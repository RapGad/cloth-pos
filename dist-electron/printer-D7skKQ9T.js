import require$$0$5 from "util";
import require$$1$2 from "stream";
import require$$0$3 from "zlib";
import require$$0$4 from "buffer";
import require$$1$3 from "string_decoder";
import require$$1$5 from "path";
import require$$0$6 from "assert";
import require$$0$a from "fs";
import require$$0$8 from "net";
import require$$0$7 from "url";
import require$$0$9 from "crypto";
import require$$2$2 from "http";
import require$$4$2 from "https";
import require$$1$4 from "querystring";
import require$$3$3 from "tls";
import require$$0$b from "events";
import require$$2$3 from "os";
import { BrowserWindow } from "electron";
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var encode_1;
var hasRequiredEncode;
function requireEncode() {
  if (hasRequiredEncode) return encode_1;
  hasRequiredEncode = 1;
  function pushBits(arr, n, value) {
    for (var bit = 1 << n - 1; bit; bit = bit >>> 1) {
      arr.push(bit & value ? 1 : 0);
    }
  }
  function encode_8bit(data2) {
    var len = data2.length;
    var bits = [];
    for (var i = 0; i < len; i++) {
      pushBits(bits, 8, data2[i]);
    }
    var res = {};
    var d = [0, 1, 0, 0];
    pushBits(d, 16, len);
    res.data10 = res.data27 = d.concat(bits);
    if (len < 256) {
      var d = [0, 1, 0, 0];
      pushBits(d, 8, len);
      res.data1 = d.concat(bits);
    }
    return res;
  }
  var ALPHANUM = (function(s) {
    var res = {};
    for (var i = 0; i < s.length; i++) {
      res[s[i]] = i;
    }
    return res;
  })("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:");
  function encode_alphanum(str) {
    var len = str.length;
    var bits = [];
    for (var i = 0; i < len; i += 2) {
      var b = 6;
      var n = ALPHANUM[str[i]];
      if (str[i + 1]) {
        b = 11;
        n = n * 45 + ALPHANUM[str[i + 1]];
      }
      pushBits(bits, b, n);
    }
    var res = {};
    var d = [0, 0, 1, 0];
    pushBits(d, 13, len);
    res.data27 = d.concat(bits);
    if (len < 2048) {
      var d = [0, 0, 1, 0];
      pushBits(d, 11, len);
      res.data10 = d.concat(bits);
    }
    if (len < 512) {
      var d = [0, 0, 1, 0];
      pushBits(d, 9, len);
      res.data1 = d.concat(bits);
    }
    return res;
  }
  function encode_numeric(str) {
    var len = str.length;
    var bits = [];
    for (var i = 0; i < len; i += 3) {
      var s = str.substr(i, 3);
      var b = Math.ceil(s.length * 10 / 3);
      pushBits(bits, b, parseInt(s, 10));
    }
    var res = {};
    var d = [0, 0, 0, 1];
    pushBits(d, 14, len);
    res.data27 = d.concat(bits);
    if (len < 4096) {
      var d = [0, 0, 0, 1];
      pushBits(d, 12, len);
      res.data10 = d.concat(bits);
    }
    if (len < 1024) {
      var d = [0, 0, 0, 1];
      pushBits(d, 10, len);
      res.data1 = d.concat(bits);
    }
    return res;
  }
  function encode_url(str) {
    var slash = str.indexOf("/", 8) + 1 || str.length;
    var res = encode(str.slice(0, slash).toUpperCase(), false);
    if (slash >= str.length) {
      return res;
    }
    var path_res = encode(str.slice(slash), false);
    res.data27 = res.data27.concat(path_res.data27);
    if (res.data10 && path_res.data10) {
      res.data10 = res.data10.concat(path_res.data10);
    }
    if (res.data1 && path_res.data1) {
      res.data1 = res.data1.concat(path_res.data1);
    }
    return res;
  }
  function encode(data2, parse_url) {
    var str;
    var t = typeof data2;
    if (t == "string" || t == "number") {
      str = "" + data2;
      data2 = new Buffer(str);
    } else if (Buffer.isBuffer(data2)) {
      str = data2.toString();
    } else if (Array.isArray(data2)) {
      data2 = new Buffer(data2);
      str = data2.toString();
    } else {
      throw new Error("Bad data");
    }
    if (/^[0-9]+$/.test(str)) {
      if (data2.length > 7089) {
        throw new Error("Too much data");
      }
      return encode_numeric(str);
    }
    if (/^[0-9A-Z \$%\*\+\.\/\:\-]+$/.test(str)) {
      if (data2.length > 4296) {
        throw new Error("Too much data");
      }
      return encode_alphanum(str);
    }
    if (parse_url && /^https?:/i.test(str)) {
      return encode_url(str);
    }
    if (data2.length > 2953) {
      throw new Error("Too much data");
    }
    return encode_8bit(data2);
  }
  encode_1 = encode;
  return encode_1;
}
var errorcode;
var hasRequiredErrorcode;
function requireErrorcode() {
  if (hasRequiredErrorcode) return errorcode;
  hasRequiredErrorcode = 1;
  var GF256_BASE = 285;
  var EXP_TABLE = [1];
  var LOG_TABLE = [];
  for (var i = 1; i < 256; i++) {
    var n = EXP_TABLE[i - 1] << 1;
    if (n > 255) n = n ^ GF256_BASE;
    EXP_TABLE[i] = n;
  }
  for (var i = 0; i < 255; i++) {
    LOG_TABLE[EXP_TABLE[i]] = i;
  }
  function exp(k) {
    while (k < 0) k += 255;
    while (k > 255) k -= 255;
    return EXP_TABLE[k];
  }
  function log(k) {
    if (k < 1 || k > 255) {
      throw Error("Bad log(" + k + ")");
    }
    return LOG_TABLE[k];
  }
  var POLYNOMIALS = [
    [0],
    // a^0 x^0
    [0, 0],
    // a^0 x^1 + a^0 x^0
    [0, 25, 1]
    // a^0 x^2 + a^25 x^1 + a^1 x^0
    // and so on...
  ];
  function generatorPolynomial(num) {
    if (POLYNOMIALS[num]) {
      return POLYNOMIALS[num];
    }
    var prev = generatorPolynomial(num - 1);
    var res = [];
    res[0] = prev[0];
    for (var i2 = 1; i2 <= num; i2++) {
      res[i2] = log(exp(prev[i2]) ^ exp(prev[i2 - 1] + num - 1));
    }
    POLYNOMIALS[num] = res;
    return res;
  }
  errorcode = function calculate_ec(msg, ec_len) {
    msg = [].slice.call(msg);
    var poly = generatorPolynomial(ec_len);
    for (var i2 = 0; i2 < ec_len; i2++) msg.push(0);
    while (msg.length > ec_len) {
      if (!msg[0]) {
        msg.shift();
        continue;
      }
      var log_k = log(msg[0]);
      for (var i2 = 0; i2 <= ec_len; i2++) {
        msg[i2] = msg[i2] ^ exp(poly[i2] + log_k);
      }
      msg.shift();
    }
    return new Buffer(msg);
  };
  return errorcode;
}
var matrix;
var hasRequiredMatrix;
function requireMatrix() {
  if (hasRequiredMatrix) return matrix;
  hasRequiredMatrix = 1;
  function init(version2) {
    var N = version2 * 4 + 17;
    var matrix2 = [];
    var zeros = new Buffer(N);
    zeros.fill(0);
    zeros = [].slice.call(zeros);
    for (var i = 0; i < N; i++) {
      matrix2[i] = zeros.slice();
    }
    return matrix2;
  }
  function fillFinders(matrix2) {
    var N = matrix2.length;
    for (var i = -3; i <= 3; i++) {
      for (var j = -3; j <= 3; j++) {
        var max = Math.max(i, j);
        var min = Math.min(i, j);
        var pixel = max == 2 && min >= -2 || min == -2 && max <= 2 ? 128 : 129;
        matrix2[3 + i][3 + j] = pixel;
        matrix2[3 + i][N - 4 + j] = pixel;
        matrix2[N - 4 + i][3 + j] = pixel;
      }
    }
    for (var i = 0; i < 8; i++) {
      matrix2[7][i] = matrix2[i][7] = matrix2[7][N - i - 1] = matrix2[i][N - 8] = matrix2[N - 8][i] = matrix2[N - 1 - i][7] = 128;
    }
  }
  function fillAlignAndTiming(matrix2) {
    var N = matrix2.length;
    if (N > 21) {
      var len = N - 13;
      var delta = Math.round(len / Math.ceil(len / 28));
      if (delta % 2) delta++;
      var res = [];
      for (var p = len + 6; p > 10; p -= delta) {
        res.unshift(p);
      }
      res.unshift(6);
      for (var i = 0; i < res.length; i++) {
        for (var j = 0; j < res.length; j++) {
          var x = res[i], y = res[j];
          if (matrix2[x][y]) continue;
          for (var r = -2; r <= 2; r++) {
            for (var c = -2; c <= 2; c++) {
              var max = Math.max(r, c);
              var min = Math.min(r, c);
              var pixel = max == 1 && min >= -1 || min == -1 && max <= 1 ? 128 : 129;
              matrix2[x + r][y + c] = pixel;
            }
          }
        }
      }
    }
    for (var i = 8; i < N - 8; i++) {
      matrix2[6][i] = matrix2[i][6] = i % 2 ? 128 : 129;
    }
  }
  function fillStub(matrix2) {
    var N = matrix2.length;
    for (var i = 0; i < 8; i++) {
      if (i != 6) {
        matrix2[8][i] = matrix2[i][8] = 128;
      }
      matrix2[8][N - 1 - i] = 128;
      matrix2[N - 1 - i][8] = 128;
    }
    matrix2[8][8] = 128;
    matrix2[N - 8][8] = 129;
    if (N < 45) return;
    for (var i = N - 11; i < N - 8; i++) {
      for (var j = 0; j < 6; j++) {
        matrix2[i][j] = matrix2[j][i] = 128;
      }
    }
  }
  var fillReserved = (function() {
    var FORMATS = Array(32);
    var VERSIONS = Array(40);
    var gf15 = 1335;
    var gf18 = 7973;
    var formats_mask = 21522;
    for (var format2 = 0; format2 < 32; format2++) {
      var res = format2 << 10;
      for (var i = 5; i > 0; i--) {
        if (res >>> 9 + i) {
          res = res ^ gf15 << i - 1;
        }
      }
      FORMATS[format2] = (res | format2 << 10) ^ formats_mask;
    }
    for (var version2 = 7; version2 <= 40; version2++) {
      var res = version2 << 12;
      for (var i = 6; i > 0; i--) {
        if (res >>> 11 + i) {
          res = res ^ gf18 << i - 1;
        }
      }
      VERSIONS[version2] = res | version2 << 12;
    }
    var EC_LEVELS = { L: 1, M: 0, Q: 3, H: 2 };
    return function fillReserved2(matrix2, ec_level, mask) {
      var N = matrix2.length;
      var format3 = FORMATS[EC_LEVELS[ec_level] << 3 | mask];
      function F(k) {
        return format3 >> k & 1 ? 129 : 128;
      }
      for (var i2 = 0; i2 < 8; i2++) {
        matrix2[8][N - 1 - i2] = F(i2);
        if (i2 < 6) matrix2[i2][8] = F(i2);
      }
      for (var i2 = 8; i2 < 15; i2++) {
        matrix2[N - 15 + i2][8] = F(i2);
        if (i2 > 8) matrix2[8][14 - i2] = F(i2);
      }
      matrix2[7][8] = F(6);
      matrix2[8][8] = F(7);
      matrix2[8][7] = F(8);
      var version3 = VERSIONS[(N - 17) / 4];
      if (!version3) return;
      function V(k) {
        return version3 >> k & 1 ? 129 : 128;
      }
      for (var i2 = 0; i2 < 6; i2++) {
        for (var j = 0; j < 3; j++) {
          matrix2[N - 11 + j][i2] = matrix2[i2][N - 11 + j] = V(i2 * 3 + j);
        }
      }
    };
  })();
  var fillData = /* @__PURE__ */ (function() {
    var MASK_FUNCTIONS = [
      function(i, j) {
        return (i + j) % 2 == 0;
      },
      function(i, j) {
        return i % 2 == 0;
      },
      function(i, j) {
        return j % 3 == 0;
      },
      function(i, j) {
        return (i + j) % 3 == 0;
      },
      function(i, j) {
        return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 == 0;
      },
      function(i, j) {
        return i * j % 2 + i * j % 3 == 0;
      },
      function(i, j) {
        return (i * j % 2 + i * j % 3) % 2 == 0;
      },
      function(i, j) {
        return (i * j % 3 + (i + j) % 2) % 2 == 0;
      }
    ];
    return function fillData2(matrix2, data2, mask) {
      var N = matrix2.length;
      var row, col, dir = -1;
      row = col = N - 1;
      var mask_fn = MASK_FUNCTIONS[mask];
      var len = data2.blocks[data2.blocks.length - 1].length;
      for (var i = 0; i < len; i++) {
        for (var b = 0; b < data2.blocks.length; b++) {
          if (data2.blocks[b].length <= i) continue;
          put(data2.blocks[b][i]);
        }
      }
      len = data2.ec_len;
      for (var i = 0; i < len; i++) {
        for (var b = 0; b < data2.ec.length; b++) {
          put(data2.ec[b][i]);
        }
      }
      if (col > -1) {
        do {
          matrix2[row][col] = mask_fn(row, col) ? 1 : 0;
        } while (next());
      }
      function put(byte) {
        for (var mask2 = 128; mask2; mask2 = mask2 >> 1) {
          var pixel = !!(mask2 & byte);
          if (mask_fn(row, col)) pixel = !pixel;
          matrix2[row][col] = pixel ? 1 : 0;
          next();
        }
      }
      function next() {
        do {
          if (col % 2 ^ col < 6) {
            if (dir < 0 && row == 0 || dir > 0 && row == N - 1) {
              col--;
              dir = -dir;
            } else {
              col++;
              row += dir;
            }
          } else {
            col--;
          }
          if (col == 6) {
            col--;
          }
          if (col < 0) {
            return false;
          }
        } while (matrix2[row][col] & 240);
        return true;
      }
    };
  })();
  function calculatePenalty(matrix2) {
    var N = matrix2.length;
    var penalty = 0;
    for (var i = 0; i < N; i++) {
      var pixel = matrix2[i][0] & 1;
      var len = 1;
      for (var j = 1; j < N; j++) {
        var p = matrix2[i][j] & 1;
        if (p == pixel) {
          len++;
          continue;
        }
        if (len >= 5) {
          penalty += len - 2;
        }
        pixel = p;
        len = 1;
      }
      if (len >= 5) {
        penalty += len - 2;
      }
    }
    for (var j = 0; j < N; j++) {
      var pixel = matrix2[0][j] & 1;
      var len = 1;
      for (var i = 1; i < N; i++) {
        var p = matrix2[i][j] & 1;
        if (p == pixel) {
          len++;
          continue;
        }
        if (len >= 5) {
          penalty += len - 2;
        }
        pixel = p;
        len = 1;
      }
      if (len >= 5) {
        penalty += len - 2;
      }
    }
    for (var i = 0; i < N - 1; i++) {
      for (var j = 0; j < N - 1; j++) {
        var s = matrix2[i][j] + matrix2[i][j + 1] + matrix2[i + 1][j] + matrix2[i + 1][j + 1] & 7;
        if (s == 0 || s == 4) {
          penalty += 3;
        }
      }
    }
    function I(k) {
      return matrix2[i][j + k] & 1;
    }
    function J(k) {
      return matrix2[i + k][j] & 1;
    }
    for (var i = 0; i < N; i++) {
      for (var j = 0; j < N; j++) {
        if (j < N - 6 && I(0) && !I(1) && I(2) && I(3) && I(4) && !I(5) && I(6)) {
          if (j >= 4 && !(I(-4) || I(-3) || I(-2) || I(-1))) {
            penalty += 40;
          }
          if (j < N - 10 && !(I(7) || I(8) || I(9) || I(10))) {
            penalty += 40;
          }
        }
        if (i < N - 6 && J(0) && !J(1) && J(2) && J(3) && J(4) && !J(5) && J(6)) {
          if (i >= 4 && !(J(-4) || J(-3) || J(-2) || J(-1))) {
            penalty += 40;
          }
          if (i < N - 10 && !(J(7) || J(8) || J(9) || J(10))) {
            penalty += 40;
          }
        }
      }
    }
    var numDark = 0;
    for (var i = 0; i < N; i++) {
      for (var j = 0; j < N; j++) {
        if (matrix2[i][j] & 1) numDark++;
      }
    }
    penalty += 10 * Math.floor(Math.abs(10 - 20 * numDark / (N * N)));
    return penalty;
  }
  function getMatrix(data2) {
    var matrix2 = init(data2.version);
    fillFinders(matrix2);
    fillAlignAndTiming(matrix2);
    fillStub(matrix2);
    var penalty = Infinity;
    var bestMask = 0;
    for (var mask = 0; mask < 8; mask++) {
      fillData(matrix2, data2, mask);
      fillReserved(matrix2, data2.ec_level, mask);
      var p = calculatePenalty(matrix2);
      if (p < penalty) {
        penalty = p;
        bestMask = mask;
      }
    }
    fillData(matrix2, data2, bestMask);
    fillReserved(matrix2, data2.ec_level, bestMask);
    return matrix2.map(function(row) {
      return row.map(function(cell) {
        return cell & 1;
      });
    });
  }
  matrix = {
    getMatrix,
    init,
    fillFinders,
    fillAlignAndTiming,
    fillStub,
    fillReserved,
    fillData,
    calculatePenalty
  };
  return matrix;
}
var qrBase;
var hasRequiredQrBase;
function requireQrBase() {
  if (hasRequiredQrBase) return qrBase;
  hasRequiredQrBase = 1;
  var encode = requireEncode();
  var calculateEC = requireErrorcode();
  var matrix2 = requireMatrix();
  function _deepCopy(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  var EC_LEVELS = ["L", "M", "Q", "H"];
  var versions = [
    [],
    // there is no version 0
    // total number of codewords, (number of ec codewords, number of blocks) * ( L, M, Q, H )
    [26, 7, 1, 10, 1, 13, 1, 17, 1],
    [44, 10, 1, 16, 1, 22, 1, 28, 1],
    [70, 15, 1, 26, 1, 36, 2, 44, 2],
    [100, 20, 1, 36, 2, 52, 2, 64, 4],
    [134, 26, 1, 48, 2, 72, 4, 88, 4],
    // 5
    [172, 36, 2, 64, 4, 96, 4, 112, 4],
    [196, 40, 2, 72, 4, 108, 6, 130, 5],
    [242, 48, 2, 88, 4, 132, 6, 156, 6],
    [292, 60, 2, 110, 5, 160, 8, 192, 8],
    [346, 72, 4, 130, 5, 192, 8, 224, 8],
    // 10
    [404, 80, 4, 150, 5, 224, 8, 264, 11],
    [466, 96, 4, 176, 8, 260, 10, 308, 11],
    [532, 104, 4, 198, 9, 288, 12, 352, 16],
    [581, 120, 4, 216, 9, 320, 16, 384, 16],
    [655, 132, 6, 240, 10, 360, 12, 432, 18],
    // 15
    [733, 144, 6, 280, 10, 408, 17, 480, 16],
    [815, 168, 6, 308, 11, 448, 16, 532, 19],
    [901, 180, 6, 338, 13, 504, 18, 588, 21],
    [991, 196, 7, 364, 14, 546, 21, 650, 25],
    [1085, 224, 8, 416, 16, 600, 20, 700, 25],
    // 20
    [1156, 224, 8, 442, 17, 644, 23, 750, 25],
    [1258, 252, 9, 476, 17, 690, 23, 816, 34],
    [1364, 270, 9, 504, 18, 750, 25, 900, 30],
    [1474, 300, 10, 560, 20, 810, 27, 960, 32],
    [1588, 312, 12, 588, 21, 870, 29, 1050, 35],
    // 25
    [1706, 336, 12, 644, 23, 952, 34, 1110, 37],
    [1828, 360, 12, 700, 25, 1020, 34, 1200, 40],
    [1921, 390, 13, 728, 26, 1050, 35, 1260, 42],
    [2051, 420, 14, 784, 28, 1140, 38, 1350, 45],
    [2185, 450, 15, 812, 29, 1200, 40, 1440, 48],
    // 30
    [2323, 480, 16, 868, 31, 1290, 43, 1530, 51],
    [2465, 510, 17, 924, 33, 1350, 45, 1620, 54],
    [2611, 540, 18, 980, 35, 1440, 48, 1710, 57],
    [2761, 570, 19, 1036, 37, 1530, 51, 1800, 60],
    [2876, 570, 19, 1064, 38, 1590, 53, 1890, 63],
    // 35
    [3034, 600, 20, 1120, 40, 1680, 56, 1980, 66],
    [3196, 630, 21, 1204, 43, 1770, 59, 2100, 70],
    [3362, 660, 22, 1260, 45, 1860, 62, 2220, 74],
    [3532, 720, 24, 1316, 47, 1950, 65, 2310, 77],
    [3706, 750, 25, 1372, 49, 2040, 68, 2430, 81]
    // 40
  ];
  versions = versions.map(function(v, index) {
    if (!index) return {};
    var res = {};
    for (var i = 1; i < 8; i += 2) {
      var length = v[0] - v[i];
      var num_template = v[i + 1];
      var ec_level = EC_LEVELS[i / 2 | 0];
      var level = {
        version: index,
        ec_level,
        data_len: length,
        ec_len: v[i] / num_template,
        blocks: [],
        ec: []
      };
      for (var k = num_template, n = length; k > 0; k--) {
        var block = n / k | 0;
        level.blocks.push(block);
        n -= block;
      }
      res[ec_level] = level;
    }
    return res;
  });
  function getTemplate(message, ec_level) {
    var i = 1;
    var len;
    if (message.data1) {
      len = Math.ceil(message.data1.length / 8);
    } else {
      i = 10;
    }
    for (; i < 10; i++) {
      var version2 = versions[i][ec_level];
      if (version2.data_len >= len) {
        return _deepCopy(version2);
      }
    }
    if (message.data10) {
      len = Math.ceil(message.data10.length / 8);
    } else {
      i = 27;
    }
    for (; i < 27; i++) {
      var version2 = versions[i][ec_level];
      if (version2.data_len >= len) {
        return _deepCopy(version2);
      }
    }
    len = Math.ceil(message.data27.length / 8);
    for (; i < 41; i++) {
      var version2 = versions[i][ec_level];
      if (version2.data_len >= len) {
        return _deepCopy(version2);
      }
    }
    throw new Error("Too much data");
  }
  function fillTemplate(message, template) {
    var blocks = new Buffer(template.data_len);
    blocks.fill(0);
    if (template.version < 10) {
      message = message.data1;
    } else if (template.version < 27) {
      message = message.data10;
    } else {
      message = message.data27;
    }
    var len = message.length;
    for (var i = 0; i < len; i += 8) {
      var b = 0;
      for (var j = 0; j < 8; j++) {
        b = b << 1 | (message[i + j] ? 1 : 0);
      }
      blocks[i / 8] = b;
    }
    var pad = 236;
    for (var i = Math.ceil((len + 4) / 8); i < blocks.length; i++) {
      blocks[i] = pad;
      pad = pad == 236 ? 17 : 236;
    }
    var offset = 0;
    template.blocks = template.blocks.map(function(n) {
      var b2 = blocks.slice(offset, offset + n);
      offset += n;
      template.ec.push(calculateEC(b2, template.ec_len));
      return b2;
    });
    return template;
  }
  function QR(text, ec_level, parse_url) {
    ec_level = EC_LEVELS.indexOf(ec_level) > -1 ? ec_level : "M";
    var message = encode(text, parse_url);
    var data2 = fillTemplate(message, getTemplate(message, ec_level));
    return matrix2.getMatrix(data2);
  }
  qrBase = {
    QR,
    getTemplate,
    fillTemplate
  };
  return qrBase;
}
var crc32 = { exports: {} };
var crc32buffer;
var hasRequiredCrc32buffer;
function requireCrc32buffer() {
  if (hasRequiredCrc32buffer) return crc32buffer;
  hasRequiredCrc32buffer = 1;
  var crc_table = [];
  for (var n = 0; n < 256; n++) {
    var c = crc_table[n] = new Buffer(4);
    c.writeUInt32BE(n, 0);
    for (var k = 0; k < 8; k++) {
      var b0 = c[0] & 1;
      var b1 = c[1] & 1;
      var b2 = c[2] & 1;
      var b3 = c[3] & 1;
      c[0] = c[0] >> 1 ^ (b3 ? 237 : 0);
      c[1] = c[1] >> 1 ^ (b3 ? 184 : 0) ^ (b0 ? 128 : 0);
      c[2] = c[2] >> 1 ^ (b3 ? 131 : 0) ^ (b1 ? 128 : 0);
      c[3] = c[3] >> 1 ^ (b3 ? 32 : 0) ^ (b2 ? 128 : 0);
    }
  }
  function update(c2, buf) {
    var l = buf.length;
    for (var n2 = 0; n2 < l; n2++) {
      var e = crc_table[c2[3] ^ buf[n2]];
      c2[3] = e[3] ^ c2[2];
      c2[2] = e[2] ^ c2[1];
      c2[1] = e[1] ^ c2[0];
      c2[0] = e[0];
    }
  }
  function crc322() {
    var l = arguments.length;
    var c2 = new Buffer(4);
    c2.fill(255);
    for (var i = 0; i < l; i++) {
      update(c2, new Buffer(arguments[i]));
    }
    c2[0] = c2[0] ^ 255;
    c2[1] = c2[1] ^ 255;
    c2[2] = c2[2] ^ 255;
    c2[3] = c2[3] ^ 255;
    return c2.readUInt32BE(0);
  }
  crc32buffer = crc322;
  return crc32buffer;
}
var hasRequiredCrc32;
function requireCrc32() {
  if (hasRequiredCrc32) return crc32.exports;
  hasRequiredCrc32 = 1;
  (function() {
    if (process.arch === "arm") {
      crc32.exports = requireCrc32buffer();
      return;
    }
    var crc_table = [];
    (function() {
      for (var n = 0; n < 256; n++) {
        var c = n;
        for (var k = 0; k < 8; k++) {
          if (c & 1) {
            c = 3988292384 ^ c >>> 1;
          } else {
            c = c >>> 1;
          }
        }
        crc_table[n] = c >>> 0;
      }
    })();
    function update(c, buf) {
      var l = buf.length;
      for (var n = 0; n < l; n++) {
        c = crc_table[(c ^ buf[n]) & 255] ^ c >>> 8;
      }
      return c;
    }
    function crc32$1() {
      var l = arguments.length;
      var c = -1;
      for (var i = 0; i < l; i++) {
        c = update(c, new Buffer(arguments[i]));
      }
      c = (c ^ -1) >>> 0;
      return c;
    }
    crc32.exports = crc32$1;
  })();
  return crc32.exports;
}
var png_1;
var hasRequiredPng$1;
function requirePng$1() {
  if (hasRequiredPng$1) return png_1;
  hasRequiredPng$1 = 1;
  var zlib = require$$0$3;
  var crc322 = requireCrc32();
  var PNG_HEAD = new Buffer([137, 80, 78, 71, 13, 10, 26, 10]);
  var PNG_IHDR = new Buffer([0, 0, 0, 13, 73, 72, 68, 82, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0]);
  var PNG_IDAT = new Buffer([0, 0, 0, 0, 73, 68, 65, 84]);
  var PNG_IEND = new Buffer([0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130]);
  function png2(bitmap3, stream) {
    stream.push(PNG_HEAD);
    var IHDR = Buffer.concat([PNG_IHDR]);
    IHDR.writeUInt32BE(bitmap3.size, 8);
    IHDR.writeUInt32BE(bitmap3.size, 12);
    IHDR.writeUInt32BE(crc322(IHDR.slice(4, -4)), 21);
    stream.push(IHDR);
    var IDAT = Buffer.concat([
      PNG_IDAT,
      zlib.deflateSync(bitmap3.data, { level: 9 }),
      new Buffer(4)
    ]);
    IDAT.writeUInt32BE(IDAT.length - 12, 0);
    IDAT.writeUInt32BE(crc322(IDAT.slice(4, -4)), IDAT.length - 4);
    stream.push(IDAT);
    stream.push(PNG_IEND);
    stream.push(null);
  }
  function bitmap2(matrix2, size, margin) {
    var N = matrix2.length;
    var X = (N + 2 * margin) * size;
    var data2 = new Buffer((X + 1) * X);
    data2.fill(255);
    for (var i = 0; i < X; i++) {
      data2[i * (X + 1)] = 0;
    }
    for (var i = 0; i < N; i++) {
      for (var j = 0; j < N; j++) {
        if (matrix2[i][j]) {
          var offset = ((margin + i) * (X + 1) + (margin + j)) * size + 1;
          data2.fill(0, offset, offset + size);
          for (var c = 1; c < size; c++) {
            data2.copy(data2, offset + c * (X + 1), offset, offset + size);
          }
        }
      }
    }
    return {
      data: data2,
      size: X
    };
  }
  png_1 = {
    bitmap: bitmap2,
    png: png2
  };
  return png_1;
}
var vector;
var hasRequiredVector;
function requireVector() {
  if (hasRequiredVector) return vector;
  hasRequiredVector = 1;
  function matrix2path(matrix2) {
    var N = matrix2.length;
    var filled = [];
    for (var row = -1; row <= N; row++) {
      filled[row] = [];
    }
    var path = [];
    for (var row = 0; row < N; row++) {
      for (var col = 0; col < N; col++) {
        if (filled[row][col]) continue;
        filled[row][col] = 1;
        if (isDark(row, col)) {
          if (!isDark(row - 1, col)) {
            path.push(plot(row, col, "right"));
          }
        } else {
          if (isDark(row, col - 1)) {
            path.push(plot(row, col, "down"));
          }
        }
      }
    }
    return path;
    function isDark(row2, col2) {
      if (row2 < 0 || col2 < 0 || row2 >= N || col2 >= N) return false;
      return !!matrix2[row2][col2];
    }
    function plot(row0, col0, dir) {
      filled[row0][col0] = 1;
      var res = [];
      res.push(["M", col0, row0]);
      var row2 = row0;
      var col2 = col0;
      var len = 0;
      do {
        switch (dir) {
          case "right":
            filled[row2][col2] = 1;
            if (isDark(row2, col2)) {
              filled[row2 - 1][col2] = 1;
              if (isDark(row2 - 1, col2)) {
                res.push(["h", len]);
                len = 0;
                dir = "up";
              } else {
                len++;
                col2++;
              }
            } else {
              res.push(["h", len]);
              len = 0;
              dir = "down";
            }
            break;
          case "left":
            filled[row2 - 1][col2 - 1] = 1;
            if (isDark(row2 - 1, col2 - 1)) {
              filled[row2][col2 - 1] = 1;
              if (isDark(row2, col2 - 1)) {
                res.push(["h", -len]);
                len = 0;
                dir = "down";
              } else {
                len++;
                col2--;
              }
            } else {
              res.push(["h", -len]);
              len = 0;
              dir = "up";
            }
            break;
          case "down":
            filled[row2][col2 - 1] = 1;
            if (isDark(row2, col2 - 1)) {
              filled[row2][col2] = 1;
              if (isDark(row2, col2)) {
                res.push(["v", len]);
                len = 0;
                dir = "right";
              } else {
                len++;
                row2++;
              }
            } else {
              res.push(["v", len]);
              len = 0;
              dir = "left";
            }
            break;
          case "up":
            filled[row2 - 1][col2] = 1;
            if (isDark(row2 - 1, col2)) {
              filled[row2 - 1][col2 - 1] = 1;
              if (isDark(row2 - 1, col2 - 1)) {
                res.push(["v", -len]);
                len = 0;
                dir = "left";
              } else {
                len++;
                row2--;
              }
            } else {
              res.push(["v", -len]);
              len = 0;
              dir = "right";
            }
            break;
        }
      } while (row2 != row0 || col2 != col0);
      return res;
    }
  }
  function pushSVGPath(matrix2, stream, margin) {
    matrix2path(matrix2).forEach(function(subpath) {
      var res = "";
      for (var k = 0; k < subpath.length; k++) {
        var item = subpath[k];
        switch (item[0]) {
          case "M":
            res += "M" + (item[1] + margin) + " " + (item[2] + margin);
            break;
          default:
            res += item.join("");
        }
      }
      res += "z";
      stream.push(res);
    });
  }
  function SVG_object(matrix2, margin) {
    var stream = [];
    pushSVGPath(matrix2, stream, margin);
    var result = {
      size: matrix2.length + 2 * margin,
      path: stream.filter(Boolean).join("")
    };
    return result;
  }
  function SVG(matrix2, stream, margin, size) {
    var X = matrix2.length + 2 * margin;
    stream.push('<svg xmlns="http://www.w3.org/2000/svg" ');
    if (size > 0) {
      var XY = X * size;
      stream.push('width="' + XY + '" height="' + XY + '" ');
    }
    stream.push('viewBox="0 0 ' + X + " " + X + '">');
    stream.push('<path d="');
    pushSVGPath(matrix2, stream, margin);
    stream.push('"/></svg>');
    stream.push(null);
  }
  function EPS(matrix2, stream, margin) {
    var N = matrix2.length;
    var scale = 9;
    var X = (N + 2 * margin) * scale;
    stream.push([
      "%!PS-Adobe-3.0 EPSF-3.0",
      "%%BoundingBox: 0 0 " + X + " " + X,
      "/h { 0 rlineto } bind def",
      "/v { 0 exch neg rlineto } bind def",
      "/M { neg " + (N + margin) + " add moveto } bind def",
      "/z { closepath } bind def",
      scale + " " + scale + " scale",
      ""
    ].join("\n"));
    matrix2path(matrix2).forEach(function(subpath) {
      var res = "";
      for (var k = 0; k < subpath.length; k++) {
        var item = subpath[k];
        switch (item[0]) {
          case "M":
            res += item[1] + margin + " " + item[2] + " M ";
            break;
          default:
            res += item[1] + " " + item[0] + " ";
        }
      }
      res += "z\n";
      stream.push(res);
    });
    stream.push("fill\n%%EOF\n");
    stream.push(null);
  }
  function PDF(matrix2, stream, margin) {
    var N = matrix2.length;
    var scale = 9;
    var X = (N + 2 * margin) * scale;
    var data2 = [
      "%PDF-1.0\n\n",
      "1 0 obj << /Type /Catalog /Pages 2 0 R >> endobj\n",
      "2 0 obj << /Type /Pages /Count 1 /Kids [ 3 0 R ] >> endobj\n"
    ];
    data2.push("3 0 obj << /Type /Page /Parent 2 0 R /Resources <<>> /Contents 4 0 R /MediaBox [ 0 0 " + X + " " + X + " ] >> endobj\n");
    var path = scale + " 0 0 " + scale + " 0 0 cm\n";
    path += matrix2path(matrix2).map(function(subpath) {
      var res = "";
      var x, y;
      for (var k = 0; k < subpath.length; k++) {
        var item = subpath[k];
        switch (item[0]) {
          case "M":
            x = item[1] + margin;
            y = N - item[2] + margin;
            res += x + " " + y + " m ";
            break;
          case "h":
            x += item[1];
            res += x + " " + y + " l ";
            break;
          case "v":
            y -= item[1];
            res += x + " " + y + " l ";
            break;
        }
      }
      res += "h";
      return res;
    }).join("\n");
    path += "\nf\n";
    data2.push("4 0 obj << /Length " + path.length + " >> stream\n" + path + "endstream\nendobj\n");
    var xref = "xref\n0 5\n0000000000 65535 f \n";
    for (var i = 1, l = data2[0].length; i < 5; i++) {
      xref += ("0000000000" + l).substr(-10) + " 00000 n \n";
      l += data2[i].length;
    }
    data2.push(
      xref,
      "trailer << /Root 1 0 R /Size 5 >>\n",
      "startxref\n" + l + "\n%%EOF\n"
    );
    stream.push(data2.join(""));
    stream.push(null);
  }
  vector = {
    svg: SVG,
    eps: EPS,
    pdf: PDF,
    svg_object: SVG_object
  };
  return vector;
}
var qr;
var hasRequiredQr;
function requireQr() {
  if (hasRequiredQr) return qr;
  hasRequiredQr = 1;
  var Readable = require$$1$2.Readable;
  var QR = requireQrBase().QR;
  var png2 = requirePng$1();
  var vector2 = requireVector();
  var fn_noop = function() {
  };
  var BITMAP_OPTIONS = {
    parse_url: false,
    ec_level: "M",
    size: 5,
    margin: 4,
    customize: null
  };
  var VECTOR_OPTIONS = {
    parse_url: false,
    ec_level: "M",
    margin: 1,
    size: 0
  };
  function get_options(options, force_type) {
    if (typeof options === "string") {
      options = { "ec_level": options };
    } else {
      options = options || {};
    }
    var _options = {
      type: String(force_type || options.type || "png").toLowerCase()
    };
    var defaults = _options.type == "png" ? BITMAP_OPTIONS : VECTOR_OPTIONS;
    for (var k in defaults) {
      _options[k] = k in options ? options[k] : defaults[k];
    }
    return _options;
  }
  function qr_image(text, options) {
    options = get_options(options);
    var matrix2 = QR(text, options.ec_level, options.parse_url);
    var stream = new Readable();
    stream._read = fn_noop;
    switch (options.type) {
      case "svg":
      case "pdf":
      case "eps":
        process.nextTick(function() {
          vector2[options.type](matrix2, stream, options.margin, options.size);
        });
        break;
      case "svgpath":
        process.nextTick(function() {
          var obj = vector2.svg_object(matrix2, options.margin, options.size);
          stream.push(obj.path);
          stream.push(null);
        });
        break;
      case "png":
      default:
        process.nextTick(function() {
          var bitmap2 = png2.bitmap(matrix2, options.size, options.margin);
          if (options.customize) {
            options.customize(bitmap2);
          }
          png2.png(bitmap2, stream);
        });
    }
    return stream;
  }
  function qr_image_sync(text, options) {
    options = get_options(options);
    var matrix2 = QR(text, options.ec_level, options.parse_url);
    var stream = [];
    var result;
    switch (options.type) {
      case "svg":
      case "pdf":
      case "eps":
        vector2[options.type](matrix2, stream, options.margin, options.size);
        result = stream.filter(Boolean).join("");
        break;
      case "png":
      default:
        var bitmap2 = png2.bitmap(matrix2, options.size, options.margin);
        if (options.customize) {
          options.customize(bitmap2);
        }
        png2.png(bitmap2, stream);
        result = Buffer.concat(stream.filter(Boolean));
    }
    return result;
  }
  function svg_object(text, options) {
    options = get_options(options, "svg");
    var matrix2 = QR(text, options.ec_level);
    return vector2.svg_object(matrix2, options.margin);
  }
  qr = {
    matrix: QR,
    image: qr_image,
    imageSync: qr_image_sync,
    svgObject: svg_object
  };
  return qr;
}
var lib$5 = { exports: {} };
var safer_1;
var hasRequiredSafer;
function requireSafer() {
  if (hasRequiredSafer) return safer_1;
  hasRequiredSafer = 1;
  var buffer = require$$0$4;
  var Buffer2 = buffer.Buffer;
  var safer = {};
  var key2;
  for (key2 in buffer) {
    if (!buffer.hasOwnProperty(key2)) continue;
    if (key2 === "SlowBuffer" || key2 === "Buffer") continue;
    safer[key2] = buffer[key2];
  }
  var Safer = safer.Buffer = {};
  for (key2 in Buffer2) {
    if (!Buffer2.hasOwnProperty(key2)) continue;
    if (key2 === "allocUnsafe" || key2 === "allocUnsafeSlow") continue;
    Safer[key2] = Buffer2[key2];
  }
  safer.Buffer.prototype = Buffer2.prototype;
  if (!Safer.from || Safer.from === Uint8Array.from) {
    Safer.from = function(value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
      }
      if (value && typeof value.length === "undefined") {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      return Buffer2(value, encodingOrOffset, length);
    };
  }
  if (!Safer.alloc) {
    Safer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
      }
      if (size < 0 || size >= 2 * (1 << 30)) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
      var buf = Buffer2(size);
      if (!fill || fill.length === 0) {
        buf.fill(0);
      } else if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
      return buf;
    };
  }
  if (!safer.kStringMaxLength) {
    try {
      safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch (e) {
    }
  }
  if (!safer.constants) {
    safer.constants = {
      MAX_LENGTH: safer.kMaxLength
    };
    if (safer.kStringMaxLength) {
      safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
    }
  }
  safer_1 = safer;
  return safer_1;
}
var bomHandling = {};
var hasRequiredBomHandling;
function requireBomHandling() {
  if (hasRequiredBomHandling) return bomHandling;
  hasRequiredBomHandling = 1;
  var BOMChar = "\uFEFF";
  bomHandling.PrependBOM = PrependBOMWrapper;
  function PrependBOMWrapper(encoder2, options) {
    this.encoder = encoder2;
    this.addBOM = true;
  }
  PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
      str = BOMChar + str;
      this.addBOM = false;
    }
    return this.encoder.write(str);
  };
  PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
  };
  bomHandling.StripBOM = StripBOMWrapper;
  function StripBOMWrapper(decoder2, options) {
    this.decoder = decoder2;
    this.pass = false;
    this.options = options || {};
  }
  StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res)
      return res;
    if (res[0] === BOMChar) {
      res = res.slice(1);
      if (typeof this.options.stripBOM === "function")
        this.options.stripBOM();
    }
    this.pass = true;
    return res;
  };
  StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
  };
  return bomHandling;
}
var encodings = {};
var internal;
var hasRequiredInternal;
function requireInternal() {
  if (hasRequiredInternal) return internal;
  hasRequiredInternal = 1;
  var Buffer2 = requireSafer().Buffer;
  internal = {
    // Encodings
    utf8: { type: "_internal", bomAware: true },
    cesu8: { type: "_internal", bomAware: true },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: true },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    // Codec.
    _internal: InternalCodec
  };
  function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64")
      this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
      this.enc = "utf8";
      this.encoder = InternalEncoderCesu8;
      if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "ðŸ’©") {
        this.decoder = InternalDecoderCesu8;
        this.defaultCharUnicode = iconv.defaultCharUnicode;
      }
    }
  }
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;
  var StringDecoder = require$$1$3.StringDecoder;
  if (!StringDecoder.prototype.end)
    StringDecoder.prototype.end = function() {
    };
  function InternalDecoder(options, codec) {
    this.decoder = new StringDecoder(codec.enc);
  }
  InternalDecoder.prototype.write = function(buf) {
    if (!Buffer2.isBuffer(buf)) {
      buf = Buffer2.from(buf);
    }
    return this.decoder.write(buf);
  };
  InternalDecoder.prototype.end = function() {
    return this.decoder.end();
  };
  function InternalEncoder(options, codec) {
    this.enc = codec.enc;
  }
  InternalEncoder.prototype.write = function(str) {
    return Buffer2.from(str, this.enc);
  };
  InternalEncoder.prototype.end = function() {
  };
  function InternalEncoderBase64(options, codec) {
    this.prevStr = "";
  }
  InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - str.length % 4;
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);
    return Buffer2.from(str, "base64");
  };
  InternalEncoderBase64.prototype.end = function() {
    return Buffer2.from(this.prevStr, "base64");
  };
  function InternalEncoderCesu8(options, codec) {
  }
  InternalEncoderCesu8.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length * 3), bufIdx = 0;
    for (var i = 0; i < str.length; i++) {
      var charCode = str.charCodeAt(i);
      if (charCode < 128)
        buf[bufIdx++] = charCode;
      else if (charCode < 2048) {
        buf[bufIdx++] = 192 + (charCode >>> 6);
        buf[bufIdx++] = 128 + (charCode & 63);
      } else {
        buf[bufIdx++] = 224 + (charCode >>> 12);
        buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
        buf[bufIdx++] = 128 + (charCode & 63);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function() {
  };
  function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
    for (var i = 0; i < buf.length; i++) {
      var curByte = buf[i];
      if ((curByte & 192) !== 128) {
        if (contBytes > 0) {
          res += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 128) {
          res += String.fromCharCode(curByte);
        } else if (curByte < 224) {
          acc = curByte & 31;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 240) {
          acc = curByte & 15;
          contBytes = 2;
          accBytes = 1;
        } else {
          res += this.defaultCharUnicode;
        }
      } else {
        if (contBytes > 0) {
          acc = acc << 6 | curByte & 63;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            if (accBytes === 2 && acc < 128 && acc > 0)
              res += this.defaultCharUnicode;
            else if (accBytes === 3 && acc < 2048)
              res += this.defaultCharUnicode;
            else
              res += String.fromCharCode(acc);
          }
        } else {
          res += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res;
  };
  InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0)
      res += this.defaultCharUnicode;
    return res;
  };
  return internal;
}
var utf32 = {};
var hasRequiredUtf32;
function requireUtf32() {
  if (hasRequiredUtf32) return utf32;
  hasRequiredUtf32 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf32._utf32 = Utf32Codec;
  function Utf32Codec(codecOptions, iconv) {
    this.iconv = iconv;
    this.bomAware = true;
    this.isLE = codecOptions.isLE;
  }
  utf32.utf32le = { type: "_utf32", isLE: true };
  utf32.utf32be = { type: "_utf32", isLE: false };
  utf32.ucs4le = "utf32le";
  utf32.ucs4be = "utf32be";
  Utf32Codec.prototype.encoder = Utf32Encoder;
  Utf32Codec.prototype.decoder = Utf32Decoder;
  function Utf32Encoder(options, codec) {
    this.isLE = codec.isLE;
    this.highSurrogate = 0;
  }
  Utf32Encoder.prototype.write = function(str) {
    var src = Buffer2.from(str, "ucs2");
    var dst = Buffer2.alloc(src.length * 2);
    var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
    var offset = 0;
    for (var i = 0; i < src.length; i += 2) {
      var code = src.readUInt16LE(i);
      var isHighSurrogate = 55296 <= code && code < 56320;
      var isLowSurrogate = 56320 <= code && code < 57344;
      if (this.highSurrogate) {
        if (isHighSurrogate || !isLowSurrogate) {
          write32.call(dst, this.highSurrogate, offset);
          offset += 4;
        } else {
          var codepoint = (this.highSurrogate - 55296 << 10 | code - 56320) + 65536;
          write32.call(dst, codepoint, offset);
          offset += 4;
          this.highSurrogate = 0;
          continue;
        }
      }
      if (isHighSurrogate)
        this.highSurrogate = code;
      else {
        write32.call(dst, code, offset);
        offset += 4;
        this.highSurrogate = 0;
      }
    }
    if (offset < dst.length)
      dst = dst.slice(0, offset);
    return dst;
  };
  Utf32Encoder.prototype.end = function() {
    if (!this.highSurrogate)
      return;
    var buf = Buffer2.alloc(4);
    if (this.isLE)
      buf.writeUInt32LE(this.highSurrogate, 0);
    else
      buf.writeUInt32BE(this.highSurrogate, 0);
    this.highSurrogate = 0;
    return buf;
  };
  function Utf32Decoder(options, codec) {
    this.isLE = codec.isLE;
    this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
    this.overflow = [];
  }
  Utf32Decoder.prototype.write = function(src) {
    if (src.length === 0)
      return "";
    var i = 0;
    var codepoint = 0;
    var dst = Buffer2.alloc(src.length + 4);
    var offset = 0;
    var isLE = this.isLE;
    var overflow = this.overflow;
    var badChar = this.badChar;
    if (overflow.length > 0) {
      for (; i < src.length && overflow.length < 4; i++)
        overflow.push(src[i]);
      if (overflow.length === 4) {
        if (isLE) {
          codepoint = overflow[i] | overflow[i + 1] << 8 | overflow[i + 2] << 16 | overflow[i + 3] << 24;
        } else {
          codepoint = overflow[i + 3] | overflow[i + 2] << 8 | overflow[i + 1] << 16 | overflow[i] << 24;
        }
        overflow.length = 0;
        offset = _writeCodepoint(dst, offset, codepoint, badChar);
      }
    }
    for (; i < src.length - 3; i += 4) {
      if (isLE) {
        codepoint = src[i] | src[i + 1] << 8 | src[i + 2] << 16 | src[i + 3] << 24;
      } else {
        codepoint = src[i + 3] | src[i + 2] << 8 | src[i + 1] << 16 | src[i] << 24;
      }
      offset = _writeCodepoint(dst, offset, codepoint, badChar);
    }
    for (; i < src.length; i++) {
      overflow.push(src[i]);
    }
    return dst.slice(0, offset).toString("ucs2");
  };
  function _writeCodepoint(dst, offset, codepoint, badChar) {
    if (codepoint < 0 || codepoint > 1114111) {
      codepoint = badChar;
    }
    if (codepoint >= 65536) {
      codepoint -= 65536;
      var high = 55296 | codepoint >> 10;
      dst[offset++] = high & 255;
      dst[offset++] = high >> 8;
      var codepoint = 56320 | codepoint & 1023;
    }
    dst[offset++] = codepoint & 255;
    dst[offset++] = codepoint >> 8;
    return offset;
  }
  Utf32Decoder.prototype.end = function() {
    this.overflow.length = 0;
  };
  utf32.utf32 = Utf32AutoCodec;
  utf32.ucs4 = "utf32";
  function Utf32AutoCodec(options, iconv) {
    this.iconv = iconv;
  }
  Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
  Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
  function Utf32AutoEncoder(options, codec) {
    options = options || {};
    if (options.addBOM === void 0)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder(options.defaultEncoding || "utf-32le", options);
  }
  Utf32AutoEncoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf32AutoEncoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf32AutoDecoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf32AutoDecoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 32)
        return "";
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf32AutoDecoder.prototype.end = function() {
    if (!this.decoder) {
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      var trail = this.decoder.end();
      if (trail)
        resStr += trail;
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var invalidLE = 0, invalidBE = 0;
    var bmpCharsLE = 0, bmpCharsBE = 0;
    outer_loop:
      for (var i = 0; i < bufs.length; i++) {
        var buf = bufs[i];
        for (var j = 0; j < buf.length; j++) {
          b.push(buf[j]);
          if (b.length === 4) {
            if (charsProcessed === 0) {
              if (b[0] === 255 && b[1] === 254 && b[2] === 0 && b[3] === 0) {
                return "utf-32le";
              }
              if (b[0] === 0 && b[1] === 0 && b[2] === 254 && b[3] === 255) {
                return "utf-32be";
              }
            }
            if (b[0] !== 0 || b[1] > 16) invalidBE++;
            if (b[3] !== 0 || b[2] > 16) invalidLE++;
            if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++;
            if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0) bmpCharsLE++;
            b.length = 0;
            charsProcessed++;
            if (charsProcessed >= 100) {
              break outer_loop;
            }
          }
        }
      }
    if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE) return "utf-32be";
    if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE) return "utf-32le";
    return defaultEncoding || "utf-32le";
  }
  return utf32;
}
var utf16 = {};
var hasRequiredUtf16;
function requireUtf16() {
  if (hasRequiredUtf16) return utf16;
  hasRequiredUtf16 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf16.utf16be = Utf16BECodec;
  function Utf16BECodec() {
  }
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;
  function Utf16BEEncoder() {
  }
  Utf16BEEncoder.prototype.write = function(str) {
    var buf = Buffer2.from(str, "ucs2");
    for (var i = 0; i < buf.length; i += 2) {
      var tmp = buf[i];
      buf[i] = buf[i + 1];
      buf[i + 1] = tmp;
    }
    return buf;
  };
  Utf16BEEncoder.prototype.end = function() {
  };
  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
  Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
      return "";
    var buf2 = Buffer2.alloc(buf.length + 1), i = 0, j = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i = 1;
      j = 2;
    }
    for (; i < buf.length - 1; i += 2, j += 2) {
      buf2[j] = buf[i + 1];
      buf2[j + 1] = buf[i];
    }
    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j).toString("ucs2");
  };
  Utf16BEDecoder.prototype.end = function() {
    this.overflowByte = -1;
  };
  utf16.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder;
  Utf16Codec.prototype.decoder = Utf16Decoder;
  function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === void 0)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder("utf-16le", options);
  }
  Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 16)
        return "";
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      var trail = this.decoder.end();
      if (trail)
        resStr += trail;
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var asciiCharsLE = 0, asciiCharsBE = 0;
    outer_loop:
      for (var i = 0; i < bufs.length; i++) {
        var buf = bufs[i];
        for (var j = 0; j < buf.length; j++) {
          b.push(buf[j]);
          if (b.length === 2) {
            if (charsProcessed === 0) {
              if (b[0] === 255 && b[1] === 254) return "utf-16le";
              if (b[0] === 254 && b[1] === 255) return "utf-16be";
            }
            if (b[0] === 0 && b[1] !== 0) asciiCharsBE++;
            if (b[0] !== 0 && b[1] === 0) asciiCharsLE++;
            b.length = 0;
            charsProcessed++;
            if (charsProcessed >= 100) {
              break outer_loop;
            }
          }
        }
      }
    if (asciiCharsBE > asciiCharsLE) return "utf-16be";
    if (asciiCharsBE < asciiCharsLE) return "utf-16le";
    return defaultEncoding || "utf-16le";
  }
  return utf16;
}
var utf7 = {};
var hasRequiredUtf7;
function requireUtf7() {
  if (hasRequiredUtf7) return utf7;
  hasRequiredUtf7 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf7.utf7 = Utf7Codec;
  utf7.unicode11utf7 = "utf7";
  function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder;
  Utf7Codec.prototype.decoder = Utf7Decoder;
  Utf7Codec.prototype.bomAware = true;
  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
  }
  Utf7Encoder.prototype.write = function(str) {
    return Buffer2.from(str.replace(nonDirectChars, (function(chunk) {
      return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }).bind(this)));
  };
  Utf7Encoder.prototype.end = function() {
  };
  function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64Regex = /[A-Za-z0-9\/+]/;
  var base64Chars = [];
  for (var i = 0; i < 256; i++)
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));
  var plusChar = "+".charCodeAt(0), minusChar = "-".charCodeAt(0), andChar = "&".charCodeAt(0);
  Utf7Decoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == plusChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64Chars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "+";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  utf7.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  Utf7IMAPCodec.prototype.bomAware = true;
  function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer2.alloc(6);
    this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str.length * 5 + 10), bufIdx = 0;
    for (var i2 = 0; i2 < str.length; i2++) {
      var uChar = str.charCodeAt(i2);
      if (32 <= uChar && uChar <= 126) {
        if (inBase64) {
          if (base64AccumIdx > 0) {
            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
            base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar;
          inBase64 = false;
        }
        if (!inBase64) {
          buf[bufIdx++] = uChar;
          if (uChar === andChar)
            buf[bufIdx++] = minusChar;
        }
      } else {
        if (!inBase64) {
          buf[bufIdx++] = andChar;
          inBase64 = true;
        }
        if (inBase64) {
          base64Accum[base64AccumIdx++] = uChar >> 8;
          base64Accum[base64AccumIdx++] = uChar & 255;
          if (base64AccumIdx == base64Accum.length) {
            bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
            base64AccumIdx = 0;
          }
        }
      }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
  };
  Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer2.alloc(10), bufIdx = 0;
    if (this.inBase64) {
      if (this.base64AccumIdx > 0) {
        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
        this.base64AccumIdx = 0;
      }
      buf[bufIdx++] = minusChar;
      this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
  };
  function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64IMAPChars = base64Chars.slice();
  base64IMAPChars[",".charCodeAt(0)] = true;
  Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == andChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64IMAPChars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "&";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii").replace(/,/g, "/");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  return utf7;
}
var sbcsCodec = {};
var hasRequiredSbcsCodec;
function requireSbcsCodec() {
  if (hasRequiredSbcsCodec) return sbcsCodec;
  hasRequiredSbcsCodec = 1;
  var Buffer2 = requireSafer().Buffer;
  sbcsCodec._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
      throw new Error("SBCS codec is called without the data.");
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
      throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (codecOptions.chars.length === 128) {
      var asciiString = "";
      for (var i = 0; i < 128; i++)
        asciiString += String.fromCharCode(i);
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
    var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
    for (var i = 0; i < codecOptions.chars.length; i++)
      encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
    this.encodeBuf = encodeBuf;
  }
  SBCSCodec.prototype.encoder = SBCSEncoder;
  SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
  }
  SBCSEncoder.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length);
    for (var i = 0; i < str.length; i++)
      buf[i] = this.encodeBuf[str.charCodeAt(i)];
    return buf;
  };
  SBCSEncoder.prototype.end = function() {
  };
  function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
  }
  SBCSDecoder.prototype.write = function(buf) {
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer2.alloc(buf.length * 2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
      idx1 = buf[i] * 2;
      idx2 = i * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString("ucs2");
  };
  SBCSDecoder.prototype.end = function() {
  };
  return sbcsCodec;
}
var sbcsData;
var hasRequiredSbcsData;
function requireSbcsData() {
  if (hasRequiredSbcsData) return sbcsData;
  hasRequiredSbcsData = 1;
  sbcsData = {
    // Not supported by iconv, not sure why.
    "10029": "maccenteuro",
    "maccenteuro": {
      "type": "_sbcs",
      "chars": "Ã„Ä€ÄÃ‰Ä„Ã–ÃœÃ¡Ä…ÄŒÃ¤ÄÄ†Ä‡Ã©Å¹ÅºÄŽÃ­ÄÄ’Ä“Ä–Ã³Ä—Ã´Ã¶ÃµÃºÄšÄ›Ã¼â€ Â°Ä˜Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Ä™Â¨â‰ Ä£Ä®Ä¯Äªâ‰¤â‰¥Ä«Ä¶âˆ‚âˆ‘Å‚Ä»Ä¼Ä½Ä¾Ä¹ÄºÅ…Å†ÅƒÂ¬âˆšÅ„Å‡âˆ†Â«Â»â€¦Â ÅˆÅÃ•Å‘ÅŒâ€“â€”â€œâ€â€˜â€™Ã·â—ŠÅÅ”Å•Å˜â€¹â€ºÅ™Å–Å—Å â€šâ€žÅ¡ÅšÅ›ÃÅ¤Å¥ÃÅ½Å¾ÅªÃ“Ã”Å«Å®ÃšÅ¯Å°Å±Å²Å³ÃÃ½Ä·Å»ÅÅ¼Ä¢Ë‡"
    },
    "808": "cp808",
    "ibm808": "cp808",
    "cp808": {
      "type": "_sbcs",
      "chars": "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑÐÑ‘Ð„Ñ”Ð‡Ñ—ÐŽÑžÂ°âˆ™Â·âˆšâ„–â‚¬â– Â "
    },
    "mik": {
      "type": "_sbcs",
      "chars": "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑâ””â”´â”¬â”œâ”€â”¼â•£â•‘â•šâ•”â•©â•¦â• â•â•¬â”â–‘â–’â–“â”‚â”¤â„–Â§â•—â•â”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    "cp720": {
      "type": "_sbcs",
      "chars": "Â€ÂÃ©Ã¢Â„Ã Â†Ã§ÃªÃ«Ã¨Ã¯Ã®ÂÂŽÂÂÙ‘Ù’Ã´Â¤Ù€Ã»Ã¹Ø¡Ø¢Ø£Ø¤Â£Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµÂ«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ø¶Ø·Ø¸Ø¹ØºÙÂµÙ‚ÙƒÙ„Ù…Ù†Ù‡ÙˆÙ‰ÙŠâ‰¡Ù‹ÙŒÙÙŽÙÙâ‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    // Aliases of generated encodings.
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",
    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",
    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek": "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",
    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",
    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",
    "cp819": "iso88591",
    "ibm819": "iso88591",
    "cyrillic": "iso88595",
    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",
    "greek": "iso88597",
    "greek8": "iso88597",
    "ecma118": "iso88597",
    "elot928": "iso88597",
    "hebrew": "iso88598",
    "hebrew8": "iso88598",
    "turkish": "iso88599",
    "turkish8": "iso88599",
    "thai": "iso885911",
    "thai8": "iso885911",
    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",
    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",
    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",
    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",
    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",
    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",
    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",
    "strk10482002": "rk1048",
    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",
    "gb198880": "iso646cn",
    "cn": "iso646cn",
    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",
    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",
    "mac": "macintosh",
    "csmacintosh": "macintosh"
  };
  return sbcsData;
}
var sbcsDataGenerated;
var hasRequiredSbcsDataGenerated;
function requireSbcsDataGenerated() {
  if (hasRequiredSbcsDataGenerated) return sbcsDataGenerated;
  hasRequiredSbcsDataGenerated = 1;
  sbcsDataGenerated = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    "windows874": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½ï¿½ï¿½ï¿½â€¦ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Â à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›ï¿½ï¿½ï¿½ï¿½"
    },
    "win874": "windows874",
    "cp874": "windows874",
    "windows1250": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½â€šï¿½â€žâ€¦â€ â€¡ï¿½â€°Å â€¹ÅšÅ¤Å½Å¹ï¿½â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢Å¡â€ºÅ›Å¥Å¾ÅºÂ Ë‡Ë˜ÅÂ¤Ä„Â¦Â§Â¨Â©ÅžÂ«Â¬Â­Â®Å»Â°Â±Ë›Å‚Â´ÂµÂ¶Â·Â¸Ä…ÅŸÂ»Ä½ËÄ¾Å¼Å”ÃÃ‚Ä‚Ã„Ä¹Ä†Ã‡ÄŒÃ‰Ä˜Ã‹ÄšÃÃŽÄŽÄÅƒÅ‡Ã“Ã”ÅÃ–Ã—Å˜Å®ÃšÅ°ÃœÃÅ¢ÃŸÅ•Ã¡Ã¢ÄƒÃ¤ÄºÄ‡Ã§ÄÃ©Ä™Ã«Ä›Ã­Ã®ÄÄ‘Å„ÅˆÃ³Ã´Å‘Ã¶Ã·Å™Å¯ÃºÅ±Ã¼Ã½Å£Ë™"
    },
    "win1250": "windows1250",
    "cp1250": "windows1250",
    "windows1251": {
      "type": "_sbcs",
      "chars": "Ð‚Ðƒâ€šÑ“â€žâ€¦â€ â€¡â‚¬â€°Ð‰â€¹ÐŠÐŒÐ‹ÐÑ’â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢Ñ™â€ºÑšÑœÑ›ÑŸÂ ÐŽÑžÐˆÂ¤ÒÂ¦Â§ÐÂ©Ð„Â«Â¬Â­Â®Ð‡Â°Â±Ð†Ñ–Ò‘ÂµÂ¶Â·Ñ‘â„–Ñ”Â»Ñ˜Ð…Ñ•Ñ—ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑ"
    },
    "win1251": "windows1251",
    "cp1251": "windows1251",
    "windows1252": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡Ë†â€°Å â€¹Å’ï¿½Å½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢Å¡â€ºÅ“ï¿½Å¾Å¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÃÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÃžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    "win1252": "windows1252",
    "cp1252": "windows1252",
    "windows1253": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡ï¿½â€°ï¿½â€¹ï¿½ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢ï¿½â€ºï¿½ï¿½ï¿½ï¿½Â Î…Î†Â£Â¤Â¥Â¦Â§Â¨Â©ï¿½Â«Â¬Â­Â®â€•Â°Â±Â²Â³Î„ÂµÂ¶Â·ÎˆÎ‰ÎŠÂ»ÎŒÂ½ÎŽÎÎÎ‘Î’Î“Î”Î•Î–Î—Î˜Î™ÎšÎ›ÎœÎÎžÎŸÎ Î¡ï¿½Î£Î¤Î¥Î¦Î§Î¨Î©ÎªÎ«Î¬Î­Î®Î¯Î°Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏ‚ÏƒÏ„Ï…Ï†Ï‡ÏˆÏ‰ÏŠÏ‹ÏŒÏÏŽï¿½"
    },
    "win1253": "windows1253",
    "cp1253": "windows1253",
    "windows1254": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡Ë†â€°Å â€¹Å’ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢Å¡â€ºÅ“ï¿½ï¿½Å¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÄžÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÄ°ÅžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ÄŸÃ±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ä±ÅŸÃ¿"
    },
    "win1254": "windows1254",
    "cp1254": "windows1254",
    "windows1255": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡Ë†â€°ï¿½â€¹ï¿½ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢ï¿½â€ºï¿½ï¿½ï¿½ï¿½Â Â¡Â¢Â£â‚ªÂ¥Â¦Â§Â¨Â©Ã—Â«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹Ã·Â»Â¼Â½Â¾Â¿Ö°Ö±Ö²Ö³Ö´ÖµÖ¶Ö·Ö¸Ö¹ÖºÖ»Ö¼Ö½Ö¾Ö¿×€××‚×ƒ×°×±×²×³×´ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½××‘×’×“×”×•×–×—×˜×™×š×›×œ××ž×Ÿ× ×¡×¢×£×¤×¥×¦×§×¨×©×ªï¿½ï¿½â€Žâ€ï¿½"
    },
    "win1255": "windows1255",
    "cp1255": "windows1255",
    "windows1256": {
      "type": "_sbcs",
      "chars": "â‚¬Ù¾â€šÆ’â€žâ€¦â€ â€¡Ë†â€°Ù¹â€¹Å’Ú†Ú˜ÚˆÚ¯â€˜â€™â€œâ€â€¢â€“â€”Ú©â„¢Ú‘â€ºÅ“â€Œâ€ÚºÂ ØŒÂ¢Â£Â¤Â¥Â¦Â§Â¨Â©Ú¾Â«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹Ø›Â»Â¼Â½Â¾ØŸÛØ¡Ø¢Ø£Ø¤Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ã—Ø·Ø¸Ø¹ØºÙ€ÙÙ‚ÙƒÃ Ù„Ã¢Ù…Ù†Ù‡ÙˆÃ§Ã¨Ã©ÃªÃ«Ù‰ÙŠÃ®Ã¯Ù‹ÙŒÙÙŽÃ´ÙÙÃ·Ù‘Ã¹Ù’Ã»Ã¼â€Žâ€Û’"
    },
    "win1256": "windows1256",
    "cp1256": "windows1256",
    "windows1257": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½â€šï¿½â€žâ€¦â€ â€¡ï¿½â€°ï¿½â€¹ï¿½Â¨Ë‡Â¸ï¿½â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢ï¿½â€ºï¿½Â¯Ë›ï¿½Â ï¿½Â¢Â£Â¤ï¿½Â¦Â§Ã˜Â©Å–Â«Â¬Â­Â®Ã†Â°Â±Â²Â³Â´ÂµÂ¶Â·Ã¸Â¹Å—Â»Â¼Â½Â¾Ã¦Ä„Ä®Ä€Ä†Ã„Ã…Ä˜Ä’ÄŒÃ‰Å¹Ä–Ä¢Ä¶ÄªÄ»Å ÅƒÅ…Ã“ÅŒÃ•Ã–Ã—Å²ÅÅšÅªÃœÅ»Å½ÃŸÄ…Ä¯ÄÄ‡Ã¤Ã¥Ä™Ä“ÄÃ©ÅºÄ—Ä£Ä·Ä«Ä¼Å¡Å„Å†Ã³ÅÃµÃ¶Ã·Å³Å‚Å›Å«Ã¼Å¼Å¾Ë™"
    },
    "win1257": "windows1257",
    "cp1257": "windows1257",
    "windows1258": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡Ë†â€°ï¿½â€¹Å’ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢ï¿½â€ºÅ“ï¿½ï¿½Å¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚Ä‚Ã„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹Ì€ÃÃŽÃÄÃ‘Ì‰Ã“Ã”Æ Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÆ¯ÌƒÃŸÃ Ã¡Ã¢ÄƒÃ¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«ÌÃ­Ã®Ã¯Ä‘Ã±Ì£Ã³Ã´Æ¡Ã¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Æ°â‚«Ã¿"
    },
    "win1258": "windows1258",
    "cp1258": "windows1258",
    "iso88591": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÃÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÃžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    "cp28591": "iso88591",
    "iso88592": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ä„Ë˜ÅÂ¤Ä½ÅšÂ§Â¨Å ÅžÅ¤Å¹Â­Å½Å»Â°Ä…Ë›Å‚Â´Ä¾Å›Ë‡Â¸Å¡ÅŸÅ¥ÅºËÅ¾Å¼Å”ÃÃ‚Ä‚Ã„Ä¹Ä†Ã‡ÄŒÃ‰Ä˜Ã‹ÄšÃÃŽÄŽÄÅƒÅ‡Ã“Ã”ÅÃ–Ã—Å˜Å®ÃšÅ°ÃœÃÅ¢ÃŸÅ•Ã¡Ã¢ÄƒÃ¤ÄºÄ‡Ã§ÄÃ©Ä™Ã«Ä›Ã­Ã®ÄÄ‘Å„ÅˆÃ³Ã´Å‘Ã¶Ã·Å™Å¯ÃºÅ±Ã¼Ã½Å£Ë™"
    },
    "cp28592": "iso88592",
    "iso88593": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ä¦Ë˜Â£Â¤ï¿½Ä¤Â§Â¨Ä°ÅžÄžÄ´Â­ï¿½Å»Â°Ä§Â²Â³Â´ÂµÄ¥Â·Â¸Ä±ÅŸÄŸÄµÂ½ï¿½Å¼Ã€ÃÃ‚ï¿½Ã„ÄŠÄˆÃ‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃï¿½Ã‘Ã’Ã“Ã”Ä Ã–Ã—ÄœÃ™ÃšÃ›ÃœÅ¬ÅœÃŸÃ Ã¡Ã¢ï¿½Ã¤Ä‹Ä‰Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ï¿½Ã±Ã²Ã³Ã´Ä¡Ã¶Ã·ÄÃ¹ÃºÃ»Ã¼Å­ÅË™"
    },
    "cp28593": "iso88593",
    "iso88594": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ä„Ä¸Å–Â¤Ä¨Ä»Â§Â¨Å Ä’Ä¢Å¦Â­Å½Â¯Â°Ä…Ë›Å—Â´Ä©Ä¼Ë‡Â¸Å¡Ä“Ä£Å§ÅŠÅ¾Å‹Ä€ÃÃ‚ÃƒÃ„Ã…Ã†Ä®ÄŒÃ‰Ä˜Ã‹Ä–ÃÃŽÄªÄÅ…ÅŒÄ¶Ã”Ã•Ã–Ã—Ã˜Å²ÃšÃ›ÃœÅ¨ÅªÃŸÄÃ¡Ã¢Ã£Ã¤Ã¥Ã¦Ä¯ÄÃ©Ä™Ã«Ä—Ã­Ã®Ä«Ä‘Å†ÅÄ·Ã´ÃµÃ¶Ã·Ã¸Å³ÃºÃ»Ã¼Å©Å«Ë™"
    },
    "cp28594": "iso88594",
    "iso88595": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ ÐÐ‚ÐƒÐ„Ð…Ð†Ð‡ÐˆÐ‰ÐŠÐ‹ÐŒÂ­ÐŽÐÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑâ„–Ñ‘Ñ’Ñ“Ñ”Ñ•Ñ–Ñ—Ñ˜Ñ™ÑšÑ›ÑœÂ§ÑžÑŸ"
    },
    "cp28595": "iso88595",
    "iso88596": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ ï¿½ï¿½ï¿½Â¤ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ØŒÂ­ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ø›ï¿½ï¿½ï¿½ØŸï¿½Ø¡Ø¢Ø£Ø¤Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ø·Ø¸Ø¹Øºï¿½ï¿½ï¿½ï¿½ï¿½Ù€ÙÙ‚ÙƒÙ„Ù…Ù†Ù‡ÙˆÙ‰ÙŠÙ‹ÙŒÙÙŽÙÙÙ‘Ù’ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
    },
    "cp28596": "iso88596",
    "iso88597": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ â€˜â€™Â£â‚¬â‚¯Â¦Â§Â¨Â©ÍºÂ«Â¬Â­ï¿½â€•Â°Â±Â²Â³Î„Î…Î†Â·ÎˆÎ‰ÎŠÂ»ÎŒÂ½ÎŽÎÎÎ‘Î’Î“Î”Î•Î–Î—Î˜Î™ÎšÎ›ÎœÎÎžÎŸÎ Î¡ï¿½Î£Î¤Î¥Î¦Î§Î¨Î©ÎªÎ«Î¬Î­Î®Î¯Î°Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏ‚ÏƒÏ„Ï…Ï†Ï‡ÏˆÏ‰ÏŠÏ‹ÏŒÏÏŽï¿½"
    },
    "cp28597": "iso88597",
    "iso88598": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ ï¿½Â¢Â£Â¤Â¥Â¦Â§Â¨Â©Ã—Â«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹Ã·Â»Â¼Â½Â¾ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â€—××‘×’×“×”×•×–×—×˜×™×š×›×œ××ž×Ÿ× ×¡×¢×£×¤×¥×¦×§×¨×©×ªï¿½ï¿½â€Žâ€ï¿½"
    },
    "cp28598": "iso88598",
    "iso88599": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÄžÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÄ°ÅžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ÄŸÃ±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ä±ÅŸÃ¿"
    },
    "cp28599": "iso88599",
    "iso885910": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ä„Ä’Ä¢ÄªÄ¨Ä¶Â§Ä»ÄÅ Å¦Å½Â­ÅªÅŠÂ°Ä…Ä“Ä£Ä«Ä©Ä·Â·Ä¼Ä‘Å¡Å§Å¾â€•Å«Å‹Ä€ÃÃ‚ÃƒÃ„Ã…Ã†Ä®ÄŒÃ‰Ä˜Ã‹Ä–ÃÃŽÃÃÅ…ÅŒÃ“Ã”Ã•Ã–Å¨Ã˜Å²ÃšÃ›ÃœÃÃžÃŸÄÃ¡Ã¢Ã£Ã¤Ã¥Ã¦Ä¯ÄÃ©Ä™Ã«Ä—Ã­Ã®Ã¯Ã°Å†ÅÃ³Ã´ÃµÃ¶Å©Ã¸Å³ÃºÃ»Ã¼Ã½Ã¾Ä¸"
    },
    "cp28600": "iso885910",
    "iso885911": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›ï¿½ï¿½ï¿½ï¿½"
    },
    "cp28601": "iso885911",
    "iso885913": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ â€Â¢Â£Â¤â€žÂ¦Â§Ã˜Â©Å–Â«Â¬Â­Â®Ã†Â°Â±Â²Â³â€œÂµÂ¶Â·Ã¸Â¹Å—Â»Â¼Â½Â¾Ã¦Ä„Ä®Ä€Ä†Ã„Ã…Ä˜Ä’ÄŒÃ‰Å¹Ä–Ä¢Ä¶ÄªÄ»Å ÅƒÅ…Ã“ÅŒÃ•Ã–Ã—Å²ÅÅšÅªÃœÅ»Å½ÃŸÄ…Ä¯ÄÄ‡Ã¤Ã¥Ä™Ä“ÄÃ©ÅºÄ—Ä£Ä·Ä«Ä¼Å¡Å„Å†Ã³ÅÃµÃ¶Ã·Å³Å‚Å›Å«Ã¼Å¼Å¾â€™"
    },
    "cp28603": "iso885913",
    "iso885914": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ á¸‚á¸ƒÂ£ÄŠÄ‹á¸ŠÂ§áº€Â©áº‚á¸‹á»²Â­Â®Å¸á¸žá¸ŸÄ Ä¡á¹€á¹Â¶á¹–áºá¹—áºƒá¹ á»³áº„áº…á¹¡Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÅ´Ã‘Ã’Ã“Ã”Ã•Ã–á¹ªÃ˜Ã™ÃšÃ›ÃœÃÅ¶ÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ÅµÃ±Ã²Ã³Ã´ÃµÃ¶á¹«Ã¸Ã¹ÃºÃ»Ã¼Ã½Å·Ã¿"
    },
    "cp28604": "iso885914",
    "iso885915": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£â‚¬Â¥Å Â§Å¡Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Å½ÂµÂ¶Â·Å¾Â¹ÂºÂ»Å’Å“Å¸Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÃÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÃžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    "cp28605": "iso885915",
    "iso885916": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ä„Ä…Åâ‚¬â€žÅ Â§Å¡Â©È˜Â«Å¹Â­ÅºÅ»Â°Â±ÄŒÅ‚Å½â€Â¶Â·Å¾ÄÈ™Â»Å’Å“Å¸Å¼Ã€ÃÃ‚Ä‚Ã„Ä†Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÄÅƒÃ’Ã“Ã”ÅÃ–ÅšÅ°Ã™ÃšÃ›ÃœÄ˜ÈšÃŸÃ Ã¡Ã¢ÄƒÃ¤Ä‡Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ä‘Å„Ã²Ã³Ã´Å‘Ã¶Å›Å±Ã¹ÃºÃ»Ã¼Ä™È›Ã¿"
    },
    "cp28606": "iso885916",
    "cp437": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÂ¢Â£Â¥â‚§Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿âŒÂ¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    "ibm437": "cp437",
    "csibm437": "cp437",
    "cp737": {
      "type": "_sbcs",
      "chars": "Î‘Î’Î“Î”Î•Î–Î—Î˜Î™ÎšÎ›ÎœÎÎžÎŸÎ Î¡Î£Î¤Î¥Î¦Î§Î¨Î©Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏƒÏ‚Ï„Ï…Ï†Ï‡Ïˆâ–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ï‰Î¬Î­Î®ÏŠÎ¯ÏŒÏÏ‹ÏŽÎ†ÎˆÎ‰ÎŠÎŒÎŽÎÂ±â‰¥â‰¤ÎªÎ«Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    "ibm737": "cp737",
    "csibm737": "cp737",
    "cp775": {
      "type": "_sbcs",
      "chars": "Ä†Ã¼Ã©ÄÃ¤Ä£Ã¥Ä‡Å‚Ä“Å–Å—Ä«Å¹Ã„Ã…Ã‰Ã¦Ã†ÅÃ¶Ä¢Â¢ÅšÅ›Ã–ÃœÃ¸Â£Ã˜Ã—Â¤Ä€ÄªÃ³Å»Å¼Åºâ€Â¦Â©Â®Â¬Â½Â¼ÅÂ«Â»â–‘â–’â–“â”‚â”¤Ä„ÄŒÄ˜Ä–â•£â•‘â•—â•Ä®Å â”â””â”´â”¬â”œâ”€â”¼Å²Åªâ•šâ•”â•©â•¦â• â•â•¬Å½Ä…ÄÄ™Ä—Ä¯Å¡Å³Å«Å¾â”˜â”Œâ–ˆâ–„â–Œâ–â–€Ã“ÃŸÅŒÅƒÃµÃ•ÂµÅ„Ä¶Ä·Ä»Ä¼Å†Ä’Å…â€™Â­Â±â€œÂ¾Â¶Â§Ã·â€žÂ°âˆ™Â·Â¹Â³Â²â– Â "
    },
    "ibm775": "cp775",
    "csibm775": "cp775",
    "cp850": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÃ¸Â£Ã˜Ã—Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿Â®Â¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤ÃÃ‚Ã€Â©â•£â•‘â•—â•Â¢Â¥â”â””â”´â”¬â”œâ”€â”¼Ã£Ãƒâ•šâ•”â•©â•¦â• â•â•¬Â¤Ã°ÃÃŠÃ‹ÃˆÄ±ÃÃŽÃâ”˜â”Œâ–ˆâ–„Â¦ÃŒâ–€Ã“ÃŸÃ”Ã’ÃµÃ•ÂµÃ¾ÃžÃšÃ›Ã™Ã½ÃÂ¯Â´Â­Â±â€—Â¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â– Â "
    },
    "ibm850": "cp850",
    "csibm850": "cp850",
    "cp852": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã¤Å¯Ä‡Ã§Å‚Ã«ÅÅ‘Ã®Å¹Ã„Ä†Ã‰Ä¹ÄºÃ´Ã¶Ä½Ä¾ÅšÅ›Ã–ÃœÅ¤Å¥ÅÃ—ÄÃ¡Ã­Ã³ÃºÄ„Ä…Å½Å¾Ä˜Ä™Â¬ÅºÄŒÅŸÂ«Â»â–‘â–’â–“â”‚â”¤ÃÃ‚ÄšÅžâ•£â•‘â•—â•Å»Å¼â”â””â”´â”¬â”œâ”€â”¼Ä‚Äƒâ•šâ•”â•©â•¦â• â•â•¬Â¤Ä‘ÄÄŽÃ‹ÄÅ‡ÃÃŽÄ›â”˜â”Œâ–ˆâ–„Å¢Å®â–€Ã“ÃŸÃ”ÅƒÅ„ÅˆÅ Å¡Å”ÃšÅ•Å°Ã½ÃÅ£Â´Â­ËË›Ë‡Ë˜Â§Ã·Â¸Â°Â¨Ë™Å±Å˜Å™â– Â "
    },
    "ibm852": "cp852",
    "csibm852": "cp852",
    "cp855": {
      "type": "_sbcs",
      "chars": "Ñ’Ð‚Ñ“ÐƒÑ‘ÐÑ”Ð„Ñ•Ð…Ñ–Ð†Ñ—Ð‡Ñ˜ÐˆÑ™Ð‰ÑšÐŠÑ›Ð‹ÑœÐŒÑžÐŽÑŸÐÑŽÐ®ÑŠÐªÐ°ÐÐ±Ð‘Ñ†Ð¦Ð´Ð”ÐµÐ•Ñ„Ð¤Ð³Ð“Â«Â»â–‘â–’â–“â”‚â”¤Ñ…Ð¥Ð¸Ð˜â•£â•‘â•—â•Ð¹Ð™â”â””â”´â”¬â”œâ”€â”¼ÐºÐšâ•šâ•”â•©â•¦â• â•â•¬Â¤Ð»Ð›Ð¼ÐœÐ½ÐÐ¾ÐžÐ¿â”˜â”Œâ–ˆâ–„ÐŸÑâ–€Ð¯Ñ€Ð ÑÐ¡Ñ‚Ð¢ÑƒÐ£Ð¶Ð–Ð²Ð’ÑŒÐ¬â„–Â­Ñ‹Ð«Ð·Ð—ÑˆÐ¨ÑÐ­Ñ‰Ð©Ñ‡Ð§Â§â– Â "
    },
    "ibm855": "cp855",
    "csibm855": "cp855",
    "cp856": {
      "type": "_sbcs",
      "chars": "××‘×’×“×”×•×–×—×˜×™×š×›×œ××ž×Ÿ× ×¡×¢×£×¤×¥×¦×§×¨×©×ªï¿½Â£ï¿½Ã—ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Â®Â¬Â½Â¼ï¿½Â«Â»â–‘â–’â–“â”‚â”¤ï¿½ï¿½ï¿½Â©â•£â•‘â•—â•Â¢Â¥â”â””â”´â”¬â”œâ”€â”¼ï¿½ï¿½â•šâ•”â•©â•¦â• â•â•¬Â¤ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â”˜â”Œâ–ˆâ–„Â¦ï¿½â–€ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Âµï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Â¯Â´Â­Â±â€—Â¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â– Â "
    },
    "ibm856": "cp856",
    "csibm856": "cp856",
    "cp857": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ä±Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ä°Ã–ÃœÃ¸Â£Ã˜ÅžÅŸÃ¡Ã­Ã³ÃºÃ±Ã‘ÄžÄŸÂ¿Â®Â¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤ÃÃ‚Ã€Â©â•£â•‘â•—â•Â¢Â¥â”â””â”´â”¬â”œâ”€â”¼Ã£Ãƒâ•šâ•”â•©â•¦â• â•â•¬Â¤ÂºÂªÃŠÃ‹Ãˆï¿½ÃÃŽÃâ”˜â”Œâ–ˆâ–„Â¦ÃŒâ–€Ã“ÃŸÃ”Ã’ÃµÃ•Âµï¿½Ã—ÃšÃ›Ã™Ã¬Ã¿Â¯Â´Â­Â±ï¿½Â¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â– Â "
    },
    "ibm857": "cp857",
    "csibm857": "cp857",
    "cp858": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÃ¸Â£Ã˜Ã—Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿Â®Â¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤ÃÃ‚Ã€Â©â•£â•‘â•—â•Â¢Â¥â”â””â”´â”¬â”œâ”€â”¼Ã£Ãƒâ•šâ•”â•©â•¦â• â•â•¬Â¤Ã°ÃÃŠÃ‹Ãˆâ‚¬ÃÃŽÃâ”˜â”Œâ–ˆâ–„Â¦ÃŒâ–€Ã“ÃŸÃ”Ã’ÃµÃ•ÂµÃ¾ÃžÃšÃ›Ã™Ã½ÃÂ¯Â´Â­Â±â€—Â¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â– Â "
    },
    "ibm858": "cp858",
    "csibm858": "cp858",
    "cp860": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã£Ã ÃÃ§ÃªÃŠÃ¨ÃÃ”Ã¬ÃƒÃ‚Ã‰Ã€ÃˆÃ´ÃµÃ²ÃšÃ¹ÃŒÃ•ÃœÂ¢Â£Ã™â‚§Ã“Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿Ã’Â¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    "ibm860": "cp860",
    "csibm860": "cp860",
    "cp861": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨ÃÃ°ÃžÃ„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã¾Ã»ÃÃ½Ã–ÃœÃ¸Â£Ã˜â‚§Æ’Ã¡Ã­Ã³ÃºÃÃÃ“ÃšÂ¿âŒÂ¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    "ibm861": "cp861",
    "csibm861": "cp861",
    "cp862": {
      "type": "_sbcs",
      "chars": "××‘×’×“×”×•×–×—×˜×™×š×›×œ××ž×Ÿ× ×¡×¢×£×¤×¥×¦×§×¨×©×ªÂ¢Â£Â¥â‚§Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿âŒÂ¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    "ibm862": "cp862",
    "csibm862": "cp862",
    "cp863": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã‚Ã Â¶Ã§ÃªÃ«Ã¨Ã¯Ã®â€—Ã€Â§Ã‰ÃˆÃŠÃ´Ã‹ÃÃ»Ã¹Â¤Ã”ÃœÂ¢Â£Ã™Ã›Æ’Â¦Â´Ã³ÃºÂ¨Â¸Â³Â¯ÃŽâŒÂ¬Â½Â¼Â¾Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    "ibm863": "cp863",
    "csibm863": "cp863",
    "cp864": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$Ùª&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~Â°Â·âˆ™âˆšâ–’â”€â”‚â”¼â”¤â”¬â”œâ”´â”â”Œâ””â”˜Î²âˆžÏ†Â±Â½Â¼â‰ˆÂ«Â»ï»·ï»¸ï¿½ï¿½ï»»ï»¼ï¿½Â Â­ïº‚Â£Â¤ïº„ï¿½ï¿½ïºŽïºïº•ïº™ØŒïºïº¡ïº¥Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©ï»‘Ø›ïº±ïºµïº¹ØŸÂ¢ïº€ïºïºƒïº…ï»Šïº‹ïºïº‘ïº“ïº—ïº›ïºŸïº£ïº§ïº©ïº«ïº­ïº¯ïº³ïº·ïº»ïº¿ï»ï»…ï»‹ï»Â¦Â¬Ã·Ã—ï»‰Ù€ï»“ï»—ï»›ï»Ÿï»£ï»§ï»«ï»­ï»¯ï»³ïº½ï»Œï»Žï»ï»¡ï¹½Ù‘ï»¥ï»©ï»¬ï»°ï»²ï»ï»•ï»µï»¶ï»ï»™ï»±â– ï¿½"
    },
    "ibm864": "cp864",
    "csibm864": "cp864",
    "cp865": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÃ¸Â£Ã˜â‚§Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿âŒÂ¬Â½Â¼Â¡Â«Â¤â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    "ibm865": "cp865",
    "csibm865": "cp865",
    "cp866": {
      "type": "_sbcs",
      "chars": "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑÐÑ‘Ð„Ñ”Ð‡Ñ—ÐŽÑžÂ°âˆ™Â·âˆšâ„–Â¤â– Â "
    },
    "ibm866": "cp866",
    "csibm866": "cp866",
    "cp869": {
      "type": "_sbcs",
      "chars": "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Î†ï¿½Â·Â¬Â¦â€˜â€™Îˆâ€•Î‰ÎŠÎªÎŒï¿½ï¿½ÎŽÎ«Â©ÎÂ²Â³Î¬Â£Î­Î®Î¯ÏŠÎÏŒÏÎ‘Î’Î“Î”Î•Î–Î—Â½Î˜Î™Â«Â»â–‘â–’â–“â”‚â”¤ÎšÎ›ÎœÎâ•£â•‘â•—â•ÎžÎŸâ”â””â”´â”¬â”œâ”€â”¼Î Î¡â•šâ•”â•©â•¦â• â•â•¬Î£Î¤Î¥Î¦Î§Î¨Î©Î±Î²Î³â”˜â”Œâ–ˆâ–„Î´Îµâ–€Î¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏƒÏ‚Ï„Î„Â­Â±Ï…Ï†Ï‡Â§ÏˆÎ…Â°Â¨Ï‰Ï‹Î°ÏŽâ– Â "
    },
    "ibm869": "cp869",
    "csibm869": "cp869",
    "cp922": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®â€¾Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÅ Ã‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÅ½ÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Å¡Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Å¾Ã¿"
    },
    "ibm922": "cp922",
    "csibm922": "cp922",
    "cp1046": {
      "type": "_sbcs",
      "chars": "ïºˆÃ—Ã·ï£¶ï£µï£´ï£·ï¹±Âˆâ– â”‚â”€â”â”Œâ””â”˜ï¹¹ï¹»ï¹½ï¹¿ï¹·ïºŠï»°ï»³ï»²ï»Žï»ï»ï»¶ï»¸ï»ºï»¼Â ï£ºï£¹ï£¸Â¤ï£»ïº‹ïº‘ïº—ïº›ïºŸïº£ØŒÂ­ïº§ïº³Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©ïº·Ø›ïº»ïº¿ï»ŠØŸï»‹Ø¡Ø¢Ø£Ø¤Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ø·ï»‡Ø¹Øºï»Œïº‚ïº„ïºŽï»“Ù€ÙÙ‚ÙƒÙ„Ù…Ù†Ù‡ÙˆÙ‰ÙŠÙ‹ÙŒÙÙŽÙÙÙ‘Ù’ï»—ï»›ï»Ÿï£¼ï»µï»·ï»¹ï»»ï»£ï»§ï»¬ï»©ï¿½"
    },
    "ibm1046": "cp1046",
    "csibm1046": "cp1046",
    "cp1124": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ ÐÐ‚ÒÐ„Ð…Ð†Ð‡ÐˆÐ‰ÐŠÐ‹ÐŒÂ­ÐŽÐÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑâ„–Ñ‘Ñ’Ò‘Ñ”Ñ•Ñ–Ñ—Ñ˜Ñ™ÑšÑ›ÑœÂ§ÑžÑŸ"
    },
    "ibm1124": "cp1124",
    "csibm1124": "cp1124",
    "cp1125": {
      "type": "_sbcs",
      "chars": "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑÐÑ‘ÒÒ‘Ð„Ñ”Ð†Ñ–Ð‡Ñ—Â·âˆšâ„–Â¤â– Â "
    },
    "ibm1125": "cp1125",
    "csibm1125": "cp1125",
    "cp1129": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£Â¤Â¥Â¦Â§Å“Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Å¸ÂµÂ¶Â·Å’Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚Ä‚Ã„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹Ì€ÃÃŽÃÄÃ‘Ì‰Ã“Ã”Æ Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÆ¯ÌƒÃŸÃ Ã¡Ã¢ÄƒÃ¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«ÌÃ­Ã®Ã¯Ä‘Ã±Ì£Ã³Ã´Æ¡Ã¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Æ°â‚«Ã¿"
    },
    "ibm1129": "cp1129",
    "csibm1129": "cp1129",
    "cp1133": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ àºàº‚àº„àº‡àºˆàºªàºŠàºàº”àº•àº–àº—àº™àºšàº›àºœàºàºžàºŸàº¡àº¢àº£àº¥àº§àº«àº­àº®ï¿½ï¿½ï¿½àº¯àº°àº²àº³àº´àºµàº¶àº·àº¸àº¹àº¼àº±àº»àº½ï¿½ï¿½ï¿½à»€à»à»‚à»ƒà»„à»ˆà»‰à»Šà»‹à»Œà»à»†ï¿½à»œà»â‚­ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½à»à»‘à»’à»“à»”à»•à»–à»—à»˜à»™ï¿½ï¿½Â¢Â¬Â¦ï¿½"
    },
    "ibm1133": "cp1133",
    "csibm1133": "cp1133",
    "cp1161": {
      "type": "_sbcs",
      "chars": "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½à¹ˆà¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºà¹‰à¹Šà¹‹â‚¬à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›Â¢Â¬Â¦Â "
    },
    "ibm1161": "cp1161",
    "csibm1161": "cp1161",
    "cp1162": {
      "type": "_sbcs",
      "chars": "â‚¬ÂÂ‚ÂƒÂ„â€¦Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂâ€˜â€™â€œâ€â€¢â€“â€”Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›ï¿½ï¿½ï¿½ï¿½"
    },
    "ibm1162": "cp1162",
    "csibm1162": "cp1162",
    "cp1163": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£â‚¬Â¥Â¦Â§Å“Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Å¸ÂµÂ¶Â·Å’Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚Ä‚Ã„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹Ì€ÃÃŽÃÄÃ‘Ì‰Ã“Ã”Æ Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÆ¯ÌƒÃŸÃ Ã¡Ã¢ÄƒÃ¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«ÌÃ­Ã®Ã¯Ä‘Ã±Ì£Ã³Ã´Æ¡Ã¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Æ°â‚«Ã¿"
    },
    "ibm1163": "cp1163",
    "csibm1163": "cp1163",
    "maccroatian": {
      "type": "_sbcs",
      "chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Å â„¢Â´Â¨â‰ Å½Ã˜âˆžÂ±â‰¤â‰¥âˆ†Âµâˆ‚âˆ‘âˆÅ¡âˆ«ÂªÂºâ„¦Å¾Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆÄ†Â«ÄŒâ€¦Â Ã€ÃƒÃ•Å’Å“Äâ€”â€œâ€â€˜â€™Ã·â—Šï¿½Â©â„Â¤â€¹â€ºÃ†Â»â€“Â·â€šâ€žâ€°Ã‚Ä‡ÃÄÃˆÃÃŽÃÃŒÃ“Ã”Ä‘Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ï€Ã‹ËšÂ¸ÃŠÃ¦Ë‡"
    },
    "maccyrillic": {
      "type": "_sbcs",
      "chars": "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯â€ Â°Â¢Â£Â§â€¢Â¶Ð†Â®Â©â„¢Ð‚Ñ’â‰ ÐƒÑ“âˆžÂ±â‰¤â‰¥Ñ–Âµâˆ‚ÐˆÐ„Ñ”Ð‡Ñ—Ð‰Ñ™ÐŠÑšÑ˜Ð…Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ð‹Ñ›ÐŒÑœÑ•â€“â€”â€œâ€â€˜â€™Ã·â€žÐŽÑžÐÑŸâ„–ÐÑ‘ÑÐ°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÂ¤"
    },
    "macgreek": {
      "type": "_sbcs",
      "chars": "Ã„Â¹Â²Ã‰Â³Ã–ÃœÎ…Ã Ã¢Ã¤Î„Â¨Ã§Ã©Ã¨ÃªÃ«Â£â„¢Ã®Ã¯â€¢Â½â€°Ã´Ã¶Â¦Â­Ã¹Ã»Ã¼â€ Î“Î”Î˜Î›ÎžÎ ÃŸÂ®Â©Î£ÎªÂ§â‰ Â°Î‡Î‘Â±â‰¤â‰¥Â¥Î’Î•Î–Î—Î™ÎšÎœÎ¦Î«Î¨Î©Î¬ÎÂ¬ÎŸÎ¡â‰ˆÎ¤Â«Â»â€¦Â Î¥Î§Î†ÎˆÅ“â€“â€•â€œâ€â€˜â€™Ã·Î‰ÎŠÎŒÎŽÎ­Î®Î¯ÏŒÎÏÎ±Î²ÏˆÎ´ÎµÏ†Î³Î·Î¹Î¾ÎºÎ»Î¼Î½Î¿Ï€ÏŽÏÏƒÏ„Î¸Ï‰Ï‚Ï‡Ï…Î¶ÏŠÏ‹ÎÎ°ï¿½"
    },
    "maciceland": {
      "type": "_sbcs",
      "chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼ÃÂ°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦Ã¦Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„Â¤ÃÃ°ÃžÃ¾Ã½Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
    },
    "macroman": {
      "type": "_sbcs",
      "chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦Ã¦Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„Â¤â€¹â€ºï¬ï¬‚â€¡Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
    },
    "macromania": {
      "type": "_sbcs",
      "chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ä‚ÅžâˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦ÄƒÅŸÂ¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„Â¤â€¹â€ºÅ¢Å£â€¡Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
    },
    "macthai": {
      "type": "_sbcs",
      "chars": "Â«Â»â€¦ï¢Œï¢ï¢’ï¢•ï¢˜ï¢‹ï¢Žï¢‘ï¢”ï¢—â€œâ€ï¢™ï¿½â€¢ï¢„ï¢‰ï¢…ï¢†ï¢‡ï¢ˆï¢Šï¢ï¢ï¢“ï¢–â€˜â€™ï¿½Â à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸º\uFEFFâ€‹â€“â€”à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹â„¢à¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™Â®Â©ï¿½ï¿½ï¿½ï¿½"
    },
    "macturkish": {
      "type": "_sbcs",
      "chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦Ã¦Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸ÄžÄŸÄ°Ä±ÅžÅŸâ€¡Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™ï¿½Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
    },
    "macukraine": {
      "type": "_sbcs",
      "chars": "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯â€ Â°ÒÂ£Â§â€¢Â¶Ð†Â®Â©â„¢Ð‚Ñ’â‰ ÐƒÑ“âˆžÂ±â‰¤â‰¥Ñ–ÂµÒ‘ÐˆÐ„Ñ”Ð‡Ñ—Ð‰Ñ™ÐŠÑšÑ˜Ð…Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ð‹Ñ›ÐŒÑœÑ•â€“â€”â€œâ€â€˜â€™Ã·â€žÐŽÑžÐÑŸâ„–ÐÑ‘ÑÐ°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÂ¤"
    },
    "koi8r": {
      "type": "_sbcs",
      "chars": "â”€â”‚â”Œâ”â””â”˜â”œâ”¤â”¬â”´â”¼â–€â–„â–ˆâ–Œâ–â–‘â–’â–“âŒ â– âˆ™âˆšâ‰ˆâ‰¤â‰¥Â âŒ¡Â°Â²Â·Ã·â•â•‘â•’Ñ‘â•“â•”â••â•–â•—â•˜â•™â•šâ•›â•œâ•â•žâ•Ÿâ• â•¡Ðâ•¢â•£â•¤â•¥â•¦â•§â•¨â•©â•ªâ•«â•¬Â©ÑŽÐ°Ð±Ñ†Ð´ÐµÑ„Ð³Ñ…Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑ€ÑÑ‚ÑƒÐ¶Ð²ÑŒÑ‹Ð·ÑˆÑÑ‰Ñ‡ÑŠÐ®ÐÐ‘Ð¦Ð”Ð•Ð¤Ð“Ð¥Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ¯Ð Ð¡Ð¢Ð£Ð–Ð’Ð¬Ð«Ð—Ð¨Ð­Ð©Ð§Ðª"
    },
    "koi8u": {
      "type": "_sbcs",
      "chars": "â”€â”‚â”Œâ”â””â”˜â”œâ”¤â”¬â”´â”¼â–€â–„â–ˆâ–Œâ–â–‘â–’â–“âŒ â– âˆ™âˆšâ‰ˆâ‰¤â‰¥Â âŒ¡Â°Â²Â·Ã·â•â•‘â•’Ñ‘Ñ”â•”Ñ–Ñ—â•—â•˜â•™â•šâ•›Ò‘â•â•žâ•Ÿâ• â•¡ÐÐ„â•£Ð†Ð‡â•¦â•§â•¨â•©â•ªÒâ•¬Â©ÑŽÐ°Ð±Ñ†Ð´ÐµÑ„Ð³Ñ…Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑ€ÑÑ‚ÑƒÐ¶Ð²ÑŒÑ‹Ð·ÑˆÑÑ‰Ñ‡ÑŠÐ®ÐÐ‘Ð¦Ð”Ð•Ð¤Ð“Ð¥Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ¯Ð Ð¡Ð¢Ð£Ð–Ð’Ð¬Ð«Ð—Ð¨Ð­Ð©Ð§Ðª"
    },
    "koi8ru": {
      "type": "_sbcs",
      "chars": "â”€â”‚â”Œâ”â””â”˜â”œâ”¤â”¬â”´â”¼â–€â–„â–ˆâ–Œâ–â–‘â–’â–“âŒ â– âˆ™âˆšâ‰ˆâ‰¤â‰¥Â âŒ¡Â°Â²Â·Ã·â•â•‘â•’Ñ‘Ñ”â•”Ñ–Ñ—â•—â•˜â•™â•šâ•›Ò‘Ñžâ•žâ•Ÿâ• â•¡ÐÐ„â•£Ð†Ð‡â•¦â•§â•¨â•©â•ªÒÐŽÂ©ÑŽÐ°Ð±Ñ†Ð´ÐµÑ„Ð³Ñ…Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑ€ÑÑ‚ÑƒÐ¶Ð²ÑŒÑ‹Ð·ÑˆÑÑ‰Ñ‡ÑŠÐ®ÐÐ‘Ð¦Ð”Ð•Ð¤Ð“Ð¥Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ¯Ð Ð¡Ð¢Ð£Ð–Ð’Ð¬Ð«Ð—Ð¨Ð­Ð©Ð§Ðª"
    },
    "koi8t": {
      "type": "_sbcs",
      "chars": "Ò›Ò“â€šÒ’â€žâ€¦â€ â€¡ï¿½â€°Ò³â€¹Ò²Ò·Ò¶ï¿½Òšâ€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢ï¿½â€ºï¿½ï¿½ï¿½ï¿½ï¿½Ó¯Ó®Ñ‘Â¤Ó£Â¦Â§ï¿½ï¿½ï¿½Â«Â¬Â­Â®ï¿½Â°Â±Â²Ðï¿½Ó¢Â¶Â·ï¿½â„–ï¿½Â»ï¿½ï¿½ï¿½Â©ÑŽÐ°Ð±Ñ†Ð´ÐµÑ„Ð³Ñ…Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑ€ÑÑ‚ÑƒÐ¶Ð²ÑŒÑ‹Ð·ÑˆÑÑ‰Ñ‡ÑŠÐ®ÐÐ‘Ð¦Ð”Ð•Ð¤Ð“Ð¥Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ¯Ð Ð¡Ð¢Ð£Ð–Ð’Ð¬Ð«Ð—Ð¨Ð­Ð©Ð§Ðª"
    },
    "armscii8": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ ï¿½Ö‡Ö‰)(Â»Â«â€”.Õ,-ÖŠâ€¦ÕœÕ›ÕžÔ±Õ¡Ô²Õ¢Ô³Õ£Ô´Õ¤ÔµÕ¥Ô¶Õ¦Ô·Õ§Ô¸Õ¨Ô¹Õ©ÔºÕªÔ»Õ«Ô¼Õ¬Ô½Õ­Ô¾Õ®Ô¿Õ¯Õ€Õ°ÕÕ±Õ‚Õ²ÕƒÕ³Õ„Õ´Õ…ÕµÕ†Õ¶Õ‡Õ·ÕˆÕ¸Õ‰Õ¹ÕŠÕºÕ‹Õ»ÕŒÕ¼ÕÕ½ÕŽÕ¾ÕÕ¿ÕÖ€Õ‘ÖÕ’Ö‚Õ“ÖƒÕ”Ö„Õ•Ö…Õ–Ö†Õšï¿½"
    },
    "rk1048": {
      "type": "_sbcs",
      "chars": "Ð‚Ðƒâ€šÑ“â€žâ€¦â€ â€¡â‚¬â€°Ð‰â€¹ÐŠÒšÒºÐÑ’â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢Ñ™â€ºÑšÒ›Ò»ÑŸÂ Ò°Ò±Ó˜Â¤Ó¨Â¦Â§ÐÂ©Ò’Â«Â¬Â­Â®Ò®Â°Â±Ð†Ñ–Ó©ÂµÂ¶Â·Ñ‘â„–Ò“Â»Ó™Ò¢Ò£Ò¯ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑ"
    },
    "tcvn": {
      "type": "_sbcs",
      "chars": "\0Ãšá»¤á»ªá»¬á»®\x07\b	\n\v\f\rá»¨á»°á»²á»¶á»¸Ãá»´\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~Ã€áº¢ÃƒÃáº áº¶áº¬Ãˆáººáº¼Ã‰áº¸á»†ÃŒá»ˆÄ¨Ãá»ŠÃ’á»ŽÃ•Ã“á»Œá»˜á»œá»žá» á»šá»¢Ã™á»¦Å¨Â Ä‚Ã‚ÃŠÃ”Æ Æ¯ÄÄƒÃ¢ÃªÃ´Æ¡Æ°Ä‘áº°Ì€Ì‰ÌƒÌÌ£Ã áº£Ã£Ã¡áº¡áº²áº±áº³áºµáº¯áº´áº®áº¦áº¨áºªáº¤á»€áº·áº§áº©áº«áº¥áº­Ã¨á»‚áº»áº½Ã©áº¹á»á»ƒá»…áº¿á»‡Ã¬á»‰á»„áº¾á»’Ä©Ã­á»‹Ã²á»”á»ÃµÃ³á»á»“á»•á»—á»‘á»™á»á»Ÿá»¡á»›á»£Ã¹á»–á»§Å©Ãºá»¥á»«á»­á»¯á»©á»±á»³á»·á»¹Ã½á»µá»"
    },
    "georgianacademy": {
      "type": "_sbcs",
      "chars": "Â€Ââ€šÆ’â€žâ€¦â€ â€¡Ë†â€°Å â€¹Å’ÂÂŽÂÂâ€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢Å¡â€ºÅ“ÂÂžÅ¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿áƒáƒ‘áƒ’áƒ“áƒ”áƒ•áƒ–áƒ—áƒ˜áƒ™áƒšáƒ›áƒœáƒáƒžáƒŸáƒ áƒ¡áƒ¢áƒ£áƒ¤áƒ¥áƒ¦áƒ§áƒ¨áƒ©áƒªáƒ«áƒ¬áƒ­áƒ®áƒ¯áƒ°áƒ±áƒ²áƒ³áƒ´áƒµáƒ¶Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    "georgianps": {
      "type": "_sbcs",
      "chars": "Â€Ââ€šÆ’â€žâ€¦â€ â€¡Ë†â€°Å â€¹Å’ÂÂŽÂÂâ€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢Å¡â€ºÅ“ÂÂžÅ¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿áƒáƒ‘áƒ’áƒ“áƒ”áƒ•áƒ–áƒ±áƒ—áƒ˜áƒ™áƒšáƒ›áƒœáƒ²áƒáƒžáƒŸáƒ áƒ¡áƒ¢áƒ³áƒ£áƒ¤áƒ¥áƒ¦áƒ§áƒ¨áƒ©áƒªáƒ«áƒ¬áƒ­áƒ®áƒ´áƒ¯áƒ°áƒµÃ¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    "pt154": {
      "type": "_sbcs",
      "chars": "Ò–Ò’Ó®Ò“â€žâ€¦Ò¶Ò®Ò²Ò¯Ò Ó¢Ò¢ÒšÒºÒ¸Ò—â€˜â€™â€œâ€â€¢â€“â€”Ò³Ò·Ò¡Ó£Ò£Ò›Ò»Ò¹Â ÐŽÑžÐˆÓ¨Ò˜Ò°Â§ÐÂ©Ó˜Â«Â¬Ó¯Â®ÒœÂ°Ò±Ð†Ñ–Ò™Ó©Â¶Â·Ñ‘â„–Ó™Â»Ñ˜ÒªÒ«ÒÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑ"
    },
    "viscii": {
      "type": "_sbcs",
      "chars": "\0áº²áº´áºª\x07\b	\n\v\f\rá»¶á»¸\x1Bá»´ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~áº áº®áº°áº¶áº¤áº¦áº¨áº¬áº¼áº¸áº¾á»€á»‚á»„á»†á»á»’á»”á»–á»˜á»¢á»šá»œá»žá»Šá»Žá»Œá»ˆá»¦Å¨á»¤á»²Ã•áº¯áº±áº·áº¥áº§áº©áº­áº½áº¹áº¿á»á»ƒá»…á»‡á»‘á»“á»•á»—á» Æ á»™á»á»Ÿá»‹á»°á»¨á»ªá»¬Æ¡á»›Æ¯Ã€ÃÃ‚Ãƒáº¢Ä‚áº³áºµÃˆÃ‰ÃŠáººÃŒÃÄ¨á»³Äá»©Ã’Ã“Ã”áº¡á»·á»«á»­Ã™Ãšá»¹á»µÃá»¡Æ°Ã Ã¡Ã¢Ã£áº£Äƒá»¯áº«Ã¨Ã©Ãªáº»Ã¬Ã­Ä©á»‰Ä‘á»±Ã²Ã³Ã´Ãµá»á»á»¥Ã¹ÃºÅ©á»§Ã½á»£á»®"
    },
    "iso646cn": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#Â¥%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}â€¾ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
    },
    "iso646jp": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[Â¥]^_`abcdefghijklmnopqrstuvwxyz{|}â€¾ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
    },
    "hproman8": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ã€Ã‚ÃˆÃŠÃ‹ÃŽÃÂ´Ë‹Ë†Â¨ËœÃ™Ã›â‚¤Â¯ÃÃ½Â°Ã‡Ã§Ã‘Ã±Â¡Â¿Â¤Â£Â¥Â§Æ’Â¢Ã¢ÃªÃ´Ã»Ã¡Ã©Ã³ÃºÃ Ã¨Ã²Ã¹Ã¤Ã«Ã¶Ã¼Ã…Ã®Ã˜Ã†Ã¥Ã­Ã¸Ã¦Ã„Ã¬Ã–ÃœÃ‰Ã¯ÃŸÃ”ÃÃƒÃ£ÃÃ°ÃÃŒÃ“Ã’Ã•ÃµÅ Å¡ÃšÅ¸Ã¿ÃžÃ¾Â·ÂµÂ¶Â¾â€”Â¼Â½ÂªÂºÂ«â– Â»Â±ï¿½"
    },
    "macintosh": {
      "type": "_sbcs",
      "chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦Ã¦Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„Â¤â€¹â€ºï¬ï¬‚â€¡Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
    },
    "ascii": {
      "type": "_sbcs",
      "chars": "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
    },
    "tis620": {
      "type": "_sbcs",
      "chars": "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›ï¿½ï¿½ï¿½ï¿½"
    }
  };
  return sbcsDataGenerated;
}
var dbcsCodec = {};
var hasRequiredDbcsCodec;
function requireDbcsCodec() {
  if (hasRequiredDbcsCodec) return dbcsCodec;
  hasRequiredDbcsCodec = 1;
  var Buffer2 = requireSafer().Buffer;
  dbcsCodec._dbcs = DBCSCodec;
  var UNASSIGNED = -1, GB18030_CODE = -2, SEQ_START = -10, NODE_START = -1e3, UNASSIGNED_NODE = new Array(256), DEF_CHAR = -1;
  for (var i = 0; i < 256; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;
  function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
      throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var mappingTable = codecOptions.table();
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
    this.decodeTableSeq = [];
    for (var i2 = 0; i2 < mappingTable.length; i2++)
      this._addDecodeChunk(mappingTable[i2]);
    if (typeof codecOptions.gb18030 === "function") {
      this.gb18030 = codecOptions.gb18030();
      var commonThirdByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var commonFourthByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var firstByteNode = this.decodeTables[0];
      for (var i2 = 129; i2 <= 254; i2++) {
        var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i2]];
        for (var j = 48; j <= 57; j++) {
          if (secondByteNode[j] === UNASSIGNED) {
            secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
          } else if (secondByteNode[j] > NODE_START) {
            throw new Error("gb18030 decode tables conflict at byte 2");
          }
          var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
          for (var k = 129; k <= 254; k++) {
            if (thirdByteNode[k] === UNASSIGNED) {
              thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
            } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {
              continue;
            } else if (thirdByteNode[k] > NODE_START) {
              throw new Error("gb18030 decode tables conflict at byte 3");
            }
            var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
            for (var l = 48; l <= 57; l++) {
              if (fourthByteNode[l] === UNASSIGNED)
                fourthByteNode[l] = GB18030_CODE;
            }
          }
        }
      }
    }
    this.defaultCharUnicode = iconv.defaultCharUnicode;
    this.encodeTable = [];
    this.encodeTableSeq = [];
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
      for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
        var val = codecOptions.encodeSkipVals[i2];
        if (typeof val === "number")
          skipEncodeChars[val] = true;
        else
          for (var j = val.from; j <= val.to; j++)
            skipEncodeChars[j] = true;
      }
    this._fillEncodeTable(0, 0, skipEncodeChars);
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd)
        if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
          this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }
    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
  }
  DBCSCodec.prototype.encoder = DBCSEncoder;
  DBCSCodec.prototype.decoder = DBCSDecoder;
  DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes = [];
    for (; addr > 0; addr >>>= 8)
      bytes.push(addr & 255);
    if (bytes.length == 0)
      bytes.push(0);
    var node = this.decodeTables[0];
    for (var i2 = bytes.length - 1; i2 > 0; i2--) {
      var val = node[bytes[i2]];
      if (val == UNASSIGNED) {
        node[bytes[i2]] = NODE_START - this.decodeTables.length;
        this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
      } else if (val <= NODE_START) {
        node = this.decodeTables[NODE_START - val];
      } else
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
  };
  DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    var curAddr = parseInt(chunk[0], 16);
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 255;
    for (var k = 1; k < chunk.length; k++) {
      var part = chunk[k];
      if (typeof part === "string") {
        for (var l = 0; l < part.length; ) {
          var code = part.charCodeAt(l++);
          if (55296 <= code && code < 56320) {
            var codeTrail = part.charCodeAt(l++);
            if (56320 <= codeTrail && codeTrail < 57344)
              writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
            else
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
          } else if (4080 < code && code <= 4095) {
            var len = 4095 - code + 2;
            var seq = [];
            for (var m = 0; m < len; m++)
              seq.push(part.charCodeAt(l++));
            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
            this.decodeTableSeq.push(seq);
          } else
            writeTable[curAddr++] = code;
        }
      } else if (typeof part === "number") {
        var charCode = writeTable[curAddr - 1] + 1;
        for (var l = 0; l < part; l++)
          writeTable[curAddr++] = charCode++;
      } else
        throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
  };
  DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8;
    if (this.encodeTable[high] === void 0)
      this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
    return this.encodeTable[high];
  };
  DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    if (bucket[low] <= SEQ_START)
      this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
    else if (bucket[low] == UNASSIGNED)
      bucket[low] = dbcsCode;
  };
  DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    var node;
    if (bucket[low] <= SEQ_START) {
      node = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
      node = {};
      if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low];
      bucket[low] = SEQ_START - this.encodeTableSeq.length;
      this.encodeTableSeq.push(node);
    }
    for (var j = 1; j < seq.length - 1; j++) {
      var oldVal = node[uCode];
      if (typeof oldVal === "object")
        node = oldVal;
      else {
        node = node[uCode] = {};
        if (oldVal !== void 0)
          node[DEF_CHAR] = oldVal;
      }
    }
    uCode = seq[seq.length - 1];
    node[uCode] = dbcsCode;
  };
  DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    var hasValues = false;
    var subNodeEmpty = {};
    for (var i2 = 0; i2 < 256; i2++) {
      var uCode = node[i2];
      var mbCode = prefix + i2;
      if (skipEncodeChars[mbCode])
        continue;
      if (uCode >= 0) {
        this._setEncodeChar(uCode, mbCode);
        hasValues = true;
      } else if (uCode <= NODE_START) {
        var subNodeIdx = NODE_START - uCode;
        if (!subNodeEmpty[subNodeIdx]) {
          var newPrefix = mbCode << 8 >>> 0;
          if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars))
            hasValues = true;
          else
            subNodeEmpty[subNodeIdx] = true;
        }
      } else if (uCode <= SEQ_START) {
        this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
        hasValues = true;
      }
    }
    return hasValues;
  };
  function DBCSEncoder(options, codec) {
    this.leadSurrogate = -1;
    this.seqObj = void 0;
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
  }
  DBCSEncoder.prototype.write = function(str) {
    var newBuf = Buffer2.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j = 0;
    while (true) {
      if (nextChar === -1) {
        if (i2 == str.length) break;
        var uCode = str.charCodeAt(i2++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }
      if (55296 <= uCode && uCode < 57344) {
        if (uCode < 56320) {
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else {
            leadSurrogate = uCode;
            uCode = UNASSIGNED;
          }
        } else {
          if (leadSurrogate !== -1) {
            uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
            leadSurrogate = -1;
          } else {
            uCode = UNASSIGNED;
          }
        }
      } else if (leadSurrogate !== -1) {
        nextChar = uCode;
        uCode = UNASSIGNED;
        leadSurrogate = -1;
      }
      var dbcsCode = UNASSIGNED;
      if (seqObj !== void 0 && uCode != UNASSIGNED) {
        var resCode = seqObj[uCode];
        if (typeof resCode === "object") {
          seqObj = resCode;
          continue;
        } else if (typeof resCode == "number") {
          dbcsCode = resCode;
        } else if (resCode == void 0) {
          resCode = seqObj[DEF_CHAR];
          if (resCode !== void 0) {
            dbcsCode = resCode;
            nextChar = uCode;
          }
        }
        seqObj = void 0;
      } else if (uCode >= 0) {
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== void 0)
          dbcsCode = subtable[uCode & 255];
        if (dbcsCode <= SEQ_START) {
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
            dbcsCode = dbcsCode % 12600;
            newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
            dbcsCode = dbcsCode % 1260;
            newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
            dbcsCode = dbcsCode % 10;
            newBuf[j++] = 48 + dbcsCode;
            continue;
          }
        }
      }
      if (dbcsCode === UNASSIGNED)
        dbcsCode = this.defaultCharSingleByte;
      if (dbcsCode < 256) {
        newBuf[j++] = dbcsCode;
      } else if (dbcsCode < 65536) {
        newBuf[j++] = dbcsCode >> 8;
        newBuf[j++] = dbcsCode & 255;
      } else if (dbcsCode < 16777216) {
        newBuf[j++] = dbcsCode >> 16;
        newBuf[j++] = dbcsCode >> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      } else {
        newBuf[j++] = dbcsCode >>> 24;
        newBuf[j++] = dbcsCode >>> 16 & 255;
        newBuf[j++] = dbcsCode >>> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === void 0)
      return;
    var newBuf = Buffer2.alloc(10), j = 0;
    if (this.seqObj) {
      var dbcsCode = this.seqObj[DEF_CHAR];
      if (dbcsCode !== void 0) {
        if (dbcsCode < 256) {
          newBuf[j++] = dbcsCode;
        } else {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 255;
        }
      }
      this.seqObj = void 0;
    }
    if (this.leadSurrogate !== -1) {
      newBuf[j++] = this.defaultCharSingleByte;
      this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.findIdx = findIdx;
  function DBCSDecoder(options, codec) {
    this.nodeIdx = 0;
    this.prevBytes = [];
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
  }
  DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBytes = this.prevBytes, prevOffset = this.prevBytes.length, seqStart = -this.prevBytes.length, uCode;
    for (var i2 = 0, j = 0; i2 < buf.length; i2++) {
      var curByte = i2 >= 0 ? buf[i2] : prevBytes[i2 + prevOffset];
      var uCode = this.decodeTables[nodeIdx][curByte];
      if (uCode >= 0) ;
      else if (uCode === UNASSIGNED) {
        uCode = this.defaultCharUnicode.charCodeAt(0);
        i2 = seqStart;
      } else if (uCode === GB18030_CODE) {
        if (i2 >= 3) {
          var ptr = (buf[i2 - 3] - 129) * 12600 + (buf[i2 - 2] - 48) * 1260 + (buf[i2 - 1] - 129) * 10 + (curByte - 48);
        } else {
          var ptr = (prevBytes[i2 - 3 + prevOffset] - 129) * 12600 + ((i2 - 2 >= 0 ? buf[i2 - 2] : prevBytes[i2 - 2 + prevOffset]) - 48) * 1260 + ((i2 - 1 >= 0 ? buf[i2 - 1] : prevBytes[i2 - 1 + prevOffset]) - 129) * 10 + (curByte - 48);
        }
        var idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        var seq = this.decodeTableSeq[SEQ_START - uCode];
        for (var k = 0; k < seq.length - 1; k++) {
          uCode = seq[k];
          newBuf[j++] = uCode & 255;
          newBuf[j++] = uCode >> 8;
        }
        uCode = seq[seq.length - 1];
      } else
        throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
      if (uCode >= 65536) {
        uCode -= 65536;
        var uCodeLead = 55296 | uCode >> 10;
        newBuf[j++] = uCodeLead & 255;
        newBuf[j++] = uCodeLead >> 8;
        uCode = 56320 | uCode & 1023;
      }
      newBuf[j++] = uCode & 255;
      newBuf[j++] = uCode >> 8;
      nodeIdx = 0;
      seqStart = i2 + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
    return newBuf.slice(0, j).toString("ucs2");
  };
  DBCSDecoder.prototype.end = function() {
    var ret = "";
    while (this.prevBytes.length > 0) {
      ret += this.defaultCharUnicode;
      var bytesArr = this.prevBytes.slice(1);
      this.prevBytes = [];
      this.nodeIdx = 0;
      if (bytesArr.length > 0)
        ret += this.write(bytesArr);
    }
    this.prevBytes = [];
    this.nodeIdx = 0;
    return ret;
  };
  function findIdx(table, val) {
    if (table[0] > val)
      return -1;
    var l = 0, r = table.length;
    while (l < r - 1) {
      var mid = l + (r - l + 1 >> 1);
      if (table[mid] <= val)
        l = mid;
      else
        r = mid;
    }
    return l;
  }
  return dbcsCodec;
}
const require$$0$2 = [
  [
    "0",
    "\0",
    128
  ],
  [
    "a1",
    "ï½¡",
    62
  ],
  [
    "8140",
    "ã€€ã€ã€‚ï¼Œï¼Žãƒ»ï¼šï¼›ï¼Ÿï¼ã‚›ã‚œÂ´ï½€Â¨ï¼¾ï¿£ï¼¿ãƒ½ãƒ¾ã‚ã‚žã€ƒä»ã€…ã€†ã€‡ãƒ¼â€•â€ï¼ï¼¼ï½žâˆ¥ï½œâ€¦â€¥â€˜â€™â€œâ€ï¼ˆï¼‰ã€”ã€•ï¼»ï¼½ï½›ï½ã€ˆ",
    9,
    "ï¼‹ï¼Â±Ã—"
  ],
  [
    "8180",
    "Ã·ï¼â‰ ï¼œï¼žâ‰¦â‰§âˆžâˆ´â™‚â™€Â°â€²â€³â„ƒï¿¥ï¼„ï¿ ï¿¡ï¼…ï¼ƒï¼†ï¼Šï¼ Â§â˜†â˜…â—‹â—â—Žâ—‡â—†â–¡â– â–³â–²â–½â–¼â€»ã€’â†’â†â†‘â†“ã€“"
  ],
  [
    "81b8",
    "âˆˆâˆ‹âŠ†âŠ‡âŠ‚âŠƒâˆªâˆ©"
  ],
  [
    "81c8",
    "âˆ§âˆ¨ï¿¢â‡’â‡”âˆ€âˆƒ"
  ],
  [
    "81da",
    "âˆ âŠ¥âŒ’âˆ‚âˆ‡â‰¡â‰’â‰ªâ‰«âˆšâˆ½âˆâˆµâˆ«âˆ¬"
  ],
  [
    "81f0",
    "â„«â€°â™¯â™­â™ªâ€ â€¡Â¶"
  ],
  [
    "81fc",
    "â—¯"
  ],
  [
    "824f",
    "ï¼",
    9
  ],
  [
    "8260",
    "ï¼¡",
    25
  ],
  [
    "8281",
    "ï½",
    25
  ],
  [
    "829f",
    "ã",
    82
  ],
  [
    "8340",
    "ã‚¡",
    62
  ],
  [
    "8380",
    "ãƒ ",
    22
  ],
  [
    "839f",
    "Î‘",
    16,
    "Î£",
    6
  ],
  [
    "83bf",
    "Î±",
    16,
    "Ïƒ",
    6
  ],
  [
    "8440",
    "Ð",
    5,
    "ÐÐ–",
    25
  ],
  [
    "8470",
    "Ð°",
    5,
    "Ñ‘Ð¶",
    7
  ],
  [
    "8480",
    "Ð¾",
    17
  ],
  [
    "849f",
    "â”€â”‚â”Œâ”â”˜â””â”œâ”¬â”¤â”´â”¼â”â”ƒâ”â”“â”›â”—â”£â”³â”«â”»â•‹â” â”¯â”¨â”·â”¿â”â”°â”¥â”¸â•‚"
  ],
  [
    "8740",
    "â‘ ",
    19,
    "â… ",
    9
  ],
  [
    "875f",
    "ã‰ãŒ”ãŒ¢ããŒ˜ãŒ§ãŒƒãŒ¶ã‘ã—ãŒãŒ¦ãŒ£ãŒ«ãŠãŒ»ãŽœãŽãŽžãŽŽãŽã„ãŽ¡"
  ],
  [
    "877e",
    "ã»"
  ],
  [
    "8780",
    "ã€ã€Ÿâ„–ãâ„¡ãŠ¤",
    4,
    "ãˆ±ãˆ²ãˆ¹ã¾ã½ã¼â‰’â‰¡âˆ«âˆ®âˆ‘âˆšâŠ¥âˆ âˆŸâŠ¿âˆµâˆ©âˆª"
  ],
  [
    "889f",
    "äºœå”–å¨ƒé˜¿å“€æ„›æŒ¨å§¶é€¢è‘µèŒœç©æ‚ªæ¡æ¸¥æ—­è‘¦èŠ¦é¯µæ¢“åœ§æ–¡æ‰±å®›å§è™»é£´çµ¢ç¶¾é®Žæˆ–ç²Ÿè¢·å®‰åºµæŒ‰æš—æ¡ˆé—‡éžæä»¥ä¼Šä½ä¾å‰å›²å¤·å§”å¨å°‰æƒŸæ„æ…°æ˜“æ¤…ç‚ºç•ç•°ç§»ç¶­ç·¯èƒƒèŽè¡£è¬‚é•éºåŒ»äº•äº¥åŸŸè‚²éƒç£¯ä¸€å£±æº¢é€¸ç¨²èŒ¨èŠ‹é°¯å…å°å’½å“¡å› å§»å¼•é£²æ·«èƒ¤è”­"
  ],
  [
    "8940",
    "é™¢é™°éš éŸ»å‹å³å®‡çƒç¾½è¿‚é›¨å¯éµœçªºä¸‘ç¢“è‡¼æ¸¦å˜˜å”„æ¬è”šé°»å§¥åŽ©æµ¦ç“œé–å™‚äº‘é‹é›²èé¤Œå¡å–¶å¬°å½±æ˜ æ›³æ „æ°¸æ³³æ´©ç‘›ç›ˆç©Žé ´è‹±è¡›è© é‹­æ¶²ç–«ç›Šé§…æ‚¦è¬è¶Šé–²æ¦ŽåŽ­å††"
  ],
  [
    "8980",
    "åœ’å °å¥„å®´å»¶æ€¨æŽ©æ´æ²¿æ¼”ç‚Žç„”ç…™ç‡•çŒ¿ç¸è‰¶è‹‘è–—é é‰›é´›å¡©æ–¼æ±šç”¥å‡¹å¤®å¥¥å¾€å¿œæŠ¼æ—ºæ¨ªæ¬§æ®´çŽ‹ç¿è¥–é´¬é´Žé»„å²¡æ²–è»å„„å±‹æ†¶è‡†æ¡¶ç‰¡ä¹™ä¿ºå¸æ©æ¸©ç©éŸ³ä¸‹åŒ–ä»®ä½•ä¼½ä¾¡ä½³åŠ å¯å˜‰å¤å«å®¶å¯¡ç§‘æš‡æžœæž¶æ­Œæ²³ç«ç‚ç¦ç¦¾ç¨¼ç®‡èŠ±è‹›èŒ„è·è¯è“è¦èª²å˜©è²¨è¿¦éŽéœžèšŠä¿„å³¨æˆ‘ç‰™ç”»è‡¥èŠ½è›¾è³€é›…é¤“é§•ä»‹ä¼šè§£å›žå¡Šå£Šå»»å¿«æ€ªæ‚”æ¢æ‡æˆ’æ‹æ”¹"
  ],
  [
    "8a40",
    "é­æ™¦æ¢°æµ·ç°ç•Œçš†çµµèŠ¥èŸ¹é–‹éšŽè²å‡±åŠ¾å¤–å’³å®³å´–æ…¨æ¦‚æ¶¯ç¢è“‹è¡—è©²éŽ§éª¸æµ¬é¦¨è›™åž£æŸ¿è›ŽéˆŽåŠƒåš‡å„å»“æ‹¡æ’¹æ ¼æ ¸æ®»ç²ç¢ºç©«è¦šè§’èµ«è¼ƒéƒ­é–£éš”é©å­¦å²³æ¥½é¡é¡ŽæŽ›ç¬ æ¨«"
  ],
  [
    "8a80",
    "æ©¿æ¢¶é°æ½Ÿå‰²å–æ°æ‹¬æ´»æ¸‡æ»‘è‘›è¤è½„ä¸”é°¹å¶æ¤›æ¨ºéž„æ ªå…œç«ƒè’²é‡œéŽŒå™›é´¨æ ¢èŒ…è±ç²¥åˆˆè‹…ç“¦ä¹¾ä¾ƒå† å¯’åˆŠå‹˜å‹§å·»å–šå ªå§¦å®Œå®˜å¯›å¹²å¹¹æ‚£æ„Ÿæ…£æ†¾æ›æ•¢æŸ‘æ¡“æ£ºæ¬¾æ­“æ±—æ¼¢æ¾—æ½…ç’°ç”˜ç›£çœ‹ç«¿ç®¡ç°¡ç·©ç¼¶ç¿°è‚è‰¦èŽžè¦³è«Œè²«é‚„é‘‘é–“é–‘é–¢é™¥éŸ“é¤¨èˆ˜ä¸¸å«å²¸å·ŒçŽ©ç™Œçœ¼å²©ç¿«è´‹é›é ‘é¡”é¡˜ä¼ä¼Žå±å–œå™¨åŸºå¥‡å¬‰å¯„å²å¸Œå¹¾å¿Œæ®æœºæ——æ—¢æœŸæ£‹æ£„"
  ],
  [
    "8b40",
    "æ©Ÿå¸°æ¯…æ°—æ±½ç•¿ç¥ˆå­£ç¨€ç´€å¾½è¦è¨˜è²´èµ·è»Œè¼é£¢é¨Žé¬¼äº€å½å„€å¦“å®œæˆ¯æŠ€æ“¬æ¬ºçŠ ç–‘ç¥‡ç¾©èŸ»èª¼è­°æŽ¬èŠéž å‰åƒå–«æ¡”æ©˜è©°ç §æµé»å´å®¢è„šè™é€†ä¸˜ä¹…ä»‡ä¼‘åŠå¸å®®å¼“æ€¥æ•‘"
  ],
  [
    "8b80",
    "æœ½æ±‚æ±²æ³£ç¸çƒç©¶çª®ç¬ˆç´šç³¾çµ¦æ—§ç‰›åŽ»å±…å·¨æ‹’æ‹ æŒ™æ¸ è™šè¨±è·é‹¸æ¼ç¦¦é­šäº¨äº«äº¬ä¾›ä¾ åƒ‘å…‡ç«¶å…±å‡¶å”åŒ¡å¿å«å–¬å¢ƒå³¡å¼·å½Šæ€¯ææ­æŒŸæ•™æ©‹æ³ç‹‚ç‹­çŸ¯èƒ¸è„…èˆˆè•Žéƒ·é¡éŸ¿é¥—é©šä»°å‡å°­æšæ¥­å±€æ›²æ¥µçŽ‰æ¡ç²åƒ…å‹¤å‡å·¾éŒ¦æ–¤æ¬£æ¬½ç´ç¦ç¦½ç­‹ç·ŠèŠ¹èŒè¡¿è¥Ÿè¬¹è¿‘é‡‘åŸéŠ€ä¹å€¶å¥åŒºç‹—çŽ–çŸ©è‹¦èº¯é§†é§ˆé§’å…·æ„šè™žå–°ç©ºå¶å¯“é‡éš…ä¸²æ«›é‡§å±‘å±ˆ"
  ],
  [
    "8c40",
    "æŽ˜çªŸæ²“é´è½¡çªªç†Šéšˆç²‚æ —ç¹°æ¡‘é¬å‹²å›è–«è¨“ç¾¤è»éƒ¡å¦è¢ˆç¥ä¿‚å‚¾åˆ‘å…„å•“åœ­çªåž‹å¥‘å½¢å¾„æµæ…¶æ…§æ†©æŽ²æºæ•¬æ™¯æ¡‚æ¸“ç•¦ç¨½ç³»çµŒç¶™ç¹‹ç½«èŒŽèŠè›è¨ˆè©£è­¦è»½é šé¶èŠ¸è¿Žé¯¨"
  ],
  [
    "8c80",
    "åŠ‡æˆŸæ’ƒæ¿€éš™æ¡å‚‘æ¬ æ±ºæ½”ç©´çµè¡€è¨£æœˆä»¶å€¹å€¦å¥å…¼åˆ¸å‰£å–§åœå …å«Œå»ºæ†²æ‡¸æ‹³æ²æ¤œæ¨©ç‰½çŠ¬çŒ®ç ”ç¡¯çµ¹çœŒè‚©è¦‹è¬™è³¢è»’é£éµé™ºé¡•é¨“é¹¸å…ƒåŽŸåŽ³å¹»å¼¦æ¸›æºçŽ„ç¾çµƒèˆ·è¨€è«ºé™ä¹Žå€‹å¤å‘¼å›ºå§‘å­¤å·±åº«å¼§æˆ¸æ•…æž¯æ¹–ç‹ç³Šè¢´è‚¡èƒ¡è°è™Žèª‡è·¨éˆ·é›‡é¡§é¼“äº”äº’ä¼åˆå‘‰å¾å¨¯å¾Œå¾¡æ‚Ÿæ¢§æªŽç‘šç¢èªžèª¤è­·é†ä¹žé¯‰äº¤ä½¼ä¾¯å€™å€–å…‰å…¬åŠŸåŠ¹å‹¾åŽšå£å‘"
  ],
  [
    "8d40",
    "åŽå–‰å‘åž¢å¥½å­”å­å®å·¥å·§å··å¹¸åºƒåºšåº·å¼˜æ’æ…ŒæŠ—æ‹˜æŽ§æ”»æ˜‚æ™ƒæ›´æ­æ ¡æ¢—æ§‹æ±Ÿæ´ªæµ©æ¸¯æºç”²çš‡ç¡¬ç¨¿ç³ ç´…ç´˜çµžç¶±è€•è€ƒè‚¯è‚±è…”è†èˆªè’è¡Œè¡¡è¬›è²¢è³¼éƒŠé…µé‰±ç ¿é‹¼é–¤é™"
  ],
  [
    "8d80",
    "é …é¦™é«˜é´»å‰›åŠ«å·åˆå£•æ‹·æ¿ è±ªè½Ÿéº¹å…‹åˆ»å‘Šå›½ç©€é…·éµ é»’ç„æ¼‰è…°ç”‘å¿½æƒšéª¨ç‹›è¾¼æ­¤é ƒä»Šå›°å¤å¢¾å©šæ¨æ‡‡æ˜æ˜†æ ¹æ¢±æ··ç—•ç´ºè‰®é­‚äº›ä½å‰å”†åµ¯å·¦å·®æŸ»æ²™ç‘³ç ‚è©éŽ–è£Ÿååº§æŒ«å‚µå‚¬å†æœ€å“‰å¡žå¦»å®°å½©æ‰æŽ¡æ ½æ­³æ¸ˆç½é‡‡çŠ€ç •ç ¦ç¥­æ–Žç´°èœè£è¼‰éš›å‰¤åœ¨æç½ªè²¡å†´å‚é˜ªå ºæ¦Šè‚´å’²å´ŽåŸ¼ç¢•é·ºä½œå‰Šå’‹æ¾æ˜¨æœ”æŸµçª„ç­–ç´¢éŒ¯æ¡œé®­ç¬¹åŒ™å†Šåˆ·"
  ],
  [
    "8e40",
    "å¯Ÿæ‹¶æ’®æ“¦æœ­æ®ºè–©é›‘çšé¯–æŒéŒ†é®«çš¿æ™’ä¸‰å‚˜å‚å±±æƒ¨æ’’æ•£æ¡Ÿç‡¦çŠç”£ç®—çº‚èš•è®ƒè³›é…¸é¤æ–¬æš«æ®‹ä»•ä»”ä¼ºä½¿åˆºå¸å²å—£å››å£«å§‹å§‰å§¿å­å±å¸‚å¸«å¿—æ€æŒ‡æ”¯å­œæ–¯æ–½æ—¨æžæ­¢"
  ],
  [
    "8e80",
    "æ­»æ°ç…ç¥‰ç§ç³¸ç´™ç´«è‚¢è„‚è‡³è¦–è©žè©©è©¦èªŒè«®è³‡è³œé›Œé£¼æ­¯äº‹ä¼¼ä¾å…å­—å¯ºæ…ˆæŒæ™‚æ¬¡æ»‹æ²»çˆ¾ç’½ç—”ç£ç¤ºè€Œè€³è‡ªè’”è¾žæ±é¹¿å¼è­˜é´«ç«ºè»¸å®é›«ä¸ƒå±åŸ·å¤±å«‰å®¤æ‚‰æ¹¿æ¼†ç–¾è³ªå®Ÿè”€ç¯ å²æŸ´èŠå±¡è•Šç¸žèˆŽå†™å°„æ¨èµ¦æ–œç…®ç¤¾ç´—è€…è¬è»Šé®è›‡é‚ªå€Ÿå‹ºå°ºæ“ç¼çˆµé…Œé‡ˆéŒ«è‹¥å¯‚å¼±æƒ¹ä¸»å–å®ˆæ‰‹æœ±æ®Šç‹©ç ç¨®è…«è¶£é…’é¦–å„’å—å‘ªå¯¿æŽˆæ¨¹ç¶¬éœ€å›šåŽå‘¨"
  ],
  [
    "8f40",
    "å®—å°±å·žä¿®æ„æ‹¾æ´²ç§€ç§‹çµ‚ç¹ç¿’è‡­èˆŸè’è¡†è¥²è®è¹´è¼¯é€±é…‹é…¬é›†é†œä»€ä½å……åå¾“æˆŽæŸ”æ±æ¸‹ç£ç¸¦é‡éŠƒå”å¤™å®¿æ·‘ç¥ç¸®ç²›å¡¾ç†Ÿå‡ºè¡“è¿°ä¿Šå³»æ˜¥çž¬ç«£èˆœé§¿å‡†å¾ªæ—¬æ¥¯æ®‰æ·³"
  ],
  [
    "8f80",
    "æº–æ½¤ç›¾ç´”å·¡éµé†‡é †å‡¦åˆæ‰€æš‘æ›™æ¸šåº¶ç·’ç½²æ›¸è–¯è—·è«¸åŠ©å™å¥³åºå¾æ•é‹¤é™¤å‚·å„Ÿå‹åŒ å‡å¬å“¨å•†å”±å˜—å¥¨å¦¾å¨¼å®µå°†å°å°‘å°šåº„åºŠå» å½°æ‰¿æŠ„æ‹›æŽŒæ·æ˜‡æ˜Œæ˜­æ™¶æ¾æ¢¢æ¨Ÿæ¨µæ²¼æ¶ˆæ¸‰æ¹˜ç„¼ç„¦ç…§ç—‡çœç¡ç¤ç¥¥ç§°ç« ç¬‘ç²§ç´¹è‚–è–è’‹è•‰è¡è£³è¨Ÿè¨¼è©”è©³è±¡è³žé†¤é‰¦é¾é˜éšœéž˜ä¸Šä¸ˆä¸žä¹—å†—å‰°åŸŽå ´å£Œå¬¢å¸¸æƒ…æ“¾æ¡æ–æµ„çŠ¶ç•³ç©£è’¸è­²é†¸éŒ å˜±åŸ´é£¾"
  ],
  [
    "9040",
    "æ‹­æ¤æ®–ç‡­ç¹”è·è‰²è§¦é£Ÿè•è¾±å°»ä¼¸ä¿¡ä¾µå”‡å¨ å¯å¯©å¿ƒæ…ŽæŒ¯æ–°æ™‹æ£®æ¦›æµ¸æ·±ç”³ç–¹çœŸç¥žç§¦ç´³è‡£èŠ¯è–ªè¦ªè¨ºèº«è¾›é€²é‡éœ‡äººä»åˆƒå¡µå£¬å°‹ç”šå°½è…Žè¨Šè¿…é™£é­ç¬¥è«é ˆé…¢å›³åŽ¨"
  ],
  [
    "9080",
    "é€—å¹åž‚å¸¥æŽ¨æ°´ç‚Šç¡ç²‹ç¿ è¡°é‚é…”éŒéŒ˜éšç‘žé«„å´‡åµ©æ•°æž¢è¶¨é››æ®æ‰æ¤™è…é —é›€è£¾æ¾„æ‘ºå¯¸ä¸–ç€¬ç•æ˜¯å‡„åˆ¶å‹¢å§“å¾æ€§æˆæ”¿æ•´æ˜Ÿæ™´æ£²æ –æ­£æ¸…ç‰²ç”Ÿç››ç²¾è–å£°è£½è¥¿èª èª“è«‹é€é†’é’é™æ–‰ç¨Žè„†éš»å¸­æƒœæˆšæ–¥æ˜”æžçŸ³ç©ç±ç¸¾è„Šè²¬èµ¤è·¡è¹Ÿç¢©åˆ‡æ‹™æŽ¥æ‘‚æŠ˜è¨­çªƒç¯€èª¬é›ªçµ¶èˆŒè‰ä»™å…ˆåƒå å®£å°‚å°–å·æˆ¦æ‰‡æ’°æ “æ ´æ³‰æµ…æ´—æŸ“æ½œç…Žç…½æ—‹ç©¿ç®­ç·š"
  ],
  [
    "9140",
    "ç¹Šç¾¨è…ºèˆ›èˆ¹è–¦è©®è³Žè·µé¸é·éŠ­éŠ‘é–ƒé®®å‰å–„æ¼¸ç„¶å…¨ç¦…ç¹•è†³ç³Žå™Œå¡‘å²¨æŽªæ›¾æ›½æ¥šç‹™ç–ç–Žç¤Žç¥–ç§Ÿç²—ç´ çµ„è˜‡è¨´é˜»é¡é¼ åƒ§å‰µåŒå¢å€‰å–ªå£®å¥çˆ½å®‹å±¤åŒæƒ£æƒ³æœæŽƒæŒ¿æŽ»"
  ],
  [
    "9180",
    "æ“æ—©æ›¹å·£æ§æ§½æ¼•ç‡¥äº‰ç—©ç›¸çª“ç³Ÿç·ç¶œè¡è‰è˜è‘¬è’¼è—»è£…èµ°é€é­éŽ—éœœé¨’åƒå¢—æ†Žè‡“è”µè´ˆé€ ä¿ƒå´å‰‡å³æ¯æ‰æŸæ¸¬è¶³é€Ÿä¿—å±žè³Šæ—ç¶šå’è¢–å…¶æƒå­˜å­«å°Šææ‘éœä»–å¤šå¤ªæ±°è©‘å”¾å •å¦¥æƒ°æ‰“æŸèˆµæ¥•é™€é§„é¨¨ä½“å †å¯¾è€å²±å¸¯å¾…æ€ æ…‹æˆ´æ›¿æ³°æ»žèƒŽè…¿è‹”è¢‹è²¸é€€é€®éšŠé»›é¯›ä»£å°å¤§ç¬¬é†é¡Œé·¹æ»ç€§å“å•„å®…æ‰˜æŠžæ‹“æ²¢æ¿¯ç¢è¨—é¸æ¿è«¾èŒ¸å‡§è›¸åª"
  ],
  [
    "9240",
    "å©ä½†é”è¾°å¥ªè„±å·½ç«ªè¾¿æ£šè°·ç‹¸é±ˆæ¨½èª°ä¸¹å˜å˜†å¦æ‹…æŽ¢æ—¦æ­Žæ·¡æ¹›ç‚­çŸ­ç«¯ç®ªç¶»è€½èƒ†è›‹èª•é›å›£å£‡å¼¾æ–­æš–æª€æ®µç”·è«‡å€¤çŸ¥åœ°å¼›æ¥æ™ºæ± ç—´ç¨šç½®è‡´èœ˜é…é¦³ç¯‰ç•œç«¹ç­‘è“„"
  ],
  [
    "9280",
    "é€ç§©çª’èŒ¶å«¡ç€ä¸­ä»²å®™å¿ æŠ½æ˜¼æŸ±æ³¨è™«è¡·è¨»é…Žé‹³é§æ¨—ç€¦çŒªè‹§è‘—è²¯ä¸å…†å‡‹å–‹å¯µå¸–å¸³åºå¼”å¼µå½«å¾´æ‡²æŒ‘æš¢æœæ½®ç‰’ç”ºçœºè´è„¹è…¸è¶èª¿è«œè¶…è·³éŠšé•·é ‚é³¥å‹…æ—ç›´æœ•æ²ˆçè³ƒéŽ®é™³æ´¥å¢œæ¤Žæ§Œè¿½éŽšç—›é€šå¡šæ ‚æŽ´æ§»ä½ƒæ¼¬æŸ˜è¾»è”¦ç¶´é”æ¤¿æ½°åªå£·å¬¬ç´¬çˆªåŠé‡£é¶´äº­ä½Žåœåµå‰ƒè²žå‘ˆå ¤å®šå¸åº•åº­å»·å¼Ÿæ‚ŒæŠµæŒºææ¢¯æ±€ç¢‡ç¦Žç¨‹ç· è‰‡è¨‚è«¦è¹„é€“"
  ],
  [
    "9340",
    "é‚¸é„­é‡˜é¼Žæ³¥æ‘˜æ“¢æ•µæ»´çš„ç¬›é©é‘æººå“²å¾¹æ’¤è½è¿­é‰„å…¸å¡«å¤©å±•åº—æ·»çºç”œè²¼è»¢é¡›ç‚¹ä¼æ®¿æ¾±ç”°é›»å…Žåå µå¡—å¦¬å± å¾’æ–—æœæ¸¡ç™»èŸè³­é€”éƒ½éç ¥ç ºåŠªåº¦åœŸå¥´æ€’å€’å…šå†¬"
  ],
  [
    "9380",
    "å‡åˆ€å”å¡”å¡˜å¥—å®•å³¶å¶‹æ‚¼æŠ•æ­æ±æ¡ƒæ¢¼æ£Ÿç›—æ·˜æ¹¯æ¶›ç¯ç‡ˆå½“ç—˜ç¥·ç­‰ç­”ç­’ç³–çµ±åˆ°è‘£è•©è—¤è¨Žè¬„è±†è¸é€ƒé€é™é™¶é ­é¨°é—˜åƒå‹•åŒå ‚å°Žæ†§æ’žæ´žçž³ç«¥èƒ´è„é“éŠ…å³ é´‡åŒ¿å¾—å¾³æ¶œç‰¹ç£ç¦¿ç¯¤æ¯’ç‹¬èª­æ ƒæ©¡å‡¸çªæ¤´å±Šé³¶è‹«å¯…é…‰ç€žå™¸å±¯æƒ‡æ•¦æ²Œè±šéé “å‘‘æ›‡éˆå¥ˆé‚£å†…ä¹å‡ªè–™è¬Žç˜æºé‹æ¥¢é¦´ç¸„ç•·å—æ¥ è»Ÿé›£æ±äºŒå°¼å¼è¿©åŒ‚è³‘è‚‰è™¹å»¿æ—¥ä¹³å…¥"
  ],
  [
    "9440",
    "å¦‚å°¿éŸ®ä»»å¦Šå¿èªæ¿¡ç¦°ç¥¢å¯§è‘±çŒ«ç†±å¹´å¿µæ»æ’šç‡ƒç²˜ä¹ƒå»¼ä¹‹åŸœåš¢æ‚©æ¿ƒç´èƒ½è„³è†¿è¾²è¦—èš¤å·´æŠŠæ’­è¦‡æ·æ³¢æ´¾ç¶ç ´å©†ç½µèŠ­é¦¬ä¿³å»ƒæ‹æŽ’æ•—æ¯ç›ƒç‰ŒèƒŒè‚ºè¼©é…å€åŸ¹åª’æ¢…"
  ],
  [
    "9480",
    "æ¥³ç…¤ç‹½è²·å£²è³ é™ªé€™è¿ç§¤çŸ§è©ä¼¯å‰¥åšæ‹æŸæ³Šç™½ç®”ç²•èˆ¶è–„è¿«æ›æ¼ çˆ†ç¸›èŽ«é§éº¦å‡½ç®±ç¡²ç®¸è‚‡ç­ˆæ«¨å¹¡è‚Œç•‘ç• å…«é‰¢æºŒç™ºé†—é«ªä¼ç½°æŠœç­é–¥é³©å™ºå¡™è›¤éš¼ä¼´åˆ¤åŠåå›å¸†æ¬æ–‘æ¿æ°¾æ±Žç‰ˆçŠ¯ç­ç•”ç¹èˆ¬è—©è²©ç¯„é‡†ç…©é ’é£¯æŒ½æ™©ç•ªç›¤ç£è•ƒè›®åŒªå‘å¦å¦ƒåº‡å½¼æ‚²æ‰‰æ‰¹æŠ«æ–æ¯”æ³Œç–²çš®ç¢‘ç§˜ç·‹ç½·è‚¥è¢«èª¹è²»é¿éžé£›æ¨‹ç°¸å‚™å°¾å¾®æž‡æ¯˜çµçœ‰ç¾Ž"
  ],
  [
    "9540",
    "é¼»æŸŠç¨—åŒ¹ç–‹é«­å½¦è†è±è‚˜å¼¼å¿…ç•¢ç­†é€¼æ¡§å§«åª›ç´ç™¾è¬¬ä¿µå½ªæ¨™æ°·æ¼‚ç“¢ç¥¨è¡¨è©•è±¹å»Ÿæç—…ç§’è‹—éŒ¨é‹²è’œè›­é°­å“å½¬æ–Œæµœç€•è²§è³“é »æ•ç“¶ä¸ä»˜åŸ å¤«å©¦å¯Œå†¨å¸ƒåºœæ€–æ‰¶æ•·"
  ],
  [
    "9580",
    "æ–§æ™®æµ®çˆ¶ç¬¦è…è†šèŠ™è­œè² è³¦èµ´é˜œé™„ä¾®æ’«æ­¦èˆžè‘¡è•ªéƒ¨å°æ¥“é¢¨è‘ºè•—ä¼å‰¯å¾©å¹…æœç¦è…¹è¤‡è¦†æ·µå¼—æ‰•æ²¸ä»ç‰©é®’åˆ†å»å™´å¢³æ†¤æ‰®ç„šå¥®ç²‰ç³žç´›é›°æ–‡èžä¸™ä½µå…µå¡€å¹£å¹³å¼ŠæŸ„ä¸¦è”½é–‰é™›ç±³é åƒ»å£ç™–ç¢§åˆ¥çž¥è”‘ç®†åå¤‰ç‰‡ç¯‡ç·¨è¾ºè¿”éä¾¿å‹‰å¨©å¼éž­ä¿èˆ—é‹ªåœƒæ•æ­©ç”«è£œè¼”ç©‚å‹Ÿå¢“æ…•æˆŠæš®æ¯ç°¿è©å€£ä¿¸åŒ…å‘†å ±å¥‰å®å³°å³¯å´©åº–æŠ±æ§æ”¾æ–¹æœ‹"
  ],
  [
    "9640",
    "æ³•æ³¡çƒ¹ç ²ç¸«èƒžèŠ³èŒè“¬èœ‚è¤’è¨ªè±Šé‚¦é‹’é£½é³³éµ¬ä¹äº¡å‚å‰–åŠå¦¨å¸½å¿˜å¿™æˆ¿æš´æœ›æŸæ£’å†’ç´¡è‚ªè†¨è¬€è²Œè²¿é‰¾é˜²å é ¬åŒ—åƒ•åœå¢¨æ’²æœ´ç‰§ç¦ç©†é‡¦å‹ƒæ²¡æ®†å €å¹Œå¥”æœ¬ç¿»å‡¡ç›†"
  ],
  [
    "9680",
    "æ‘©ç£¨é­”éº»åŸ‹å¦¹æ˜§æžšæ¯Žå“©æ§™å¹•è†œæž•é®ªæŸ¾é±’æ¡äº¦ä¿£åˆæŠ¹æœ«æ²«è¿„ä¾­ç¹­éº¿ä¸‡æ…¢æº€æ¼«è”“å‘³æœªé­…å·³ç®•å²¬å¯†èœœæ¹Šè“‘ç¨”è„ˆå¦™ç²æ°‘çœ å‹™å¤¢ç„¡ç‰ŸçŸ›éœ§éµ¡æ¤‹å©¿å¨˜å†¥åå‘½æ˜Žç›Ÿè¿·éŠ˜é³´å§ªç‰æ»…å…æ£‰ç¶¿ç·¬é¢éººæ‘¸æ¨¡èŒ‚å¦„å­Ÿæ¯›çŒ›ç›²ç¶²è€—è’™å„²æœ¨é»™ç›®æ¢å‹¿é¤…å°¤æˆ»ç±¾è²°å•æ‚¶ç´‹é–€åŒä¹Ÿå†¶å¤œçˆºè€¶é‡Žå¼¥çŸ¢åŽ„å½¹ç´„è–¬è¨³èºé–æŸ³è–®é‘“æ„‰æ„ˆæ²¹ç™’"
  ],
  [
    "9740",
    "è«­è¼¸å”¯ä½‘å„ªå‹‡å‹å®¥å¹½æ‚ æ†‚æ–æœ‰æŸšæ¹§æ¶ŒçŒ¶çŒ·ç”±ç¥è£•èª˜éŠé‚‘éƒµé›„èžå¤•äºˆä½™ä¸Žèª‰è¼¿é å‚­å¹¼å¦–å®¹åº¸æšæºæ“æ›œæ¥Šæ§˜æ´‹æº¶ç†”ç”¨çª¯ç¾Šè€€è‘‰è“‰è¦è¬¡è¸Šé¥é™½é¤Šæ…¾æŠ‘æ¬²"
  ],
  [
    "9780",
    "æ²ƒæµ´ç¿Œç¿¼æ·€ç¾…èžºè£¸æ¥èŽ±é ¼é›·æ´›çµ¡è½é…ªä¹±åµåµæ¬„æ¿«è—è˜­è¦§åˆ©åå±¥æŽæ¢¨ç†ç’ƒç—¢è£è£¡é‡Œé›¢é™¸å¾‹çŽ‡ç«‹è‘ŽæŽ ç•¥åŠ‰æµæºœç‰ç•™ç¡«ç²’éš†ç«œé¾ä¾¶æ…®æ—…è™œäº†äº®åƒšä¸¡å‡Œå¯®æ–™æ¢æ¶¼çŒŸç™‚çž­ç¨œç³§è‰¯è«’é¼é‡é™µé ˜åŠ›ç·‘å€«åŽ˜æž—æ·‹ç‡ç³è‡¨è¼ªéš£é±—éºŸç‘ å¡æ¶™ç´¯é¡žä»¤ä¼¶ä¾‹å†·åŠ±å¶ºæ€œçŽ²ç¤¼è‹“éˆ´éš·é›¶éœŠéº—é½¢æš¦æ­´åˆ—åŠ£çƒˆè£‚å»‰æ‹æ†æ¼£ç…‰ç°¾ç·´è¯"
  ],
  [
    "9840",
    "è“®é€£éŒ¬å‘‚é­¯æ«“ç‚‰è³‚è·¯éœ²åŠ´å©å»Šå¼„æœ—æ¥¼æ¦”æµªæ¼ç‰¢ç‹¼ç¯­è€è¾è‹éƒŽå…­éº“ç¦„è‚‹éŒ²è«–å€­å’Œè©±æ­ªè³„è„‡æƒ‘æž é·²äº™äº˜é°è©«è—è•¨æ¤€æ¹¾ç¢—è…•"
  ],
  [
    "989f",
    "å¼Œä¸ä¸•ä¸ªä¸±ä¸¶ä¸¼ä¸¿ä¹‚ä¹–ä¹˜äº‚äº…è±«äºŠèˆ’å¼äºŽäºžäºŸäº äº¢äº°äº³äº¶ä»Žä»ä»„ä»†ä»‚ä»—ä»žä»­ä»Ÿä»·ä¼‰ä½šä¼°ä½›ä½ä½—ä½‡ä½¶ä¾ˆä¾ä¾˜ä½»ä½©ä½°ä¾‘ä½¯ä¾†ä¾–å„˜ä¿”ä¿Ÿä¿Žä¿˜ä¿›ä¿‘ä¿šä¿ä¿¤ä¿¥å€šå€¨å€”å€ªå€¥å€…ä¼œä¿¶å€¡å€©å€¬ä¿¾ä¿¯å€‘å€†åƒå‡æœƒå•ååˆåšå–å¬å¸å‚€å‚šå‚…å‚´å‚²"
  ],
  [
    "9940",
    "åƒ‰åƒŠå‚³åƒ‚åƒ–åƒžåƒ¥åƒ­åƒ£åƒ®åƒ¹åƒµå„‰å„å„‚å„–å„•å„”å„šå„¡å„ºå„·å„¼å„»å„¿å…€å…’å…Œå…”å…¢ç«¸å…©å…ªå…®å†€å†‚å›˜å†Œå†‰å†å†‘å†“å†•å†–å†¤å†¦å†¢å†©å†ªå†«å†³å†±å†²å†°å†µå†½å‡…å‡‰å‡›å‡ è™•å‡©å‡­"
  ],
  [
    "9980",
    "å‡°å‡µå‡¾åˆ„åˆ‹åˆ”åˆŽåˆ§åˆªåˆ®åˆ³åˆ¹å‰å‰„å‰‹å‰Œå‰žå‰”å‰ªå‰´å‰©å‰³å‰¿å‰½åŠåŠ”åŠ’å‰±åŠˆåŠ‘è¾¨è¾§åŠ¬åŠ­åŠ¼åŠµå‹å‹å‹—å‹žå‹£å‹¦é£­å‹ å‹³å‹µå‹¸å‹¹åŒ†åŒˆç”¸åŒåŒåŒåŒ•åŒšåŒ£åŒ¯åŒ±åŒ³åŒ¸å€å†å…ä¸—å‰åå‡–åžå©å®å¤˜å»å·åŽ‚åŽ–åŽ åŽ¦åŽ¥åŽ®åŽ°åŽ¶åƒç°’é›™åŸæ›¼ç‡®å®å¨å­åºåå½å‘€å¬å­å¼å®å¶å©åå‘Žå’å‘µå’Žå‘Ÿå‘±å‘·å‘°å’’å‘»å’€å‘¶å’„å’å’†å“‡å’¢å’¸å’¥å’¬å“„å“ˆå’¨"
  ],
  [
    "9a40",
    "å’«å“‚å’¤å’¾å’¼å“˜å“¥å“¦å”å””å“½å“®å“­å“ºå“¢å”¹å•€å•£å•Œå”®å•œå•…å•–å•—å”¸å”³å•å–™å–€å’¯å–Šå–Ÿå•»å•¾å–˜å–žå–®å•¼å–ƒå–©å–‡å–¨å—šå—…å—Ÿå—„å—œå—¤å—”å˜”å—·å˜–å—¾å—½å˜›å—¹å™Žå™ç‡Ÿå˜´å˜¶å˜²å˜¸"
  ],
  [
    "9a80",
    "å™«å™¤å˜¯å™¬å™ªåš†åš€åšŠåš åš”åšåš¥åš®åš¶åš´å›‚åš¼å›å›ƒå›€å›ˆå›Žå›‘å›“å›—å›®å›¹åœ€å›¿åœ„åœ‰åœˆåœ‹åœåœ“åœ˜åœ–å—‡åœœåœ¦åœ·åœ¸åŽåœ»å€åå©åŸ€åžˆå¡å¿åž‰åž“åž åž³åž¤åžªåž°åŸƒåŸ†åŸ”åŸ’åŸ“å ŠåŸ–åŸ£å ‹å ™å å¡²å ¡å¡¢å¡‹å¡°æ¯€å¡’å ½å¡¹å¢…å¢¹å¢Ÿå¢«å¢ºå£žå¢»å¢¸å¢®å£…å£“å£‘å£—å£™å£˜å£¥å£œå£¤å£Ÿå£¯å£ºå£¹å£»å£¼å£½å¤‚å¤Šå¤å¤›æ¢¦å¤¥å¤¬å¤­å¤²å¤¸å¤¾ç«’å¥•å¥å¥Žå¥šå¥˜å¥¢å¥ å¥§å¥¬å¥©"
  ],
  [
    "9b40",
    "å¥¸å¦å¦ä½žä¾«å¦£å¦²å§†å§¨å§œå¦å§™å§šå¨¥å¨Ÿå¨‘å¨œå¨‰å¨šå©€å©¬å©‰å¨µå¨¶å©¢å©ªåªšåª¼åª¾å«‹å«‚åª½å«£å«—å«¦å«©å«–å«ºå«»å¬Œå¬‹å¬–å¬²å«å¬ªå¬¶å¬¾å­ƒå­…å­€å­‘å­•å­šå­›å­¥å­©å­°å­³å­µå­¸æ–ˆå­ºå®€"
  ],
  [
    "9b80",
    "å®ƒå®¦å®¸å¯ƒå¯‡å¯‰å¯”å¯å¯¤å¯¦å¯¢å¯žå¯¥å¯«å¯°å¯¶å¯³å°…å°‡å°ˆå°å°“å° å°¢å°¨å°¸å°¹å±å±†å±Žå±“å±å±å­±å±¬å±®ä¹¢å±¶å±¹å²Œå²‘å²”å¦›å²«å²»å²¶å²¼å²·å³…å²¾å³‡å³™å³©å³½å³ºå³­å¶Œå³ªå´‹å´•å´—åµœå´Ÿå´›å´‘å´”å´¢å´šå´™å´˜åµŒåµ’åµŽåµ‹åµ¬åµ³åµ¶å¶‡å¶„å¶‚å¶¢å¶å¶¬å¶®å¶½å¶å¶·å¶¼å·‰å·å·“å·’å·–å·›å·«å·²å·µå¸‹å¸šå¸™å¸‘å¸›å¸¶å¸·å¹„å¹ƒå¹€å¹Žå¹—å¹”å¹Ÿå¹¢å¹¤å¹‡å¹µå¹¶å¹ºéº¼å¹¿åº å»å»‚å»ˆå»å»"
  ],
  [
    "9c40",
    "å»–å»£å»å»šå»›å»¢å»¡å»¨å»©å»¬å»±å»³å»°å»´å»¸å»¾å¼ƒå¼‰å½å½œå¼‹å¼‘å¼–å¼©å¼­å¼¸å½å½ˆå½Œå½Žå¼¯å½‘å½–å½—å½™å½¡å½­å½³å½·å¾ƒå¾‚å½¿å¾Šå¾ˆå¾‘å¾‡å¾žå¾™å¾˜å¾ å¾¨å¾­å¾¼å¿–å¿»å¿¤å¿¸å¿±å¿æ‚³å¿¿æ€¡æ "
  ],
  [
    "9c80",
    "æ€™æ€æ€©æ€Žæ€±æ€›æ€•æ€«æ€¦æ€æ€ºæšææªæ·æŸæŠæ†ææ£æƒæ¤æ‚æ¬æ«æ™æ‚æ‚æƒ§æ‚ƒæ‚šæ‚„æ‚›æ‚–æ‚—æ‚’æ‚§æ‚‹æƒ¡æ‚¸æƒ æƒ“æ‚´å¿°æ‚½æƒ†æ‚µæƒ˜æ…æ„•æ„†æƒ¶æƒ·æ„€æƒ´æƒºæ„ƒæ„¡æƒ»æƒ±æ„æ„Žæ…‡æ„¾æ„¨æ„§æ…Šæ„¿æ„¼æ„¬æ„´æ„½æ…‚æ…„æ…³æ…·æ…˜æ…™æ…šæ…«æ…´æ…¯æ…¥æ…±æ…Ÿæ…æ…“æ…µæ†™æ†–æ†‡æ†¬æ†”æ†šæ†Šæ†‘æ†«æ†®æ‡Œæ‡Šæ‡‰æ‡·æ‡ˆæ‡ƒæ‡†æ†ºæ‡‹ç½¹æ‡æ‡¦æ‡£æ‡¶æ‡ºæ‡´æ‡¿æ‡½æ‡¼æ‡¾æˆ€æˆˆæˆ‰æˆæˆŒæˆ”æˆ›"
  ],
  [
    "9d40",
    "æˆžæˆ¡æˆªæˆ®æˆ°æˆ²æˆ³æ‰æ‰Žæ‰žæ‰£æ‰›æ‰ æ‰¨æ‰¼æŠ‚æŠ‰æ‰¾æŠ’æŠ“æŠ–æ‹”æŠƒæŠ”æ‹—æ‹‘æŠ»æ‹æ‹¿æ‹†æ“”æ‹ˆæ‹œæ‹Œæ‹Šæ‹‚æ‹‡æŠ›æ‹‰æŒŒæ‹®æ‹±æŒ§æŒ‚æŒˆæ‹¯æ‹µææŒ¾ææœææŽ–æŽŽæŽ€æŽ«æ¶æŽ£æŽæŽ‰æŽŸæŽµæ«"
  ],
  [
    "9d80",
    "æ©æŽ¾æ©æ€æ†æ£æ‰æ’æ¶æ„æ–æ´æ†æ“æ¦æ¶æ”æ—æ¨ææ‘§æ‘¯æ‘¶æ‘Žæ”ªæ’•æ’“æ’¥æ’©æ’ˆæ’¼æ“šæ“’æ“…æ“‡æ’»æ“˜æ“‚æ“±æ“§èˆ‰æ“ æ“¡æŠ¬æ“£æ“¯æ”¬æ“¶æ“´æ“²æ“ºæ”€æ“½æ”˜æ”œæ”…æ”¤æ”£æ”«æ”´æ”µæ”·æ”¶æ”¸ç•‹æ•ˆæ•–æ••æ•æ•˜æ•žæ•æ•²æ•¸æ–‚æ–ƒè®Šæ–›æ–Ÿæ–«æ–·æ—ƒæ—†æ—æ—„æ—Œæ—’æ—›æ—™æ— æ—¡æ—±æ²æ˜Šæ˜ƒæ—»æ³æ˜µæ˜¶æ˜´æ˜œæ™æ™„æ™‰æ™æ™žæ™æ™¤æ™§æ™¨æ™Ÿæ™¢æ™°æšƒæšˆæšŽæš‰æš„æš˜æšæ›æš¹æ›‰æš¾æš¼"
  ],
  [
    "9e40",
    "æ›„æš¸æ›–æ›šæ› æ˜¿æ›¦æ›©æ›°æ›µæ›·æœæœ–æœžæœ¦æœ§éœ¸æœ®æœ¿æœ¶ææœ¸æœ·æ†æžæ æ™æ£æ¤æž‰æ°æž©æ¼æªæžŒæž‹æž¦æž¡æž…æž·æŸ¯æž´æŸ¬æž³æŸ©æž¸æŸ¤æŸžæŸæŸ¢æŸ®æž¹æŸŽæŸ†æŸ§æªœæ žæ¡†æ ©æ¡€æ¡æ ²æ¡Ž"
  ],
  [
    "9e80",
    "æ¢³æ «æ¡™æ¡£æ¡·æ¡¿æ¢Ÿæ¢æ¢­æ¢”æ¢æ¢›æ¢ƒæª®æ¢¹æ¡´æ¢µæ¢ æ¢ºæ¤æ¢æ¡¾æ¤æ£Šæ¤ˆæ£˜æ¤¢æ¤¦æ£¡æ¤Œæ£æ£”æ£§æ£•æ¤¶æ¤’æ¤„æ£—æ££æ¤¥æ£¹æ£ æ£¯æ¤¨æ¤ªæ¤šæ¤£æ¤¡æ£†æ¥¹æ¥·æ¥œæ¥¸æ¥«æ¥”æ¥¾æ¥®æ¤¹æ¥´æ¤½æ¥™æ¤°æ¥¡æ¥žæ¥æ¦æ¥ªæ¦²æ¦®æ§æ¦¿æ§æ§“æ¦¾æ§Žå¯¨æ§Šæ§æ¦»æ§ƒæ¦§æ¨®æ¦‘æ¦ æ¦œæ¦•æ¦´æ§žæ§¨æ¨‚æ¨›æ§¿æ¬Šæ§¹æ§²æ§§æ¨…æ¦±æ¨žæ§­æ¨”æ§«æ¨Šæ¨’æ«æ¨£æ¨“æ©„æ¨Œæ©²æ¨¶æ©¸æ©‡æ©¢æ©™æ©¦æ©ˆæ¨¸æ¨¢æªæªæª æª„æª¢æª£"
  ],
  [
    "9f40",
    "æª—è˜—æª»æ«ƒæ«‚æª¸æª³æª¬æ«žæ«‘æ«Ÿæªªæ«šæ«ªæ«»æ¬…è˜–æ«ºæ¬’æ¬–é¬±æ¬Ÿæ¬¸æ¬·ç›œæ¬¹é£®æ­‡æ­ƒæ­‰æ­æ­™æ­”æ­›æ­Ÿæ­¡æ­¸æ­¹æ­¿æ®€æ®„æ®ƒæ®æ®˜æ®•æ®žæ®¤æ®ªæ®«æ®¯æ®²æ®±æ®³æ®·æ®¼æ¯†æ¯‹æ¯“æ¯Ÿæ¯¬æ¯«æ¯³æ¯¯"
  ],
  [
    "9f80",
    "éº¾æ°ˆæ°“æ°”æ°›æ°¤æ°£æ±žæ±•æ±¢æ±ªæ²‚æ²æ²šæ²æ²›æ±¾æ±¨æ±³æ²’æ²æ³„æ³±æ³“æ²½æ³—æ³…æ³æ²®æ²±æ²¾æ²ºæ³›æ³¯æ³™æ³ªæ´Ÿè¡æ´¶æ´«æ´½æ´¸æ´™æ´µæ´³æ´’æ´Œæµ£æ¶“æµ¤æµšæµ¹æµ™æ¶Žæ¶•æ¿¤æ¶…æ·¹æ¸•æ¸Šæ¶µæ·‡æ·¦æ¶¸æ·†æ·¬æ·žæ·Œæ·¨æ·’æ·…æ·ºæ·™æ·¤æ·•æ·ªæ·®æ¸­æ¹®æ¸®æ¸™æ¹²æ¹Ÿæ¸¾æ¸£æ¹«æ¸«æ¹¶æ¹æ¸Ÿæ¹ƒæ¸ºæ¹Žæ¸¤æ»¿æ¸æ¸¸æº‚æºªæº˜æ»‰æº·æ»“æº½æº¯æ»„æº²æ»”æ»•æºæº¥æ»‚æºŸæ½æ¼‘çŒæ»¬æ»¸æ»¾æ¼¿æ»²æ¼±æ»¯æ¼²æ»Œ"
  ],
  [
    "e040",
    "æ¼¾æ¼“æ»·æ¾†æ½ºæ½¸æ¾æ¾€æ½¯æ½›æ¿³æ½­æ¾‚æ½¼æ½˜æ¾Žæ¾‘æ¿‚æ½¦æ¾³æ¾£æ¾¡æ¾¤æ¾¹æ¿†æ¾ªæ¿Ÿæ¿•æ¿¬æ¿”æ¿˜æ¿±æ¿®æ¿›ç€‰ç€‹æ¿ºç€‘ç€ç€æ¿¾ç€›ç€šæ½´ç€ç€˜ç€Ÿç€°ç€¾ç€²ç‘ç£ç‚™ç‚’ç‚¯çƒ±ç‚¬ç‚¸ç‚³ç‚®çƒŸçƒ‹çƒ"
  ],
  [
    "e080",
    "çƒ™ç„‰çƒ½ç„œç„™ç…¥ç…•ç†ˆç…¦ç…¢ç…Œç…–ç…¬ç†ç‡»ç†„ç†•ç†¨ç†¬ç‡—ç†¹ç†¾ç‡’ç‡‰ç‡”ç‡Žç‡ ç‡¬ç‡§ç‡µç‡¼ç‡¹ç‡¿çˆçˆçˆ›çˆ¨çˆ­çˆ¬çˆ°çˆ²çˆ»çˆ¼çˆ¿ç‰€ç‰†ç‰‹ç‰˜ç‰´ç‰¾çŠ‚çŠçŠ‡çŠ’çŠ–çŠ¢çŠ§çŠ¹çŠ²ç‹ƒç‹†ç‹„ç‹Žç‹’ç‹¢ç‹ ç‹¡ç‹¹ç‹·å€çŒ—çŒŠçŒœçŒ–çŒçŒ´çŒ¯çŒ©çŒ¥çŒ¾çŽçé»˜ç—çªç¨ç°ç¸çµç»çºçˆçŽ³çŽçŽ»ç€ç¥ç®çžç’¢ç…ç‘¯ç¥ç¸ç²çºç‘•ç¿ç‘Ÿç‘™ç‘ç‘œç‘©ç‘°ç‘£ç‘ªç‘¶ç‘¾ç’‹ç’žç’§ç“Šç“ç“”ç±"
  ],
  [
    "e140",
    "ç“ ç“£ç“§ç“©ç“®ç“²ç“°ç“±ç“¸ç“·ç”„ç”ƒç”…ç”Œç”Žç”ç”•ç”“ç”žç”¦ç”¬ç”¼ç•„ç•ç•Šç•‰ç•›ç•†ç•šç•©ç•¤ç•§ç•«ç•­ç•¸ç•¶ç–†ç–‡ç•´ç–Šç–‰ç–‚ç–”ç–šç–ç–¥ç–£ç—‚ç–³ç—ƒç–µç–½ç–¸ç–¼ç–±ç—ç—Šç—’ç—™ç—£ç—žç—¾ç—¿"
  ],
  [
    "e180",
    "ç—¼ç˜ç—°ç—ºç—²ç—³ç˜‹ç˜ç˜‰ç˜Ÿç˜§ç˜ ç˜¡ç˜¢ç˜¤ç˜´ç˜°ç˜»ç™‡ç™ˆç™†ç™œç™˜ç™¡ç™¢ç™¨ç™©ç™ªç™§ç™¬ç™°ç™²ç™¶ç™¸ç™¼çš€çšƒçšˆçš‹çšŽçš–çš“çš™çššçš°çš´çš¸çš¹çšºç›‚ç›ç›–ç›’ç›žç›¡ç›¥ç›§ç›ªè˜¯ç›»çœˆçœ‡çœ„çœ©çœ¤çœžçœ¥çœ¦çœ›çœ·çœ¸ç‡çšç¨ç«ç›ç¥ç¿ç¾ç¹çžŽçž‹çž‘çž çžžçž°çž¶çž¹çž¿çž¼çž½çž»çŸ‡çŸçŸ—çŸšçŸœçŸ£çŸ®çŸ¼ç Œç ’ç¤¦ç  ç¤ªç¡…ç¢Žç¡´ç¢†ç¡¼ç¢šç¢Œç¢£ç¢µç¢ªç¢¯ç£‘ç£†ç£‹ç£”ç¢¾ç¢¼ç£…ç£Šç£¬"
  ],
  [
    "e240",
    "ç£§ç£šç£½ç£´ç¤‡ç¤’ç¤‘ç¤™ç¤¬ç¤«ç¥€ç¥ ç¥—ç¥Ÿç¥šç¥•ç¥“ç¥ºç¥¿ç¦Šç¦ç¦§é½‹ç¦ªç¦®ç¦³ç¦¹ç¦ºç§‰ç§•ç§§ç§¬ç§¡ç§£ç¨ˆç¨ç¨˜ç¨™ç¨ ç¨Ÿç¦€ç¨±ç¨»ç¨¾ç¨·ç©ƒç©—ç©‰ç©¡ç©¢ç©©é¾ç©°ç©¹ç©½çªˆçª—çª•çª˜çª–çª©ç«ˆçª°"
  ],
  [
    "e280",
    "çª¶ç«…ç«„çª¿é‚ƒç«‡ç«Šç«ç«ç«•ç«“ç«™ç«šç«ç«¡ç«¢ç«¦ç«­ç«°ç¬‚ç¬ç¬Šç¬†ç¬³ç¬˜ç¬™ç¬žç¬µç¬¨ç¬¶ç­ç­ºç¬„ç­ç¬‹ç­Œç­…ç­µç­¥ç­´ç­§ç­°ç­±ç­¬ç­®ç®ç®˜ç®Ÿç®ç®œç®šç®‹ç®’ç®ç­ç®™ç¯‹ç¯ç¯Œç¯ç®´ç¯†ç¯ç¯©ç°‘ç°”ç¯¦ç¯¥ç± ç°€ç°‡ç°“ç¯³ç¯·ç°—ç°ç¯¶ç°£ç°§ç°ªç°Ÿç°·ç°«ç°½ç±Œç±ƒç±”ç±ç±€ç±ç±˜ç±Ÿç±¤ç±–ç±¥ç±¬ç±µç²ƒç²ç²¤ç²­ç²¢ç²«ç²¡ç²¨ç²³ç²²ç²±ç²®ç²¹ç²½ç³€ç³…ç³‚ç³˜ç³’ç³œç³¢é¬»ç³¯ç³²ç³´ç³¶ç³ºç´†"
  ],
  [
    "e340",
    "ç´‚ç´œç´•ç´Šçµ…çµ‹ç´®ç´²ç´¿ç´µçµ†çµ³çµ–çµŽçµ²çµ¨çµ®çµçµ£ç¶“ç¶‰çµ›ç¶çµ½ç¶›ç¶ºç¶®ç¶£ç¶µç·‡ç¶½ç¶«ç¸½ç¶¢ç¶¯ç·œç¶¸ç¶Ÿç¶°ç·˜ç·ç·¤ç·žç·»ç·²ç·¡ç¸…ç¸Šç¸£ç¸¡ç¸’ç¸±ç¸Ÿç¸‰ç¸‹ç¸¢ç¹†ç¹¦ç¸»ç¸µç¸¹ç¹ƒç¸·"
  ],
  [
    "e380",
    "ç¸²ç¸ºç¹§ç¹ç¹–ç¹žç¹™ç¹šç¹¹ç¹ªç¹©ç¹¼ç¹»çºƒç·•ç¹½è¾®ç¹¿çºˆçº‰çºŒçº’çºçº“çº”çº–çºŽçº›çºœç¼¸ç¼ºç½…ç½Œç½ç½Žç½ç½‘ç½•ç½”ç½˜ç½Ÿç½ ç½¨ç½©ç½§ç½¸ç¾‚ç¾†ç¾ƒç¾ˆç¾‡ç¾Œç¾”ç¾žç¾ç¾šç¾£ç¾¯ç¾²ç¾¹ç¾®ç¾¶ç¾¸è­±ç¿…ç¿†ç¿Šç¿•ç¿”ç¿¡ç¿¦ç¿©ç¿³ç¿¹é£œè€†è€„è€‹è€’è€˜è€™è€œè€¡è€¨è€¿è€»èŠè†è’è˜èšèŸè¢è¨è³è²è°è¶è¹è½è¿è‚„è‚†è‚…è‚›è‚“è‚šè‚­å†è‚¬èƒ›èƒ¥èƒ™èƒèƒ„èƒšèƒ–è„‰èƒ¯èƒ±è„›è„©è„£è„¯è…‹"
  ],
  [
    "e440",
    "éš‹è…†è„¾è…“è…‘èƒ¼è…±è…®è…¥è…¦è…´è†ƒè†ˆè†Šè†€è†‚è† è†•è†¤è†£è…Ÿè†“è†©è†°è†µè†¾è†¸è†½è‡€è‡‚è†ºè‡‰è‡è‡‘è‡™è‡˜è‡ˆè‡šè‡Ÿè‡ è‡§è‡ºè‡»è‡¾èˆèˆ‚èˆ…èˆ‡èˆŠèˆèˆèˆ–èˆ©èˆ«èˆ¸èˆ³è‰€è‰™è‰˜è‰è‰šè‰Ÿè‰¤"
  ],
  [
    "e480",
    "è‰¢è‰¨è‰ªè‰«èˆ®è‰±è‰·è‰¸è‰¾èŠèŠ’èŠ«èŠŸèŠ»èŠ¬è‹¡è‹£è‹Ÿè‹’è‹´è‹³è‹ºèŽ“èŒƒè‹»è‹¹è‹žèŒ†è‹œèŒ‰è‹™èŒµèŒ´èŒ–èŒ²èŒ±è€èŒ¹èè…èŒ¯èŒ«èŒ—èŒ˜èŽ…èŽšèŽªèŽŸèŽ¢èŽ–èŒ£èŽŽèŽ‡èŽŠè¼èŽµè³èµèŽ èŽ‰èŽ¨è´è“è«èŽè½èƒè˜è‹èè·è‡è è²èè¢è èŽ½è¸è”†è»è‘­èªè¼è•šè’„è‘·è‘«è’­è‘®è’‚è‘©è‘†è¬è‘¯è‘¹èµè“Šè‘¢è’¹è’¿è’Ÿè“™è“è’»è“šè“è“è“†è“–è’¡è”¡è“¿è“´è”—è”˜è”¬è”Ÿè”•è””è“¼è•€è•£è•˜è•ˆ"
  ],
  [
    "e540",
    "è•è˜‚è•‹è••è–€è–¤è–ˆè–‘è–Šè–¨è•­è–”è–›è—ªè–‡è–œè•·è•¾è–è—‰è–ºè—è–¹è—è—•è—è—¥è—œè—¹è˜Šè˜“è˜‹è—¾è—ºè˜†è˜¢è˜šè˜°è˜¿è™ä¹•è™”è™Ÿè™§è™±èš“èš£èš©èšªèš‹èšŒèš¶èš¯è›„è›†èš°è›‰è £èš«è›”è›žè›©è›¬"
  ],
  [
    "e580",
    "è›Ÿè››è›¯èœ’èœ†èœˆèœ€èœƒè›»èœ‘èœ‰èœè›¹èœŠèœ´èœ¿èœ·èœ»èœ¥èœ©èœšè èŸè¸èŒèŽè´è—è¨è®è™è“è£èªè …èž¢èžŸèž‚èž¯èŸ‹èž½èŸ€èŸé›–èž«èŸ„èž³èŸ‡èŸ†èž»èŸ¯èŸ²èŸ è è èŸ¾èŸ¶èŸ·è ŽèŸ’è ‘è –è •è ¢è ¡è ±è ¶è ¹è §è »è¡„è¡‚è¡’è¡™è¡žè¡¢è¡«è¢è¡¾è¢žè¡µè¡½è¢µè¡²è¢‚è¢—è¢’è¢®è¢™è¢¢è¢è¢¤è¢°è¢¿è¢±è£ƒè£„è£”è£˜è£™è£è£¹è¤‚è£¼è£´è£¨è£²è¤„è¤Œè¤Šè¤“è¥ƒè¤žè¤¥è¤ªè¤«è¥è¥„è¤»è¤¶è¤¸è¥Œè¤è¥ è¥ž"
  ],
  [
    "e640",
    "è¥¦è¥¤è¥­è¥ªè¥¯è¥´è¥·è¥¾è¦ƒè¦ˆè¦Šè¦“è¦˜è¦¡è¦©è¦¦è¦¬è¦¯è¦²è¦ºè¦½è¦¿è§€è§šè§œè§è§§è§´è§¸è¨ƒè¨–è¨è¨Œè¨›è¨è¨¥è¨¶è©è©›è©’è©†è©ˆè©¼è©­è©¬è©¢èª…èª‚èª„èª¨èª¡èª‘èª¥èª¦èªšèª£è«„è«è«‚è«šè««è«³è«§"
  ],
  [
    "e680",
    "è«¤è«±è¬”è« è«¢è«·è«žè«›è¬Œè¬‡è¬šè«¡è¬–è¬è¬—è¬ è¬³éž«è¬¦è¬«è¬¾è¬¨è­è­Œè­è­Žè­‰è­–è­›è­šè­«è­Ÿè­¬è­¯è­´è­½è®€è®Œè®Žè®’è®“è®–è®™è®šè°ºè±è°¿è±ˆè±Œè±Žè±è±•è±¢è±¬è±¸è±ºè²‚è²‰è²…è²Šè²è²Žè²”è±¼è²˜æˆè²­è²ªè²½è²²è²³è²®è²¶è³ˆè³è³¤è³£è³šè³½è³ºè³»è´„è´…è´Šè´‡è´è´è´é½Žè´“è³è´”è´–èµ§èµ­èµ±èµ³è¶è¶™è·‚è¶¾è¶ºè·è·šè·–è·Œè·›è·‹è·ªè·«è·Ÿè·£è·¼è¸ˆè¸‰è·¿è¸è¸žè¸è¸Ÿè¹‚è¸µè¸°è¸´è¹Š"
  ],
  [
    "e740",
    "è¹‡è¹‰è¹Œè¹è¹ˆè¹™è¹¤è¹ è¸ªè¹£è¹•è¹¶è¹²è¹¼èºèº‡èº…èº„èº‹èºŠèº“èº‘èº”èº™èºªèº¡èº¬èº°è»†èº±èº¾è»…è»ˆè»‹è»›è»£è»¼è»»è»«è»¾è¼Šè¼…è¼•è¼’è¼™è¼“è¼œè¼Ÿè¼›è¼Œè¼¦è¼³è¼»è¼¹è½…è½‚è¼¾è½Œè½‰è½†è½Žè½—è½œ"
  ],
  [
    "e780",
    "è½¢è½£è½¤è¾œè¾Ÿè¾£è¾­è¾¯è¾·è¿šè¿¥è¿¢è¿ªè¿¯é‚‡è¿´é€…è¿¹è¿ºé€‘é€•é€¡é€é€žé€–é€‹é€§é€¶é€µé€¹è¿¸ééé‘é’é€Žé‰é€¾é–é˜éžé¨é¯é¶éš¨é²é‚‚é½é‚é‚€é‚Šé‚‰é‚é‚¨é‚¯é‚±é‚µéƒ¢éƒ¤æ‰ˆéƒ›é„‚é„’é„™é„²é„°é…Šé…–é…˜é…£é…¥é…©é…³é…²é†‹é†‰é†‚é†¢é†«é†¯é†ªé†µé†´é†ºé‡€é‡é‡‰é‡‹é‡é‡–é‡Ÿé‡¡é‡›é‡¼é‡µé‡¶éˆžé‡¿éˆ”éˆ¬éˆ•éˆ‘é‰žé‰—é‰…é‰‰é‰¤é‰ˆéŠ•éˆ¿é‰‹é‰éŠœéŠ–éŠ“éŠ›é‰šé‹éŠ¹éŠ·é‹©éŒé‹ºé„éŒ®"
  ],
  [
    "e840",
    "éŒ™éŒ¢éŒšéŒ£éŒºéŒµéŒ»éœé é¼é®é–éŽ°éŽ¬éŽ­éŽ”éŽ¹é–é—é¨é¥é˜éƒéééˆé¤éšé”é“éƒé‡éé¶é«éµé¡éºé‘é‘’é‘„é‘›é‘ é‘¢é‘žé‘ªéˆ©é‘°é‘µé‘·é‘½é‘šé‘¼é‘¾é’é‘¿é–‚é–‡é–Šé–”é––é–˜é–™"
  ],
  [
    "e880",
    "é– é–¨é–§é–­é–¼é–»é–¹é–¾é—Šæ¿¶é—ƒé—é—Œé—•é—”é—–é—œé—¡é—¥é—¢é˜¡é˜¨é˜®é˜¯é™‚é™Œé™é™‹é™·é™œé™žé™é™Ÿé™¦é™²é™¬éšéš˜éš•éš—éšªéš§éš±éš²éš°éš´éš¶éš¸éš¹é›Žé›‹é›‰é›è¥é›œéœé›•é›¹éœ„éœ†éœˆéœ“éœŽéœ‘éœéœ–éœ™éœ¤éœªéœ°éœ¹éœ½éœ¾é„é†éˆé‚é‰éœé é¤é¦é¨å‹’é«é±é¹éž…é¼éžéºéž†éž‹éžéžéžœéž¨éž¦éž£éž³éž´éŸƒéŸ†éŸˆéŸ‹éŸœéŸ­é½éŸ²ç«ŸéŸ¶éŸµé é Œé ¸é ¤é ¡é ·é ½é¡†é¡é¡‹é¡«é¡¯é¡°"
  ],
  [
    "e940",
    "é¡±é¡´é¡³é¢ªé¢¯é¢±é¢¶é£„é£ƒé£†é£©é£«é¤ƒé¤‰é¤’é¤”é¤˜é¤¡é¤é¤žé¤¤é¤ é¤¬é¤®é¤½é¤¾é¥‚é¥‰é¥…é¥é¥‹é¥‘é¥’é¥Œé¥•é¦—é¦˜é¦¥é¦­é¦®é¦¼é§Ÿé§›é§é§˜é§‘é§­é§®é§±é§²é§»é§¸é¨é¨é¨…é§¢é¨™é¨«é¨·é©…é©‚é©€é©ƒ"
  ],
  [
    "e980",
    "é¨¾é©•é©é©›é©—é©Ÿé©¢é©¥é©¤é©©é©«é©ªéª­éª°éª¼é«€é«é«‘é«“é«”é«žé«Ÿé«¢é«£é«¦é«¯é««é«®é«´é«±é«·é«»é¬†é¬˜é¬šé¬Ÿé¬¢é¬£é¬¥é¬§é¬¨é¬©é¬ªé¬®é¬¯é¬²é­„é­ƒé­é­é­Žé­‘é­˜é­´é®“é®ƒé®‘é®–é®—é®Ÿé® é®¨é®´é¯€é¯Šé®¹é¯†é¯é¯‘é¯’é¯£é¯¢é¯¤é¯”é¯¡é°ºé¯²é¯±é¯°é°•é°”é°‰é°“é°Œé°†é°ˆé°’é°Šé°„é°®é°›é°¥é°¤é°¡é°°é±‡é°²é±†é°¾é±šé± é±§é±¶é±¸é³§é³¬é³°é´‰é´ˆé³«é´ƒé´†é´ªé´¦é¶¯é´£é´Ÿéµ„é´•é´’éµé´¿é´¾éµ†éµˆ"
  ],
  [
    "ea40",
    "éµéµžéµ¤éµ‘éµéµ™éµ²é¶‰é¶‡é¶«éµ¯éµºé¶šé¶¤é¶©é¶²é·„é·é¶»é¶¸é¶ºé·†é·é·‚é·™é·“é·¸é·¦é·­é·¯é·½é¸šé¸›é¸žé¹µé¹¹é¹½éºéºˆéº‹éºŒéº’éº•éº‘éºéº¥éº©éº¸éºªéº­é¡é»Œé»Žé»é»é»”é»œé»žé»é» é»¥é»¨é»¯"
  ],
  [
    "ea80",
    "é»´é»¶é»·é»¹é»»é»¼é»½é¼‡é¼ˆçš·é¼•é¼¡é¼¬é¼¾é½Šé½’é½”é½£é½Ÿé½ é½¡é½¦é½§é½¬é½ªé½·é½²é½¶é¾•é¾œé¾ å ¯æ§‡é™ç‘¤å‡œç†™"
  ],
  [
    "ed40",
    "çºŠè¤œéˆéŠˆè“œä¿‰ç‚»æ˜±æ£ˆé‹¹æ›»å½…ä¸¨ä»¡ä»¼ä¼€ä¼ƒä¼¹ä½–ä¾’ä¾Šä¾šä¾”ä¿å€å€¢ä¿¿å€žå†å°å‚å‚”åƒ´åƒ˜å…Šå…¤å†å†¾å‡¬åˆ•åŠœåŠ¦å‹€å‹›åŒ€åŒ‡åŒ¤å²åŽ“åŽ²åï¨Žå’œå’Šå’©å“¿å–†å™å¥åž¬åŸˆåŸ‡ï¨"
  ],
  [
    "ed80",
    "ï¨å¢žå¢²å¤‹å¥“å¥›å¥å¥£å¦¤å¦ºå­–å¯€ç”¯å¯˜å¯¬å°žå²¦å²ºå³µå´§åµ“ï¨‘åµ‚åµ­å¶¸å¶¹å·å¼¡å¼´å½§å¾·å¿žææ‚…æ‚Šæƒžæƒ•æ„ æƒ²æ„‘æ„·æ„°æ†˜æˆ“æŠ¦æµæ‘ æ’æ“Žæ•Žæ˜€æ˜•æ˜»æ˜‰æ˜®æ˜žæ˜¤æ™¥æ™—æ™™ï¨’æ™³æš™æš æš²æš¿æ›ºæœŽï¤©æ¦æž»æ¡’æŸ€æ æ¡„æ£ï¨“æ¥¨ï¨”æ¦˜æ§¢æ¨°æ©«æ©†æ©³æ©¾æ«¢æ«¤æ¯–æ°¿æ±œæ²†æ±¯æ³šæ´„æ¶‡æµ¯æ¶–æ¶¬æ·æ·¸æ·²æ·¼æ¸¹æ¹œæ¸§æ¸¼æº¿æ¾ˆæ¾µæ¿µç€…ç€‡ç€¨ç‚…ç‚«ç„ç„„ç…œç…†ç…‡ï¨•ç‡ç‡¾çŠ±"
  ],
  [
    "ee40",
    "çŠ¾çŒ¤ï¨–ç·çŽ½ç‰ç–ç£ç’ç‡çµç¦çªç©ç®ç‘¢ç’‰ç’Ÿç”ç•¯çš‚çšœçšžçš›çš¦ï¨—ç†åŠ¯ç ¡ç¡Žç¡¤ç¡ºç¤°ï¨˜ï¨™ï¨šç¦”ï¨›ç¦›ç«‘ç«§ï¨œç««ç®žï¨çµˆçµœç¶·ç¶ ç·–ç¹’ç½‡ç¾¡ï¨žèŒè¢è¿è‡è¶è‘ˆè’´è•“è•™"
  ],
  [
    "ee80",
    "è•«ï¨Ÿè–°ï¨ ï¨¡è ‡è£µè¨’è¨·è©¹èª§èª¾è«Ÿï¨¢è«¶è­“è­¿è³°è³´è´’èµ¶ï¨£è»ï¨¤ï¨¥é§éƒžï¨¦é„•é„§é‡šé‡—é‡žé‡­é‡®é‡¤é‡¥éˆ†éˆéˆŠéˆºé‰€éˆ¼é‰Žé‰™é‰‘éˆ¹é‰§éŠ§é‰·é‰¸é‹§é‹—é‹™é‹ï¨§é‹•é‹ é‹“éŒ¥éŒ¡é‹»ï¨¨éŒžé‹¿éŒéŒ‚é°é—éŽ¤é†éžé¸é±é‘…é‘ˆé–’ï§œï¨©éšéš¯éœ³éœ»éƒééé‘é•é¡—é¡¥ï¨ªï¨«é¤§ï¨¬é¦žé©Žé«™é«œé­µé­²é®é®±é®»é°€éµ°éµ«ï¨­é¸™é»‘"
  ],
  [
    "eeef",
    "â…°",
    9,
    "ï¿¢ï¿¤ï¼‡ï¼‚"
  ],
  [
    "f040",
    "î€€",
    62
  ],
  [
    "f080",
    "î€¿",
    124
  ],
  [
    "f140",
    "î‚¼",
    62
  ],
  [
    "f180",
    "îƒ»",
    124
  ],
  [
    "f240",
    "î…¸",
    62
  ],
  [
    "f280",
    "î†·",
    124
  ],
  [
    "f340",
    "îˆ´",
    62
  ],
  [
    "f380",
    "î‰³",
    124
  ],
  [
    "f440",
    "î‹°",
    62
  ],
  [
    "f480",
    "îŒ¯",
    124
  ],
  [
    "f540",
    "îŽ¬",
    62
  ],
  [
    "f580",
    "î«",
    124
  ],
  [
    "f640",
    "î‘¨",
    62
  ],
  [
    "f680",
    "î’§",
    124
  ],
  [
    "f740",
    "î”¤",
    62
  ],
  [
    "f780",
    "î•£",
    124
  ],
  [
    "f840",
    "î— ",
    62
  ],
  [
    "f880",
    "î˜Ÿ",
    124
  ],
  [
    "f940",
    "îšœ"
  ],
  [
    "fa40",
    "â…°",
    9,
    "â… ",
    9,
    "ï¿¢ï¿¤ï¼‡ï¼‚ãˆ±â„–â„¡âˆµçºŠè¤œéˆéŠˆè“œä¿‰ç‚»æ˜±æ£ˆé‹¹æ›»å½…ä¸¨ä»¡ä»¼ä¼€ä¼ƒä¼¹ä½–ä¾’ä¾Šä¾šä¾”ä¿å€å€¢ä¿¿å€žå†å°å‚å‚”åƒ´åƒ˜å…Š"
  ],
  [
    "fa80",
    "å…¤å†å†¾å‡¬åˆ•åŠœåŠ¦å‹€å‹›åŒ€åŒ‡åŒ¤å²åŽ“åŽ²åï¨Žå’œå’Šå’©å“¿å–†å™å¥åž¬åŸˆåŸ‡ï¨ï¨å¢žå¢²å¤‹å¥“å¥›å¥å¥£å¦¤å¦ºå­–å¯€ç”¯å¯˜å¯¬å°žå²¦å²ºå³µå´§åµ“ï¨‘åµ‚åµ­å¶¸å¶¹å·å¼¡å¼´å½§å¾·å¿žææ‚…æ‚Šæƒžæƒ•æ„ æƒ²æ„‘æ„·æ„°æ†˜æˆ“æŠ¦æµæ‘ æ’æ“Žæ•Žæ˜€æ˜•æ˜»æ˜‰æ˜®æ˜žæ˜¤æ™¥æ™—æ™™ï¨’æ™³æš™æš æš²æš¿æ›ºæœŽï¤©æ¦æž»æ¡’æŸ€æ æ¡„æ£ï¨“æ¥¨ï¨”æ¦˜æ§¢æ¨°æ©«æ©†æ©³æ©¾æ«¢æ«¤æ¯–æ°¿æ±œæ²†æ±¯æ³šæ´„æ¶‡æµ¯"
  ],
  [
    "fb40",
    "æ¶–æ¶¬æ·æ·¸æ·²æ·¼æ¸¹æ¹œæ¸§æ¸¼æº¿æ¾ˆæ¾µæ¿µç€…ç€‡ç€¨ç‚…ç‚«ç„ç„„ç…œç…†ç…‡ï¨•ç‡ç‡¾çŠ±çŠ¾çŒ¤ï¨–ç·çŽ½ç‰ç–ç£ç’ç‡çµç¦çªç©ç®ç‘¢ç’‰ç’Ÿç”ç•¯çš‚çšœçšžçš›çš¦ï¨—ç†åŠ¯ç ¡ç¡Žç¡¤ç¡ºç¤°ï¨˜ï¨™"
  ],
  [
    "fb80",
    "ï¨šç¦”ï¨›ç¦›ç«‘ç«§ï¨œç««ç®žï¨çµˆçµœç¶·ç¶ ç·–ç¹’ç½‡ç¾¡ï¨žèŒè¢è¿è‡è¶è‘ˆè’´è•“è•™è•«ï¨Ÿè–°ï¨ ï¨¡è ‡è£µè¨’è¨·è©¹èª§èª¾è«Ÿï¨¢è«¶è­“è­¿è³°è³´è´’èµ¶ï¨£è»ï¨¤ï¨¥é§éƒžï¨¦é„•é„§é‡šé‡—é‡žé‡­é‡®é‡¤é‡¥éˆ†éˆéˆŠéˆºé‰€éˆ¼é‰Žé‰™é‰‘éˆ¹é‰§éŠ§é‰·é‰¸é‹§é‹—é‹™é‹ï¨§é‹•é‹ é‹“éŒ¥éŒ¡é‹»ï¨¨éŒžé‹¿éŒéŒ‚é°é—éŽ¤é†éžé¸é±é‘…é‘ˆé–’ï§œï¨©éšéš¯éœ³éœ»éƒééé‘é•é¡—é¡¥ï¨ªï¨«é¤§ï¨¬é¦žé©Žé«™"
  ],
  [
    "fc40",
    "é«œé­µé­²é®é®±é®»é°€éµ°éµ«ï¨­é¸™é»‘"
  ]
];
const require$$1$1 = /* @__PURE__ */ JSON.parse('[["0","\\u0000",127],["8ea1","ï½¡",62],["a1a1","ã€€ã€ã€‚ï¼Œï¼Žãƒ»ï¼šï¼›ï¼Ÿï¼ã‚›ã‚œÂ´ï½€Â¨ï¼¾ï¿£ï¼¿ãƒ½ãƒ¾ã‚ã‚žã€ƒä»ã€…ã€†ã€‡ãƒ¼â€•â€ï¼ï¼¼ï½žâˆ¥ï½œâ€¦â€¥â€˜â€™â€œâ€ï¼ˆï¼‰ã€”ã€•ï¼»ï¼½ï½›ï½ã€ˆ",9,"ï¼‹ï¼Â±Ã—Ã·ï¼â‰ ï¼œï¼žâ‰¦â‰§âˆžâˆ´â™‚â™€Â°â€²â€³â„ƒï¿¥ï¼„ï¿ ï¿¡ï¼…ï¼ƒï¼†ï¼Šï¼ Â§â˜†â˜…â—‹â—â—Žâ—‡"],["a2a1","â—†â–¡â– â–³â–²â–½â–¼â€»ã€’â†’â†â†‘â†“ã€“"],["a2ba","âˆˆâˆ‹âŠ†âŠ‡âŠ‚âŠƒâˆªâˆ©"],["a2ca","âˆ§âˆ¨ï¿¢â‡’â‡”âˆ€âˆƒ"],["a2dc","âˆ âŠ¥âŒ’âˆ‚âˆ‡â‰¡â‰’â‰ªâ‰«âˆšâˆ½âˆâˆµâˆ«âˆ¬"],["a2f2","â„«â€°â™¯â™­â™ªâ€ â€¡Â¶"],["a2fe","â—¯"],["a3b0","ï¼",9],["a3c1","ï¼¡",25],["a3e1","ï½",25],["a4a1","ã",82],["a5a1","ã‚¡",85],["a6a1","Î‘",16,"Î£",6],["a6c1","Î±",16,"Ïƒ",6],["a7a1","Ð",5,"ÐÐ–",25],["a7d1","Ð°",5,"Ñ‘Ð¶",25],["a8a1","â”€â”‚â”Œâ”â”˜â””â”œâ”¬â”¤â”´â”¼â”â”ƒâ”â”“â”›â”—â”£â”³â”«â”»â•‹â” â”¯â”¨â”·â”¿â”â”°â”¥â”¸â•‚"],["ada1","â‘ ",19,"â… ",9],["adc0","ã‰ãŒ”ãŒ¢ããŒ˜ãŒ§ãŒƒãŒ¶ã‘ã—ãŒãŒ¦ãŒ£ãŒ«ãŠãŒ»ãŽœãŽãŽžãŽŽãŽã„ãŽ¡"],["addf","ã»ã€ã€Ÿâ„–ãâ„¡ãŠ¤",4,"ãˆ±ãˆ²ãˆ¹ã¾ã½ã¼â‰’â‰¡âˆ«âˆ®âˆ‘âˆšâŠ¥âˆ âˆŸâŠ¿âˆµâˆ©âˆª"],["b0a1","äºœå”–å¨ƒé˜¿å“€æ„›æŒ¨å§¶é€¢è‘µèŒœç©æ‚ªæ¡æ¸¥æ—­è‘¦èŠ¦é¯µæ¢“åœ§æ–¡æ‰±å®›å§è™»é£´çµ¢ç¶¾é®Žæˆ–ç²Ÿè¢·å®‰åºµæŒ‰æš—æ¡ˆé—‡éžæä»¥ä¼Šä½ä¾å‰å›²å¤·å§”å¨å°‰æƒŸæ„æ…°æ˜“æ¤…ç‚ºç•ç•°ç§»ç¶­ç·¯èƒƒèŽè¡£è¬‚é•éºåŒ»äº•äº¥åŸŸè‚²éƒç£¯ä¸€å£±æº¢é€¸ç¨²èŒ¨èŠ‹é°¯å…å°å’½å“¡å› å§»å¼•é£²æ·«èƒ¤è”­"],["b1a1","é™¢é™°éš éŸ»å‹å³å®‡çƒç¾½è¿‚é›¨å¯éµœçªºä¸‘ç¢“è‡¼æ¸¦å˜˜å”„æ¬è”šé°»å§¥åŽ©æµ¦ç“œé–å™‚äº‘é‹é›²èé¤Œå¡å–¶å¬°å½±æ˜ æ›³æ „æ°¸æ³³æ´©ç‘›ç›ˆç©Žé ´è‹±è¡›è© é‹­æ¶²ç–«ç›Šé§…æ‚¦è¬è¶Šé–²æ¦ŽåŽ­å††åœ’å °å¥„å®´å»¶æ€¨æŽ©æ´æ²¿æ¼”ç‚Žç„”ç…™ç‡•çŒ¿ç¸è‰¶è‹‘è–—é é‰›é´›å¡©æ–¼æ±šç”¥å‡¹å¤®å¥¥å¾€å¿œ"],["b2a1","æŠ¼æ—ºæ¨ªæ¬§æ®´çŽ‹ç¿è¥–é´¬é´Žé»„å²¡æ²–è»å„„å±‹æ†¶è‡†æ¡¶ç‰¡ä¹™ä¿ºå¸æ©æ¸©ç©éŸ³ä¸‹åŒ–ä»®ä½•ä¼½ä¾¡ä½³åŠ å¯å˜‰å¤å«å®¶å¯¡ç§‘æš‡æžœæž¶æ­Œæ²³ç«ç‚ç¦ç¦¾ç¨¼ç®‡èŠ±è‹›èŒ„è·è¯è“è¦èª²å˜©è²¨è¿¦éŽéœžèšŠä¿„å³¨æˆ‘ç‰™ç”»è‡¥èŠ½è›¾è³€é›…é¤“é§•ä»‹ä¼šè§£å›žå¡Šå£Šå»»å¿«æ€ªæ‚”æ¢æ‡æˆ’æ‹æ”¹"],["b3a1","é­æ™¦æ¢°æµ·ç°ç•Œçš†çµµèŠ¥èŸ¹é–‹éšŽè²å‡±åŠ¾å¤–å’³å®³å´–æ…¨æ¦‚æ¶¯ç¢è“‹è¡—è©²éŽ§éª¸æµ¬é¦¨è›™åž£æŸ¿è›ŽéˆŽåŠƒåš‡å„å»“æ‹¡æ’¹æ ¼æ ¸æ®»ç²ç¢ºç©«è¦šè§’èµ«è¼ƒéƒ­é–£éš”é©å­¦å²³æ¥½é¡é¡ŽæŽ›ç¬ æ¨«æ©¿æ¢¶é°æ½Ÿå‰²å–æ°æ‹¬æ´»æ¸‡æ»‘è‘›è¤è½„ä¸”é°¹å¶æ¤›æ¨ºéž„æ ªå…œç«ƒè’²é‡œéŽŒå™›é´¨æ ¢èŒ…è±"],["b4a1","ç²¥åˆˆè‹…ç“¦ä¹¾ä¾ƒå† å¯’åˆŠå‹˜å‹§å·»å–šå ªå§¦å®Œå®˜å¯›å¹²å¹¹æ‚£æ„Ÿæ…£æ†¾æ›æ•¢æŸ‘æ¡“æ£ºæ¬¾æ­“æ±—æ¼¢æ¾—æ½…ç’°ç”˜ç›£çœ‹ç«¿ç®¡ç°¡ç·©ç¼¶ç¿°è‚è‰¦èŽžè¦³è«Œè²«é‚„é‘‘é–“é–‘é–¢é™¥éŸ“é¤¨èˆ˜ä¸¸å«å²¸å·ŒçŽ©ç™Œçœ¼å²©ç¿«è´‹é›é ‘é¡”é¡˜ä¼ä¼Žå±å–œå™¨åŸºå¥‡å¬‰å¯„å²å¸Œå¹¾å¿Œæ®æœºæ——æ—¢æœŸæ£‹æ£„"],["b5a1","æ©Ÿå¸°æ¯…æ°—æ±½ç•¿ç¥ˆå­£ç¨€ç´€å¾½è¦è¨˜è²´èµ·è»Œè¼é£¢é¨Žé¬¼äº€å½å„€å¦“å®œæˆ¯æŠ€æ“¬æ¬ºçŠ ç–‘ç¥‡ç¾©èŸ»èª¼è­°æŽ¬èŠéž å‰åƒå–«æ¡”æ©˜è©°ç §æµé»å´å®¢è„šè™é€†ä¸˜ä¹…ä»‡ä¼‘åŠå¸å®®å¼“æ€¥æ•‘æœ½æ±‚æ±²æ³£ç¸çƒç©¶çª®ç¬ˆç´šç³¾çµ¦æ—§ç‰›åŽ»å±…å·¨æ‹’æ‹ æŒ™æ¸ è™šè¨±è·é‹¸æ¼ç¦¦é­šäº¨äº«äº¬"],["b6a1","ä¾›ä¾ åƒ‘å…‡ç«¶å…±å‡¶å”åŒ¡å¿å«å–¬å¢ƒå³¡å¼·å½Šæ€¯ææ­æŒŸæ•™æ©‹æ³ç‹‚ç‹­çŸ¯èƒ¸è„…èˆˆè•Žéƒ·é¡éŸ¿é¥—é©šä»°å‡å°­æšæ¥­å±€æ›²æ¥µçŽ‰æ¡ç²åƒ…å‹¤å‡å·¾éŒ¦æ–¤æ¬£æ¬½ç´ç¦ç¦½ç­‹ç·ŠèŠ¹èŒè¡¿è¥Ÿè¬¹è¿‘é‡‘åŸéŠ€ä¹å€¶å¥åŒºç‹—çŽ–çŸ©è‹¦èº¯é§†é§ˆé§’å…·æ„šè™žå–°ç©ºå¶å¯“é‡éš…ä¸²æ«›é‡§å±‘å±ˆ"],["b7a1","æŽ˜çªŸæ²“é´è½¡çªªç†Šéšˆç²‚æ —ç¹°æ¡‘é¬å‹²å›è–«è¨“ç¾¤è»éƒ¡å¦è¢ˆç¥ä¿‚å‚¾åˆ‘å…„å•“åœ­çªåž‹å¥‘å½¢å¾„æµæ…¶æ…§æ†©æŽ²æºæ•¬æ™¯æ¡‚æ¸“ç•¦ç¨½ç³»çµŒç¶™ç¹‹ç½«èŒŽèŠè›è¨ˆè©£è­¦è»½é šé¶èŠ¸è¿Žé¯¨åŠ‡æˆŸæ’ƒæ¿€éš™æ¡å‚‘æ¬ æ±ºæ½”ç©´çµè¡€è¨£æœˆä»¶å€¹å€¦å¥å…¼åˆ¸å‰£å–§åœå …å«Œå»ºæ†²æ‡¸æ‹³æ²"],["b8a1","æ¤œæ¨©ç‰½çŠ¬çŒ®ç ”ç¡¯çµ¹çœŒè‚©è¦‹è¬™è³¢è»’é£éµé™ºé¡•é¨“é¹¸å…ƒåŽŸåŽ³å¹»å¼¦æ¸›æºçŽ„ç¾çµƒèˆ·è¨€è«ºé™ä¹Žå€‹å¤å‘¼å›ºå§‘å­¤å·±åº«å¼§æˆ¸æ•…æž¯æ¹–ç‹ç³Šè¢´è‚¡èƒ¡è°è™Žèª‡è·¨éˆ·é›‡é¡§é¼“äº”äº’ä¼åˆå‘‰å¾å¨¯å¾Œå¾¡æ‚Ÿæ¢§æªŽç‘šç¢èªžèª¤è­·é†ä¹žé¯‰äº¤ä½¼ä¾¯å€™å€–å…‰å…¬åŠŸåŠ¹å‹¾åŽšå£å‘"],["b9a1","åŽå–‰å‘åž¢å¥½å­”å­å®å·¥å·§å··å¹¸åºƒåºšåº·å¼˜æ’æ…ŒæŠ—æ‹˜æŽ§æ”»æ˜‚æ™ƒæ›´æ­æ ¡æ¢—æ§‹æ±Ÿæ´ªæµ©æ¸¯æºç”²çš‡ç¡¬ç¨¿ç³ ç´…ç´˜çµžç¶±è€•è€ƒè‚¯è‚±è…”è†èˆªè’è¡Œè¡¡è¬›è²¢è³¼éƒŠé…µé‰±ç ¿é‹¼é–¤é™é …é¦™é«˜é´»å‰›åŠ«å·åˆå£•æ‹·æ¿ è±ªè½Ÿéº¹å…‹åˆ»å‘Šå›½ç©€é…·éµ é»’ç„æ¼‰è…°ç”‘å¿½æƒšéª¨ç‹›è¾¼"],["baa1","æ­¤é ƒä»Šå›°å¤å¢¾å©šæ¨æ‡‡æ˜æ˜†æ ¹æ¢±æ··ç—•ç´ºè‰®é­‚äº›ä½å‰å”†åµ¯å·¦å·®æŸ»æ²™ç‘³ç ‚è©éŽ–è£Ÿååº§æŒ«å‚µå‚¬å†æœ€å“‰å¡žå¦»å®°å½©æ‰æŽ¡æ ½æ­³æ¸ˆç½é‡‡çŠ€ç •ç ¦ç¥­æ–Žç´°èœè£è¼‰éš›å‰¤åœ¨æç½ªè²¡å†´å‚é˜ªå ºæ¦Šè‚´å’²å´ŽåŸ¼ç¢•é·ºä½œå‰Šå’‹æ¾æ˜¨æœ”æŸµçª„ç­–ç´¢éŒ¯æ¡œé®­ç¬¹åŒ™å†Šåˆ·"],["bba1","å¯Ÿæ‹¶æ’®æ“¦æœ­æ®ºè–©é›‘çšé¯–æŒéŒ†é®«çš¿æ™’ä¸‰å‚˜å‚å±±æƒ¨æ’’æ•£æ¡Ÿç‡¦çŠç”£ç®—çº‚èš•è®ƒè³›é…¸é¤æ–¬æš«æ®‹ä»•ä»”ä¼ºä½¿åˆºå¸å²å—£å››å£«å§‹å§‰å§¿å­å±å¸‚å¸«å¿—æ€æŒ‡æ”¯å­œæ–¯æ–½æ—¨æžæ­¢æ­»æ°ç…ç¥‰ç§ç³¸ç´™ç´«è‚¢è„‚è‡³è¦–è©žè©©è©¦èªŒè«®è³‡è³œé›Œé£¼æ­¯äº‹ä¼¼ä¾å…å­—å¯ºæ…ˆæŒæ™‚"],["bca1","æ¬¡æ»‹æ²»çˆ¾ç’½ç—”ç£ç¤ºè€Œè€³è‡ªè’”è¾žæ±é¹¿å¼è­˜é´«ç«ºè»¸å®é›«ä¸ƒå±åŸ·å¤±å«‰å®¤æ‚‰æ¹¿æ¼†ç–¾è³ªå®Ÿè”€ç¯ å²æŸ´èŠå±¡è•Šç¸žèˆŽå†™å°„æ¨èµ¦æ–œç…®ç¤¾ç´—è€…è¬è»Šé®è›‡é‚ªå€Ÿå‹ºå°ºæ“ç¼çˆµé…Œé‡ˆéŒ«è‹¥å¯‚å¼±æƒ¹ä¸»å–å®ˆæ‰‹æœ±æ®Šç‹©ç ç¨®è…«è¶£é…’é¦–å„’å—å‘ªå¯¿æŽˆæ¨¹ç¶¬éœ€å›šåŽå‘¨"],["bda1","å®—å°±å·žä¿®æ„æ‹¾æ´²ç§€ç§‹çµ‚ç¹ç¿’è‡­èˆŸè’è¡†è¥²è®è¹´è¼¯é€±é…‹é…¬é›†é†œä»€ä½å……åå¾“æˆŽæŸ”æ±æ¸‹ç£ç¸¦é‡éŠƒå”å¤™å®¿æ·‘ç¥ç¸®ç²›å¡¾ç†Ÿå‡ºè¡“è¿°ä¿Šå³»æ˜¥çž¬ç«£èˆœé§¿å‡†å¾ªæ—¬æ¥¯æ®‰æ·³æº–æ½¤ç›¾ç´”å·¡éµé†‡é †å‡¦åˆæ‰€æš‘æ›™æ¸šåº¶ç·’ç½²æ›¸è–¯è—·è«¸åŠ©å™å¥³åºå¾æ•é‹¤é™¤å‚·å„Ÿ"],["bea1","å‹åŒ å‡å¬å“¨å•†å”±å˜—å¥¨å¦¾å¨¼å®µå°†å°å°‘å°šåº„åºŠå» å½°æ‰¿æŠ„æ‹›æŽŒæ·æ˜‡æ˜Œæ˜­æ™¶æ¾æ¢¢æ¨Ÿæ¨µæ²¼æ¶ˆæ¸‰æ¹˜ç„¼ç„¦ç…§ç—‡çœç¡ç¤ç¥¥ç§°ç« ç¬‘ç²§ç´¹è‚–è–è’‹è•‰è¡è£³è¨Ÿè¨¼è©”è©³è±¡è³žé†¤é‰¦é¾é˜éšœéž˜ä¸Šä¸ˆä¸žä¹—å†—å‰°åŸŽå ´å£Œå¬¢å¸¸æƒ…æ“¾æ¡æ–æµ„çŠ¶ç•³ç©£è’¸è­²é†¸éŒ å˜±åŸ´é£¾"],["bfa1","æ‹­æ¤æ®–ç‡­ç¹”è·è‰²è§¦é£Ÿè•è¾±å°»ä¼¸ä¿¡ä¾µå”‡å¨ å¯å¯©å¿ƒæ…ŽæŒ¯æ–°æ™‹æ£®æ¦›æµ¸æ·±ç”³ç–¹çœŸç¥žç§¦ç´³è‡£èŠ¯è–ªè¦ªè¨ºèº«è¾›é€²é‡éœ‡äººä»åˆƒå¡µå£¬å°‹ç”šå°½è…Žè¨Šè¿…é™£é­ç¬¥è«é ˆé…¢å›³åŽ¨é€—å¹åž‚å¸¥æŽ¨æ°´ç‚Šç¡ç²‹ç¿ è¡°é‚é…”éŒéŒ˜éšç‘žé«„å´‡åµ©æ•°æž¢è¶¨é››æ®æ‰æ¤™è…é —é›€è£¾"],["c0a1","æ¾„æ‘ºå¯¸ä¸–ç€¬ç•æ˜¯å‡„åˆ¶å‹¢å§“å¾æ€§æˆæ”¿æ•´æ˜Ÿæ™´æ£²æ –æ­£æ¸…ç‰²ç”Ÿç››ç²¾è–å£°è£½è¥¿èª èª“è«‹é€é†’é’é™æ–‰ç¨Žè„†éš»å¸­æƒœæˆšæ–¥æ˜”æžçŸ³ç©ç±ç¸¾è„Šè²¬èµ¤è·¡è¹Ÿç¢©åˆ‡æ‹™æŽ¥æ‘‚æŠ˜è¨­çªƒç¯€èª¬é›ªçµ¶èˆŒè‰ä»™å…ˆåƒå å®£å°‚å°–å·æˆ¦æ‰‡æ’°æ “æ ´æ³‰æµ…æ´—æŸ“æ½œç…Žç…½æ—‹ç©¿ç®­ç·š"],["c1a1","ç¹Šç¾¨è…ºèˆ›èˆ¹è–¦è©®è³Žè·µé¸é·éŠ­éŠ‘é–ƒé®®å‰å–„æ¼¸ç„¶å…¨ç¦…ç¹•è†³ç³Žå™Œå¡‘å²¨æŽªæ›¾æ›½æ¥šç‹™ç–ç–Žç¤Žç¥–ç§Ÿç²—ç´ çµ„è˜‡è¨´é˜»é¡é¼ åƒ§å‰µåŒå¢å€‰å–ªå£®å¥çˆ½å®‹å±¤åŒæƒ£æƒ³æœæŽƒæŒ¿æŽ»æ“æ—©æ›¹å·£æ§æ§½æ¼•ç‡¥äº‰ç—©ç›¸çª“ç³Ÿç·ç¶œè¡è‰è˜è‘¬è’¼è—»è£…èµ°é€é­éŽ—éœœé¨’åƒå¢—æ†Ž"],["c2a1","è‡“è”µè´ˆé€ ä¿ƒå´å‰‡å³æ¯æ‰æŸæ¸¬è¶³é€Ÿä¿—å±žè³Šæ—ç¶šå’è¢–å…¶æƒå­˜å­«å°Šææ‘éœä»–å¤šå¤ªæ±°è©‘å”¾å •å¦¥æƒ°æ‰“æŸèˆµæ¥•é™€é§„é¨¨ä½“å †å¯¾è€å²±å¸¯å¾…æ€ æ…‹æˆ´æ›¿æ³°æ»žèƒŽè…¿è‹”è¢‹è²¸é€€é€®éšŠé»›é¯›ä»£å°å¤§ç¬¬é†é¡Œé·¹æ»ç€§å“å•„å®…æ‰˜æŠžæ‹“æ²¢æ¿¯ç¢è¨—é¸æ¿è«¾èŒ¸å‡§è›¸åª"],["c3a1","å©ä½†é”è¾°å¥ªè„±å·½ç«ªè¾¿æ£šè°·ç‹¸é±ˆæ¨½èª°ä¸¹å˜å˜†å¦æ‹…æŽ¢æ—¦æ­Žæ·¡æ¹›ç‚­çŸ­ç«¯ç®ªç¶»è€½èƒ†è›‹èª•é›å›£å£‡å¼¾æ–­æš–æª€æ®µç”·è«‡å€¤çŸ¥åœ°å¼›æ¥æ™ºæ± ç—´ç¨šç½®è‡´èœ˜é…é¦³ç¯‰ç•œç«¹ç­‘è“„é€ç§©çª’èŒ¶å«¡ç€ä¸­ä»²å®™å¿ æŠ½æ˜¼æŸ±æ³¨è™«è¡·è¨»é…Žé‹³é§æ¨—ç€¦çŒªè‹§è‘—è²¯ä¸å…†å‡‹å–‹å¯µ"],["c4a1","å¸–å¸³åºå¼”å¼µå½«å¾´æ‡²æŒ‘æš¢æœæ½®ç‰’ç”ºçœºè´è„¹è…¸è¶èª¿è«œè¶…è·³éŠšé•·é ‚é³¥å‹…æ—ç›´æœ•æ²ˆçè³ƒéŽ®é™³æ´¥å¢œæ¤Žæ§Œè¿½éŽšç—›é€šå¡šæ ‚æŽ´æ§»ä½ƒæ¼¬æŸ˜è¾»è”¦ç¶´é”æ¤¿æ½°åªå£·å¬¬ç´¬çˆªåŠé‡£é¶´äº­ä½Žåœåµå‰ƒè²žå‘ˆå ¤å®šå¸åº•åº­å»·å¼Ÿæ‚ŒæŠµæŒºææ¢¯æ±€ç¢‡ç¦Žç¨‹ç· è‰‡è¨‚è«¦è¹„é€“"],["c5a1","é‚¸é„­é‡˜é¼Žæ³¥æ‘˜æ“¢æ•µæ»´çš„ç¬›é©é‘æººå“²å¾¹æ’¤è½è¿­é‰„å…¸å¡«å¤©å±•åº—æ·»çºç”œè²¼è»¢é¡›ç‚¹ä¼æ®¿æ¾±ç”°é›»å…Žåå µå¡—å¦¬å± å¾’æ–—æœæ¸¡ç™»èŸè³­é€”éƒ½éç ¥ç ºåŠªåº¦åœŸå¥´æ€’å€’å…šå†¬å‡åˆ€å”å¡”å¡˜å¥—å®•å³¶å¶‹æ‚¼æŠ•æ­æ±æ¡ƒæ¢¼æ£Ÿç›—æ·˜æ¹¯æ¶›ç¯ç‡ˆå½“ç—˜ç¥·ç­‰ç­”ç­’ç³–çµ±åˆ°"],["c6a1","è‘£è•©è—¤è¨Žè¬„è±†è¸é€ƒé€é™é™¶é ­é¨°é—˜åƒå‹•åŒå ‚å°Žæ†§æ’žæ´žçž³ç«¥èƒ´è„é“éŠ…å³ é´‡åŒ¿å¾—å¾³æ¶œç‰¹ç£ç¦¿ç¯¤æ¯’ç‹¬èª­æ ƒæ©¡å‡¸çªæ¤´å±Šé³¶è‹«å¯…é…‰ç€žå™¸å±¯æƒ‡æ•¦æ²Œè±šéé “å‘‘æ›‡éˆå¥ˆé‚£å†…ä¹å‡ªè–™è¬Žç˜æºé‹æ¥¢é¦´ç¸„ç•·å—æ¥ è»Ÿé›£æ±äºŒå°¼å¼è¿©åŒ‚è³‘è‚‰è™¹å»¿æ—¥ä¹³å…¥"],["c7a1","å¦‚å°¿éŸ®ä»»å¦Šå¿èªæ¿¡ç¦°ç¥¢å¯§è‘±çŒ«ç†±å¹´å¿µæ»æ’šç‡ƒç²˜ä¹ƒå»¼ä¹‹åŸœåš¢æ‚©æ¿ƒç´èƒ½è„³è†¿è¾²è¦—èš¤å·´æŠŠæ’­è¦‡æ·æ³¢æ´¾ç¶ç ´å©†ç½µèŠ­é¦¬ä¿³å»ƒæ‹æŽ’æ•—æ¯ç›ƒç‰ŒèƒŒè‚ºè¼©é…å€åŸ¹åª’æ¢…æ¥³ç…¤ç‹½è²·å£²è³ é™ªé€™è¿ç§¤çŸ§è©ä¼¯å‰¥åšæ‹æŸæ³Šç™½ç®”ç²•èˆ¶è–„è¿«æ›æ¼ çˆ†ç¸›èŽ«é§éº¦"],["c8a1","å‡½ç®±ç¡²ç®¸è‚‡ç­ˆæ«¨å¹¡è‚Œç•‘ç• å…«é‰¢æºŒç™ºé†—é«ªä¼ç½°æŠœç­é–¥é³©å™ºå¡™è›¤éš¼ä¼´åˆ¤åŠåå›å¸†æ¬æ–‘æ¿æ°¾æ±Žç‰ˆçŠ¯ç­ç•”ç¹èˆ¬è—©è²©ç¯„é‡†ç…©é ’é£¯æŒ½æ™©ç•ªç›¤ç£è•ƒè›®åŒªå‘å¦å¦ƒåº‡å½¼æ‚²æ‰‰æ‰¹æŠ«æ–æ¯”æ³Œç–²çš®ç¢‘ç§˜ç·‹ç½·è‚¥è¢«èª¹è²»é¿éžé£›æ¨‹ç°¸å‚™å°¾å¾®æž‡æ¯˜çµçœ‰ç¾Ž"],["c9a1","é¼»æŸŠç¨—åŒ¹ç–‹é«­å½¦è†è±è‚˜å¼¼å¿…ç•¢ç­†é€¼æ¡§å§«åª›ç´ç™¾è¬¬ä¿µå½ªæ¨™æ°·æ¼‚ç“¢ç¥¨è¡¨è©•è±¹å»Ÿæç—…ç§’è‹—éŒ¨é‹²è’œè›­é°­å“å½¬æ–Œæµœç€•è²§è³“é »æ•ç“¶ä¸ä»˜åŸ å¤«å©¦å¯Œå†¨å¸ƒåºœæ€–æ‰¶æ•·æ–§æ™®æµ®çˆ¶ç¬¦è…è†šèŠ™è­œè² è³¦èµ´é˜œé™„ä¾®æ’«æ­¦èˆžè‘¡è•ªéƒ¨å°æ¥“é¢¨è‘ºè•—ä¼å‰¯å¾©å¹…æœ"],["caa1","ç¦è…¹è¤‡è¦†æ·µå¼—æ‰•æ²¸ä»ç‰©é®’åˆ†å»å™´å¢³æ†¤æ‰®ç„šå¥®ç²‰ç³žç´›é›°æ–‡èžä¸™ä½µå…µå¡€å¹£å¹³å¼ŠæŸ„ä¸¦è”½é–‰é™›ç±³é åƒ»å£ç™–ç¢§åˆ¥çž¥è”‘ç®†åå¤‰ç‰‡ç¯‡ç·¨è¾ºè¿”éä¾¿å‹‰å¨©å¼éž­ä¿èˆ—é‹ªåœƒæ•æ­©ç”«è£œè¼”ç©‚å‹Ÿå¢“æ…•æˆŠæš®æ¯ç°¿è©å€£ä¿¸åŒ…å‘†å ±å¥‰å®å³°å³¯å´©åº–æŠ±æ§æ”¾æ–¹æœ‹"],["cba1","æ³•æ³¡çƒ¹ç ²ç¸«èƒžèŠ³èŒè“¬èœ‚è¤’è¨ªè±Šé‚¦é‹’é£½é³³éµ¬ä¹äº¡å‚å‰–åŠå¦¨å¸½å¿˜å¿™æˆ¿æš´æœ›æŸæ£’å†’ç´¡è‚ªè†¨è¬€è²Œè²¿é‰¾é˜²å é ¬åŒ—åƒ•åœå¢¨æ’²æœ´ç‰§ç¦ç©†é‡¦å‹ƒæ²¡æ®†å €å¹Œå¥”æœ¬ç¿»å‡¡ç›†æ‘©ç£¨é­”éº»åŸ‹å¦¹æ˜§æžšæ¯Žå“©æ§™å¹•è†œæž•é®ªæŸ¾é±’æ¡äº¦ä¿£åˆæŠ¹æœ«æ²«è¿„ä¾­ç¹­éº¿ä¸‡æ…¢æº€"],["cca1","æ¼«è”“å‘³æœªé­…å·³ç®•å²¬å¯†èœœæ¹Šè“‘ç¨”è„ˆå¦™ç²æ°‘çœ å‹™å¤¢ç„¡ç‰ŸçŸ›éœ§éµ¡æ¤‹å©¿å¨˜å†¥åå‘½æ˜Žç›Ÿè¿·éŠ˜é³´å§ªç‰æ»…å…æ£‰ç¶¿ç·¬é¢éººæ‘¸æ¨¡èŒ‚å¦„å­Ÿæ¯›çŒ›ç›²ç¶²è€—è’™å„²æœ¨é»™ç›®æ¢å‹¿é¤…å°¤æˆ»ç±¾è²°å•æ‚¶ç´‹é–€åŒä¹Ÿå†¶å¤œçˆºè€¶é‡Žå¼¥çŸ¢åŽ„å½¹ç´„è–¬è¨³èºé–æŸ³è–®é‘“æ„‰æ„ˆæ²¹ç™’"],["cda1","è«­è¼¸å”¯ä½‘å„ªå‹‡å‹å®¥å¹½æ‚ æ†‚æ–æœ‰æŸšæ¹§æ¶ŒçŒ¶çŒ·ç”±ç¥è£•èª˜éŠé‚‘éƒµé›„èžå¤•äºˆä½™ä¸Žèª‰è¼¿é å‚­å¹¼å¦–å®¹åº¸æšæºæ“æ›œæ¥Šæ§˜æ´‹æº¶ç†”ç”¨çª¯ç¾Šè€€è‘‰è“‰è¦è¬¡è¸Šé¥é™½é¤Šæ…¾æŠ‘æ¬²æ²ƒæµ´ç¿Œç¿¼æ·€ç¾…èžºè£¸æ¥èŽ±é ¼é›·æ´›çµ¡è½é…ªä¹±åµåµæ¬„æ¿«è—è˜­è¦§åˆ©åå±¥æŽæ¢¨ç†ç’ƒ"],["cea1","ç—¢è£è£¡é‡Œé›¢é™¸å¾‹çŽ‡ç«‹è‘ŽæŽ ç•¥åŠ‰æµæºœç‰ç•™ç¡«ç²’éš†ç«œé¾ä¾¶æ…®æ—…è™œäº†äº®åƒšä¸¡å‡Œå¯®æ–™æ¢æ¶¼çŒŸç™‚çž­ç¨œç³§è‰¯è«’é¼é‡é™µé ˜åŠ›ç·‘å€«åŽ˜æž—æ·‹ç‡ç³è‡¨è¼ªéš£é±—éºŸç‘ å¡æ¶™ç´¯é¡žä»¤ä¼¶ä¾‹å†·åŠ±å¶ºæ€œçŽ²ç¤¼è‹“éˆ´éš·é›¶éœŠéº—é½¢æš¦æ­´åˆ—åŠ£çƒˆè£‚å»‰æ‹æ†æ¼£ç…‰ç°¾ç·´è¯"],["cfa1","è“®é€£éŒ¬å‘‚é­¯æ«“ç‚‰è³‚è·¯éœ²åŠ´å©å»Šå¼„æœ—æ¥¼æ¦”æµªæ¼ç‰¢ç‹¼ç¯­è€è¾è‹éƒŽå…­éº“ç¦„è‚‹éŒ²è«–å€­å’Œè©±æ­ªè³„è„‡æƒ‘æž é·²äº™äº˜é°è©«è—è•¨æ¤€æ¹¾ç¢—è…•"],["d0a1","å¼Œä¸ä¸•ä¸ªä¸±ä¸¶ä¸¼ä¸¿ä¹‚ä¹–ä¹˜äº‚äº…è±«äºŠèˆ’å¼äºŽäºžäºŸäº äº¢äº°äº³äº¶ä»Žä»ä»„ä»†ä»‚ä»—ä»žä»­ä»Ÿä»·ä¼‰ä½šä¼°ä½›ä½ä½—ä½‡ä½¶ä¾ˆä¾ä¾˜ä½»ä½©ä½°ä¾‘ä½¯ä¾†ä¾–å„˜ä¿”ä¿Ÿä¿Žä¿˜ä¿›ä¿‘ä¿šä¿ä¿¤ä¿¥å€šå€¨å€”å€ªå€¥å€…ä¼œä¿¶å€¡å€©å€¬ä¿¾ä¿¯å€‘å€†åƒå‡æœƒå•ååˆåšå–å¬å¸å‚€å‚šå‚…å‚´å‚²"],["d1a1","åƒ‰åƒŠå‚³åƒ‚åƒ–åƒžåƒ¥åƒ­åƒ£åƒ®åƒ¹åƒµå„‰å„å„‚å„–å„•å„”å„šå„¡å„ºå„·å„¼å„»å„¿å…€å…’å…Œå…”å…¢ç«¸å…©å…ªå…®å†€å†‚å›˜å†Œå†‰å†å†‘å†“å†•å†–å†¤å†¦å†¢å†©å†ªå†«å†³å†±å†²å†°å†µå†½å‡…å‡‰å‡›å‡ è™•å‡©å‡­å‡°å‡µå‡¾åˆ„åˆ‹åˆ”åˆŽåˆ§åˆªåˆ®åˆ³åˆ¹å‰å‰„å‰‹å‰Œå‰žå‰”å‰ªå‰´å‰©å‰³å‰¿å‰½åŠåŠ”åŠ’å‰±åŠˆåŠ‘è¾¨"],["d2a1","è¾§åŠ¬åŠ­åŠ¼åŠµå‹å‹å‹—å‹žå‹£å‹¦é£­å‹ å‹³å‹µå‹¸å‹¹åŒ†åŒˆç”¸åŒåŒåŒåŒ•åŒšåŒ£åŒ¯åŒ±åŒ³åŒ¸å€å†å…ä¸—å‰åå‡–åžå©å®å¤˜å»å·åŽ‚åŽ–åŽ åŽ¦åŽ¥åŽ®åŽ°åŽ¶åƒç°’é›™åŸæ›¼ç‡®å®å¨å­åºåå½å‘€å¬å­å¼å®å¶å©åå‘Žå’å‘µå’Žå‘Ÿå‘±å‘·å‘°å’’å‘»å’€å‘¶å’„å’å’†å“‡å’¢å’¸å’¥å’¬å“„å“ˆå’¨"],["d3a1","å’«å“‚å’¤å’¾å’¼å“˜å“¥å“¦å”å””å“½å“®å“­å“ºå“¢å”¹å•€å•£å•Œå”®å•œå•…å•–å•—å”¸å”³å•å–™å–€å’¯å–Šå–Ÿå•»å•¾å–˜å–žå–®å•¼å–ƒå–©å–‡å–¨å—šå—…å—Ÿå—„å—œå—¤å—”å˜”å—·å˜–å—¾å—½å˜›å—¹å™Žå™ç‡Ÿå˜´å˜¶å˜²å˜¸å™«å™¤å˜¯å™¬å™ªåš†åš€åšŠåš åš”åšåš¥åš®åš¶åš´å›‚åš¼å›å›ƒå›€å›ˆå›Žå›‘å›“å›—å›®å›¹åœ€å›¿åœ„åœ‰"],["d4a1","åœˆåœ‹åœåœ“åœ˜åœ–å—‡åœœåœ¦åœ·åœ¸åŽåœ»å€åå©åŸ€åžˆå¡å¿åž‰åž“åž åž³åž¤åžªåž°åŸƒåŸ†åŸ”åŸ’åŸ“å ŠåŸ–åŸ£å ‹å ™å å¡²å ¡å¡¢å¡‹å¡°æ¯€å¡’å ½å¡¹å¢…å¢¹å¢Ÿå¢«å¢ºå£žå¢»å¢¸å¢®å£…å£“å£‘å£—å£™å£˜å£¥å£œå£¤å£Ÿå£¯å£ºå£¹å£»å£¼å£½å¤‚å¤Šå¤å¤›æ¢¦å¤¥å¤¬å¤­å¤²å¤¸å¤¾ç«’å¥•å¥å¥Žå¥šå¥˜å¥¢å¥ å¥§å¥¬å¥©"],["d5a1","å¥¸å¦å¦ä½žä¾«å¦£å¦²å§†å§¨å§œå¦å§™å§šå¨¥å¨Ÿå¨‘å¨œå¨‰å¨šå©€å©¬å©‰å¨µå¨¶å©¢å©ªåªšåª¼åª¾å«‹å«‚åª½å«£å«—å«¦å«©å«–å«ºå«»å¬Œå¬‹å¬–å¬²å«å¬ªå¬¶å¬¾å­ƒå­…å­€å­‘å­•å­šå­›å­¥å­©å­°å­³å­µå­¸æ–ˆå­ºå®€å®ƒå®¦å®¸å¯ƒå¯‡å¯‰å¯”å¯å¯¤å¯¦å¯¢å¯žå¯¥å¯«å¯°å¯¶å¯³å°…å°‡å°ˆå°å°“å° å°¢å°¨å°¸å°¹å±å±†å±Žå±“"],["d6a1","å±å±å­±å±¬å±®ä¹¢å±¶å±¹å²Œå²‘å²”å¦›å²«å²»å²¶å²¼å²·å³…å²¾å³‡å³™å³©å³½å³ºå³­å¶Œå³ªå´‹å´•å´—åµœå´Ÿå´›å´‘å´”å´¢å´šå´™å´˜åµŒåµ’åµŽåµ‹åµ¬åµ³åµ¶å¶‡å¶„å¶‚å¶¢å¶å¶¬å¶®å¶½å¶å¶·å¶¼å·‰å·å·“å·’å·–å·›å·«å·²å·µå¸‹å¸šå¸™å¸‘å¸›å¸¶å¸·å¹„å¹ƒå¹€å¹Žå¹—å¹”å¹Ÿå¹¢å¹¤å¹‡å¹µå¹¶å¹ºéº¼å¹¿åº å»å»‚å»ˆå»å»"],["d7a1","å»–å»£å»å»šå»›å»¢å»¡å»¨å»©å»¬å»±å»³å»°å»´å»¸å»¾å¼ƒå¼‰å½å½œå¼‹å¼‘å¼–å¼©å¼­å¼¸å½å½ˆå½Œå½Žå¼¯å½‘å½–å½—å½™å½¡å½­å½³å½·å¾ƒå¾‚å½¿å¾Šå¾ˆå¾‘å¾‡å¾žå¾™å¾˜å¾ å¾¨å¾­å¾¼å¿–å¿»å¿¤å¿¸å¿±å¿æ‚³å¿¿æ€¡æ æ€™æ€æ€©æ€Žæ€±æ€›æ€•æ€«æ€¦æ€æ€ºæšææªæ·æŸæŠæ†ææ£æƒæ¤æ‚æ¬æ«æ™æ‚æ‚æƒ§æ‚ƒæ‚š"],["d8a1","æ‚„æ‚›æ‚–æ‚—æ‚’æ‚§æ‚‹æƒ¡æ‚¸æƒ æƒ“æ‚´å¿°æ‚½æƒ†æ‚µæƒ˜æ…æ„•æ„†æƒ¶æƒ·æ„€æƒ´æƒºæ„ƒæ„¡æƒ»æƒ±æ„æ„Žæ…‡æ„¾æ„¨æ„§æ…Šæ„¿æ„¼æ„¬æ„´æ„½æ…‚æ…„æ…³æ…·æ…˜æ…™æ…šæ…«æ…´æ…¯æ…¥æ…±æ…Ÿæ…æ…“æ…µæ†™æ†–æ†‡æ†¬æ†”æ†šæ†Šæ†‘æ†«æ†®æ‡Œæ‡Šæ‡‰æ‡·æ‡ˆæ‡ƒæ‡†æ†ºæ‡‹ç½¹æ‡æ‡¦æ‡£æ‡¶æ‡ºæ‡´æ‡¿æ‡½æ‡¼æ‡¾æˆ€æˆˆæˆ‰æˆæˆŒæˆ”æˆ›"],["d9a1","æˆžæˆ¡æˆªæˆ®æˆ°æˆ²æˆ³æ‰æ‰Žæ‰žæ‰£æ‰›æ‰ æ‰¨æ‰¼æŠ‚æŠ‰æ‰¾æŠ’æŠ“æŠ–æ‹”æŠƒæŠ”æ‹—æ‹‘æŠ»æ‹æ‹¿æ‹†æ“”æ‹ˆæ‹œæ‹Œæ‹Šæ‹‚æ‹‡æŠ›æ‹‰æŒŒæ‹®æ‹±æŒ§æŒ‚æŒˆæ‹¯æ‹µææŒ¾ææœææŽ–æŽŽæŽ€æŽ«æ¶æŽ£æŽæŽ‰æŽŸæŽµæ«æ©æŽ¾æ©æ€æ†æ£æ‰æ’æ¶æ„æ–æ´æ†æ“æ¦æ¶æ”æ—æ¨ææ‘§æ‘¯æ‘¶æ‘Žæ”ªæ’•æ’“æ’¥æ’©æ’ˆæ’¼"],["daa1","æ“šæ“’æ“…æ“‡æ’»æ“˜æ“‚æ“±æ“§èˆ‰æ“ æ“¡æŠ¬æ“£æ“¯æ”¬æ“¶æ“´æ“²æ“ºæ”€æ“½æ”˜æ”œæ”…æ”¤æ”£æ”«æ”´æ”µæ”·æ”¶æ”¸ç•‹æ•ˆæ•–æ••æ•æ•˜æ•žæ•æ•²æ•¸æ–‚æ–ƒè®Šæ–›æ–Ÿæ–«æ–·æ—ƒæ—†æ—æ—„æ—Œæ—’æ—›æ—™æ— æ—¡æ—±æ²æ˜Šæ˜ƒæ—»æ³æ˜µæ˜¶æ˜´æ˜œæ™æ™„æ™‰æ™æ™žæ™æ™¤æ™§æ™¨æ™Ÿæ™¢æ™°æšƒæšˆæšŽæš‰æš„æš˜æšæ›æš¹æ›‰æš¾æš¼"],["dba1","æ›„æš¸æ›–æ›šæ› æ˜¿æ›¦æ›©æ›°æ›µæ›·æœæœ–æœžæœ¦æœ§éœ¸æœ®æœ¿æœ¶ææœ¸æœ·æ†æžæ æ™æ£æ¤æž‰æ°æž©æ¼æªæžŒæž‹æž¦æž¡æž…æž·æŸ¯æž´æŸ¬æž³æŸ©æž¸æŸ¤æŸžæŸæŸ¢æŸ®æž¹æŸŽæŸ†æŸ§æªœæ žæ¡†æ ©æ¡€æ¡æ ²æ¡Žæ¢³æ «æ¡™æ¡£æ¡·æ¡¿æ¢Ÿæ¢æ¢­æ¢”æ¢æ¢›æ¢ƒæª®æ¢¹æ¡´æ¢µæ¢ æ¢ºæ¤æ¢æ¡¾æ¤æ£Šæ¤ˆæ£˜æ¤¢æ¤¦æ£¡æ¤Œæ£"],["dca1","æ£”æ£§æ£•æ¤¶æ¤’æ¤„æ£—æ££æ¤¥æ£¹æ£ æ£¯æ¤¨æ¤ªæ¤šæ¤£æ¤¡æ£†æ¥¹æ¥·æ¥œæ¥¸æ¥«æ¥”æ¥¾æ¥®æ¤¹æ¥´æ¤½æ¥™æ¤°æ¥¡æ¥žæ¥æ¦æ¥ªæ¦²æ¦®æ§æ¦¿æ§æ§“æ¦¾æ§Žå¯¨æ§Šæ§æ¦»æ§ƒæ¦§æ¨®æ¦‘æ¦ æ¦œæ¦•æ¦´æ§žæ§¨æ¨‚æ¨›æ§¿æ¬Šæ§¹æ§²æ§§æ¨…æ¦±æ¨žæ§­æ¨”æ§«æ¨Šæ¨’æ«æ¨£æ¨“æ©„æ¨Œæ©²æ¨¶æ©¸æ©‡æ©¢æ©™æ©¦æ©ˆæ¨¸æ¨¢æªæªæª æª„æª¢æª£"],["dda1","æª—è˜—æª»æ«ƒæ«‚æª¸æª³æª¬æ«žæ«‘æ«Ÿæªªæ«šæ«ªæ«»æ¬…è˜–æ«ºæ¬’æ¬–é¬±æ¬Ÿæ¬¸æ¬·ç›œæ¬¹é£®æ­‡æ­ƒæ­‰æ­æ­™æ­”æ­›æ­Ÿæ­¡æ­¸æ­¹æ­¿æ®€æ®„æ®ƒæ®æ®˜æ®•æ®žæ®¤æ®ªæ®«æ®¯æ®²æ®±æ®³æ®·æ®¼æ¯†æ¯‹æ¯“æ¯Ÿæ¯¬æ¯«æ¯³æ¯¯éº¾æ°ˆæ°“æ°”æ°›æ°¤æ°£æ±žæ±•æ±¢æ±ªæ²‚æ²æ²šæ²æ²›æ±¾æ±¨æ±³æ²’æ²æ³„æ³±æ³“æ²½æ³—æ³…æ³æ²®æ²±æ²¾"],["dea1","æ²ºæ³›æ³¯æ³™æ³ªæ´Ÿè¡æ´¶æ´«æ´½æ´¸æ´™æ´µæ´³æ´’æ´Œæµ£æ¶“æµ¤æµšæµ¹æµ™æ¶Žæ¶•æ¿¤æ¶…æ·¹æ¸•æ¸Šæ¶µæ·‡æ·¦æ¶¸æ·†æ·¬æ·žæ·Œæ·¨æ·’æ·…æ·ºæ·™æ·¤æ·•æ·ªæ·®æ¸­æ¹®æ¸®æ¸™æ¹²æ¹Ÿæ¸¾æ¸£æ¹«æ¸«æ¹¶æ¹æ¸Ÿæ¹ƒæ¸ºæ¹Žæ¸¤æ»¿æ¸æ¸¸æº‚æºªæº˜æ»‰æº·æ»“æº½æº¯æ»„æº²æ»”æ»•æºæº¥æ»‚æºŸæ½æ¼‘çŒæ»¬æ»¸æ»¾æ¼¿æ»²æ¼±æ»¯æ¼²æ»Œ"],["dfa1","æ¼¾æ¼“æ»·æ¾†æ½ºæ½¸æ¾æ¾€æ½¯æ½›æ¿³æ½­æ¾‚æ½¼æ½˜æ¾Žæ¾‘æ¿‚æ½¦æ¾³æ¾£æ¾¡æ¾¤æ¾¹æ¿†æ¾ªæ¿Ÿæ¿•æ¿¬æ¿”æ¿˜æ¿±æ¿®æ¿›ç€‰ç€‹æ¿ºç€‘ç€ç€æ¿¾ç€›ç€šæ½´ç€ç€˜ç€Ÿç€°ç€¾ç€²ç‘ç£ç‚™ç‚’ç‚¯çƒ±ç‚¬ç‚¸ç‚³ç‚®çƒŸçƒ‹çƒçƒ™ç„‰çƒ½ç„œç„™ç…¥ç…•ç†ˆç…¦ç…¢ç…Œç…–ç…¬ç†ç‡»ç†„ç†•ç†¨ç†¬ç‡—ç†¹ç†¾ç‡’ç‡‰ç‡”ç‡Žç‡ ç‡¬ç‡§ç‡µç‡¼"],["e0a1","ç‡¹ç‡¿çˆçˆçˆ›çˆ¨çˆ­çˆ¬çˆ°çˆ²çˆ»çˆ¼çˆ¿ç‰€ç‰†ç‰‹ç‰˜ç‰´ç‰¾çŠ‚çŠçŠ‡çŠ’çŠ–çŠ¢çŠ§çŠ¹çŠ²ç‹ƒç‹†ç‹„ç‹Žç‹’ç‹¢ç‹ ç‹¡ç‹¹ç‹·å€çŒ—çŒŠçŒœçŒ–çŒçŒ´çŒ¯çŒ©çŒ¥çŒ¾çŽçé»˜ç—çªç¨ç°ç¸çµç»çºçˆçŽ³çŽçŽ»ç€ç¥ç®çžç’¢ç…ç‘¯ç¥ç¸ç²çºç‘•ç¿ç‘Ÿç‘™ç‘ç‘œç‘©ç‘°ç‘£ç‘ªç‘¶ç‘¾ç’‹ç’žç’§ç“Šç“ç“”ç±"],["e1a1","ç“ ç“£ç“§ç“©ç“®ç“²ç“°ç“±ç“¸ç“·ç”„ç”ƒç”…ç”Œç”Žç”ç”•ç”“ç”žç”¦ç”¬ç”¼ç•„ç•ç•Šç•‰ç•›ç•†ç•šç•©ç•¤ç•§ç•«ç•­ç•¸ç•¶ç–†ç–‡ç•´ç–Šç–‰ç–‚ç–”ç–šç–ç–¥ç–£ç—‚ç–³ç—ƒç–µç–½ç–¸ç–¼ç–±ç—ç—Šç—’ç—™ç—£ç—žç—¾ç—¿ç—¼ç˜ç—°ç—ºç—²ç—³ç˜‹ç˜ç˜‰ç˜Ÿç˜§ç˜ ç˜¡ç˜¢ç˜¤ç˜´ç˜°ç˜»ç™‡ç™ˆç™†ç™œç™˜ç™¡ç™¢ç™¨ç™©ç™ªç™§ç™¬ç™°"],["e2a1","ç™²ç™¶ç™¸ç™¼çš€çšƒçšˆçš‹çšŽçš–çš“çš™çššçš°çš´çš¸çš¹çšºç›‚ç›ç›–ç›’ç›žç›¡ç›¥ç›§ç›ªè˜¯ç›»çœˆçœ‡çœ„çœ©çœ¤çœžçœ¥çœ¦çœ›çœ·çœ¸ç‡çšç¨ç«ç›ç¥ç¿ç¾ç¹çžŽçž‹çž‘çž çžžçž°çž¶çž¹çž¿çž¼çž½çž»çŸ‡çŸçŸ—çŸšçŸœçŸ£çŸ®çŸ¼ç Œç ’ç¤¦ç  ç¤ªç¡…ç¢Žç¡´ç¢†ç¡¼ç¢šç¢Œç¢£ç¢µç¢ªç¢¯ç£‘ç£†ç£‹ç£”ç¢¾ç¢¼ç£…ç£Šç£¬"],["e3a1","ç£§ç£šç£½ç£´ç¤‡ç¤’ç¤‘ç¤™ç¤¬ç¤«ç¥€ç¥ ç¥—ç¥Ÿç¥šç¥•ç¥“ç¥ºç¥¿ç¦Šç¦ç¦§é½‹ç¦ªç¦®ç¦³ç¦¹ç¦ºç§‰ç§•ç§§ç§¬ç§¡ç§£ç¨ˆç¨ç¨˜ç¨™ç¨ ç¨Ÿç¦€ç¨±ç¨»ç¨¾ç¨·ç©ƒç©—ç©‰ç©¡ç©¢ç©©é¾ç©°ç©¹ç©½çªˆçª—çª•çª˜çª–çª©ç«ˆçª°çª¶ç«…ç«„çª¿é‚ƒç«‡ç«Šç«ç«ç«•ç«“ç«™ç«šç«ç«¡ç«¢ç«¦ç«­ç«°ç¬‚ç¬ç¬Šç¬†ç¬³ç¬˜ç¬™ç¬žç¬µç¬¨ç¬¶ç­"],["e4a1","ç­ºç¬„ç­ç¬‹ç­Œç­…ç­µç­¥ç­´ç­§ç­°ç­±ç­¬ç­®ç®ç®˜ç®Ÿç®ç®œç®šç®‹ç®’ç®ç­ç®™ç¯‹ç¯ç¯Œç¯ç®´ç¯†ç¯ç¯©ç°‘ç°”ç¯¦ç¯¥ç± ç°€ç°‡ç°“ç¯³ç¯·ç°—ç°ç¯¶ç°£ç°§ç°ªç°Ÿç°·ç°«ç°½ç±Œç±ƒç±”ç±ç±€ç±ç±˜ç±Ÿç±¤ç±–ç±¥ç±¬ç±µç²ƒç²ç²¤ç²­ç²¢ç²«ç²¡ç²¨ç²³ç²²ç²±ç²®ç²¹ç²½ç³€ç³…ç³‚ç³˜ç³’ç³œç³¢é¬»ç³¯ç³²ç³´ç³¶ç³ºç´†"],["e5a1","ç´‚ç´œç´•ç´Šçµ…çµ‹ç´®ç´²ç´¿ç´µçµ†çµ³çµ–çµŽçµ²çµ¨çµ®çµçµ£ç¶“ç¶‰çµ›ç¶çµ½ç¶›ç¶ºç¶®ç¶£ç¶µç·‡ç¶½ç¶«ç¸½ç¶¢ç¶¯ç·œç¶¸ç¶Ÿç¶°ç·˜ç·ç·¤ç·žç·»ç·²ç·¡ç¸…ç¸Šç¸£ç¸¡ç¸’ç¸±ç¸Ÿç¸‰ç¸‹ç¸¢ç¹†ç¹¦ç¸»ç¸µç¸¹ç¹ƒç¸·ç¸²ç¸ºç¹§ç¹ç¹–ç¹žç¹™ç¹šç¹¹ç¹ªç¹©ç¹¼ç¹»çºƒç·•ç¹½è¾®ç¹¿çºˆçº‰çºŒçº’çºçº“çº”çº–çºŽçº›çºœç¼¸ç¼º"],["e6a1","ç½…ç½Œç½ç½Žç½ç½‘ç½•ç½”ç½˜ç½Ÿç½ ç½¨ç½©ç½§ç½¸ç¾‚ç¾†ç¾ƒç¾ˆç¾‡ç¾Œç¾”ç¾žç¾ç¾šç¾£ç¾¯ç¾²ç¾¹ç¾®ç¾¶ç¾¸è­±ç¿…ç¿†ç¿Šç¿•ç¿”ç¿¡ç¿¦ç¿©ç¿³ç¿¹é£œè€†è€„è€‹è€’è€˜è€™è€œè€¡è€¨è€¿è€»èŠè†è’è˜èšèŸè¢è¨è³è²è°è¶è¹è½è¿è‚„è‚†è‚…è‚›è‚“è‚šè‚­å†è‚¬èƒ›èƒ¥èƒ™èƒèƒ„èƒšèƒ–è„‰èƒ¯èƒ±è„›è„©è„£è„¯è…‹"],["e7a1","éš‹è…†è„¾è…“è…‘èƒ¼è…±è…®è…¥è…¦è…´è†ƒè†ˆè†Šè†€è†‚è† è†•è†¤è†£è…Ÿè†“è†©è†°è†µè†¾è†¸è†½è‡€è‡‚è†ºè‡‰è‡è‡‘è‡™è‡˜è‡ˆè‡šè‡Ÿè‡ è‡§è‡ºè‡»è‡¾èˆèˆ‚èˆ…èˆ‡èˆŠèˆèˆèˆ–èˆ©èˆ«èˆ¸èˆ³è‰€è‰™è‰˜è‰è‰šè‰Ÿè‰¤è‰¢è‰¨è‰ªè‰«èˆ®è‰±è‰·è‰¸è‰¾èŠèŠ’èŠ«èŠŸèŠ»èŠ¬è‹¡è‹£è‹Ÿè‹’è‹´è‹³è‹ºèŽ“èŒƒè‹»è‹¹è‹žèŒ†è‹œèŒ‰è‹™"],["e8a1","èŒµèŒ´èŒ–èŒ²èŒ±è€èŒ¹èè…èŒ¯èŒ«èŒ—èŒ˜èŽ…èŽšèŽªèŽŸèŽ¢èŽ–èŒ£èŽŽèŽ‡èŽŠè¼èŽµè³èµèŽ èŽ‰èŽ¨è´è“è«èŽè½èƒè˜è‹èè·è‡è è²èè¢è èŽ½è¸è”†è»è‘­èªè¼è•šè’„è‘·è‘«è’­è‘®è’‚è‘©è‘†è¬è‘¯è‘¹èµè“Šè‘¢è’¹è’¿è’Ÿè“™è“è’»è“šè“è“è“†è“–è’¡è”¡è“¿è“´è”—è”˜è”¬è”Ÿè”•è””è“¼è•€è•£è•˜è•ˆ"],["e9a1","è•è˜‚è•‹è••è–€è–¤è–ˆè–‘è–Šè–¨è•­è–”è–›è—ªè–‡è–œè•·è•¾è–è—‰è–ºè—è–¹è—è—•è—è—¥è—œè—¹è˜Šè˜“è˜‹è—¾è—ºè˜†è˜¢è˜šè˜°è˜¿è™ä¹•è™”è™Ÿè™§è™±èš“èš£èš©èšªèš‹èšŒèš¶èš¯è›„è›†èš°è›‰è £èš«è›”è›žè›©è›¬è›Ÿè››è›¯èœ’èœ†èœˆèœ€èœƒè›»èœ‘èœ‰èœè›¹èœŠèœ´èœ¿èœ·èœ»èœ¥èœ©èœšè èŸè¸èŒèŽè´è—è¨è®è™"],["eaa1","è“è£èªè …èž¢èžŸèž‚èž¯èŸ‹èž½èŸ€èŸé›–èž«èŸ„èž³èŸ‡èŸ†èž»èŸ¯èŸ²èŸ è è èŸ¾èŸ¶èŸ·è ŽèŸ’è ‘è –è •è ¢è ¡è ±è ¶è ¹è §è »è¡„è¡‚è¡’è¡™è¡žè¡¢è¡«è¢è¡¾è¢žè¡µè¡½è¢µè¡²è¢‚è¢—è¢’è¢®è¢™è¢¢è¢è¢¤è¢°è¢¿è¢±è£ƒè£„è£”è£˜è£™è£è£¹è¤‚è£¼è£´è£¨è£²è¤„è¤Œè¤Šè¤“è¥ƒè¤žè¤¥è¤ªè¤«è¥è¥„è¤»è¤¶è¤¸è¥Œè¤è¥ è¥ž"],["eba1","è¥¦è¥¤è¥­è¥ªè¥¯è¥´è¥·è¥¾è¦ƒè¦ˆè¦Šè¦“è¦˜è¦¡è¦©è¦¦è¦¬è¦¯è¦²è¦ºè¦½è¦¿è§€è§šè§œè§è§§è§´è§¸è¨ƒè¨–è¨è¨Œè¨›è¨è¨¥è¨¶è©è©›è©’è©†è©ˆè©¼è©­è©¬è©¢èª…èª‚èª„èª¨èª¡èª‘èª¥èª¦èªšèª£è«„è«è«‚è«šè««è«³è«§è«¤è«±è¬”è« è«¢è«·è«žè«›è¬Œè¬‡è¬šè«¡è¬–è¬è¬—è¬ è¬³éž«è¬¦è¬«è¬¾è¬¨è­è­Œè­è­Žè­‰è­–è­›è­šè­«"],["eca1","è­Ÿè­¬è­¯è­´è­½è®€è®Œè®Žè®’è®“è®–è®™è®šè°ºè±è°¿è±ˆè±Œè±Žè±è±•è±¢è±¬è±¸è±ºè²‚è²‰è²…è²Šè²è²Žè²”è±¼è²˜æˆè²­è²ªè²½è²²è²³è²®è²¶è³ˆè³è³¤è³£è³šè³½è³ºè³»è´„è´…è´Šè´‡è´è´è´é½Žè´“è³è´”è´–èµ§èµ­èµ±èµ³è¶è¶™è·‚è¶¾è¶ºè·è·šè·–è·Œè·›è·‹è·ªè·«è·Ÿè·£è·¼è¸ˆè¸‰è·¿è¸è¸žè¸è¸Ÿè¹‚è¸µè¸°è¸´è¹Š"],["eda1","è¹‡è¹‰è¹Œè¹è¹ˆè¹™è¹¤è¹ è¸ªè¹£è¹•è¹¶è¹²è¹¼èºèº‡èº…èº„èº‹èºŠèº“èº‘èº”èº™èºªèº¡èº¬èº°è»†èº±èº¾è»…è»ˆè»‹è»›è»£è»¼è»»è»«è»¾è¼Šè¼…è¼•è¼’è¼™è¼“è¼œè¼Ÿè¼›è¼Œè¼¦è¼³è¼»è¼¹è½…è½‚è¼¾è½Œè½‰è½†è½Žè½—è½œè½¢è½£è½¤è¾œè¾Ÿè¾£è¾­è¾¯è¾·è¿šè¿¥è¿¢è¿ªè¿¯é‚‡è¿´é€…è¿¹è¿ºé€‘é€•é€¡é€é€žé€–é€‹é€§é€¶é€µé€¹è¿¸"],["eea1","ééé‘é’é€Žé‰é€¾é–é˜éžé¨é¯é¶éš¨é²é‚‚é½é‚é‚€é‚Šé‚‰é‚é‚¨é‚¯é‚±é‚µéƒ¢éƒ¤æ‰ˆéƒ›é„‚é„’é„™é„²é„°é…Šé…–é…˜é…£é…¥é…©é…³é…²é†‹é†‰é†‚é†¢é†«é†¯é†ªé†µé†´é†ºé‡€é‡é‡‰é‡‹é‡é‡–é‡Ÿé‡¡é‡›é‡¼é‡µé‡¶éˆžé‡¿éˆ”éˆ¬éˆ•éˆ‘é‰žé‰—é‰…é‰‰é‰¤é‰ˆéŠ•éˆ¿é‰‹é‰éŠœéŠ–éŠ“éŠ›é‰šé‹éŠ¹éŠ·é‹©éŒé‹ºé„éŒ®"],["efa1","éŒ™éŒ¢éŒšéŒ£éŒºéŒµéŒ»éœé é¼é®é–éŽ°éŽ¬éŽ­éŽ”éŽ¹é–é—é¨é¥é˜éƒéééˆé¤éšé”é“éƒé‡éé¶é«éµé¡éºé‘é‘’é‘„é‘›é‘ é‘¢é‘žé‘ªéˆ©é‘°é‘µé‘·é‘½é‘šé‘¼é‘¾é’é‘¿é–‚é–‡é–Šé–”é––é–˜é–™é– é–¨é–§é–­é–¼é–»é–¹é–¾é—Šæ¿¶é—ƒé—é—Œé—•é—”é—–é—œé—¡é—¥é—¢é˜¡é˜¨é˜®é˜¯é™‚é™Œé™é™‹é™·é™œé™ž"],["f0a1","é™é™Ÿé™¦é™²é™¬éšéš˜éš•éš—éšªéš§éš±éš²éš°éš´éš¶éš¸éš¹é›Žé›‹é›‰é›è¥é›œéœé›•é›¹éœ„éœ†éœˆéœ“éœŽéœ‘éœéœ–éœ™éœ¤éœªéœ°éœ¹éœ½éœ¾é„é†éˆé‚é‰éœé é¤é¦é¨å‹’é«é±é¹éž…é¼éžéºéž†éž‹éžéžéžœéž¨éž¦éž£éž³éž´éŸƒéŸ†éŸˆéŸ‹éŸœéŸ­é½éŸ²ç«ŸéŸ¶éŸµé é Œé ¸é ¤é ¡é ·é ½é¡†é¡é¡‹é¡«é¡¯é¡°"],["f1a1","é¡±é¡´é¡³é¢ªé¢¯é¢±é¢¶é£„é£ƒé£†é£©é£«é¤ƒé¤‰é¤’é¤”é¤˜é¤¡é¤é¤žé¤¤é¤ é¤¬é¤®é¤½é¤¾é¥‚é¥‰é¥…é¥é¥‹é¥‘é¥’é¥Œé¥•é¦—é¦˜é¦¥é¦­é¦®é¦¼é§Ÿé§›é§é§˜é§‘é§­é§®é§±é§²é§»é§¸é¨é¨é¨…é§¢é¨™é¨«é¨·é©…é©‚é©€é©ƒé¨¾é©•é©é©›é©—é©Ÿé©¢é©¥é©¤é©©é©«é©ªéª­éª°éª¼é«€é«é«‘é«“é«”é«žé«Ÿé«¢é«£é«¦é«¯é««é«®é«´é«±é«·"],["f2a1","é«»é¬†é¬˜é¬šé¬Ÿé¬¢é¬£é¬¥é¬§é¬¨é¬©é¬ªé¬®é¬¯é¬²é­„é­ƒé­é­é­Žé­‘é­˜é­´é®“é®ƒé®‘é®–é®—é®Ÿé® é®¨é®´é¯€é¯Šé®¹é¯†é¯é¯‘é¯’é¯£é¯¢é¯¤é¯”é¯¡é°ºé¯²é¯±é¯°é°•é°”é°‰é°“é°Œé°†é°ˆé°’é°Šé°„é°®é°›é°¥é°¤é°¡é°°é±‡é°²é±†é°¾é±šé± é±§é±¶é±¸é³§é³¬é³°é´‰é´ˆé³«é´ƒé´†é´ªé´¦é¶¯é´£é´Ÿéµ„é´•é´’éµé´¿é´¾éµ†éµˆ"],["f3a1","éµéµžéµ¤éµ‘éµéµ™éµ²é¶‰é¶‡é¶«éµ¯éµºé¶šé¶¤é¶©é¶²é·„é·é¶»é¶¸é¶ºé·†é·é·‚é·™é·“é·¸é·¦é·­é·¯é·½é¸šé¸›é¸žé¹µé¹¹é¹½éºéºˆéº‹éºŒéº’éº•éº‘éºéº¥éº©éº¸éºªéº­é¡é»Œé»Žé»é»é»”é»œé»žé»é» é»¥é»¨é»¯é»´é»¶é»·é»¹é»»é»¼é»½é¼‡é¼ˆçš·é¼•é¼¡é¼¬é¼¾é½Šé½’é½”é½£é½Ÿé½ é½¡é½¦é½§é½¬é½ªé½·é½²é½¶é¾•é¾œé¾ "],["f4a1","å ¯æ§‡é™ç‘¤å‡œç†™"],["f9a1","çºŠè¤œéˆéŠˆè“œä¿‰ç‚»æ˜±æ£ˆé‹¹æ›»å½…ä¸¨ä»¡ä»¼ä¼€ä¼ƒä¼¹ä½–ä¾’ä¾Šä¾šä¾”ä¿å€å€¢ä¿¿å€žå†å°å‚å‚”åƒ´åƒ˜å…Šå…¤å†å†¾å‡¬åˆ•åŠœåŠ¦å‹€å‹›åŒ€åŒ‡åŒ¤å²åŽ“åŽ²åï¨Žå’œå’Šå’©å“¿å–†å™å¥åž¬åŸˆåŸ‡ï¨ï¨å¢žå¢²å¤‹å¥“å¥›å¥å¥£å¦¤å¦ºå­–å¯€ç”¯å¯˜å¯¬å°žå²¦å²ºå³µå´§åµ“ï¨‘åµ‚åµ­å¶¸å¶¹å·å¼¡å¼´å½§å¾·"],["faa1","å¿žææ‚…æ‚Šæƒžæƒ•æ„ æƒ²æ„‘æ„·æ„°æ†˜æˆ“æŠ¦æµæ‘ æ’æ“Žæ•Žæ˜€æ˜•æ˜»æ˜‰æ˜®æ˜žæ˜¤æ™¥æ™—æ™™ï¨’æ™³æš™æš æš²æš¿æ›ºæœŽï¤©æ¦æž»æ¡’æŸ€æ æ¡„æ£ï¨“æ¥¨ï¨”æ¦˜æ§¢æ¨°æ©«æ©†æ©³æ©¾æ«¢æ«¤æ¯–æ°¿æ±œæ²†æ±¯æ³šæ´„æ¶‡æµ¯æ¶–æ¶¬æ·æ·¸æ·²æ·¼æ¸¹æ¹œæ¸§æ¸¼æº¿æ¾ˆæ¾µæ¿µç€…ç€‡ç€¨ç‚…ç‚«ç„ç„„ç…œç…†ç…‡ï¨•ç‡ç‡¾çŠ±"],["fba1","çŠ¾çŒ¤ï¨–ç·çŽ½ç‰ç–ç£ç’ç‡çµç¦çªç©ç®ç‘¢ç’‰ç’Ÿç”ç•¯çš‚çšœçšžçš›çš¦ï¨—ç†åŠ¯ç ¡ç¡Žç¡¤ç¡ºç¤°ï¨˜ï¨™ï¨šç¦”ï¨›ç¦›ç«‘ç«§ï¨œç««ç®žï¨çµˆçµœç¶·ç¶ ç·–ç¹’ç½‡ç¾¡ï¨žèŒè¢è¿è‡è¶è‘ˆè’´è•“è•™è•«ï¨Ÿè–°ï¨ ï¨¡è ‡è£µè¨’è¨·è©¹èª§èª¾è«Ÿï¨¢è«¶è­“è­¿è³°è³´è´’èµ¶ï¨£è»ï¨¤ï¨¥é§éƒžï¨¦é„•é„§é‡š"],["fca1","é‡—é‡žé‡­é‡®é‡¤é‡¥éˆ†éˆéˆŠéˆºé‰€éˆ¼é‰Žé‰™é‰‘éˆ¹é‰§éŠ§é‰·é‰¸é‹§é‹—é‹™é‹ï¨§é‹•é‹ é‹“éŒ¥éŒ¡é‹»ï¨¨éŒžé‹¿éŒéŒ‚é°é—éŽ¤é†éžé¸é±é‘…é‘ˆé–’ï§œï¨©éšéš¯éœ³éœ»éƒééé‘é•é¡—é¡¥ï¨ªï¨«é¤§ï¨¬é¦žé©Žé«™é«œé­µé­²é®é®±é®»é°€éµ°éµ«ï¨­é¸™é»‘"],["fcf1","â…°",9,"ï¿¢ï¿¤ï¼‡ï¼‚"],["8fa2af","Ë˜Ë‡Â¸Ë™ËÂ¯Ë›Ëšï½žÎ„Î…"],["8fa2c2","Â¡Â¦Â¿"],["8fa2eb","ÂºÂªÂ©Â®â„¢Â¤â„–"],["8fa6e1","Î†ÎˆÎ‰ÎŠÎª"],["8fa6e7","ÎŒ"],["8fa6e9","ÎŽÎ«"],["8fa6ec","Î"],["8fa6f1","Î¬Î­Î®Î¯ÏŠÎÏŒÏ‚ÏÏ‹Î°ÏŽ"],["8fa7c2","Ð‚",10,"ÐŽÐ"],["8fa7f2","Ñ’",10,"ÑžÑŸ"],["8fa9a1","Ã†Ä"],["8fa9a4","Ä¦"],["8fa9a6","Ä²"],["8fa9a8","ÅÄ¿"],["8fa9ab","ÅŠÃ˜Å’"],["8fa9af","Å¦Ãž"],["8fa9c1","Ã¦Ä‘Ã°Ä§Ä±Ä³Ä¸Å‚Å€Å‰Å‹Ã¸Å“ÃŸÅ§Ã¾"],["8faaa1","ÃÃ€Ã„Ã‚Ä‚ÇÄ€Ä„Ã…ÃƒÄ†ÄˆÄŒÃ‡ÄŠÄŽÃ‰ÃˆÃ‹ÃŠÄšÄ–Ä’Ä˜"],["8faaba","ÄœÄžÄ¢Ä Ä¤ÃÃŒÃÃŽÇÄ°ÄªÄ®Ä¨Ä´Ä¶Ä¹Ä½Ä»ÅƒÅ‡Å…Ã‘Ã“Ã’Ã–Ã”Ç‘ÅÅŒÃ•Å”Å˜Å–ÅšÅœÅ ÅžÅ¤Å¢ÃšÃ™ÃœÃ›Å¬Ç“Å°ÅªÅ²Å®Å¨Ç—Ç›Ç™Ç•Å´ÃÅ¸Å¶Å¹Å½Å»"],["8faba1","Ã¡Ã Ã¤Ã¢ÄƒÇŽÄÄ…Ã¥Ã£Ä‡Ä‰ÄÃ§Ä‹ÄÃ©Ã¨Ã«ÃªÄ›Ä—Ä“Ä™ÇµÄÄŸ"],["8fabbd","Ä¡Ä¥Ã­Ã¬Ã¯Ã®Ç"],["8fabc5","Ä«Ä¯Ä©ÄµÄ·ÄºÄ¾Ä¼Å„ÅˆÅ†Ã±Ã³Ã²Ã¶Ã´Ç’Å‘ÅÃµÅ•Å™Å—Å›ÅÅ¡ÅŸÅ¥Å£ÃºÃ¹Ã¼Ã»Å­Ç”Å±Å«Å³Å¯Å©Ç˜ÇœÇšÇ–ÅµÃ½Ã¿Å·ÅºÅ¾Å¼"],["8fb0a1","ä¸‚ä¸„ä¸…ä¸Œä¸’ä¸Ÿä¸£ä¸¤ä¸¨ä¸«ä¸®ä¸¯ä¸°ä¸µä¹€ä¹ä¹„ä¹‡ä¹‘ä¹šä¹œä¹£ä¹¨ä¹©ä¹´ä¹µä¹¹ä¹¿äºäº–äº—äºäº¯äº¹ä»ƒä»ä»šä»›ä» ä»¡ä»¢ä»¨ä»¯ä»±ä»³ä»µä»½ä»¾ä»¿ä¼€ä¼‚ä¼ƒä¼ˆä¼‹ä¼Œä¼’ä¼•ä¼–ä¼—ä¼™ä¼®ä¼±ä½ ä¼³ä¼µä¼·ä¼¹ä¼»ä¼¾ä½€ä½‚ä½ˆä½‰ä½‹ä½Œä½’ä½”ä½–ä½˜ä½Ÿä½£ä½ªä½¬ä½®ä½±ä½·ä½¸ä½¹ä½ºä½½ä½¾ä¾ä¾‚ä¾„"],["8fb1a1","ä¾…ä¾‰ä¾Šä¾Œä¾Žä¾ä¾’ä¾“ä¾”ä¾—ä¾™ä¾šä¾žä¾Ÿä¾²ä¾·ä¾¹ä¾»ä¾¼ä¾½ä¾¾ä¿€ä¿ä¿…ä¿†ä¿ˆä¿‰ä¿‹ä¿Œä¿ä¿ä¿’ä¿œä¿ ä¿¢ä¿°ä¿²ä¿¼ä¿½ä¿¿å€€å€å€„å€‡å€Šå€Œå€Žå€å€“å€—å€˜å€›å€œå€å€žå€¢å€§å€®å€°å€²å€³å€µå€åå‚å…å†åŠåŒåŽå‘å’å“å—å™åŸå å¢å£å¦å§åªå­å°å±å€»å‚å‚ƒå‚„å‚†å‚Šå‚Žå‚å‚"],["8fb2a1","å‚’å‚“å‚”å‚–å‚›å‚œå‚ž",4,"å‚ªå‚¯å‚°å‚¹å‚ºå‚½åƒ€åƒƒåƒ„åƒ‡åƒŒåƒŽåƒåƒ“åƒ”åƒ˜åƒœåƒåƒŸåƒ¢åƒ¤åƒ¦åƒ¨åƒ©åƒ¯åƒ±åƒ¶åƒºåƒ¾å„ƒå„†å„‡å„ˆå„‹å„Œå„å„Žåƒ²å„å„—å„™å„›å„œå„å„žå„£å„§å„¨å„¬å„­å„¯å„±å„³å„´å„µå„¸å„¹å…‚å…Šå…å…“å…•å…—å…˜å…Ÿå…¤å…¦å…¾å†ƒå†„å†‹å†Žå†˜å†å†¡å†£å†­å†¸å†ºå†¼å†¾å†¿å‡‚"],["8fb3a1","å‡ˆå‡å‡‘å‡’å‡“å‡•å‡˜å‡žå‡¢å‡¥å‡®å‡²å‡³å‡´å‡·åˆåˆ‚åˆ…åˆ’åˆ“åˆ•åˆ–åˆ˜åˆ¢åˆ¨åˆ±åˆ²åˆµåˆ¼å‰…å‰‰å‰•å‰—å‰˜å‰šå‰œå‰Ÿå‰ å‰¡å‰¦å‰®å‰·å‰¸å‰¹åŠ€åŠ‚åŠ…åŠŠåŠŒåŠ“åŠ•åŠ–åŠ—åŠ˜åŠšåŠœåŠ¤åŠ¥åŠ¦åŠ§åŠ¯åŠ°åŠ¶åŠ·åŠ¸åŠºåŠ»åŠ½å‹€å‹„å‹†å‹ˆå‹Œå‹å‹‘å‹”å‹–å‹›å‹œå‹¡å‹¥å‹¨å‹©å‹ªå‹¬å‹°å‹±å‹´å‹¶å‹·åŒ€åŒƒåŒŠåŒ‹"],["8fb4a1","åŒŒåŒ‘åŒ“åŒ˜åŒ›åŒœåŒžåŒŸåŒ¥åŒ§åŒ¨åŒ©åŒ«åŒ¬åŒ­åŒ°åŒ²åŒµåŒ¼åŒ½åŒ¾å‚åŒå‹å™å›å¡å£å¥å¬å­å²å¹å¾åŽƒåŽ‡åŽˆåŽŽåŽ“åŽ”åŽ™åŽåŽ¡åŽ¤åŽªåŽ«åŽ¯åŽ²åŽ´åŽµåŽ·åŽ¸åŽºåŽ½å€å…åå’å“å•åšååžå å¦å§åµå‚å“åšå¡å§å¨åªå¯å±å´åµå‘ƒå‘„å‘‡å‘å‘å‘žå‘¢å‘¤å‘¦å‘§å‘©å‘«å‘­å‘®å‘´å‘¿"],["8fb5a1","å’å’ƒå’…å’ˆå’‰å’å’‘å’•å’–å’œå’Ÿå’¡å’¦å’§å’©å’ªå’­å’®å’±å’·å’¹å’ºå’»å’¿å“†å“Šå“å“Žå“ å“ªå“¬å“¯å“¶å“¼å“¾å“¿å”€å”å”…å”ˆå”‰å”Œå”å”Žå”•å”ªå”«å”²å”µå”¶å”»å”¼å”½å•å•‡å•‰å•Šå•å•å•‘å•˜å•šå•›å•žå• å•¡å•¤å•¦å•¿å–å–‚å–†å–ˆå–Žå–å–‘å–’å–“å–”å–—å–£å–¤å–­å–²å–¿å—å—ƒå—†å—‰å—‹å—Œå—Žå—‘å—’"],["8fb6a1","å—“å——å—˜å—›å—žå—¢å—©å—¶å—¿å˜…å˜ˆå˜Šå˜",5,"å˜™å˜¬å˜°å˜³å˜µå˜·å˜¹å˜»å˜¼å˜½å˜¿å™€å™å™ƒå™„å™†å™‰å™‹å™å™å™”å™žå™ å™¡å™¢å™£å™¦å™©å™­å™¯å™±å™²å™µåš„åš…åšˆåš‹åšŒåš•åš™åššåšåšžåšŸåš¦åš§åš¨åš©åš«åš¬åš­åš±åš³åš·åš¾å›…å›‰å›Šå›‹å›å›å›Œå›å›™å›œå›å›Ÿå›¡å›¤",4,"å›±å›«å›­"],["8fb7a1","å›¶å›·åœåœ‚åœ‡åœŠåœŒåœ‘åœ•åœšåœ›åœåœ åœ¢åœ£åœ¤åœ¥åœ©åœªåœ¬åœ®åœ¯åœ³åœ´åœ½åœ¾åœ¿å…å†åŒåå’å¢å¥å§å¨å«å­",4,"å³å´åµå·å¹åºå»å¼å¾åžåžƒåžŒåž”åž—åž™åžšåžœåžåžžåžŸåž¡åž•åž§åž¨åž©åž¬åž¸åž½åŸ‡åŸˆåŸŒåŸåŸ•åŸåŸžåŸ¤åŸ¦åŸ§åŸ©åŸ­åŸ°åŸµåŸ¶åŸ¸åŸ½åŸ¾åŸ¿å ƒå „å ˆå ‰åŸ¡"],["8fb8a1","å Œå å ›å žå Ÿå  å ¦å §å ­å ²å ¹å ¿å¡‰å¡Œå¡å¡å¡å¡•å¡Ÿå¡¡å¡¤å¡§å¡¨å¡¸å¡¼å¡¿å¢€å¢å¢‡å¢ˆå¢‰å¢Šå¢Œå¢å¢å¢å¢”å¢–å¢å¢ å¢¡å¢¢å¢¦å¢©å¢±å¢²å£„å¢¼å£‚å£ˆå£å£Žå£å£’å£”å£–å£šå£å£¡å£¢å£©å£³å¤…å¤†å¤‹å¤Œå¤’å¤“å¤”è™å¤å¤¡å¤£å¤¤å¤¨å¤¯å¤°å¤³å¤µå¤¶å¤¿å¥ƒå¥†å¥’å¥“å¥™å¥›å¥å¥žå¥Ÿå¥¡å¥£å¥«å¥­"],["8fb9a1","å¥¯å¥²å¥µå¥¶å¥¹å¥»å¥¼å¦‹å¦Œå¦Žå¦’å¦•å¦—å¦Ÿå¦¤å¦§å¦­å¦®å¦¯å¦°å¦³å¦·å¦ºå¦¼å§å§ƒå§„å§ˆå§Šå§å§’å§å§žå§Ÿå§£å§¤å§§å§®å§¯å§±å§²å§´å§·å¨€å¨„å¨Œå¨å¨Žå¨’å¨“å¨žå¨£å¨¤å¨§å¨¨å¨ªå¨­å¨°å©„å©…å©‡å©ˆå©Œå©å©•å©žå©£å©¥å©§å©­å©·å©ºå©»å©¾åª‹åªåª“åª–åª™åªœåªžåªŸåª åª¢åª§åª¬åª±åª²åª³åªµåª¸åªºåª»åª¿"],["8fbaa1","å«„å«†å«ˆå«å«šå«œå« å«¥å«ªå«®å«µå«¶å«½å¬€å¬å¬ˆå¬—å¬´å¬™å¬›å¬å¬¡å¬¥å¬­å¬¸å­å­‹å­Œå­’å­–å­žå­¨å­®å­¯å­¼å­½å­¾å­¿å®å®„å®†å®Šå®Žå®å®‘å®“å®”å®–å®¨å®©å®¬å®­å®¯å®±å®²å®·å®ºå®¼å¯€å¯å¯å¯å¯–",4,"å¯ å¯¯å¯±å¯´å¯½å°Œå°—å°žå°Ÿå°£å°¦å°©å°«å°¬å°®å°°å°²å°µå°¶å±™å±šå±œå±¢å±£å±§å±¨å±©"],["8fbba1","å±­å±°å±´å±µå±ºå±»å±¼å±½å²‡å²ˆå²Šå²å²’å²å²Ÿå² å²¢å²£å²¦å²ªå²²å²´å²µå²ºå³‰å³‹å³’å³å³—å³®å³±å³²å³´å´å´†å´å´’å´«å´£å´¤å´¦å´§å´±å´´å´¹å´½å´¿åµ‚åµƒåµ†åµˆåµ•åµ‘åµ™åµŠåµŸåµ åµ¡åµ¢åµ¤åµªåµ­åµ°åµ¹åµºåµ¾åµ¿å¶å¶ƒå¶ˆå¶Šå¶’å¶“å¶”å¶•å¶™å¶›å¶Ÿå¶ å¶§å¶«å¶°å¶´å¶¸å¶¹å·ƒå·‡å·‹å·å·Žå·˜å·™å· å·¤"],["8fbca1","å·©å·¸å·¹å¸€å¸‡å¸å¸’å¸”å¸•å¸˜å¸Ÿå¸ å¸®å¸¨å¸²å¸µå¸¾å¹‹å¹å¹‰å¹‘å¹–å¹˜å¹›å¹œå¹žå¹¨å¹ª",4,"å¹°åº€åº‹åºŽåº¢åº¤åº¥åº¨åºªåº¬åº±åº³åº½åº¾åº¿å»†å»Œå»‹å»Žå»‘å»’å»”å»•å»œå»žå»¥å»«å¼‚å¼†å¼‡å¼ˆå¼Žå¼™å¼œå¼å¼¡å¼¢å¼£å¼¤å¼¨å¼«å¼¬å¼®å¼°å¼´å¼¶å¼»å¼½å¼¿å½€å½„å½…å½‡å½å½å½”å½˜å½›å½ å½£å½¤å½§"],["8fbda1","å½¯å½²å½´å½µå½¸å½ºå½½å½¾å¾‰å¾å¾å¾–å¾œå¾å¾¢å¾§å¾«å¾¤å¾¬å¾¯å¾°å¾±å¾¸å¿„å¿‡å¿ˆå¿‰å¿‹å¿",4,"å¿žå¿¡å¿¢å¿¨å¿©å¿ªå¿¬å¿­å¿®å¿¯å¿²å¿³å¿¶å¿ºå¿¼æ€‡æ€Šæ€æ€“æ€”æ€—æ€˜æ€šæ€Ÿæ€¤æ€­æ€³æ€µæ€æ‡æˆæ‰æŒæ‘æ”æ–æ—ææ¡æ§æ±æ¾æ¿æ‚‚æ‚†æ‚ˆæ‚Šæ‚Žæ‚‘æ‚“æ‚•æ‚˜æ‚æ‚žæ‚¢æ‚¤æ‚¥æ‚¨æ‚°æ‚±æ‚·"],["8fbea1","æ‚»æ‚¾æƒ‚æƒ„æƒˆæƒ‰æƒŠæƒ‹æƒŽæƒæƒ”æƒ•æƒ™æƒ›æƒæƒžæƒ¢æƒ¥æƒ²æƒµæƒ¸æƒ¼æƒ½æ„‚æ„‡æ„Šæ„Œæ„",4,"æ„–æ„—æ„™æ„œæ„žæ„¢æ„ªæ„«æ„°æ„±æ„µæ„¶æ„·æ„¹æ…æ……æ…†æ…‰æ…žæ… æ…¬æ…²æ…¸æ…»æ…¼æ…¿æ†€æ†æ†ƒæ†„æ†‹æ†æ†’æ†“æ†—æ†˜æ†œæ†æ†Ÿæ† æ†¥æ†¨æ†ªæ†­æ†¸æ†¹æ†¼æ‡€æ‡æ‡‚æ‡Žæ‡æ‡•æ‡œæ‡æ‡žæ‡Ÿæ‡¡æ‡¢æ‡§æ‡©æ‡¥"],["8fbfa1","æ‡¬æ‡­æ‡¯æˆæˆƒæˆ„æˆ‡æˆ“æˆ•æˆœæˆ æˆ¢æˆ£æˆ§æˆ©æˆ«æˆ¹æˆ½æ‰‚æ‰ƒæ‰„æ‰†æ‰Œæ‰æ‰‘æ‰’æ‰”æ‰–æ‰šæ‰œæ‰¤æ‰­æ‰¯æ‰³æ‰ºæ‰½æŠæŠŽæŠæŠæŠ¦æŠ¨æŠ³æŠ¶æŠ·æŠºæŠ¾æŠ¿æ‹„æ‹Žæ‹•æ‹–æ‹šæ‹ªæ‹²æ‹´æ‹¼æ‹½æŒƒæŒ„æŒŠæŒ‹æŒæŒæŒ“æŒ–æŒ˜æŒ©æŒªæŒ­æŒµæŒ¶æŒ¹æŒ¼ææ‚æƒæ„æ†æŠæ‹æŽæ’æ“æ”æ˜æ›æ¥æ¦æ¬æ­æ±æ´æµ"],["8fc0a1","æ¸æ¼æ½æ¿æŽ‚æŽ„æŽ‡æŽŠæŽæŽ”æŽ•æŽ™æŽšæŽžæŽ¤æŽ¦æŽ­æŽ®æŽ¯æŽ½ææ…æˆæŽæ‘æ“æ”æ•æœæ æ¥æªæ¬æ²æ³æµæ¸æ¹æ‰æŠææ’æ”æ˜æžæ æ¢æ¤æ¥æ©æªæ¯æ°æµæ½æ¿æ‘‹æ‘æ‘‘æ‘’æ‘“æ‘”æ‘šæ‘›æ‘œæ‘æ‘Ÿæ‘ æ‘¡æ‘£æ‘­æ‘³æ‘´æ‘»æ‘½æ’…æ’‡æ’æ’æ’‘æ’˜æ’™æ’›æ’æ’Ÿæ’¡æ’£æ’¦æ’¨æ’¬æ’³æ’½æ’¾æ’¿"],["8fc1a1","æ“„æ“‰æ“Šæ“‹æ“Œæ“Žæ“æ“‘æ“•æ“—æ“¤æ“¥æ“©æ“ªæ“­æ“°æ“µæ“·æ“»æ“¿æ”æ”„æ”ˆæ”‰æ”Šæ”æ”“æ””æ”–æ”™æ”›æ”žæ”Ÿæ”¢æ”¦æ”©æ”®æ”±æ”ºæ”¼æ”½æ•ƒæ•‡æ•‰æ•æ•’æ•”æ•Ÿæ• æ•§æ•«æ•ºæ•½æ–æ–…æ–Šæ–’æ–•æ–˜æ–æ– æ–£æ–¦æ–®æ–²æ–³æ–´æ–¿æ—‚æ—ˆæ—‰æ—Žæ—æ—”æ—–æ—˜æ—Ÿæ—°æ—²æ—´æ—µæ—¹æ—¾æ—¿æ˜€æ˜„æ˜ˆæ˜‰æ˜æ˜‘æ˜’æ˜•æ˜–æ˜"],["8fc2a1","æ˜žæ˜¡æ˜¢æ˜£æ˜¤æ˜¦æ˜©æ˜ªæ˜«æ˜¬æ˜®æ˜°æ˜±æ˜³æ˜¹æ˜·æ™€æ™…æ™†æ™Šæ™Œæ™‘æ™Žæ™—æ™˜æ™™æ™›æ™œæ™ æ™¡æ›»æ™ªæ™«æ™¬æ™¾æ™³æ™µæ™¿æ™·æ™¸æ™¹æ™»æš€æ™¼æš‹æšŒæšæšæš’æš™æššæš›æšœæšŸæš æš¤æš­æš±æš²æšµæš»æš¿æ›€æ›‚æ›ƒæ›ˆæ›Œæ›Žæ›æ›”æ››æ›Ÿæ›¨æ›«æ›¬æ›®æ›ºæœ…æœ‡æœŽæœ“æœ™æœœæœ æœ¢æœ³æœ¾æ…æ‡æˆæŒæ”æ•æ"],["8fc3a1","æ¦æ¬æ®æ´æ¶æ»æžæž„æžŽæžæž‘æž“æž–æž˜æž™æž›æž°æž±æž²æžµæž»æž¼æž½æŸ¹æŸ€æŸ‚æŸƒæŸ…æŸˆæŸ‰æŸ’æŸ—æŸ™æŸœæŸ¡æŸ¦æŸ°æŸ²æŸ¶æŸ·æ¡’æ ”æ ™æ æ Ÿæ ¨æ §æ ¬æ ­æ ¯æ °æ ±æ ³æ »æ ¿æ¡„æ¡…æ¡Šæ¡Œæ¡•æ¡—æ¡˜æ¡›æ¡«æ¡®",4,"æ¡µæ¡¹æ¡ºæ¡»æ¡¼æ¢‚æ¢„æ¢†æ¢ˆæ¢–æ¢˜æ¢šæ¢œæ¢¡æ¢£æ¢¥æ¢©æ¢ªæ¢®æ¢²æ¢»æ£…æ£ˆæ£Œæ£"],["8fc4a1","æ£æ£‘æ£“æ£–æ£™æ£œæ£æ£¥æ£¨æ£ªæ£«æ£¬æ£­æ£°æ£±æ£µæ£¶æ£»æ£¼æ£½æ¤†æ¤‰æ¤Šæ¤æ¤‘æ¤“æ¤–æ¤—æ¤±æ¤³æ¤µæ¤¸æ¤»æ¥‚æ¥…æ¥‰æ¥Žæ¥—æ¥›æ¥£æ¥¤æ¥¥æ¥¦æ¥¨æ¥©æ¥¬æ¥°æ¥±æ¥²æ¥ºæ¥»æ¥¿æ¦€æ¦æ¦’æ¦–æ¦˜æ¦¡æ¦¥æ¦¦æ¦¨æ¦«æ¦­æ¦¯æ¦·æ¦¸æ¦ºæ¦¼æ§…æ§ˆæ§‘æ§–æ§—æ§¢æ§¥æ§®æ§¯æ§±æ§³æ§µæ§¾æ¨€æ¨æ¨ƒæ¨æ¨‘æ¨•æ¨šæ¨æ¨ æ¨¤æ¨¨æ¨°æ¨²"],["8fc5a1","æ¨´æ¨·æ¨»æ¨¾æ¨¿æ©…æ©†æ©‰æ©Šæ©Žæ©æ©‘æ©’æ©•æ©–æ©›æ©¤æ©§æ©ªæ©±æ©³æ©¾æªæªƒæª†æª‡æª‰æª‹æª‘æª›æªæªžæªŸæª¥æª«æª¯æª°æª±æª´æª½æª¾æª¿æ«†æ«‰æ«ˆæ«Œæ«æ«”æ«•æ«–æ«œæ«æ«¤æ«§æ«¬æ«°æ«±æ«²æ«¼æ«½æ¬‚æ¬ƒæ¬†æ¬‡æ¬‰æ¬æ¬æ¬‘æ¬—æ¬›æ¬žæ¬¤æ¬¨æ¬«æ¬¬æ¬¯æ¬µæ¬¶æ¬»æ¬¿æ­†æ­Šæ­æ­’æ­–æ­˜æ­æ­ æ­§æ­«æ­®æ­°æ­µæ­½"],["8fc6a1","æ­¾æ®‚æ®…æ®—æ®›æ®Ÿæ® æ®¢æ®£æ®¨æ®©æ®¬æ®­æ®®æ®°æ®¸æ®¹æ®½æ®¾æ¯ƒæ¯„æ¯‰æ¯Œæ¯–æ¯šæ¯¡æ¯£æ¯¦æ¯§æ¯®æ¯±æ¯·æ¯¹æ¯¿æ°‚æ°„æ°…æ°‰æ°æ°Žæ°æ°’æ°™æ°Ÿæ°¦æ°§æ°¨æ°¬æ°®æ°³æ°µæ°¶æ°ºæ°»æ°¿æ±Šæ±‹æ±æ±æ±’æ±”æ±™æ±›æ±œæ±«æ±­æ±¯æ±´æ±¶æ±¸æ±¹æ±»æ²…æ²†æ²‡æ²‰æ²”æ²•æ²—æ²˜æ²œæ²Ÿæ²°æ²²æ²´æ³‚æ³†æ³æ³æ³æ³‘æ³’æ³”æ³–"],["8fc7a1","æ³šæ³œæ³ æ³§æ³©æ³«æ³¬æ³®æ³²æ³´æ´„æ´‡æ´Šæ´Žæ´æ´‘æ´“æ´šæ´¦æ´§æ´¨æ±§æ´®æ´¯æ´±æ´¹æ´¼æ´¿æµ—æµžæµŸæµ¡æµ¥æµ§æµ¯æµ°æµ¼æ¶‚æ¶‡æ¶‘æ¶’æ¶”æ¶–æ¶—æ¶˜æ¶ªæ¶¬æ¶´æ¶·æ¶¹æ¶½æ¶¿æ·„æ·ˆæ·Šæ·Žæ·æ·–æ·›æ·æ·Ÿæ· æ·¢æ·¥æ·©æ·¯æ·°æ·´æ·¶æ·¼æ¸€æ¸„æ¸žæ¸¢æ¸§æ¸²æ¸¶æ¸¹æ¸»æ¸¼æ¹„æ¹…æ¹ˆæ¹‰æ¹‹æ¹æ¹‘æ¹’æ¹“æ¹”æ¹—æ¹œæ¹æ¹ž"],["8fc8a1","æ¹¢æ¹£æ¹¨æ¹³æ¹»æ¹½æºæº“æº™æº æº§æº­æº®æº±æº³æº»æº¿æ»€æ»æ»ƒæ»‡æ»ˆæ»Šæ»æ»Žæ»æ»«æ»­æ»®æ»¹æ»»æ»½æ¼„æ¼ˆæ¼Šæ¼Œæ¼æ¼–æ¼˜æ¼šæ¼›æ¼¦æ¼©æ¼ªæ¼¯æ¼°æ¼³æ¼¶æ¼»æ¼¼æ¼­æ½æ½‘æ½’æ½“æ½—æ½™æ½šæ½æ½žæ½¡æ½¢æ½¨æ½¬æ½½æ½¾æ¾ƒæ¾‡æ¾ˆæ¾‹æ¾Œæ¾æ¾æ¾’æ¾“æ¾”æ¾–æ¾šæ¾Ÿæ¾ æ¾¥æ¾¦æ¾§æ¾¨æ¾®æ¾¯æ¾°æ¾µæ¾¶æ¾¼æ¿…æ¿‡æ¿ˆæ¿Š"],["8fc9a1","æ¿šæ¿žæ¿¨æ¿©æ¿°æ¿µæ¿¹æ¿¼æ¿½ç€€ç€…ç€†ç€‡ç€ç€—ç€ ç€£ç€¯ç€´ç€·ç€¹ç€¼çƒç„çˆç‰çŠç‹ç”ç•ççžçŽç¤ç¥ç¬ç®çµç¶ç¾ç‚ç‚…ç‚†ç‚”",4,"ç‚›ç‚¤ç‚«ç‚°ç‚±ç‚´ç‚·çƒŠçƒ‘çƒ“çƒ”çƒ•çƒ–çƒ˜çƒœçƒ¤çƒºç„ƒ",4,"ç„‹ç„Œç„ç„žç„ ç„«ç„­ç„¯ç„°ç„±ç„¸ç…ç……ç…†ç…‡ç…Šç…‹ç…ç…’ç…—ç…šç…œç…žç… "],["8fcaa1","ç…¨ç…¹ç†€ç†…ç†‡ç†Œç†’ç†šç†›ç† ç†¢ç†¯ç†°ç†²ç†³ç†ºç†¿ç‡€ç‡ç‡„ç‡‹ç‡Œç‡“ç‡–ç‡™ç‡šç‡œç‡¸ç‡¾çˆ€çˆ‡çˆˆçˆ‰çˆ“çˆ—çˆšçˆçˆŸçˆ¤çˆ«çˆ¯çˆ´çˆ¸çˆ¹ç‰ç‰‚ç‰ƒç‰…ç‰Žç‰ç‰ç‰“ç‰•ç‰–ç‰šç‰œç‰žç‰ ç‰£ç‰¨ç‰«ç‰®ç‰¯ç‰±ç‰·ç‰¸ç‰»ç‰¼ç‰¿çŠ„çŠ‰çŠçŠŽçŠ“çŠ›çŠ¨çŠ­çŠ®çŠ±çŠ´çŠ¾ç‹ç‹‡ç‹‰ç‹Œç‹•ç‹–ç‹˜ç‹Ÿç‹¥ç‹³ç‹´ç‹ºç‹»"],["8fcba1","ç‹¾çŒ‚çŒ„çŒ…çŒ‡çŒ‹çŒçŒ’çŒ“çŒ˜çŒ™çŒžçŒ¢çŒ¤çŒ§çŒ¨çŒ¬çŒ±çŒ²çŒµçŒºçŒ»çŒ½çƒççç’ç–ç˜ççžçŸç ç¦ç§ç©ç«ç¬ç®ç¯ç±ç·ç¹ç¼çŽ€çŽçŽƒçŽ…çŽ†çŽŽçŽçŽ“çŽ•çŽ—çŽ˜çŽœçŽžçŽŸçŽ çŽ¢çŽ¥çŽ¦çŽªçŽ«çŽ­çŽµçŽ·çŽ¹çŽ¼çŽ½çŽ¿ç…ç†ç‰ç‹çŒçç’ç“ç–ç™çç¡ç£ç¦ç§ç©ç´çµç·ç¹çºç»ç½"],["8fcca1","ç¿ç€çç„ç‡çŠç‘çšç›ç¤ç¦ç¨",9,"ç¹ç‘€ç‘ƒç‘„ç‘†ç‘‡ç‘‹ç‘ç‘‘ç‘’ç‘—ç‘ç‘¢ç‘¦ç‘§ç‘¨ç‘«ç‘­ç‘®ç‘±ç‘²ç’€ç’ç’…ç’†ç’‡ç’‰ç’ç’ç’‘ç’’ç’˜ç’™ç’šç’œç’Ÿç’ ç’¡ç’£ç’¦ç’¨ç’©ç’ªç’«ç’®ç’¯ç’±ç’²ç’µç’¹ç’»ç’¿ç“ˆç“‰ç“Œç“ç““ç“˜ç“šç“›ç“žç“Ÿç“¤ç“¨ç“ªç“«ç“¯ç“´ç“ºç“»ç“¼ç“¿ç”†"],["8fcda1","ç”’ç”–ç”—ç” ç”¡ç”¤ç”§ç”©ç”ªç”¯ç”¶ç”¹ç”½ç”¾ç”¿ç•€ç•ƒç•‡ç•ˆç•Žç•ç•’ç•—ç•žç•Ÿç•¡ç•¯ç•±ç•¹",5,"ç–ç–…ç–ç–’ç–“ç–•ç–™ç–œç–¢ç–¤ç–´ç–ºç–¿ç—€ç—ç—„ç—†ç—Œç—Žç—ç——ç—œç—Ÿç— ç—¡ç—¤ç—§ç—¬ç—®ç—¯ç—±ç—¹ç˜€ç˜‚ç˜ƒç˜„ç˜‡ç˜ˆç˜Šç˜Œç˜ç˜’ç˜“ç˜•ç˜–ç˜™ç˜›ç˜œç˜ç˜žç˜£ç˜¥ç˜¦ç˜©ç˜­ç˜²ç˜³ç˜µç˜¸ç˜¹"],["8fcea1","ç˜ºç˜¼ç™Šç™€ç™ç™ƒç™„ç™…ç™‰ç™‹ç™•ç™™ç™Ÿç™¤ç™¥ç™­ç™®ç™¯ç™±ç™´çšçš…çšŒçšçš•çš›çšœçšçšŸçš çš¢",6,"çšªçš­çš½ç›ç›…ç›‰ç›‹ç›Œç›Žç›”ç›™ç› ç›¦ç›¨ç›¬ç›°ç›±ç›¶ç›¹ç›¼çœ€çœ†çœŠçœŽçœ’çœ”çœ•çœ—çœ™çœšçœœçœ¢çœ¨çœ­çœ®çœ¯çœ´çœµçœ¶çœ¹çœ½çœ¾ç‚ç…ç†çŠççŽçç’ç–ç—çœçžçŸç ç¢"],["8fcfa1","ç¤ç§çªç¬ç°ç²ç³ç´çºç½çž€çž„çžŒçžçž”çž•çž–çžšçžŸçž¢çž§çžªçž®çž¯çž±çžµçž¾çŸƒçŸ‰çŸ‘çŸ’çŸ•çŸ™çŸžçŸŸçŸ çŸ¤çŸ¦çŸªçŸ¬çŸ°çŸ±çŸ´çŸ¸çŸ»ç …ç †ç ‰ç ç Žç ‘ç ç ¡ç ¢ç £ç ­ç ®ç °ç µç ·ç¡ƒç¡„ç¡‡ç¡ˆç¡Œç¡Žç¡’ç¡œç¡žç¡ ç¡¡ç¡£ç¡¤ç¡¨ç¡ªç¡®ç¡ºç¡¾ç¢Šç¢ç¢”ç¢˜ç¢¡ç¢ç¢žç¢Ÿç¢¤ç¢¨ç¢¬ç¢­ç¢°ç¢±ç¢²ç¢³"],["8fd0a1","ç¢»ç¢½ç¢¿ç£‡ç£ˆç£‰ç£Œç£Žç£’ç£“ç£•ç£–ç£¤ç£›ç£Ÿç£ ç£¡ç£¦ç£ªç£²ç£³ç¤€ç£¶ç£·ç£ºç£»ç£¿ç¤†ç¤Œç¤ç¤šç¤œç¤žç¤Ÿç¤ ç¤¥ç¤§ç¤©ç¤­ç¤±ç¤´ç¤µç¤»ç¤½ç¤¿ç¥„ç¥…ç¥†ç¥Šç¥‹ç¥ç¥‘ç¥”ç¥˜ç¥›ç¥œç¥§ç¥©ç¥«ç¥²ç¥¹ç¥»ç¥¼ç¥¾ç¦‹ç¦Œç¦‘ç¦“ç¦”ç¦•ç¦–ç¦˜ç¦›ç¦œç¦¡ç¦¨ç¦©ç¦«ç¦¯ç¦±ç¦´ç¦¸ç¦»ç§‚ç§„ç§‡ç§ˆç§Šç§ç§”ç§–ç§šç§ç§ž"],["8fd1a1","ç§ ç§¢ç§¥ç§ªç§«ç§­ç§±ç§¸ç§¼ç¨‚ç¨ƒç¨‡ç¨‰ç¨Šç¨Œç¨‘ç¨•ç¨›ç¨žç¨¡ç¨§ç¨«ç¨­ç¨¯ç¨°ç¨´ç¨µç¨¸ç¨¹ç¨ºç©„ç©…ç©‡ç©ˆç©Œç©•ç©–ç©™ç©œç©ç©Ÿç© ç©¥ç©§ç©ªç©­ç©µç©¸ç©¾çª€çª‚çª…çª†çªŠçª‹çªçª‘çª”çªžçª çª£çª¬çª³çªµçª¹çª»çª¼ç«†ç«‰ç«Œç«Žç«‘ç«›ç«¨ç«©ç««ç«¬ç«±ç«´ç«»ç«½ç«¾ç¬‡ç¬”ç¬Ÿç¬£ç¬§ç¬©ç¬ªç¬«ç¬­ç¬®ç¬¯ç¬°"],["8fd2a1","ç¬±ç¬´ç¬½ç¬¿ç­€ç­ç­‡ç­Žç­•ç­ ç­¤ç­¦ç­©ç­ªç­­ç­¯ç­²ç­³ç­·ç®„ç®‰ç®Žç®ç®‘ç®–ç®›ç®žç® ç®¥ç®¬ç®¯ç®°ç®²ç®µç®¶ç®ºç®»ç®¼ç®½ç¯‚ç¯…ç¯ˆç¯Šç¯”ç¯–ç¯—ç¯™ç¯šç¯›ç¯¨ç¯ªç¯²ç¯´ç¯µç¯¸ç¯¹ç¯ºç¯¼ç¯¾ç°ç°‚ç°ƒç°„ç°†ç°‰ç°‹ç°Œç°Žç°ç°™ç°›ç° ç°¥ç°¦ç°¨ç°¬ç°±ç°³ç°´ç°¶ç°¹ç°ºç±†ç±Šç±•ç±‘ç±’ç±“ç±™",5],["8fd3a1","ç±¡ç±£ç±§ç±©ç±­ç±®ç±°ç±²ç±¹ç±¼ç±½ç²†ç²‡ç²ç²”ç²žç² ç²¦ç²°ç²¶ç²·ç²ºç²»ç²¼ç²¿ç³„ç³‡ç³ˆç³‰ç³ç³ç³“ç³”ç³•ç³—ç³™ç³šç³ç³¦ç³©ç³«ç³µç´ƒç´‡ç´ˆç´‰ç´ç´‘ç´’ç´“ç´–ç´ç´žç´£ç´¦ç´ªç´­ç´±ç´¼ç´½ç´¾çµ€çµçµ‡çµˆçµçµ‘çµ“çµ—çµ™çµšçµœçµçµ¥çµ§çµªçµ°çµ¸çµºçµ»çµ¿ç¶ç¶‚ç¶ƒç¶…ç¶†ç¶ˆç¶‹ç¶Œç¶ç¶‘ç¶–ç¶—ç¶"],["8fd4a1","ç¶žç¶¦ç¶§ç¶ªç¶³ç¶¶ç¶·ç¶¹ç·‚",4,"ç·Œç·ç·Žç·—ç·™ç¸€ç·¢ç·¥ç·¦ç·ªç·«ç·­ç·±ç·µç·¶ç·¹ç·ºç¸ˆç¸ç¸‘ç¸•ç¸—ç¸œç¸ç¸ ç¸§ç¸¨ç¸¬ç¸­ç¸¯ç¸³ç¸¶ç¸¿ç¹„ç¹…ç¹‡ç¹Žç¹ç¹’ç¹˜ç¹Ÿç¹¡ç¹¢ç¹¥ç¹«ç¹®ç¹¯ç¹³ç¹¸ç¹¾çºçº†çº‡çºŠçºçº‘çº•çº˜çºšçºçºžç¼¼ç¼»ç¼½ç¼¾ç¼¿ç½ƒç½„ç½‡ç½ç½’ç½“ç½›ç½œç½ç½¡ç½£ç½¤ç½¥ç½¦ç½­"],["8fd5a1","ç½±ç½½ç½¾ç½¿ç¾€ç¾‹ç¾ç¾ç¾ç¾‘ç¾–ç¾—ç¾œç¾¡ç¾¢ç¾¦ç¾ªç¾­ç¾´ç¾¼ç¾¿ç¿€ç¿ƒç¿ˆç¿Žç¿ç¿›ç¿Ÿç¿£ç¿¥ç¿¨ç¿¬ç¿®ç¿¯ç¿²ç¿ºç¿½ç¿¾ç¿¿è€‡è€ˆè€Šè€è€Žè€è€‘è€“è€”è€–è€è€žè€Ÿè€ è€¤è€¦è€¬è€®è€°è€´è€µè€·è€¹è€ºè€¼è€¾è€è„è è¤è¦è­è±èµè‚è‚ˆè‚Žè‚œè‚žè‚¦è‚§è‚«è‚¸è‚¹èƒˆèƒèƒèƒ’èƒ”èƒ•èƒ—èƒ˜èƒ èƒ­èƒ®"],["8fd6a1","èƒ°èƒ²èƒ³èƒ¶èƒ¹èƒºèƒ¾è„ƒè„‹è„–è„—è„˜è„œè„žè„ è„¤è„§è„¬è„°è„µè„ºè„¼è……è…‡è…Šè…Œè…’è…—è… è…¡è…§è…¨è…©è…­è…¯è…·è†è†è†„è†…è††è†‹è†Žè†–è†˜è†›è†žè†¢è†®è†²è†´è†»è‡‹è‡ƒè‡…è‡Šè‡Žè‡è‡•è‡—è‡›è‡è‡žè‡¡è‡¤è‡«è‡¬è‡°è‡±è‡²è‡µè‡¶è‡¸è‡¹è‡½è‡¿èˆ€èˆƒèˆèˆ“èˆ”èˆ™èˆšèˆèˆ¡èˆ¢èˆ¨èˆ²èˆ´èˆºè‰ƒè‰„è‰…è‰†"],["8fd7a1","è‰‹è‰Žè‰è‰‘è‰–è‰œè‰ è‰£è‰§è‰­è‰´è‰»è‰½è‰¿èŠ€èŠèŠƒèŠ„èŠ‡èŠ‰èŠŠèŠŽèŠ‘èŠ”èŠ–èŠ˜èŠšèŠ›èŠ èŠ¡èŠ£èŠ¤èŠ§èŠ¨èŠ©èŠªèŠ®èŠ°èŠ²èŠ´èŠ·èŠºèŠ¼èŠ¾èŠ¿è‹†è‹è‹•è‹šè‹ è‹¢è‹¤è‹¨è‹ªè‹­è‹¯è‹¶è‹·è‹½è‹¾èŒ€èŒèŒ‡èŒˆèŒŠèŒ‹è”èŒ›èŒèŒžèŒŸèŒ¡èŒ¢èŒ¬èŒ­èŒ®èŒ°èŒ³èŒ·èŒºèŒ¼èŒ½è‚èƒè„è‡èèŽè‘è•è–è—è°è¸"],["8fd8a1","è½è¿èŽ€èŽ‚èŽ„èŽ†èŽèŽ’èŽ”èŽ•èŽ˜èŽ™èŽ›èŽœèŽèŽ¦èŽ§èŽ©èŽ¬èŽ¾èŽ¿è€è‡è‰èèè‘è”èè“è¨èªè¶è¸è¹è¼èè†èŠèè‘è•è™èŽ­è¯è¹è‘…è‘‡è‘ˆè‘Šè‘è‘è‘‘è‘’è‘–è‘˜è‘™è‘šè‘œè‘ è‘¤è‘¥è‘§è‘ªè‘°è‘³è‘´è‘¶è‘¸è‘¼è‘½è’è’…è’’è’“è’•è’žè’¦è’¨è’©è’ªè’¯è’±è’´è’ºè’½è’¾è“€è“‚è“‡è“ˆè“Œè“è““"],["8fd9a1","è“œè“§è“ªè“¯è“°è“±è“²è“·è”²è“ºè“»è“½è”‚è”ƒè”‡è”Œè”Žè”è”œè”žè”¢è”£è”¤è”¥è”§è”ªè”«è”¯è”³è”´è”¶è”¿è•†è•",4,"è•–è•™è•œ",6,"è•¤è•«è•¯è•¹è•ºè•»è•½è•¿è–è–…è–†è–‰è–‹è–Œè–è–“è–˜è–è–Ÿè– è–¢è–¥è–§è–´è–¶è–·è–¸è–¼è–½è–¾è–¿è—‚è—‡è—Šè—‹è—Žè–­è—˜è—šè—Ÿè— è—¦è—¨è—­è—³è—¶è—¼"],["8fdaa1","è—¿è˜€è˜„è˜…è˜è˜Žè˜è˜‘è˜’è˜˜è˜™è˜›è˜žè˜¡è˜§è˜©è˜¶è˜¸è˜ºè˜¼è˜½è™€è™‚è™†è™’è™“è™–è™—è™˜è™™è™è™ ",4,"è™©è™¬è™¯è™µè™¶è™·è™ºèšèš‘èš–èš˜èššèšœèš¡èš¦èš§èš¨èš­èš±èš³èš´èšµèš·èš¸èš¹èš¿è›€è›è›ƒè›…è›‘è›’è›•è›—è›šè›œè› è›£è›¥è›§èšˆè›ºè›¼è›½èœ„èœ…èœ‡èœ‹èœŽèœèœèœ“èœ”èœ™èœžèœŸèœ¡èœ£"],["8fdba1","èœ¨èœ®èœ¯èœ±èœ²èœ¹èœºèœ¼èœ½èœ¾è€èƒè…èè˜èè¡è¤è¥è¯è±è²è»èžƒ",6,"èž‹èžŒèžèž“èž•èž—èž˜èž™èžžèž èž£èž§èž¬èž­èž®èž±èžµèž¾èž¿èŸèŸˆèŸ‰èŸŠèŸŽèŸ•èŸ–èŸ™èŸšèŸœèŸŸèŸ¢èŸ£èŸ¤èŸªèŸ«èŸ­èŸ±èŸ³èŸ¸èŸºèŸ¿è è ƒè †è ‰è Šè ‹è è ™è ’è “è ”è ˜è šè ›è œè žè Ÿè ¨è ­è ®è °è ²è µ"],["8fdca1","è ºè ¼è¡è¡ƒè¡…è¡ˆè¡‰è¡Šè¡‹è¡Žè¡‘è¡•è¡–è¡˜è¡šè¡œè¡Ÿè¡ è¡¤è¡©è¡±è¡¹è¡»è¢€è¢˜è¢šè¢›è¢œè¢Ÿè¢ è¢¨è¢ªè¢ºè¢½è¢¾è£€è£Š",4,"è£‘è£’è£“è£›è£žè£§è£¯è£°è£±è£µè£·è¤è¤†è¤è¤Žè¤è¤•è¤–è¤˜è¤™è¤šè¤œè¤ è¤¦è¤§è¤¨è¤°è¤±è¤²è¤µè¤¹è¤ºè¤¾è¥€è¥‚è¥…è¥†è¥‰è¥è¥’è¥—è¥šè¥›è¥œè¥¡è¥¢è¥£è¥«è¥®è¥°è¥³è¥µè¥º"],["8fdda1","è¥»è¥¼è¥½è¦‰è¦è¦è¦”è¦•è¦›è¦œè¦Ÿè¦ è¦¥è¦°è¦´è¦µè¦¶è¦·è¦¼è§”",4,"è§¥è§©è§«è§­è§±è§³è§¶è§¹è§½è§¿è¨„è¨…è¨‡è¨è¨‘è¨’è¨”è¨•è¨žè¨ è¨¢è¨¤è¨¦è¨«è¨¬è¨¯è¨µè¨·è¨½è¨¾è©€è©ƒè©…è©‡è©‰è©è©Žè©“è©–è©—è©˜è©œè©è©¡è©¥è©§è©µè©¶è©·è©¹è©ºè©»è©¾è©¿èª€èªƒèª†èª‹èªèªèª’èª–èª—èª™èªŸèª§èª©èª®èª¯èª³"],["8fdea1","èª¶èª·èª»èª¾è«ƒè«†è«ˆè«‰è«Šè«‘è«“è«”è«•è«—è«è«Ÿè«¬è«°è«´è«µè«¶è«¼è«¿è¬…è¬†è¬‹è¬‘è¬œè¬žè¬Ÿè¬Šè¬­è¬°è¬·è¬¼è­‚",4,"è­ˆè­’è­“è­”è­™è­è­žè­£è­­è­¶è­¸è­¹è­¼è­¾è®è®„è®…è®‹è®è®è®”è®•è®œè®žè®Ÿè°¸è°¹è°½è°¾è±…è±‡è±‰è±‹è±è±‘è±“è±”è±—è±˜è±›è±è±™è±£è±¤è±¦è±¨è±©è±­è±³è±µè±¶è±»è±¾è²†"],["8fdfa1","è²‡è²‹è²è²’è²“è²™è²›è²œè²¤è²¹è²ºè³…è³†è³‰è³‹è³è³–è³•è³™è³è³¡è³¨è³¬è³¯è³°è³²è³µè³·è³¸è³¾è³¿è´è´ƒè´‰è´’è´—è´›èµ¥èµ©èµ¬èµ®èµ¿è¶‚è¶„è¶ˆè¶è¶è¶‘è¶•è¶žè¶Ÿè¶ è¶¦è¶«è¶¬è¶¯è¶²è¶µè¶·è¶¹è¶»è·€è·…è·†è·‡è·ˆè·Šè·Žè·‘è·”è·•è·—è·™è·¤è·¥è·§è·¬è·°è¶¼è·±è·²è·´è·½è¸è¸„è¸…è¸†è¸‹è¸‘è¸”è¸–è¸ è¸¡è¸¢"],["8fe0a1","è¸£è¸¦è¸§è¸±è¸³è¸¶è¸·è¸¸è¸¹è¸½è¹€è¹è¹‹è¹è¹Žè¹è¹”è¹›è¹œè¹è¹žè¹¡è¹¢è¹©è¹¬è¹­è¹¯è¹°è¹±è¹¹è¹ºè¹»èº‚èºƒèº‰èºèº’èº•èºšèº›èºèºžèº¢èº§èº©èº­èº®èº³èºµèººèº»è»€è»è»ƒè»„è»‡è»è»‘è»”è»œè»¨è»®è»°è»±è»·è»¹è»ºè»­è¼€è¼‚è¼‡è¼ˆè¼è¼è¼–è¼—è¼˜è¼žè¼ è¼¡è¼£è¼¥è¼§è¼¨è¼¬è¼­è¼®è¼´è¼µè¼¶è¼·è¼ºè½€è½"],["8fe1a1","è½ƒè½‡è½è½‘",4,"è½˜è½è½žè½¥è¾è¾ è¾¡è¾¤è¾¥è¾¦è¾µè¾¶è¾¸è¾¾è¿€è¿è¿†è¿Šè¿‹è¿è¿è¿’è¿“è¿•è¿ è¿£è¿¤è¿¨è¿®è¿±è¿µè¿¶è¿»è¿¾é€‚é€„é€ˆé€Œé€˜é€›é€¨é€©é€¯é€ªé€¬é€­é€³é€´é€·é€¿éƒé„éŒé›éé¢é¦é§é¬é°é´é¹é‚…é‚ˆé‚‹é‚Œé‚Žé‚é‚•é‚—é‚˜é‚™é‚›é‚ é‚¡é‚¢é‚¥é‚°é‚²é‚³é‚´é‚¶é‚½éƒŒé‚¾éƒƒ"],["8fe2a1","éƒ„éƒ…éƒ‡éƒˆéƒ•éƒ—éƒ˜éƒ™éƒœéƒéƒŸéƒ¥éƒ’éƒ¶éƒ«éƒ¯éƒ°éƒ´éƒ¾éƒ¿é„€é„„é„…é„†é„ˆé„é„é„”é„–é„—é„˜é„šé„œé„žé„ é„¥é„¢é„£é„§é„©é„®é„¯é„±é„´é„¶é„·é„¹é„ºé„¼é„½é…ƒé…‡é…ˆé…é…“é…—é…™é…šé…›é…¡é…¤é…§é…­é…´é…¹é…ºé…»é†é†ƒé†…é††é†Šé†Žé†‘é†“é†”é†•é†˜é†žé†¡é†¦é†¨é†¬é†­é†®é†°é†±é†²é†³é†¶é†»é†¼é†½é†¿"],["8fe3a1","é‡‚é‡ƒé‡…é‡“é‡”é‡—é‡™é‡šé‡žé‡¤é‡¥é‡©é‡ªé‡¬",5,"é‡·é‡¹é‡»é‡½éˆ€éˆéˆ„éˆ…éˆ†éˆ‡éˆ‰éˆŠéˆŒéˆéˆ’éˆ“éˆ–éˆ˜éˆœéˆéˆ£éˆ¤éˆ¥éˆ¦éˆ¨éˆ®éˆ¯éˆ°éˆ³éˆµéˆ¶éˆ¸éˆ¹éˆºéˆ¼éˆ¾é‰€é‰‚é‰ƒé‰†é‰‡é‰Šé‰é‰Žé‰é‰‘é‰˜é‰™é‰œé‰é‰ é‰¡é‰¥é‰§é‰¨é‰©é‰®é‰¯é‰°é‰µ",4,"é‰»é‰¼é‰½é‰¿éŠˆéŠ‰éŠŠéŠéŠŽéŠ’éŠ—"],["8fe4a1","éŠ™éŠŸéŠ éŠ¤éŠ¥éŠ§éŠ¨éŠ«éŠ¯éŠ²éŠ¶éŠ¸éŠºéŠ»éŠ¼éŠ½éŠ¿",4,"é‹…é‹†é‹‡é‹ˆé‹‹é‹Œé‹é‹Žé‹é‹“é‹•é‹—é‹˜é‹™é‹œé‹é‹Ÿé‹ é‹¡é‹£é‹¥é‹§é‹¨é‹¬é‹®é‹°é‹¹é‹»é‹¿éŒ€éŒ‚éŒˆéŒéŒ‘éŒ”éŒ•éŒœéŒéŒžéŒŸéŒ¡éŒ¤éŒ¥éŒ§éŒ©éŒªéŒ³éŒ´éŒ¶éŒ·é‡éˆé‰éé‘é’é•é—é˜éšéžé¤é¥é§é©éªé­é¯é°é±é³é´é¶"],["8fe5a1","éºé½é¿éŽ€éŽéŽ‚éŽˆéŽŠéŽ‹éŽéŽéŽ’éŽ•éŽ˜éŽ›éŽžéŽ¡éŽ£éŽ¤éŽ¦éŽ¨éŽ«éŽ´éŽµéŽ¶éŽºéŽ©éé„é…é†é‡é‰",4,"é“é™éœéžéŸé¢é¦é§é¹é·é¸éºé»é½éé‚é„éˆé‰ééŽéé•é–é—éŸé®é¯é±é²é³é´é»é¿é½é‘ƒé‘…é‘ˆé‘Šé‘Œé‘•é‘™é‘œé‘Ÿé‘¡é‘£é‘¨é‘«é‘­é‘®é‘¯é‘±é‘²é’„é’ƒé•¸é•¹"],["8fe6a1","é•¾é–„é–ˆé–Œé–é–Žé–é–žé–Ÿé–¡é–¦é–©é–«é–¬é–´é–¶é–ºé–½é–¿é—†é—ˆé—‰é—‹é—é—‘é—’é—“é—™é—šé—é—žé—Ÿé— é—¤é—¦é˜é˜žé˜¢é˜¤é˜¥é˜¦é˜¬é˜±é˜³é˜·é˜¸é˜¹é˜ºé˜¼é˜½é™é™’é™”é™–é™—é™˜é™¡é™®é™´é™»é™¼é™¾é™¿éšéš‚éšƒéš„éš‰éš‘éš–éššéšéšŸéš¤éš¥éš¦éš©éš®éš¯éš³éšºé›Šé›’å¶²é›˜é›šé›é›žé›Ÿé›©é›¯é›±é›ºéœ‚"],["8fe7a1","éœƒéœ…éœ‰éœšéœ›éœéœ¡éœ¢éœ£éœ¨éœ±éœ³ééƒéŠéŽéé•é—é˜éšé›é£é§éªé®é³é¶é·é¸é»é½é¿éž€éž‰éž•éž–éž—éž™éžšéžžéžŸéž¢éž¬éž®éž±éž²éžµéž¶éž¸éž¹éžºéž¼éž¾éž¿éŸéŸ„éŸ…éŸ‡éŸ‰éŸŠéŸŒéŸéŸŽéŸéŸ‘éŸ”éŸ—éŸ˜éŸ™éŸéŸžéŸ éŸ›éŸ¡éŸ¤éŸ¯éŸ±éŸ´éŸ·éŸ¸éŸºé ‡é Šé ™é é Žé ”é –é œé žé  é £é ¦"],["8fe8a1","é «é ®é ¯é °é ²é ³é µé ¥é ¾é¡„é¡‡é¡Šé¡‘é¡’é¡“é¡–é¡—é¡™é¡šé¡¢é¡£é¡¥é¡¦é¡ªé¡¬é¢«é¢­é¢®é¢°é¢´é¢·é¢¸é¢ºé¢»é¢¿é£‚é£…é£ˆé£Œé£¡é££é£¥é£¦é£§é£ªé£³é£¶é¤‚é¤‡é¤ˆé¤‘é¤•é¤–é¤—é¤šé¤›é¤œé¤Ÿé¤¢é¤¦é¤§é¤«é¤±",4,"é¤¹é¤ºé¤»é¤¼é¥€é¥é¥†é¥‡é¥ˆé¥é¥Žé¥”é¥˜é¥™é¥›é¥œé¥žé¥Ÿé¥ é¦›é¦é¦Ÿé¦¦é¦°é¦±é¦²é¦µ"],["8fe9a1","é¦¹é¦ºé¦½é¦¿é§ƒé§‰é§“é§”é§™é§šé§œé§žé§§é§ªé§«é§¬é§°é§´é§µé§¹é§½é§¾é¨‚é¨ƒé¨„é¨‹é¨Œé¨é¨‘é¨–é¨žé¨ é¨¢é¨£é¨¤é¨§é¨­é¨®é¨³é¨µé¨¶é¨¸é©‡é©é©„é©Šé©‹é©Œé©Žé©‘é©”é©–é©éªªéª¬éª®éª¯éª²éª´éªµéª¶éª¹éª»éª¾éª¿é«é«ƒé«†é«ˆé«Žé«é«’é«•é«–é«—é«›é«œé« é«¤é«¥é«§é«©é«¬é«²é«³é«µé«¹é«ºé«½é«¿",4],["8feaa1","é¬„é¬…é¬ˆé¬‰é¬‹é¬Œé¬é¬Žé¬é¬’é¬–é¬™é¬›é¬œé¬ é¬¦é¬«é¬­é¬³é¬´é¬µé¬·é¬¹é¬ºé¬½é­ˆé­‹é­Œé­•é­–é­—é­›é­žé­¡é­£é­¥é­¦é­¨é­ª",4,"é­³é­µé­·é­¸é­¹é­¿é®€é®„é®…é®†é®‡é®‰é®Šé®‹é®é®é®é®”é®šé®é®žé®¦é®§é®©é®¬é®°é®±é®²é®·é®¸é®»é®¼é®¾é®¿é¯é¯‡é¯ˆé¯Žé¯é¯—é¯˜é¯é¯Ÿé¯¥é¯§é¯ªé¯«é¯¯é¯³é¯·é¯¸"],["8feba1","é¯¹é¯ºé¯½é¯¿é°€é°‚é°‹é°é°‘é°–é°˜é°™é°šé°œé°žé°¢é°£é°¦",4,"é°±é°µé°¶é°·é°½é±é±ƒé±„é±…é±‰é±Šé±Žé±é±é±“é±”é±–é±˜é±›é±é±žé±Ÿé±£é±©é±ªé±œé±«é±¨é±®é±°é±²é±µé±·é±»é³¦é³²é³·é³¹é´‹é´‚é´‘é´—é´˜é´œé´é´žé´¯é´°é´²é´³é´´é´ºé´¼éµ…é´½éµ‚éµƒéµ‡éµŠéµ“éµ”éµŸéµ£éµ¢éµ¥éµ©éµªéµ«éµ°éµ¶éµ·éµ»"],["8feca1","éµ¼éµ¾é¶ƒé¶„é¶†é¶Šé¶é¶Žé¶’é¶“é¶•é¶–é¶—é¶˜é¶¡é¶ªé¶¬é¶®é¶±é¶µé¶¹é¶¼é¶¿é·ƒé·‡é·‰é·Šé·”é·•é·–é·—é·šé·žé·Ÿé· é·¥é·§é·©é·«é·®é·°é·³é·´é·¾é¸Šé¸‚é¸‡é¸Žé¸é¸‘é¸’é¸•é¸–é¸™é¸œé¸é¹ºé¹»é¹¼éº€éº‚éºƒéº„éº…éº‡éºŽéºéº–éº˜éº›éºžéº¤éº¨éº¬éº®éº¯éº°éº³éº´éºµé»†é»ˆé»‹é»•é»Ÿé»¤é»§é»¬é»­é»®é»°é»±é»²é»µ"],["8feda1","é»¸é»¿é¼‚é¼ƒé¼‰é¼é¼é¼‘é¼’é¼”é¼–é¼—é¼™é¼šé¼›é¼Ÿé¼¢é¼¦é¼ªé¼«é¼¯é¼±é¼²é¼´é¼·é¼¹é¼ºé¼¼é¼½é¼¿é½é½ƒ",4,"é½“é½•é½–é½—é½˜é½šé½é½žé½¨é½©é½­",4,"é½³é½µé½ºé½½é¾é¾é¾‘é¾’é¾”é¾–é¾—é¾žé¾¡é¾¢é¾£é¾¥"]]');
const require$$2$1 = /* @__PURE__ */ JSON.parse('[["0","\\u0000",127,"â‚¬"],["8140","ä¸‚ä¸„ä¸…ä¸†ä¸ä¸’ä¸—ä¸Ÿä¸ ä¸¡ä¸£ä¸¦ä¸©ä¸®ä¸¯ä¸±ä¸³ä¸µä¸·ä¸¼ä¹€ä¹ä¹‚ä¹„ä¹†ä¹Šä¹‘ä¹•ä¹—ä¹šä¹›ä¹¢ä¹£ä¹¤ä¹¥ä¹§ä¹¨ä¹ª",5,"ä¹²ä¹´",9,"ä¹¿",6,"äº‡äºŠ"],["8180","äºäº–äº—äº™äºœäºäºžäº£äºªäº¯äº°äº±äº´äº¶äº·äº¸äº¹äº¼äº½äº¾ä»ˆä»Œä»ä»ä»’ä»šä»›ä»œä» ä»¢ä»¦ä»§ä»©ä»­ä»®ä»¯ä»±ä»´ä»¸ä»¹ä»ºä»¼ä»¾ä¼€ä¼‚",6,"ä¼‹ä¼Œä¼’",4,"ä¼œä¼ä¼¡ä¼£ä¼¨ä¼©ä¼¬ä¼­ä¼®ä¼±ä¼³ä¼µä¼·ä¼¹ä¼»ä¼¾",4,"ä½„ä½…ä½‡",5,"ä½’ä½”ä½–ä½¡ä½¢ä½¦ä½¨ä½ªä½«ä½­ä½®ä½±ä½²ä½µä½·ä½¸ä½¹ä½ºä½½ä¾€ä¾ä¾‚ä¾…ä¾†ä¾‡ä¾Šä¾Œä¾Žä¾ä¾’ä¾“ä¾•ä¾–ä¾˜ä¾™ä¾šä¾œä¾žä¾Ÿä¾¡ä¾¢"],["8240","ä¾¤ä¾«ä¾­ä¾°",4,"ä¾¶",8,"ä¿€ä¿ä¿‚ä¿†ä¿‡ä¿ˆä¿‰ä¿‹ä¿Œä¿ä¿’",4,"ä¿™ä¿›ä¿ ä¿¢ä¿¤ä¿¥ä¿§ä¿«ä¿¬ä¿°ä¿²ä¿´ä¿µä¿¶ä¿·ä¿¹ä¿»ä¿¼ä¿½ä¿¿",11],["8280","å€‹å€Žå€å€‘å€“å€•å€–å€—å€›å€å€žå€ å€¢å€£å€¤å€§å€«å€¯",10,"å€»å€½å€¿å€åå‚å„å…å†å‰åŠå‹åå",4,"å–å—å˜å™å›å",7,"å¦",5,"å­",8,"å¸å¹åºå¼å½å‚å‚‚å‚ƒå‚„å‚†å‚‡å‚‰å‚Šå‚‹å‚Œå‚Ž",20,"å‚¤å‚¦å‚ªå‚«å‚­",4,"å‚³",6,"å‚¼"],["8340","å‚½",17,"åƒ",5,"åƒ—åƒ˜åƒ™åƒ›",10,"åƒ¨åƒ©åƒªåƒ«åƒ¯åƒ°åƒ±åƒ²åƒ´åƒ¶",4,"åƒ¼",9,"å„ˆ"],["8380","å„‰å„Šå„Œ",5,"å„“",13,"å„¢",28,"å…‚å…‡å…Šå…Œå…Žå…å…å…’å…“å…—å…˜å…™å…›å…",4,"å…£å…¤å…¦å…§å…©å…ªå…¯å…²å…ºå…¾å…¿å†ƒå†„å††å†‡å†Šå†‹å†Žå†å†å†‘å†“å†”å†˜å†šå†å†žå†Ÿå†¡å†£å†¦",4,"å†­å†®å†´å†¸å†¹å†ºå†¾å†¿å‡å‡‚å‡ƒå‡…å‡ˆå‡Šå‡å‡Žå‡å‡’",5],["8440","å‡˜å‡™å‡šå‡œå‡žå‡Ÿå‡¢å‡£å‡¥",5,"å‡¬å‡®å‡±å‡²å‡´å‡·å‡¾åˆ„åˆ…åˆ‰åˆ‹åˆŒåˆåˆåˆ“åˆ”åˆ•åˆœåˆžåˆŸåˆ¡åˆ¢åˆ£åˆ¥åˆ¦åˆ§åˆªåˆ¬åˆ¯åˆ±åˆ²åˆ´åˆµåˆ¼åˆ¾å‰„",5,"å‰‹å‰Žå‰å‰’å‰“å‰•å‰—å‰˜"],["8480","å‰™å‰šå‰›å‰å‰Ÿå‰ å‰¢å‰£å‰¤å‰¦å‰¨å‰«å‰¬å‰­å‰®å‰°å‰±å‰³",9,"å‰¾åŠ€åŠƒ",4,"åŠ‰",6,"åŠ‘åŠ’åŠ”",6,"åŠœåŠ¤åŠ¥åŠ¦åŠ§åŠ®åŠ¯åŠ°åŠ´",9,"å‹€å‹å‹‚å‹„å‹…å‹†å‹ˆå‹Šå‹Œå‹å‹Žå‹å‹‘å‹“å‹”å‹•å‹—å‹™",5,"å‹ å‹¡å‹¢å‹£å‹¥",10,"å‹±",7,"å‹»å‹¼å‹½åŒåŒ‚åŒƒåŒ„åŒ‡åŒ‰åŒŠåŒ‹åŒŒåŒŽ"],["8540","åŒ‘åŒ’åŒ“åŒ”åŒ˜åŒ›åŒœåŒžåŒŸåŒ¢åŒ¤åŒ¥åŒ§åŒ¨åŒ©åŒ«åŒ¬åŒ­åŒ¯",9,"åŒ¼åŒ½å€å‚å„å†å‹åŒååå”å˜å™å›åå¥å¨åªå¬å­å²å¶å¹å»å¼å½å¾åŽ€åŽåŽƒåŽ‡åŽˆåŽŠåŽŽåŽ"],["8580","åŽ",4,"åŽ–åŽ—åŽ™åŽ›åŽœåŽžåŽ åŽ¡åŽ¤åŽ§åŽªåŽ«åŽ¬åŽ­åŽ¯",6,"åŽ·åŽ¸åŽ¹åŽºåŽ¼åŽ½åŽ¾å€åƒ",4,"åŽååå’å“å•åšåœååžå¡å¢å§å´åºå¾å¿å€å‚å…å‡å‹å”å˜å™åšåœå¢å¤å¥åªå°å³å¶å·åºå½å¿å‘å‘‚å‘„å‘…å‘‡å‘‰å‘Œå‘å‘Žå‘å‘‘å‘šå‘",4,"å‘£å‘¥å‘§å‘©",7,"å‘´å‘¹å‘ºå‘¾å‘¿å’å’ƒå’…å’‡å’ˆå’‰å’Šå’å’‘å’“å’—å’˜å’œå’žå’Ÿå’ å’¡"],["8640","å’¢å’¥å’®å’°å’²å’µå’¶å’·å’¹å’ºå’¼å’¾å“ƒå“…å“Šå“‹å“–å“˜å“›å“ ",4,"å“«å“¬å“¯å“°å“±å“´",5,"å“»å“¾å”€å”‚å”ƒå”„å”…å”ˆå”Š",4,"å”’å”“å”•",5,"å”œå”å”žå”Ÿå”¡å”¥å”¦"],["8680","å”¨å”©å”«å”­å”²å”´å”µå”¶å”¸å”¹å”ºå”»å”½å•€å•‚å•…å•‡å•ˆå•‹",4,"å•‘å•’å•“å•”å•—",4,"å•å•žå•Ÿå• å•¢å•£å•¨å•©å•«å•¯",5,"å•¹å•ºå•½å•¿å–…å–†å–Œå–å–Žå–å–’å–“å–•å––å–—å–šå–›å–žå– ",6,"å–¨",8,"å–²å–´å–¶å–¸å–ºå–¼å–¿",4,"å—†å—‡å—ˆå—Šå—‹å—Žå—å—å—•å——",4,"å—žå— å—¢å—§å—©å—­å—®å—°å—±å—´å—¶å—¸",4,"å—¿å˜‚å˜ƒå˜„å˜…"],["8740","å˜†å˜‡å˜Šå˜‹å˜å˜",7,"å˜™å˜šå˜œå˜å˜ å˜¡å˜¢å˜¥å˜¦å˜¨å˜©å˜ªå˜«å˜®å˜¯å˜°å˜³å˜µå˜·å˜¸å˜ºå˜¼å˜½å˜¾å™€",11,"å™",4,"å™•å™–å™šå™›å™",4],["8780","å™£å™¥å™¦å™§å™­å™®å™¯å™°å™²å™³å™´å™µå™·å™¸å™¹å™ºå™½",7,"åš‡",6,"åšåš‘åš’åš”",14,"åš¤",10,"åš°",6,"åš¸åš¹åšºåš»åš½",12,"å›‹",8,"å›•å›–å›˜å›™å›œå›£å›¥",5,"å›¬å›®å›¯å›²å›³å›¶å›·å›¸å›»å›¼åœ€åœåœ‚åœ…åœ‡åœ‹",6],["8840","åœ’",9,"åœåœžåœ åœ¡åœ¢åœ¤åœ¥åœ¦åœ§åœ«åœ±åœ²åœ´",4,"åœ¼åœ½åœ¿ååƒå„å…å†åˆå‰å‹å’",4,"å˜å™å¢å£å¥å§å¬å®å°å±å²å´åµå¸å¹åºå½å¾å¿åž€"],["8880","åžåž‡åžˆåž‰åžŠåž",4,"åž”",6,"åžœåžåžžåžŸåž¥åž¨åžªåž¬åž¯åž°åž±åž³åžµåž¶åž·åž¹",8,"åŸ„",6,"åŸŒåŸåŸåŸ‘åŸ“åŸ–åŸ—åŸ›åŸœåŸžåŸ¡åŸ¢åŸ£åŸ¥",7,"åŸ®åŸ°åŸ±åŸ²åŸ³åŸµåŸ¶åŸ·åŸ»åŸ¼åŸ¾åŸ¿å å ƒå „å …å ˆå ‰å Šå Œå Žå å å ’å “å ”å –å —å ˜å šå ›å œå å Ÿå ¢å £å ¥",4,"å «",4,"å ±å ²å ³å ´å ¶",7],["8940","å ¾",5,"å¡…",6,"å¡Žå¡å¡å¡’å¡“å¡•å¡–å¡—å¡™",4,"å¡Ÿ",5,"å¡¦",4,"å¡­",16,"å¡¿å¢‚å¢„å¢†å¢‡å¢ˆå¢Šå¢‹å¢Œ"],["8980","å¢",4,"å¢”",4,"å¢›å¢œå¢å¢ ",7,"å¢ª",17,"å¢½å¢¾å¢¿å£€å£‚å£ƒå£„å£†",10,"å£’å£“å£”å£–",13,"å£¥",5,"å£­å£¯å£±å£²å£´å£µå£·å£¸å£º",7,"å¤ƒå¤…å¤†å¤ˆ",4,"å¤Žå¤å¤‘å¤’å¤“å¤—å¤˜å¤›å¤å¤žå¤ å¤¡å¤¢å¤£å¤¦å¤¨å¤¬å¤°å¤²å¤³å¤µå¤¶å¤»"],["8a40","å¤½å¤¾å¤¿å¥€å¥ƒå¥…å¥†å¥Šå¥Œå¥å¥å¥’å¥“å¥™å¥›",4,"å¥¡å¥£å¥¤å¥¦",12,"å¥µå¥·å¥ºå¥»å¥¼å¥¾å¥¿å¦€å¦…å¦‰å¦‹å¦Œå¦Žå¦å¦å¦‘å¦”å¦•å¦˜å¦šå¦›å¦œå¦å¦Ÿå¦ å¦¡å¦¢å¦¦"],["8a80","å¦§å¦¬å¦­å¦°å¦±å¦³",5,"å¦ºå¦¼å¦½å¦¿",6,"å§‡å§ˆå§‰å§Œå§å§Žå§å§•å§–å§™å§›å§ž",4,"å§¤å§¦å§§å§©å§ªå§«å§­",11,"å§ºå§¼å§½å§¾å¨€å¨‚å¨Šå¨‹å¨å¨Žå¨å¨å¨’å¨”å¨•å¨–å¨—å¨™å¨šå¨›å¨å¨žå¨¡å¨¢å¨¤å¨¦å¨§å¨¨å¨ª",6,"å¨³å¨µå¨·",4,"å¨½å¨¾å¨¿å©",4,"å©‡å©ˆå©‹",9,"å©–å©—å©˜å©™å©›",5],["8b40","å©¡å©£å©¤å©¥å©¦å©¨å©©å©«",8,"å©¸å©¹å©»å©¼å©½å©¾åª€",17,"åª“",6,"åªœ",13,"åª«åª¬"],["8b80","åª­",4,"åª´åª¶åª·åª¹",4,"åª¿å«€å«ƒ",5,"å«Šå«‹å«",4,"å«“å«•å«—å«™å«šå«›å«å«žå«Ÿå«¢å«¤å«¥å«§å«¨å«ªå«¬",4,"å«²",22,"å¬Š",11,"å¬˜",25,"å¬³å¬µå¬¶å¬¸",7,"å­",6],["8c40","å­ˆ",7,"å­’å­–å­žå­ å­¡å­§å­¨å­«å­­å­®å­¯å­²å­´å­¶å­·å­¸å­¹å­»å­¼å­¾å­¿å®‚å®†å®Šå®å®Žå®å®‘å®’å®”å®–å®Ÿå®§å®¨å®©å®¬å®­å®®å®¯å®±å®²å®·å®ºå®»å®¼å¯€å¯å¯ƒå¯ˆå¯‰å¯Šå¯‹å¯å¯Žå¯"],["8c80","å¯‘å¯”",8,"å¯ å¯¢å¯£å¯¦å¯§å¯©",4,"å¯¯å¯±",6,"å¯½å¯¾å°€å°‚å°ƒå°…å°‡å°ˆå°‹å°Œå°å°Žå°å°’å°“å°—å°™å°›å°žå°Ÿå° å°¡å°£å°¦å°¨å°©å°ªå°«å°­å°®å°¯å°°å°²å°³å°µå°¶å°·å±ƒå±„å±†å±‡å±Œå±å±’å±“å±”å±–å±—å±˜å±šå±›å±œå±å±Ÿå±¢å±¤å±§",6,"å±°å±²",6,"å±»å±¼å±½å±¾å²€å²ƒ",4,"å²‰å²Šå²‹å²Žå²å²’å²“å²•å²",4,"å²¤",4],["8d40","å²ªå²®å²¯å²°å²²å²´å²¶å²¹å²ºå²»å²¼å²¾å³€å³‚å³ƒå³…",5,"å³Œ",5,"å³“",5,"å³š",6,"å³¢å³£å³§å³©å³«å³¬å³®å³¯å³±",9,"å³¼",4],["8d80","å´å´„å´…å´ˆ",5,"å´",4,"å´•å´—å´˜å´™å´šå´œå´å´Ÿ",4,"å´¥å´¨å´ªå´«å´¬å´¯",4,"å´µ",7,"å´¿",7,"åµˆåµ‰åµ",10,"åµ™åµšåµœåµž",10,"åµªåµ­åµ®åµ°åµ±åµ²åµ³åµµ",12,"å¶ƒ",21,"å¶šå¶›å¶œå¶žå¶Ÿå¶ "],["8e40","å¶¡",21,"å¶¸",12,"å·†",6,"å·Ž",12,"å·œå·Ÿå· å·£å·¤å·ªå·¬å·­"],["8e80","å·°å·µå·¶å·¸",4,"å·¿å¸€å¸„å¸‡å¸‰å¸Šå¸‹å¸å¸Žå¸’å¸“å¸—å¸ž",7,"å¸¨",4,"å¸¯å¸°å¸²",4,"å¸¹å¸ºå¸¾å¸¿å¹€å¹å¹ƒå¹†",5,"å¹",6,"å¹–",4,"å¹œå¹å¹Ÿå¹ å¹£",14,"å¹µå¹·å¹¹å¹¾åºåº‚åºƒåº…åºˆåº‰åºŒåºåºŽåº’åº˜åº›åºåº¡åº¢åº£åº¤åº¨",4,"åº®",4,"åº´åººåº»åº¼åº½åº¿",6],["8f40","å»†å»‡å»ˆå»‹",5,"å»”å»•å»—å»˜å»™å»šå»œ",11,"å»©å»«",8,"å»µå»¸å»¹å»»å»¼å»½å¼…å¼†å¼‡å¼‰å¼Œå¼å¼Žå¼å¼’å¼”å¼–å¼™å¼šå¼œå¼å¼žå¼¡å¼¢å¼£å¼¤"],["8f80","å¼¨å¼«å¼¬å¼®å¼°å¼²",6,"å¼»å¼½å¼¾å¼¿å½",14,"å½‘å½”å½™å½šå½›å½œå½žå½Ÿå½ å½£å½¥å½§å½¨å½«å½®å½¯å½²å½´å½µå½¶å½¸å½ºå½½å½¾å½¿å¾ƒå¾†å¾å¾Žå¾å¾‘å¾“å¾”å¾–å¾šå¾›å¾å¾žå¾Ÿå¾ å¾¢",5,"å¾©å¾«å¾¬å¾¯",5,"å¾¶å¾¸å¾¹å¾ºå¾»å¾¾",4,"å¿‡å¿ˆå¿Šå¿‹å¿Žå¿“å¿”å¿•å¿šå¿›å¿œå¿žå¿Ÿå¿¢å¿£å¿¥å¿¦å¿¨å¿©å¿¬å¿¯å¿°å¿²å¿³å¿´å¿¶å¿·å¿¹å¿ºå¿¼æ€‡"],["9040","æ€ˆæ€‰æ€‹æ€Œæ€æ€‘æ€“æ€—æ€˜æ€šæ€žæ€Ÿæ€¢æ€£æ€¤æ€¬æ€­æ€®æ€°",4,"æ€¶",4,"æ€½æ€¾æ€æ„",6,"æŒæŽææ‘æ“æ”æ–æ—æ˜æ›æœæžæŸæ æ¡æ¥æ¦æ®æ±æ²æ´æµæ·æ¾æ‚€"],["9080","æ‚æ‚‚æ‚…æ‚†æ‚‡æ‚ˆæ‚Šæ‚‹æ‚Žæ‚æ‚æ‚‘æ‚“æ‚•æ‚—æ‚˜æ‚™æ‚œæ‚žæ‚¡æ‚¢æ‚¤æ‚¥æ‚§æ‚©æ‚ªæ‚®æ‚°æ‚³æ‚µæ‚¶æ‚·æ‚¹æ‚ºæ‚½",7,"æƒ‡æƒˆæƒ‰æƒŒ",4,"æƒ’æƒ“æƒ”æƒ–æƒ—æƒ™æƒ›æƒžæƒ¡",4,"æƒªæƒ±æƒ²æƒµæƒ·æƒ¸æƒ»",4,"æ„‚æ„ƒæ„„æ„…æ„‡æ„Šæ„‹æ„Œæ„",4,"æ„–æ„—æ„˜æ„™æ„›æ„œæ„æ„žæ„¡æ„¢æ„¥æ„¨æ„©æ„ªæ„¬",18,"æ…€",6],["9140","æ…‡æ…‰æ…‹æ…æ…æ…æ…’æ…“æ…”æ…–",6,"æ…žæ…Ÿæ… æ…¡æ…£æ…¤æ…¥æ…¦æ…©",6,"æ…±æ…²æ…³æ…´æ…¶æ…¸",18,"æ†Œæ†æ†",4,"æ†•"],["9180","æ†–",6,"æ†ž",8,"æ†ªæ†«æ†­",9,"æ†¸",5,"æ†¿æ‡€æ‡æ‡ƒ",4,"æ‡‰æ‡Œ",4,"æ‡“æ‡•",16,"æ‡§",13,"æ‡¶",8,"æˆ€",5,"æˆ‡æˆ‰æˆ“æˆ”æˆ™æˆœæˆæˆžæˆ æˆ£æˆ¦æˆ§æˆ¨æˆ©æˆ«æˆ­æˆ¯æˆ°æˆ±æˆ²æˆµæˆ¶æˆ¸",4,"æ‰‚æ‰„æ‰…æ‰†æ‰Š"],["9240","æ‰æ‰æ‰•æ‰–æ‰—æ‰™æ‰šæ‰œ",6,"æ‰¤æ‰¥æ‰¨æ‰±æ‰²æ‰´æ‰µæ‰·æ‰¸æ‰ºæ‰»æ‰½æŠæŠ‚æŠƒæŠ…æŠ†æŠ‡æŠˆæŠ‹",5,"æŠ”æŠ™æŠœæŠæŠžæŠ£æŠ¦æŠ§æŠ©æŠªæŠ­æŠ®æŠ¯æŠ°æŠ²æŠ³æŠ´æŠ¶æŠ·æŠ¸æŠºæŠ¾æ‹€æ‹"],["9280","æ‹ƒæ‹‹æ‹æ‹‘æ‹•æ‹æ‹žæ‹ æ‹¡æ‹¤æ‹ªæ‹«æ‹°æ‹²æ‹µæ‹¸æ‹¹æ‹ºæ‹»æŒ€æŒƒæŒ„æŒ…æŒ†æŒŠæŒ‹æŒŒæŒæŒæŒæŒ’æŒ“æŒ”æŒ•æŒ—æŒ˜æŒ™æŒœæŒ¦æŒ§æŒ©æŒ¬æŒ­æŒ®æŒ°æŒ±æŒ³",5,"æŒ»æŒ¼æŒ¾æŒ¿æ€ææ„æ‡æˆæŠæ‘æ’æ“æ”æ–",7,"æ æ¤æ¥æ¦æ¨æªæ«æ¬æ¯æ°æ²æ³æ´æµæ¸æ¹æ¼æ½æ¾æ¿æŽæŽƒæŽ„æŽ…æŽ†æŽ‹æŽæŽ‘æŽ“æŽ”æŽ•æŽ—æŽ™",6,"æŽ¡æŽ¤æŽ¦æŽ«æŽ¯æŽ±æŽ²æŽµæŽ¶æŽ¹æŽ»æŽ½æŽ¿æ€"],["9340","ææ‚æƒæ…æ‡æˆæŠæ‹æŒæ‘æ“æ”æ•æ—",6,"æŸæ¢æ¤",4,"æ«æ¬æ®æ¯æ°æ±æ³æµæ·æ¹æºæ»æ¼æ¾æƒæ„æ†",4,"ææŽæ‘æ’æ•",5,"ææŸæ¢æ£æ¤"],["9380","æ¥æ§æ¨æ©æ«æ®",5,"æµ",4,"æ»æ¼æ¾æ‘€æ‘‚æ‘ƒæ‘‰æ‘‹",6,"æ‘“æ‘•æ‘–æ‘—æ‘™",4,"æ‘Ÿ",7,"æ‘¨æ‘ªæ‘«æ‘¬æ‘®",9,"æ‘»",6,"æ’ƒæ’†æ’ˆ",8,"æ’“æ’”æ’—æ’˜æ’šæ’›æ’œæ’æ’Ÿ",4,"æ’¥æ’¦æ’§æ’¨æ’ªæ’«æ’¯æ’±æ’²æ’³æ’´æ’¶æ’¹æ’»æ’½æ’¾æ’¿æ“æ“ƒæ“„æ“†",6,"æ“æ“‘æ““æ“”æ“•æ“–æ“™æ“š"],["9440","æ“›æ“œæ“æ“Ÿæ“ æ“¡æ“£æ“¥æ“§",24,"æ”",7,"æ”Š",7,"æ”“",4,"æ”™",8],["9480","æ”¢æ”£æ”¤æ”¦",4,"æ”¬æ”­æ”°æ”±æ”²æ”³æ”·æ”ºæ”¼æ”½æ•€",4,"æ•†æ•‡æ•Šæ•‹æ•æ•Žæ•æ•’æ•“æ•”æ•—æ•˜æ•šæ•œæ•Ÿæ• æ•¡æ•¤æ•¥æ•§æ•¨æ•©æ•ªæ•­æ•®æ•¯æ•±æ•³æ•µæ•¶æ•¸",14,"æ–ˆæ–‰æ–Šæ–æ–Žæ–æ–’æ–”æ–•æ––æ–˜æ–šæ–æ–žæ– æ–¢æ–£æ–¦æ–¨æ–ªæ–¬æ–®æ–±",7,"æ–ºæ–»æ–¾æ–¿æ—€æ—‚æ—‡æ—ˆæ—‰æ—Šæ—æ—æ—‘æ—“æ—”æ—•æ—˜",7,"æ—¡æ—£æ—¤æ—ªæ—«"],["9540","æ—²æ—³æ—´æ—µæ—¸æ—¹æ—»",4,"æ˜æ˜„æ˜…æ˜‡æ˜ˆæ˜‰æ˜‹æ˜æ˜æ˜‘æ˜’æ˜–æ˜—æ˜˜æ˜šæ˜›æ˜œæ˜žæ˜¡æ˜¢æ˜£æ˜¤æ˜¦æ˜©æ˜ªæ˜«æ˜¬æ˜®æ˜°æ˜²æ˜³æ˜·",4,"æ˜½æ˜¿æ™€æ™‚æ™„",6,"æ™æ™Žæ™æ™‘æ™˜"],["9580","æ™™æ™›æ™œæ™æ™žæ™ æ™¢æ™£æ™¥æ™§æ™©",4,"æ™±æ™²æ™³æ™µæ™¸æ™¹æ™»æ™¼æ™½æ™¿æš€æšæšƒæš…æš†æšˆæš‰æšŠæš‹æšæšŽæšæšæš’æš“æš”æš•æš˜",4,"æšž",8,"æš©",4,"æš¯",4,"æšµæš¶æš·æš¸æšºæš»æš¼æš½æš¿",25,"æ›šæ›ž",7,"æ›§æ›¨æ›ª",5,"æ›±æ›µæ›¶æ›¸æ›ºæ›»æ›½æœæœ‚æœƒ"],["9640","æœ„æœ…æœ†æœ‡æœŒæœŽæœæœ‘æœ’æœ“æœ–æœ˜æœ™æœšæœœæœžæœ ",5,"æœ§æœ©æœ®æœ°æœ²æœ³æœ¶æœ·æœ¸æœ¹æœ»æœ¼æœ¾æœ¿ææ„æ…æ‡æŠæ‹ææ’æ”æ•æ—",4,"ææ¢æ£æ¤æ¦æ§æ«æ¬æ®æ±æ´æ¶"],["9680","æ¸æ¹æºæ»æ½æž€æž‚æžƒæž…æž†æžˆæžŠæžŒæžæžŽæžæž‘æž’æž“æž”æž–æž™æž›æžŸæž æž¡æž¤æž¦æž©æž¬æž®æž±æž²æž´æž¹",7,"æŸ‚æŸ…",9,"æŸ•æŸ–æŸ—æŸ›æŸŸæŸ¡æŸ£æŸ¤æŸ¦æŸ§æŸ¨æŸªæŸ«æŸ­æŸ®æŸ²æŸµ",7,"æŸ¾æ æ ‚æ ƒæ „æ †æ æ æ ’æ ”æ •æ ˜",4,"æ žæ Ÿæ  æ ¢",6,"æ «",6,"æ ´æ µæ ¶æ ºæ »æ ¿æ¡‡æ¡‹æ¡æ¡æ¡’æ¡–",5],["9740","æ¡œæ¡æ¡žæ¡Ÿæ¡ªæ¡¬",7,"æ¡µæ¡¸",8,"æ¢‚æ¢„æ¢‡",7,"æ¢æ¢‘æ¢’æ¢”æ¢•æ¢–æ¢˜",9,"æ¢£æ¢¤æ¢¥æ¢©æ¢ªæ¢«æ¢¬æ¢®æ¢±æ¢²æ¢´æ¢¶æ¢·æ¢¸"],["9780","æ¢¹",6,"æ£æ£ƒ",5,"æ£Šæ£Œæ£Žæ£æ£æ£‘æ£“æ£”æ£–æ£—æ£™æ£›",4,"æ£¡æ£¢æ£¤",9,"æ£¯æ£²æ£³æ£´æ£¶æ£·æ£¸æ£»æ£½æ£¾æ£¿æ¤€æ¤‚æ¤ƒæ¤„æ¤†",4,"æ¤Œæ¤æ¤‘æ¤“",11,"æ¤¡æ¤¢æ¤£æ¤¥",7,"æ¤®æ¤¯æ¤±æ¤²æ¤³æ¤µæ¤¶æ¤·æ¤¸æ¤ºæ¤»æ¤¼æ¤¾æ¥€æ¥æ¥ƒ",16,"æ¥•æ¥–æ¥˜æ¥™æ¥›æ¥œæ¥Ÿ"],["9840","æ¥¡æ¥¢æ¥¤æ¥¥æ¥§æ¥¨æ¥©æ¥ªæ¥¬æ¥­æ¥¯æ¥°æ¥²",4,"æ¥ºæ¥»æ¥½æ¥¾æ¥¿æ¦æ¦ƒæ¦…æ¦Šæ¦‹æ¦Œæ¦Ž",5,"æ¦–æ¦—æ¦™æ¦šæ¦",9,"æ¦©æ¦ªæ¦¬æ¦®æ¦¯æ¦°æ¦²æ¦³æ¦µæ¦¶æ¦¸æ¦¹æ¦ºæ¦¼æ¦½"],["9880","æ¦¾æ¦¿æ§€æ§‚",7,"æ§‹æ§æ§æ§‘æ§’æ§“æ§•",5,"æ§œæ§æ§žæ§¡",11,"æ§®æ§¯æ§°æ§±æ§³",9,"æ§¾æ¨€",9,"æ¨‹",11,"æ¨™",5,"æ¨ æ¨¢",5,"æ¨©æ¨«æ¨¬æ¨­æ¨®æ¨°æ¨²æ¨³æ¨´æ¨¶",6,"æ¨¿",4,"æ©…æ©†æ©ˆ",7,"æ©‘",6,"æ©š"],["9940","æ©œ",4,"æ©¢æ©£æ©¤æ©¦",10,"æ©²",6,"æ©ºæ©»æ©½æ©¾æ©¿æªæª‚æªƒæª…",8,"æªæª’",4,"æª˜",7,"æª¡",5],["9980","æª§æª¨æªªæª­",114,"æ¬¥æ¬¦æ¬¨",6],["9a40","æ¬¯æ¬°æ¬±æ¬³æ¬´æ¬µæ¬¶æ¬¸æ¬»æ¬¼æ¬½æ¬¿æ­€æ­æ­‚æ­„æ­…æ­ˆæ­Šæ­‹æ­",11,"æ­š",7,"æ­¨æ­©æ­«",13,"æ­ºæ­½æ­¾æ­¿æ®€æ®…æ®ˆ"],["9a80","æ®Œæ®Žæ®æ®æ®‘æ®”æ®•æ®—æ®˜æ®™æ®œ",4,"æ®¢",7,"æ®«",7,"æ®¶æ®¸",6,"æ¯€æ¯ƒæ¯„æ¯†",4,"æ¯Œæ¯Žæ¯æ¯‘æ¯˜æ¯šæ¯œ",4,"æ¯¢",7,"æ¯¬æ¯­æ¯®æ¯°æ¯±æ¯²æ¯´æ¯¶æ¯·æ¯¸æ¯ºæ¯»æ¯¼æ¯¾",6,"æ°ˆ",4,"æ°Žæ°’æ°—æ°œæ°æ°žæ° æ°£æ°¥æ°«æ°¬æ°­æ°±æ°³æ°¶æ°·æ°¹æ°ºæ°»æ°¼æ°¾æ°¿æ±ƒæ±„æ±…æ±ˆæ±‹",4,"æ±‘æ±’æ±“æ±–æ±˜"],["9b40","æ±™æ±šæ±¢æ±£æ±¥æ±¦æ±§æ±«",4,"æ±±æ±³æ±µæ±·æ±¸æ±ºæ±»æ±¼æ±¿æ²€æ²„æ²‡æ²Šæ²‹æ²æ²Žæ²‘æ²’æ²•æ²–æ²—æ²˜æ²šæ²œæ²æ²žæ² æ²¢æ²¨æ²¬æ²¯æ²°æ²´æ²µæ²¶æ²·æ²ºæ³€æ³æ³‚æ³ƒæ³†æ³‡æ³ˆæ³‹æ³æ³Žæ³æ³‘æ³’æ³˜"],["9b80","æ³™æ³šæ³œæ³æ³Ÿæ³¤æ³¦æ³§æ³©æ³¬æ³­æ³²æ³´æ³¹æ³¿æ´€æ´‚æ´ƒæ´…æ´†æ´ˆæ´‰æ´Šæ´æ´æ´æ´‘æ´“æ´”æ´•æ´–æ´˜æ´œæ´æ´Ÿ",5,"æ´¦æ´¨æ´©æ´¬æ´­æ´¯æ´°æ´´æ´¶æ´·æ´¸æ´ºæ´¿æµ€æµ‚æµ„æµ‰æµŒæµæµ•æµ–æµ—æµ˜æµ›æµæµŸæµ¡æµ¢æµ¤æµ¥æµ§æµ¨æµ«æµ¬æµ­æµ°æµ±æµ²æµ³æµµæµ¶æµ¹æµºæµ»æµ½",4,"æ¶ƒæ¶„æ¶†æ¶‡æ¶Šæ¶‹æ¶æ¶æ¶æ¶’æ¶–",4,"æ¶œæ¶¢æ¶¥æ¶¬æ¶­æ¶°æ¶±æ¶³æ¶´æ¶¶æ¶·æ¶¹",5,"æ·æ·‚æ·ƒæ·ˆæ·‰æ·Š"],["9c40","æ·æ·Žæ·æ·æ·’æ·“æ·”æ·•æ·—æ·šæ·›æ·œæ·Ÿæ·¢æ·£æ·¥æ·§æ·¨æ·©æ·ªæ·­æ·¯æ·°æ·²æ·´æ·µæ·¶æ·¸æ·ºæ·½",7,"æ¸†æ¸‡æ¸ˆæ¸‰æ¸‹æ¸æ¸’æ¸“æ¸•æ¸˜æ¸™æ¸›æ¸œæ¸žæ¸Ÿæ¸¢æ¸¦æ¸§æ¸¨æ¸ªæ¸¬æ¸®æ¸°æ¸±æ¸³æ¸µ"],["9c80","æ¸¶æ¸·æ¸¹æ¸»",7,"æ¹…",7,"æ¹æ¹æ¹‘æ¹’æ¹•æ¹—æ¹™æ¹šæ¹œæ¹æ¹žæ¹ ",10,"æ¹¬æ¹­æ¹¯",14,"æº€æºæº‚æº„æº‡æºˆæºŠ",4,"æº‘",6,"æº™æºšæº›æºæºžæº æº¡æº£æº¤æº¦æº¨æº©æº«æº¬æº­æº®æº°æº³æºµæº¸æº¹æº¼æº¾æº¿æ»€æ»ƒæ»„æ»…æ»†æ»ˆæ»‰æ»Šæ»Œæ»æ»Žæ»æ»’æ»–æ»˜æ»™æ»›æ»œæ»æ»£æ»§æ»ª",5],["9d40","æ»°æ»±æ»²æ»³æ»µæ»¶æ»·æ»¸æ»º",7,"æ¼ƒæ¼„æ¼…æ¼‡æ¼ˆæ¼Š",4,"æ¼æ¼‘æ¼’æ¼–",9,"æ¼¡æ¼¢æ¼£æ¼¥æ¼¦æ¼§æ¼¨æ¼¬æ¼®æ¼°æ¼²æ¼´æ¼µæ¼·",6,"æ¼¿æ½€æ½æ½‚"],["9d80","æ½ƒæ½„æ½…æ½ˆæ½‰æ½Šæ½Œæ½Ž",9,"æ½™æ½šæ½›æ½æ½Ÿæ½ æ½¡æ½£æ½¤æ½¥æ½§",5,"æ½¯æ½°æ½±æ½³æ½µæ½¶æ½·æ½¹æ½»æ½½",6,"æ¾…æ¾†æ¾‡æ¾Šæ¾‹æ¾",12,"æ¾æ¾žæ¾Ÿæ¾ æ¾¢",4,"æ¾¨",10,"æ¾´æ¾µæ¾·æ¾¸æ¾º",5,"æ¿æ¿ƒ",5,"æ¿Š",6,"æ¿“",10,"æ¿Ÿæ¿¢æ¿£æ¿¤æ¿¥"],["9e40","æ¿¦",7,"æ¿°",32,"ç€’",7,"ç€œ",6,"ç€¤",6],["9e80","ç€«",9,"ç€¶ç€·ç€¸ç€º",17,"ççŽç",13,"çŸ",11,"ç®ç±ç²ç³ç´ç·ç¹çºç»ç½ç‚ç‚‚ç‚ƒç‚„ç‚†ç‚‡ç‚ˆç‚‹ç‚Œç‚ç‚ç‚ç‚‘ç‚“ç‚—ç‚˜ç‚šç‚›ç‚ž",12,"ç‚°ç‚²ç‚´ç‚µç‚¶ç‚ºç‚¾ç‚¿çƒ„çƒ…çƒ†çƒ‡çƒ‰çƒ‹",12,"çƒš"],["9f40","çƒœçƒçƒžçƒ çƒ¡çƒ¢çƒ£çƒ¥çƒªçƒ®çƒ°",6,"çƒ¸çƒºçƒ»çƒ¼çƒ¾",10,"ç„‹",4,"ç„‘ç„’ç„”ç„—ç„›",10,"ç„§",7,"ç„²ç„³ç„´"],["9f80","ç„µç„·",13,"ç…†ç…‡ç…ˆç…‰ç…‹ç…ç…",12,"ç…ç…Ÿ",4,"ç…¥ç…©",4,"ç…¯ç…°ç…±ç…´ç…µç…¶ç…·ç…¹ç…»ç…¼ç…¾",5,"ç†…",4,"ç†‹ç†Œç†ç†Žç†ç†‘ç†’ç†“ç†•ç†–ç†—ç†š",4,"ç†¡",6,"ç†©ç†ªç†«ç†­",5,"ç†´ç†¶ç†·ç†¸ç†º",8,"ç‡„",9,"ç‡",4],["a040","ç‡–",9,"ç‡¡ç‡¢ç‡£ç‡¤ç‡¦ç‡¨",5,"ç‡¯",9,"ç‡º",11,"çˆ‡",19],["a080","çˆ›çˆœçˆž",9,"çˆ©çˆ«çˆ­çˆ®çˆ¯çˆ²çˆ³çˆ´çˆºçˆ¼çˆ¾ç‰€",6,"ç‰‰ç‰Šç‰‹ç‰Žç‰ç‰ç‰‘ç‰“ç‰”ç‰•ç‰—ç‰˜ç‰šç‰œç‰žç‰ ç‰£ç‰¤ç‰¥ç‰¨ç‰ªç‰«ç‰¬ç‰­ç‰°ç‰±ç‰³ç‰´ç‰¶ç‰·ç‰¸ç‰»ç‰¼ç‰½çŠ‚çŠƒçŠ…",4,"çŠŒçŠŽçŠçŠ‘çŠ“",11,"çŠ ",11,"çŠ®çŠ±çŠ²çŠ³çŠµçŠº",6,"ç‹…ç‹†ç‹‡ç‹‰ç‹Šç‹‹ç‹Œç‹ç‹‘ç‹“ç‹”ç‹•ç‹–ç‹˜ç‹šç‹›"],["a1a1","ã€€ã€ã€‚Â·Ë‰Ë‡Â¨ã€ƒã€…â€”ï½žâ€–â€¦â€˜â€™â€œâ€ã€”ã€•ã€ˆ",7,"ã€–ã€—ã€ã€‘Â±Ã—Ã·âˆ¶âˆ§âˆ¨âˆ‘âˆâˆªâˆ©âˆˆâˆ·âˆšâŠ¥âˆ¥âˆ âŒ’âŠ™âˆ«âˆ®â‰¡â‰Œâ‰ˆâˆ½âˆâ‰ â‰®â‰¯â‰¤â‰¥âˆžâˆµâˆ´â™‚â™€Â°â€²â€³â„ƒï¼„Â¤ï¿ ï¿¡â€°Â§â„–â˜†â˜…â—‹â—â—Žâ—‡â—†â–¡â– â–³â–²â€»â†’â†â†‘â†“ã€“"],["a2a1","â…°",9],["a2b1","â’ˆ",19,"â‘´",19,"â‘ ",9],["a2e5","ãˆ ",9],["a2f1","â… ",11],["a3a1","ï¼ï¼‚ï¼ƒï¿¥ï¼…",88,"ï¿£"],["a4a1","ã",82],["a5a1","ã‚¡",85],["a6a1","Î‘",16,"Î£",6],["a6c1","Î±",16,"Ïƒ",6],["a6e0","ï¸µï¸¶ï¸¹ï¸ºï¸¿ï¹€ï¸½ï¸¾ï¹ï¹‚ï¹ƒï¹„"],["a6ee","ï¸»ï¸¼ï¸·ï¸¸ï¸±"],["a6f4","ï¸³ï¸´"],["a7a1","Ð",5,"ÐÐ–",25],["a7d1","Ð°",5,"Ñ‘Ð¶",25],["a840","ËŠË‹Ë™â€“â€•â€¥â€µâ„…â„‰â†–â†—â†˜â†™âˆ•âˆŸâˆ£â‰’â‰¦â‰§âŠ¿â•",35,"â–",6],["a880","â–ˆ",7,"â–“â–”â–•â–¼â–½â—¢â—£â—¤â—¥â˜‰âŠ•ã€’ã€ã€ž"],["a8a1","ÄÃ¡ÇŽÃ Ä“Ã©Ä›Ã¨Ä«Ã­ÇÃ¬ÅÃ³Ç’Ã²Å«ÃºÇ”Ã¹Ç–Ç˜ÇšÇœÃ¼ÃªÉ‘"],["a8bd","Å„Åˆ"],["a8c0","É¡"],["a8c5","ã„…",36],["a940","ã€¡",8,"ãŠ£ãŽŽãŽãŽœãŽãŽžãŽ¡ã„ãŽã‘ã’ã•ï¸°ï¿¢ï¿¤"],["a959","â„¡ãˆ±"],["a95c","â€"],["a960","ãƒ¼ã‚›ã‚œãƒ½ãƒ¾ã€†ã‚ã‚žï¹‰",9,"ï¹”ï¹•ï¹–ï¹—ï¹™",8],["a980","ï¹¢",4,"ï¹¨ï¹©ï¹ªï¹«"],["a996","ã€‡"],["a9a4","â”€",75],["aa40","ç‹œç‹ç‹Ÿç‹¢",5,"ç‹ªç‹«ç‹µç‹¶ç‹¹ç‹½ç‹¾ç‹¿çŒ€çŒ‚çŒ„",5,"çŒ‹çŒŒçŒçŒçŒçŒ‘çŒ’çŒ”çŒ˜çŒ™çŒšçŒŸçŒ çŒ£çŒ¤çŒ¦çŒ§çŒ¨çŒ­çŒ¯çŒ°çŒ²çŒ³çŒµçŒ¶çŒºçŒ»çŒ¼çŒ½ç€",8],["aa80","ç‰çŠç‹çŒçŽçç‘ç“ç”ç•ç–ç˜",7,"ç¡",10,"ç®ç°ç±"],["ab40","ç²",11,"ç¿",4,"çŽ…çŽ†çŽˆçŽŠçŽŒçŽçŽçŽçŽ’çŽ“çŽ”çŽ•çŽ—çŽ˜çŽ™çŽšçŽœçŽçŽžçŽ çŽ¡çŽ£",5,"çŽªçŽ¬çŽ­çŽ±çŽ´çŽµçŽ¶çŽ¸çŽ¹çŽ¼çŽ½çŽ¾çŽ¿ççƒ",4],["ab80","ç‹çŒçŽç’",6,"çšç›çœççŸç¡ç¢ç£ç¤ç¦ç¨çªç«ç¬ç®ç¯ç°ç±ç³",4],["ac40","ç¸",10,"ç„ç‡çˆç‹çŒççŽç‘",8,"çœ",5,"ç£ç¤ç§ç©ç«ç­ç¯ç±ç²ç·",4,"ç½ç¾ç¿ç‘€ç‘‚",11],["ac80","ç‘Ž",6,"ç‘–ç‘˜ç‘ç‘ ",12,"ç‘®ç‘¯ç‘±",4,"ç‘¸ç‘¹ç‘º"],["ad40","ç‘»ç‘¼ç‘½ç‘¿ç’‚ç’„ç’…ç’†ç’ˆç’‰ç’Šç’Œç’ç’ç’‘",10,"ç’ç’Ÿ",7,"ç’ª",15,"ç’»",12],["ad80","ç“ˆ",9,"ç““",8,"ç“ç“Ÿç“¡ç“¥ç“§",6,"ç“°ç“±ç“²"],["ae40","ç“³ç“µç“¸",6,"ç”€ç”ç”‚ç”ƒç”…",7,"ç”Žç”ç”’ç””ç”•ç”–ç”—ç”›ç”ç”žç” ",4,"ç”¦ç”§ç”ªç”®ç”´ç”¶ç”¹ç”¼ç”½ç”¿ç•ç•‚ç•ƒç•„ç•†ç•‡ç•‰ç•Šç•ç•ç•‘ç•’ç•“ç••ç•–ç•—ç•˜"],["ae80","ç•",7,"ç•§ç•¨ç•©ç•«",6,"ç•³ç•µç•¶ç•·ç•º",4,"ç–€ç–ç–‚ç–„ç–…ç–‡"],["af40","ç–ˆç–‰ç–Šç–Œç–ç–Žç–ç–“ç–•ç–˜ç–›ç–œç–žç–¢ç–¦",4,"ç–­ç–¶ç–·ç–ºç–»ç–¿ç—€ç—ç—†ç—‹ç—Œç—Žç—ç—ç—‘ç—“ç——ç—™ç—šç—œç—ç—Ÿç— ç—¡ç—¥ç—©ç—¬ç—­ç—®ç—¯ç—²ç—³ç—µç—¶ç—·ç—¸ç—ºç—»ç—½ç—¾ç˜‚ç˜„ç˜†ç˜‡"],["af80","ç˜ˆç˜‰ç˜‹ç˜ç˜Žç˜ç˜‘ç˜’ç˜“ç˜”ç˜–ç˜šç˜œç˜ç˜žç˜¡ç˜£ç˜§ç˜¨ç˜¬ç˜®ç˜¯ç˜±ç˜²ç˜¶ç˜·ç˜¹ç˜ºç˜»ç˜½ç™ç™‚ç™„"],["b040","ç™…",6,"ç™Ž",5,"ç™•ç™—",4,"ç™ç™Ÿç™ ç™¡ç™¢ç™¤",6,"ç™¬ç™­ç™®ç™°",7,"ç™¹ç™ºç™¼ç™¿çš€çšçšƒçš…çš‰çšŠçšŒçšçšçšçš’çš”çš•çš—çš˜çššçš›"],["b080","çšœ",7,"çš¥",8,"çš¯çš°çš³çšµ",9,"ç›€ç›ç›ƒå•Šé˜¿åŸƒæŒ¨å“Žå”‰å“€çš‘ç™Œè”¼çŸ®è‰¾ç¢çˆ±éš˜éžæ°¨å®‰ä¿ºæŒ‰æš—å²¸èƒºæ¡ˆè‚®æ˜‚ç›Žå‡¹æ•–ç†¬ç¿±è¢„å‚²å¥¥æ‡Šæ¾³èŠ­æŒæ‰’å­å§ç¬†å…«ç–¤å·´æ‹”è·‹é¶æŠŠè€™åéœ¸ç½¢çˆ¸ç™½æŸç™¾æ‘†ä½°è´¥æ‹œç¨—æ–‘ç­æ¬æ‰³èˆ¬é¢æ¿ç‰ˆæ‰®æ‹Œä¼´ç“£åŠåŠžç»Šé‚¦å¸®æ¢†æ¦œè†€ç»‘æ£’ç£…èšŒé•‘å‚è°¤è‹žèƒžåŒ…è¤’å‰¥"],["b140","ç›„ç›‡ç›‰ç›‹ç›Œç›“ç›•ç›™ç›šç›œç›ç›žç› ",4,"ç›¦",7,"ç›°ç›³ç›µç›¶ç›·ç›ºç›»ç›½ç›¿çœ€çœ‚çœƒçœ…çœ†çœŠçœŒçœŽ",10,"çœ›çœœçœçœžçœ¡çœ£çœ¤çœ¥çœ§çœªçœ«"],["b180","çœ¬çœ®çœ°",4,"çœ¹çœ»çœ½çœ¾çœ¿ç‚ç„ç…ç†çˆ",7,"ç’",7,"çœè–„é›¹ä¿å ¡é¥±å®æŠ±æŠ¥æš´è±¹é²çˆ†æ¯ç¢‘æ‚²å‘åŒ—è¾ˆèƒŒè´é’¡å€ç‹ˆå¤‡æƒ«ç„™è¢«å¥”è‹¯æœ¬ç¬¨å´©ç»·ç”­æ³µè¹¦è¿¸é€¼é¼»æ¯”é„™ç¬”å½¼ç¢§è“–è”½æ¯•æ¯™æ¯–å¸åº‡ç—¹é—­æ•å¼Šå¿…è¾Ÿå£è‡‚é¿é™›éž­è¾¹ç¼–è´¬æ‰ä¾¿å˜åžè¾¨è¾©è¾«éæ ‡å½ªè†˜è¡¨é³–æ†‹åˆ«ç˜ªå½¬æ–Œæ¿’æ»¨å®¾æ‘ˆå…µå†°æŸ„ä¸™ç§‰é¥¼ç‚³"],["b240","ççžçŸç ç¤ç§ç©çªç­",11,"çºç»ç¼çžçž‚çžƒçž†",5,"çžçžçž“",11,"çž¡çž£çž¤çž¦çž¨çž«çž­çž®çž¯çž±çž²çž´çž¶",4],["b280","çž¼çž¾çŸ€",12,"çŸŽ",8,"çŸ˜çŸ™çŸšçŸ",4,"çŸ¤ç—…å¹¶çŽ»è æ’­æ‹¨é’µæ³¢åšå‹ƒæé“‚ç®”ä¼¯å¸›èˆ¶è„–è†Šæ¸¤æ³Šé©³æ•åœå“ºè¡¥åŸ ä¸å¸ƒæ­¥ç°¿éƒ¨æ€–æ“¦çŒœè£ææ‰è´¢ç¬è¸©é‡‡å½©èœè”¡é¤å‚èš•æ®‹æƒ­æƒ¨ç¿è‹èˆ±ä»“æ²§è—æ“ç³™æ§½æ›¹è‰åŽ•ç­–ä¾§å†Œæµ‹å±‚è¹­æ’å‰èŒ¬èŒ¶æŸ¥ç¢´æ½å¯Ÿå²”å·®è¯§æ‹†æŸ´è±ºæ€æŽºè‰é¦‹è°—ç¼ é“²äº§é˜é¢¤æ˜ŒçŒ–"],["b340","çŸ¦çŸ¨çŸªçŸ¯çŸ°çŸ±çŸ²çŸ´çŸµçŸ·çŸ¹çŸºçŸ»çŸ¼ç ƒ",5,"ç Šç ‹ç Žç ç ç “ç •ç ™ç ›ç žç  ç ¡ç ¢ç ¤ç ¨ç ªç «ç ®ç ¯ç ±ç ²ç ³ç µç ¶ç ½ç ¿ç¡ç¡‚ç¡ƒç¡„ç¡†ç¡ˆç¡‰ç¡Šç¡‹ç¡ç¡ç¡‘ç¡“ç¡”ç¡˜ç¡™ç¡š"],["b380","ç¡›ç¡œç¡ž",11,"ç¡¯",7,"ç¡¸ç¡¹ç¡ºç¡»ç¡½",6,"åœºå°å¸¸é•¿å¿è‚ åŽ‚æ•žç•…å”±å€¡è¶…æŠ„é’žæœå˜²æ½®å·¢åµç‚’è½¦æ‰¯æ’¤æŽ£å½»æ¾ˆéƒ´è‡£è¾°å°˜æ™¨å¿±æ²‰é™ˆè¶è¡¬æ’‘ç§°åŸŽæ©™æˆå‘ˆä¹˜ç¨‹æƒ©æ¾„è¯šæ‰¿é€žéª‹ç§¤åƒç—´æŒåŒ™æ± è¿Ÿå¼›é©°è€»é½¿ä¾ˆå°ºèµ¤ç¿…æ–¥ç‚½å……å†²è™«å´‡å® æŠ½é…¬ç•´è¸Œç¨ æ„ç­¹ä»‡ç»¸çž…ä¸‘è‡­åˆå‡ºæ©±åŽ¨èº‡é”„é›æ»é™¤æ¥š"],["b440","ç¢„ç¢…ç¢†ç¢ˆç¢Šç¢‹ç¢ç¢ç¢’ç¢”ç¢•ç¢–ç¢™ç¢ç¢žç¢ ç¢¢ç¢¤ç¢¦ç¢¨",7,"ç¢µç¢¶ç¢·ç¢¸ç¢ºç¢»ç¢¼ç¢½ç¢¿ç£€ç£‚ç£ƒç£„ç£†ç£‡ç£ˆç£Œç£ç£Žç£ç£‘ç£’ç£“ç£–ç£—ç£˜ç£š",9],["b480","ç£¤ç£¥ç£¦ç£§ç£©ç£ªç£«ç£­",4,"ç£³ç£µç£¶ç£¸ç£¹ç£»",5,"ç¤‚ç¤ƒç¤„ç¤†",6,"ç¡€å‚¨çŸ—æè§¦å¤„æ£å·ç©¿æ¤½ä¼ èˆ¹å–˜ä¸²ç–®çª—å¹¢åºŠé—¯åˆ›å¹ç‚Šæ¶é”¤åž‚æ˜¥æ¤¿é†‡å”‡æ·³çº¯è ¢æˆ³ç»°ç–µèŒ¨ç£é›Œè¾žæ…ˆç“·è¯æ­¤åˆºèµæ¬¡èªè‘±å›±åŒ†ä»Žä¸›å‡‘ç²—é†‹ç°‡ä¿ƒè¹¿ç¯¡çªœæ‘§å´”å‚¬è„†ç˜ç²¹æ·¬ç¿ æ‘å­˜å¯¸ç£‹æ’®æ“æŽªæŒ«é”™æ­è¾¾ç­”ç˜©æ‰“å¤§å‘†æ­¹å‚£æˆ´å¸¦æ®†ä»£è´·è¢‹å¾…é€®"],["b540","ç¤",5,"ç¤”",9,"ç¤Ÿ",4,"ç¤¥",14,"ç¤µ",4,"ç¤½ç¤¿ç¥‚ç¥ƒç¥„ç¥…ç¥‡ç¥Š",8,"ç¥”ç¥•ç¥˜ç¥™ç¥¡ç¥£"],["b580","ç¥¤ç¥¦ç¥©ç¥ªç¥«ç¥¬ç¥®ç¥°",6,"ç¥¹ç¥»",4,"ç¦‚ç¦ƒç¦†ç¦‡ç¦ˆç¦‰ç¦‹ç¦Œç¦ç¦Žç¦ç¦‘ç¦’æ€ è€½æ‹…ä¸¹å•éƒ¸æŽ¸èƒ†æ—¦æ°®ä½†æƒ®æ·¡è¯žå¼¹è›‹å½“æŒ¡å…šè¡æ¡£åˆ€æ£è¹ˆå€’å²›ç¥·å¯¼åˆ°ç¨»æ‚¼é“ç›—å¾·å¾—çš„è¹¬ç¯ç™»ç­‰çžªå‡³é‚“å ¤ä½Žæ»´è¿ªæ•Œç¬›ç‹„æ¶¤ç¿Ÿå«¡æŠµåº•åœ°è’‚ç¬¬å¸å¼Ÿé€’ç¼”é¢ æŽ‚æ»‡ç¢˜ç‚¹å…¸é›åž«ç”µä½ƒç”¸åº—æƒ¦å¥ æ·€æ®¿ç¢‰å¼é›•å‡‹åˆæŽ‰åŠé’“è°ƒè·Œçˆ¹ç¢Ÿè¶è¿­è°å "],["b640","ç¦“",6,"ç¦›",11,"ç¦¨",10,"ç¦´",4,"ç¦¼ç¦¿ç§‚ç§„ç§…ç§‡ç§ˆç§Šç§Œç§Žç§ç§ç§“ç§”ç§–ç§—ç§™",5,"ç§ ç§¡ç§¢ç§¥ç§¨ç§ª"],["b680","ç§¬ç§®ç§±",6,"ç§¹ç§ºç§¼ç§¾ç§¿ç¨ç¨„ç¨…ç¨‡ç¨ˆç¨‰ç¨Šç¨Œç¨",4,"ç¨•ç¨–ç¨˜ç¨™ç¨›ç¨œä¸ç›¯å®é’‰é¡¶é¼Žé”­å®šè®¢ä¸¢ä¸œå†¬è‘£æ‡‚åŠ¨æ ‹ä¾—æ«å†»æ´žå…œæŠ–æ–—é™¡è±†é€—ç—˜éƒ½ç£æ¯’çŠŠç‹¬è¯»å µç¹èµŒæœé•€è‚šåº¦æ¸¡å¦’ç«¯çŸ­é”»æ®µæ–­ç¼Žå †å…‘é˜Ÿå¯¹å¢©å¨è¹²æ•¦é¡¿å›¤é’ç›¾éæŽ‡å“†å¤šå¤ºåž›èº²æœµè·ºèˆµå‰æƒ°å •è›¾å³¨é¹…ä¿„é¢è®¹å¨¥æ¶åŽ„æ‰¼éé„‚é¥¿æ©è€Œå„¿è€³å°”é¥µæ´±äºŒ"],["b740","ç¨ç¨Ÿç¨¡ç¨¢ç¨¤",14,"ç¨´ç¨µç¨¶ç¨¸ç¨ºç¨¾ç©€",5,"ç©‡",9,"ç©’",4,"ç©˜",16],["b780","ç©©",6,"ç©±ç©²ç©³ç©µç©»ç©¼ç©½ç©¾çª‚çª…çª‡çª‰çªŠçª‹çªŒçªŽçªçªçª“çª”çª™çªšçª›çªžçª¡çª¢è´°å‘ç½šç­ä¼ä¹é˜€æ³•çè—©å¸†ç•ªç¿»æ¨ŠçŸ¾é’’ç¹å‡¡çƒ¦åè¿”èŒƒè´©çŠ¯é¥­æ³›åŠèŠ³æ–¹è‚ªæˆ¿é˜²å¦¨ä»¿è®¿çººæ”¾è²éžå•¡é£žè‚¥åŒªè¯½å è‚ºåºŸæ²¸è´¹èŠ¬é…šå©æ°›åˆ†çº·åŸç„šæ±¾ç²‰å¥‹ä»½å¿¿æ„¤ç²ªä¸°å°æž«èœ‚å³°é”‹é£Žç–¯çƒ½é€¢å†¯ç¼è®½å¥‰å‡¤ä½›å¦å¤«æ•·è‚¤å­µæ‰¶æ‹‚è¾å¹…æ°Ÿç¬¦ä¼ä¿˜æœ"],["b840","çª£çª¤çª§çª©çªªçª«çª®",4,"çª´",10,"ç«€",10,"ç«Œ",9,"ç«—ç«˜ç«šç«›ç«œç«ç«¡ç«¢ç«¤ç«§",5,"ç«®ç«°ç«±ç«²ç«³"],["b880","ç«´",4,"ç«»ç«¼ç«¾ç¬€ç¬ç¬‚ç¬…ç¬‡ç¬‰ç¬Œç¬ç¬Žç¬ç¬’ç¬“ç¬–ç¬—ç¬˜ç¬šç¬œç¬ç¬Ÿç¬¡ç¬¢ç¬£ç¬§ç¬©ç¬­æµ®æ¶ªç¦è¢±å¼—ç”«æŠšè¾…ä¿¯é‡œæ–§è„¯è…‘åºœè…èµ´å‰¯è¦†èµ‹å¤å‚…ä»˜é˜œçˆ¶è…¹è´Ÿå¯Œè®£é™„å¦‡ç¼šå’å™¶å˜Žè¯¥æ”¹æ¦‚é’™ç›–æº‰å¹²ç”˜æ†æŸ‘ç«¿è‚èµ¶æ„Ÿç§†æ•¢èµ£å†ˆåˆšé’¢ç¼¸è‚›çº²å²—æ¸¯æ ç¯™çš‹é«˜è†ç¾”ç³•æžé•ç¨¿å‘Šå“¥æ­Œææˆˆé¸½èƒ³ç–™å‰²é©è‘›æ ¼è›¤é˜éš”é“¬ä¸ªå„ç»™æ ¹è·Ÿè€•æ›´åºšç¾¹"],["b940","ç¬¯ç¬°ç¬²ç¬´ç¬µç¬¶ç¬·ç¬¹ç¬»ç¬½ç¬¿",5,"ç­†ç­ˆç­Šç­ç­Žç­“ç­•ç­—ç­™ç­œç­žç­Ÿç­¡ç­£",10,"ç­¯ç­°ç­³ç­´ç­¶ç­¸ç­ºç­¼ç­½ç­¿ç®ç®‚ç®ƒç®„ç®†",6,"ç®Žç®"],["b980","ç®‘ç®’ç®“ç®–ç®˜ç®™ç®šç®›ç®žç®Ÿç® ç®£ç®¤ç®¥ç®®ç®¯ç®°ç®²ç®³ç®µç®¶ç®·ç®¹",7,"ç¯‚ç¯ƒç¯„åŸ‚è€¿æ¢—å·¥æ”»åŠŸæ­é¾šä¾›èº¬å…¬å®«å¼“å·©æ±žæ‹±è´¡å…±é’©å‹¾æ²Ÿè‹Ÿç‹—åž¢æž„è´­å¤Ÿè¾œè‡å’•ç®ä¼°æ²½å­¤å§‘é¼“å¤è›Šéª¨è°·è‚¡æ•…é¡¾å›ºé›‡åˆ®ç“œå‰å¯¡æŒ‚è¤‚ä¹–æ‹æ€ªæ£ºå…³å®˜å† è§‚ç®¡é¦†ç½æƒ¯çŒè´¯å…‰å¹¿é€›ç‘°è§„åœ­ç¡…å½’é¾Ÿé—ºè½¨é¬¼è¯¡ç™¸æ¡‚æŸœè·ªè´µåˆ½è¾Šæ»šæ£é”…éƒ­å›½æžœè£¹è¿‡å“ˆ"],["ba40","ç¯…ç¯ˆç¯‰ç¯Šç¯‹ç¯ç¯Žç¯ç¯ç¯’ç¯”",4,"ç¯›ç¯œç¯žç¯Ÿç¯ ç¯¢ç¯£ç¯¤ç¯§ç¯¨ç¯©ç¯«ç¯¬ç¯­ç¯¯ç¯°ç¯²",4,"ç¯¸ç¯¹ç¯ºç¯»ç¯½ç¯¿",7,"ç°ˆç°‰ç°Šç°ç°Žç°",5,"ç°—ç°˜ç°™"],["ba80","ç°š",4,"ç° ",5,"ç°¨ç°©ç°«",12,"ç°¹",5,"ç±‚éª¸å­©æµ·æ°¦äº¥å®³éª‡é…£æ†¨é‚¯éŸ©å«æ¶µå¯’å‡½å–Šç½•ç¿°æ’¼ææ—±æ†¾æ‚ç„Šæ±—æ±‰å¤¯æ­èˆªå£•åšŽè±ªæ¯«éƒå¥½è€—å·æµ©å‘µå–è·èæ ¸ç¦¾å’Œä½•åˆç›’è²‰é˜‚æ²³æ¶¸èµ«è¤é¹¤è´ºå˜¿é»‘ç—•å¾ˆç‹ æ¨å“¼äº¨æ¨ªè¡¡æ’è½°å“„çƒ˜è™¹é¸¿æ´ªå®å¼˜çº¢å–‰ä¾¯çŒ´å¼åŽšå€™åŽå‘¼ä¹Žå¿½ç‘šå£¶è‘«èƒ¡è´ç‹ç³Šæ¹–"],["bb40","ç±ƒ",9,"ç±Ž",36,"ç±µ",5,"ç±¾",9],["bb80","ç²ˆç²Š",6,"ç²“ç²”ç²–ç²™ç²šç²›ç² ç²¡ç²£ç²¦ç²§ç²¨ç²©ç²«ç²¬ç²­ç²¯ç²°ç²´",4,"ç²ºç²»å¼§è™Žå”¬æŠ¤äº’æ²ªæˆ·èŠ±å“—åŽçŒ¾æ»‘ç”»åˆ’åŒ–è¯æ§å¾Šæ€€æ·®åæ¬¢çŽ¯æ¡“è¿˜ç¼“æ¢æ‚£å”¤ç—ªè±¢ç„•æ¶£å®¦å¹»è’æ…Œé»„ç£ºè—ç°§çš‡å‡°æƒ¶ç…Œæ™ƒå¹Œæè°Žç°æŒ¥è¾‰å¾½æ¢è›”å›žæ¯æ‚”æ…§å‰æƒ æ™¦è´¿ç§½ä¼šçƒ©æ±‡è®³è¯²ç»˜è¤æ˜å©šé­‚æµ‘æ··è±æ´»ä¼™ç«èŽ·æˆ–æƒ‘éœè´§ç¥¸å‡»åœ¾åŸºæœºç•¸ç¨½ç§¯ç®•"],["bc40","ç²¿ç³€ç³‚ç³ƒç³„ç³†ç³‰ç³‹ç³Ž",6,"ç³˜ç³šç³›ç³ç³žç³¡",6,"ç³©",5,"ç³°",7,"ç³¹ç³ºç³¼",13,"ç´‹",5],["bc80","ç´‘",14,"ç´¡ç´£ç´¤ç´¥ç´¦ç´¨ç´©ç´ªç´¬ç´­ç´®ç´°",6,"è‚Œé¥¥è¿¹æ¿€è®¥é¸¡å§¬ç»©ç¼‰å‰æžæ£˜è¾‘ç±é›†åŠæ€¥ç–¾æ±²å³å«‰çº§æŒ¤å‡ è„Šå·±è“ŸæŠ€å†€å­£ä¼Žç¥­å‰‚æ‚¸æµŽå¯„å¯‚è®¡è®°æ—¢å¿Œé™…å¦“ç»§çºªå˜‰æž·å¤¹ä½³å®¶åŠ èšé¢Šè´¾ç”²é’¾å‡ç¨¼ä»·æž¶é©¾å«æ­¼ç›‘åšå°–ç¬ºé—´ç…Žå…¼è‚©è‰°å¥¸ç¼„èŒ§æ£€æŸ¬ç¢±ç¡·æ‹£æ¡ç®€ä¿­å‰ªå‡èæ§›é‰´è·µè´±è§é”®ç®­ä»¶"],["bd40","ç´·",54,"çµ¯",7],["bd80","çµ¸",32,"å¥èˆ°å‰‘é¥¯æ¸æº…æ¶§å»ºåƒµå§œå°†æµ†æ±Ÿç–†è’‹æ¡¨å¥–è®²åŒ é…±é™è•‰æ¤’ç¤ç„¦èƒ¶äº¤éƒŠæµ‡éª„å¨‡åš¼æ…é“°çŸ«ä¾¥è„šç‹¡è§’é¥ºç¼´ç»žå‰¿æ•™é…µè½¿è¾ƒå«çª–æ­æŽ¥çš†ç§¸è¡—é˜¶æˆªåŠ«èŠ‚æ¡”æ°æ·ç«ç«­æ´ç»“è§£å§æˆ’è—‰èŠ¥ç•Œå€Ÿä»‹ç–¥è¯«å±Šå·¾ç­‹æ–¤é‡‘ä»Šæ´¥è¥Ÿç´§é”¦ä»…è°¨è¿›é³æ™‹ç¦è¿‘çƒ¬æµ¸"],["be40","ç¶™",12,"ç¶§",6,"ç¶¯",42],["be80","ç·š",32,"å°½åŠ²è†å…¢èŒŽç›æ™¶é²¸äº¬æƒŠç²¾ç²³ç»äº•è­¦æ™¯é¢ˆé™å¢ƒæ•¬é•œå¾„ç—‰é–ç«Ÿç«žå‡€ç‚¯çª˜æªç©¶çº çŽ–éŸ­ä¹…ç¸ä¹é…’åŽ©æ•‘æ—§è‡¼èˆ…å’Žå°±ç–šéž æ‹˜ç‹™ç–½å±…é©¹èŠå±€å’€çŸ©ä¸¾æ²®èšæ‹’æ®å·¨å…·è·è¸žé”¯ä¿±å¥æƒ§ç‚¬å‰§æé¹ƒå¨Ÿå€¦çœ·å·ç»¢æ’…æ”«æŠ‰æŽ˜å€”çˆµè§‰å†³è¯€ç»å‡èŒé’§å†›å›å³»"],["bf40","ç·»",62],["bf80","ç¸ºç¸¼",4,"ç¹‚",4,"ç¹ˆ",21,"ä¿Šç«£æµšéƒ¡éªå–€å’–å¡å’¯å¼€æ©æ¥·å‡¯æ…¨åˆŠå ªå‹˜åŽç çœ‹åº·æ…·ç³ æ‰›æŠ—äº¢ç‚•è€ƒæ‹·çƒ¤é å·è‹›æŸ¯æ£µç£•é¢—ç§‘å£³å’³å¯æ¸´å…‹åˆ»å®¢è¯¾è‚¯å•ƒåž¦æ³å‘å­ç©ºæå­”æŽ§æŠ å£æ‰£å¯‡æž¯å“­çªŸè‹¦é…·åº“è£¤å¤¸åž®æŒŽè·¨èƒ¯å—ç­·ä¾©å¿«å®½æ¬¾åŒ¡ç­ç‹‚æ¡†çŸ¿çœ¶æ—·å†µäºç›”å²¿çª¥è‘µå¥Žé­å‚€"],["c040","ç¹ž",35,"çºƒ",23,"çºœçºçºž"],["c080","çº®çº´çº»çº¼ç»–ç»¤ç»¬ç»¹ç¼Šç¼ç¼žç¼·ç¼¹ç¼»",6,"ç½ƒç½†",9,"ç½’ç½“é¦ˆæ„§æºƒå¤æ˜†æ†å›°æ‹¬æ‰©å»“é˜”åžƒæ‹‰å–‡èœ¡è…Šè¾£å•¦èŽ±æ¥èµ–è“å©ªæ æ‹¦ç¯®é˜‘å…°æ¾œè°°æ½è§ˆæ‡’ç¼†çƒ‚æ»¥ç…æ¦”ç‹¼å»ŠéƒŽæœ—æµªæžåŠ³ç‰¢è€ä½¬å§¥é…ªçƒ™æ¶å‹’ä¹é›·é•­è•¾ç£Šç´¯å„¡åž’æ“‚è‚‹ç±»æ³ªæ£±æ¥žå†·åŽ˜æ¢¨çŠé»Žç¯±ç‹¸ç¦»æ¼“ç†æŽé‡Œé²¤ç¤¼èŽ‰è”åæ —ä¸½åŽ‰åŠ±ç ¾åŽ†åˆ©å‚ˆä¾‹ä¿"],["c140","ç½–ç½™ç½›ç½œç½ç½žç½ ç½£",4,"ç½«ç½¬ç½­ç½¯ç½°ç½³ç½µç½¶ç½·ç½¸ç½ºç½»ç½¼ç½½ç½¿ç¾€ç¾‚",7,"ç¾‹ç¾ç¾",4,"ç¾•",4,"ç¾›ç¾œç¾ ç¾¢ç¾£ç¾¥ç¾¦ç¾¨",6,"ç¾±"],["c180","ç¾³",4,"ç¾ºç¾»ç¾¾ç¿€ç¿‚ç¿ƒç¿„ç¿†ç¿‡ç¿ˆç¿‰ç¿‹ç¿ç¿",4,"ç¿–ç¿—ç¿™",5,"ç¿¢ç¿£ç—¢ç«‹ç²’æ²¥éš¶åŠ›ç’ƒå“©ä¿©è”èŽ²è¿žé•°å»‰æ€œæ¶Ÿå¸˜æ•›è„¸é“¾æ‹ç‚¼ç»ƒç²®å‡‰æ¢ç²±è‰¯ä¸¤è¾†é‡æ™¾äº®è°…æ’©èŠåƒšç–—ç‡Žå¯¥è¾½æ½¦äº†æ’‚é•£å»–æ–™åˆ—è£‚çƒˆåŠ£çŒŽç³æž—ç£·éœ–ä¸´é‚»é³žæ·‹å‡›èµåæ‹ŽçŽ²è±é›¶é¾„é“ƒä¼¶ç¾šå‡Œçµé™µå²­é¢†å¦ä»¤æºœç‰æ¦´ç¡«é¦ç•™åˆ˜ç˜¤æµæŸ³å…­é¾™è‹å’™ç¬¼çª¿"],["c240","ç¿¤ç¿§ç¿¨ç¿ªç¿«ç¿¬ç¿­ç¿¯ç¿²ç¿´",6,"ç¿½ç¿¾ç¿¿è€‚è€‡è€ˆè€‰è€Šè€Žè€è€‘è€“è€šè€›è€è€žè€Ÿè€¡è€£è€¤è€«",5,"è€²è€´è€¹è€ºè€¼è€¾è€èè„è…è‡èˆè‰èŽèèè‘è“è•è–è—"],["c280","è™è›",13,"è«",5,"è²",11,"éš†åž„æ‹¢é™‡æ¥¼å¨„æ‚ç¯“æ¼é™‹èŠ¦å¢é¢…åºç‚‰æŽ³å¤è™é²éº“ç¢Œéœ²è·¯èµ‚é¹¿æ½žç¦„å½•é™†æˆ®é©´å•é“ä¾£æ—…å±¥å±¡ç¼•è™‘æ°¯å¾‹çŽ‡æ»¤ç»¿å³¦æŒ›å­ªæ»¦åµä¹±æŽ ç•¥æŠ¡è½®ä¼¦ä»‘æ²¦çº¶è®ºèèžºç½—é€»é”£ç®©éª¡è£¸è½æ´›éª†ç»œå¦ˆéº»çŽ›ç èš‚é©¬éª‚å˜›å—åŸ‹ä¹°éº¦å–è¿ˆè„‰çž’é¦’è›®æ»¡è”“æ›¼æ…¢æ¼«"],["c340","è¾è‚è‚‚è‚…è‚ˆè‚Šè‚",5,"è‚”è‚•è‚—è‚™è‚žè‚£è‚¦è‚§è‚¨è‚¬è‚°è‚³è‚µè‚¶è‚¸è‚¹è‚»èƒ…èƒ‡",4,"èƒ",6,"èƒ˜èƒŸèƒ èƒ¢èƒ£èƒ¦èƒ®èƒµèƒ·èƒ¹èƒ»èƒ¾èƒ¿è„€è„è„ƒè„„è„…è„‡è„ˆè„‹"],["c380","è„Œè„•è„—è„™è„›è„œè„è„Ÿ",12,"è„­è„®è„°è„³è„´è„µè„·è„¹",4,"è„¿è°©èŠ’èŒ«ç›²æ°“å¿™èŽ½çŒ«èŒ…é”šæ¯›çŸ›é“†å¯èŒ‚å†’å¸½è²Œè´¸ä¹ˆçŽ«æžšæ¢…é…¶éœ‰ç…¤æ²¡çœ‰åª’é•æ¯ç¾Žæ˜§å¯å¦¹åªšé—¨é—·ä»¬èŒè’™æª¬ç›Ÿé”°çŒ›æ¢¦å­Ÿçœ¯é†šé¡ç³œè¿·è°œå¼¥ç±³ç§˜è§…æ³Œèœœå¯†å¹‚æ£‰çœ ç»µå†•å…å‹‰å¨©ç¼…é¢è‹—æçž„è—ç§’æ¸ºåº™å¦™è”‘ç­æ°‘æŠ¿çš¿æ•æ‚¯é—½æ˜ŽèžŸé¸£é“­åå‘½è°¬æ‘¸"],["c440","è…€",5,"è…‡è…‰è…è…Žè…è…’è…–è…—è…˜è…›",4,"è…¡è…¢è…£è…¤è…¦è…¨è…ªè…«è…¬è…¯è…²è…³è…µè…¶è…·è…¸è†è†ƒ",4,"è†‰è†‹è†Œè†è†Žè†è†’",5,"è†™è†šè†ž",4,"è†¤è†¥"],["c480","è†§è†©è†«",7,"è†´",5,"è†¼è†½è†¾è†¿è‡„è‡…è‡‡è‡ˆè‡‰è‡‹è‡",6,"æ‘¹è˜‘æ¨¡è†œç£¨æ‘©é­”æŠ¹æœ«èŽ«å¢¨é»˜æ²«æ¼ å¯žé™Œè°‹ç‰ŸæŸæ‹‡ç‰¡äº©å§†æ¯å¢“æš®å¹•å‹Ÿæ…•æœ¨ç›®ç¦ç‰§ç©†æ‹¿å“ªå‘é’ é‚£å¨œçº³æ°–ä¹ƒå¥¶è€å¥ˆå—ç”·éš¾å›ŠæŒ è„‘æ¼é—¹æ·–å‘¢é¦å†…å«©èƒ½å¦®éœ“å€ªæ³¥å°¼æ‹Ÿä½ åŒ¿è…»é€†æººè”«æ‹ˆå¹´ç¢¾æ’µæ»å¿µå¨˜é…¿é¸Ÿå°¿æè‚å­½å•®é•Šé•æ¶…æ‚¨æŸ ç‹žå‡å®"],["c540","è‡”",14,"è‡¤è‡¥è‡¦è‡¨è‡©è‡«è‡®",4,"è‡µ",5,"è‡½è‡¿èˆƒèˆ‡",4,"èˆŽèˆèˆ‘èˆ“èˆ•",5,"èˆèˆ èˆ¤èˆ¥èˆ¦èˆ§èˆ©èˆ®èˆ²èˆºèˆ¼èˆ½èˆ¿"],["c580","è‰€è‰è‰‚è‰ƒè‰…è‰†è‰ˆè‰Šè‰Œè‰è‰Žè‰",7,"è‰™è‰›è‰œè‰è‰žè‰ ",7,"è‰©æ‹§æ³žç‰›æ‰­é’®çº½è„“æµ“å†œå¼„å¥´åŠªæ€’å¥³æš–è™ç–ŸæŒªæ‡¦ç³¯è¯ºå“¦æ¬§é¸¥æ®´è—•å‘•å¶æ²¤å•ªè¶´çˆ¬å¸•æ€•ç¶æ‹æŽ’ç‰Œå¾˜æ¹ƒæ´¾æ”€æ½˜ç›˜ç£ç›¼ç•”åˆ¤å›ä¹“åºžæ—è€ªèƒ–æŠ›å’†åˆ¨ç‚®è¢è·‘æ³¡å‘¸èƒšåŸ¹è£´èµ”é™ªé…ä½©æ²›å–·ç›†ç °æŠ¨çƒ¹æ¾Žå½­è“¬æ£šç¡¼ç¯·è†¨æœ‹é¹æ§ç¢°å¯ç ’éœ¹æ‰¹æŠ«åŠˆçµæ¯—"],["c640","è‰ªè‰«è‰¬è‰­è‰±è‰µè‰¶è‰·è‰¸è‰»è‰¼èŠ€èŠèŠƒèŠ…èŠ†èŠ‡èŠ‰èŠŒèŠèŠ“èŠ”èŠ•èŠ–èŠšèŠ›èŠžèŠ èŠ¢èŠ£èŠ§èŠ²èŠµèŠ¶èŠºèŠ»èŠ¼èŠ¿è‹€è‹‚è‹ƒè‹…è‹†è‹‰è‹è‹–è‹™è‹šè‹è‹¢è‹§è‹¨è‹©è‹ªè‹¬è‹­è‹®è‹°è‹²è‹³è‹µè‹¶è‹¸"],["c680","è‹ºè‹¼",4,"èŒŠèŒ‹èŒèŒèŒ’èŒ“èŒ–èŒ˜èŒ™èŒ",9,"èŒ©èŒªèŒ®èŒ°èŒ²èŒ·èŒ»èŒ½å•¤è„¾ç–²çš®åŒ¹ç—žåƒ»å±è­¬ç¯‡åç‰‡éª—é£˜æ¼‚ç“¢ç¥¨æ’‡çž¥æ‹¼é¢‘è´«å“è˜ä¹’åªè‹¹èå¹³å‡­ç“¶è¯„å±å¡æ³¼é¢‡å©†ç ´é­„è¿«ç²•å‰–æ‰‘é“ºä»†èŽ†è‘¡è©è’²åŸ”æœ´åœƒæ™®æµ¦è°±æ›ç€‘æœŸæ¬ºæ –æˆšå¦»ä¸ƒå‡„æ¼†æŸ’æ²å…¶æ£‹å¥‡æ­§ç•¦å´Žè„é½æ——ç¥ˆç¥éª‘èµ·å²‚ä¹žä¼å¯å¥‘ç Œå™¨æ°”è¿„å¼ƒæ±½æ³£è®«æŽ"],["c740","èŒ¾èŒ¿èè‚è„è…èˆèŠ",4,"è“è•",4,"èè¢è°",6,"è¹èºè¾",6,"èŽ‡èŽˆèŽŠèŽ‹èŽŒèŽèŽèŽèŽ‘èŽ”èŽ•èŽ–èŽ—èŽ™èŽšèŽèŽŸèŽ¡",6,"èŽ¬èŽ­èŽ®"],["c780","èŽ¯èŽµèŽ»èŽ¾èŽ¿è‚èƒè„è†èˆè‰è‹èèŽèè‘è’è“è•è—è™èšè›èžè¢è£è¤è¦è§è¨è«è¬è­æ°æ´½ç‰µæ‰¦é’Žé“…åƒè¿ç­¾ä»Ÿè°¦ä¹¾é»”é’±é’³å‰æ½œé£æµ…è°´å ‘åµŒæ¬ æ­‰æžªå‘›è…”ç¾Œå¢™è”·å¼ºæŠ¢æ©‡é”¹æ•²æ‚„æ¡¥çž§ä¹”ä¾¨å·§éž˜æ’¬ç¿˜å³­ä¿çªåˆ‡èŒ„ä¸”æ€¯çªƒé’¦ä¾µäº²ç§¦ç´å‹¤èŠ¹æ“’ç¦½å¯æ²é’è½»æ°¢å€¾å¿æ¸…æ“Žæ™´æ°°æƒ…é¡·è¯·åº†ç¼ç©·ç§‹ä¸˜é‚±çƒæ±‚å›šé…‹æ³…è¶‹åŒºè›†æ›²èº¯å±ˆé©±æ¸ "],["c840","è®è¯è³",4,"èºè»è¼è¾è¿è€è‚è…è‡èˆè‰èŠèè’",5,"è™èšè›èž",5,"è©",7,"è²",5,"è¹èºè»è¾",7,"è‘‡è‘ˆè‘‰"],["c880","è‘Š",6,"è‘’",4,"è‘˜è‘è‘žè‘Ÿè‘ è‘¢è‘¤",4,"è‘ªè‘®è‘¯è‘°è‘²è‘´è‘·è‘¹è‘»è‘¼å–å¨¶é¾‹è¶£åŽ»åœˆé¢§æƒé†›æ³‰å…¨ç—Šæ‹³çŠ¬åˆ¸åŠç¼ºç‚”ç˜¸å´é¹Šæ¦·ç¡®é›€è£™ç¾¤ç„¶ç‡ƒå†‰æŸ“ç“¤å£¤æ”˜åš·è®©é¥¶æ‰°ç»•æƒ¹çƒ­å£¬ä»äººå¿éŸ§ä»»è®¤åˆƒå¦Šçº«æ‰”ä»æ—¥æˆŽèŒ¸è“‰è£èžç†”æº¶å®¹ç»’å†—æ‰æŸ”è‚‰èŒ¹è •å„’å­ºå¦‚è¾±ä¹³æ±å…¥è¤¥è½¯é˜®è•Šç‘žé”é—°æ¶¦è‹¥å¼±æ’’æ´’è¨è…®é³ƒå¡žèµ›ä¸‰å"],["c940","è‘½",4,"è’ƒè’„è’…è’†è’Šè’è’",7,"è’˜è’šè’›è’è’žè’Ÿè’ è’¢",12,"è’°è’±è’³è’µè’¶è’·è’»è’¼è’¾è“€è“‚è“ƒè“…è“†è“‡è“ˆè“‹è“Œè“Žè“è“’è“”è“•è“—"],["c980","è“˜",4,"è“žè“¡è“¢è“¤è“§",4,"è“­è“®è“¯è“±",10,"è“½è“¾è”€è”è”‚ä¼žæ•£æ¡‘å—“ä¸§æ”éªšæ‰«å«‚ç‘Ÿè‰²æ¶©æ£®åƒ§èŽŽç ‚æ€åˆ¹æ²™çº±å‚»å•¥ç…žç­›æ™’çŠè‹«æ‰å±±åˆ ç…½è¡«é—ªé™•æ“…èµ¡è†³å–„æ±•æ‰‡ç¼®å¢’ä¼¤å•†èµæ™Œä¸Šå°šè£³æ¢¢æŽç¨çƒ§èŠå‹ºéŸ¶å°‘å“¨é‚µç»å¥¢èµŠè›‡èˆŒèˆèµ¦æ‘„å°„æ…‘æ¶‰ç¤¾è®¾ç ·ç”³å‘»ä¼¸èº«æ·±å¨ ç»…ç¥žæ²ˆå®¡å©¶ç”šè‚¾æ…Žæ¸—å£°ç”Ÿç”¥ç‰²å‡ç»³"],["ca40","è”ƒ",8,"è”è”Žè”è”è”’è””è”•è”–è”˜è”™è”›è”œè”è”žè” è”¢",8,"è”­",9,"è”¾",4,"è•„è•…è•†è•‡è•‹",10],["ca80","è•—è•˜è•šè•›è•œè•è•Ÿ",4,"è•¥è•¦è•§è•©",8,"è•³è•µè•¶è•·è•¸è•¼è•½è•¿è–€è–çœç››å‰©èƒœåœ£å¸ˆå¤±ç‹®æ–½æ¹¿è¯—å°¸è™±åçŸ³æ‹¾æ—¶ä»€é£Ÿèš€å®žè¯†å²çŸ¢ä½¿å±Žé©¶å§‹å¼ç¤ºå£«ä¸–æŸ¿äº‹æ‹­èª“é€åŠ¿æ˜¯å—œå™¬é€‚ä»•ä¾é‡Šé¥°æ°å¸‚æƒå®¤è§†è¯•æ”¶æ‰‹é¦–å®ˆå¯¿æŽˆå”®å—ç˜¦å…½è”¬æž¢æ¢³æ®ŠæŠ’è¾“å”èˆ’æ·‘ç–ä¹¦èµŽå­°ç†Ÿè–¯æš‘æ›™ç½²èœ€é»é¼ å±žæœ¯è¿°æ ‘æŸæˆç«–å¢…åº¶æ•°æ¼±"],["cb40","è–‚è–ƒè–†è–ˆ",6,"è–",10,"è–",6,"è–¥è–¦è–§è–©è–«è–¬è–­è–±",5,"è–¸è–º",6,"è—‚",6,"è—Š",4,"è—‘è—’"],["cb80","è—”è—–",5,"è—",6,"è—¥è—¦è—§è—¨è—ª",14,"æ•åˆ·è€æ‘”è¡°ç”©å¸…æ “æ‹´éœœåŒçˆ½è°æ°´ç¡ç¨Žå®çž¬é¡ºèˆœè¯´ç¡•æœ”çƒæ–¯æ’•å˜¶æ€ç§å¸ä¸æ­»è‚†å¯ºå—£å››ä¼ºä¼¼é¥²å·³æ¾è€¸æ€‚é¢‚é€å®‹è®¼è¯µæœè‰˜æ“žå—½è‹é…¥ä¿—ç´ é€Ÿç²Ÿåƒ³å¡‘æº¯å®¿è¯‰è‚ƒé…¸è’œç®—è™½éš‹éšç»¥é«“ç¢Žå²ç©—é‚éš§ç¥Ÿå­™æŸç¬‹è“‘æ¢­å”†ç¼©çç´¢é”æ‰€å¡Œä»–å®ƒå¥¹å¡”"],["cc40","è—¹è—ºè—¼è—½è—¾è˜€",4,"è˜†",10,"è˜’è˜“è˜”è˜•è˜—",15,"è˜¨è˜ª",13,"è˜¹è˜ºè˜»è˜½è˜¾è˜¿è™€"],["cc80","è™",11,"è™’è™“è™•",4,"è™›è™œè™è™Ÿè™ è™¡è™£",7,"ç­æŒžè¹‹è¸èƒŽè‹”æŠ¬å°æ³°é…žå¤ªæ€æ±°åæ‘Šè´ªç˜«æ»©å›æª€ç—°æ½­è°­è°ˆå¦æ¯¯è¢’ç¢³æŽ¢å¹ç‚­æ±¤å¡˜æªå ‚æ£ è†›å”ç³–å€˜èººæ·Œè¶Ÿçƒ«æŽæ¶›æ»”ç»¦è„æ¡ƒé€ƒæ·˜é™¶è®¨å¥—ç‰¹è—¤è…¾ç–¼èªŠæ¢¯å‰”è¸¢é”‘æé¢˜è¹„å•¼ä½“æ›¿åšæƒ•æ¶•å‰ƒå±‰å¤©æ·»å¡«ç”°ç”œæ¬èˆ”è…†æŒ‘æ¡è¿¢çœºè·³è´´é“å¸–åŽ…å¬çƒƒ"],["cd40","è™­è™¯è™°è™²",6,"èšƒ",6,"èšŽ",4,"èš”èš–",5,"èšž",4,"èš¥èš¦èš«èš­èš®èš²èš³èš·èš¸èš¹èš»",4,"è›è›‚è›ƒè›…è›ˆè›Œè›è›’è›“è›•è›–è›—è›šè›œ"],["cd80","è›è› è›¡è›¢è›£è›¥è›¦è›§è›¨è›ªè›«è›¬è›¯è›µè›¶è›·è›ºè›»è›¼è›½è›¿èœèœ„èœ…èœ†èœ‹èœŒèœŽèœèœèœ‘èœ”èœ–æ±€å»·åœäº­åº­æŒºè‰‡é€šæ¡é…®çž³åŒé“œå½¤ç«¥æ¡¶æ…ç­’ç»Ÿç—›å·æŠ•å¤´é€å‡¸ç§ƒçªå›¾å¾’é€”æ¶‚å± åœŸåå…”æ¹å›¢æŽ¨é¢“è…¿èœ•è¤ªé€€åžå±¯è‡€æ‹–æ‰˜è„±é¸µé™€é©®é©¼æ¤­å¦¥æ‹“å”¾æŒ–å“‡è›™æ´¼å¨ƒç“¦è¢œæ­ªå¤–è±Œå¼¯æ¹¾çŽ©é¡½ä¸¸çƒ·å®Œç¢—æŒ½æ™šçš–æƒ‹å®›å©‰ä¸‡è…•æ±ªçŽ‹äº¡æž‰ç½‘å¾€æ—ºæœ›å¿˜å¦„å¨"],["ce40","èœ™èœ›èœèœŸèœ èœ¤èœ¦èœ§èœ¨èœªèœ«èœ¬èœ­èœ¯èœ°èœ²èœ³èœµèœ¶èœ¸èœ¹èœºèœ¼èœ½è€",6,"èŠè‹èèèè‘è’è”è•è–è˜èš",5,"è¡è¢è¦",7,"è¯è±è²è³èµ"],["ce80","è·è¸è¹èºè¿èž€èžèž„èž†èž‡èž‰èžŠèžŒèžŽ",4,"èž”èž•èž–èž˜",6,"èž ",4,"å·å¾®å±éŸ¦è¿æ¡…å›´å”¯æƒŸä¸ºæ½ç»´è‹‡èŽå§”ä¼Ÿä¼ªå°¾çº¬æœªè”šå‘³ç•èƒƒå–‚é­ä½æ¸­è°“å°‰æ…°å«ç˜Ÿæ¸©èšŠæ–‡é—»çº¹å»ç¨³ç´Šé—®å—¡ç¿ç“®æŒèœ—æ¶¡çªæˆ‘æ–¡å§æ¡æ²ƒå·«å‘œé’¨ä¹Œæ±¡è¯¬å±‹æ— èŠœæ¢§å¾å´æ¯‹æ­¦äº”æ‚åˆèˆžä¼ä¾®åžæˆŠé›¾æ™¤ç‰©å‹¿åŠ¡æ‚Ÿè¯¯æ˜”ç†™æžè¥¿ç¡’çŸ½æ™°å˜»å¸é”¡ç‰º"],["cf40","èž¥èž¦èž§èž©èžªèž®èž°èž±èž²èž´èž¶èž·èž¸èž¹èž»èž¼èž¾èž¿èŸ",4,"èŸ‡èŸˆèŸ‰èŸŒ",4,"èŸ”",6,"èŸœèŸèŸžèŸŸèŸ¡èŸ¢èŸ£èŸ¤èŸ¦èŸ§èŸ¨èŸ©èŸ«èŸ¬èŸ­èŸ¯",9],["cf80","èŸºèŸ»èŸ¼èŸ½èŸ¿è €è è ‚è „",5,"è ‹",7,"è ”è —è ˜è ™è šè œ",4,"è £ç¨€æ¯å¸Œæ‚‰è†å¤•æƒœç†„çƒ¯æºªæ±çŠ€æª„è¢­å¸­ä¹ åª³å–œé“£æ´—ç³»éš™æˆç»†çžŽè™¾åŒ£éœžè¾–æš‡å³¡ä¾ ç‹­ä¸‹åŽ¦å¤å“æŽ€é”¨å…ˆä»™é²œçº¤å’¸è´¤è¡”èˆ·é—²æ¶Žå¼¦å«Œæ˜¾é™©çŽ°çŒ®åŽ¿è…ºé¦…ç¾¡å®ªé™·é™çº¿ç›¸åŽ¢é•¶é¦™ç®±è¥„æ¹˜ä¹¡ç¿”ç¥¥è¯¦æƒ³å“äº«é¡¹å··æ©¡åƒå‘è±¡è§ç¡éœ„å‰Šå“®åš£é”€æ¶ˆå®µæ·†æ™“"],["d040","è ¤",13,"è ³",5,"è ºè »è ½è ¾è ¿è¡è¡‚è¡ƒè¡†",5,"è¡Ž",5,"è¡•è¡–è¡˜è¡š",6,"è¡¦è¡§è¡ªè¡­è¡¯è¡±è¡³è¡´è¡µè¡¶è¡¸è¡¹è¡º"],["d080","è¡»è¡¼è¢€è¢ƒè¢†è¢‡è¢‰è¢Šè¢Œè¢Žè¢è¢è¢‘è¢“è¢”è¢•è¢—",4,"è¢",4,"è¢£è¢¥",5,"å°å­æ ¡è‚–å•¸ç¬‘æ•ˆæ¥”äº›æ­‡èŽéž‹åæŒŸæºé‚ªæ–œèƒè°å†™æ¢°å¸èŸ¹æ‡ˆæ³„æ³»è°¢å±‘è–ªèŠ¯é”Œæ¬£è¾›æ–°å¿»å¿ƒä¿¡è¡…æ˜Ÿè…¥çŒ©æƒºå…´åˆ‘åž‹å½¢é‚¢è¡Œé†’å¹¸ææ€§å§“å…„å‡¶èƒ¸åŒˆæ±¹é›„ç†Šä¼‘ä¿®ç¾žæœ½å—…é”ˆç§€è¢–ç»£å¢ŸæˆŒéœ€è™šå˜˜é¡»å¾è®¸è“„é…—å™æ—­åºç•œæ¤çµ®å©¿ç»ªç»­è½©å–§å®£æ‚¬æ—‹çŽ„"],["d140","è¢¬è¢®è¢¯è¢°è¢²",4,"è¢¸è¢¹è¢ºè¢»è¢½è¢¾è¢¿è£€è£ƒè£„è£‡è£ˆè£Šè£‹è£Œè£è£è£è£‘è£“è£–è£—è£š",4,"è£ è£¡è£¦è£§è£©",6,"è£²è£µè£¶è£·è£ºè£»è£½è£¿è¤€è¤è¤ƒ",5],["d180","è¤‰è¤‹",4,"è¤‘è¤”",4,"è¤œ",4,"è¤¢è¤£è¤¤è¤¦è¤§è¤¨è¤©è¤¬è¤­è¤®è¤¯è¤±è¤²è¤³è¤µè¤·é€‰ç™£çœ©ç»šé´è–›å­¦ç©´é›ªè¡€å‹‹ç†å¾ªæ—¬è¯¢å¯»é©¯å·¡æ®‰æ±›è®­è®¯é€Šè¿…åŽ‹æŠ¼é¸¦é¸­å‘€ä¸«èŠ½ç‰™èšœå´–è¡™æ¶¯é›…å“‘äºšè®¶ç„‰å’½é˜‰çƒŸæ·¹ç›ä¸¥ç ”èœ’å²©å»¶è¨€é¢œé˜Žç‚Žæ²¿å¥„æŽ©çœ¼è¡æ¼”è‰³å °ç‡•åŽŒç šé›å”å½¦ç„°å®´è°šéªŒæ®ƒå¤®é¸¯ç§§æ¨æ‰¬ä½¯ç–¡ç¾Šæ´‹é˜³æ°§ä»°ç—’å…»æ ·æ¼¾é‚€è…°å¦–ç‘¶"],["d240","è¤¸",8,"è¥‚è¥ƒè¥…",24,"è¥ ",5,"è¥§",19,"è¥¼"],["d280","è¥½è¥¾è¦€è¦‚è¦„è¦…è¦‡",26,"æ‘‡å°§é¥çª‘è°£å§šå’¬èˆ€è¯è¦è€€æ¤°å™Žè€¶çˆ·é‡Žå†¶ä¹Ÿé¡µæŽ–ä¸šå¶æ›³è…‹å¤œæ¶²ä¸€å£¹åŒ»æ–é“±ä¾ä¼Šè¡£é¢å¤·é—ç§»ä»ªèƒ°ç–‘æ²‚å®œå§¨å½æ¤…èšå€šå·²ä¹™çŸ£ä»¥è‰ºæŠ‘æ˜“é‚‘å±¹äº¿å½¹è‡†é€¸è‚„ç–«äº¦è£”æ„æ¯…å¿†ä¹‰ç›Šæº¢è¯£è®®è°Šè¯‘å¼‚ç¿¼ç¿Œç»ŽèŒµè«å› æ®·éŸ³é˜´å§»åŸé“¶æ·«å¯…é¥®å°¹å¼•éš"],["d340","è¦¢",30,"è§ƒè§è§“è§”è§•è§—è§˜è§™è§›è§è§Ÿè§ è§¡è§¢è§¤è§§è§¨è§©è§ªè§¬è§­è§®è§°è§±è§²è§´",6],["d380","è§»",4,"è¨",5,"è¨ˆ",21,"å°è‹±æ¨±å©´é¹°åº”ç¼¨èŽ¹è¤è¥è§è‡è¿Žèµ¢ç›ˆå½±é¢–ç¡¬æ˜ å“Ÿæ‹¥ä½£è‡ƒç—ˆåº¸é›è¸Šè›¹å’æ³³æ¶Œæ°¸æ¿å‹‡ç”¨å¹½ä¼˜æ‚ å¿§å°¤ç”±é‚®é“€çŠ¹æ²¹æ¸¸é…‰æœ‰å‹å³ä½‘é‡‰è¯±åˆå¹¼è¿‚æ·¤äºŽç›‚æ¦†è™žæ„šèˆ†ä½™ä¿žé€¾é±¼æ„‰æ¸æ¸”éš…äºˆå¨±é›¨ä¸Žå±¿ç¦¹å®‡è¯­ç¾½çŽ‰åŸŸèŠ‹éƒåé‡å–»å³ªå¾¡æ„ˆæ¬²ç‹±è‚²èª‰"],["d440","è¨ž",31,"è¨¿",8,"è©‰",21],["d480","è©Ÿ",25,"è©º",6,"æµ´å¯“è£•é¢„è±«é©­é¸³æ¸Šå†¤å…ƒåž£è¢åŽŸæ´è¾•å›­å‘˜åœ†çŒ¿æºç¼˜è¿œè‹‘æ„¿æ€¨é™¢æ›°çº¦è¶Šè·ƒé’¥å²³ç²¤æœˆæ‚¦é˜…è€˜äº‘éƒ§åŒ€é™¨å…è¿è•´é…æ™•éŸµå­•åŒç ¸æ‚æ ½å“‰ç¾å®°è½½å†åœ¨å’±æ”’æš‚èµžèµƒè„è‘¬é­ç³Ÿå‡¿è—»æž£æ—©æ¾¡èš¤èºå™ªé€ çš‚ç¶ç‡¥è´£æ‹©åˆ™æ³½è´¼æ€Žå¢žæ†Žæ›¾èµ æ‰Žå–³æ¸£æœ­è½§"],["d540","èª",7,"èª‹",7,"èª”",46],["d580","è«ƒ",32,"é“¡é—¸çœ¨æ …æ¦¨å’‹ä¹ç‚¸è¯ˆæ‘˜æ–‹å®…çª„å€ºå¯¨çž»æ¯¡è©¹ç²˜æ²¾ç›æ–©è¾—å´­å±•è˜¸æ ˆå æˆ˜ç«™æ¹›ç»½æ¨Ÿç« å½°æ¼³å¼ æŽŒæ¶¨æ–ä¸ˆå¸è´¦ä»—èƒ€ç˜´éšœæ‹›æ˜­æ‰¾æ²¼èµµç…§ç½©å…†è‚‡å¬é®æŠ˜å“²è›°è¾™è€…é”—è”—è¿™æµ™çæ–ŸçœŸç”„ç §è‡»è´žé’ˆä¾¦æž•ç–¹è¯Šéœ‡æŒ¯é•‡é˜µè’¸æŒ£çå¾ç‹°äº‰æ€”æ•´æ‹¯æ­£æ”¿"],["d640","è«¤",34,"è¬ˆ",27],["d680","è¬¤è¬¥è¬§",30,"å¸§ç—‡éƒ‘è¯èŠæžæ”¯å±èœ˜çŸ¥è‚¢è„‚æ±ä¹‹ç»‡èŒç›´æ¤æ®–æ‰§å€¼ä¾„å€æŒ‡æ­¢è¶¾åªæ—¨çº¸å¿—æŒšæŽ·è‡³è‡´ç½®å¸œå³™åˆ¶æ™ºç§©ç¨šè´¨ç‚™ç—”æ»žæ²»çª’ä¸­ç›…å¿ é’Ÿè¡·ç»ˆç§è‚¿é‡ä»²ä¼—èˆŸå‘¨å·žæ´²è¯Œç²¥è½´è‚˜å¸šå’’çš±å®™æ˜¼éª¤ç æ ªè››æœ±çŒªè¯¸è¯›é€ç«¹çƒ›ç…®æ‹„çž©å˜±ä¸»è‘—æŸ±åŠ©è›€è´®é“¸ç­‘"],["d740","è­†",31,"è­§",4,"è­­",25],["d780","è®‡",24,"è®¬è®±è®»è¯‡è¯è¯ªè°‰è°žä½æ³¨ç¥é©»æŠ“çˆªæ‹½ä¸“ç –è½¬æ’°èµšç¯†æ¡©åº„è£…å¦†æ’žå£®çŠ¶æ¤Žé”¥è¿½èµ˜å ç¼€è°†å‡†æ‰æ‹™å“æ¡Œç¢èŒé…Œå•„ç€ç¼æµŠå…¹å’¨èµ„å§¿æ»‹æ·„å­œç´«ä»”ç±½æ»“å­è‡ªæ¸å­—é¬ƒæ£•è¸ªå®—ç»¼æ€»çºµé‚¹èµ°å¥æç§Ÿè¶³å’æ—ç¥–è¯…é˜»ç»„é’»çº‚å˜´é†‰æœ€ç½ªå°Šéµæ˜¨å·¦ä½æŸžåšä½œååº§"],["d840","è°¸",8,"è±‚è±ƒè±„è±…è±ˆè±Šè±‹è±",7,"è±–è±—è±˜è±™è±›",5,"è±£",6,"è±¬",6,"è±´è±µè±¶è±·è±»",6,"è²ƒè²„è²†è²‡"],["d880","è²ˆè²‹è²",6,"è²•è²–è²—è²™",20,"äºä¸Œå…€ä¸å»¿å…ä¸•äº˜ä¸žé¬²å­¬å™©ä¸¨ç¦ºä¸¿åŒ•ä¹‡å¤­çˆ»å®æ°å›Ÿèƒ¤é¦—æ¯“ç¾é¼—ä¸¶äºŸé¼ä¹œä¹©äº“èŠˆå­›å•¬å˜ä»„åŽåŽåŽ£åŽ¥åŽ®é¥èµåŒšåµåŒ¦åŒ®åŒ¾èµœå¦å£åˆ‚åˆˆåˆŽåˆ­åˆ³åˆ¿å‰€å‰Œå‰žå‰¡å‰œè’¯å‰½åŠ‚åŠåŠåŠ“å†‚ç½”äº»ä»ƒä»‰ä»‚ä»¨ä»¡ä»«ä»žä¼›ä»³ä¼¢ä½¤ä»µä¼¥ä¼§ä¼‰ä¼«ä½žä½§æ”¸ä½šä½"],["d940","è²®",62],["d980","è³­",32,"ä½Ÿä½—ä¼²ä¼½ä½¶ä½´ä¾‘ä¾‰ä¾ƒä¾ä½¾ä½»ä¾ªä½¼ä¾¬ä¾”ä¿¦ä¿¨ä¿ªä¿…ä¿šä¿£ä¿œä¿‘ä¿Ÿä¿¸å€©åŒä¿³å€¬å€å€®å€­ä¿¾å€œå€Œå€¥å€¨å¾åƒå•åˆåŽå¬å»å‚¥å‚§å‚©å‚ºåƒ–å„†åƒ­åƒ¬åƒ¦åƒ®å„‡å„‹ä»æ°½ä½˜ä½¥ä¿Žé¾ æ±†ç±´å…®å·½é»‰é¦˜å†å¤”å‹¹åŒè¨‡åŒå‡«å¤™å…•äº å…–äº³è¡®è¢¤äºµè„”è£’ç¦€å¬´è ƒç¾¸å†«å†±å†½å†¼"],["da40","è´Ž",14,"è´ èµ‘èµ’èµ—èµŸèµ¥èµ¨èµ©èµªèµ¬èµ®èµ¯èµ±èµ²èµ¸",8,"è¶‚è¶ƒè¶†è¶‡è¶ˆè¶‰è¶Œ",4,"è¶’è¶“è¶•",9,"è¶ è¶¡"],["da80","è¶¢è¶¤",12,"è¶²è¶¶è¶·è¶¹è¶»è¶½è·€è·è·‚è·…è·‡è·ˆè·‰è·Šè·è·è·’è·“è·”å‡‡å†–å†¢å†¥è® è®¦è®§è®ªè®´è®µè®·è¯‚è¯ƒè¯‹è¯è¯Žè¯’è¯“è¯”è¯–è¯˜è¯™è¯œè¯Ÿè¯ è¯¤è¯¨è¯©è¯®è¯°è¯³è¯¶è¯¹è¯¼è¯¿è°€è°‚è°„è°‡è°Œè°è°‘è°’è°”è°•è°–è°™è°›è°˜è°è°Ÿè° è°¡è°¥è°§è°ªè°«è°®è°¯è°²è°³è°µè°¶å©åºé˜é˜¢é˜¡é˜±é˜ªé˜½é˜¼é™‚é™‰é™”é™Ÿé™§é™¬é™²é™´éšˆéšéš—éš°é‚—é‚›é‚é‚™é‚¬é‚¡é‚´é‚³é‚¶é‚º"],["db40","è·•è·˜è·™è·œè· è·¡è·¢è·¥è·¦è·§è·©è·­è·®è·°è·±è·²è·´è·¶è·¼è·¾",6,"è¸†è¸‡è¸ˆè¸‹è¸è¸Žè¸è¸‘è¸’è¸“è¸•",7,"è¸ è¸¡è¸¤",4,"è¸«è¸­è¸°è¸²è¸³è¸´è¸¶è¸·è¸¸è¸»è¸¼è¸¾"],["db80","è¸¿è¹ƒè¹…è¹†è¹Œ",4,"è¹“",5,"è¹š",11,"è¹§è¹¨è¹ªè¹«è¹®è¹±é‚¸é‚°éƒéƒ…é‚¾éƒéƒ„éƒ‡éƒ“éƒ¦éƒ¢éƒœéƒ—éƒ›éƒ«éƒ¯éƒ¾é„„é„¢é„žé„£é„±é„¯é„¹é…ƒé…†åˆå¥‚åŠ¢åŠ¬åŠ­åŠ¾å“¿å‹å‹–å‹°åŸç‡®çŸå»´å‡µå‡¼é¬¯åŽ¶å¼ç•šå·¯åŒåž©åž¡å¡¾å¢¼å£…å£‘åœ©åœ¬åœªåœ³åœ¹åœ®åœ¯åœåœ»å‚å©åž…å«åž†å¼å»å¨å­å¶å³åž­åž¤åžŒåž²åŸåž§åž´åž“åž åŸ•åŸ˜åŸšåŸ™åŸ’åž¸åŸ´åŸ¯åŸ¸åŸ¤åŸ"],["dc40","è¹³è¹µè¹·",4,"è¹½è¹¾èº€èº‚èºƒèº„èº†èºˆ",6,"èº‘èº’èº“èº•",6,"èºèºŸ",11,"èº­èº®èº°èº±èº³",6,"èº»",7],["dc80","è»ƒ",10,"è»",21,"å ‹å åŸ½åŸ­å €å žå ™å¡„å  å¡¥å¡¬å¢å¢‰å¢šå¢€é¦¨é¼™æ‡¿è‰¹è‰½è‰¿èŠèŠŠèŠ¨èŠ„èŠŽèŠ‘èŠ—èŠ™èŠ«èŠ¸èŠ¾èŠ°è‹ˆè‹Šè‹£èŠ˜èŠ·èŠ®è‹‹è‹Œè‹èŠ©èŠ´èŠ¡èŠªèŠŸè‹„è‹ŽèŠ¤è‹¡èŒ‰è‹·è‹¤èŒèŒ‡è‹œè‹´è‹’è‹˜èŒŒè‹»è‹“èŒ‘èŒšèŒ†èŒ”èŒ•è‹ è‹•èŒœè‘è›èœèŒˆèŽ’èŒ¼èŒ´èŒ±èŽ›èžèŒ¯èè‡èƒèŸè€èŒ—è èŒ­èŒºèŒ³è¦è¥"],["dd40","è»¥",62],["dd80","è¼¤",32,"è¨èŒ›è©è¬èªè­è®èŽ°è¸èŽ³èŽ´èŽ èŽªèŽ“èŽœèŽ…è¼èŽ¶èŽ©è½èŽ¸è»èŽ˜èŽžèŽ¨èŽºèŽ¼èèè¥è˜å ‡è˜è‹èè½è–èœè¸è‘è†è”èŸèèƒè¸è¹èªè…è€è¦è°è¡è‘œè‘‘è‘šè‘™è‘³è’‡è’ˆè‘ºè’‰è‘¸è¼è‘†è‘©è‘¶è’Œè’Žè±è‘­è“è“è“è“¦è’½è““è“Šè’¿è’ºè“ è’¡è’¹è’´è’—è“¥è“£è”Œç”è”¸è“°è”¹è”Ÿè”º"],["de40","è½…",32,"è½ªè¾€è¾Œè¾’è¾è¾ è¾¡è¾¢è¾¤è¾¥è¾¦è¾§è¾ªè¾¬è¾­è¾®è¾¯è¾²è¾³è¾´è¾µè¾·è¾¸è¾ºè¾»è¾¼è¾¿è¿€è¿ƒè¿†"],["de80","è¿‰",4,"è¿è¿’è¿–è¿—è¿šè¿ è¿¡è¿£è¿§è¿¬è¿¯è¿±è¿²è¿´è¿µè¿¶è¿ºè¿»è¿¼è¿¾è¿¿é€‡é€ˆé€Œé€Žé€“é€•é€˜è•–è”»è“¿è“¼è•™è•ˆè•¨è•¤è•žè•ºçž¢è•ƒè•²è•»è–¤è–¨è–‡è–è•¹è–®è–œè–…è–¹è–·è–°è—“è—è—œè—¿è˜§è˜…è˜©è˜–è˜¼å»¾å¼ˆå¤¼å¥è€·å¥•å¥šå¥˜åŒå°¢å°¥å°¬å°´æ‰Œæ‰ªæŠŸæŠ»æ‹Šæ‹šæ‹—æ‹®æŒ¢æ‹¶æŒ¹æ‹æƒæŽ­æ¶æ±æºæŽŽæŽ´æ­æŽ¬æŽŠæ©æŽ®æŽ¼æ²æ¸æ æ¿æ„æžæŽæ‘’æ†æŽ¾æ‘…æ‘æ‹æ›æ æŒæ¦æ¡æ‘žæ’„æ‘­æ’–"],["df40","é€™é€œé€£é€¤é€¥é€§",5,"é€°",4,"é€·é€¹é€ºé€½é€¿é€éƒé…é†éˆ",4,"éŽé”é•é–é™éšéœ",5,"é¤é¦é§é©éªé«é¬é¯",4,"é¶",6,"é¾é‚"],["df80","é‚„é‚…é‚†é‚‡é‚‰é‚Šé‚Œ",4,"é‚’é‚”é‚–é‚˜é‚šé‚œé‚žé‚Ÿé‚ é‚¤é‚¥é‚§é‚¨é‚©é‚«é‚­é‚²é‚·é‚¼é‚½é‚¿éƒ€æ‘ºæ’·æ’¸æ’™æ’ºæ“€æ“æ“—æ“¤æ“¢æ”‰æ”¥æ”®å¼‹å¿’ç”™å¼‘åŸå±å½å©å¨å»å’å–å†å‘‹å‘’å‘“å‘”å‘–å‘ƒå¡å‘—å‘™å£å²å’‚å’”å‘·å‘±å‘¤å’šå’›å’„å‘¶å‘¦å’å“å’­å“‚å’´å“’å’§å’¦å““å“”å‘²å’£å“•å’»å’¿å“Œå“™å“šå“œå’©å’ªå’¤å“å“å“žå”›å“§å” å“½å””å“³å”¢å”£å”å”‘å”§å”ªå•§å–å–µå•‰å•­å•å••å”¿å•å”¼"],["e040","éƒ‚éƒƒéƒ†éƒˆéƒ‰éƒ‹éƒŒéƒéƒ’éƒ”éƒ•éƒ–éƒ˜éƒ™éƒšéƒžéƒŸéƒ éƒ£éƒ¤éƒ¥éƒ©éƒªéƒ¬éƒ®éƒ°éƒ±éƒ²éƒ³éƒµéƒ¶éƒ·éƒ¹éƒºéƒ»éƒ¼éƒ¿é„€é„é„ƒé„…",19,"é„šé„›é„œ"],["e080","é„é„Ÿé„ é„¡é„¤",10,"é„°é„²",6,"é„º",8,"é…„å”·å•–å•µå•¶å•·å”³å”°å•œå–‹å—’å–ƒå–±å–¹å–ˆå–å–Ÿå•¾å—–å–‘å•»å—Ÿå–½å–¾å–”å–™å—ªå—·å—‰å˜Ÿå—‘å—«å—¬å—”å—¦å—å—„å—¯å—¥å—²å—³å—Œå—å—¨å—µå—¤è¾”å˜žå˜ˆå˜Œå˜å˜¤å˜£å—¾å˜€å˜§å˜­å™˜å˜¹å™—å˜¬å™å™¢å™™å™œå™Œå™”åš†å™¤å™±å™«å™»å™¼åš…åš“åš¯å›”å›—å›å›¡å›µå›«å›¹å›¿åœ„åœŠåœ‰åœœå¸å¸™å¸”å¸‘å¸±å¸»å¸¼"],["e140","é……é…‡é…ˆé…‘é…“é…”é…•é…–é…˜é…™é…›é…œé…Ÿé… é…¦é…§é…¨é…«é…­é…³é…ºé…»é…¼é†€",4,"é††é†ˆé†Šé†Žé†é†“",6,"é†œ",5,"é†¤",5,"é†«é†¬é†°é†±é†²é†³é†¶é†·é†¸é†¹é†»"],["e180","é†¼",10,"é‡ˆé‡‹é‡é‡’",9,"é‡",8,"å¸·å¹„å¹”å¹›å¹žå¹¡å²Œå±ºå²å²å²–å²ˆå²˜å²™å²‘å²šå²œå²µå²¢å²½å²¬å²«å²±å²£å³å²·å³„å³’å³¤å³‹å³¥å´‚å´ƒå´§å´¦å´®å´¤å´žå´†å´›åµ˜å´¾å´´å´½åµ¬åµ›åµ¯åµåµ«åµ‹åµŠåµ©åµ´å¶‚å¶™å¶è±³å¶·å·…å½³å½·å¾‚å¾‡å¾‰å¾Œå¾•å¾™å¾œå¾¨å¾­å¾µå¾¼è¡¢å½¡çŠ­çŠ°çŠ´çŠ·çŠ¸ç‹ƒç‹ç‹Žç‹ç‹’ç‹¨ç‹¯ç‹©ç‹²ç‹´ç‹·çŒç‹³çŒƒç‹º"],["e240","é‡¦",62],["e280","éˆ¥",32,"ç‹»çŒ—çŒ“çŒ¡çŒŠçŒžçŒçŒ•çŒ¢çŒ¹çŒ¥çŒ¬çŒ¸çŒ±ççç—ç ç¬ç¯ç¾èˆ›å¤¥é£§å¤¤å¤‚é¥£é¥§",5,"é¥´é¥·é¥½é¦€é¦„é¦‡é¦Šé¦é¦é¦‘é¦“é¦”é¦•åº€åº‘åº‹åº–åº¥åº åº¹åºµåº¾åº³èµ“å»’å»‘å»›å»¨å»ªè†ºå¿„å¿‰å¿–å¿æ€ƒå¿®æ€„å¿¡å¿¤å¿¾æ€…æ€†å¿ªå¿­å¿¸æ€™æ€µæ€¦æ€›æ€æ€æ€©æ€«æ€Šæ€¿æ€¡æ¸æ¹æ»æºæ‚"],["e340","é‰†",45,"é‰µ",16],["e380","éŠ†",7,"éŠ",24,"æªæ½æ‚–æ‚šæ‚­æ‚æ‚ƒæ‚’æ‚Œæ‚›æƒ¬æ‚»æ‚±æƒæƒ˜æƒ†æƒšæ‚´æ„ æ„¦æ„•æ„£æƒ´æ„€æ„Žæ„«æ…Šæ…µæ†¬æ†”æ†§æ†·æ‡”æ‡µå¿éš³é—©é—«é—±é—³é—µé—¶é—¼é—¾é˜ƒé˜„é˜†é˜ˆé˜Šé˜‹é˜Œé˜é˜é˜’é˜•é˜–é˜—é˜™é˜šä¸¬çˆ¿æˆ•æ°µæ±”æ±œæ±Šæ²£æ²…æ²æ²”æ²Œæ±¨æ±©æ±´æ±¶æ²†æ²©æ³æ³”æ²­æ³·æ³¸æ³±æ³—æ²²æ³ æ³–æ³ºæ³«æ³®æ²±æ³“æ³¯æ³¾"],["e440","éŠ¨",5,"éŠ¯",24,"é‹‰",31],["e480","é‹©",32,"æ´¹æ´§æ´Œæµƒæµˆæ´‡æ´„æ´™æ´Žæ´«æµæ´®æ´µæ´šæµæµ’æµ”æ´³æ¶‘æµ¯æ¶žæ¶ æµžæ¶“æ¶”æµœæµ æµ¼æµ£æ¸šæ·‡æ·…æ·žæ¸Žæ¶¿æ· æ¸‘æ·¦æ·æ·™æ¸–æ¶«æ¸Œæ¶®æ¸«æ¹®æ¹Žæ¹«æº²æ¹Ÿæº†æ¹“æ¹”æ¸²æ¸¥æ¹„æ»Ÿæº±æº˜æ» æ¼­æ»¢æº¥æº§æº½æº»æº·æ»—æº´æ»æºæ»‚æºŸæ½¢æ½†æ½‡æ¼¤æ¼•æ»¹æ¼¯æ¼¶æ½‹æ½´æ¼ªæ¼‰æ¼©æ¾‰æ¾æ¾Œæ½¸æ½²æ½¼æ½ºæ¿‘"],["e540","éŒŠ",51,"éŒ¿",10],["e580","éŠ",31,"é«æ¿‰æ¾§æ¾¹æ¾¶æ¿‚æ¿¡æ¿®æ¿žæ¿ æ¿¯ç€šç€£ç€›ç€¹ç€µççžå®€å®„å®•å®“å®¥å®¸ç”¯éªžæ´å¯¤å¯®è¤°å¯°è¹‡è¬‡è¾¶è¿“è¿•è¿¥è¿®è¿¤è¿©è¿¦è¿³è¿¨é€…é€„é€‹é€¦é€‘é€é€–é€¡é€µé€¶é€­é€¯é„é‘é’éé¨é˜é¢é›æš¹é´é½é‚‚é‚ˆé‚ƒé‚‹å½å½—å½–å½˜å°»å’«å±å±™å­±å±£å±¦ç¾¼å¼ªå¼©å¼­è‰´å¼¼é¬»å±®å¦å¦ƒå¦å¦©å¦ªå¦£"],["e640","é¬",34,"éŽ",27],["e680","éŽ¬",29,"é‹éŒéå¦—å§Šå¦«å¦žå¦¤å§’å¦²å¦¯å§—å¦¾å¨…å¨†å§å¨ˆå§£å§˜å§¹å¨Œå¨‰å¨²å¨´å¨‘å¨£å¨“å©€å©§å©Šå©•å¨¼å©¢å©µèƒ¬åªªåª›å©·å©ºåª¾å««åª²å«’å«”åª¸å« å«£å«±å«–å«¦å«˜å«œå¬‰å¬—å¬–å¬²å¬·å­€å°•å°œå­šå­¥å­³å­‘å­“å­¢é©µé©·é©¸é©ºé©¿é©½éª€éªéª…éªˆéªŠéªéª’éª“éª–éª˜éª›éªœéªéªŸéª éª¢éª£éª¥éª§çºŸçº¡çº£çº¥çº¨çº©"],["e740","éŽ",7,"é—",54],["e780","éŽ",32,"çº­çº°çº¾ç»€ç»ç»‚ç»‰ç»‹ç»Œç»ç»”ç»—ç»›ç» ç»¡ç»¨ç»«ç»®ç»¯ç»±ç»²ç¼ç»¶ç»ºç»»ç»¾ç¼ç¼‚ç¼ƒç¼‡ç¼ˆç¼‹ç¼Œç¼ç¼‘ç¼’ç¼—ç¼™ç¼œç¼›ç¼Ÿç¼¡",6,"ç¼ªç¼«ç¼¬ç¼­ç¼¯",4,"ç¼µå¹ºç•¿å·›ç”¾é‚•çŽŽçŽ‘çŽ®çŽ¢çŽŸçç‚ç‘çŽ·çŽ³ç€ç‰çˆç¥ç™é¡¼çŠç©ç§çžçŽºç²ççªç‘›ç¦ç¥ç¨ç°ç®ç¬"],["e840","é¯",14,"é¿",43,"é‘¬é‘­é‘®é‘¯"],["e880","é‘°",20,"é’‘é’–é’˜é“‡é“é““é“”é“šé“¦é“»é”œé” ç›çšç‘ç‘œç‘—ç‘•ç‘™ç‘·ç‘­ç‘¾ç’œç’Žç’€ç’ç’‡ç’‹ç’žç’¨ç’©ç’ç’§ç“’ç’ºéŸªéŸ«éŸ¬æŒæ“æžæˆæ©æž¥æž‡æªæ³æž˜æž§æµæž¨æžžæž­æž‹æ·æ¼æŸ°æ ‰æŸ˜æ ŠæŸ©æž°æ ŒæŸ™æžµæŸšæž³æŸæ €æŸƒæž¸æŸ¢æ ŽæŸæŸ½æ ²æ ³æ¡ æ¡¡æ¡Žæ¡¢æ¡„æ¡¤æ¢ƒæ æ¡•æ¡¦æ¡æ¡§æ¡€æ ¾æ¡Šæ¡‰æ ©æ¢µæ¢æ¡´æ¡·æ¢“æ¡«æ£‚æ¥®æ£¼æ¤Ÿæ¤ æ£¹"],["e940","é”§é”³é”½é•ƒé•ˆé•‹é••é•šé• é•®é•´é•µé•·",7,"é–€",42],["e980","é–«",32,"æ¤¤æ£°æ¤‹æ¤æ¥—æ££æ¤æ¥±æ¤¹æ¥ æ¥‚æ¥æ¦„æ¥«æ¦€æ¦˜æ¥¸æ¤´æ§Œæ¦‡æ¦ˆæ§Žæ¦‰æ¥¦æ¥£æ¥¹æ¦›æ¦§æ¦»æ¦«æ¦­æ§”æ¦±æ§æ§Šæ§Ÿæ¦•æ§ æ¦æ§¿æ¨¯æ§­æ¨—æ¨˜æ©¥æ§²æ©„æ¨¾æª æ©æ©›æ¨µæªŽæ©¹æ¨½æ¨¨æ©˜æ©¼æª‘æªæª©æª—æª«çŒ·ç’æ®æ®‚æ®‡æ®„æ®’æ®“æ®æ®šæ®›æ®¡æ®ªè½«è½­è½±è½²è½³è½µè½¶è½¸è½·è½¹è½ºè½¼è½¾è¾è¾‚è¾„è¾‡è¾‹"],["ea40","é—Œ",27,"é—¬é—¿é˜‡é˜“é˜˜é˜›é˜žé˜ é˜£",6,"é˜«é˜¬é˜­é˜¯é˜°é˜·é˜¸é˜¹é˜ºé˜¾é™é™ƒé™Šé™Žé™é™‘é™’é™“é™–é™—"],["ea80","é™˜é™™é™šé™œé™é™žé™ é™£é™¥é™¦é™«é™­",4,"é™³é™¸",12,"éš‡éš‰éšŠè¾è¾Žè¾è¾˜è¾šè»Žæˆ‹æˆ—æˆ›æˆŸæˆ¢æˆ¡æˆ¥æˆ¤æˆ¬è‡§ç“¯ç“´ç“¿ç”ç”‘ç”“æ”´æ—®æ—¯æ—°æ˜Šæ˜™æ²æ˜ƒæ˜•æ˜€ç‚…æ›·æ˜æ˜´æ˜±æ˜¶æ˜µè€†æ™Ÿæ™”æ™æ™æ™–æ™¡æ™—æ™·æš„æšŒæš§æšæš¾æ››æ›œæ›¦æ›©è´²è´³è´¶è´»è´½èµ€èµ…èµ†èµˆèµ‰èµ‡èµèµ•èµ™è§‡è§Šè§‹è§Œè§Žè§è§è§‘ç‰®çŠŸç‰ç‰¦ç‰¯ç‰¾ç‰¿çŠ„çŠ‹çŠçŠçŠ’æŒˆæŒ²æŽ°"],["eb40","éšŒéšŽéš‘éš’éš“éš•éš–éššéš›éš",9,"éš¨",7,"éš±éš²éš´éšµéš·éš¸éšºéš»éš¿é›‚é›ƒé›ˆé›Šé›‹é›é›‘é›“é›”é›–",9,"é›¡",6,"é›«"],["eb80","é›¬é›­é›®é›°é›±é›²é›´é›µé›¸é›ºé›»é›¼é›½é›¿éœ‚éœƒéœ…éœŠéœ‹éœŒéœéœ‘éœ’éœ”éœ•éœ—",4,"éœéœŸéœ æ¿æ“˜è€„æ¯ªæ¯³æ¯½æ¯µæ¯¹æ°…æ°‡æ°†æ°æ°•æ°˜æ°™æ°šæ°¡æ°©æ°¤æ°ªæ°²æ”µæ••æ•«ç‰ç‰’ç‰–çˆ°è™¢åˆ–è‚Ÿè‚œè‚“è‚¼æœŠè‚½è‚±è‚«è‚­è‚´è‚·èƒ§èƒ¨èƒ©èƒªèƒ›èƒ‚èƒ„èƒ™èƒèƒ—æœèƒèƒ«èƒ±èƒ´èƒ­è„è„Žèƒ²èƒ¼æœ•è„’è±šè„¶è„žè„¬è„˜è„²è…ˆè…Œè…“è…´è…™è…šè…±è… è…©è…¼è…½è…­è…§å¡åªµè†ˆè†‚è†‘æ»•è†£è†ªè‡Œæœ¦è‡Šè†»"],["ec40","éœ¡",8,"éœ«éœ¬éœ®éœ¯éœ±éœ³",4,"éœºéœ»éœ¼éœ½éœ¿",18,"é”é•é—é˜éšéœééŸé£é¤é¦é§é¨éª",7],["ec80","é²éµé·",4,"é½",7,"éž†",4,"éžŒéžŽéžéžéž“éž•éž–éž—éž™",4,"è‡è†¦æ¬¤æ¬·æ¬¹æ­ƒæ­†æ­™é£‘é£’é£“é£•é£™é£šæ®³å½€æ¯‚è§³æ–é½‘æ–“æ–¼æ—†æ—„æ—ƒæ—Œæ—Žæ—’æ—–ç‚€ç‚œç‚–ç‚ç‚»çƒ€ç‚·ç‚«ç‚±çƒ¨çƒŠç„ç„“ç„–ç„¯ç„±ç…³ç…œç…¨ç……ç…²ç…Šç…¸ç…ºç†˜ç†³ç†µç†¨ç† ç‡ ç‡”ç‡§ç‡¹çˆçˆ¨ç¬ç„˜ç…¦ç†¹æˆ¾æˆ½æ‰ƒæ‰ˆæ‰‰ç¤»ç¥€ç¥†ç¥‰ç¥›ç¥œç¥“ç¥šç¥¢ç¥—ç¥ ç¥¯ç¥§ç¥ºç¦…ç¦Šç¦šç¦§ç¦³å¿‘å¿"],["ed40","éžžéžŸéž¡éž¢éž¤",6,"éž¬éž®éž°éž±éž³éžµ",46],["ed80","éŸ¤éŸ¥éŸ¨éŸ®",4,"éŸ´éŸ·",23,"æ€¼ææšæ§ææ™æ£æ‚«æ„†æ„æ…æ†©æ†æ‡‹æ‡‘æˆ†è‚€è¿æ²“æ³¶æ·¼çŸ¶çŸ¸ç €ç ‰ç —ç ˜ç ‘æ–«ç ­ç œç ç ¹ç ºç »ç Ÿç ¼ç ¥ç ¬ç £ç ©ç¡Žç¡­ç¡–ç¡—ç ¦ç¡ç¡‡ç¡Œç¡ªç¢›ç¢“ç¢šç¢‡ç¢œç¢¡ç¢£ç¢²ç¢¹ç¢¥ç£”ç£™ç£‰ç£¬ç£²ç¤…ç£´ç¤“ç¤¤ç¤žç¤´é¾›é»¹é»»é»¼ç›±çœ„çœç›¹çœ‡çœˆçœšçœ¢çœ™çœ­çœ¦çœµçœ¸çç‘ç‡çƒçšç¨"],["ee40","é ",62],["ee80","é¡Ž",32,"ç¢ç¥ç¿çžç½çž€çžŒçž‘çžŸçž çž°çžµçž½ç”ºç•€ç•Žç•‹ç•ˆç•›ç•²ç•¹ç–ƒç½˜ç½¡ç½Ÿè©ˆç½¨ç½´ç½±ç½¹ç¾ç½¾ç›ç›¥è ²é’…é’†é’‡é’‹é’Šé’Œé’é’é’é’”é’—é’•é’šé’›é’œé’£é’¤é’«é’ªé’­é’¬é’¯é’°é’²é’´é’¶",4,"é’¼é’½é’¿é“„é“ˆ",6,"é“é“‘é“’é“•é“–é“—é“™é“˜é“›é“žé“Ÿé“ é“¢é“¤é“¥é“§é“¨é“ª"],["ef40","é¡¯",5,"é¢‹é¢Žé¢’é¢•é¢™é¢£é¢¨",37,"é£é£é£”é£–é£—é£›é£œé£é£ ",4],["ef80","é£¥é£¦é£©",30,"é“©é“«é“®é“¯é“³é“´é“µé“·é“¹é“¼é“½é“¿é”ƒé”‚é”†é”‡é”‰é”Šé”é”Žé”é”’",4,"é”˜é”›é”é”žé”Ÿé”¢é”ªé”«é”©é”¬é”±é”²é”´é”¶é”·é”¸é”¼é”¾é”¿é•‚é”µé•„é•…é•†é•‰é•Œé•Žé•é•’é•“é•”é•–é•—é•˜é•™é•›é•žé•Ÿé•é•¡é•¢é•¤",8,"é•¯é•±é•²é•³é”ºçŸ§çŸ¬é›‰ç§•ç§­ç§£ç§«ç¨†åµ‡ç¨ƒç¨‚ç¨žç¨”"],["f040","é¤ˆ",4,"é¤Žé¤é¤‘",28,"é¤¯",26],["f080","é¥Š",9,"é¥–",12,"é¥¤é¥¦é¥³é¥¸é¥¹é¥»é¥¾é¦‚é¦ƒé¦‰ç¨¹ç¨·ç©‘é»é¦¥ç©°çšˆçšŽçš“çš™çš¤ç“žç“ ç”¬é¸ é¸¢é¸¨",4,"é¸²é¸±é¸¶é¸¸é¸·é¸¹é¸ºé¸¾é¹é¹‚é¹„é¹†é¹‡é¹ˆé¹‰é¹‹é¹Œé¹Žé¹‘é¹•é¹—é¹šé¹›é¹œé¹žé¹£é¹¦",6,"é¹±é¹­é¹³ç–’ç–”ç––ç– ç–ç–¬ç–£ç–³ç–´ç–¸ç—„ç–±ç–°ç—ƒç—‚ç—–ç—ç—£ç—¨ç—¦ç—¤ç—«ç—§ç˜ƒç—±ç—¼ç—¿ç˜ç˜€ç˜…ç˜Œç˜—ç˜Šç˜¥ç˜˜ç˜•ç˜™"],["f140","é¦Œé¦Žé¦š",10,"é¦¦é¦§é¦©",47],["f180","é§™",32,"ç˜›ç˜¼ç˜¢ç˜ ç™€ç˜­ç˜°ç˜¿ç˜µç™ƒç˜¾ç˜³ç™ç™žç™”ç™œç™–ç™«ç™¯ç¿Šç«¦ç©¸ç©¹çª€çª†çªˆçª•çª¦çª çª¬çª¨çª­çª³è¡¤è¡©è¡²è¡½è¡¿è¢‚è¢¢è£†è¢·è¢¼è£‰è£¢è£Žè££è£¥è£±è¤šè£¼è£¨è£¾è£°è¤¡è¤™è¤“è¤›è¤Šè¤´è¤«è¤¶è¥è¥¦è¥»ç–‹èƒ¥çš²çš´çŸœè€’è€”è€–è€œè€ è€¢è€¥è€¦è€§è€©è€¨è€±è€‹è€µèƒè†èè’è©è±è¦ƒé¡¸é¢€é¢ƒ"],["f240","é§º",62],["f280","é¨¹",32,"é¢‰é¢Œé¢é¢é¢”é¢šé¢›é¢žé¢Ÿé¢¡é¢¢é¢¥é¢¦è™è™”è™¬è™®è™¿è™ºè™¼è™»èš¨èšèš‹èš¬èšèš§èš£èšªèš“èš©èš¶è›„èšµè›Žèš°èšºèš±èš¯è›‰è›èš´è›©è›±è›²è›­è›³è›èœ“è›žè›´è›Ÿè›˜è›‘èœƒèœ‡è›¸èœˆèœŠèœèœ‰èœ£èœ»èœžèœ¥èœ®èœšèœ¾èˆèœ´èœ±èœ©èœ·èœ¿èž‚èœ¢è½è¾è»è è°èŒè®èž‹è“è£è¼è¤è™è¥èž“èž¯èž¨èŸ’"],["f340","é©š",17,"é©²éªƒéª‰éªéªŽéª”éª•éª™éª¦éª©",6,"éª²éª³éª´éªµéª¹éª»éª½éª¾éª¿é«ƒé«„é«†",4,"é«é«Žé«é«é«’é«”é«•é«–é«—é«™é«šé«›é«œ"],["f380","é«é«žé« é«¢é«£é«¤é«¥é«§é«¨é«©é«ªé«¬é«®é«°",8,"é«ºé«¼",6,"é¬„é¬…é¬†èŸ†èžˆèž…èž­èž—èžƒèž«èŸ¥èž¬èžµèž³èŸ‹èŸ“èž½èŸ‘èŸ€èŸŠèŸ›èŸªèŸ èŸ®è –è “èŸ¾è Šè ›è ¡è ¹è ¼ç¼¶ç½‚ç½„ç½…èˆç«ºç«½ç¬ˆç¬ƒç¬„ç¬•ç¬Šç¬«ç¬ç­‡ç¬¸ç¬ªç¬™ç¬®ç¬±ç¬ ç¬¥ç¬¤ç¬³ç¬¾ç¬žç­˜ç­šç­…ç­µç­Œç­ç­ ç­®ç­»ç­¢ç­²ç­±ç®ç®¦ç®§ç®¸ç®¬ç®ç®¨ç®…ç®ªç®œç®¢ç®«ç®´ç¯‘ç¯ç¯Œç¯ç¯šç¯¥ç¯¦ç¯ªç°Œç¯¾ç¯¼ç°ç°–ç°‹"],["f440","é¬‡é¬‰",5,"é¬é¬‘é¬’é¬”",10,"é¬ é¬¡é¬¢é¬¤",10,"é¬°é¬±é¬³",7,"é¬½é¬¾é¬¿é­€é­†é­Šé­‹é­Œé­Žé­é­’é­“é­•",5],["f480","é­›",32,"ç°Ÿç°ªç°¦ç°¸ç±ç±€è‡¾èˆèˆ‚èˆ„è‡¬è¡„èˆ¡èˆ¢èˆ£èˆ­èˆ¯èˆ¨èˆ«èˆ¸èˆ»èˆ³èˆ´èˆ¾è‰„è‰‰è‰‹è‰è‰šè‰Ÿè‰¨è¡¾è¢…è¢ˆè£˜è£Ÿè¥žç¾ç¾Ÿç¾§ç¾¯ç¾°ç¾²ç±¼æ•‰ç²‘ç²ç²œç²žç²¢ç²²ç²¼ç²½ç³ç³‡ç³Œç³ç³ˆç³…ç³—ç³¨è‰®æš¨ç¾¿ç¿Žç¿•ç¿¥ç¿¡ç¿¦ç¿©ç¿®ç¿³ç³¸çµ·ç¶¦ç¶®ç¹‡çº›éº¸éº´èµ³è¶„è¶”è¶‘è¶±èµ§èµ­è±‡è±‰é…Šé…é…Žé…é…¤"],["f540","é­¼",62],["f580","é®»",32,"é…¢é…¡é…°é…©é…¯é…½é…¾é…²é…´é…¹é†Œé†…é†é†é†‘é†¢é†£é†ªé†­é†®é†¯é†µé†´é†ºè±•é¹¾è¶¸è·«è¸…è¹™è¹©è¶µè¶¿è¶¼è¶ºè·„è·–è·—è·šè·žè·Žè·è·›è·†è·¬è··è·¸è·£è·¹è·»è·¤è¸‰è·½è¸”è¸è¸Ÿè¸¬è¸®è¸£è¸¯è¸ºè¹€è¸¹è¸µè¸½è¸±è¹‰è¹è¹‚è¹‘è¹’è¹Šè¹°è¹¶è¹¼è¹¯è¹´èº…èºèº”èºèºœèºžè±¸è²‚è²Šè²…è²˜è²”æ–›è§–è§žè§šè§œ"],["f640","é¯œ",62],["f680","é°›",32,"è§¥è§«è§¯è¨¾è¬¦é“é›©é›³é›¯éœ†éœéœˆéœéœŽéœªéœ­éœ°éœ¾é¾€é¾ƒé¾…",5,"é¾Œé»¾é¼‹é¼éš¹éš¼éš½é›Žé›’çž¿é› éŠŽéŠ®é‹ˆéŒ¾éªéŠéŽé¾é‘«é±¿é²‚é²…é²†é²‡é²ˆç¨£é²‹é²Žé²é²‘é²’é²”é²•é²šé²›é²ž",5,"é²¥",4,"é²«é²­é²®é²°",7,"é²ºé²»é²¼é²½é³„é³…é³†é³‡é³Šé³‹"],["f740","é°¼",62],["f780","é±»é±½é±¾é²€é²ƒé²„é²‰é²Šé²Œé²é²“é²–é²—é²˜é²™é²é²ªé²¬é²¯é²¹é²¾",4,"é³ˆé³‰é³‘é³’é³šé³›é³ é³¡é³Œ",4,"é³“é³”é³•é³—é³˜é³™é³œé³é³Ÿé³¢é¼éž…éž‘éž’éž”éž¯éž«éž£éž²éž´éª±éª°éª·é¹˜éª¶éªºéª¼é«é«€é«…é«‚é«‹é«Œé«‘é­…é­ƒé­‡é­‰é­ˆé­é­‘é£¨é¤é¤®é¥•é¥”é«Ÿé«¡é«¦é«¯é««é«»é«­é«¹é¬ˆé¬é¬“é¬Ÿé¬£éº½éº¾ç¸»éº‚éº‡éºˆéº‹éº’é–éºéºŸé»›é»œé»é» é»Ÿé»¢é»©é»§é»¥é»ªé»¯é¼¢é¼¬é¼¯é¼¹é¼·é¼½é¼¾é½„"],["f840","é³£",62],["f880","é´¢",32],["f940","éµƒ",62],["f980","é¶‚",32],["fa40","é¶£",62],["fa80","é·¢",32],["fb40","é¸ƒ",27,"é¸¤é¸§é¸®é¸°é¸´é¸»é¸¼é¹€é¹é¹é¹’é¹“é¹”é¹–é¹™é¹é¹Ÿé¹ é¹¡é¹¢é¹¥é¹®é¹¯é¹²é¹´",9,"éº€"],["fb80","éºéºƒéº„éº…éº†éº‰éºŠéºŒ",5,"éº”",8,"éºžéº ",5,"éº§éº¨éº©éºª"],["fc40","éº«",8,"éºµéº¶éº·éº¹éººéº¼éº¿",4,"é»…é»†é»‡é»ˆé»Šé»‹é»Œé»é»’é»“é»•é»–é»—é»™é»šé»žé»¡é»£é»¤é»¦é»¨é»«é»¬é»­é»®é»°",8,"é»ºé»½é»¿",6],["fc80","é¼†",4,"é¼Œé¼é¼‘é¼’é¼”é¼•é¼–é¼˜é¼š",5,"é¼¡é¼£",8,"é¼­é¼®é¼°é¼±"],["fd40","é¼²",4,"é¼¸é¼ºé¼¼é¼¿",4,"é½…",10,"é½’",38],["fd80","é½¹",5,"é¾é¾‚é¾",11,"é¾œé¾é¾žé¾¡",4,"ï¤¬ï¥¹ï¦•ï§§ï§±"],["fe40","ï¨Œï¨ï¨Žï¨ï¨‘ï¨“ï¨”ï¨˜ï¨Ÿï¨ ï¨¡ï¨£ï¨¤ï¨§ï¨¨ï¨©"]]');
const require$$3$2 = [
  [
    "a140",
    "î“†",
    62
  ],
  [
    "a180",
    "î”…",
    32
  ],
  [
    "a240",
    "î”¦",
    62
  ],
  [
    "a280",
    "î•¥",
    32
  ],
  [
    "a2ab",
    "î¦",
    5
  ],
  [
    "a2e3",
    "â‚¬î­"
  ],
  [
    "a2ef",
    "î®î¯"
  ],
  [
    "a2fd",
    "î°î±"
  ],
  [
    "a340",
    "î–†",
    62
  ],
  [
    "a380",
    "î—…",
    31,
    "ã€€"
  ],
  [
    "a440",
    "î—¦",
    62
  ],
  [
    "a480",
    "î˜¥",
    32
  ],
  [
    "a4f4",
    "î²",
    10
  ],
  [
    "a540",
    "î™†",
    62
  ],
  [
    "a580",
    "îš…",
    32
  ],
  [
    "a5f7",
    "î½",
    7
  ],
  [
    "a640",
    "îš¦",
    62
  ],
  [
    "a680",
    "î›¥",
    32
  ],
  [
    "a6b9",
    "îž…",
    7
  ],
  [
    "a6d9",
    "îž",
    6
  ],
  [
    "a6ec",
    "îž”îž•"
  ],
  [
    "a6f3",
    "îž–"
  ],
  [
    "a6f6",
    "îž—",
    8
  ],
  [
    "a740",
    "îœ†",
    62
  ],
  [
    "a780",
    "î…",
    32
  ],
  [
    "a7c2",
    "îž ",
    14
  ],
  [
    "a7f2",
    "îž¯",
    12
  ],
  [
    "a896",
    "îž¼",
    10
  ],
  [
    "a8bc",
    "á¸¿"
  ],
  [
    "a8bf",
    "Ç¹"
  ],
  [
    "a8c1",
    "îŸ‰îŸŠîŸ‹îŸŒ"
  ],
  [
    "a8ea",
    "îŸ",
    20
  ],
  [
    "a958",
    "îŸ¢"
  ],
  [
    "a95b",
    "îŸ£"
  ],
  [
    "a95d",
    "îŸ¤îŸ¥îŸ¦"
  ],
  [
    "a989",
    "ã€¾â¿°",
    11
  ],
  [
    "a997",
    "îŸ´",
    12
  ],
  [
    "a9f0",
    "î ",
    14
  ],
  [
    "aaa1",
    "î€€",
    93
  ],
  [
    "aba1",
    "îž",
    93
  ],
  [
    "aca1",
    "î‚¼",
    93
  ],
  [
    "ada1",
    "î„š",
    93
  ],
  [
    "aea1",
    "î…¸",
    93
  ],
  [
    "afa1",
    "î‡–",
    93
  ],
  [
    "d7fa",
    "î ",
    4
  ],
  [
    "f8a1",
    "îˆ´",
    93
  ],
  [
    "f9a1",
    "îŠ’",
    93
  ],
  [
    "faa1",
    "î‹°",
    93
  ],
  [
    "fba1",
    "îŽ",
    93
  ],
  [
    "fca1",
    "îŽ¬",
    93
  ],
  [
    "fda1",
    "îŠ",
    93
  ],
  [
    "fe50",
    "âºî –î —î ˜âº„ã‘³ã‘‡âºˆâº‹î žã–žã˜šã˜ŽâºŒâº—ã¥®ã¤˜î ¦ã§ã§Ÿã©³ã§î «î ¬ã­Žã±®ã³ âº§î ±î ²âºªä–ä…Ÿâº®äŒ·âº³âº¶âº·î »äŽ±äŽ¬âº»ää“–ä™¡ä™Œî¡ƒ"
  ],
  [
    "fe80",
    "äœ£äœ©ä¼äžâ»Šä¥‡ä¥ºä¥½ä¦‚ä¦ƒä¦…ä¦†ä¦Ÿä¦›ä¦·ä¦¶î¡”î¡•ä²£ä²Ÿä² ä²¡ä±·ä²¢ä´“",
    6,
    "ä¶®î¡¤î‘¨",
    93
  ],
  [
    "8135f437",
    "îŸ‡"
  ]
];
const uChars = [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536];
const gbChars = [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189e3];
const require$$4$1 = {
  uChars,
  gbChars
};
const require$$5$1 = /* @__PURE__ */ JSON.parse('[["0","\\u0000",127],["8141","ê°‚ê°ƒê°…ê°†ê°‹",4,"ê°˜ê°žê°Ÿê°¡ê°¢ê°£ê°¥",6,"ê°®ê°²ê°³ê°´"],["8161","ê°µê°¶ê°·ê°ºê°»ê°½ê°¾ê°¿ê±",9,"ê±Œê±Ž",5,"ê±•"],["8181","ê±–ê±—ê±™ê±šê±›ê±",18,"ê±²ê±³ê±µê±¶ê±¹ê±»",4,"ê²‚ê²‡ê²ˆê²ê²Žê²ê²‘ê²’ê²“ê²•",6,"ê²žê²¢",5,"ê²«ê²­ê²®ê²±",6,"ê²ºê²¾ê²¿ê³€ê³‚ê³ƒê³…ê³†ê³‡ê³‰ê³Šê³‹ê³",7,"ê³–ê³˜",7,"ê³¢ê³£ê³¥ê³¦ê³©ê³«ê³­ê³®ê³²ê³´ê³·",4,"ê³¾ê³¿ê´ê´‚ê´ƒê´…ê´‡",4,"ê´Žê´ê´’ê´“"],["8241","ê´”ê´•ê´–ê´—ê´™ê´šê´›ê´ê´žê´Ÿê´¡",7,"ê´ªê´«ê´®",5],["8261","ê´¶ê´·ê´¹ê´ºê´»ê´½",6,"êµ†êµˆêµŠ",5,"êµ‘êµ’êµ“êµ•êµ–êµ—"],["8281","êµ™",7,"êµ¢êµ¤",7,"êµ®êµ¯êµ±êµ²êµ·êµ¸êµ¹êµºêµ¾ê¶€ê¶ƒ",4,"ê¶Šê¶‹ê¶ê¶Žê¶ê¶‘",10,"ê¶ž",5,"ê¶¥",17,"ê¶¸",7,"ê·‚ê·ƒê·…ê·†ê·‡ê·‰",6,"ê·’ê·”",7,"ê·ê·žê·Ÿê·¡ê·¢ê·£ê·¥",18],["8341","ê·ºê·»ê·½ê·¾ê¸‚",5,"ê¸Šê¸Œê¸Ž",5,"ê¸•",7],["8361","ê¸",18,"ê¸²ê¸³ê¸µê¸¶ê¸¹ê¸»ê¸¼"],["8381","ê¸½ê¸¾ê¸¿ê¹‚ê¹„ê¹‡ê¹ˆê¹‰ê¹‹ê¹ê¹‘ê¹’ê¹“ê¹•ê¹—",4,"ê¹žê¹¢ê¹£ê¹¤ê¹¦ê¹§ê¹ªê¹«ê¹­ê¹®ê¹¯ê¹±",6,"ê¹ºê¹¾",5,"êº†",5,"êº",46,"êº¿ê»ê»‚ê»ƒê»…",6,"ê»Žê»’",5,"ê»šê»›ê»",8],["8441","ê»¦ê»§ê»©ê»ªê»¬ê»®",5,"ê»µê»¶ê»·ê»¹ê»ºê»»ê»½",8],["8461","ê¼†ê¼‰ê¼Šê¼‹ê¼Œê¼Žê¼ê¼‘",18],["8481","ê¼¤",7,"ê¼®ê¼¯ê¼±ê¼³ê¼µ",6,"ê¼¾ê½€ê½„ê½…ê½†ê½‡ê½Š",5,"ê½‘",10,"ê½ž",5,"ê½¦",18,"ê½º",5,"ê¾ê¾‚ê¾ƒê¾…ê¾†ê¾‡ê¾‰",6,"ê¾’ê¾“ê¾”ê¾–",5,"ê¾",26,"ê¾ºê¾»ê¾½ê¾¾"],["8541","ê¾¿ê¿",5,"ê¿Šê¿Œê¿",4,"ê¿•",6,"ê¿",4],["8561","ê¿¢",5,"ê¿ª",5,"ê¿²ê¿³ê¿µê¿¶ê¿·ê¿¹",6,"ë€‚ë€ƒ"],["8581","ë€…",6,"ë€ë€Žë€ë€‘ë€’ë€“ë€•",6,"ë€ž",9,"ë€©",26,"ë†ë‡ë‰ë‹ëëëë‘ë’ë–ë˜ëšë›ëœëž",29,"ë¾ë¿ë‚ë‚‚ë‚ƒë‚…",6,"ë‚Žë‚ë‚’",5,"ë‚›ë‚ë‚žë‚£ë‚¤"],["8641","ë‚¥ë‚¦ë‚§ë‚ªë‚°ë‚²ë‚¶ë‚·ë‚¹ë‚ºë‚»ë‚½",6,"ëƒ†ëƒŠ",5,"ëƒ’"],["8661","ëƒ“ëƒ•ëƒ–ëƒ—ëƒ™",6,"ëƒ¡ëƒ¢ëƒ£ëƒ¤ëƒ¦",10],["8681","ëƒ±",22,"ë„Šë„ë„Žë„ë„‘ë„”ë„•ë„–ë„—ë„šë„ž",4,"ë„¦ë„§ë„©ë„ªë„«ë„­",6,"ë„¶ë„º",5,"ë…‚ë…ƒë……ë…†ë…‡ë…‰",6,"ë…’ë…“ë…–ë…—ë…™ë…šë…›ë…ë…žë…Ÿë…¡",22,"ë…ºë…»ë…½ë…¾ë…¿ë†ë†ƒ",4,"ë†Šë†Œë†Žë†ë†ë†‘ë†•ë†–ë†—ë†™ë†šë†›ë†"],["8741","ë†ž",9,"ë†©",15],["8761","ë†¹",18,"ë‡ë‡Žë‡ë‡‘ë‡’ë‡“ë‡•"],["8781","ë‡–",5,"ë‡žë‡ ",7,"ë‡ªë‡«ë‡­ë‡®ë‡¯ë‡±",7,"ë‡ºë‡¼ë‡¾",5,"ëˆ†ëˆ‡ëˆ‰ëˆŠëˆ",6,"ëˆ–ëˆ˜ëˆš",5,"ëˆ¡",18,"ëˆµ",6,"ëˆ½",26,"ë‰™ë‰šë‰›ë‰ë‰žë‰Ÿë‰¡",6,"ë‰ª",4],["8841","ë‰¯",4,"ë‰¶",5,"ë‰½",6,"ëŠ†ëŠ‡ëŠˆëŠŠ",4],["8861","ëŠëŠ’ëŠ“ëŠ•ëŠ–ëŠ—ëŠ›",4,"ëŠ¢ëŠ¤ëŠ§ëŠ¨ëŠ©ëŠ«ëŠ­ëŠ®ëŠ¯ëŠ±ëŠ²ëŠ³ëŠµëŠ¶ëŠ·"],["8881","ëŠ¸",15,"ë‹Šë‹‹ë‹ë‹Žë‹ë‹‘ë‹“",4,"ë‹šë‹œë‹žë‹Ÿë‹ ë‹¡ë‹£ë‹§ë‹©ë‹ªë‹°ë‹±ë‹²ë‹¶ë‹¼ë‹½ë‹¾ëŒ‚ëŒƒëŒ…ëŒ†ëŒ‡ëŒ‰",6,"ëŒ’ëŒ–",5,"ëŒ",54,"ë—ë™ëšëë ë¡ë¢ë£"],["8941","ë¦ë¨ëªë¬ë­ë¯ë²ë³ëµë¶ë·ë¹",6,"ëŽ‚ëŽ†",5,"ëŽ"],["8961","ëŽŽëŽëŽ‘ëŽ’ëŽ“ëŽ•",10,"ëŽ¢",5,"ëŽ©ëŽªëŽ«ëŽ­"],["8981","ëŽ®",21,"ë†ë‡ë‰ëŠëëë‘ë’ë“ë–ë˜ëšëœëžëŸë¡ë¢ë£ë¥ë¦ë§ë©",18,"ë½",18,"ë‘",6,"ë™ëšë›ëëžëŸë¡",6,"ëªë¬",7,"ëµ",15],["8a41","ë‘…",10,"ë‘’ë‘“ë‘•ë‘–ë‘—ë‘™",6,"ë‘¢ë‘¤ë‘¦"],["8a61","ë‘§",4,"ë‘­",18,"ë’ë’‚"],["8a81","ë’ƒ",4,"ë’‰",19,"ë’ž",5,"ë’¥ë’¦ë’§ë’©ë’ªë’«ë’­",7,"ë’¶ë’¸ë’º",5,"ë“ë“‚ë“ƒë“…ë“†ë“‡ë“‰",6,"ë“‘ë“’ë““ë“”ë“–",5,"ë“žë“Ÿë“¡ë“¢ë“¥ë“§",4,"ë“®ë“°ë“²",5,"ë“¹",26,"ë”–ë”—ë”™ë”šë”"],["8b41","ë”ž",5,"ë”¦ë”«",4,"ë”²ë”³ë”µë”¶ë”·ë”¹",6,"ë•‚ë•†"],["8b61","ë•‡ë•ˆë•‰ë•Šë•Žë•ë•‘ë•’ë•“ë••",6,"ë•žë•¢",8],["8b81","ë•«",52,"ë–¢ë–£ë–¥ë–¦ë–§ë–©ë–¬ë–­ë–®ë–¯ë–²ë–¶",4,"ë–¾ë–¿ë—ë—‚ë—ƒë—…",6,"ë—Žë—’",5,"ë—™",18,"ë—­",18],["8c41","ë˜€",15,"ë˜’ë˜“ë˜•ë˜–ë˜—ë˜™",4],["8c61","ë˜ž",6,"ë˜¦",5,"ë˜­",6,"ë˜µ",5],["8c81","ë˜»",12,"ë™‰",26,"ë™¥ë™¦ë™§ë™©",50,"ëšžëšŸëš¡ëš¢ëš£ëš¥",5,"ëš­ëš®ëš¯ëš°ëš²",16],["8d41","ë›ƒ",16,"ë›•",8],["8d61","ë›ž",17,"ë›±ë›²ë›³ë›µë›¶ë›·ë›¹ë›º"],["8d81","ë›»",4,"ëœ‚ëœƒëœ„ëœ†",33,"ëœªëœ«ëœ­ëœ®ëœ±",6,"ëœºëœ¼",7,"ë…ë†ë‡ë‰ëŠë‹ë",6,"ë–",9,"ë¡ë¢ë£ë¥ë¦ë§ë©",6,"ë²ë´ë¶",5,"ë¾ë¿ëžëž‚ëžƒëž…",6,"ëžŽëž“ëž”ëž•ëžšëž›ëžëžž"],["8e41","ëžŸëž¡",6,"ëžªëž®",5,"ëž¶ëž·ëž¹",8],["8e61","ëŸ‚",4,"ëŸˆëŸŠ",19],["8e81","ëŸž",13,"ëŸ®ëŸ¯ëŸ±ëŸ²ëŸ³ëŸµ",6,"ëŸ¾ë ‚",4,"ë Šë ‹ë ë Žë ë ‘",6,"ë šë œë ž",5,"ë ¦ë §ë ©ë ªë «ë ­",6,"ë ¶ë º",5,"ë¡ë¡‚ë¡ƒë¡…",11,"ë¡’ë¡”",7,"ë¡žë¡Ÿë¡¡ë¡¢ë¡£ë¡¥",6,"ë¡®ë¡°ë¡²",5,"ë¡¹ë¡ºë¡»ë¡½",7],["8f41","ë¢…",7,"ë¢Ž",17],["8f61","ë¢ ",7,"ë¢©",6,"ë¢±ë¢²ë¢³ë¢µë¢¶ë¢·ë¢¹",4],["8f81","ë¢¾ë¢¿ë£‚ë£„ë£†",5,"ë£ë£Žë£ë£‘ë£’ë£“ë£•",7,"ë£žë£ ë£¢",5,"ë£ªë£«ë£­ë£®ë£¯ë£±",6,"ë£ºë£¼ë£¾",5,"ë¤…",18,"ë¤™",6,"ë¤¡",26,"ë¤¾ë¤¿ë¥ë¥‚ë¥ƒë¥…",6,"ë¥ë¥Žë¥ë¥’",5],["9041","ë¥šë¥›ë¥ë¥žë¥Ÿë¥¡",6,"ë¥ªë¥¬ë¥®",5,"ë¥¶ë¥·ë¥¹ë¥ºë¥»ë¥½"],["9061","ë¥¾",5,"ë¦†ë¦ˆë¦‹ë¦Œë¦",15],["9081","ë¦Ÿ",12,"ë¦®ë¦¯ë¦±ë¦²ë¦³ë¦µ",6,"ë¦¾ë§€ë§‚",5,"ë§Šë§‹ë§ë§“",4,"ë§šë§œë§Ÿë§ ë§¢ë§¦ë§§ë§©ë§ªë§«ë§­",6,"ë§¶ë§»",4,"ë¨‚",5,"ë¨‰",11,"ë¨–",33,"ë¨ºë¨»ë¨½ë¨¾ë¨¿ë©ë©ƒë©„ë©…ë©†"],["9141","ë©‡ë©Šë©Œë©ë©ë©‘ë©’ë©–ë©—ë©™ë©šë©›ë©",6,"ë©¦ë©ª",5],["9161","ë©²ë©³ë©µë©¶ë©·ë©¹",9,"ëª†ëªˆëª‰ëªŠëª‹ëª",5],["9181","ëª“",20,"ëªªëª­ëª®ëª¯ëª±ëª³",4,"ëªºëª¼ëª¾",5,"ë«…ë«†ë«‡ë«‰",14,"ë«š",33,"ë«½ë«¾ë«¿ë¬ë¬‚ë¬ƒë¬…",7,"ë¬Žë¬ë¬’",5,"ë¬™ë¬šë¬›ë¬ë¬žë¬Ÿë¬¡",6],["9241","ë¬¨ë¬ªë¬¬",7,"ë¬·ë¬¹ë¬ºë¬¿",4,"ë­†ë­ˆë­Šë­‹ë­Œë­Žë­‘ë­’"],["9261","ë­“ë­•ë­–ë­—ë­™",7,"ë­¢ë­¤",7,"ë­­",4],["9281","ë­²",21,"ë®‰ë®Šë®‹ë®ë®Žë®ë®‘",18,"ë®¥ë®¦ë®§ë®©ë®ªë®«ë®­",6,"ë®µë®¶ë®¸",7,"ë¯ë¯‚ë¯ƒë¯…ë¯†ë¯‡ë¯‰",6,"ë¯‘ë¯’ë¯”",35,"ë¯ºë¯»ë¯½ë¯¾ë°"],["9341","ë°ƒ",4,"ë°Šë°Žë°ë°’ë°“ë°™ë°šë° ë°¡ë°¢ë°£ë°¦ë°¨ë°ªë°«ë°¬ë°®ë°¯ë°²ë°³ë°µ"],["9361","ë°¶ë°·ë°¹",6,"ë±‚ë±†ë±‡ë±ˆë±Šë±‹ë±Žë±ë±‘",8],["9381","ë±šë±›ë±œë±ž",37,"ë²†ë²‡ë²‰ë²Šë²ë²",4,"ë²–ë²˜ë²›",4,"ë²¢ë²£ë²¥ë²¦ë²©",6,"ë²²ë²¶",5,"ë²¾ë²¿ë³ë³‚ë³ƒë³…",7,"ë³Žë³’ë³“ë³”ë³–ë³—ë³™ë³šë³›ë³",22,"ë³·ë³¹ë³ºë³»ë³½"],["9441","ë³¾",5,"ë´†ë´ˆë´Š",5,"ë´‘ë´’ë´“ë´•",8],["9461","ë´ž",5,"ë´¥",6,"ë´­",12],["9481","ë´º",5,"ëµ",6,"ëµŠëµ‹ëµëµŽëµëµ‘",6,"ëµš",9,"ëµ¥ëµ¦ëµ§ëµ©",22,"ë¶‚ë¶ƒë¶…ë¶†ë¶‹",4,"ë¶’ë¶”ë¶–ë¶—ë¶˜ë¶›ë¶",6,"ë¶¥",10,"ë¶±",6,"ë¶¹",24],["9541","ë·’ë·“ë·–ë·—ë·™ë·šë·›ë·",11,"ë·ª",5,"ë·±"],["9561","ë·²ë·³ë·µë·¶ë··ë·¹",6,"ë¸ë¸‚ë¸„ë¸†",5,"ë¸Žë¸ë¸‘ë¸’ë¸“"],["9581","ë¸•",6,"ë¸žë¸ ",35,"ë¹†ë¹‡ë¹‰ë¹Šë¹‹ë¹ë¹",4,"ë¹–ë¹˜ë¹œë¹ë¹žë¹Ÿë¹¢ë¹£ë¹¥ë¹¦ë¹§ë¹©ë¹«",4,"ë¹²ë¹¶",4,"ë¹¾ë¹¿ëºëº‚ëºƒëº…",6,"ëºŽëº’",5,"ëºš",13,"ëº©",14],["9641","ëº¸",23,"ë»’ë»“"],["9661","ë»•ë»–ë»™",6,"ë»¡ë»¢ë»¦",5,"ë»­",8],["9681","ë»¶",10,"ë¼‚",5,"ë¼Š",13,"ë¼šë¼ž",33,"ë½‚ë½ƒë½…ë½†ë½‡ë½‰",6,"ë½’ë½“ë½”ë½–",44],["9741","ë¾ƒ",16,"ë¾•",8],["9761","ë¾ž",17,"ë¾±",7],["9781","ë¾¹",11,"ë¿†",5,"ë¿Žë¿ë¿‘ë¿’ë¿“ë¿•",6,"ë¿ë¿žë¿ ë¿¢",89,"ì€½ì€¾ì€¿"],["9841","ì€",16,"ì’",5,"ì™ìšì›"],["9861","ììžìŸì¡",6,"ìª",15],["9881","ìº",21,"ì‚’ì‚“ì‚•ì‚–ì‚—ì‚™",6,"ì‚¢ì‚¤ì‚¦",5,"ì‚®ì‚±ì‚²ì‚·",4,"ì‚¾ìƒ‚ìƒƒìƒ„ìƒ†ìƒ‡ìƒŠìƒ‹ìƒìƒŽìƒìƒ‘",6,"ìƒšìƒž",5,"ìƒ¦ìƒ§ìƒ©ìƒªìƒ«ìƒ­",6,"ìƒ¶ìƒ¸ìƒº",5,"ì„ì„‚ì„ƒì„…ì„†ì„‡ì„‰",6,"ì„‘ì„’ì„“ì„”ì„–",5,"ì„¡ì„¢ì„¥ì„¨ì„©ì„ªì„«ì„®"],["9941","ì„²ì„³ì„´ì„µì„·ì„ºì„»ì„½ì„¾ì„¿ì…",6,"ì…Šì…Ž",5,"ì…–ì…—"],["9961","ì…™ì…šì…›ì…",6,"ì…¦ì…ª",5,"ì…±ì…²ì…³ì…µì…¶ì…·ì…¹ì…ºì…»"],["9981","ì…¼",8,"ì††",5,"ì†ì†‘ì†’ì†“ì†•ì†—",4,"ì†žì† ì†¢ì†£ì†¤ì†¦ì†§ì†ªì†«ì†­ì†®ì†¯ì†±",11,"ì†¾",5,"ì‡…ì‡†ì‡‡ì‡‰ì‡Šì‡‹ì‡",6,"ì‡•ì‡–ì‡™",6,"ì‡¡ì‡¢ì‡£ì‡¥ì‡¦ì‡§ì‡©",6,"ì‡²ì‡´",7,"ì‡¾ì‡¿ìˆìˆ‚ìˆƒìˆ…",6,"ìˆŽìˆìˆ’",5,"ìˆšìˆ›ìˆìˆžìˆ¡ìˆ¢ìˆ£"],["9a41","ìˆ¤ìˆ¥ìˆ¦ìˆ§ìˆªìˆ¬ìˆ®ìˆ°ìˆ³ìˆµ",16],["9a61","ì‰†ì‰‡ì‰‰",6,"ì‰’ì‰“ì‰•ì‰–ì‰—ì‰™",6,"ì‰¡ì‰¢ì‰£ì‰¤ì‰¦"],["9a81","ì‰§",4,"ì‰®ì‰¯ì‰±ì‰²ì‰³ì‰µ",6,"ì‰¾ìŠ€ìŠ‚",5,"ìŠŠ",5,"ìŠ‘",6,"ìŠ™ìŠšìŠœìŠž",5,"ìŠ¦ìŠ§ìŠ©ìŠªìŠ«ìŠ®",5,"ìŠ¶ìŠ¸ìŠº",33,"ì‹žì‹Ÿì‹¡ì‹¢ì‹¥",5,"ì‹®ì‹°ì‹²ì‹³ì‹´ì‹µì‹·ì‹ºì‹½ì‹¾ì‹¿ìŒ",6,"ìŒŠìŒ‹ìŒŽìŒ"],["9b41","ìŒìŒ‘ìŒ’ìŒ–ìŒ—ìŒ™ìŒšìŒ›ìŒ",6,"ìŒ¦ìŒ§ìŒª",8],["9b61","ìŒ³",17,"ì†",7],["9b81","ìŽ",25,"ìªì«ì­ì®ì¯ì±ì³",4,"ìºì»ì¾",5,"ìŽ…ìŽ†ìŽ‡ìŽ‰ìŽŠìŽ‹ìŽ",50,"ì",22,"ìš"],["9c41","ì›ììžì¡ì£",4,"ìªì«ì¬ì®",5,"ì¶ì·ì¹",5],["9c61","ì¿",8,"ì‰",6,"ì‘",9],["9c81","ì›",8,"ì¥",6,"ì­ì®ì¯ì±ì²ì³ìµ",6,"ì¾",9,"ì‘‰",26,"ì‘¦ì‘§ì‘©ì‘ªì‘«ì‘­",6,"ì‘¶ì‘·ì‘¸ì‘º",5,"ì’",18,"ì’•",6,"ì’",12],["9d41","ì’ª",13,"ì’¹ì’ºì’»ì’½",8],["9d61","ì“†",25],["9d81","ì“ ",8,"ì“ª",5,"ì“²ì“³ì“µì“¶ì“·ì“¹ì“»ì“¼ì“½ì“¾ì”‚",9,"ì”ì”Žì”ì”‘ì”’ì”“ì”•",6,"ì”",10,"ì”ªì”«ì”­ì”®ì”¯ì”±",6,"ì”ºì”¼ì”¾",5,"ì•†ì•‡ì•‹ì•ì•ì•‘ì•’ì•–ì•šì•›ì•œì•Ÿì•¢ì•£ì•¥ì•¦ì•§ì•©",6,"ì•²ì•¶",5,"ì•¾ì•¿ì–ì–‚ì–ƒì–…ì–†ì–ˆì–‰ì–Šì–‹ì–Žì–ì–’ì–“ì–”"],["9e41","ì––ì–™ì–šì–›ì–ì–žì–Ÿì–¡",7,"ì–ª",9,"ì–¶"],["9e61","ì–·ì–ºì–¿",4,"ì—‹ì—ì—ì—’ì—“ì—•ì—–ì——ì—™",6,"ì—¢ì—¤ì—¦ì—§"],["9e81","ì—¨ì—©ì—ªì—«ì—¯ì—±ì—²ì—³ì—µì—¸ì—¹ì—ºì—»ì˜‚ì˜ƒì˜„ì˜‰ì˜Šì˜‹ì˜ì˜Žì˜ì˜‘",6,"ì˜šì˜",6,"ì˜¦ì˜§ì˜©ì˜ªì˜«ì˜¯ì˜±ì˜²ì˜¶ì˜¸ì˜ºì˜¼ì˜½ì˜¾ì˜¿ì™‚ì™ƒì™…ì™†ì™‡ì™‰",6,"ì™’ì™–",5,"ì™žì™Ÿì™¡",10,"ì™­ì™®ì™°ì™²",5,"ì™ºì™»ì™½ì™¾ì™¿ìš",6,"ìšŠìšŒìšŽ",5,"ìš–ìš—ìš™ìššìš›ìš",6,"ìš¦"],["9f41","ìš¨ìšª",5,"ìš²ìš³ìšµìš¶ìš·ìš»",4,"ì›‚ì›„ì›†",5,"ì›Ž"],["9f61","ì›ì›‘ì›’ì›“ì›•",6,"ì›žì›Ÿì›¢",5,"ì›ªì›«ì›­ì›®ì›¯ì›±ì›²"],["9f81","ì›³",4,"ì›ºì›»ì›¼ì›¾",5,"ìœ†ìœ‡ìœ‰ìœŠìœ‹ìœ",6,"ìœ–ìœ˜ìœš",5,"ìœ¢ìœ£ìœ¥ìœ¦ìœ§ìœ©",6,"ìœ²ìœ´ìœ¶ìœ¸ìœ¹ìœºìœ»ìœ¾ìœ¿ìì‚ìƒì…",4,"ì‹ìŽìì™ìšì›ììžìŸì¡",6,"ì©ìªì¬",7,"ì¶ì·ì¹ìºì»ì¿ìž€ìžìž‚ìž†ìž‹ìžŒìžìžìž’ìž“ìž•ìž™ìž›",4,"ìž¢ìž§",4,"ìž®ìž¯ìž±ìž²ìž³ìžµìž¶ìž·"],["a041","ìž¸ìž¹ìžºìž»ìž¾ìŸ‚",5,"ìŸŠìŸ‹ìŸìŸìŸ‘",6,"ìŸ™ìŸšìŸ›ìŸœ"],["a061","ìŸž",5,"ìŸ¥ìŸ¦ìŸ§ìŸ©ìŸªìŸ«ìŸ­",13],["a081","ìŸ»",4,"ì ‚ì ƒì …ì †ì ‡ì ‰ì ‹",4,"ì ’ì ”ì —",4,"ì žì Ÿì ¡ì ¢ì £ì ¥",6,"ì ®ì °ì ²",5,"ì ¹ì ºì »ì ½ì ¾ì ¿ì¡",6,"ì¡Šì¡‹ì¡Ž",5,"ì¡•",26,"ì¡²ì¡³ì¡µì¡¶ì¡·ì¡¹ì¡»",4,"ì¢‚ì¢„ì¢ˆì¢‰ì¢Šì¢Ž",5,"ì¢•",7,"ì¢žì¢ ì¢¢ì¢£ì¢¤"],["a141","ì¢¥ì¢¦ì¢§ì¢©",18,"ì¢¾ì¢¿ì£€ì£"],["a161","ì£‚ì£ƒì£…ì£†ì£‡ì£‰ì£Šì£‹ì£",6,"ì£–ì£˜ì£š",5,"ì£¢ì££ì£¥"],["a181","ì£¦",14,"ì£¶",5,"ì£¾ì£¿ì¤ì¤‚ì¤ƒì¤‡",4,"ì¤Žã€€ã€ã€‚Â·â€¥â€¦Â¨ã€ƒÂ­â€•âˆ¥ï¼¼âˆ¼â€˜â€™â€œâ€ã€”ã€•ã€ˆ",9,"Â±Ã—Ã·â‰ â‰¤â‰¥âˆžâˆ´Â°â€²â€³â„ƒâ„«ï¿ ï¿¡ï¿¥â™‚â™€âˆ âŠ¥âŒ’âˆ‚âˆ‡â‰¡â‰’Â§â€»â˜†â˜…â—‹â—â—Žâ—‡â—†â–¡â– â–³â–²â–½â–¼â†’â†â†‘â†“â†”ã€“â‰ªâ‰«âˆšâˆ½âˆâˆµâˆ«âˆ¬âˆˆâˆ‹âŠ†âŠ‡âŠ‚âŠƒâˆªâˆ©âˆ§âˆ¨ï¿¢"],["a241","ì¤ì¤’",5,"ì¤™",18],["a261","ì¤­",6,"ì¤µ",18],["a281","ì¥ˆ",7,"ì¥’ì¥“ì¥•ì¥–ì¥—ì¥™",6,"ì¥¢ì¥¤",7,"ì¥­ì¥®ì¥¯â‡’â‡”âˆ€âˆƒÂ´ï½žË‡Ë˜ËËšË™Â¸Ë›Â¡Â¿Ëâˆ®âˆ‘âˆÂ¤â„‰â€°â—â—€â–·â–¶â™¤â™ â™¡â™¥â™§â™£âŠ™â—ˆâ–£â—â—‘â–’â–¤â–¥â–¨â–§â–¦â–©â™¨â˜â˜Žâ˜œâ˜žÂ¶â€ â€¡â†•â†—â†™â†–â†˜â™­â™©â™ªâ™¬ã‰¿ãˆœâ„–ã‡â„¢ã‚ã˜â„¡â‚¬Â®"],["a341","ì¥±ì¥²ì¥³ì¥µ",6,"ì¥½",10,"ì¦Šì¦‹ì¦ì¦Žì¦"],["a361","ì¦‘",6,"ì¦šì¦œì¦ž",16],["a381","ì¦¯",16,"ì§‚ì§ƒì§…ì§†ì§‰ì§‹",4,"ì§’ì§”ì§—ì§˜ì§›ï¼",58,"ï¿¦ï¼½",32,"ï¿£"],["a441","ì§žì§Ÿì§¡ì§£ì§¥ì§¦ì§¨ì§©ì§ªì§«ì§®ì§²",5,"ì§ºì§»ì§½ì§¾ì§¿ì¨ì¨‚ì¨ƒì¨„"],["a461","ì¨…ì¨†ì¨‡ì¨Šì¨Ž",5,"ì¨•ì¨–ì¨—ì¨™",12],["a481","ì¨¦ì¨§ì¨¨ì¨ª",28,"ã„±",93],["a541","ì©‡",4,"ì©Žì©ì©‘ì©’ì©“ì©•",6,"ì©žì©¢",5,"ì©©ì©ª"],["a561","ì©«",17,"ì©¾",5,"ìª…ìª†"],["a581","ìª‡",16,"ìª™",14,"â…°",9],["a5b0","â… ",9],["a5c1","Î‘",16,"Î£",6],["a5e1","Î±",16,"Ïƒ",6],["a641","ìª¨",19,"ìª¾ìª¿ì«ì«‚ì«ƒì«…"],["a661","ì«†",5,"ì«Žì«ì«’ì«”ì«•ì«–ì«—ì«š",5,"ì«¡",6],["a681","ì«¨ì«©ì«ªì««ì«­",6,"ì«µ",18,"ì¬‰ì¬Šâ”€â”‚â”Œâ”â”˜â””â”œâ”¬â”¤â”´â”¼â”â”ƒâ”â”“â”›â”—â”£â”³â”«â”»â•‹â” â”¯â”¨â”·â”¿â”â”°â”¥â”¸â•‚â”’â”‘â”šâ”™â”–â”•â”Žâ”â”žâ”Ÿâ”¡â”¢â”¦â”§â”©â”ªâ”­â”®â”±â”²â”µâ”¶â”¹â”ºâ”½â”¾â•€â•â•ƒ",7],["a741","ì¬‹",4,"ì¬‘ì¬’ì¬“ì¬•ì¬–ì¬—ì¬™",6,"ì¬¢",7],["a761","ì¬ª",22,"ì­‚ì­ƒì­„"],["a781","ì­…ì­†ì­‡ì­Šì­‹ì­ì­Žì­ì­‘",6,"ì­šì­›ì­œì­ž",5,"ì­¥",7,"ãŽ•ãŽ–ãŽ—â„“ãŽ˜ã„ãŽ£ãŽ¤ãŽ¥ãŽ¦ãŽ™",9,"ãŠãŽãŽŽãŽããŽˆãŽ‰ãˆãŽ§ãŽ¨ãŽ°",9,"ãŽ€",4,"ãŽº",5,"ãŽ",4,"â„¦ã€ããŽŠãŽ‹ãŽŒã–ã…ãŽ­ãŽ®ãŽ¯ã›ãŽ©ãŽªãŽ«ãŽ¬ããã“ãƒã‰ãœã†"],["a841","ì­­",10,"ì­º",14],["a861","ì®‰",18,"ì®",6],["a881","ì®¤",19,"ì®¹",11,"Ã†ÃÂªÄ¦"],["a8a6","Ä²"],["a8a8","Ä¿ÅÃ˜Å’ÂºÃžÅ¦ÅŠ"],["a8b1","ã‰ ",27,"â“",25,"â‘ ",14,"Â½â…“â…”Â¼Â¾â…›â…œâ…â…ž"],["a941","ì¯…",14,"ì¯•",10],["a961","ì¯ ì¯¡ì¯¢ì¯£ì¯¥ì¯¦ì¯¨ì¯ª",18],["a981","ì¯½",14,"ì°Žì°ì°‘ì°’ì°“ì°•",6,"ì°žì°Ÿì° ì°£ì°¤Ã¦Ä‘Ã°Ä§Ä±Ä³Ä¸Å€Å‚Ã¸Å“ÃŸÃ¾Å§Å‹Å‰ãˆ€",27,"â’œ",25,"â‘´",14,"Â¹Â²Â³â´â¿â‚â‚‚â‚ƒâ‚„"],["aa41","ì°¥ì°¦ì°ªì°«ì°­ì°¯ì°±",6,"ì°ºì°¿",4,"ì±†ì±‡ì±‰ì±Šì±‹ì±ì±Ž"],["aa61","ì±",4,"ì±–ì±š",5,"ì±¡ì±¢ì±£ì±¥ì±§ì±©",6,"ì±±ì±²"],["aa81","ì±³ì±´ì±¶",29,"ã",82],["ab41","ì²”ì²•ì²–ì²—ì²šì²›ì²ì²žì²Ÿì²¡",6,"ì²ªì²®",5,"ì²¶ì²·ì²¹"],["ab61","ì²ºì²»ì²½",6,"ì³†ì³ˆì³Š",5,"ì³‘ì³’ì³“ì³•",5],["ab81","ì³›",8,"ì³¥",6,"ì³­ì³®ì³¯ì³±",12,"ã‚¡",85],["ac41","ì³¾ì³¿ì´€ì´‚",5,"ì´Šì´‹ì´ì´Žì´ì´‘",6,"ì´šì´œì´žì´Ÿì´ "],["ac61","ì´¡ì´¢ì´£ì´¥ì´¦ì´§ì´©ì´ªì´«ì´­",11,"ì´º",4],["ac81","ì´¿",28,"ìµìµžìµŸÐ",5,"ÐÐ–",25],["acd1","Ð°",5,"Ñ‘Ð¶",25],["ad41","ìµ¡ìµ¢ìµ£ìµ¥",6,"ìµ®ìµ°ìµ²",5,"ìµ¹",7],["ad61","ì¶",6,"ì¶‰",10,"ì¶–ì¶—ì¶™ì¶šì¶›ì¶ì¶žì¶Ÿ"],["ad81","ì¶ ì¶¡ì¶¢ì¶£ì¶¦ì¶¨ì¶ª",5,"ì¶±",18,"ì·…"],["ae41","ì·†",5,"ì·ì·Žì·ì·‘",16],["ae61","ì·¢",5,"ì·©ì·ªì·«ì·­ì·®ì·¯ì·±",6,"ì·ºì·¼ì·¾",4],["ae81","ì¸ƒì¸…ì¸†ì¸‡ì¸‰ì¸Šì¸‹ì¸",6,"ì¸•ì¸–ì¸—ì¸˜ì¸š",5,"ì¸¢ì¸£ì¸¥ì¸¦ì¸§ì¸©ì¸ªì¸«"],["af41","ì¸¬ì¸­ì¸®ì¸¯ì¸²ì¸´ì¸¶",19],["af61","ì¹Š",13,"ì¹šì¹›ì¹ì¹žì¹¢",5,"ì¹ªì¹¬"],["af81","ì¹®",5,"ì¹¶ì¹·ì¹¹ì¹ºì¹»ì¹½",6,"ìº†ìºˆìºŠ",5,"ìº’ìº“ìº•ìº–ìº—ìº™"],["b041","ìºš",5,"ìº¢ìº¦",5,"ìº®",12],["b061","ìº»",5,"ì»‚",19],["b081","ì»–",13,"ì»¦ì»§ì»©ì»ªì»­",6,"ì»¶ì»º",5,"ê°€ê°ê°„ê°‡ê°ˆê°‰ê°Šê°",7,"ê°™",4,"ê° ê°¤ê°¬ê°­ê°¯ê°°ê°±ê°¸ê°¹ê°¼ê±€ê±‹ê±ê±”ê±˜ê±œê±°ê±±ê±´ê±·ê±¸ê±ºê²€ê²ê²ƒê²„ê²…ê²†ê²‰ê²Šê²‹ê²Œê²ê²”ê²œê²ê²Ÿê² ê²¡ê²¨ê²©ê²ªê²¬ê²¯ê²°ê²¸ê²¹ê²»ê²¼ê²½ê³ê³„ê³ˆê³Œê³•ê³—ê³ ê³¡ê³¤ê³§ê³¨ê³ªê³¬ê³¯ê³°ê³±ê³³ê³µê³¶ê³¼ê³½ê´€ê´„ê´†"],["b141","ì¼‚ì¼ƒì¼…ì¼†ì¼‡ì¼‰",6,"ì¼’ì¼”ì¼–",5,"ì¼ì¼žì¼Ÿì¼¡ì¼¢ì¼£"],["b161","ì¼¥",6,"ì¼®ì¼²",5,"ì¼¹",11],["b181","ì½…",14,"ì½–ì½—ì½™ì½šì½›ì½",6,"ì½¦ì½¨ì½ªì½«ì½¬ê´Œê´ê´ê´‘ê´˜ê´œê´ ê´©ê´¬ê´­ê´´ê´µê´¸ê´¼êµ„êµ…êµ‡êµ‰êµêµ”êµ˜êµ¡êµ£êµ¬êµ­êµ°êµ³êµ´êµµêµ¶êµ»êµ¼êµ½êµ¿ê¶ê¶‚ê¶ˆê¶‰ê¶Œê¶ê¶œê¶ê¶¤ê¶·ê·€ê·ê·„ê·ˆê·ê·‘ê·“ê·œê· ê·¤ê·¸ê·¹ê·¼ê·¿ê¸€ê¸ê¸ˆê¸‰ê¸‹ê¸ê¸”ê¸°ê¸±ê¸´ê¸·ê¸¸ê¸ºê¹€ê¹ê¹ƒê¹…ê¹†ê¹Šê¹Œê¹ê¹Žê¹ê¹”ê¹–ê¹œê¹ê¹Ÿê¹ ê¹¡ê¹¥ê¹¨ê¹©ê¹¬ê¹°ê¹¸"],["b241","ì½­ì½®ì½¯ì½²ì½³ì½µì½¶ì½·ì½¹",6,"ì¾ì¾‚ì¾ƒì¾„ì¾†",5,"ì¾"],["b261","ì¾Ž",18,"ì¾¢",5,"ì¾©"],["b281","ì¾ª",5,"ì¾±",18,"ì¿…",6,"ê¹¹ê¹»ê¹¼ê¹½êº„êº…êºŒêº¼êº½êº¾ê»€ê»„ê»Œê»ê»ê»ê»‘ê»˜ê»™ê»œê»¨ê»«ê»­ê»´ê»¸ê»¼ê¼‡ê¼ˆê¼ê¼ê¼¬ê¼­ê¼°ê¼²ê¼´ê¼¼ê¼½ê¼¿ê½ê½‚ê½ƒê½ˆê½‰ê½ê½œê½ê½¤ê½¥ê½¹ê¾€ê¾„ê¾ˆê¾ê¾‘ê¾•ê¾œê¾¸ê¾¹ê¾¼ê¿€ê¿‡ê¿ˆê¿‰ê¿‹ê¿ê¿Žê¿”ê¿œê¿¨ê¿©ê¿°ê¿±ê¿´ê¿¸ë€€ë€ë€„ë€Œë€ë€”ë€œë€ë€¨ë„ë…ëˆëŠëŒëŽë“ë”ë•ë—ë™"],["b341","ì¿Œ",19,"ì¿¢ì¿£ì¿¥ì¿¦ì¿§ì¿©"],["b361","ì¿ª",5,"ì¿²ì¿´ì¿¶",5,"ì¿½ì¿¾ì¿¿í€í€‚í€ƒí€…",5],["b381","í€‹",5,"í€’",5,"í€™",19,"ëë¼ë½ë‚€ë‚„ë‚Œë‚ë‚ë‚‘ë‚˜ë‚™ë‚šë‚œë‚Ÿë‚ ë‚¡ë‚¢ë‚¨ë‚©ë‚«",4,"ë‚±ë‚³ë‚´ë‚µë‚¸ë‚¼ëƒ„ëƒ…ëƒ‡ëƒˆëƒ‰ëƒëƒ‘ëƒ”ëƒ˜ëƒ ëƒ¥ë„ˆë„‰ë„‹ë„Œë„ë„’ë„“ë„˜ë„™ë„›ë„œë„ë„£ë„¤ë„¥ë„¨ë„¬ë„´ë„µë„·ë„¸ë„¹ë…€ë…ë…„ë…ˆë…ë…‘ë…”ë…•ë…˜ë…œë… ë…¸ë…¹ë…¼ë†€ë†‚ë†ˆë†‰ë†‹ë†ë†’ë†“ë†”ë†˜ë†œë†¨ë‡Œë‡ë‡”ë‡œë‡"],["b441","í€®",5,"í€¶í€·í€¹í€ºí€»í€½",6,"í†íˆíŠ",5],["b461","í‘í’í“í•í–í—í™",6,"í¡",10,"í®í¯"],["b481","í±í²í³íµ",6,"í¾í¿í‚€í‚‚",18,"ë‡Ÿë‡¨ë‡©ë‡¬ë‡°ë‡¹ë‡»ë‡½ëˆ„ëˆ…ëˆˆëˆ‹ëˆŒëˆ”ëˆ•ëˆ—ëˆ™ëˆ ëˆ´ëˆ¼ë‰˜ë‰œë‰ ë‰¨ë‰©ë‰´ë‰µë‰¼ëŠ„ëŠ…ëŠ‰ëŠëŠ‘ëŠ”ëŠ˜ëŠ™ëŠšëŠ ëŠ¡ëŠ£ëŠ¥ëŠ¦ëŠªëŠ¬ëŠ°ëŠ´ë‹ˆë‹‰ë‹Œë‹ë‹’ë‹˜ë‹™ë‹›ë‹ë‹¢ë‹¤ë‹¥ë‹¦ë‹¨ë‹«",4,"ë‹³ë‹´ë‹µë‹·",4,"ë‹¿ëŒ€ëŒëŒ„ëŒˆëŒëŒ‘ëŒ“ëŒ”ëŒ•ëŒœë”ë•ë–ë˜ë›ëœëžëŸë¤ë¥"],["b541","í‚•",14,"í‚¦í‚§í‚©í‚ªí‚«í‚­",5],["b561","í‚³í‚¶í‚¸í‚º",5,"íƒ‚íƒƒíƒ…íƒ†íƒ‡íƒŠ",5,"íƒ’íƒ–",4],["b581","íƒ›íƒžíƒŸíƒ¡íƒ¢íƒ£íƒ¥",6,"íƒ®íƒ²",5,"íƒ¹",11,"ë§ë©ë«ë®ë°ë±ë´ë¸ëŽ€ëŽëŽƒëŽ„ëŽ…ëŽŒëŽëŽ”ëŽ ëŽ¡ëŽ¨ëŽ¬ë„ë…ëˆë‹ëŒëŽëë”ë•ë—ë™ë›ëë ë¤ë¨ë¼ëë˜ëœë ë¨ë©ë«ë´ë‘ë‘‘ë‘”ë‘˜ë‘ ë‘¡ë‘£ë‘¥ë‘¬ë’€ë’ˆë’ë’¤ë’¨ë’¬ë’µë’·ë’¹ë“€ë“„ë“ˆë“ë“•ë“œë“ë“ ë“£ë“¤ë“¦ë“¬ë“­ë“¯ë“±ë“¸ë””ë”•ë”˜ë”›ë”œë”¤ë”¥ë”§ë”¨ë”©ë”ªë”°ë”±ë”´ë”¸"],["b641","í„…",7,"í„Ž",17],["b661","í„ ",15,"í„²í„³í„µí„¶í„·í„¹í„»í„¼í„½í„¾"],["b681","í„¿í…‚í…†",5,"í…Ží…í…‘í…’í…“í…•",6,"í…ží… í…¢",5,"í…©í…ªí…«í…­ë•€ë•ë•ƒë•„ë•…ë•‹ë•Œë•ë•ë•”ë•œë•ë•Ÿë• ë•¡ë– ë–¡ë–¤ë–¨ë–ªë–«ë–°ë–±ë–³ë–´ë–µë–»ë–¼ë–½ë—€ë—„ë—Œë—ë—ë—ë—‘ë—˜ë—¬ë˜ë˜‘ë˜”ë˜˜ë˜¥ë˜¬ë˜´ë™ˆë™¤ë™¨ëšœëšëš ëš¤ëš«ëš¬ëš±ë›”ë›°ë›´ë›¸ëœ€ëœëœ…ëœ¨ëœ©ëœ¬ëœ¯ëœ°ëœ¸ëœ¹ëœ»ë„ëˆëŒë”ë•ë ë¤ë¨ë°ë±ë³ëµë¼ë½ëž€ëž„ëžŒëžëžëžëž‘ëž’ëž–ëž—"],["b741","í…®",13,"í…½",6,"í†…í††í†‡í†‰í†Š"],["b761","í†‹",20,"í†¢í†£í†¥í†¦í†§"],["b781","í†©",6,"í†²í†´í†¶í†·í†¸í†¹í†»í†½í†¾í†¿í‡",14,"ëž˜ëž™ëžœëž ëž¨ëž©ëž«ëž¬ëž­ëž´ëžµëž¸ëŸ‡ëŸ‰ëŸ¬ëŸ­ëŸ°ëŸ´ëŸ¼ëŸ½ëŸ¿ë €ë ë ‡ë ˆë ‰ë Œë ë ˜ë ™ë ›ë ë ¤ë ¥ë ¨ë ¬ë ´ë µë ·ë ¸ë ¹ë¡€ë¡„ë¡‘ë¡“ë¡œë¡ë¡ ë¡¤ë¡¬ë¡­ë¡¯ë¡±ë¡¸ë¡¼ë¢ë¢¨ë¢°ë¢´ë¢¸ë£€ë£ë£ƒë£…ë£Œë£ë£”ë£ë£Ÿë£¡ë£¨ë£©ë£¬ë£°ë£¸ë£¹ë£»ë£½ë¤„ë¤˜ë¤ ë¤¼ë¤½ë¥€ë¥„ë¥Œë¥ë¥‘ë¥˜ë¥™ë¥œë¥ ë¥¨ë¥©"],["b841","í‡",7,"í‡™",17],["b861","í‡«",8,"í‡µí‡¶í‡·í‡¹",13],["b881","íˆˆíˆŠ",5,"íˆ‘",24,"ë¥«ë¥­ë¥´ë¥µë¥¸ë¥¼ë¦„ë¦…ë¦‡ë¦‰ë¦Šë¦ë¦Žë¦¬ë¦­ë¦°ë¦´ë¦¼ë¦½ë¦¿ë§ë§ˆë§‰ë§Œë§Ž",4,"ë§˜ë§™ë§›ë§ë§žë§¡ë§£ë§¤ë§¥ë§¨ë§¬ë§´ë§µë§·ë§¸ë§¹ë§ºë¨€ë¨ë¨ˆë¨•ë¨¸ë¨¹ë¨¼ë©€ë©‚ë©ˆë©‰ë©‹ë©ë©Žë©“ë©”ë©•ë©˜ë©œë©¤ë©¥ë©§ë©¨ë©©ë©°ë©±ë©´ë©¸ëªƒëª„ëª…ëª‡ëªŒëª¨ëª©ëª«ëª¬ëª°ëª²ëª¸ëª¹ëª»ëª½ë«„ë«ˆë«˜ë«™ë«¼"],["b941","íˆªíˆ«íˆ®íˆ¯íˆ±íˆ²íˆ³íˆµ",6,"íˆ¾í‰€í‰‚",5,"í‰‰í‰Ší‰‹í‰Œ"],["b961","í‰",14,"í‰",6,"í‰¥í‰¦í‰§í‰¨"],["b981","í‰©",22,"íŠ‚íŠƒíŠ…íŠ†íŠ‡íŠ‰íŠŠíŠ‹íŠŒë¬€ë¬„ë¬ë¬ë¬‘ë¬˜ë¬œë¬ ë¬©ë¬«ë¬´ë¬µë¬¶ë¬¸ë¬»ë¬¼ë¬½ë¬¾ë­„ë­…ë­‡ë­‰ë­ë­ë­ë­”ë­˜ë­¡ë­£ë­¬ë®ˆë®Œë®ë®¤ë®¨ë®¬ë®´ë®·ë¯€ë¯„ë¯ˆë¯ë¯“ë¯¸ë¯¹ë¯¼ë¯¿ë°€ë°‚ë°ˆë°‰ë°‹ë°Œë°ë°ë°‘ë°”",4,"ë°›",4,"ë°¤ë°¥ë°§ë°©ë°­ë°°ë°±ë°´ë°¸ë±€ë±ë±ƒë±„ë±…ë±‰ë±Œë±ë±ë±ë²„ë²…ë²ˆë²‹ë²Œë²Žë²”ë²•ë²—"],["ba41","íŠíŠŽíŠíŠ’íŠ“íŠ”íŠ–",5,"íŠíŠžíŠŸíŠ¡íŠ¢íŠ£íŠ¥",6,"íŠ­"],["ba61","íŠ®íŠ¯íŠ°íŠ²",5,"íŠºíŠ»íŠ½íŠ¾í‹í‹ƒ",4,"í‹Ší‹Œ",5],["ba81","í‹’í‹“í‹•í‹–í‹—í‹™í‹ší‹›í‹",6,"í‹¦",9,"í‹²í‹³í‹µí‹¶í‹·í‹¹í‹ºë²™ë²šë² ë²¡ë²¤ë²§ë²¨ë²°ë²±ë²³ë²´ë²µë²¼ë²½ë³€ë³„ë³ë³ë³ë³‘ë³•ë³˜ë³œë³´ë³µë³¶ë³¸ë³¼ë´„ë´…ë´‡ë´‰ë´ë´”ë´¤ë´¬ëµ€ëµˆëµ‰ëµŒëµëµ˜ëµ™ëµ¤ëµ¨ë¶€ë¶ë¶„ë¶‡ë¶ˆë¶‰ë¶Šë¶ë¶‘ë¶“ë¶•ë¶™ë¶šë¶œë¶¤ë¶°ë¶¸ë·”ë·•ë·˜ë·œë·©ë·°ë·´ë·¸ë¸€ë¸ƒë¸…ë¸Œë¸ë¸ë¸”ë¸œë¸ë¸Ÿë¹„ë¹…ë¹ˆë¹Œë¹Žë¹”ë¹•ë¹—ë¹™ë¹šë¹›ë¹ ë¹¡ë¹¤"],["bb41","í‹»",4,"íŒ‚íŒ„íŒ†",5,"íŒíŒ‘íŒ’íŒ“íŒ•íŒ—",4,"íŒžíŒ¢íŒ£"],["bb61","íŒ¤íŒ¦íŒ§íŒªíŒ«íŒ­íŒ®íŒ¯íŒ±",6,"íŒºíŒ¾",5,"í†í‡íˆí‰"],["bb81","íŠ",31,"ë¹¨ë¹ªë¹°ë¹±ë¹³ë¹´ë¹µë¹»ë¹¼ë¹½ëº€ëº„ëºŒëºëºëºëº‘ëº˜ëº™ëº¨ë»ë»‘ë»”ë»—ë»˜ë» ë»£ë»¤ë»¥ë»¬ë¼ë¼ˆë¼‰ë¼˜ë¼™ë¼›ë¼œë¼ë½€ë½ë½„ë½ˆë½ë½‘ë½•ë¾”ë¾°ë¿…ë¿Œë¿ë¿ë¿”ë¿œë¿Ÿë¿¡ì€¼ì‘ì˜ìœì ì¨ì©ì‚ì‚‘ì‚”ì‚˜ì‚ ì‚¡ì‚£ì‚¥ì‚¬ì‚­ì‚¯ì‚°ì‚³ì‚´ì‚µì‚¶ì‚¼ì‚½ì‚¿ìƒ€ìƒìƒ…ìƒˆìƒ‰ìƒŒìƒìƒ˜ìƒ™ìƒ›ìƒœìƒìƒ¤"],["bc41","íª",17,"í¾í¿íŽíŽ‚íŽƒíŽ…íŽ†íŽ‡"],["bc61","íŽˆíŽ‰íŽŠíŽ‹íŽŽíŽ’",5,"íŽšíŽ›íŽíŽžíŽŸíŽ¡",6,"íŽªíŽ¬íŽ®"],["bc81","íŽ¯",4,"íŽµíŽ¶íŽ·íŽ¹íŽºíŽ»íŽ½",6,"í†í‡íŠ",5,"í‘",5,"ìƒ¥ìƒ¨ìƒ¬ìƒ´ìƒµìƒ·ìƒ¹ì„€ì„„ì„ˆì„ì„•ì„œ",4,"ì„£ì„¤ì„¦ì„§ì„¬ì„­ì„¯ì„°ì„±ì„¶ì„¸ì„¹ì„¼ì…€ì…ˆì…‰ì…‹ì…Œì…ì…”ì…•ì…˜ì…œì…¤ì…¥ì…§ì…¨ì…©ì…°ì…´ì…¸ì†…ì†Œì†ì†Žì†ì†”ì†–ì†œì†ì†Ÿì†¡ì†¥ì†¨ì†©ì†¬ì†°ì†½ì‡„ì‡ˆì‡Œì‡”ì‡—ì‡˜ì‡ ì‡¤ì‡¨ì‡°ì‡±ì‡³ì‡¼ì‡½ìˆ€ìˆ„ìˆŒìˆìˆìˆ‘ìˆ˜ìˆ™ìˆœìˆŸìˆ ìˆ¨ìˆ©ìˆ«ìˆ­"],["bd41","í—í™",7,"í¢í¤",7,"í®í¯í±í²í³íµí¶í·"],["bd61","í¸í¹íºí»í¾í€í‚",5,"í‰",13],["bd81","í—",5,"íž",25,"ìˆ¯ìˆ±ìˆ²ìˆ´ì‰ˆì‰ì‰‘ì‰”ì‰˜ì‰ ì‰¥ì‰¬ì‰­ì‰°ì‰´ì‰¼ì‰½ì‰¿ìŠìŠˆìŠ‰ìŠìŠ˜ìŠ›ìŠìŠ¤ìŠ¥ìŠ¨ìŠ¬ìŠ­ìŠ´ìŠµìŠ·ìŠ¹ì‹œì‹ì‹ ì‹£ì‹¤ì‹«ì‹¬ì‹­ì‹¯ì‹±ì‹¶ì‹¸ì‹¹ì‹»ì‹¼ìŒ€ìŒˆìŒ‰ìŒŒìŒìŒ“ìŒ”ìŒ•ìŒ˜ìŒœìŒ¤ìŒ¥ìŒ¨ìŒ©ì…ì¨ì©ì¬ì°ì²ì¸ì¹ì¼ì½ìŽ„ìŽˆìŽŒì€ì˜ì™ìœìŸì ì¢ì¨ì©ì­ì´ìµì¸ìˆìì¤ì¬ì°"],["be41","í¸",7,"í‘í‘‚í‘ƒí‘…",14],["be61","í‘”",7,"í‘í‘ží‘Ÿí‘¡í‘¢í‘£í‘¥",7,"í‘®í‘°í‘±í‘²"],["be81","í‘³",4,"í‘ºí‘»í‘½í‘¾í’í’ƒ",4,"í’Ší’Œí’Ž",5,"í’•",8,"ì´ì¼ì½ì‘ˆì‘¤ì‘¥ì‘¨ì‘¬ì‘´ì‘µì‘¹ì’€ì’”ì’œì’¸ì’¼ì“©ì“°ì“±ì“´ì“¸ì“ºì“¿ì”€ì”ì”Œì”ì””ì”œì”¨ì”©ì”¬ì”°ì”¸ì”¹ì”»ì”½ì•„ì•…ì•ˆì•‰ì•Šì•Œì•ì•Žì•“ì•”ì••ì•—ì•˜ì•™ì•ì•žì• ì•¡ì•¤ì•¨ì•°ì•±ì•³ì•´ì•µì•¼ì•½ì–€ì–„ì–‡ì–Œì–ì–ì–‘ì–•ì–—ì–˜ì–œì– ì–©ì–´ì–µì–¸ì–¹ì–»ì–¼ì–½ì–¾ì—„",6,"ì—Œì—Ž"],["bf41","í’ž",10,"í’ª",14],["bf61","í’¹",18,"í“í“Ží“í“‘í“’í““í“•"],["bf81","í“–",5,"í“í“ží“ ",7,"í“©í“ªí“«í“­í“®í“¯í“±",6,"í“¹í“ºí“¼ì—ì—‘ì—”ì—˜ì— ì—¡ì—£ì—¥ì—¬ì—­ì—®ì—°ì—´ì—¶ì—·ì—¼",5,"ì˜…ì˜†ì˜‡ì˜ˆì˜Œì˜ì˜˜ì˜™ì˜›ì˜œì˜¤ì˜¥ì˜¨ì˜¬ì˜­ì˜®ì˜°ì˜³ì˜´ì˜µì˜·ì˜¹ì˜»ì™€ì™ì™„ì™ˆì™ì™‘ì™“ì™”ì™•ì™œì™ì™ ì™¬ì™¯ì™±ì™¸ì™¹ì™¼ìš€ìšˆìš‰ìš‹ìšìš”ìš•ìš˜ìšœìš¤ìš¥ìš§ìš©ìš°ìš±ìš´ìš¸ìš¹ìšºì›€ì›ì›ƒì›…ì›Œì›ì›ì›”ì›œì›ì› ì›¡ì›¨"],["c041","í“¾",5,"í”…í”†í”‡í”‰í”Ší”‹í”",6,"í”–í”˜",5],["c061","í”ž",25],["c081","í”¸í”¹í”ºí”»í”¾í”¿í•í•‚í•ƒí•…",6,"í•Ží•í•’",5,"í•ší•›í•í•ží•Ÿí•¡í•¢í•£ì›©ì›¬ì›°ì›¸ì›¹ì›½ìœ„ìœ…ìœˆìœŒìœ”ìœ•ìœ—ìœ™ìœ ìœ¡ìœ¤ìœ¨ìœ°ìœ±ìœ³ìœµìœ·ìœ¼ìœ½ì€ì„ìŠìŒììì‘",7,"ìœì ì¨ì«ì´ìµì¸ì¼ì½ì¾ìžƒìž„ìž…ìž‡ìžˆìž‰ìžŠìžŽìžìž‘ìž”ìž–ìž—ìž˜ìžšìž ìž¡ìž£ìž¤ìž¥ìž¦ìž¬ìž­ìž°ìž´ìž¼ìž½ìž¿ìŸ€ìŸìŸˆìŸ‰ìŸŒìŸŽìŸìŸ˜ìŸìŸ¤ìŸ¨ìŸ¬ì €ì ì „ì ˆì Š"],["c141","í•¤í•¦í•§í•ªí•¬í•®",5,"í•¶í•·í•¹í•ºí•»í•½",6,"í–†í–Ší–‹"],["c161","í–Œí–í–Ží–í–‘",19,"í–¦í–§"],["c181","í–¨",31,"ì ì ‘ì “ì •ì –ì œì ì  ì ¤ì ¬ì ­ì ¯ì ±ì ¸ì ¼ì¡€ì¡ˆì¡‰ì¡Œì¡ì¡”ì¡°ì¡±ì¡´ì¡¸ì¡ºì¢€ì¢ì¢ƒì¢…ì¢†ì¢‡ì¢‹ì¢Œì¢ì¢”ì¢ì¢Ÿì¢¡ì¢¨ì¢¼ì¢½ì£„ì£ˆì£Œì£”ì£•ì£—ì£™ì£ ì£¡ì£¤ì£µì£¼ì£½ì¤€ì¤„ì¤…ì¤†ì¤Œì¤ì¤ì¤‘ì¤˜ì¤¬ì¤´ì¥ì¥‘ì¥”ì¥˜ì¥ ì¥¡ì¥£ì¥¬ì¥°ì¥´ì¥¼ì¦ˆì¦‰ì¦Œì¦ì¦˜ì¦™ì¦›ì¦ì§€ì§ì§„ì§‡ì§ˆì§Šì§ì§‘ì§“"],["c241","í—Ší—‹í—í—Ží—í—‘í—“",4,"í—ší—œí—ž",5,"í—¦í—§í—©í—ªí—«í—­í—®"],["c261","í—¯",4,"í—¶í—¸í—º",5,"í˜‚í˜ƒí˜…í˜†í˜‡í˜‰",6,"í˜’"],["c281","í˜–",5,"í˜í˜ží˜Ÿí˜¡í˜¢í˜£í˜¥",7,"í˜®",9,"í˜ºí˜»ì§•ì§–ì§™ì§šì§œì§ì§ ì§¢ì§¤ì§§ì§¬ì§­ì§¯ì§°ì§±ì§¸ì§¹ì§¼ì¨€ì¨ˆì¨‰ì¨‹ì¨Œì¨ì¨”ì¨˜ì¨©ì©Œì©ì©ì©”ì©œì©ì©Ÿì© ì©¡ì©¨ì©½ìª„ìª˜ìª¼ìª½ì«€ì«„ì«Œì«ì«ì«‘ì«“ì«˜ì«™ì« ì«¬ì«´ì¬ˆì¬ì¬”ì¬˜ì¬ ì¬¡ì­ì­ˆì­‰ì­Œì­ì­˜ì­™ì­ì­¤ì­¸ì­¹ì®œì®¸ì¯”ì¯¤ì¯§ì¯©ì°Œì°ì°ì°”ì°œì°ì°¡ì°¢ì°§ì°¨ì°©ì°¬ì°®ì°°ì°¸ì°¹ì°»"],["c341","í˜½í˜¾í˜¿í™í™‚í™ƒí™„í™†í™‡í™Ší™Œí™Ží™í™í™’í™“í™–í™—í™™í™ší™›í™",4],["c361","í™¢",4,"í™¨í™ª",5,"í™²í™³í™µ",11],["c381","íšíš‚íš„íš†",5,"íšŽíšíš‘íš’íš“íš•",7,"íšžíš íš¢",5,"íš©íšªì°¼ì°½ì°¾ì±„ì±…ì±ˆì±Œì±”ì±•ì±—ì±˜ì±™ì± ì±¤ì±¦ì±¨ì±°ì±µì²˜ì²™ì²œì² ì²¨ì²©ì²«ì²¬ì²­ì²´ì²µì²¸ì²¼ì³„ì³…ì³‡ì³‰ì³ì³”ì³¤ì³¬ì³°ì´ì´ˆì´‰ì´Œì´ì´˜ì´™ì´›ì´ì´¤ì´¨ì´¬ì´¹ìµœìµ ìµ¤ìµ¬ìµ­ìµ¯ìµ±ìµ¸ì¶ˆì¶”ì¶•ì¶˜ì¶œì¶¤ì¶¥ì¶§ì¶©ì¶°ì·„ì·Œì·ì·¨ì·¬ì·°ì·¸ì·¹ì·»ì·½ì¸„ì¸ˆì¸Œì¸”ì¸™ì¸ ì¸¡ì¸¤ì¸¨ì¸°ì¸±ì¸³ì¸µ"],["c441","íš«íš­íš®íš¯íš±",7,"íšºíš¼",7,"í›†í›‡í›‰í›Ší›‹"],["c461","í›í›Ží›í›í›’í›“í›•í›–í›˜í›š",5,"í›¡í›¢í›£í›¥í›¦í›§í›©",4],["c481","í›®í›¯í›±í›²í›³í›´í›¶",5,"í›¾í›¿íœíœ‚íœƒíœ…",11,"íœ’íœ“íœ”ì¹˜ì¹™ì¹œì¹Ÿì¹ ì¹¡ì¹¨ì¹©ì¹«ì¹­ì¹´ì¹µì¹¸ì¹¼ìº„ìº…ìº‡ìº‰ìºìº‘ìº”ìº˜ìº ìº¡ìº£ìº¤ìº¥ìº¬ìº­ì»ì»¤ì»¥ì»¨ì»«ì»¬ì»´ì»µì»·ì»¸ì»¹ì¼€ì¼ì¼„ì¼ˆì¼ì¼‘ì¼“ì¼•ì¼œì¼ ì¼¤ì¼¬ì¼­ì¼¯ì¼°ì¼±ì¼¸ì½”ì½•ì½˜ì½œì½¤ì½¥ì½§ì½©ì½°ì½±ì½´ì½¸ì¾€ì¾…ì¾Œì¾¡ì¾¨ì¾°ì¿„ì¿ ì¿¡ì¿¤ì¿¨ì¿°ì¿±ì¿³ì¿µì¿¼í€€í€„í€‘í€˜í€­í€´í€µí€¸í€¼"],["c541","íœ•íœ–íœ—íœšíœ›íœíœžíœŸíœ¡",6,"íœªíœ¬íœ®",5,"íœ¶íœ·íœ¹"],["c561","íœºíœ»íœ½",6,"í…í†íˆíŠ",5,"í’í“í•íš",4],["c581","íŸí¢í¤í¦í§í¨íªí«í­í®í¯í±í²í³íµ",6,"í¾í¿íž€íž‚",5,"ížŠíž‹í„í…í‡í‰íí”í˜í í¬í­í°í´í¼í½í‚í‚¤í‚¥í‚¨í‚¬í‚´í‚µí‚·í‚¹íƒ€íƒíƒ„íƒˆíƒ‰íƒíƒ‘íƒ“íƒ”íƒ•íƒœíƒíƒ íƒ¤íƒ¬íƒ­íƒ¯íƒ°íƒ±íƒ¸í„í„°í„±í„´í„¸í„ºí…€í…í…ƒí…„í……í…Œí…í…í…”í…œí…í…Ÿí…¡í…¨í…¬í…¼í†„í†ˆí† í†¡í†¤í†¨í†°í†±í†³í†µí†ºí†¼í‡€í‡˜í‡´í‡¸íˆ‡íˆ‰íˆíˆ¬íˆ­íˆ°íˆ´íˆ¼íˆ½íˆ¿í‰í‰ˆí‰œ"],["c641","ížížŽížíž‘",6,"ížšížœížž",5],["c6a1","í‰¤íŠ€íŠíŠ„íŠˆíŠíŠ‘íŠ•íŠœíŠ íŠ¤íŠ¬íŠ±íŠ¸íŠ¹íŠ¼íŠ¿í‹€í‹‚í‹ˆí‹‰í‹‹í‹”í‹˜í‹œí‹¤í‹¥í‹°í‹±í‹´í‹¸íŒ€íŒíŒƒíŒ…íŒŒíŒíŒŽíŒíŒ”íŒ–íŒœíŒíŒŸíŒ íŒ¡íŒ¥íŒ¨íŒ©íŒ¬íŒ°íŒ¸íŒ¹íŒ»íŒ¼íŒ½í„í…í¼í½íŽ€íŽ„íŽŒíŽíŽíŽíŽ‘íŽ˜íŽ™íŽœíŽ íŽ¨íŽ©íŽ«íŽ­íŽ´íŽ¸íŽ¼í„í…íˆí‰íí˜í¡í£í¬í­í°í´í¼í½í¿í"],["c7a1","íˆíí‘€í‘„í‘œí‘ í‘¤í‘­í‘¯í‘¸í‘¹í‘¼í‘¿í’€í’‚í’ˆí’‰í’‹í’í’”í’©í“Œí“í“”í“œí“Ÿí“¨í“¬í“°í“¸í“»í“½í”„í”ˆí”Œí””í”•í”—í”¼í”½í•€í•„í•Œí•í•í•‘í•˜í•™í•œí• í•¥í•¨í•©í•«í•­í•´í•µí•¸í•¼í–„í–…í–‡í–ˆí–‰í–í–¥í—ˆí—‰í—Œí—í—’í—˜í—™í—›í—í—¤í—¥í—¨í—¬í—´í—µí—·í—¹í˜€í˜í˜„í˜ˆí˜í˜‘í˜“í˜”í˜•í˜œí˜ "],["c8a1","í˜¤í˜­í˜¸í˜¹í˜¼í™€í™…í™ˆí™‰í™‹í™í™‘í™”í™•í™˜í™œí™§í™©í™°í™±í™´íšƒíš…íšŒíšíšíš”íšíšŸíš¡íš¨íš¬íš°íš¹íš»í›„í›…í›ˆí›Œí›‘í›”í›—í›™í› í›¤í›¨í›°í›µí›¼í›½íœ€íœ„íœ‘íœ˜íœ™íœœíœ íœ¨íœ©íœ«íœ­íœ´íœµíœ¸íœ¼í„í‡í‰íí‘í”í–í—í˜í™í í¡í£í¥í©í¬í°í´í¼í½ížížˆíž‰ížŒížíž˜íž™íž›íž"],["caa1","ä¼½ä½³å‡åƒ¹åŠ å¯å‘µå“¥å˜‰å«å®¶æš‡æž¶æž·æŸ¯æ­Œç‚ç—‚ç¨¼è‹›èŒ„è¡—è¢ˆè¨¶è³ˆè·è»»è¿¦é§•åˆ»å´å„æªæ…¤æ®¼çè„šè¦ºè§’é–£ä¾ƒåˆŠå¢¾å¥¸å§¦å¹²å¹¹æ‡‡æ€æ†æŸ¬æ¡¿æ¾—ç™Žçœ‹ç£µç¨ˆç«¿ç°¡è‚è‰®è‰±è««é–“ä¹«å–æ›·æ¸´ç¢£ç«­è‘›è¤èŽéž¨å‹˜åŽå ªåµŒæ„Ÿæ†¾æˆ¡æ•¢æŸ‘æ©„æ¸›ç”˜ç–³ç›£çž°ç´ºé‚¯é‘‘é‘’é¾•"],["cba1","åŒ£å²¬ç”²èƒ›é‰€é–˜å‰›å ˆå§œå²¡å´—åº·å¼ºå½Šæ…·æ±Ÿç•ºç–†ç³ çµ³ç¶±ç¾Œè…”èˆ¡è–‘è¥è¬›é‹¼é™é±‡ä»‹ä»·å€‹å‡±å¡æ„·æ„¾æ…¨æ”¹æ§ªæ¼‘ç–¥çš†ç›–ç®‡èŠ¥è“‹ï¤€éŽ§é–‹å–€å®¢å‘ï¤ç²³ç¾¹é†µå€¨åŽ»å±…å·¨æ‹’æ®æ“šæ“§æ¸ ç‚¬ç¥›è·è¸žï¤‚é½é‰…é‹¸ä¹¾ä»¶å¥å·¾å»ºæ„†æ¥—è…±è™”è¹‡éµé¨«ä¹žå‚‘æ°æ¡€å„‰åŠåŠ’æª¢"],["cca1","çž¼éˆé»”åŠ«æ€¯è¿²åˆæ†©æ­æ“Šæ ¼æª„æ¿€è†ˆè¦¡éš”å …ç‰½çŠ¬ç”„çµ¹ç¹­è‚©è¦‹è­´é£éµ‘æŠ‰æ±ºæ½”çµç¼ºè¨£å…¼æ…Šç®è¬™é‰—éŽŒäº¬ä¿“å€žå‚¾å„†å‹å‹å¿å°å¢ƒåºšå¾‘æ…¶æ†¬æ“Žæ•¬æ™¯æš»æ›´æ¢—æ¶‡ç‚…çƒ±ç’Ÿç’¥ç“Šç—™ç¡¬ç£¬ç«Ÿç«¶çµ…ç¶“è€•è€¿è„›èŽ–è­¦è¼•é€•é¡é ƒé ¸é©šé¯¨ä¿‚å•“å ºå¥‘å­£å±†æ‚¸æˆ’æ¡‚æ¢°"],["cda1","æ£¨æºªç•Œç™¸ç£Žç¨½ç³»ç¹«ç¹¼è¨ˆèª¡è°¿éšŽé·„å¤å©å‘Šå‘±å›ºå§‘å­¤å°»åº«æ‹·æ”·æ•…æ•²æš æž¯æ§æ²½ç—¼çšç¾ç¨¿ç¾”è€ƒè‚¡è†è‹¦è‹½è°è—è ±è¢´èª¥ï¤ƒè¾œéŒ®é›‡é¡§é«˜é¼“å“­æ–›æ›²æ¢ç©€è°·éµ å›°å¤å´‘æ˜†æ¢±æ£æ»¾ç¨è¢žé¯¤æ±¨ï¤„éª¨ä¾›å…¬å…±åŠŸå­”å·¥ææ­æ‹±æŽ§æ”»ç™ç©ºèš£è²¢éžä¸²å¯¡æˆˆæžœç“œ"],["cea1","ç§‘è“èª‡èª²è·¨éŽé‹é¡†å»“æ§¨è—¿éƒ­ï¤…å† å®˜å¯¬æ…£æ£ºæ¬¾çŒç¯ç“˜ç®¡ç½è…è§€è²«é—œé¤¨åˆ®ææ‹¬é€‚ä¾Šå…‰åŒ¡å£™å»£æ› æ´¸ç‚šç‹‚ç–ç­èƒ±é‘›å¦æŽ›ç½«ä¹–å‚€å¡Šå£žæ€ªæ„§æ‹æ§é­å®ç´˜è‚±è½Ÿäº¤åƒ‘å’¬å–¬å¬Œå¶ å·§æ”ªæ•Žæ ¡æ©‹ç‹¡çšŽçŸ¯çµžç¿¹è† è•Žè›Ÿè¼ƒè½ŽéƒŠé¤ƒé©•é®«ä¸˜ä¹…ä¹ä»‡ä¿±å…·å‹¾"],["cfa1","å€å£å¥å’Žå˜”åµåž¢å¯‡å¶‡å»æ‡¼æ‹˜æ•‘æž¸æŸ©æ§‹æ­æ¯†æ¯¬æ±‚æºç¸ç‹—çŽ–çƒçž¿çŸ©ç©¶çµ¿è€‰è‡¼èˆ…èˆŠè‹Ÿè¡¢è¬³è³¼è»€é€‘é‚±é‰¤éŠ¶é§’é©…é³©é·—é¾œåœ‹å±€èŠéž éž«éº´å›çª˜ç¾¤è£™è»éƒ¡å €å±ˆæŽ˜çªŸå®®å¼“ç©¹çª®èŠŽèº¬å€¦åˆ¸å‹¸å·åœˆæ‹³æ²æ¬Šæ·ƒçœ·åŽ¥ç—è•¨è¹¶é—•æœºæ«ƒæ½°è©­è»Œé¥‹ï¤†æ™·æ­¸è²´"],["d0a1","é¬¼ï¤‡å«åœ­å¥Žæ†æ§»çªç¡…çªºç«…ç³¾è‘µè¦èµ³é€µé–¨å‹»å‡ç•‡ç­ èŒéˆžï¤ˆæ©˜å…‹å‰‹åŠ‡æˆŸæ£˜æ¥µéš™åƒ…åŠ¤å‹¤æ‡ƒæ–¤æ ¹æ§¿ç‘¾ç­‹èŠ¹è«è¦²è¬¹è¿‘é¥‰ï¤‰ä»Šå¦—æ“’æ˜‘æªŽç´ç¦ç¦½èŠ©è¡¾è¡¿è¥Ÿï¤ŠéŒ¦ä¼‹åŠæ€¥æ‰±æ±²ç´šçµ¦äº˜å…¢çŸœè‚¯ä¼ä¼Žå…¶å†€å—œå™¨åœ»åŸºåŸ¼å¤”å¥‡å¦“å¯„å²å´Žå·±å¹¾å¿ŒæŠ€æ——æ—£"],["d1a1","æœžæœŸæžæ£‹æ£„æ©Ÿæ¬ºæ°£æ±½æ²‚æ·‡çŽ˜ç¦çªç’‚ç’£ç•¸ç•¿ç¢ç£¯ç¥ç¥‡ç¥ˆç¥ºç®•ç´€ç¶ºç¾ˆè€†è€­è‚Œè¨˜è­è±ˆèµ·éŒ¡éŒ¤é£¢é¥‘é¨Žé¨é©¥éº’ç·Šä½¶å‰æ‹®æ¡”é‡‘å–«å„ºï¤‹ï¤Œå¨œæ‡¦ï¤æ‹æ‹¿ï¤Ž",5,"é‚£ï¤”",4,"è«¾ï¤™ï¤šï¤›ï¤œæš–ï¤ç…–ï¤žï¤Ÿé›£ï¤ ææºå—ï¤¡æžæ¥ æ¹³ï¤¢ç”·ï¤£ï¤¤ï¤¥"],["d2a1","ç´ï¤¦ï¤§è¡²å›Šå¨˜ï¤¨",4,"ä¹ƒï¤­å…§å¥ˆæŸ°è€ï¤®å¥³å¹´æ’šç§Šå¿µæ¬æ‹ˆæ»å¯§å¯—åŠªï¤¯å¥´å¼©æ€’ï¤°ï¤±ï¤²ç‘™ï¤³",5,"é§‘ï¤¹",10,"æ¿ƒï¥„ï¥…è†¿è¾²æƒ±ï¥†ï¥‡è…¦ï¥ˆï¥‰å°¿ï¥Š",7,"å«©è¨¥æ»ç´ï¥’",5,"èƒ½ï¥˜ï¥™å°¼æ³¥åŒ¿æººå¤šèŒ¶"],["d3a1","ä¸¹äº¶ä½†å–®åœ˜å£‡å½–æ–·æ—¦æª€æ®µæ¹çŸ­ç«¯ç°žç·žè›‹è¢’é„²é›æ’»æ¾¾çºç–¸é”å•–åæ†ºæ“”æ›‡æ·¡æ¹›æ½­æ¾¹ç—°èƒè†½è•è¦ƒè«‡è­šéŒŸæ²“ç•“ç­”è¸éå”å ‚å¡˜å¹¢æˆ‡æ’žæ£ ç•¶ç³–èž³é»¨ä»£åžˆå®å¤§å°å²±å¸¶å¾…æˆ´æ“¡çŽ³è‡ºè¢‹è²¸éšŠé»›å®…å¾·æ‚³å€’åˆ€åˆ°åœ–å µå¡—å°Žå± å³¶å¶‹åº¦å¾’æ‚¼æŒ‘æŽ‰æ—æ¡ƒ"],["d4a1","æ£¹æ«‚æ·˜æ¸¡æ»”æ¿¤ç‡¾ç›œç¹ç¦±ç¨»è„è¦©è³­è·³è¹ˆé€ƒé€”é“éƒ½éé™¶éŸœæ¯’ç€†ç‰˜çŠ¢ç¨ç£ç¦¿ç¯¤çº›è®€å¢©æƒ‡æ•¦æ—½æš¾æ²Œç„žç‡‰è±šé “ä¹­çªä»å†¬å‡å‹•åŒæ†§æ±æ¡æ£Ÿæ´žæ½¼ç–¼çž³ç«¥èƒ´è‘£éŠ…å…œæ–—æœæž“ç—˜ç«‡è³ï¥šè±†é€—é ­å±¯è‡€èŠšéé¯éˆå¾—å¶æ©™ç‡ˆç™»ç­‰è—¤è¬„é„§é¨°å–‡æ‡¶ï¥›ç™©ç¾…"],["d5a1","è˜¿èžºè£¸é‚ï¥œæ´›çƒ™çžçµ¡è½ï¥é…ªé§±ï¥žäº‚åµæ¬„æ¬’ç€¾çˆ›è˜­é¸žå‰Œè¾£åµæ“¥æ”¬æ¬–æ¿«ç±ƒçºœè—è¥¤è¦½æ‹‰è‡˜è Ÿå»Šæœ—æµªç‹¼ç…ç‘¯èž‚éƒžä¾†å´å¾ èŠå†·æŽ ç•¥äº®å€†å…©å‡‰æ¢æ¨‘ç²®ç²±ç³§è‰¯è«’è¼›é‡ä¾¶å„·å‹µå‘‚å»¬æ…®æˆ¾æ—…æ«šæ¿¾ç¤ªè—œè £é–­é©¢é©ªéº—é»ŽåŠ›æ›†æ­·ç€ç¤«è½¢é‚æ†æˆ€æ”£æ¼£"],["d6a1","ç…‰ç’‰ç·´è¯è“®è¼¦é€£éŠå†½åˆ—åŠ£æ´Œçƒˆè£‚å»‰æ–‚æ®®æ¿‚ç°¾çµä»¤ä¼¶å›¹ï¥Ÿå²ºå¶ºæ€œçŽ²ç¬­ç¾šç¿Žè†é€žéˆ´é›¶éˆé ˜é½¡ä¾‹æ¾§ç¦®é†´éš·å‹žï¥ æ’ˆæ“„æ«“æ½žç€˜çˆç›§è€è˜†è™œè·¯è¼…éœ²é­¯é·ºé¹µç¢Œç¥¿ç¶ è‰éŒ„é¹¿éº“è«–å£Ÿå¼„æœ§ç€§ç“ç± è¾å„¡ç€¨ç‰¢ç£Šè³‚è³šè³´é›·äº†åƒšå¯®å»–æ–™ç‡Žç™‚çž­èŠè“¼"],["d7a1","é¼é¬§é¾å£˜å©å±¢æ¨“æ·šæ¼ç˜»ç´¯ç¸·è”žè¤¸é¤é™‹åŠ‰æ—’æŸ³æ¦´æµæºœç€ç‰ç‘ ç•™ç˜¤ç¡«è¬¬é¡žå…­æˆ®é™¸ä¾–å€«å´™æ·ªç¶¸è¼ªå¾‹æ…„æ —ï¥¡éš†å‹’è‚‹å‡œå‡Œæ¥žç¨œç¶¾è±é™µä¿šåˆ©åŽ˜åå”Žå±¥æ‚§æŽæ¢¨æµ¬çŠç‹¸ç†ç’ƒï¥¢ç—¢ç±¬ç½¹ç¾¸èŽ‰è£è£¡é‡Œé‡é›¢é¯‰åæ½¾ç‡ç’˜è—ºèºªéš£é±—éºŸæž—æ·‹ç³è‡¨éœ–ç ¬"],["d8a1","ç«‹ç¬ ç²’æ‘©ç‘ªç—²ç¢¼ç£¨é¦¬é­”éº»å¯žå¹•æ¼ è†œèŽ«é‚ˆä¸‡åå¨©å·’å½Žæ…¢æŒ½æ™©æ›¼æ»¿æ¼«ç£çžžè¬è”“è »è¼“é¥…é°»å”œæŠ¹æœ«æ²«èŒ‰è¥ªéºäº¡å¦„å¿˜å¿™æœ›ç¶²ç½”èŠ’èŒ«èŽ½è¼žé‚™åŸ‹å¦¹åª’å¯æ˜§æžšæ¢…æ¯ç…¤ç½µè²·è³£é‚é­…è„ˆè²Šé™Œé©€éº¥å­Ÿæ°“çŒ›ç›²ç›ŸèŒå†ªè¦“å…å†•å‹‰æ£‰æ²”çœ„çœ ç¶¿ç·¬é¢éºµæ»…"],["d9a1","è”‘å†¥åå‘½æ˜Žæšæ¤§æºŸçš¿çž‘èŒ—è“‚èžŸé…©éŠ˜é³´è¢‚ä¾®å†’å‹Ÿå§†å¸½æ…•æ‘¸æ‘¹æš®æŸæ¨¡æ¯æ¯›ç‰Ÿç‰¡ç‘çœ¸çŸ›è€—èŠ¼èŒ…è¬€è¬¨è²Œæœ¨æ²ç‰§ç›®ç¦ç©†é¶©æ­¿æ²’å¤¢æœ¦è’™å¯å¢“å¦™å»Ÿææ˜´æ³æ¸ºçŒ«ç«—è‹—éŒ¨å‹™å·«æ†®æ‡‹æˆŠæ‹‡æ’«æ— æ¥™æ­¦æ¯‹ç„¡ç·ç•ç¹†èˆžèŒ‚è•ªèª£è²¿éœ§éµ¡å¢¨é»˜å€‘åˆŽå»å•æ–‡"],["daa1","æ±¶ç´Šç´‹èžèšŠé–€é›¯å‹¿æ²•ç‰©å‘³åªšå°¾åµ‹å½Œå¾®æœªæ¢¶æ¥£æ¸¼æ¹„çœ‰ç±³ç¾Žè–‡è¬Žè¿·é¡é»´å²·æ‚¶æ„æ†«æ•æ—»æ—¼æ°‘æ³¯çŽŸç‰ç·¡é–”å¯†èœœè¬å‰åšæ‹ææ’²æœ´æ¨¸æ³Šç€ç’žç®”ç²•ç¸›è†Šèˆ¶è–„è¿«é›¹é§ä¼´åŠåå›æ‹Œæ¬æ”€æ–‘æ§ƒæ³®æ½˜ç­ç•”ç˜¢ç›¤ç›¼ç£ç£»ç¤¬çµ†èˆ¬èŸ è¿”é ’é£¯å‹ƒæ‹”æ’¥æ¸¤æ½‘"],["dba1","ç™¼è·‹é†±é‰¢é«®é­ƒå€£å‚åŠå¦¨å°¨å¹‡å½·æˆ¿æ”¾æ–¹æ—æ˜‰æž‹æ¦œæ»‚ç£…ç´¡è‚ªè†€èˆ«èŠ³è’¡èšŒè¨ªè¬—é‚¦é˜²é¾å€ä¿³ï¥£åŸ¹å¾˜æ‹œæŽ’æ¯æ¹ƒç„™ç›ƒèƒŒèƒšè£´è£µè¤™è³ è¼©é…é™ªä¼¯ä½°å¸›æŸæ ¢ç™½ç™¾é­„å¹¡æ¨Šç…©ç‡”ç•ªï¥¤ç¹è•ƒè—©é£œä¼ç­ç½°é–¥å‡¡å¸†æ¢µæ°¾æ±Žæ³›çŠ¯ç¯„èŒƒæ³•çºåƒ»åŠˆå£æ“˜æª—ç’§ç™–"],["dca1","ç¢§è˜—é—¢éœ¹ï¥¥åžå¼è®Šè¾¨è¾¯é‚Šåˆ¥çž¥é±‰é¼ˆä¸™å€‚å…µå±›å¹·æ˜žæ˜ºæŸ„æ£…ç‚³ç”ç—…ç§‰ç«è¼§é¤ é¨ˆä¿å ¡å ±å¯¶æ™®æ­¥æ´‘æ¹ºæ½½ç¤ç”«è©è£œè¤“è­œè¼”ä¼åƒ•åŒåœå®“å¾©æœç¦è…¹èŒ¯è””è¤‡è¦†è¼¹è¼»é¦¥é°’æœ¬ä¹¶ä¿¸å¥‰å°å³¯å³°æ§æ£’çƒ½ç†¢ç«ç¸«è“¬èœ‚é€¢é‹’é³³ä¸ä»˜ä¿¯å‚…å‰–å‰¯å¦å’åŸ å¤«å©¦"],["dda1","å­šå­µå¯Œåºœï¥¦æ‰¶æ•·æ–§æµ®æº¥çˆ¶ç¬¦ç°¿ç¼¶è…è…‘è†šè‰€èŠ™èŽ©è¨ƒè² è³¦è³»èµ´è¶ºéƒ¨é‡œé˜œé™„é§™é³§åŒ—åˆ†å©å™´å¢³å¥”å¥®å¿¿æ†¤æ‰®æ˜æ±¾ç„šç›†ç²‰ç³žç´›èŠ¬è³é›°ï¥§ä½›å¼—å½¿æ‹‚å´©æœ‹æ£šç¡¼ç¹ƒéµ¬ä¸•å‚™åŒ•åŒªå‘å¦ƒå©¢åº‡æ‚²æ†Šæ‰‰æ‰¹æ–æž‡æ¦§æ¯”æ¯–æ¯—æ¯˜æ²¸ï¥¨çµç—ºç ’ç¢‘ç§•ç§˜ç²ƒç·‹ç¿¡è‚¥"],["dea1","è„¾è‡‚è²èœšè£¨èª¹è­¬è²»é„™éžé£›é¼»åš¬å¬ªå½¬æ–Œæª³æ®¯æµœæ¿±ç€•ç‰çŽ­è²§è³“é »æ†‘æ°·è˜é¨ä¹äº‹äº›ä»•ä¼ºä¼¼ä½¿ä¿Ÿåƒ¿å²å¸å”†å—£å››å£«å¥¢å¨‘å¯«å¯ºå°„å·³å¸«å¾™æ€æ¨æ–œæ–¯æŸ¶æŸ»æ¢­æ­»æ²™æ³—æ¸£ç€‰ç…ç ‚ç¤¾ç¥€ç¥ ç§ç¯©ç´—çµ²è‚†èˆèŽŽè“‘è›‡è£Ÿè©è©žè¬è³œèµ¦è¾­é‚ªé£¼é§Ÿéºå‰Šï¥©æœ”ï¥ª"],["dfa1","å‚˜åˆªå±±æ•£æ±•çŠç”£ç–ç®—è’œé…¸éœ°ä¹·æ’’æ®ºç…žè–©ä¸‰ï¥«æ‰æ£®æ¸—èŠŸè”˜è¡«æ·æ¾éˆ’é¢¯ä¸Šå‚·åƒå„Ÿå•†å–ªå˜—å­€å°™å³ å¸¸åºŠåº å»‚æƒ³æ¡‘æ©¡æ¹˜çˆ½ç‰€ç‹€ç›¸ç¥¥ç®±ç¿”è£³è§´è©³è±¡è³žéœœå¡žç’½è³½å—‡ï¥¬ç©¡ç´¢è‰²ç‰²ç”Ÿç”¥ï¥­ç¬™å¢…å£»å¶¼åºåº¶å¾æ•æŠ’æ¿æ•æš‘æ›™æ›¸æ –æ£²çŠ€ç‘žç­®çµ®ç·–ç½²"],["e0a1","èƒ¥èˆ’è–¯è¥¿èª“é€é‹¤é»é¼ å¤•å¥­å¸­æƒœæ˜”æ™³æžæ±æ·…æ½ŸçŸ³ç¢©è“†é‡‹éŒ«ä»™åƒŠå…ˆå–„å¬‹å®£æ‰‡æ•¾æ—‹æ¸²ç…½çç‘„ç’‡ç’¿ç™¬ç¦ªç·šç¹•ç¾¨è…ºè†³èˆ¹è˜šèŸ¬è©µè·£é¸éŠ‘é¥é¥é®®å¨å±‘æ¥”æ³„æ´©æ¸«èˆŒè–›è¤»è¨­èªªé›ªé½§å‰¡æš¹æ®²çº–èŸ¾è´é–ƒé™æ”æ¶‰ç‡®ï¥®åŸŽå§“å®¬æ€§æƒºæˆæ˜Ÿæ™ŸçŒ©ç¹ç››çœç­¬"],["e1a1","è–è²è…¥èª é†’ä¸–å‹¢æ­²æ´—ç¨…ç¬¹ç´°ï¥¯è²°å¬å˜¯å¡‘å®µå°å°‘å·¢æ‰€æŽƒæ”æ˜­æ¢³æ²¼æ¶ˆæº¯ç€Ÿç‚¤ç‡’ç”¦ç–ç–Žç˜™ç¬‘ç¯ ç°«ç´ ç´¹è”¬è•­è˜‡è¨´é€é¡é‚µéŠ·éŸ¶é¨·ä¿—å±¬æŸæ¶‘ç²ŸçºŒè¬–è´–é€Ÿå­«å·½æè“€éœé£¡çŽ‡å®‹æ‚šæ¾æ·žè¨Ÿèª¦é€é Œåˆ·ï¥°ç‘ç¢ŽéŽ–è¡°é‡—ä¿®å—å—½å›šåž‚å£½å«‚å®ˆå²«å³€å¸¥æ„"],["e2a1","æˆæ‰‹æŽˆæœæ”¶æ•¸æ¨¹æ®Šæ°´æ´™æ¼±ç‡§ç‹©ç¸ç‡ç’²ç˜¦ç¡ç§€ç©—ç«ªç²¹ç¶ç¶¬ç¹¡ç¾žè„©èŒ±è’è“šè—ªè¢–èª°è®è¼¸é‚é‚ƒé…¬éŠ–éŠ¹éš‹éš§éš¨é›–éœ€é ˆé¦–é«“é¬šå”å¡¾å¤™å­°å®¿æ·‘æ½šç†Ÿç¡ç’¹è‚…è½å·¡å¾‡å¾ªæ‚æ—¬æ ’æ¥¯æ©“æ®‰æ´µæ·³ç£ç›¾çž¬ç­ç´”è„£èˆœè€è“´è•£è©¢è«„é†‡éŒžé †é¦´æˆŒè¡“è¿°é‰¥å´‡å´§"],["e3a1","åµ©ç‘Ÿè†è¨æ¿•æ‹¾ç¿’è¤¶è¥²ä¸žä¹˜åƒ§å‹å‡æ‰¿æ˜‡ç¹©è …é™žä¾åŒ™å˜¶å§‹åª¤å°¸å±Žå±å¸‚å¼‘æƒæ–½æ˜¯æ™‚æž¾æŸ´çŒœçŸ¢ç¤ºç¿…è’”è“è¦–è©¦è©©è«¡è±•è±ºåŸ´å¯”å¼æ¯æ‹­æ¤æ®–æ¹œç†„ç¯’è•è­˜è»¾é£Ÿé£¾ä¼¸ä¾ä¿¡å‘»å¨ å®¸æ„¼æ–°æ™¨ç‡¼ç”³ç¥žç´³è…Žè‡£èŽ˜è–ªè—Žèœƒè¨Šèº«è¾›ï¥±è¿…å¤±å®¤å¯¦æ‚‰å¯©å°‹å¿ƒæ²"],["e4a1","ï¥²æ·±ç€‹ç”šèŠ¯è«¶ä»€åï¥³é›™æ°äºžä¿„å…’å•žå¨¥å³¨æˆ‘ç‰™èŠ½èŽªè›¾è¡™è¨é˜¿é›…é¤“é´‰éµå Šå²³å¶½å¹„æƒ¡æ„•æ¡æ¨‚æ¸¥é„‚é”é¡Žé°é½·å®‰å²¸æŒ‰æ™æ¡ˆçœ¼é›éžé¡”é®Ÿæ–¡è¬è»‹é–¼å”µå²©å·–åºµæš—ç™Œè´é—‡å£“æŠ¼ç‹Žé´¨ä»°å¤®æ€æ˜»æ®ƒç§§é´¦åŽ“å“€åŸƒå´–æ„›æ›–æ¶¯ç¢è‰¾éš˜é„åŽ„æ‰¼æŽ–æ¶²ç¸Šè…‹é¡"],["e5a1","æ«»ç½Œé¶¯é¸šä¹Ÿå€»å†¶å¤œæƒ¹æ¶æ¤°çˆºè€¶ï¥´é‡Žå¼±ï¥µï¥¶ç´„è‹¥è‘¯è’»è—¥èºï¥·ä½¯ï¥¸ï¥¹å£¤å­ƒæ™æšæ”˜æ•­æš˜ï¥ºæ¥Šæ¨£æ´‹ç€ç…¬ç—’ç˜ç¦³ç©°ï¥»ç¾Šï¥¼è¥„ï¥½è®“é‡€é™½ï¥¾é¤Šåœ„å¾¡æ–¼æ¼ç˜€ç¦¦èªžé¦­é­šé½¬å„„æ†¶æŠ‘æªè‡†åƒå °å½¦ç„‰è¨€è«ºå­¼è˜–ä¿ºå„¼åš´å¥„æŽ©æ·¹å¶ªæ¥­å††äºˆä½™ï¥¿ï¦€ï¦å¦‚ï¦‚"],["e6a1","ï¦ƒæ­Ÿæ±ï¦„ç’µç¤–ï¦…èˆ‡è‰…èŒ¹è¼¿è½ï¦†é¤˜ï¦‡ï¦ˆï¦‰äº¦ï¦ŠåŸŸå½¹æ˜“ï¦‹ï¦Œç–«ç¹¹è­¯ï¦é€†é©›åš¥å §å§¸å¨Ÿå®´ï¦Žå»¶ï¦ï¦ææŒ»ï¦‘æ¤½æ²‡æ²¿æ¶Žæ¶“æ·µæ¼”ï¦’çƒŸç„¶ç…™ï¦“ç‡ƒç‡•ï¦”ç¡ç¡¯ï¦•ç­µç·£ï¦–ç¸¯ï¦—è¡è»Ÿï¦˜ï¦™ï¦šé‰›ï¦›é³¶ï¦œï¦ï¦žæ‚…æ¶…ï¦Ÿç†±ï¦ ï¦¡é–±åŽ­ï¦¢ï¦£ï¦¤æŸ“ï¦¥ç‚Žç„°ç°è‰¶è‹’"],["e7a1","ï¦¦é–»é«¥é¹½æ›„ï¦§ç‡è‘‰ï¦¨ï¦©å¡‹ï¦ªï¦«å¶¸å½±ï¦¬æ˜ æšŽæ¥¹æ¦®æ°¸æ³³æ¸¶æ½æ¿šç€›ç€¯ç…ç‡Ÿç°ï¦­ç‘›ï¦®ç“”ç›ˆç©Žçº“ï¦¯ï¦°è‹±è© è¿Žï¦±éˆï¦²éœ™ï¦³ï¦´ä¹‚å€ªï¦µåˆˆå¡æ›³æ±­æ¿ŠçŒŠç¿ç©¢èŠ®è—è˜‚ï¦¶è£”è©£è­½è±«ï¦·éŠ³ï¦¸éœ“é äº”ä¼ä¿‰å‚²åˆå¾å³å—šå¡¢å¢ºå¥§å¨›å¯¤æ‚Ÿï¦¹æ‡Šæ•–æ—¿æ™¤æ¢§æ±šæ¾³"],["e8a1","çƒç†¬ç’ç­½èœˆèª¤é°²é¼‡å±‹æ²ƒç„çŽ‰éˆºæº«ç‘¥ç˜Ÿç©©ç¸•è˜Šå…€å£…æ“ç“®ç”•ç™°ç¿é‚•é›é¥”æ¸¦ç“¦çª©çªªè‡¥è›™è¸è¨›å©‰å®Œå®›æ¢¡æ¤€æµ£çŽ©ç“ç¬ç¢—ç·©ç¿«è„˜è…•èŽžè±Œé˜®é ‘æ›°å¾€æ—ºæž‰æ±ªçŽ‹å€­å¨ƒæ­ªçŸ®å¤–åµ¬å·çŒ¥ç•ï¦ºï¦»åƒ¥å‡¹å ¯å¤­å¦–å§šå¯¥ï¦¼ï¦½å¶¢æ‹—æ–æ’“æ“¾ï¦¾æ›œï¦¿æ©ˆï§€ç‡¿ç‘¤ï§"],["e9a1","çªˆçª¯ç¹‡ç¹žè€€è…°ï§‚èŸ¯è¦è¬ é™ï§ƒé‚€é¥’æ…¾æ¬²æµ´ç¸Ÿè¤¥è¾±ä¿‘å‚­å†—å‹‡åŸ‡å¢‰å®¹åº¸æ…‚æ¦•æ¶Œæ¹§æº¶ç†”ç‘¢ç”¨ç”¬è³èŒ¸è“‰è¸ŠéŽ”éžï§„äºŽä½‘å¶å„ªåˆå‹å³å®‡å¯“å°¤æ„šæ†‚æ—´ç‰›çŽ—ç‘€ç›‚ç¥ç¦‘ç¦¹ç´†ç¾½èŠ‹è—•è™žè¿‚é‡éƒµé‡ªéš…é›¨é›©å‹–å½§æ—­æ˜±æ ¯ç…œç¨¶éƒé Šäº‘ï§…æ©’æ®žæ¾ç†‰è€˜èŠ¸è•“"],["eaa1","é‹éš•é›²éŸ»è”šé¬±äºç†Šé›„å…ƒåŽŸå“¡åœ“åœ’åž£åª›å«„å¯ƒæ€¨æ„¿æ´æ²…æ´¹æ¹²æºçˆ°çŒ¿ç‘—è‹‘è¢è½…é ï§†é™¢é¡˜é´›æœˆè¶Šé‰žä½å‰åƒžå±åœå§”å¨å°‰æ…°æšæ¸­çˆ²ç‘‹ç·¯èƒƒèŽè‘¦è”¿èŸè¡›è¤˜è¬‚é•éŸ‹é­ä¹³ä¾‘å„’å…ªï§‡å”¯å–©å­ºå®¥å¹¼å¹½åº¾æ‚ æƒŸæ„ˆæ„‰æ„æ”¸æœ‰ï§ˆæŸ”æŸšï§‰æ¥¡æ¥¢æ²¹æ´§ï§Šæ¸¸ï§‹"],["eba1","æ¿¡çŒ¶çŒ·ï§Œç‘œç”±ï§ç™’ï§Žï§ç¶­è‡¾è¸è£•èª˜è«›è«­è¸°è¹‚éŠé€¾éºé…‰é‡‰é®ï§ï§‘å ‰ï§’æ¯“è‚‰è‚²ï§“ï§”å…å¥«å°¹ï§•ï§–æ½¤çŽ§èƒ¤è´‡ï§—éˆ—é–ï§˜ï§™ï§šï§›è¿æˆŽç€œçµ¨èžï§œåž æ©æ…‡æ®·èª¾éŠ€éš±ä¹™åŸæ·«è”­é™°éŸ³é£®æ–æ³£é‚‘å‡æ‡‰è†ºé·¹ä¾å€šå„€å®œæ„æ‡¿æ“¬æ¤…æ¯…ç–‘çŸ£ç¾©è‰¤è–èŸ»è¡£èª¼"],["eca1","è­°é†«äºŒä»¥ä¼Šï§ï§žå¤·å§¨ï§Ÿå·²å¼›å½›æ€¡ï§ ï§¡ï§¢ï§£çˆ¾ç¥ï§¤ç•°ç—ï§¥ç§»ï§¦è€Œè€³è‚„è‹¡è‘ï§§ï§¨è²½è²³é‚‡ï§©ï§ªé£´é¤Œï§«ï§¬ç€·ç›Šç¿Šç¿Œç¿¼è¬šäººä»åˆƒå°ï§­å’½å› å§»å¯…å¼•å¿æ¹®ï§®ï§¯çµªèŒµï§°èš“èªï§±é­é·ï§²ï§³ä¸€ä½šä½¾å£¹æ—¥æº¢é€¸éŽ°é¦¹ä»»å£¬å¦Šå§™æï§´ï§µç¨”ï§¶èè³ƒå…¥å„"],["eda1","ï§·ï§¸ï§¹ä»å‰©å­•èŠ¿ä»”åˆºå’¨å§‰å§¿å­å­—å­œæ£æ…ˆæ»‹ç‚™ç…®çŽ†ç“·ç–µç£ç´«è€…è‡ªèŒ¨è”—è—‰è«®è³‡é›Œä½œå‹ºåš¼æ–«æ˜¨ç¼ç‚¸çˆµç¶½èŠé…Œé›€éµ²å­±æ£§æ®˜æ½ºç›žå²‘æš«æ½›ç®´ç°ªè ¶é›œä¸ˆä»—åŒ å ´å¢»å£¯å¥¬å°‡å¸³åº„å¼µæŽŒæš²æ–æ¨Ÿæª£æ¬Œæ¼¿ç‰†ï§ºçç’‹ç« ç²§è…¸è‡Ÿè‡§èŽŠè‘¬è”£è–”è—è£è´“é†¬é•·"],["eea1","éšœå†å“‰åœ¨å®°æ‰ææ ½æ¢“æ¸½æ»“ç½ç¸¡è£è²¡è¼‰é½‹é½Žçˆ­ç®è«éŒšä½‡ä½Žå„²å’€å§åº•æŠµæµæ¥®æ¨—æ²®æ¸šç‹™çŒªç–½ç®¸ç´µè‹§è¹è‘—è—·è©›è²¯èº‡é€™é‚¸é›Žé½Ÿå‹£åŠå«¡å¯‚æ‘˜æ•µæ»´ç‹„ï§»çš„ç©ç¬›ç±ç¸¾ç¿Ÿè»è¬«è³Šèµ¤è·¡è¹Ÿè¿ªè¿¹é©é‘ä½ƒä½ºå‚³å…¨å…¸å‰å‰ªå¡¡å¡¼å¥ å°ˆå±•å»›æ‚›æˆ°æ “æ®¿æ°ˆæ¾±"],["efa1","ç…Žç ç”°ç”¸ç•‘ç™²ç­Œç®‹ç®­ç¯†çºè©®è¼¾è½‰éˆ¿éŠ“éŒ¢é«é›»é¡šé¡«é¤žåˆ‡æˆªæŠ˜æµ™ç™¤ç«Šç¯€çµ¶å å²¾åº—æ¼¸ç‚¹ç²˜éœ‘é®Žé»žæŽ¥æ‘ºè¶ä¸äº•äº­åœåµå‘ˆå§ƒå®šå¹€åº­å»·å¾æƒ…æŒºæ”¿æ•´æ—Œæ™¶æ™¸æŸ¾æ¥¨æª‰æ­£æ±€æ·€æ·¨æ¸Ÿæ¹žç€žç‚¡çŽŽç½ç”ºç›ç¢‡ç¦Žç¨‹ç©½ç²¾ç¶Žè‰‡è¨‚è«ªè²žé„­é…Šé‡˜é‰¦é‹ŒéŒ éœ†é–"],["f0a1","éœé ‚é¼Žåˆ¶åŠ‘å•¼å ¤å¸å¼Ÿæ‚Œææ¢¯æ¿Ÿç¥­ç¬¬è‡è–ºè£½è«¸è¹„é†é™¤éš›éœ½é¡Œé½Šä¿Žå…†å‡‹åŠ©å˜²å¼”å½«æŽªæ“æ—©æ™æ›ºæ›¹æœæ¢æ£—æ§½æ¼•æ½®ç…§ç‡¥çˆªç’ªçœºç¥–ç¥šç§Ÿç¨ çª•ç²—ç³Ÿçµ„ç¹°è‚‡è—»èš¤è©”èª¿è¶™èºé€ é­é‡£é˜»é›•é³¥æ—ç°‡è¶³éƒå­˜å°Šå’æ‹™çŒå€§å®—å¾žæ‚°æ…«æ£•æ·™ç®ç¨®çµ‚ç¶œç¸±è…«"],["f1a1","è¸ªè¸µé¾é˜ä½åå·¦åº§æŒ«ç½ªä¸»ä½ä¾åšå§èƒ„å‘ªå‘¨å—¾å¥å®™å·žå»šæ™æœ±æŸ±æ ªæ³¨æ´²æ¹Šæ¾ç‚·ç ç–‡ç±Œç´‚ç´¬ç¶¢èˆŸè››è¨»èª…èµ°èºŠè¼³é€±é…Žé…’é‘„é§ç«¹ç²¥ä¿Šå„å‡†åŸˆå¯¯å³»æ™™æ¨½æµšæº–æ¿¬ç„Œç•¯ç«£è ¢é€¡éµé›‹é§¿èŒä¸­ä»²è¡†é‡å½æ«›æ¥«æ±è‘ºå¢žæ†Žæ›¾æ‹¯çƒç”‘ç—‡ç¹’è’¸è­‰è´ˆä¹‹åª"],["f2a1","å’«åœ°å€å¿—æŒæŒ‡æ‘¯æ”¯æ—¨æ™ºæžæž³æ­¢æ± æ²šæ¼¬çŸ¥ç ¥ç¥‰ç¥—ç´™è‚¢è„‚è‡³èŠèŠ·èœ˜èªŒï§¼è´„è¶¾é²ç›´ç¨™ç¨·ç¹”è·å”‡å—”å¡µæŒ¯æ¢æ™‰æ™‹æ¡­æ¦›æ®„æ´¥æº±çç‘¨ç’¡ç•›ç–¹ç›¡çœžçž‹ç§¦ç¸‰ç¸è‡»è”¯è¢—è¨ºè³‘è»«è¾°é€²éŽ­é™£é™³éœ‡ä¾„å±å§ªå«‰å¸™æ¡Žç“†ç–¾ç§©çª’è†£è›­è³ªè·Œè¿­æ–Ÿæœ•ï§½åŸ·æ½—ç·è¼¯"],["f3a1","é¶é›†å¾µæ‡²æ¾„ä¸”ä¾˜å€Ÿå‰å—Ÿåµ¯å·®æ¬¡æ­¤ç£‹ç®šï§¾è¹‰è»Šé®æ‰æ¾ç€çª„éŒ¯é‘¿é½ªæ’°æ¾¯ç‡¦ç’¨ç“šç«„ç°’çº‚ç²²çº˜è®šè´Šé‘½é¤é¥Œåˆ¹å¯Ÿæ“¦æœ­ç´®åƒ­åƒå¡¹æ…˜æ…™æ‡ºæ–¬ç«™è®’è®–å€‰å€¡å‰µå”±å¨¼å» å½°æ„´æ•žæ˜Œæ˜¶æš¢æ§æ»„æ¼²çŒ–ç˜¡çª“è„¹è‰™è–è’¼å‚µåŸ°å¯€å¯¨å½©æŽ¡ç ¦ç¶µèœè”¡é‡‡é‡µå†ŠæŸµç­–"],["f4a1","è²¬å‡„å¦»æ‚½è™•å€œï§¿å‰”å°ºæ…½æˆšæ‹“æ“²æ–¥æ»Œç˜ è„Šè¹ é™Ÿéš»ä»Ÿåƒå–˜å¤©å·æ“…æ³‰æ·ºçŽ”ç©¿èˆ›è–¦è³¤è¸é·é‡§é—¡é˜¡éŸ†å‡¸å“²å–†å¾¹æ’¤æ¾ˆç¶´è¼Ÿè½éµåƒ‰å°–æ²¾æ·»ç”›çž»ç°½ç±¤è©¹è«‚å žå¦¾å¸–æ·ç‰’ç–Šç«è«œè²¼è¼’å»³æ™´æ·¸è½èè«‹é‘é¯–ï¨€å‰ƒæ›¿æ¶•æ»¯ç· è«¦é€®éžé«”åˆå‰¿å“¨æ†”æŠ„æ‹›æ¢¢"],["f5a1","æ¤’æ¥šæ¨µç‚’ç„¦ç¡ç¤ç¤Žç§’ç¨è‚–è‰¸è‹•è‰è•‰è²‚è¶…é…¢é†‹é†®ä¿ƒå›‘ç‡­çŸ—èœ€è§¸å¯¸å¿–æ‘é‚¨å¢å¡šå¯µæ‚¤æ†æ‘ ç¸½è°è”¥éŠƒæ’®å‚¬å´”æœ€å¢œæŠ½æŽ¨æ¤Žæ¥¸æ¨žæ¹«çšºç§‹èŠ»è©è«è¶¨è¿½é„’é…‹é†œéŒéŒ˜éŽšé››é¨¶é°ä¸‘ç•œç¥ç«ºç­‘ç¯‰ç¸®è“„è¹™è¹´è»¸é€æ˜¥æ¤¿ç‘ƒå‡ºæœ®é»œå……å¿ æ²–èŸ²è¡è¡·æ‚´è†µèƒ"],["f6a1","è´…å–å¹å˜´å¨¶å°±ç‚Šç¿ èšè„†è‡­è¶£é†‰é©Ÿé·²å´ä»„åŽ æƒ»æ¸¬å±¤ä¾ˆå€¤å—¤å³™å¹Ÿæ¥æ¢”æ²»æ·„ç†¾ç—”ç—´ç™¡ç¨šç©‰ç·‡ç·»ç½®è‡´èš©è¼œé›‰é¦³é½’å‰‡å‹…é£­è¦ªä¸ƒæŸ’æ¼†ä¾µå¯¢æž•æ²ˆæµ¸ç›ç §é‡é¼èŸ„ç§¤ç¨±å¿«ä»–å’¤å”¾å¢®å¦¥æƒ°æ‰“æ‹–æœ¶æ¥•èˆµé™€é¦±é§å€¬å“å•„å¼ï¨æ‰˜ï¨‚æ“¢æ™«æŸæ¿æ¿¯ç¢ç¸è¨—"],["f7a1","é¸å‘‘å˜†å¦å½ˆæ†šæ­Žç˜ç‚­ç¶»èª•å¥ªè„«æŽ¢çœˆè€½è²ªå¡”æ­æ¦»å®•å¸‘æ¹¯ï¨ƒè•©å…Œå°å¤ªæ€ æ…‹æ®†æ±°æ³°ç¬žèƒŽè‹”è·†é‚°é¢±ï¨„æ“‡æ¾¤æ’‘æ”„å…ŽååœŸè¨Žæ…Ÿæ¡¶ï¨…ç—›ç­’çµ±é€šå †æ§Œè…¿è¤ªé€€é ¹å¸å¥—å¦¬æŠ•é€é¬ªæ…ç‰¹é—–å¡å©†å·´æŠŠæ’­æ“ºæ·æ³¢æ´¾çˆ¬ç¶ç ´ç½·èŠ­è·›é —åˆ¤å‚æ¿ç‰ˆç“£è²©è¾¦éˆ‘"],["f8a1","é˜ªå…«å­æŒä½©å”„æ‚–æ•—æ²›æµ¿ç‰Œç‹½ç¨—è¦‡è²å½­æ¾Žçƒ¹è†¨æ„Žä¾¿åæ‰ç‰‡ç¯‡ç·¨ç¿©ééž­é¨™è²¶åªå¹³æž°èè©•å å¬–å¹£å»¢å¼Šæ–ƒè‚ºè”½é–‰é™›ä½ˆåŒ…åŒåŒå’†å“ºåœƒå¸ƒæ€–æŠ›æŠ±æ•ï¨†æ³¡æµ¦ç–±ç ²èƒžè„¯è‹žè‘¡è’²è¢è¤’é€‹é‹ªé£½é®‘å¹…æš´æ›ç€‘çˆ†ï¨‡ä¿µå‰½å½ªæ…“æ“æ¨™æ¼‚ç“¢ç¥¨è¡¨è±¹é£‡é£„é©ƒ"],["f9a1","å“ç¨Ÿæ¥“è«·è±Šé¢¨é¦®å½¼æŠ«ç–²çš®è¢«é¿é™‚åŒ¹å¼¼å¿…æ³ŒçŒç•¢ç–‹ç­†è‹¾é¦ä¹é€¼ä¸‹ä½•åŽ¦å¤å»ˆæ˜°æ²³ç‘•è·è¦è³€ééœžé°•å£‘å­¸è™è¬”é¶´å¯’æ¨æ‚æ—±æ±—æ¼¢æ¾£ç€šç½•ç¿°é–‘é–’é™éŸ“å‰²è½„å‡½å«å’¸å•£å–Šæª»æ¶µç·˜è‰¦éŠœé™·é¹¹åˆå“ˆç›’è›¤é–¤é—”é™œäº¢ä¼‰å§®å«¦å··æ’æŠ—æ­æ¡æ²†æ¸¯ç¼¸è‚›èˆª"],["faa1","ï¨ˆï¨‰é …äº¥å•å’³åž“å¥šå­©å®³æ‡ˆæ¥·æµ·ç€£èŸ¹è§£è©²è«§é‚‚é§­éª¸åŠ¾æ ¸å€–å¹¸æè‡è¡Œäº«å‘åš®ç¦é„•éŸ¿é¤‰é¥—é¦™å™“å¢Ÿè™›è¨±æ†²æ«¶ç»è»’æ­‡éšªé©—å¥•çˆ€èµ«é©ä¿”å³´å¼¦æ‡¸æ™›æ³«ç‚«çŽ„çŽ¹ç¾çœ©ççµƒçµ¢ç¸£èˆ·è¡’ï¨Šè³¢é‰‰é¡¯å­‘ç©´è¡€é å«Œä¿ å”å¤¾å³½æŒ¾æµ¹ç‹¹è„…è„‡èŽ¢é‹é °äº¨å…„åˆ‘åž‹"],["fba1","å½¢æ³‚æ»Žç€…çç‚¯ç†’ç©ç‘©èŠèž¢è¡¡é€ˆé‚¢éŽ£é¦¨å…®å½—æƒ æ…§æš³è•™è¹Šé†¯éž‹ä¹Žäº’å‘¼å£•å£ºå¥½å²µå¼§æˆ¶æ‰ˆæ˜Šæ™§æ¯«æµ©æ·æ¹–æ»¸æ¾”æ¿ æ¿©çç‹ç¥ç‘šç“ çš“ç¥œç³Šç¸žèƒ¡èŠ¦è‘«è’¿è™Žè™Ÿè´è­·è±ªéŽ¬é €é¡¥æƒ‘æˆ–é…·å©šæ˜æ··æ¸¾ç¿é­‚å¿½æƒšç¬å“„å¼˜æ±žæ³“æ´ªçƒ˜ç´…è™¹è¨Œé´»åŒ–å’Œå¬…æ¨ºç«ç•µ"],["fca1","ç¦ç¦¾èŠ±è¯è©±è­è²¨é´ï¨‹æ“´æ”«ç¢ºç¢»ç©«ä¸¸å–šå¥å®¦å¹»æ‚£æ›æ­¡æ™¥æ¡“æ¸™ç…¥ç’°ç´ˆé‚„é©©é°¥æ´»æ»‘çŒ¾è±é—Šå‡°å¹Œå¾¨ææƒ¶æ„°æ…Œæ™ƒæ™„æ¦¥æ³æ¹Ÿæ»‰æ½¢ç…Œç’œçš‡ç¯ç°§è’è—é‘éšé»ƒåŒ¯å›žå»»å¾Šæ¢æ‚”æ‡·æ™¦æœƒæªœæ·®æ¾®ç°çªç¹ªè†¾èŒ´è›”èª¨è³„åŠƒç²å®–æ©«é„å“®åš†å­æ•ˆæ–…æ›‰æ¢Ÿæ¶æ·†"],["fda1","çˆ»è‚´é…µé©ä¾¯å€™åŽšåŽå¼å–‰å—…å¸¿å¾Œæœ½ç…¦çé€…å‹›å‹³å¡¤å£Žç„„ç†ç‡»è–°è¨“æšˆè–¨å–§æš„ç…Šè±å‰å–™æ¯å½™å¾½æ®æš‰ç…‡è«±è¼éº¾ä¼‘æºçƒ‹ç•¦è™§æ¤è­Žé·¸å…‡å‡¶åŒˆæ´¶èƒ¸é»‘æ˜•æ¬£ç‚˜ç—•åƒå±¹ç´‡è¨–æ¬ æ¬½æ­†å¸æ°æ´½ç¿•èˆˆåƒ–å‡žå–œå™«å›å§¬å¬‰å¸Œæ†™æ†˜æˆ±æ™žæ›¦ç†™ç†¹ç†ºçŠ§ç¦§ç¨€ç¾²è©°"]]');
const require$$6$1 = /* @__PURE__ */ JSON.parse('[["0","\\u0000",127],["a140","ã€€ï¼Œã€ã€‚ï¼Žâ€§ï¼›ï¼šï¼Ÿï¼ï¸°â€¦â€¥ï¹ï¹‘ï¹’Â·ï¹”ï¹•ï¹–ï¹—ï½œâ€“ï¸±â€”ï¸³â•´ï¸´ï¹ï¼ˆï¼‰ï¸µï¸¶ï½›ï½ï¸·ï¸¸ã€”ã€•ï¸¹ï¸ºã€ã€‘ï¸»ï¸¼ã€Šã€‹ï¸½ï¸¾ã€ˆã€‰ï¸¿ï¹€ã€Œã€ï¹ï¹‚ã€Žã€ï¹ƒï¹„ï¹™ï¹š"],["a1a1","ï¹›ï¹œï¹ï¹žâ€˜â€™â€œâ€ã€ã€žâ€µâ€²ï¼ƒï¼†ï¼Šâ€»Â§ã€ƒâ—‹â—â–³â–²â—Žâ˜†â˜…â—‡â—†â–¡â– â–½â–¼ãŠ£â„…Â¯ï¿£ï¼¿Ëï¹‰ï¹Šï¹ï¹Žï¹‹ï¹Œï¹Ÿï¹ ï¹¡ï¼‹ï¼Ã—Ã·Â±âˆšï¼œï¼žï¼â‰¦â‰§â‰ âˆžâ‰’â‰¡ï¹¢",4,"ï½žâˆ©âˆªâŠ¥âˆ âˆŸâŠ¿ã’ã‘âˆ«âˆ®âˆµâˆ´â™€â™‚âŠ•âŠ™â†‘â†“â†â†’â†–â†—â†™â†˜âˆ¥âˆ£ï¼"],["a240","ï¼¼âˆ•ï¹¨ï¼„ï¿¥ã€’ï¿ ï¿¡ï¼…ï¼ â„ƒâ„‰ï¹©ï¹ªï¹«ã•ãŽœãŽãŽžãŽãŽ¡ãŽŽãŽã„Â°å…™å…›å…žå…å…¡å…£å—§ç“©ç³Žâ–",7,"â–â–Žâ–â–Œâ–‹â–Šâ–‰â”¼â”´â”¬â”¤â”œâ–”â”€â”‚â–•â”Œâ”â””â”˜â•­"],["a2a1","â•®â•°â•¯â•â•žâ•ªâ•¡â—¢â—£â—¥â—¤â•±â•²â•³ï¼",9,"â… ",9,"ã€¡",8,"åå„å…ï¼¡",25,"ï½",21],["a340","ï½—ï½˜ï½™ï½šÎ‘",16,"Î£",6,"Î±",16,"Ïƒ",6,"ã„…",10],["a3a1","ã„",25,"Ë™Ë‰ËŠË‡Ë‹"],["a3e1","â‚¬"],["a440","ä¸€ä¹™ä¸ä¸ƒä¹ƒä¹äº†äºŒäººå„¿å…¥å…«å‡ åˆ€åˆåŠ›åŒ•ååœåˆä¸‰ä¸‹ä¸ˆä¸Šä¸«ä¸¸å‡¡ä¹…ä¹ˆä¹Ÿä¹žäºŽäº¡å…€åˆƒå‹ºåƒå‰å£åœŸå£«å¤•å¤§å¥³å­å­‘å­“å¯¸å°å°¢å°¸å±±å·å·¥å·±å·²å·³å·¾å¹²å»¾å¼‹å¼“æ‰"],["a4a1","ä¸‘ä¸ä¸ä¸­ä¸°ä¸¹ä¹‹å°¹äºˆäº‘äº•äº’äº”äº¢ä»ä»€ä»ƒä»†ä»‡ä»ä»Šä»‹ä»„å…ƒå…å…§å…­å…®å…¬å†—å‡¶åˆ†åˆ‡åˆˆå‹»å‹¾å‹¿åŒ–åŒ¹åˆå‡å…åžåŽ„å‹åŠåå£¬å¤©å¤«å¤ªå¤­å­”å°‘å°¤å°ºå±¯å·´å¹»å»¿å¼”å¼•å¿ƒæˆˆæˆ¶æ‰‹æ‰Žæ”¯æ–‡æ–—æ–¤æ–¹æ—¥æ›°æœˆæœ¨æ¬ æ­¢æ­¹æ¯‹æ¯”æ¯›æ°æ°´ç«çˆªçˆ¶çˆ»ç‰‡ç‰™ç‰›çŠ¬çŽ‹ä¸™"],["a540","ä¸–ä¸•ä¸”ä¸˜ä¸»ä¹ä¹ä¹Žä»¥ä»˜ä»”ä»•ä»–ä»—ä»£ä»¤ä»™ä»žå……å…„å†‰å†Šå†¬å‡¹å‡ºå‡¸åˆŠåŠ åŠŸåŒ…åŒ†åŒ—åŒä»ŸåŠå‰å¡å å¯å®åŽ»å¯å¤å³å¬å®å©å¨å¼å¸åµå«å¦åªå²å±å°å¥å­å»å››å›šå¤–"],["a5a1","å¤®å¤±å¥´å¥¶å­•å®ƒå°¼å·¨å·§å·¦å¸‚å¸ƒå¹³å¹¼å¼å¼˜å¼—å¿…æˆŠæ‰“æ‰”æ‰’æ‰‘æ–¥æ—¦æœ®æœ¬æœªæœ«æœ­æ­£æ¯æ°‘æ°æ°¸æ±æ±€æ°¾çŠ¯çŽ„çŽ‰ç“œç“¦ç”˜ç”Ÿç”¨ç”©ç”°ç”±ç”²ç”³ç–‹ç™½çš®çš¿ç›®çŸ›çŸ¢çŸ³ç¤ºç¦¾ç©´ç«‹ä¸žä¸Ÿä¹’ä¹“ä¹©äº™äº¤äº¦äº¥ä»¿ä¼‰ä¼™ä¼Šä¼•ä¼ä¼ä¼‘ä¼ä»²ä»¶ä»»ä»°ä»³ä»½ä¼ä¼‹å…‰å…‡å…†å…ˆå…¨"],["a640","å…±å†å†°åˆ—åˆ‘åˆ’åˆŽåˆ–åŠ£åŒˆåŒ¡åŒ å°å±å‰ååŒåŠååå‹å„å‘ååˆåƒåŽå†å’å› å›žå›åœ³åœ°åœ¨åœ­åœ¬åœ¯åœ©å¤™å¤šå¤·å¤¸å¦„å¥¸å¦ƒå¥½å¥¹å¦‚å¦å­—å­˜å®‡å®ˆå®…å®‰å¯ºå°–å±¹å·žå¸†å¹¶å¹´"],["a6a1","å¼å¼›å¿™å¿–æˆŽæˆŒæˆæˆæ‰£æ‰›æ‰˜æ”¶æ—©æ—¨æ—¬æ—­æ›²æ›³æœ‰æœ½æœ´æœ±æœµæ¬¡æ­¤æ­»æ°–æ±æ±—æ±™æ±Ÿæ± æ±æ±•æ±¡æ±›æ±æ±Žç°ç‰Ÿç‰ç™¾ç«¹ç±³ç³¸ç¼¶ç¾Šç¾½è€è€ƒè€Œè€’è€³è¿è‚‰è‚‹è‚Œè‡£è‡ªè‡³è‡¼èˆŒèˆ›èˆŸè‰®è‰²è‰¾è™«è¡€è¡Œè¡£è¥¿é˜¡ä¸²äº¨ä½ä½ä½‡ä½—ä½žä¼´ä½›ä½•ä¼°ä½ä½‘ä¼½ä¼ºä¼¸ä½ƒä½”ä¼¼ä½†ä½£"],["a740","ä½œä½ ä¼¯ä½Žä¼¶ä½™ä½ä½ˆä½šå…Œå…‹å…å…µå†¶å†·åˆ¥åˆ¤åˆ©åˆªåˆ¨åŠ«åŠ©åŠªåŠ¬åŒ£å³åµåå­åžå¾å¦å‘Žå§å‘†å‘ƒå³å‘ˆå‘‚å›å©å‘Šå¹å»å¸å®åµå¶å å¼å‘€å±å«åŸå¬å›ªå›°å›¤å›«åŠå‘å€å"],["a7a1","å‡åŽåœ¾åååœ»å£¯å¤¾å¦å¦’å¦¨å¦žå¦£å¦™å¦–å¦å¦¤å¦“å¦Šå¦¥å­å­œå­šå­›å®Œå®‹å®å°¬å±€å±å°¿å°¾å²å²‘å²”å²Œå·«å¸Œåºåº‡åºŠå»·å¼„å¼Ÿå½¤å½¢å½·å½¹å¿˜å¿Œå¿—å¿å¿±å¿«å¿¸å¿ªæˆ’æˆ‘æŠ„æŠ—æŠ–æŠ€æ‰¶æŠ‰æ‰­æŠŠæ‰¼æ‰¾æ‰¹æ‰³æŠ’æ‰¯æŠ˜æ‰®æŠ•æŠ“æŠ‘æŠ†æ”¹æ”»æ”¸æ—±æ›´æŸæŽæææ‘æœæ–æžæ‰æ†æ "],["a840","æ“æ—æ­¥æ¯æ±‚æ±žæ²™æ²æ²ˆæ²‰æ²…æ²›æ±ªæ±ºæ²æ±°æ²Œæ±¨æ²–æ²’æ±½æ²ƒæ±²æ±¾æ±´æ²†æ±¶æ²æ²”æ²˜æ²‚ç¶ç¼ç½ç¸ç‰¢ç‰¡ç‰ ç‹„ç‹‚çŽ–ç”¬ç”«ç”·ç”¸çš‚ç›¯çŸ£ç§ç§€ç¦¿ç©¶ç³»ç½•è‚–è‚“è‚è‚˜è‚›è‚šè‚²è‰¯èŠ’"],["a8a1","èŠ‹èŠè¦‹è§’è¨€è°·è±†è±•è²èµ¤èµ°è¶³èº«è»Šè¾›è¾°è¿‚è¿†è¿…è¿„å·¡é‚‘é‚¢é‚ªé‚¦é‚£é…‰é‡†é‡Œé˜²é˜®é˜±é˜ªé˜¬ä¸¦ä¹–ä¹³äº‹äº›äºžäº«äº¬ä½¯ä¾ä¾ä½³ä½¿ä½¬ä¾›ä¾‹ä¾†ä¾ƒä½°ä½µä¾ˆä½©ä½»ä¾–ä½¾ä¾ä¾‘ä½ºå…”å…’å…•å…©å…·å…¶å…¸å†½å‡½åˆ»åˆ¸åˆ·åˆºåˆ°åˆ®åˆ¶å‰åŠ¾åŠ»å’å”å“å‘å¦å·å¸å¹å–å”å—å‘³å‘µ"],["a940","å’–å‘¸å’•å’€å‘»å‘·å’„å’’å’†å‘¼å’å‘±å‘¶å’Œå’šå‘¢å‘¨å’‹å‘½å’Žå›ºåžƒå·åªå©å¡å¦å¤å¼å¤œå¥‰å¥‡å¥ˆå¥„å¥”å¦¾å¦»å§”å¦¹å¦®å§‘å§†å§å§å§‹å§“å§Šå¦¯å¦³å§’å§…å­Ÿå­¤å­£å®—å®šå®˜å®œå®™å®›å°šå±ˆå±…"],["a9a1","å±†å²·å²¡å²¸å²©å²«å²±å²³å¸˜å¸šå¸–å¸•å¸›å¸‘å¹¸åºšåº—åºœåº•åº–å»¶å¼¦å¼§å¼©å¾€å¾å½¿å½¼å¿å¿ å¿½å¿µå¿¿æ€æ€”æ€¯æ€µæ€–æ€ªæ€•æ€¡æ€§æ€©æ€«æ€›æˆ–æˆ•æˆ¿æˆ¾æ‰€æ‰¿æ‹‰æ‹Œæ‹„æŠ¿æ‹‚æŠ¹æ‹’æ‹›æŠ«æ‹“æ‹”æ‹‹æ‹ˆæŠ¨æŠ½æŠ¼æ‹æ‹™æ‹‡æ‹æŠµæ‹šæŠ±æ‹˜æ‹–æ‹—æ‹†æŠ¬æ‹Žæ”¾æ–§æ–¼æ—ºæ˜”æ˜“æ˜Œæ˜†æ˜‚æ˜Žæ˜€æ˜æ˜•æ˜Š"],["aa40","æ˜‡æœæœ‹æ­æž‹æž•æ±æžœæ³æ·æž‡æžæž—æ¯æ°æ¿æž‰æ¾æžæµæžšæž“æ¼æªæ²æ¬£æ­¦æ­§æ­¿æ°“æ°›æ³£æ³¨æ³³æ²±æ³Œæ³¥æ²³æ²½æ²¾æ²¼æ³¢æ²«æ³•æ³“æ²¸æ³„æ²¹æ³æ²®æ³—æ³…æ³±æ²¿æ²»æ³¡æ³›æ³Šæ²¬æ³¯æ³œæ³–æ³ "],["aaa1","ç‚•ç‚Žç‚’ç‚Šç‚™çˆ¬çˆ­çˆ¸ç‰ˆç‰§ç‰©ç‹€ç‹Žç‹™ç‹—ç‹çŽ©çŽ¨çŽŸçŽ«çŽ¥ç”½ç–ç–™ç–šçš„ç›‚ç›²ç›´çŸ¥çŸ½ç¤¾ç¥€ç¥ç§‰ç§ˆç©ºç©¹ç«ºç³¾ç½”ç¾Œç¾‹è€…è‚ºè‚¥è‚¢è‚±è‚¡è‚«è‚©è‚´è‚ªè‚¯è‡¥è‡¾èˆèŠ³èŠèŠ™èŠ­èŠ½èŠŸèŠ¹èŠ±èŠ¬èŠ¥èŠ¯èŠ¸èŠ£èŠ°èŠ¾èŠ·è™Žè™±åˆè¡¨è»‹è¿Žè¿”è¿‘é‚µé‚¸é‚±é‚¶é‡‡é‡‘é•·é–€é˜œé™€é˜¿é˜»é™„"],["ab40","é™‚éš¹é›¨é’éžäºŸäº­äº®ä¿¡ä¾µä¾¯ä¾¿ä¿ ä¿‘ä¿ä¿ä¿ƒä¾¶ä¿˜ä¿Ÿä¿Šä¿—ä¾®ä¿ä¿„ä¿‚ä¿šä¿Žä¿žä¾·å…—å†’å†‘å† å‰Žå‰ƒå‰Šå‰å‰Œå‰‹å‰‡å‹‡å‹‰å‹ƒå‹åŒå—å»åŽšå›å’¬å“€å’¨å“Žå“‰å’¸å’¦å’³å“‡å“‚å’½å’ªå“"],["aba1","å“„å“ˆå’¯å’«å’±å’»å’©å’§å’¿å›¿åž‚åž‹åž åž£åž¢åŸŽåž®åž“å¥•å¥‘å¥å¥Žå¥å§œå§˜å§¿å§£å§¨å¨ƒå§¥å§ªå§šå§¦å¨å§»å­©å®£å®¦å®¤å®¢å®¥å°å±Žå±å±å±‹å³™å³’å··å¸å¸¥å¸Ÿå¹½åº åº¦å»ºå¼ˆå¼­å½¥å¾ˆå¾…å¾Šå¾‹å¾‡å¾Œå¾‰æ€’æ€æ€ æ€¥æ€Žæ€¨ææ°æ¨æ¢æ†æƒæ¬æ«æªæ¤æ‰æ‹œæŒ–æŒ‰æ‹¼æ‹­æŒæ‹®æ‹½æŒ‡æ‹±æ‹·"],["ac40","æ‹¯æ‹¬æ‹¾æ‹´æŒ‘æŒ‚æ”¿æ•…æ–«æ–½æ—¢æ˜¥æ˜­æ˜ æ˜§æ˜¯æ˜Ÿæ˜¨æ˜±æ˜¤æ›·æŸ¿æŸ“æŸ±æŸ”æŸæŸ¬æž¶æž¯æŸµæŸ©æŸ¯æŸ„æŸ‘æž´æŸšæŸ¥æž¸æŸæŸžæŸ³æž°æŸ™æŸ¢æŸæŸ’æ­ªæ®ƒæ®†æ®µæ¯’æ¯—æ°Ÿæ³‰æ´‹æ´²æ´ªæµæ´¥æ´Œæ´±æ´žæ´—"],["aca1","æ´»æ´½æ´¾æ´¶æ´›æ³µæ´¹æ´§æ´¸æ´©æ´®æ´µæ´Žæ´«ç‚«ç‚ºç‚³ç‚¬ç‚¯ç‚­ç‚¸ç‚®ç‚¤çˆ°ç‰²ç‰¯ç‰´ç‹©ç‹ ç‹¡çŽ·çŠçŽ»çŽ²çç€çŽ³ç”šç”­ç•ç•Œç•Žç•‹ç–«ç–¤ç–¥ç–¢ç–£ç™¸çš†çš‡çšˆç›ˆç›†ç›ƒç›…çœç›¹ç›¸çœ‰çœ‹ç›¾ç›¼çœ‡çŸœç ‚ç ”ç Œç ç¥†ç¥‰ç¥ˆç¥‡ç¦¹ç¦ºç§‘ç§’ç§‹ç©¿çªç«¿ç«½ç±½ç´‚ç´…ç´€ç´‰ç´‡ç´„ç´†ç¼¸ç¾Žç¾¿è€„"],["ad40","è€è€è€‘è€¶èƒ–èƒ¥èƒšèƒƒèƒ„èƒŒèƒ¡èƒ›èƒŽèƒžèƒ¤èƒè‡´èˆ¢è‹§èŒƒèŒ…è‹£è‹›è‹¦èŒ„è‹¥èŒ‚èŒ‰è‹’è‹—è‹±èŒè‹œè‹”è‹‘è‹žè‹“è‹Ÿè‹¯èŒ†è™è™¹è™»è™ºè¡è¡«è¦è§”è¨ˆè¨‚è¨ƒè²žè² èµ´èµ³è¶´è»è»Œè¿°è¿¦è¿¢è¿ªè¿¥"],["ada1","è¿­è¿«è¿¤è¿¨éƒŠéƒŽéƒéƒƒé…‹é…Šé‡é–‚é™é™‹é™Œé™é¢é©éŸ‹éŸ­éŸ³é é¢¨é£›é£Ÿé¦–é¦™ä¹˜äº³å€Œå€å€£ä¿¯å€¦å€¥ä¿¸å€©å€–å€†å€¼å€Ÿå€šå€’å€‘ä¿ºå€€å€”å€¨ä¿±å€¡å€‹å€™å€˜ä¿³ä¿®å€­å€ªä¿¾å€«å€‰å…¼å†¤å†¥å†¢å‡å‡Œå‡†å‡‹å‰–å‰œå‰”å‰›å‰åŒªå¿åŽŸåŽåŸå“¨å”å”å”·å“¼å“¥å“²å”†å“ºå””å“©å“­å“¡å”‰å“®å“ª"],["ae40","å“¦å”§å”‡å“½å”åœƒåœ„åŸ‚åŸ”åŸ‹åŸƒå ‰å¤å¥—å¥˜å¥šå¨‘å¨˜å¨œå¨Ÿå¨›å¨“å§¬å¨ å¨£å¨©å¨¥å¨Œå¨‰å­«å±˜å®°å®³å®¶å®´å®®å®µå®¹å®¸å°„å±‘å±•å±å³­å³½å³»å³ªå³¨å³°å³¶å´å³´å·®å¸­å¸«åº«åº­åº§å¼±å¾’å¾‘å¾æ™"],["aea1","æ£æ¥ææ•æ­æ©æ¯æ‚„æ‚Ÿæ‚šæ‚æ‚”æ‚Œæ‚…æ‚–æ‰‡æ‹³æŒˆæ‹¿æŽæŒ¾æŒ¯æ•æ‚æ†ææ‰æŒºææŒ½æŒªæŒ«æŒ¨ææŒæ•ˆæ•‰æ–™æ—æ—…æ™‚æ™‰æ™æ™ƒæ™’æ™Œæ™…æ™æ›¸æœ”æœ•æœ—æ ¡æ ¸æ¡ˆæ¡†æ¡“æ ¹æ¡‚æ¡”æ ©æ¢³æ —æ¡Œæ¡‘æ ½æŸ´æ¡æ¡€æ ¼æ¡ƒæ ªæ¡…æ “æ ˜æ¡æ®Šæ®‰æ®·æ°£æ°§æ°¨æ°¦æ°¤æ³°æµªæ¶•æ¶ˆæ¶‡æµ¦æµ¸æµ·æµ™æ¶“"],["af40","æµ¬æ¶‰æµ®æµšæµ´æµ©æ¶Œæ¶Šæµ¹æ¶…æµ¥æ¶”çƒŠçƒ˜çƒ¤çƒ™çƒˆçƒçˆ¹ç‰¹ç‹¼ç‹¹ç‹½ç‹¸ç‹·çŽ†ç­ç‰ç®ç çªçžç•”ç•ç•œç•šç•™ç–¾ç—…ç—‡ç–²ç–³ç–½ç–¼ç–¹ç—‚ç–¸çš‹çš°ç›Šç›ç›Žçœ©çœŸçœ çœ¨çŸ©ç °ç §ç ¸ç ç ´ç ·"],["afa1","ç ¥ç ­ç  ç Ÿç ²ç¥•ç¥ç¥ ç¥Ÿç¥–ç¥žç¥ç¥—ç¥šç§¤ç§£ç§§ç§Ÿç§¦ç§©ç§˜çª„çªˆç«™ç¬†ç¬‘ç²‰ç´¡ç´—ç´‹ç´Šç´ ç´¢ç´”ç´ç´•ç´šç´œç´ç´™ç´›ç¼ºç½Ÿç¾”ç¿…ç¿è€†è€˜è€•è€™è€—è€½è€¿èƒ±è„‚èƒ°è„…èƒ­èƒ´è„†èƒ¸èƒ³è„ˆèƒ½è„Šèƒ¼èƒ¯è‡­è‡¬èˆ€èˆèˆªèˆ«èˆ¨èˆ¬èŠ»èŒ«è’è”èŠèŒ¸èè‰èŒµèŒ´èèŒ²èŒ¹èŒ¶èŒ—è€èŒ±èŒ¨èƒ"],["b040","è™”èšŠèšªèš“èš¤èš©èšŒèš£èšœè¡°è¡·è¢è¢‚è¡½è¡¹è¨˜è¨è¨Žè¨Œè¨•è¨Šè¨—è¨“è¨–è¨è¨‘è±ˆè±ºè±¹è²¡è²¢èµ·èº¬è»’è»”è»è¾±é€é€†è¿·é€€è¿ºè¿´é€ƒè¿½é€…è¿¸é‚•éƒ¡éƒéƒ¢é…’é…é…Œé‡˜é‡é‡—é‡œé‡™é–ƒé™¢é™£é™¡"],["b0a1","é™›é™é™¤é™˜é™žéš»é£¢é¦¬éª¨é«˜é¬¥é¬²é¬¼ä¹¾åºå½åœå‡åƒåŒåšå‰å¥å¶åŽå•åµå´å·åå€å¯å­å…œå†•å‡°å‰ªå‰¯å‹’å‹™å‹˜å‹•åŒåŒåŒ™åŒ¿å€åŒ¾åƒæ›¼å•†å•ªå•¦å•„å•žå•¡å•ƒå•Šå”±å•–å•å••å”¯å•¤å”¸å”®å•œå”¬å•£å”³å•å•—åœˆåœ‹åœ‰åŸŸå …å Šå †åŸ åŸ¤åŸºå ‚å µåŸ·åŸ¹å¤ å¥¢å¨¶å©å©‰å©¦å©ªå©€"],["b140","å¨¼å©¢å©šå©†å©Šå­°å¯‡å¯…å¯„å¯‚å®¿å¯†å°‰å°ˆå°‡å± å±œå±å´‡å´†å´Žå´›å´–å´¢å´‘å´©å´”å´™å´¤å´§å´—å·¢å¸¸å¸¶å¸³å¸·åº·åº¸åº¶åºµåº¾å¼µå¼·å½—å½¬å½©å½«å¾—å¾™å¾žå¾˜å¾¡å¾ å¾œæ¿æ‚£æ‚‰æ‚ æ‚¨æƒ‹æ‚´æƒ¦æ‚½"],["b1a1","æƒ…æ‚»æ‚µæƒœæ‚¼æƒ˜æƒ•æƒ†æƒŸæ‚¸æƒšæƒ‡æˆšæˆ›æ‰ˆæŽ æŽ§æ²æŽ–æŽ¢æŽ¥æ·æ§æŽ˜æŽªæ±æŽ©æŽ‰æŽƒæŽ›æ«æŽ¨æŽ„æŽˆæŽ™æŽ¡æŽ¬æŽ’æŽæŽ€æ»æ©æ¨æºæ•æ•–æ•‘æ•™æ•—å•Ÿæ•æ•˜æ••æ•”æ–œæ–›æ–¬æ—æ—‹æ—Œæ—Žæ™æ™šæ™¤æ™¨æ™¦æ™žæ›¹å‹—æœ›æ¢æ¢¯æ¢¢æ¢“æ¢µæ¡¿æ¡¶æ¢±æ¢§æ¢—æ¢°æ¢ƒæ£„æ¢­æ¢†æ¢…æ¢”æ¢æ¢¨æ¢Ÿæ¢¡æ¢‚æ¬²æ®º"],["b240","æ¯«æ¯¬æ°«æ¶Žæ¶¼æ·³æ·™æ¶²æ·¡æ·Œæ·¤æ·»æ·ºæ¸…æ·‡æ·‹æ¶¯æ·‘æ¶®æ·žæ·¹æ¶¸æ··æ·µæ·…æ·’æ¸šæ¶µæ·šæ·«æ·˜æ·ªæ·±æ·®æ·¨æ·†æ·„æ¶ªæ·¬æ¶¿æ·¦çƒ¹ç„‰ç„Šçƒ½çƒ¯çˆ½ç‰½çŠçŒœçŒ›çŒ–çŒ“çŒ™çŽ‡ç…çŠçƒç†ç¾çç“ ç“¶"],["b2a1","ç“·ç”œç”¢ç•¥ç•¦ç•¢ç•°ç–ç—”ç—•ç–µç—Šç—çšŽç›”ç›’ç››çœ·çœ¾çœ¼çœ¶çœ¸çœºç¡«ç¡ƒç¡Žç¥¥ç¥¨ç¥­ç§»çª’çª•ç¬ ç¬¨ç¬›ç¬¬ç¬¦ç¬™ç¬žç¬®ç²’ç²—ç²•çµ†çµƒçµ±ç´®ç´¹ç´¼çµ€ç´°ç´³çµ„ç´¯çµ‚ç´²ç´±ç¼½ç¾žç¾šç¿Œç¿Žç¿’è€œèŠè†è„¯è„–è„£è„«è„©è„°è„¤èˆ‚èˆµèˆ·èˆ¶èˆ¹èŽŽèŽžèŽ˜è¸èŽ¢èŽ–èŽ½èŽ«èŽ’èŽŠèŽ“èŽ‰èŽ è·è»è¼"],["b340","èŽ†èŽ§è™•å½ªè›‡è›€èš¶è›„èšµè›†è›‹èš±èš¯è›‰è¡“è¢žè¢ˆè¢«è¢’è¢–è¢è¢‹è¦“è¦è¨ªè¨è¨£è¨¥è¨±è¨­è¨Ÿè¨›è¨¢è±‰è±šè²©è²¬è²«è²¨è²ªè²§èµ§èµ¦è¶¾è¶ºè»›è»Ÿé€™é€é€šé€—é€£é€Ÿé€é€é€•é€žé€ é€é€¢é€–é€›é€”"],["b3a1","éƒ¨éƒ­éƒ½é…—é‡Žé‡µé‡¦é‡£é‡§é‡­é‡©é–‰é™ªé™µé™³é™¸é™°é™´é™¶é™·é™¬é›€é›ªé›©ç« ç«Ÿé ‚é ƒé­šé³¥é¹µé¹¿éº¥éº»å‚¢å‚å‚…å‚™å‚‘å‚€å‚–å‚˜å‚šæœ€å‡±å‰²å‰´å‰µå‰©å‹žå‹å‹›åšåŽ¥å•»å–€å–§å•¼å–Šå–å–˜å–‚å–œå–ªå–”å–‡å–‹å–ƒå–³å–®å–Ÿå”¾å–²å–šå–»å–¬å–±å•¾å–‰å–«å–™åœå ¯å ªå ´å ¤å °å ±å ¡å å  å£¹å£ºå¥ "],["b440","å©·åªšå©¿åª’åª›åª§å­³å­±å¯’å¯Œå¯“å¯å°Šå°‹å°±åµŒåµå´´åµ‡å·½å¹…å¸½å¹€å¹ƒå¹¾å»Šå»å»‚å»„å¼¼å½­å¾©å¾ªå¾¨æƒ‘æƒ¡æ‚²æ‚¶æƒ æ„œæ„£æƒºæ„•æƒ°æƒ»æƒ´æ…¨æƒ±æ„Žæƒ¶æ„‰æ„€æ„’æˆŸæ‰‰æŽ£æŽŒææ€æ©æ‰æ†æ"],["b4a1","æ’æ£ææ¡æ–æ­æ®æ¶æ´æªæ›æ‘’æšæ¹æ•žæ•¦æ•¢æ•£æ–‘æ–æ–¯æ™®æ™°æ™´æ™¶æ™¯æš‘æ™ºæ™¾æ™·æ›¾æ›¿æœŸæœæ£ºæ£•æ£ æ£˜æ£—æ¤…æ£Ÿæ£µæ£®æ£§æ£¹æ£’æ£²æ££æ£‹æ£æ¤æ¤’æ¤Žæ£‰æ£šæ¥®æ£»æ¬¾æ¬ºæ¬½æ®˜æ®–æ®¼æ¯¯æ°®æ°¯æ°¬æ¸¯æ¸¸æ¹”æ¸¡æ¸²æ¹§æ¹Šæ¸ æ¸¥æ¸£æ¸›æ¹›æ¹˜æ¸¤æ¹–æ¹®æ¸­æ¸¦æ¹¯æ¸´æ¹æ¸ºæ¸¬æ¹ƒæ¸æ¸¾æ»‹"],["b540","æº‰æ¸™æ¹Žæ¹£æ¹„æ¹²æ¹©æ¹Ÿç„™ç„šç„¦ç„°ç„¡ç„¶ç…®ç„œç‰ŒçŠ„çŠ€çŒ¶çŒ¥çŒ´çŒ©çºçªç³ç¢ç¥çµç¶ç´ç¯ç›ç¦ç¨ç”¥ç”¦ç•«ç•ªç—¢ç—›ç—£ç—™ç—˜ç—žç— ç™»ç™¼çš–çš“çš´ç›œççŸ­ç¡ç¡¬ç¡¯ç¨ç¨ˆç¨‹ç¨…ç¨€çª˜"],["b5a1","çª—çª–ç«¥ç«£ç­‰ç­–ç­†ç­ç­’ç­”ç­ç­‹ç­ç­‘ç²Ÿç²¥çµžçµçµ¨çµ•ç´«çµ®çµ²çµ¡çµ¦çµ¢çµ°çµ³å–„ç¿”ç¿•è€‹è’è‚…è…•è…”è…‹è…‘è…Žè„¹è…†è„¾è…Œè…“è…´èˆ’èˆœè©èƒè¸èè è…è‹èè¯è±è´è‘—èŠè°èŒèŒè½è²èŠè¸èŽè„èœè‡è”èŸè™›è›Ÿè›™è›­è›”è››è›¤è›è›žè¡—è£è£‚è¢±è¦ƒè¦–è¨»è© è©•è©žè¨¼è©"],["b640","è©”è©›è©è©†è¨´è¨ºè¨¶è©–è±¡è²‚è²¯è²¼è²³è²½è³è²»è³€è²´è²·è²¶è²¿è²¸è¶Šè¶…è¶è·Žè·è·‹è·šè·‘è·Œè·›è·†è»»è»¸è»¼è¾œé€®é€µé€±é€¸é€²é€¶é„‚éƒµé„‰éƒ¾é…£é…¥é‡éˆ”éˆ•éˆ£éˆ‰éˆžéˆéˆéˆ‡éˆ‘é–”é–é–‹é–‘"],["b6a1","é–“é–’é–ŽéšŠéšŽéš‹é™½éš…éš†éšé™²éš„é›é›…é›„é›†é›‡é›¯é›²éŸŒé …é †é ˆé£§é£ªé£¯é£©é£²é£­é¦®é¦­é»ƒé»é»‘äº‚å‚­å‚µå‚²å‚³åƒ…å‚¾å‚¬å‚·å‚»å‚¯åƒ‡å‰¿å‰·å‰½å‹Ÿå‹¦å‹¤å‹¢å‹£åŒ¯å—Ÿå—¨å—“å—¦å—Žå—œå—‡å—‘å—£å—¤å—¯å—šå—¡å—…å—†å—¥å—‰åœ’åœ“å¡žå¡‘å¡˜å¡—å¡šå¡”å¡«å¡Œå¡­å¡Šå¡¢å¡’å¡‹å¥§å«å«‰å«Œåª¾åª½åª¼"],["b740","åª³å«‚åª²åµ©åµ¯å¹Œå¹¹å»‰å»ˆå¼’å½™å¾¬å¾®æ„šæ„æ…ˆæ„Ÿæƒ³æ„›æƒ¹æ„æ„ˆæ…Žæ…Œæ…„æ…æ„¾æ„´æ„§æ„æ„†æ„·æˆ¡æˆ¢æ“æ¾æžæªæ­æ½æ¬ææœæ”ææ¶æ–æ—æ†æ•¬æ–Ÿæ–°æš—æš‰æš‡æšˆæš–æš„æš˜æšæœƒæ¦”æ¥­"],["b7a1","æ¥šæ¥·æ¥ æ¥”æ¥µæ¤°æ¦‚æ¥Šæ¥¨æ¥«æ¥žæ¥“æ¥¹æ¦†æ¥æ¥£æ¥›æ­‡æ­²æ¯€æ®¿æ¯“æ¯½æº¢æº¯æ»“æº¶æ»‚æºæºæ»‡æ»…æº¥æº˜æº¼æººæº«æ»‘æº–æºœæ»„æ»”æºªæº§æº´ç…Žç…™ç…©ç…¤ç…‰ç…§ç…œç…¬ç…¦ç…Œç…¥ç…žç…†ç…¨ç…–çˆºç‰’çŒ·ç…çŒ¿çŒ¾ç‘¯ç‘šç‘•ç‘Ÿç‘žç‘ç¿ç‘™ç‘›ç‘œç•¶ç•¸ç˜€ç—°ç˜ç—²ç—±ç—ºç—¿ç—´ç—³ç›žç›Ÿç›ç«ç¦çžç£"],["b840","ç¹çªç¬çœç¥ç¨ç¢çŸ®ç¢Žç¢°ç¢—ç¢˜ç¢Œç¢‰ç¡¼ç¢‘ç¢“ç¡¿ç¥ºç¥¿ç¦è¬ç¦½ç¨œç¨šç¨ ç¨”ç¨Ÿç¨žçªŸçª ç­·ç¯€ç­ ç­®ç­§ç²±ç²³ç²µç¶“çµ¹ç¶‘ç¶ç¶çµ›ç½®ç½©ç½ªç½²ç¾©ç¾¨ç¾¤è–è˜è‚†è‚„è…±è…°è…¸è…¥è…®è…³è…«"],["b8a1","è…¹è…ºè…¦èˆ…è‰‡è’‚è‘·è½è±è‘µè‘¦è‘«è‘‰è‘¬è‘›è¼èµè‘¡è‘£è‘©è‘­è‘†è™žè™œè™Ÿè›¹èœ“èœˆèœ‡èœ€è›¾è›»èœ‚èœƒèœ†èœŠè¡™è£Ÿè£”è£™è£œè£˜è£è£¡è£Šè£•è£’è¦œè§£è©«è©²è©³è©¦è©©è©°èª‡è©¼è©£èª è©±èª…è©­è©¢è©®è©¬è©¹è©»è¨¾è©¨è±¢è²Šè²‰è³Šè³‡è³ˆè³„è²²è³ƒè³‚è³…è·¡è·Ÿè·¨è·¯è·³è·ºè·ªè·¤è·¦èº²è¼ƒè¼‰è»¾è¼Š"],["b940","è¾Ÿè¾²é‹éŠé“é‚é”é€¼é•éé‡ééŽéé‘é€¾éé„’é„—é…¬é…ªé…©é‡‰éˆ·é‰—éˆ¸éˆ½é‰€éˆ¾é‰›é‰‹é‰¤é‰‘éˆ´é‰‰é‰é‰…éˆ¹éˆ¿é‰šé–˜éš˜éš”éš•é›é›‹é›‰é›Šé›·é›»é›¹é›¶é–é´é¶é é ‘é “é Šé ’é Œé£¼é£´"],["b9a1","é£½é£¾é¦³é¦±é¦´é«¡é³©éº‚é¼Žé¼“é¼ åƒ§åƒ®åƒ¥åƒ–åƒ­åƒšåƒ•åƒåƒ‘åƒ±åƒŽåƒ©å…¢å‡³åŠƒåŠ‚åŒ±åŽ­å—¾å˜€å˜›å˜—å—½å˜”å˜†å˜‰å˜å˜Žå—·å˜–å˜Ÿå˜ˆå˜å—¶åœ˜åœ–å¡µå¡¾å¢ƒå¢“å¢Šå¡¹å¢…å¡½å£½å¤¥å¤¢å¤¤å¥ªå¥©å«¡å«¦å«©å«—å«–å«˜å«£å­µå¯žå¯§å¯¡å¯¥å¯¦å¯¨å¯¢å¯¤å¯Ÿå°å±¢å¶„å¶‡å¹›å¹£å¹•å¹—å¹”å»“å»–å¼Šå½†å½°å¾¹æ…‡"],["ba40","æ„¿æ…‹æ…·æ…¢æ…£æ…Ÿæ…šæ…˜æ…µæˆªæ’‡æ‘˜æ‘”æ’¤æ‘¸æ‘Ÿæ‘ºæ‘‘æ‘§æ´æ‘­æ‘»æ•²æ–¡æ——æ—–æš¢æš¨æšæ¦œæ¦¨æ¦•æ§æ¦®æ§“æ§‹æ¦›æ¦·æ¦»æ¦«æ¦´æ§æ§æ¦­æ§Œæ¦¦æ§ƒæ¦£æ­‰æ­Œæ°³æ¼³æ¼”æ»¾æ¼“æ»´æ¼©æ¼¾æ¼ æ¼¬æ¼æ¼‚æ¼¢"],["baa1","æ»¿æ»¯æ¼†æ¼±æ¼¸æ¼²æ¼£æ¼•æ¼«æ¼¯æ¾ˆæ¼ªæ»¬æ¼æ»²æ»Œæ»·ç†”ç†™ç…½ç†Šç†„ç†’çˆ¾çŠ’çŠ–ç„çç‘¤ç‘£ç‘ªç‘°ç‘­ç”„ç–‘ç˜§ç˜ç˜‹ç˜‰ç˜“ç›¡ç›£çž„ç½ç¿ç¡ç£ç¢Ÿç¢§ç¢³ç¢©ç¢£ç¦Žç¦ç¦ç¨®ç¨±çªªçª©ç«­ç«¯ç®¡ç®•ç®‹ç­µç®—ç®ç®”ç®ç®¸ç®‡ç®„ç²¹ç²½ç²¾ç¶»ç¶°ç¶œç¶½ç¶¾ç¶ ç·Šç¶´ç¶²ç¶±ç¶ºç¶¢ç¶¿ç¶µç¶¸ç¶­ç·’ç·‡ç¶¬"],["bb40","ç½°ç¿ ç¿¡ç¿Ÿèžèšè‚‡è…è†€è†è†ˆè†Šè…¿è†‚è‡§è‡ºèˆ‡èˆ”èˆžè‰‹è“‰è’¿è“†è“„è’™è’žè’²è’œè“‹è’¸è“€è““è’è’¼è“‘è“Šèœ¿èœœèœ»èœ¢èœ¥èœ´èœ˜è•èœ·èœ©è£³è¤‚è£´è£¹è£¸è£½è£¨è¤šè£¯èª¦èªŒèªžèª£èªèª¡èª“èª¤"],["bba1","èªªèª¥èª¨èª˜èª‘èªšèª§è±ªè²è²Œè³“è³‘è³’èµ«è¶™è¶•è·¼è¼”è¼’è¼•è¼“è¾£é é˜éœé£é™éžé¢éé›é„™é„˜é„žé…µé…¸é…·é…´é‰¸éŠ€éŠ…éŠ˜éŠ–é‰»éŠ“éŠœéŠ¨é‰¼éŠ‘é–¡é–¨é–©é–£é–¥é–¤éš™éšœéš›é›Œé›’éœ€é¼éž…éŸ¶é —é ˜é¢¯é¢±é¤ƒé¤…é¤Œé¤‰é§éª¯éª°é«¦é­é­‚é³´é³¶é³³éº¼é¼»é½Šå„„å„€åƒ»åƒµåƒ¹å„‚å„ˆå„‰å„…å‡œ"],["bc40","åŠ‡åŠˆåŠ‰åŠåŠŠå‹°åŽ²å˜®å˜»å˜¹å˜²å˜¿å˜´å˜©å™“å™Žå™—å™´å˜¶å˜¯å˜°å¢€å¢Ÿå¢žå¢³å¢œå¢®å¢©å¢¦å¥­å¬‰å«»å¬‹å«µå¬Œå¬ˆå¯®å¯¬å¯©å¯«å±¤å±¥å¶å¶”å¹¢å¹Ÿå¹¡å»¢å»šå»Ÿå»å»£å» å½ˆå½±å¾·å¾µæ…¶æ…§æ…®æ…æ…•æ†‚"],["bca1","æ…¼æ…°æ…«æ…¾æ†§æ†æ†«æ†Žæ†¬æ†šæ†¤æ†”æ†®æˆ®æ‘©æ‘¯æ‘¹æ’žæ’²æ’ˆæ’æ’°æ’¥æ’“æ’•æ’©æ’’æ’®æ’­æ’«æ’šæ’¬æ’™æ’¢æ’³æ•µæ•·æ•¸æš®æš«æš´æš±æ¨£æ¨Ÿæ§¨æ¨æ¨žæ¨™æ§½æ¨¡æ¨“æ¨Šæ§³æ¨‚æ¨…æ§­æ¨‘æ­æ­Žæ®¤æ¯…æ¯†æ¼¿æ½¼æ¾„æ½‘æ½¦æ½”æ¾†æ½­æ½›æ½¸æ½®æ¾Žæ½ºæ½°æ½¤æ¾—æ½˜æ»•æ½¯æ½ æ½Ÿç†Ÿç†¬ç†±ç†¨ç‰–çŠ›çŽç—ç‘©ç’‹ç’ƒ"],["bd40","ç‘¾ç’€ç•¿ç˜ ç˜©ç˜Ÿç˜¤ç˜¦ç˜¡ç˜¢çššçšºç›¤çžŽçž‡çžŒçž‘çž‹ç£‹ç£…ç¢ºç£Šç¢¾ç£•ç¢¼ç£ç¨¿ç¨¼ç©€ç¨½ç¨·ç¨»çª¯çª®ç®­ç®±ç¯„ç®´ç¯†ç¯‡ç¯ç® ç¯Œç³Šç· ç·´ç·¯ç·»ç·˜ç·¬ç·ç·¨ç·£ç·šç·žç·©ç¶žç·™ç·²ç·¹ç½µç½·ç¾¯"],["bda1","ç¿©è€¦è†›è†œè†è† è†šè†˜è”—è”½è”šè“®è”¬è”­è”“è”‘è”£è”¡è””è“¬è”¥è“¿è”†èž‚è´è¶è è¦è¸è¨è™è—èŒè“è¡›è¡è¤è¤‡è¤’è¤“è¤•è¤Šèª¼è«’è«‡è«„èª•è«‹è«¸èª²è«‰è«‚èª¿èª°è«–è«èª¶èª¹è«›è±Œè±Žè±¬è³ è³žè³¦è³¤è³¬è³­è³¢è³£è³œè³ªè³¡èµ­è¶Ÿè¶£è¸«è¸è¸è¸¢è¸è¸©è¸Ÿè¸¡è¸žèººè¼è¼›è¼Ÿè¼©è¼¦è¼ªè¼œè¼ž"],["be40","è¼¥é©é®é¨é­é·é„°é„­é„§é„±é†‡é†‰é†‹é†ƒé‹…éŠ»éŠ·é‹ªéŠ¬é‹¤é‹éŠ³éŠ¼é‹’é‹‡é‹°éŠ²é–­é–±éœ„éœ†éœ‡éœ‰é éžéž‹éžé ¡é «é œé¢³é¤Šé¤“é¤’é¤˜é§é§é§Ÿé§›é§‘é§•é§’é§™éª·é«®é«¯é¬§é­…é­„é­·é­¯é´†é´‰"],["bea1","é´ƒéº©éº¾é»Žå¢¨é½’å„’å„˜å„”å„å„•å†€å†ªå‡åŠ‘åŠ“å‹³å™™å™«å™¹å™©å™¤å™¸å™ªå™¨å™¥å™±å™¯å™¬å™¢å™¶å£å¢¾å£‡å£…å¥®å¬å¬´å­¸å¯°å°Žå½Šæ†²æ†‘æ†©æ†Šæ‡æ†¶æ†¾æ‡Šæ‡ˆæˆ°æ“…æ“æ“‹æ’»æ’¼æ“šæ“„æ“‡æ“‚æ“æ’¿æ“’æ“”æ’¾æ•´æ›†æ›‰æš¹æ›„æ›‡æš¸æ¨½æ¨¸æ¨ºæ©™æ©«æ©˜æ¨¹æ©„æ©¢æ©¡æ©‹æ©‡æ¨µæ©Ÿæ©ˆæ­™æ­·æ°…æ¿‚æ¾±æ¾¡"],["bf40","æ¿ƒæ¾¤æ¿æ¾§æ¾³æ¿€æ¾¹æ¾¶æ¾¦æ¾ æ¾´ç†¾ç‡‰ç‡ç‡’ç‡ˆç‡•ç†¹ç‡Žç‡™ç‡œç‡ƒç‡„ç¨ç’œç’£ç’˜ç’Ÿç’žç“¢ç”Œç”ç˜´ç˜¸ç˜ºç›§ç›¥çž çžžçžŸçž¥ç£¨ç£šç£¬ç£§ç¦¦ç©ç©Žç©†ç©Œç©‹çªºç¯™ç°‘ç¯‰ç¯¤ç¯›ç¯¡ç¯©ç¯¦ç³•ç³–ç¸Š"],["bfa1","ç¸‘ç¸ˆç¸›ç¸£ç¸žç¸ç¸‰ç¸ç½¹ç¾²ç¿°ç¿±ç¿®è€¨è†³è†©è†¨è‡»èˆˆè‰˜è‰™è•Šè•™è•ˆè•¨è•©è•ƒè•‰è•­è•ªè•žèžƒèžŸèžžèž¢èžè¡¡è¤ªè¤²è¤¥è¤«è¤¡è¦ªè¦¦è«¦è«ºè««è«±è¬€è«œè«§è«®è«¾è¬è¬‚è«·è«­è«³è«¶è«¼è±«è±­è²“è³´è¹„è¸±è¸´è¹‚è¸¹è¸µè¼»è¼¯è¼¸è¼³è¾¨è¾¦éµé´é¸é²é¼éºé„´é†’éŒ éŒ¶é‹¸éŒ³éŒ¯éŒ¢é‹¼éŒ«éŒ„éŒš"],["c040","éŒéŒ¦éŒ¡éŒ•éŒ®éŒ™é–»éš§éš¨éšªé›•éœŽéœ‘éœ–éœéœ“éœé›éœé¦éž˜é °é ¸é »é ·é ­é ¹é ¤é¤é¤¨é¤žé¤›é¤¡é¤šé§­é§¢é§±éª¸éª¼é«»é«­é¬¨é®‘é´•é´£é´¦é´¨é´’é´›é»˜é»”é¾é¾œå„ªå„Ÿå„¡å„²å‹µåšŽåš€åšåš…åš‡"],["c0a1","åšå£•å£“å£‘å£Žå¬°å¬ªå¬¤å­ºå°·å±¨å¶¼å¶ºå¶½å¶¸å¹«å½Œå¾½æ‡‰æ‡‚æ‡‡æ‡¦æ‡‹æˆ²æˆ´æ“Žæ“Šæ“˜æ“ æ“°æ“¦æ“¬æ“±æ“¢æ“­æ–‚æ–ƒæ›™æ›–æª€æª”æª„æª¢æªœæ«›æª£æ©¾æª—æªæª æ­œæ®®æ¯šæ°ˆæ¿˜æ¿±æ¿Ÿæ¿ æ¿›æ¿¤æ¿«æ¿¯æ¾€æ¿¬æ¿¡æ¿©æ¿•æ¿®æ¿°ç‡§ç‡Ÿç‡®ç‡¦ç‡¥ç‡­ç‡¬ç‡´ç‡ çˆµç‰†ç°ç²ç’©ç’°ç’¦ç’¨ç™†ç™‚ç™Œç›ªçž³çžªçž°çž¬"],["c140","çž§çž­çŸ¯ç£·ç£ºç£´ç£¯ç¤ç¦§ç¦ªç©—çª¿ç°‡ç°ç¯¾ç¯·ç°Œç¯ ç³ ç³œç³žç³¢ç³Ÿç³™ç³ç¸®ç¸¾ç¹†ç¸·ç¸²ç¹ƒç¸«ç¸½ç¸±ç¹…ç¹ç¸´ç¸¹ç¹ˆç¸µç¸¿ç¸¯ç½„ç¿³ç¿¼è±è²è°è¯è³è‡†è‡ƒè†ºè‡‚è‡€è†¿è†½è‡‰è†¾è‡¨èˆ‰è‰±è–ª"],["c1a1","è–„è•¾è–œè–‘è–”è–¯è–›è–‡è–¨è–Šè™§èŸ€èŸ‘èž³èŸ’èŸ†èž«èž»èžºèŸˆèŸ‹è¤»è¤¶è¥„è¤¸è¤½è¦¬è¬Žè¬—è¬™è¬›è¬Šè¬ è¬è¬„è¬è±è°¿è±³è³ºè³½è³¼è³¸è³»è¶¨è¹‰è¹‹è¹ˆè¹Šè½„è¼¾è½‚è½…è¼¿é¿é½é‚„é‚é‚‚é‚€é„¹é†£é†žé†œééŽ‚éŒ¨éµéŠé¥é‹éŒ˜é¾é¬é›é°éšé”é—Šé—‹é—Œé—ˆé—†éš±éš¸é›–éœœéœžéž éŸ“é¡†é¢¶é¤µé¨"],["c240","é§¿é®®é®«é®ªé®­é´»é´¿éº‹é»é»žé»œé»é»›é¼¾é½‹å¢åš•åš®å£™å£˜å¬¸å½æ‡£æˆ³æ“´æ“²æ“¾æ”†æ“ºæ“»æ“·æ–·æ›œæœ¦æª³æª¬æ«ƒæª»æª¸æ«‚æª®æª¯æ­Ÿæ­¸æ®¯ç€‰ç€‹æ¿¾ç€†æ¿ºç€‘ç€ç‡»ç‡¼ç‡¾ç‡¸ç·çµç’§ç’¿ç”•ç™–ç™˜"],["c2a1","ç™’çž½çž¿çž»çž¼ç¤Žç¦®ç©¡ç©¢ç© ç«„ç«…ç°«ç°§ç°ªç°žç°£ç°¡ç³§ç¹”ç¹•ç¹žç¹šç¹¡ç¹’ç¹™ç½ˆç¿¹ç¿»è·è¶è‡è‡èˆŠè—è–©è—è—è—‰è–°è–ºè–¹è–¦èŸ¯èŸ¬èŸ²èŸ è¦†è¦²è§´è¬¨è¬¹è¬¬è¬«è±è´…è¹™è¹£è¹¦è¹¤è¹Ÿè¹•è»€è½‰è½é‚‡é‚ƒé‚ˆé†«é†¬é‡éŽ”éŽŠéŽ–éŽ¢éŽ³éŽ®éŽ¬éŽ°éŽ˜éŽšéŽ—é—”é—–é—é—•é›¢é›œé›™é››é›žéœ¤éž£éž¦"],["c340","éž­éŸ¹é¡é¡é¡Œé¡Žé¡“é¢ºé¤¾é¤¿é¤½é¤®é¦¥é¨Žé«é¬ƒé¬†é­é­Žé­é¯Šé¯‰é¯½é¯ˆé¯€éµ‘éµéµ é» é¼•é¼¬å„³åš¥å£žå£Ÿå£¢å¯µé¾å»¬æ‡²æ‡·æ‡¶æ‡µæ”€æ”æ› æ›æ«¥æ«æ«šæ«“ç€›ç€Ÿç€¨ç€šç€ç€•ç€˜çˆ†çˆç‰˜çŠ¢ç¸"],["c3a1","çºç’½ç“Šç“£ç–‡ç–†ç™Ÿç™¡çŸ‡ç¤™ç¦±ç©«ç©©ç°¾ç°¿ç°¸ç°½ç°·ç±€ç¹«ç¹­ç¹¹ç¹©ç¹ªç¾…ç¹³ç¾¶ç¾¹ç¾¸è‡˜è—©è—è—ªè—•è—¤è—¥è—·èŸ»è …è èŸ¹èŸ¾è¥ è¥Ÿè¥–è¥žè­è­œè­˜è­‰è­šè­Žè­è­†è­™è´ˆè´Šè¹¼è¹²èº‡è¹¶è¹¬è¹ºè¹´è½”è½Žè¾­é‚Šé‚‹é†±é†®é¡é‘éŸéƒéˆéœéé–é¢éé˜é¤é—é¨é—œéš´é›£éœªéœ§é¡éŸœéŸ»é¡ž"],["c440","é¡˜é¡›é¢¼é¥…é¥‰é¨–é¨™é¬é¯¨é¯§é¯–é¯›é¶‰éµ¡éµ²éµªéµ¬éº’éº—éº“éº´å‹¸åš¨åš·åš¶åš´åš¼å£¤å­€å­ƒå­½å¯¶å·‰æ‡¸æ‡ºæ”˜æ””æ”™æ›¦æœ§æ«¬ç€¾ç€°ç€²çˆç»ç“ç™¢ç™¥ç¤¦ç¤ªç¤¬ç¤«ç«‡ç«¶ç±Œç±ƒç±ç³¯ç³°è¾®ç¹½ç¹¼"],["c4a1","çº‚ç½Œè€€è‡šè‰¦è—»è—¹è˜‘è—ºè˜†è˜‹è˜‡è˜Šè ”è •è¥¤è¦ºè§¸è­°è­¬è­¦è­¯è­Ÿè­«è´è´èº‰èºèº…èº‚é†´é‡‹é˜éƒé½é—¡éœ°é£„é¥’é¥‘é¦¨é¨«é¨°é¨·é¨µé°“é°é¹¹éºµé»¨é¼¯é½Ÿé½£é½¡å„·å„¸å›å›€å›‚å¤”å±¬å·æ‡¼æ‡¾æ”æ”œæ–•æ›©æ«»æ¬„æ«ºæ®²çŒçˆ›çŠ§ç“–ç“”ç™©çŸ“ç±çºçºŒç¾¼è˜—è˜­è˜šè £è ¢è ¡è Ÿè¥ªè¥¬è¦½è­´"],["c540","è­·è­½è´“èºŠèºèº‹è½Ÿè¾¯é†ºé®é³éµéºé¸é²é«é—¢éœ¸éœ¹éœ²éŸ¿é¡§é¡¥é¥—é©…é©ƒé©€é¨¾é«é­”é­‘é°­é°¥é¶¯é¶´é·‚é¶¸éºé»¯é¼™é½œé½¦é½§å„¼å„»å›ˆå›Šå›‰å­¿å·”å·’å½Žæ‡¿æ”¤æ¬Šæ­¡ç‘ç˜çŽ€ç“¤ç–Šç™®ç™¬"],["c5a1","ç¦³ç± ç±Ÿè¾è½è‡Ÿè¥²è¥¯è§¼è®€è´–è´—èº‘èº“è½¡é…ˆé‘„é‘‘é‘’éœ½éœ¾éŸƒéŸé¡«é¥•é©•é©é«’é¬šé±‰é°±é°¾é°»é·“é·—é¼´é½¬é½ªé¾”å›Œå·–æˆ€æ”£æ”«æ”ªæ›¬æ¬ç“šç«Šç±¤ç±£ç±¥çº“çº–çº”è‡¢è˜¸è˜¿è ±è®Šé‚é‚é‘£é‘ é‘¤é¨é¡¯é¥œé©šé©›é©—é«“é«”é«‘é±”é±—é±–é·¥éºŸé»´å›‘å£©æ”¬çžç™±ç™²çŸ—ç½ç¾ˆè ¶è ¹è¡¢è®“è®’"],["c640","è®–è‰·è´›é‡€é‘ªé‚éˆé„éŸ†é¡°é©Ÿé¬¢é­˜é±Ÿé·¹é·ºé¹¼é¹½é¼‡é½·é½²å»³æ¬–ç£ç±¬ç±®è »è§€èº¡é‡é‘²é‘°é¡±é¥žé«–é¬£é»Œç¤çŸšè®šé‘·éŸ‰é©¢é©¥çºœè®œèºªé‡…é‘½é‘¾é‘¼é±·é±¸é»·è±”é‘¿é¸šçˆ¨é©ªé¬±é¸›é¸žç±²"],["c940","ä¹‚ä¹œå‡µåŒšåŽ‚ä¸‡ä¸Œä¹‡äºå›—ï¨Œå±®å½³ä¸å†‡ä¸Žä¸®äº“ä»‚ä»‰ä»ˆå†˜å‹¼å¬åŽ¹åœ å¤ƒå¤¬å°å·¿æ—¡æ®³æ¯Œæ°”çˆ¿ä¸±ä¸¼ä»¨ä»œä»©ä»¡ä»ä»šåˆŒåŒœåŒåœ¢åœ£å¤—å¤¯å®å®„å°’å°»å±´å±³å¸„åº€åº‚å¿‰æˆ‰æ‰æ°•"],["c9a1","æ°¶æ±ƒæ°¿æ°»çŠ®çŠ°çŽŠç¦¸è‚Šé˜žä¼Žä¼˜ä¼¬ä»µä¼”ä»±ä¼€ä»·ä¼ˆä¼ä¼‚ä¼…ä¼¢ä¼“ä¼„ä»´ä¼’å†±åˆ“åˆ‰åˆåŠ¦åŒ¢åŒŸååŽŠå‡å›¡å›Ÿåœ®åœªåœ´å¤¼å¦€å¥¼å¦…å¥»å¥¾å¥·å¥¿å­–å°•å°¥å±¼å±ºå±»å±¾å·Ÿå¹µåº„å¼‚å¼šå½´å¿•å¿”å¿æ‰œæ‰žæ‰¤æ‰¡æ‰¦æ‰¢æ‰™æ‰ æ‰šæ‰¥æ—¯æ—®æœ¾æœ¹æœ¸æœ»æœºæœ¿æœ¼æœ³æ°˜æ±†æ±’æ±œæ±æ±Šæ±”æ±‹"],["ca40","æ±Œç±ç‰žçŠ´çŠµçŽŽç”ªç™¿ç©µç½‘è‰¸è‰¼èŠ€è‰½è‰¿è™è¥¾é‚™é‚—é‚˜é‚›é‚”é˜¢é˜¤é˜ é˜£ä½–ä¼»ä½¢ä½‰ä½“ä½¤ä¼¾ä½§ä½’ä½Ÿä½ä½˜ä¼­ä¼³ä¼¿ä½¡å†å†¹åˆœåˆžåˆ¡åŠ­åŠ®åŒ‰å£å²åŽŽåŽå°å·åªå‘”å‘…å™åœå¥å˜"],["caa1","å½å‘å‘å¨å¤å‘‡å›®å›§å›¥åå…åŒå‰å‹å’å¤†å¥€å¦¦å¦˜å¦ å¦—å¦Žå¦¢å¦å¦å¦§å¦¡å®Žå®’å°¨å°ªå²å²å²ˆå²‹å²‰å²’å²Šå²†å²“å²•å· å¸Šå¸Žåº‹åº‰åºŒåºˆåºå¼…å¼å½¸å½¶å¿’å¿‘å¿å¿­å¿¨å¿®å¿³å¿¡å¿¤å¿£å¿ºå¿¯å¿·å¿»æ€€å¿´æˆºæŠƒæŠŒæŠŽæŠæŠ”æŠ‡æ‰±æ‰»æ‰ºæ‰°æŠæŠˆæ‰·æ‰½æ‰²æ‰´æ”·æ—°æ—´æ—³æ—²æ—µæ…æ‡"],["cb40","æ™æ•æŒæˆæææšæ‹æ¯æ°™æ°šæ±¸æ±§æ±«æ²„æ²‹æ²æ±±æ±¯æ±©æ²šæ±­æ²‡æ²•æ²œæ±¦æ±³æ±¥æ±»æ²Žç´çºç‰£çŠ¿çŠ½ç‹ƒç‹†ç‹çŠºç‹…çŽ•çŽ—çŽ“çŽ”çŽ’ç”ºç”¹ç–”ç–•çšç¤½è€´è‚•è‚™è‚è‚’è‚œèŠèŠèŠ…èŠŽèŠ‘èŠ“"],["cba1","èŠŠèŠƒèŠ„è±¸è¿‰è¾¿é‚Ÿé‚¡é‚¥é‚žé‚§é‚ é˜°é˜¨é˜¯é˜­ä¸³ä¾˜ä½¼ä¾…ä½½ä¾€ä¾‡ä½¶ä½´ä¾‰ä¾„ä½·ä½Œä¾—ä½ªä¾šä½¹ä¾ä½¸ä¾ä¾œä¾”ä¾žä¾’ä¾‚ä¾•ä½«ä½®å†žå†¼å†¾åˆµåˆ²åˆ³å‰†åˆ±åŠ¼åŒŠåŒ‹åŒ¼åŽ’åŽ”å’‡å‘¿å’å’‘å’‚å’ˆå‘«å‘ºå‘¾å‘¥å‘¬å‘´å‘¦å’å‘¯å‘¡å‘ å’˜å‘£å‘§å‘¤å›·å›¹å¯å²å­å«å±å°å¶åž€åµå»å³å´å¢"],["cc40","å¨å½å¤Œå¥…å¦µå¦ºå§å§Žå¦²å§Œå§å¦¶å¦¼å§ƒå§–å¦±å¦½å§€å§ˆå¦´å§‡å­¢å­¥å®“å®•å±„å±‡å²®å²¤å² å²µå²¯å²¨å²¬å²Ÿå²£å²­å²¢å²ªå²§å²å²¥å²¶å²°å²¦å¸—å¸”å¸™å¼¨å¼¢å¼£å¼¤å½”å¾‚å½¾å½½å¿žå¿¥æ€­æ€¦æ€™æ€²æ€‹"],["cca1","æ€´æ€Šæ€—æ€³æ€šæ€žæ€¬æ€¢æ€æ€æ€®æ€“æ€‘æ€Œæ€‰æ€œæˆ”æˆ½æŠ­æŠ´æ‹‘æŠ¾æŠªæŠ¶æ‹ŠæŠ®æŠ³æŠ¯æŠ»æŠ©æŠ°æŠ¸æ”½æ–¨æ–»æ˜‰æ—¼æ˜„æ˜’æ˜ˆæ—»æ˜ƒæ˜‹æ˜æ˜…æ—½æ˜‘æ˜æ›¶æœŠæž…æ¬æžŽæž’æ¶æ»æž˜æž†æž„æ´æžæžŒæºæžŸæž‘æž™æžƒæ½æžæ¸æ¹æž”æ¬¥æ®€æ­¾æ¯žæ°æ²“æ³¬æ³«æ³®æ³™æ²¶æ³”æ²­æ³§æ²·æ³æ³‚æ²ºæ³ƒæ³†æ³­æ³²"],["cd40","æ³’æ³æ²´æ²Šæ²æ²€æ³žæ³€æ´°æ³æ³‡æ²°æ³¹æ³æ³©æ³‘ç‚”ç‚˜ç‚…ç‚“ç‚†ç‚„ç‚‘ç‚–ç‚‚ç‚šç‚ƒç‰ªç‹–ç‹‹ç‹˜ç‹‰ç‹œç‹’ç‹”ç‹šç‹Œç‹‘çŽ¤çŽ¡çŽ­çŽ¦çŽ¢çŽ çŽ¬çŽç“ç“¨ç”¿ç•€ç”¾ç–Œç–˜çš¯ç›³ç›±ç›°ç›µçŸ¸çŸ¼çŸ¹çŸ»çŸº"],["cda1","çŸ·ç¥‚ç¤¿ç§…ç©¸ç©»ç«»ç±µç³½è€µè‚è‚®è‚£è‚¸è‚µè‚­èˆ èŠ è‹€èŠ«èŠšèŠ˜èŠ›èŠµèŠ§èŠ®èŠ¼èŠžèŠºèŠ´èŠ¨èŠ¡èŠ©è‹‚èŠ¤è‹ƒèŠ¶èŠ¢è™°è™¯è™­è™®è±–è¿’è¿‹è¿“è¿è¿–è¿•è¿—é‚²é‚´é‚¯é‚³é‚°é˜¹é˜½é˜¼é˜ºé™ƒä¿ä¿…ä¿“ä¾²ä¿‰ä¿‹ä¿ä¿”ä¿œä¿™ä¾»ä¾³ä¿›ä¿‡ä¿–ä¾ºä¿€ä¾¹ä¿¬å‰„å‰‰å‹€å‹‚åŒ½å¼åŽ—åŽ–åŽ™åŽ˜å’ºå’¡å’­å’¥å“"],["ce40","å“ƒèŒå’·å’®å“–å’¶å“…å“†å’ å‘°å’¼å’¢å’¾å‘²å“žå’°åžµåžžåžŸåž¤åžŒåž—åžåž›åž”åž˜åžåž™åž¥åžšåž•å£´å¤å¥“å§¡å§žå§®å¨€å§±å§å§ºå§½å§¼å§¶å§¤å§²å§·å§›å§©å§³å§µå§ å§¾å§´å§­å®¨å±Œå³å³˜å³Œå³—å³‹å³›"],["cea1","å³žå³šå³‰å³‡å³Šå³–å³“å³”å³å³ˆå³†å³Žå³Ÿå³¸å·¹å¸¡å¸¢å¸£å¸ å¸¤åº°åº¤åº¢åº›åº£åº¥å¼‡å¼®å½–å¾†æ€·æ€¹æ”æ²æžæ…æ“æ‡æ‰æ›æŒæ€æ‚æŸæ€¤æ„æ˜æ¦æ®æ‰‚æ‰ƒæ‹æŒæŒ‹æ‹µæŒŽæŒƒæ‹«æ‹¹æŒæŒŒæ‹¸æ‹¶æŒ€æŒ“æŒ”æ‹ºæŒ•æ‹»æ‹°æ•æ•ƒæ–ªæ–¿æ˜¶æ˜¡æ˜²æ˜µæ˜œæ˜¦æ˜¢æ˜³æ˜«æ˜ºæ˜æ˜´æ˜¹æ˜®æœæœæŸæŸ²æŸˆæžº"],["cf40","æŸœæž»æŸ¸æŸ˜æŸ€æž·æŸ…æŸ«æŸ¤æŸŸæžµæŸæž³æŸ·æŸ¶æŸ®æŸ£æŸ‚æž¹æŸŽæŸ§æŸ°æž²æŸ¼æŸ†æŸ­æŸŒæž®æŸ¦æŸ›æŸºæŸ‰æŸŠæŸƒæŸªæŸ‹æ¬¨æ®‚æ®„æ®¶æ¯–æ¯˜æ¯ æ° æ°¡æ´¨æ´´æ´­æ´Ÿæ´¼æ´¿æ´’æ´Šæ³šæ´³æ´„æ´™æ´ºæ´šæ´‘æ´€æ´æµ‚"],["cfa1","æ´æ´˜æ´·æ´ƒæ´æµ€æ´‡æ´ æ´¬æ´ˆæ´¢æ´‰æ´ç‚·ç‚Ÿç‚¾ç‚±ç‚°ç‚¡ç‚´ç‚µç‚©ç‰ç‰‰ç‰Šç‰¬ç‰°ç‰³ç‰®ç‹Šç‹¤ç‹¨ç‹«ç‹Ÿç‹ªç‹¦ç‹£çŽ…çŒç‚çˆç…çŽ¹çŽ¶çŽµçŽ´ç«çŽ¿ç‡çŽ¾çƒç†çŽ¸ç‹ç“¬ç“®ç”®ç•‡ç•ˆç–§ç–ªç™¹ç›„çœˆçœƒçœ„çœ…çœŠç›·ç›»ç›ºçŸ§çŸ¨ç †ç ‘ç ’ç …ç ç ç Žç ‰ç ƒç “ç¥Šç¥Œç¥‹ç¥…ç¥„ç§•ç§ç§ç§–ç§Žçª€"],["d040","ç©¾ç«‘ç¬€ç¬ç±ºç±¸ç±¹ç±¿ç²€ç²ç´ƒç´ˆç´ç½˜ç¾‘ç¾ç¾¾è€‡è€Žè€è€”è€·èƒ˜èƒ‡èƒ èƒ‘èƒˆèƒ‚èƒèƒ…èƒ£èƒ™èƒœèƒŠèƒ•èƒ‰èƒèƒ—èƒ¦èƒè‡¿èˆ¡èŠ”è‹™è‹¾è‹¹èŒ‡è‹¨èŒ€è‹•èŒºè‹«è‹–è‹´è‹¬è‹¡è‹²è‹µèŒŒè‹»è‹¶è‹°è‹ª"],["d0a1","è‹¤è‹ è‹ºè‹³è‹­è™·è™´è™¼è™³è¡è¡Žè¡§è¡ªè¡©è§“è¨„è¨‡èµ²è¿£è¿¡è¿®è¿ éƒ±é‚½é‚¿éƒ•éƒ…é‚¾éƒ‡éƒ‹éƒˆé‡”é‡“é™”é™é™‘é™“é™Šé™Žå€žå€…å€‡å€“å€¢å€°å€›ä¿µä¿´å€³å€·å€¬ä¿¶ä¿·å€—å€œå€ å€§å€µå€¯å€±å€Žå…šå†”å†“å‡Šå‡„å‡…å‡ˆå‡Žå‰¡å‰šå‰’å‰žå‰Ÿå‰•å‰¢å‹åŒŽåŽžå”¦å“¢å”—å”’å“§å“³å“¤å”šå“¿å”„å”ˆå“«å”‘å”…å“±"],["d140","å”Šå“»å“·å“¸å“ å”Žå”ƒå”‹åœåœ‚åŸŒå ²åŸ•åŸ’åžºåŸ†åž½åž¼åž¸åž¶åž¿åŸ‡åŸåž¹åŸå¤Žå¥Šå¨™å¨–å¨­å¨®å¨•å¨å¨—å¨Šå¨žå¨³å­¬å®§å®­å®¬å°ƒå±–å±”å³¬å³¿å³®å³±å³·å´€å³¹å¸©å¸¨åº¨åº®åºªåº¬å¼³å¼°å½§ææšæ§"],["d1a1","ææ‚¢æ‚ˆæ‚€æ‚’æ‚æ‚æ‚ƒæ‚•æ‚›æ‚—æ‚‡æ‚œæ‚Žæˆ™æ‰†æ‹²æŒæ–æŒ¬æ„æ…æŒ¶æƒæ¤æŒ¹æ‹æŠæŒ¼æŒ©ææŒ´æ˜æ”æ™æŒ­æ‡æŒ³æšæ‘æŒ¸æ—æ€æˆæ•Šæ•†æ—†æ—ƒæ—„æ—‚æ™Šæ™Ÿæ™‡æ™‘æœ’æœ“æ Ÿæ šæ¡‰æ ²æ ³æ »æ¡‹æ¡æ –æ ±æ œæ µæ «æ ­æ ¯æ¡Žæ¡„æ ´æ æ ’æ ”æ ¦æ ¨æ ®æ¡æ ºæ ¥æ  æ¬¬æ¬¯æ¬­æ¬±æ¬´æ­­è‚‚æ®ˆæ¯¦æ¯¤"],["d240","æ¯¨æ¯£æ¯¢æ¯§æ°¥æµºæµ£æµ¤æµ¶æ´æµ¡æ¶’æµ˜æµ¢æµ­æµ¯æ¶‘æ¶æ·¯æµ¿æ¶†æµžæµ§æµ æ¶—æµ°æµ¼æµŸæ¶‚æ¶˜æ´¯æµ¨æ¶‹æµ¾æ¶€æ¶„æ´–æ¶ƒæµ»æµ½æµµæ¶çƒœçƒ“çƒ‘çƒçƒ‹ç¼¹çƒ¢çƒ—çƒ’çƒžçƒ çƒ”çƒçƒ…çƒ†çƒ‡çƒšçƒŽçƒ¡ç‰‚ç‰¸"],["d2a1","ç‰·ç‰¶çŒ€ç‹ºç‹´ç‹¾ç‹¶ç‹³ç‹»çŒç“ç™ç¥ç–çŽ¼ç§ç£ç©çœç’ç›ç”ççšç—ç˜ç¨ç“žç“Ÿç“´ç“µç”¡ç•›ç•Ÿç–°ç—ç–»ç—„ç—€ç–¿ç–¶ç–ºçšŠç›‰çœçœ›çœçœ“çœ’çœ£çœ‘çœ•çœ™çœšçœ¢çœ§ç £ç ¬ç ¢ç µç ¯ç ¨ç ®ç «ç ¡ç ©ç ³ç ªç ±ç¥”ç¥›ç¥ç¥œç¥“ç¥’ç¥‘ç§«ç§¬ç§ ç§®ç§­ç§ªç§œç§žç§çª†çª‰çª…çª‹çªŒçªŠçª‡ç«˜ç¬"],["d340","ç¬„ç¬“ç¬…ç¬ç¬ˆç¬Šç¬Žç¬‰ç¬’ç²„ç²‘ç²Šç²Œç²ˆç²ç²…ç´žç´ç´‘ç´Žç´˜ç´–ç´“ç´Ÿç´’ç´ç´Œç½œç½¡ç½žç½ ç½ç½›ç¾–ç¾’ç¿ƒç¿‚ç¿€è€–è€¾è€¹èƒºèƒ²èƒ¹èƒµè„èƒ»è„€èˆèˆ¯èˆ¥èŒ³èŒ­è„èŒ™è‘èŒ¥è–èŒ¿èèŒ¦èŒœèŒ¢"],["d3a1","è‚èŽèŒ›èŒªèŒˆèŒ¼èèŒ–èŒ¤èŒ èŒ·èŒ¯èŒ©è‡è…èŒè“èŒžèŒ¬è‹èŒ§èˆè™“è™’èš¢èš¨èš–èšèš‘èšžèš‡èš—èš†èš‹èššèš…èš¥èš™èš¡èš§èš•èš˜èšŽèšèšèš”è¡ƒè¡„è¡­è¡µè¡¶è¡²è¢€è¡±è¡¿è¡¯è¢ƒè¡¾è¡´è¡¼è¨’è±‡è±—è±»è²¤è²£èµ¶èµ¸è¶µè¶·è¶¶è»‘è»“è¿¾è¿µé€‚è¿¿è¿»é€„è¿¼è¿¶éƒ–éƒ éƒ™éƒšéƒ£éƒŸéƒ¥éƒ˜éƒ›éƒ—éƒœéƒ¤é…"],["d440","é…Žé…é‡•é‡¢é‡šé™œé™Ÿéš¼é££é«Ÿé¬¯ä¹¿å°åªå¡åžå å“å‹åå²åˆååå›åŠå¢å€•å…åŸå©å«å£å¤å†å€å®å³å—å‘å‡å‰«å‰­å‰¬å‰®å‹–å‹“åŒ­åŽœå•µå•¶å”¼å•å•å”´å”ªå•‘å•¢å”¶å”µå”°å•’å•…"],["d4a1","å”Œå”²å•¥å•Žå”¹å•ˆå”­å”»å•€å•‹åœŠåœ‡åŸ»å ”åŸ¢åŸ¶åŸœåŸ´å €åŸ­åŸ½å ˆåŸ¸å ‹åŸ³åŸå ‡åŸ®åŸ£åŸ²åŸ¥åŸ¬åŸ¡å ŽåŸ¼å åŸ§å å ŒåŸ±åŸ©åŸ°å å „å¥œå© å©˜å©•å©§å©žå¨¸å¨µå©­å©å©Ÿå©¥å©¬å©“å©¤å©—å©ƒå©å©’å©„å©›å©ˆåªŽå¨¾å©å¨¹å©Œå©°å©©å©‡å©‘å©–å©‚å©œå­²å­®å¯å¯€å±™å´žå´‹å´å´šå´ å´Œå´¨å´å´¦å´¥å´"],["d540","å´°å´’å´£å´Ÿå´®å¸¾å¸´åº±åº´åº¹åº²åº³å¼¶å¼¸å¾›å¾–å¾Ÿæ‚Šæ‚æ‚†æ‚¾æ‚°æ‚ºæƒ“æƒ”æƒæƒ¤æƒ™æƒæƒˆæ‚±æƒ›æ‚·æƒŠæ‚¿æƒƒæƒæƒ€æŒ²æ¥æŽŠæŽ‚æ½æŽ½æŽžæŽ­æŽæŽ—æŽ«æŽŽæ¯æŽ‡æŽæ®æŽ¯æµæŽœæ­æŽ®æ¼æŽ¤æŒ»æŽŸ"],["d5a1","æ¸æŽ…æŽæŽ‘æŽæ°æ•“æ—æ™¥æ™¡æ™›æ™™æ™œæ™¢æœ˜æ¡¹æ¢‡æ¢æ¢œæ¡­æ¡®æ¢®æ¢«æ¥–æ¡¯æ¢£æ¢¬æ¢©æ¡µæ¡´æ¢²æ¢æ¡·æ¢’æ¡¼æ¡«æ¡²æ¢ªæ¢€æ¡±æ¡¾æ¢›æ¢–æ¢‹æ¢ æ¢‰æ¢¤æ¡¸æ¡»æ¢‘æ¢Œæ¢Šæ¡½æ¬¶æ¬³æ¬·æ¬¸æ®‘æ®æ®æ®Žæ®Œæ°ªæ·€æ¶«æ¶´æ¶³æ¹´æ¶¬æ·©æ·¢æ¶·æ·¶æ·”æ¸€æ·ˆæ· æ·Ÿæ·–æ¶¾æ·¥æ·œæ·æ·›æ·´æ·Šæ¶½æ·­æ·°æ¶ºæ·•æ·‚æ·æ·‰"],["d640","æ·æ·²æ·“æ·½æ·—æ·æ·£æ¶»çƒºç„çƒ·ç„—çƒ´ç„Œçƒ°ç„„çƒ³ç„çƒ¼çƒ¿ç„†ç„“ç„€çƒ¸çƒ¶ç„‹ç„‚ç„Žç‰¾ç‰»ç‰¼ç‰¿çŒçŒ—çŒ‡çŒ‘çŒ˜çŒŠçŒˆç‹¿çŒçŒžçŽˆç¶ç¸çµç„çç½ç‡ç€çºç¼ç¿çŒç‹ç´çˆç•¤ç•£ç—Žç—’ç—"],["d6a1","ç—‹ç—Œç—‘ç—çšçš‰ç›“çœ¹çœ¯çœ­çœ±çœ²çœ´çœ³çœ½çœ¥çœ»çœµç¡ˆç¡’ç¡‰ç¡ç¡Šç¡Œç ¦ç¡…ç¡ç¥¤ç¥§ç¥©ç¥ªç¥£ç¥«ç¥¡ç¦»ç§ºç§¸ç§¶ç§·çªçª”çªç¬µç­‡ç¬´ç¬¥ç¬°ç¬¢ç¬¤ç¬³ç¬˜ç¬ªç¬ç¬±ç¬«ç¬­ç¬¯ç¬²ç¬¸ç¬šç¬£ç²”ç²˜ç²–ç²£ç´µç´½ç´¸ç´¶ç´ºçµ…ç´¬ç´©çµçµ‡ç´¾ç´¿çµŠç´»ç´¨ç½£ç¾•ç¾œç¾ç¾›ç¿Šç¿‹ç¿ç¿ç¿‘ç¿‡ç¿ç¿‰è€Ÿ"],["d740","è€žè€›è‡èƒèˆè„˜è„¥è„™è„›è„­è„Ÿè„¬è„žè„¡è„•è„§è„è„¢èˆ‘èˆ¸èˆ³èˆºèˆ´èˆ²è‰´èŽèŽ£èŽ¨èŽèºè³èŽ¤è´èŽèŽèŽ•èŽ™èµèŽ”èŽ©è½èŽƒèŽŒèŽèŽ›èŽªèŽ‹è¾èŽ¥èŽ¯èŽˆèŽ—èŽ°è¿èŽ¦èŽ‡èŽ®è¶èŽšè™™è™–èš¿èš·"],["d7a1","è›‚è›è›…èšºèš°è›ˆèš¹èš³èš¸è›Œèš´èš»èš¼è›ƒèš½èš¾è¡’è¢‰è¢•è¢¨è¢¢è¢ªè¢šè¢‘è¢¡è¢Ÿè¢˜è¢§è¢™è¢›è¢—è¢¤è¢¬è¢Œè¢“è¢Žè¦‚è§–è§™è§•è¨°è¨§è¨¬è¨žè°¹è°»è±œè±è±½è²¥èµ½èµ»èµ¹è¶¼è·‚è¶¹è¶¿è·è»˜è»žè»è»œè»—è» è»¡é€¤é€‹é€‘é€œé€Œé€¡éƒ¯éƒªéƒ°éƒ´éƒ²éƒ³éƒ”éƒ«éƒ¬éƒ©é…–é…˜é…šé…“é…•é‡¬é‡´é‡±é‡³é‡¸é‡¤é‡¹é‡ª"],["d840","é‡«é‡·é‡¨é‡®é•ºé–†é–ˆé™¼é™­é™«é™±é™¯éš¿éªé „é£¥é¦—å‚›å‚•å‚”å‚žå‚‹å‚£å‚ƒå‚Œå‚Žå‚å¨å‚œå‚’å‚‚å‚‡å…Ÿå‡”åŒ’åŒ‘åŽ¤åŽ§å–‘å–¨å–¥å–­å•·å™…å–¢å–“å–ˆå–å–µå–å–£å–’å–¤å•½å–Œå–¦å•¿å–•å–¡å–ŽåœŒå ©å ·"],["d8a1","å ™å žå §å £å ¨åŸµå¡ˆå ¥å œå ›å ³å ¿å ¶å ®å ¹å ¸å ­å ¬å »å¥¡åª¯åª”åªŸå©ºåª¢åªžå©¸åª¦å©¼åª¥åª¬åª•åª®å¨·åª„åªŠåª—åªƒåª‹åª©å©»å©½åªŒåªœåªåª“åªå¯ªå¯å¯‹å¯”å¯‘å¯Šå¯Žå°Œå°°å´·åµƒåµ«åµåµ‹å´¿å´µåµ‘åµŽåµ•å´³å´ºåµ’å´½å´±åµ™åµ‚å´¹åµ‰å´¸å´¼å´²å´¶åµ€åµ…å¹„å¹å½˜å¾¦å¾¥å¾«æƒ‰æ‚¹æƒŒæƒ¢æƒŽæƒ„æ„”"],["d940","æƒ²æ„Šæ„–æ„…æƒµæ„“æƒ¸æƒ¼æƒ¾æƒæ„ƒæ„˜æ„æ„æƒ¿æ„„æ„‹æ‰ŠæŽ”æŽ±æŽ°æŽæ¥æ¨æ¯æƒæ’æ³æŠæ æ¶æ•æ²æµæ‘¡æŸæŽ¾ææœæ„æ˜æ“æ‚æ‡æŒæ‹æˆæ°æ—æ™æ”²æ•§æ•ªæ•¤æ•œæ•¨æ•¥æ–Œæ–æ–žæ–®æ—æ—’"],["d9a1","æ™¼æ™¬æ™»æš€æ™±æ™¹æ™ªæ™²æœæ¤Œæ£“æ¤„æ£œæ¤ªæ£¬æ£ªæ£±æ¤æ£–æ£·æ£«æ£¤æ£¶æ¤“æ¤æ£³æ£¡æ¤‡æ£Œæ¤ˆæ¥°æ¢´æ¤‘æ£¯æ£†æ¤”æ£¸æ£æ£½æ£¼æ£¨æ¤‹æ¤Šæ¤—æ£Žæ£ˆæ£æ£žæ£¦æ£´æ£‘æ¤†æ£”æ£©æ¤•æ¤¥æ£‡æ¬¹æ¬»æ¬¿æ¬¼æ®”æ®—æ®™æ®•æ®½æ¯°æ¯²æ¯³æ°°æ·¼æ¹†æ¹‡æ¸Ÿæ¹‰æºˆæ¸¼æ¸½æ¹…æ¹¢æ¸«æ¸¿æ¹æ¹æ¹³æ¸œæ¸³æ¹‹æ¹€æ¹‘æ¸»æ¸ƒæ¸®æ¹ž"],["da40","æ¹¨æ¹œæ¹¡æ¸±æ¸¨æ¹ æ¹±æ¹«æ¸¹æ¸¢æ¸°æ¹“æ¹¥æ¸§æ¹¸æ¹¤æ¹·æ¹•æ¹¹æ¹’æ¹¦æ¸µæ¸¶æ¹šç„ ç„žç„¯çƒ»ç„®ç„±ç„£ç„¥ç„¢ç„²ç„Ÿç„¨ç„ºç„›ç‰‹ç‰šçŠˆçŠ‰çŠ†çŠ…çŠ‹çŒ’çŒ‹çŒ°çŒ¢çŒ±çŒ³çŒ§çŒ²çŒ­çŒ¦çŒ£çŒµçŒŒç®ç¬ç°ç«ç–"],["daa1","çšç¡ç­ç±ç¤ç£çç©ç ç²ç“»ç”¯ç•¯ç•¬ç—§ç—šç—¡ç—¦ç—ç—Ÿç—¤ç——çš•çš’ç›šç†ç‡ç„çç…çŠçŽç‹çŒçŸžçŸ¬ç¡ ç¡¤ç¡¥ç¡œç¡­ç¡±ç¡ªç¡®ç¡°ç¡©ç¡¨ç¡žç¡¢ç¥´ç¥³ç¥²ç¥°ç¨‚ç¨Šç¨ƒç¨Œç¨„çª™ç«¦ç«¤ç­Šç¬»ç­„ç­ˆç­Œç­Žç­€ç­˜ç­…ç²¢ç²žç²¨ç²¡çµ˜çµ¯çµ£çµ“çµ–çµ§çµªçµçµ­çµœçµ«çµ’çµ”çµ©çµ‘çµŸçµŽç¼¾ç¼¿ç½¥"],["db40","ç½¦ç¾¢ç¾ ç¾¡ç¿—è‘èèèƒ¾èƒ”è…ƒè…Šè…’è…è…‡è„½è…è„ºè‡¦è‡®è‡·è‡¸è‡¹èˆ„èˆ¼èˆ½èˆ¿è‰µèŒ»èè¹è£è€è¨è’è§è¤è¼è¶èè†èˆè«è£èŽ¿èèè¥è˜è¿è¡è‹èŽè–èµè‰è‰èèžè‘è†è‚è³"],["dba1","è•èºè‡è‘èªè“èƒè¬è®è„è»è—è¢è›è›è¾è›˜è›¢è›¦è›“è›£è›šè›ªè›è›«è›œè›¬è›©è›—è›¨è›‘è¡ˆè¡–è¡•è¢ºè£—è¢¹è¢¸è£€è¢¾è¢¶è¢¼è¢·è¢½è¢²è¤è£‰è¦•è¦˜è¦—è§è§šè§›è©Žè©è¨¹è©™è©€è©—è©˜è©„è©…è©’è©ˆè©‘è©Šè©Œè©è±Ÿè²è²€è²ºè²¾è²°è²¹è²µè¶„è¶€è¶‰è·˜è·“è·è·‡è·–è·œè·è·•è·™è·ˆè·—è·…è»¯è»·è»º"],["dc40","è»¹è»¦è»®è»¥è»µè»§è»¨è»¶è»«è»±è»¬è»´è»©é€­é€´é€¯é„†é„¬é„„éƒ¿éƒ¼é„ˆéƒ¹éƒ»é„é„€é„‡é„…é„ƒé…¡é…¤é…Ÿé…¢é… éˆéˆŠéˆ¥éˆƒéˆšéˆ¦éˆéˆŒéˆ€éˆ’é‡¿é‡½éˆ†éˆ„éˆ§éˆ‚éˆœéˆ¤éˆ™éˆ—éˆ…éˆ–é•»é–é–Œé–éš‡é™¾éšˆ"],["dca1","éš‰éšƒéš€é›‚é›ˆé›ƒé›±é›°é¬é°é®é ‡é¢©é£«é³¦é»¹äºƒäº„äº¶å‚½å‚¿åƒ†å‚®åƒ„åƒŠå‚´åƒˆåƒ‚å‚°åƒå‚ºå‚±åƒ‹åƒ‰å‚¶å‚¸å‡—å‰ºå‰¸å‰»å‰¼å—ƒå—›å—Œå—å—‹å—Šå—å—€å—”å—„å—©å–¿å—’å–å—å—•å—¢å—–å—ˆå—²å—å—™å—‚åœ”å¡“å¡¨å¡¤å¡å¡å¡‰å¡¯å¡•å¡Žå¡å¡™å¡¥å¡›å ½å¡£å¡±å£¼å«‡å«„å«‹åªºåª¸åª±åªµåª°åª¿å«ˆåª»å«†"],["dd40","åª·å«€å«Šåª´åª¶å«åª¹åªå¯–å¯˜å¯™å°Ÿå°³åµ±åµ£åµŠåµ¥åµ²åµ¬åµžåµ¨åµ§åµ¢å·°å¹å¹Žå¹Šå¹å¹‹å»…å»Œå»†å»‹å»‡å½€å¾¯å¾­æƒ·æ…‰æ…Šæ„«æ……æ„¶æ„²æ„®æ…†æ„¯æ…æ„©æ…€æˆ é…¨æˆ£æˆ¥æˆ¤æ…æ±æ«ææ’æ‰æ æ¤"],["dda1","æ³æ‘ƒæŸæ•æ˜æ¹æ·æ¢æ£æŒæ¦æ°æ¨æ‘æµæ¯æŠæšæ‘€æ¥æ§æ‹æ§æ›æ®æ¡æŽæ•¯æ–’æ—“æš†æšŒæš•æšæš‹æšŠæš™æš”æ™¸æœ æ¥¦æ¥Ÿæ¤¸æ¥Žæ¥¢æ¥±æ¤¿æ¥…æ¥ªæ¤¹æ¥‚æ¥—æ¥™æ¥ºæ¥ˆæ¥‰æ¤µæ¥¬æ¤³æ¤½æ¥¥æ£°æ¥¸æ¤´æ¥©æ¥€æ¥¯æ¥„æ¥¶æ¥˜æ¥æ¥´æ¥Œæ¤»æ¥‹æ¤·æ¥œæ¥æ¥‘æ¤²æ¥’æ¤¯æ¥»æ¤¼æ­†æ­…æ­ƒæ­‚æ­ˆæ­æ®›ï¨æ¯»æ¯¼"],["de40","æ¯¹æ¯·æ¯¸æº›æ»–æ»ˆæºæ»€æºŸæº“æº”æº æº±æº¹æ»†æ»’æº½æ»æºžæ»‰æº·æº°æ»æº¦æ»æº²æº¾æ»ƒæ»œæ»˜æº™æº’æºŽæºæº¤æº¡æº¿æº³æ»æ»Šæº—æº®æº£ç…‡ç…”ç…’ç…£ç… ç…ç…ç…¢ç…²ç…¸ç…ªç…¡ç…‚ç…˜ç…ƒç…‹ç…°ç…Ÿç…ç…“"],["dea1","ç…„ç…ç…šç‰çŠçŠŒçŠ‘çŠçŠŽçŒ¼ç‚çŒ»çŒºç€çŠç‰ç‘„ç‘Šç‘‹ç‘’ç‘‘ç‘—ç‘€ç‘ç‘ç‘Žç‘‚ç‘†ç‘ç‘”ç“¡ç“¿ç“¾ç“½ç”ç•¹ç•·æ¦ƒç—¯ç˜ç˜ƒç—·ç—¾ç—¼ç—¹ç—¸ç˜ç—»ç—¶ç—­ç—µç—½çš™çšµç›ç•çŸç ç’ç–çšç©ç§ç”ç™ç­çŸ ç¢‡ç¢šç¢”ç¢ç¢„ç¢•ç¢…ç¢†ç¢¡ç¢ƒç¡¹ç¢™ç¢€ç¢–ç¡»ç¥¼ç¦‚ç¥½ç¥¹ç¨‘ç¨˜ç¨™ç¨’ç¨—ç¨•ç¨¢ç¨“"],["df40","ç¨›ç¨çª£çª¢çªžç««ç­¦ç­¤ç­­ç­´ç­©ç­²ç­¥ç­³ç­±ç­°ç­¡ç­¸ç­¶ç­£ç²²ç²´ç²¯ç¶ˆç¶†ç¶€ç¶çµ¿ç¶…çµºç¶Žçµ»ç¶ƒçµ¼ç¶Œç¶”ç¶„çµ½ç¶’ç½­ç½«ç½§ç½¨ç½¬ç¾¦ç¾¥ç¾§ç¿›ç¿œè€¡è…¤è… è…·è…œè…©è…›è…¢è…²æœ¡è…žè…¶è…§è…¯"],["dfa1","è…„è…¡èˆè‰‰è‰„è‰€è‰‚è‰…è“±è¿è‘–è‘¶è‘¹è’è’è‘¥è‘‘è‘€è’†è‘§è°è‘è‘½è‘šè‘™è‘´è‘³è‘è”‡è‘žè·èºè´è‘ºè‘ƒè‘¸è²è‘…è©è™è‘‹è¯è‘‚è­è‘Ÿè‘°è¹è‘Žè‘Œè‘’è‘¯è“…è’Žè»è‘‡è¶è³è‘¨è‘¾è‘„è«è‘ è‘”è‘®è‘èœ‹èœ„è›·èœŒè›ºè›–è›µèè›¸èœŽèœ‰èœè›¶èœèœ…è£–è£‹è£è£Žè£žè£›è£šè£Œè£è¦…è¦›è§Ÿè§¥è§¤"],["e040","è§¡è§ è§¢è§œè§¦è©¶èª†è©¿è©¡è¨¿è©·èª‚èª„è©µèªƒèªè©´è©ºè°¼è±‹è±Šè±¥è±¤è±¦è²†è²„è²…è³Œèµ¨èµ©è¶‘è¶Œè¶Žè¶è¶è¶“è¶”è¶è¶’è·°è· è·¬è·±è·®è·è·©è·£è·¢è·§è·²è·«è·´è¼†è»¿è¼è¼€è¼…è¼‡è¼ˆè¼‚è¼‹é’é€¿"],["e0a1","é„é‰é€½é„é„é„é„‘é„–é„”é„‹é„Žé…®é…¯é‰ˆé‰’éˆ°éˆºé‰¦éˆ³é‰¥é‰žéŠƒéˆ®é‰Šé‰†é‰­é‰¬é‰é‰ é‰§é‰¯éˆ¶é‰¡é‰°éˆ±é‰”é‰£é‰é‰²é‰Žé‰“é‰Œé‰–éˆ²é–Ÿé–œé–žé–›éš’éš“éš‘éš—é›Žé›ºé›½é›¸é›µé³é·é¸é²é é é Žé¢¬é£¶é£¹é¦¯é¦²é¦°é¦µéª­éª«é­›é³ªé³­é³§éº€é»½åƒ¦åƒ”åƒ—åƒ¨åƒ³åƒ›åƒªåƒåƒ¤åƒ“åƒ¬åƒ°åƒ¯åƒ£åƒ "],["e140","å‡˜åŠ€åŠå‹©å‹«åŒ°åŽ¬å˜§å˜•å˜Œå˜’å—¼å˜å˜œå˜å˜“å˜‚å—ºå˜å˜„å—¿å—¹å¢‰å¡¼å¢å¢˜å¢†å¢å¡¿å¡´å¢‹å¡ºå¢‡å¢‘å¢Žå¡¶å¢‚å¢ˆå¡»å¢”å¢å£¾å¥«å«œå«®å«¥å«•å«ªå«šå«­å««å«³å«¢å« å«›å«¬å«žå«å«™å«¨å«Ÿå­·å¯ "],["e1a1","å¯£å±£å¶‚å¶€åµ½å¶†åµºå¶åµ·å¶Šå¶‰å¶ˆåµ¾åµ¼å¶åµ¹åµ¿å¹˜å¹™å¹“å»˜å»‘å»—å»Žå»œå»•å»™å»’å»”å½„å½ƒå½¯å¾¶æ„¬æ„¨æ…æ…žæ…±æ…³æ…’æ…“æ…²æ…¬æ†€æ…´æ…”æ…ºæ…›æ…¥æ„»æ…ªæ…¡æ…–æˆ©æˆ§æˆ«æ«æ‘æ‘›æ‘æ‘´æ‘¶æ‘²æ‘³æ‘½æ‘µæ‘¦æ’¦æ‘Žæ’‚æ‘žæ‘œæ‘‹æ‘“æ‘ æ‘æ‘¿æ¿æ‘¬æ‘«æ‘™æ‘¥æ‘·æ•³æ– æš¡æš æšŸæœ…æœ„æœ¢æ¦±æ¦¶æ§‰"],["e240","æ¦ æ§Žæ¦–æ¦°æ¦¬æ¦¼æ¦‘æ¦™æ¦Žæ¦§æ¦æ¦©æ¦¾æ¦¯æ¦¿æ§„æ¦½æ¦¤æ§”æ¦¹æ§Šæ¦šæ§æ¦³æ¦“æ¦ªæ¦¡æ¦žæ§™æ¦—æ¦æ§‚æ¦µæ¦¥æ§†æ­Šæ­æ­‹æ®žæ®Ÿæ® æ¯ƒæ¯„æ¯¾æ»Žæ»µæ»±æ¼ƒæ¼¥æ»¸æ¼·æ»»æ¼®æ¼‰æ½Žæ¼™æ¼šæ¼§æ¼˜æ¼»æ¼’æ»­æ¼Š"],["e2a1","æ¼¶æ½³æ»¹æ»®æ¼­æ½€æ¼°æ¼¼æ¼µæ»«æ¼‡æ¼Žæ½ƒæ¼…æ»½æ»¶æ¼¹æ¼œæ»¼æ¼ºæ¼Ÿæ¼æ¼žæ¼ˆæ¼¡ç†‡ç†ç†‰ç†€ç†…ç†‚ç†ç…»ç††ç†ç†—ç‰„ç‰“çŠ—çŠ•çŠ“çƒçç‘çŒç‘¢ç‘³ç‘±ç‘µç‘²ç‘§ç‘®ç”€ç”‚ç”ƒç•½ç–ç˜–ç˜ˆç˜Œç˜•ç˜‘ç˜Šç˜”çš¸çžç¼çž…çž‚ç®çž€ç¯ç¾çžƒç¢²ç¢ªç¢´ç¢­ç¢¨ç¡¾ç¢«ç¢žç¢¥ç¢ ç¢¬ç¢¢ç¢¤ç¦˜ç¦Šç¦‹ç¦–ç¦•ç¦”ç¦“"],["e340","ç¦—ç¦ˆç¦’ç¦ç¨«ç©Šç¨°ç¨¯ç¨¨ç¨¦çª¨çª«çª¬ç«®ç®ˆç®œç®Šç®‘ç®ç®–ç®ç®Œç®›ç®Žç®…ç®˜åŠ„ç®™ç®¤ç®‚ç²»ç²¿ç²¼ç²ºç¶§ç¶·ç·‚ç¶£ç¶ªç·ç·€ç·…ç¶ç·Žç·„ç·†ç·‹ç·Œç¶¯ç¶¹ç¶–ç¶¼ç¶Ÿç¶¦ç¶®ç¶©ç¶¡ç·‰ç½³ç¿¢ç¿£ç¿¥ç¿ž"],["e3a1","è€¤èèœè†‰è††è†ƒè†‡è†è†Œè†‹èˆ•è’—è’¤è’¡è’Ÿè’ºè“Žè“‚è’¬è’®è’«è’¹è’´è“è“è’ªè’šè’±è“è’è’§è’»è’¢è’”è“‡è“Œè’›è’©è’¯è’¨è“–è’˜è’¶è“è’ è“—è“”è“’è“›è’°è’‘è™¡èœ³èœ£èœ¨è«è€èœ®èœžèœ¡èœ™èœ›èƒèœ¬èèœ¾è†èœ èœ²èœªèœ­èœ¼èœ’èœºèœ±èœµè‚èœ¦èœ§èœ¸èœ¤èœšèœ°èœ‘è£·è£§è£±è£²è£ºè£¾è£®è£¼è£¶è£»"],["e440","è£°è£¬è£«è¦è¦¡è¦Ÿè¦žè§©è§«è§¨èª«èª™èª‹èª’èªèª–è°½è±¨è±©è³•è³è³—è¶–è¸‰è¸‚è·¿è¸è·½è¸Šè¸ƒè¸‡è¸†è¸…è·¾è¸€è¸„è¼è¼‘è¼Žè¼é„£é„œé„ é„¢é„Ÿé„é„šé„¤é„¡é„›é…ºé…²é…¹é…³éŠ¥éŠ¤é‰¶éŠ›é‰ºéŠ éŠ”éŠªéŠ"],["e4a1","éŠ¦éŠšéŠ«é‰¹éŠ—é‰¿éŠ£é‹®éŠŽéŠ‚éŠ•éŠ¢é‰½éŠˆéŠ¡éŠŠéŠ†éŠŒéŠ™éŠ§é‰¾éŠ‡éŠ©éŠéŠ‹éˆ­éšžéš¡é›¿é˜é½éºé¾éžƒéž€éž‚é»éž„éžé¿éŸŽéŸé –é¢­é¢®é¤‚é¤€é¤‡é¦é¦œé§ƒé¦¹é¦»é¦ºé§‚é¦½é§‡éª±é«£é«§é¬¾é¬¿é­ é­¡é­Ÿé³±é³²é³µéº§åƒ¿å„ƒå„°åƒ¸å„†å„‡åƒ¶åƒ¾å„‹å„Œåƒ½å„ŠåŠ‹åŠŒå‹±å‹¯å™ˆå™‚å™Œå˜µå™å™Šå™‰å™†å™˜"],["e540","å™šå™€å˜³å˜½å˜¬å˜¾å˜¸å˜ªå˜ºåœšå¢«å¢å¢±å¢ å¢£å¢¯å¢¬å¢¥å¢¡å£¿å«¿å«´å«½å«·å«¶å¬ƒå«¸å¬‚å«¹å¬å¬‡å¬…å¬å±§å¶™å¶—å¶Ÿå¶’å¶¢å¶“å¶•å¶ å¶œå¶¡å¶šå¶žå¹©å¹å¹ å¹œç·³å»›å»žå»¡å½‰å¾²æ†‹æ†ƒæ…¹æ†±æ†°æ†¢æ†‰"],["e5a1","æ†›æ†“æ†¯æ†­æ†Ÿæ†’æ†ªæ†¡æ†æ…¦æ†³æˆ­æ‘®æ‘°æ’–æ’ æ’…æ’—æ’œæ’æ’‹æ’Šæ’Œæ’£æ’Ÿæ‘¨æ’±æ’˜æ•¶æ•ºæ•¹æ•»æ–²æ–³æšµæš°æš©æš²æš·æšªæš¯æ¨€æ¨†æ¨—æ§¥æ§¸æ¨•æ§±æ§¤æ¨ æ§¿æ§¬æ§¢æ¨›æ¨æ§¾æ¨§æ§²æ§®æ¨”æ§·æ§§æ©€æ¨ˆæ§¦æ§»æ¨æ§¼æ§«æ¨‰æ¨„æ¨˜æ¨¥æ¨æ§¶æ¨¦æ¨‡æ§´æ¨–æ­‘æ®¥æ®£æ®¢æ®¦æ°æ°€æ¯¿æ°‚æ½æ¼¦æ½¾æ¾‡æ¿†æ¾’"],["e640","æ¾æ¾‰æ¾Œæ½¢æ½æ¾…æ½šæ¾–æ½¶æ½¬æ¾‚æ½•æ½²æ½’æ½æ½—æ¾”æ¾“æ½æ¼€æ½¡æ½«æ½½æ½§æ¾æ½“æ¾‹æ½©æ½¿æ¾•æ½£æ½·æ½ªæ½»ç†²ç†¯ç†›ç†°ç† ç†šç†©ç†µç†ç†¥ç†žç†¤ç†¡ç†ªç†œç†§ç†³çŠ˜çŠšç˜ç’çžçŸç çç›ç¡çšç™"],["e6a1","ç¢ç’‡ç’‰ç’Šç’†ç’ç‘½ç’…ç’ˆç‘¼ç‘¹ç”ˆç”‡ç•¾ç˜¥ç˜žç˜™ç˜ç˜œç˜£ç˜šç˜¨ç˜›çšœçšçšžçš›çžçžçž‰çžˆç£ç¢»ç£ç£Œç£‘ç£Žç£”ç£ˆç£ƒç£„ç£‰ç¦šç¦¡ç¦ ç¦œç¦¢ç¦›æ­¶ç¨¹çª²çª´çª³ç®·ç¯‹ç®¾ç®¬ç¯Žç®¯ç®¹ç¯Šç®µç³…ç³ˆç³Œç³‹ç··ç·›ç·ªç·§ç·—ç·¡ç¸ƒç·ºç·¦ç·¶ç·±ç·°ç·®ç·Ÿç½¶ç¾¬ç¾°ç¾­ç¿­ç¿«ç¿ªç¿¬ç¿¦ç¿¨è¤è§è†£è†Ÿ"],["e740","è†žè†•è†¢è†™è†—èˆ–è‰è‰“è‰’è‰è‰Žè‰‘è”¤è”»è”è”€è”©è”Žè”‰è”è”Ÿè”Šè”§è”œè“»è”«è“ºè”ˆè”Œè“´è”ªè“²è”•è“·è“«è“³è“¼è”’è“ªè“©è”–è“¾è”¨è”è”®è”‚è“½è”žè“¶è”±è”¦è“§è“¨è“°è“¯è“¹è”˜è” è”°è”‹è”™è”¯è™¢"],["e7a1","è–è£è¤è·èŸ¡è³è˜è”è›è’è¡èšè‘èžè­èªèèŽèŸèè¯è¬èºè®èœè¥èè»èµè¢è§è©è¡šè¤…è¤Œè¤”è¤‹è¤—è¤˜è¤™è¤†è¤–è¤‘è¤Žè¤‰è¦¢è¦¤è¦£è§­è§°è§¬è«è«†èª¸è«“è«‘è«”è«•èª»è«—èª¾è«€è«…è«˜è«ƒèªºèª½è«™è°¾è±è²è³¥è³Ÿè³™è³¨è³šè³è³§è¶ è¶œè¶¡è¶›è¸ è¸£è¸¥è¸¤è¸®è¸•è¸›è¸–è¸‘è¸™è¸¦è¸§"],["e840","è¸”è¸’è¸˜è¸“è¸œè¸—è¸šè¼¬è¼¤è¼˜è¼šè¼ è¼£è¼–è¼—é³é°é¯é§é«é„¯é„«é„©é„ªé„²é„¦é„®é†…é††é†Šé†é†‚é†„é†€é‹é‹ƒé‹„é‹€é‹™éŠ¶é‹é‹±é‹Ÿé‹˜é‹©é‹—é‹é‹Œé‹¯é‹‚é‹¨é‹Šé‹ˆé‹Žé‹¦é‹é‹•é‹‰é‹ é‹žé‹§é‹‘é‹“"],["e8a1","éŠµé‹¡é‹†éŠ´é•¼é–¬é–«é–®é–°éš¤éš¢é›“éœ…éœˆéœ‚éšéžŠéžŽéžˆéŸéŸé žé é ¦é ©é ¨é  é ›é §é¢²é¤ˆé£ºé¤‘é¤”é¤–é¤—é¤•é§œé§é§é§“é§”é§Žé§‰é§–é§˜é§‹é§—é§Œéª³é«¬é««é«³é«²é«±é­†é­ƒé­§é­´é­±é­¦é­¶é­µé­°é­¨é­¤é­¬é³¼é³ºé³½é³¿é³·é´‡é´€é³¹é³»é´ˆé´…é´„éºƒé»“é¼é¼å„œå„“å„—å„šå„‘å‡žåŒ´å¡å™°å™ å™®"],["e940","å™³å™¦å™£å™­å™²å™žå™·åœœåœ›å£ˆå¢½å£‰å¢¿å¢ºå£‚å¢¼å£†å¬—å¬™å¬›å¬¡å¬”å¬“å¬å¬–å¬¨å¬šå¬ å¬žå¯¯å¶¬å¶±å¶©å¶§å¶µå¶°å¶®å¶ªå¶¨å¶²å¶­å¶¯å¶´å¹§å¹¨å¹¦å¹¯å»©å»§å»¦å»¨å»¥å½‹å¾¼æ†æ†¨æ†–æ‡…æ†´æ‡†æ‡æ‡Œæ†º"],["e9a1","æ†¿æ†¸æ†Œæ“—æ“–æ“æ“æ“‰æ’½æ’‰æ“ƒæ“›æ“³æ“™æ”³æ•¿æ•¼æ–¢æ›ˆæš¾æ›€æ›Šæ›‹æ›æš½æš»æšºæ›Œæœ£æ¨´æ©¦æ©‰æ©§æ¨²æ©¨æ¨¾æ©æ©­æ©¶æ©›æ©‘æ¨¨æ©šæ¨»æ¨¿æ©æ©ªæ©¤æ©æ©æ©”æ©¯æ©©æ© æ¨¼æ©žæ©–æ©•æ©æ©Žæ©†æ­•æ­”æ­–æ®§æ®ªæ®«æ¯ˆæ¯‡æ°„æ°ƒæ°†æ¾­æ¿‹æ¾£æ¿‡æ¾¼æ¿Žæ¿ˆæ½žæ¿„æ¾½æ¾žæ¿Šæ¾¨ç€„æ¾¥æ¾®æ¾ºæ¾¬æ¾ªæ¿æ¾¿æ¾¸"],["ea40","æ¾¢æ¿‰æ¾«æ¿æ¾¯æ¾²æ¾°ç‡…ç‡‚ç†¿ç†¸ç‡–ç‡€ç‡ç‡‹ç‡”ç‡Šç‡‡ç‡ç†½ç‡˜ç†¼ç‡†ç‡šç‡›çŠçŠžç©ç¦ç§ç¬ç¥ç«çªç‘¿ç’šç’ ç’”ç’’ç’•ç’¡ç”‹ç–€ç˜¯ç˜­ç˜±ç˜½ç˜³ç˜¼ç˜µç˜²ç˜°çš»ç›¦çžšçžçž¡çžœçž›çž¢çž£çž•çž™"],["eaa1","çž—ç£ç£©ç£¥ç£ªç£žç££ç£›ç£¡ç£¢ç£­ç£Ÿç£ ç¦¤ç©„ç©ˆç©‡çª¶çª¸çªµçª±çª·ç¯žç¯£ç¯§ç¯ç¯•ç¯¥ç¯šç¯¨ç¯¹ç¯”ç¯ªç¯¢ç¯œç¯«ç¯˜ç¯Ÿç³’ç³”ç³—ç³ç³‘ç¸’ç¸¡ç¸—ç¸Œç¸Ÿç¸ ç¸“ç¸Žç¸œç¸•ç¸šç¸¢ç¸‹ç¸ç¸–ç¸ç¸”ç¸¥ç¸¤ç½ƒç½»ç½¼ç½ºç¾±ç¿¯è€ªè€©è¬è†±è†¦è†®è†¹è†µè†«è†°è†¬è†´è†²è†·è†§è‡²è‰•è‰–è‰—è•–è•…è•«è•è•“è•¡è•˜"],["eb40","è•€è•†è•¤è•è•¢è•„è•‘è•‡è•£è”¾è•›è•±è•Žè•®è•µè••è•§è• è–Œè•¦è•è•”è•¥è•¬è™£è™¥è™¤èž›èžèž—èž“èž’èžˆèžèž–èž˜è¹èž‡èž£èž…èžèž‘èžèž„èž”èžœèžšèž‰è¤žè¤¦è¤°è¤­è¤®è¤§è¤±è¤¢è¤©è¤£è¤¯è¤¬è¤Ÿè§±è« "],["eba1","è«¢è«²è«´è«µè«è¬”è«¤è«Ÿè«°è«ˆè«žè«¡è«¨è«¿è«¯è«»è²‘è²’è²è³µè³®è³±è³°è³³èµ¬èµ®è¶¥è¶§è¸³è¸¾è¸¸è¹€è¹…è¸¶è¸¼è¸½è¹è¸°è¸¿èº½è¼¶è¼®è¼µè¼²è¼¹è¼·è¼´é¶é¹é»é‚†éƒºé„³é„µé„¶é†“é†é†‘é†é†éŒ§éŒžéŒˆéŒŸéŒ†éŒéºéŒ¸éŒ¼éŒ›éŒ£éŒ’éŒé†éŒ­éŒŽéŒé‹‹éŒé‹ºéŒ¥éŒ“é‹¹é‹·éŒ´éŒ‚éŒ¤é‹¿éŒ©éŒ¹éŒµéŒªéŒ”éŒŒ"],["ec40","éŒ‹é‹¾éŒ‰éŒ€é‹»éŒ–é–¼é—é–¾é–¹é–ºé–¶é–¿é–µé–½éš©é›”éœ‹éœ’éœéž™éž—éž”éŸ°éŸ¸é µé ¯é ²é¤¤é¤Ÿé¤§é¤©é¦žé§®é§¬é§¥é§¤é§°é§£é§ªé§©é§§éª¹éª¿éª´éª»é«¶é«ºé«¹é«·é¬³é®€é®…é®‡é­¼é­¾é­»é®‚é®“é®’é®é­ºé®•"],["eca1","é­½é®ˆé´¥é´—é´ é´žé´”é´©é´é´˜é´¢é´é´™é´Ÿéºˆéº†éº‡éº®éº­é»•é»–é»ºé¼’é¼½å„¦å„¥å„¢å„¤å„ å„©å‹´åš“åšŒåšåš†åš„åšƒå™¾åš‚å™¿åšå£–å£”å£å£’å¬­å¬¥å¬²å¬£å¬¬å¬§å¬¦å¬¯å¬®å­»å¯±å¯²å¶·å¹¬å¹ªå¾¾å¾»æ‡ƒæ†µæ†¼æ‡§æ‡ æ‡¥æ‡¤æ‡¨æ‡žæ“¯æ“©æ“£æ“«æ“¤æ“¨æ–æ–€æ–¶æ—šæ›’æªæª–æªæª¥æª‰æªŸæª›æª¡æªžæª‡æª“æªŽ"],["ed40","æª•æªƒæª¨æª¤æª‘æ©¿æª¦æªšæª…æªŒæª’æ­›æ®­æ°‰æ¿Œæ¾©æ¿´æ¿”æ¿£æ¿œæ¿­æ¿§æ¿¦æ¿žæ¿²æ¿æ¿¢æ¿¨ç‡¡ç‡±ç‡¨ç‡²ç‡¤ç‡°ç‡¢ç³ç®ç¯ç’—ç’²ç’«ç’ç’ªç’­ç’±ç’¥ç’¯ç”ç”‘ç”’ç”ç–„ç™ƒç™ˆç™‰ç™‡çš¤ç›©çžµçž«çž²çž·çž¶"],["eda1","çž´çž±çž¨çŸ°ç£³ç£½ç¤‚ç£»ç£¼ç£²ç¤…ç£¹ç£¾ç¤„ç¦«ç¦¨ç©œç©›ç©–ç©˜ç©”ç©šçª¾ç«€ç«ç°…ç°ç¯²ç°€ç¯¿ç¯»ç°Žç¯´ç°‹ç¯³ç°‚ç°‰ç°ƒç°ç¯¸ç¯½ç°†ç¯°ç¯±ç°ç°Šç³¨ç¸­ç¸¼ç¹‚ç¸³é¡ˆç¸¸ç¸ªç¹‰ç¹€ç¹‡ç¸©ç¹Œç¸°ç¸»ç¸¶ç¹„ç¸ºç½…ç½¿ç½¾ç½½ç¿´ç¿²è€¬è†»è‡„è‡Œè‡Šè‡…è‡‡è†¼è‡©è‰›è‰šè‰œè–ƒè–€è–è–§è–•è– è–‹è–£è•»è–¤è–šè–ž"],["ee40","è•·è•¼è–‰è–¡è•ºè•¸è•—è–Žè––è–†è–è–™è–è–è–¢è–‚è–ˆè–…è•¹è•¶è–˜è–è–Ÿè™¨èž¾èžªèž­èŸ…èž°èž¬èž¹èžµèž¼èž®èŸ‰èŸƒèŸ‚èŸŒèž·èž¯èŸ„èŸŠèž´èž¶èž¿èž¸èž½èŸžèž²è¤µè¤³è¤¼è¤¾è¥è¥’è¤·è¥‚è¦­è¦¯è¦®è§²è§³è¬ž"],["eea1","è¬˜è¬–è¬‘è¬…è¬‹è¬¢è¬è¬’è¬•è¬‡è¬è¬ˆè¬†è¬œè¬“è¬šè±è±°è±²è±±è±¯è²•è²”è³¹èµ¯è¹Žè¹è¹“è¹è¹Œè¹‡è½ƒè½€é‚…é¾é„¸é†šé†¢é†›é†™é†Ÿé†¡é†é† éŽ¡éŽƒéŽ¯é¤é–é‡é¼é˜éœé¶é‰éé‘é é­éŽéŒéªé¹é—é•é’éé±é·é»é¡éžé£é§éŽ€éŽé™é—‡é—€é—‰é—ƒé—…é–·éš®éš°éš¬éœ éœŸéœ˜éœéœ™éžšéž¡éžœ"],["ef40","éžžéžéŸ•éŸ”éŸ±é¡é¡„é¡Šé¡‰é¡…é¡ƒé¤¥é¤«é¤¬é¤ªé¤³é¤²é¤¯é¤­é¤±é¤°é¦˜é¦£é¦¡é¨‚é§ºé§´é§·é§¹é§¸é§¶é§»é§½é§¾é§¼é¨ƒéª¾é«¾é«½é¬é«¼é­ˆé®šé®¨é®žé®›é®¦é®¡é®¥é®¤é®†é®¢é® é®¯é´³éµéµ§é´¶é´®é´¯é´±é´¸é´°"],["efa1","éµ…éµ‚éµƒé´¾é´·éµ€é´½ç¿µé´­éºŠéº‰éºéº°é»ˆé»šé»»é»¿é¼¤é¼£é¼¢é½”é¾ å„±å„­å„®åš˜åšœåš—åššåšåš™å¥°å¬¼å±©å±ªå·€å¹­å¹®æ‡˜æ‡Ÿæ‡­æ‡®æ‡±æ‡ªæ‡°æ‡«æ‡–æ‡©æ“¿æ”„æ“½æ“¸æ”æ”ƒæ“¼æ–”æ—›æ›šæ››æ›˜æ«…æª¹æª½æ«¡æ«†æªºæª¶æª·æ«‡æª´æª­æ­žæ¯‰æ°‹ç€‡ç€Œç€ç€ç€…ç€”ç€Žæ¿¿ç€€æ¿»ç€¦æ¿¼æ¿·ç€Šçˆç‡¿ç‡¹çˆƒç‡½ç¶"],["f040","ç’¸ç“€ç’µç“ç’¾ç’¶ç’»ç“‚ç””ç”“ç™œç™¤ç™™ç™ç™“ç™—ç™šçš¦çš½ç›¬çŸ‚çžºç£¿ç¤Œç¤“ç¤”ç¤‰ç¤ç¤’ç¤‘ç¦­ç¦¬ç©Ÿç°œç°©ç°™ç° ç°Ÿç°­ç°ç°¦ç°¨ç°¢ç°¥ç°°ç¹œç¹ç¹–ç¹£ç¹˜ç¹¢ç¹Ÿç¹‘ç¹ ç¹—ç¹“ç¾µç¾³ç¿·ç¿¸èµè‡‘è‡’"],["f0a1","è‡è‰Ÿè‰žè–´è—†è—€è—ƒè—‚è–³è–µè–½è—‡è—„è–¿è—‹è—Žè—ˆè—…è–±è–¶è—’è˜¤è–¸è–·è–¾è™©èŸ§èŸ¦èŸ¢èŸ›èŸ«èŸªèŸ¥èŸŸèŸ³èŸ¤èŸ”èŸœèŸ“èŸ­èŸ˜èŸ£èž¤èŸ—èŸ™è èŸ´èŸ¨èŸè¥“è¥‹è¥è¥Œè¥†è¥è¥‘è¥‰è¬ªè¬§è¬£è¬³è¬°è¬µè­‡è¬¯è¬¼è¬¾è¬±è¬¥è¬·è¬¦è¬¶è¬®è¬¤è¬»è¬½è¬ºè±‚è±µè²™è²˜è²—è³¾è´„è´‚è´€è¹œè¹¢è¹ è¹—è¹–è¹žè¹¥è¹§"],["f140","è¹›è¹šè¹¡è¹è¹©è¹”è½†è½‡è½ˆè½‹é„¨é„ºé„»é„¾é†¨é†¥é†§é†¯é†ªéŽµéŽŒéŽ’éŽ·éŽ›éŽéŽ‰éŽ§éŽŽéŽªéŽžéŽ¦éŽ•éŽˆéŽ™éŽŸéŽéŽ±éŽ‘éŽ²éŽ¤éŽ¨éŽ´éŽ£éŽ¥é—’é—“é—‘éš³é›—é›šå·‚é›Ÿé›˜é›éœ£éœ¢éœ¥éž¬éž®éž¨éž«éž¤éžª"],["f1a1","éž¢éž¥éŸ—éŸ™éŸ–éŸ˜éŸºé¡é¡‘é¡’é¢¸é¥é¤¼é¤ºé¨é¨‹é¨‰é¨é¨„é¨‘é¨Šé¨…é¨‡é¨†é«€é«œé¬ˆé¬„é¬…é¬©é¬µé­Šé­Œé­‹é¯‡é¯†é¯ƒé®¿é¯é®µé®¸é¯“é®¶é¯„é®¹é®½éµœéµ“éµéµŠéµ›éµ‹éµ™éµ–éµŒéµ—éµ’éµ”éµŸéµ˜éµšéºŽéºŒé»Ÿé¼é¼€é¼–é¼¥é¼«é¼ªé¼©é¼¨é½Œé½•å„´å„µåŠ–å‹·åŽ´åš«åš­åš¦åš§åšªåš¬å£šå£å£›å¤’å¬½å¬¾å¬¿å·ƒå¹°"],["f240","å¾¿æ‡»æ”‡æ”æ”æ”‰æ”Œæ”Žæ–„æ—žæ—æ›žæ«§æ« æ«Œæ«‘æ«™æ«‹æ«Ÿæ«œæ«æ««æ«æ«æ«žæ­ æ®°æ°Œç€™ç€§ç€ ç€–ç€«ç€¡ç€¢ç€£ç€©ç€—ç€¤ç€œç€ªçˆŒçˆŠçˆ‡çˆ‚çˆ…çŠ¥çŠ¦çŠ¤çŠ£çŠ¡ç“‹ç“…ç’·ç“ƒç”–ç™ çŸ‰çŸŠçŸ„çŸ±ç¤ç¤›"],["f2a1","ç¤¡ç¤œç¤—ç¤žç¦°ç©§ç©¨ç°³ç°¼ç°¹ç°¬ç°»ç³¬ç³ªç¹¶ç¹µç¹¸ç¹°ç¹·ç¹¯ç¹ºç¹²ç¹´ç¹¨ç½‹ç½Šç¾ƒç¾†ç¾·ç¿½ç¿¾è¸è‡—è‡•è‰¤è‰¡è‰£è—«è—±è—­è—™è—¡è—¨è—šè——è—¬è—²è—¸è—˜è—Ÿè—£è—œè—‘è—°è—¦è—¯è—žè—¢è €èŸºè ƒèŸ¶èŸ·è ‰è Œè ‹è †èŸ¼è ˆèŸ¿è Šè ‚è¥¢è¥šè¥›è¥—è¥¡è¥œè¥˜è¥è¥™è¦ˆè¦·è¦¶è§¶è­è­ˆè­Šè­€è­“è­–è­”è­‹è­•"],["f340","è­‘è­‚è­’è­—è±ƒè±·è±¶è²šè´†è´‡è´‰è¶¬è¶ªè¶­è¶«è¹­è¹¸è¹³è¹ªè¹¯è¹»è»‚è½’è½‘è½è½è½“è¾´é…€é„¿é†°é†­éžé‡éé‚éšéé¹é¬éŒé™éŽ©é¦éŠé”é®é£é•é„éŽé€é’é§é•½é—šé—›é›¡éœ©éœ«éœ¬éœ¨éœ¦"],["f3a1","éž³éž·éž¶éŸéŸžéŸŸé¡œé¡™é¡é¡—é¢¿é¢½é¢»é¢¾é¥ˆé¥‡é¥ƒé¦¦é¦§é¨šé¨•é¨¥é¨é¨¤é¨›é¨¢é¨ é¨§é¨£é¨žé¨œé¨”é«‚é¬‹é¬Šé¬Žé¬Œé¬·é¯ªé¯«é¯ é¯žé¯¤é¯¦é¯¢é¯°é¯”é¯—é¯¬é¯œé¯™é¯¥é¯•é¯¡é¯šéµ·é¶é¶Šé¶„é¶ˆéµ±é¶€éµ¸é¶†é¶‹é¶Œéµ½éµ«éµ´éµµéµ°éµ©é¶…éµ³éµ»é¶‚éµ¯éµ¹éµ¿é¶‡éµ¨éº”éº‘é»€é»¼é¼­é½€é½é½é½–é½—é½˜åŒ·åš²"],["f440","åšµåš³å££å­…å·†å·‡å»®å»¯å¿€å¿æ‡¹æ”—æ”–æ”•æ”“æ—Ÿæ›¨æ›£æ›¤æ«³æ«°æ«ªæ«¨æ«¹æ«±æ«®æ«¯ç€¼ç€µç€¯ç€·ç€´ç€±ç‚ç€¸ç€¿ç€ºç€¹ç€ç€»ç€³ççˆ“çˆ”çŠ¨ç½ç¼ç’ºçš«çšªçš¾ç›­çŸŒçŸŽçŸçŸçŸ²ç¤¥ç¤£ç¤§ç¤¨ç¤¤ç¤©"],["f4a1","ç¦²ç©®ç©¬ç©­ç«·ç±‰ç±ˆç±Šç±‡ç±…ç³®ç¹»ç¹¾çºçº€ç¾ºç¿¿è¹è‡›è‡™èˆ‹è‰¨è‰©è˜¢è—¿è˜è—¾è˜›è˜€è—¶è˜„è˜‰è˜…è˜Œè—½è ™è è ‘è —è “è –è¥£è¥¦è¦¹è§·è­ è­ªè­è­¨è­£è­¥è­§è­­è¶®èº†èºˆèº„è½™è½–è½—è½•è½˜è½šé‚é…ƒé…é†·é†µé†²é†³é‹é“é»é éé”é¾é•éé¨é™ééµé€é·é‡éŽé–é’éºé‰é¸éŠé¿"],["f540","é¼éŒé¶é‘é†é—žé— é—Ÿéœ®éœ¯éž¹éž»éŸ½éŸ¾é¡ é¡¢é¡£é¡Ÿé£é£‚é¥é¥Žé¥™é¥Œé¥‹é¥“é¨²é¨´é¨±é¨¬é¨ªé¨¶é¨©é¨®é¨¸é¨­é«‡é«Šé«†é¬é¬’é¬‘é°‹é°ˆé¯·é°…é°’é¯¸é±€é°‡é°Žé°†é°—é°”é°‰é¶Ÿé¶™é¶¤é¶é¶’é¶˜é¶é¶›"],["f5a1","é¶ é¶”é¶œé¶ªé¶—é¶¡é¶šé¶¢é¶¨é¶žé¶£é¶¿é¶©é¶–é¶¦é¶§éº™éº›éºšé»¥é»¤é»§é»¦é¼°é¼®é½›é½ é½žé½é½™é¾‘å„ºå„¹åŠ˜åŠ—å›ƒåš½åš¾å­ˆå­‡å·‹å·å»±æ‡½æ”›æ¬‚æ«¼æ¬ƒæ«¸æ¬€çƒç„çŠçˆç‰ç…ç†çˆçˆšçˆ™ç¾ç”—ç™ªçŸç¤­ç¤±ç¤¯ç±”ç±“ç³²çºŠçº‡çºˆçº‹çº†çºç½ç¾»è€°è‡è˜˜è˜ªè˜¦è˜Ÿè˜£è˜œè˜™è˜§è˜®è˜¡è˜ è˜©è˜žè˜¥"],["f640","è ©è è ›è  è ¤è œè «è¡Šè¥­è¥©è¥®è¥«è§ºè­¹è­¸è­…è­ºè­»è´è´”è¶¯èºŽèºŒè½žè½›è½é…†é…„é……é†¹é¿é»é¶é©é½é¼é°é¹éªé·é¬é‘€é±é—¥é—¤é—£éœµéœºéž¿éŸ¡é¡¤é£‰é£†é£€é¥˜é¥–é¨¹é¨½é©†é©„é©‚é©é¨º"],["f6a1","é¨¿é«é¬•é¬—é¬˜é¬–é¬ºé­’é°«é°é°œé°¬é°£é°¨é°©é°¤é°¡é¶·é¶¶é¶¼é·é·‡é·Šé·é¶¾é·…é·ƒé¶»é¶µé·Žé¶¹é¶ºé¶¬é·ˆé¶±é¶­é·Œé¶³é·é¶²é¹ºéºœé»«é»®é»­é¼›é¼˜é¼šé¼±é½Žé½¥é½¤é¾’äº¹å›†å›…å›‹å¥±å­‹å­Œå·•å·‘å»²æ”¡æ” æ”¦æ”¢æ¬‹æ¬ˆæ¬‰æ°ç•ç–ç—ç’çˆžçˆŸçŠ©ç¿ç“˜ç“•ç“™ç“—ç™­çš­ç¤µç¦´ç©°ç©±ç±—ç±œç±™ç±›ç±š"],["f740","ç³´ç³±çº‘ç½ç¾‡è‡žè‰«è˜´è˜µè˜³è˜¬è˜²è˜¶è ¬è ¨è ¦è ªè ¥è¥±è¦¿è¦¾è§»è­¾è®„è®‚è®†è®…è­¿è´•èº•èº”èºšèº’èºèº–èº—è½ è½¢é…‡é‘Œé‘é‘Šé‘‹é‘é‘‡é‘…é‘ˆé‘‰é‘†éœ¿éŸ£é¡ªé¡©é£‹é¥”é¥›é©Žé©“é©”é©Œé©é©ˆé©Š"],["f7a1","é©‰é©’é©é«é¬™é¬«é¬»é­–é­•é±†é±ˆé°¿é±„é°¹é°³é±é°¼é°·é°´é°²é°½é°¶é·›é·’é·žé·šé·‹é·é·œé·‘é·Ÿé·©é·™é·˜é·–é·µé·•é·éº¶é»°é¼µé¼³é¼²é½‚é½«é¾•é¾¢å„½åŠ™å£¨å£§å¥²å­å·˜è ¯å½æˆæˆƒæˆ„æ”©æ”¥æ––æ›«æ¬‘æ¬’æ¬æ¯Šç›çšçˆ¢çŽ‚çŽçŽƒç™°çŸ”ç±§ç±¦çº•è‰¬è˜ºè™€è˜¹è˜¼è˜±è˜»è˜¾è °è ²è ®è ³è¥¶è¥´è¥³è§¾"],["f840","è®Œè®Žè®‹è®ˆè±…è´™èº˜è½¤è½£é†¼é‘¢é‘•é‘é‘—é‘žéŸ„éŸ…é €é©–é©™é¬žé¬Ÿé¬ é±’é±˜é±é±Šé±é±‹é±•é±™é±Œé±Žé·»é··é·¯é·£é·«é·¸é·¤é·¶é·¡é·®é·¦é·²é·°é·¢é·¬é·´é·³é·¨é·­é»‚é»é»²é»³é¼†é¼œé¼¸é¼·é¼¶é½ƒé½"],["f8a1","é½±é½°é½®é½¯å›“å›å­Žå±­æ”­æ›­æ›®æ¬“çŸç¡çç çˆ£ç“›ç“¥çŸ•ç¤¸ç¦·ç¦¶ç±ªçº—ç¾‰è‰­è™ƒè ¸è ·è µè¡‹è®”è®•èºžèºŸèº èºé†¾é†½é‡‚é‘«é‘¨é‘©é›¥é†éƒé‡éŸ‡éŸ¥é©žé«•é­™é±£é±§é±¦é±¢é±žé± é¸‚é·¾é¸‡é¸ƒé¸†é¸…é¸€é¸é¸‰é·¿é·½é¸„éº é¼žé½†é½´é½µé½¶å›”æ”®æ–¸æ¬˜æ¬™æ¬—æ¬šç¢çˆ¦çŠªçŸ˜çŸ™ç¤¹ç±©ç±«ç³¶çºš"],["f940","çº˜çº›çº™è‡ è‡¡è™†è™‡è™ˆè¥¹è¥ºè¥¼è¥»è§¿è®˜è®™èº¥èº¤èº£é‘®é‘­é‘¯é‘±é‘³é‰é¡²é¥Ÿé±¨é±®é±­é¸‹é¸é¸é¸é¸’é¸‘éº¡é»µé¼‰é½‡é½¸é½»é½ºé½¹åœžç¦ç±¯è ¼è¶²èº¦é‡ƒé‘´é‘¸é‘¶é‘µé© é±´é±³é±±é±µé¸”é¸“é»¶é¼Š"],["f9a1","é¾¤ç¨ç¥ç³·è™ªè ¾è ½è ¿è®žè²œèº©è»‰é‹é¡³é¡´é£Œé¥¡é¦«é©¤é©¦é©§é¬¤é¸•é¸—é½ˆæˆ‡æ¬žçˆ§è™Œèº¨é’‚é’€é’é©©é©¨é¬®é¸™çˆ©è™‹è®Ÿé’ƒé±¹éº·ç™µé©«é±ºé¸ç©çªéº¤é½¾é½‰é¾˜ç¢éŠ¹è£å¢»æ’ç²§å«ºâ•”â•¦â•—â• â•¬â•£â•šâ•©â•â•’â•¤â••â•žâ•ªâ•¡â•˜â•§â•›â•“â•¥â•–â•Ÿâ•«â•¢â•™â•¨â•œâ•‘â•â•­â•®â•°â•¯â–“"]]');
const require$$7$1 = [
  [
    "8740",
    "ä°ä°²ä˜ƒä–¦ä•¸ð§‰§äµ·ä–³ð§²±ä³¢ð§³…ã®•äœ¶ä„ä±‡ä±€ð¤Š¿ð£˜—ð§’ð¦º‹ð§ƒ’ä±—ðª‘ää—šä²…ð§±¬ä´‡äª¤äš¡ð¦¬£çˆ¥ð¥©”ð¡©£ð£¸†ð£½¡æ™å›»"
  ],
  [
    "8767",
    "ç¶•å¤ð¨®¹ã·´éœ´ð§¯¯å¯›ð¡µžåª¤ã˜¥ð©º°å«‘å®·å³¼æ®è–“ð©¥…ç‘¡ç’ã¡µð¡µ“ð£šžð¦€¡ã»¬"
  ],
  [
    "87a1",
    "ð¥£žã«µç«¼é¾—ð¤…¡ð¨¤ð£‡ªð ªŠð£‰žäŒŠè’„é¾–é¯ä¤°è˜“å¢–éŠéˆ˜ç§ç¨²æ™ æ¨©è¢ç‘Œç¯…æž‚ç¨¬å‰é†ã“¦ç„ð¥¶¹ç“†é¿‡åž³ä¤¯å‘Œä„±ð£šŽå ˜ç©²ð§­¥è®äš®ð¦ºˆä†ð¥¶™ç®®ð¢’¼é¿ˆð¢“ð¢“‰ð¢“Œé¿‰è”„ð£–»ä‚´é¿Šä“¡ðª·¿æ‹ç®é¿‹"
  ],
  [
    "8840",
    "ã‡€",
    4,
    "ð „Œã‡…ð ƒ‘ð ƒã‡†ã‡‡ð ƒ‹ð¡¿¨ã‡ˆð ƒŠã‡‰ã‡Šã‡‹ã‡Œð „Žã‡ã‡ŽÄ€ÃÇÃ€Ä’Ã‰ÄšÃˆÅŒÃ“Ç‘Ã’à¿¿ÃŠÌ„áº¾à¿¿ÃŠÌŒá»€ÃŠÄÃ¡ÇŽÃ É‘Ä“Ã©Ä›Ã¨Ä«Ã­ÇÃ¬ÅÃ³Ç’Ã²Å«ÃºÇ”Ã¹Ç–Ç˜Çš"
  ],
  [
    "88a1",
    "ÇœÃ¼à¿¿ÃªÌ„áº¿à¿¿ÃªÌŒá»ÃªÉ¡âšâ›"
  ],
  [
    "8940",
    "ðªŽ©ð¡……"
  ],
  [
    "8943",
    "æ”Š"
  ],
  [
    "8946",
    "ä¸½æ»éµŽé‡Ÿ"
  ],
  [
    "894c",
    "ð§œµæ’‘ä¼šä¼¨ä¾¨å…–å…´å†œå‡¤åŠ¡åŠ¨åŒ»åŽå‘å˜å›¢å£°å¤„å¤‡å¤²å¤´å­¦å®žå®Ÿå²šåº†æ€»æ–‰æŸ¾æ „æ¡¥æµŽç‚¼ç”µçº¤çº¬çººç»‡ç»ç»Ÿç¼†ç¼·è‰ºè‹è¯è§†è®¾è¯¢è½¦è½§è½®"
  ],
  [
    "89a1",
    "ç‘ç³¼ç·æ¥†ç«‰åˆ§"
  ],
  [
    "89ab",
    "é†Œç¢¸é…žè‚¼"
  ],
  [
    "89b0",
    "è´‹èƒ¶ð §§"
  ],
  [
    "89b5",
    "è‚Ÿé»‡ä³é·‰é¸Œä°¾ð©·¶ð§€Žé¸Šðª„³ã—"
  ],
  [
    "89c1",
    "æºšèˆ¾ç”™"
  ],
  [
    "89c5",
    "ä¤‘é©¬éªé¾™ç¦‡ð¨‘¬ð¡·Šð —ð¢«¦ä¸¤äºäº€äº‡äº¿ä»«ä¼·ã‘Œä¾½ã¹ˆå€ƒå‚ˆã‘½ã’“ã’¥å††å¤…å‡›å‡¼åˆ…äº‰å‰¹åŠåŒ§ã—‡åŽ©ã•‘åŽ°ã•“å‚å£ã•­ã•²ãšå’“å’£å’´å’¹å“å“¯å”˜å”£å”¨ã–˜å”¿ã–¥ã–¿å——ã—…"
  ],
  [
    "8a40",
    "ð§¶„å”¥"
  ],
  [
    "8a43",
    "ð ±‚ð ´•ð¥„«å–ð¢³†ã§¬ð è¹†ð¤¶¸ð©“¥ä“ð¨‚¾çºð¢°¸ã¨´äŸ•ð¨…ð¦§²ð¤·ªæ“ð µ¼ð ¾´ð ³•ð¡ƒ´æ’è¹¾ð º–ð °‹ð ½¤ð¢²©ð¨‰–ð¤““"
  ],
  [
    "8a64",
    "ð µ†ð©©ð¨ƒ©äŸ´ð¤º§ð¢³‚éª²ã©§ð©—´ã¿­ã”†ð¥‹‡ð©Ÿ”ð§£ˆð¢µ„éµ®é •"
  ],
  [
    "8a76",
    "ä™ð¦‚¥æ’´å“£ð¢µŒð¢¯Šð¡·ã§»ð¡¯"
  ],
  [
    "8aa1",
    "ð¦›šð¦œ–ð§¦ æ“ªð¥’ð ±ƒè¹¨ð¢†¡ð¨­Œð œ±"
  ],
  [
    "8aac",
    "ä ‹ð †©ã¿ºå¡³ð¢¶"
  ],
  [
    "8ab2",
    "ð¤—ˆð “¼ð¦‚—ð ½Œð ¶–å•¹ä‚»äŽº"
  ],
  [
    "8abb",
    "äª´ð¢©¦ð¡‚è†ªé£µð ¶œæ¹ã§¾ð¢µè·€åš¡æ‘¼ã¹ƒ"
  ],
  [
    "8ac9",
    "ðª˜ð ¸‰ð¢«ð¢³‰"
  ],
  [
    "8ace",
    "ð¡ƒˆð£§‚ã¦’ã¨†ð¨Š›ã•¸ð¥¹‰ð¢ƒ‡å™’ð ¼±ð¢²²ð©œ ã’¼æ°½ð¤¸»"
  ],
  [
    "8adf",
    "ð§•´ð¢º‹ð¢ˆˆðª™›ð¨³ð ¹ºð °´ð¦ œç¾“ð¡ƒð¢ ƒð¢¤¹ã—»ð¥‡£ð ºŒð ¾ð ºªã¾“ð ¼°ð µ‡ð¡…ð ¹Œ"
  ],
  [
    "8af6",
    "ð º«ð ®©ð µˆð¡ƒ€ð¡„½ã¿¹ð¢š–æ²ð ¾­"
  ],
  [
    "8b40",
    "ð£´ð§˜¹ð¢¯Žð µ¾ð µ¿ð¢±‘ð¢±•ã¨˜ð º˜ð¡ƒ‡ð ¼®ðª˜²ð¦­ð¨³’ð¨¶™ð¨³Šé–ªå“Œè‹„å–¹"
  ],
  [
    "8b55",
    "ð©»ƒé°¦éª¶ð§žð¢·®ç…€è…­èƒ¬å°œð¦•²è„´ãž—åŸð¨‚½é†¶ð »ºð ¸ð ¹·ð »»ã—ð¤·«ã˜‰ð ³–åš¯ð¢žµð¡ƒ‰ð ¸ð ¹¸ð¡¸ð¡…ˆð¨ˆ‡ð¡‘•ð ¹¹ð¤¹ð¢¶¤å©”ð¡€ð¡€žð¡ƒµð¡ƒ¶åžœð ¸‘"
  ],
  [
    "8ba1",
    "ð§š”ð¨‹ð ¾µð ¹»ð¥…¾ãœƒð ¾¶ð¡†€ð¥‹˜ðªŠ½ð¤§šð¡ ºð¤…·ð¨‰¼å¢™å‰¨ã˜šð¥œ½ç®²å­¨ä €ä¬¬é¼§ä§§é°Ÿé®ð¥­´ð£„½å—»ã—²åš‰ä¸¨å¤‚ð¡¯ð¯¡¸é‘ð ‚†ä¹›äº»ã”¾å°£å½‘å¿„ã£ºæ‰Œæ”µæ­ºæ°µæ°ºç¬çˆ«ä¸¬çŠ­ð¤£©ç½’ç¤»ç³¹ç½“ð¦‰ªã“"
  ],
  [
    "8bde",
    "ð¦‹è€‚è‚€ð¦˜’ð¦¥‘åè¡¤è§ð§¢²è® è´é’…é•¸é•¿é—¨ð¨¸éŸ¦é¡µé£Žé£žé¥£ð© é±¼é¸Ÿé»„æ­¯ï¤‡ä¸·ð ‚‡é˜æˆ·é’¢"
  ],
  [
    "8c40",
    "å€»æ·¾ð©±³é¾¦ã·‰è¢ð¤…Žç·å³µä¬ ð¥‡ã•™ð¥´°æ„¢ð¨¨²è¾§é‡¶ç†‘æœ™çŽºð£Šðª„‡ã²‹ð¡¦€ä¬ç£¤ç‚å†®ð¨œä€‰æ©£ðªŠºäˆ£è˜ð ©¯ç¨ªð©¥‡ð¨«ªé•çåŒ¤ð¢¾é´ç›™ð¨§£é¾§çŸäº£ä¿°å‚¼ä¸¯ä¼—é¾¨å´ç¶‹å¢’å£ð¡¶¶åº’åº™å¿‚ð¢œ’æ–‹"
  ],
  [
    "8ca1",
    "ð£¹æ¤™æ©ƒð£±£æ³¿"
  ],
  [
    "8ca7",
    "çˆ€ð¤”…çŽŒã»›ð¤¨“å¬•ç’¹è®ƒð¥²¤ð¥š•çª“ç¯¬ç³ƒç¹¬è‹¸è–—é¾©è¢é¾ªèº¹é¾«è¿è•Ÿé§ éˆ¡é¾¬ð¨¶¹ð¡¿ä±äŠ¢å¨š"
  ],
  [
    "8cc9",
    "é¡¨æ«ä‰¶åœ½"
  ],
  [
    "8cce",
    "è—–ð¤¥»èŠ¿ð§„ä²ð¦µ´åµ»ð¦¬•ð¦¾¾é¾­é¾®å®–é¾¯æ›§ç¹›æ¹—ç§Šã¶ˆä“ƒð£‰–ð¢ž–äŽšä”¶"
  ],
  [
    "8ce6",
    "å³•ð£¬šè«¹å±¸ã´’ð£•‘åµ¸é¾²ç…—ä•˜ð¤ƒ¬ð¡¸£ä±·ã¥¸ã‘Šð †¤ð¦±è«Œä¾´ð ˆ¹å¦¿è…¬é¡–ð©£ºå¼»"
  ],
  [
    "8d40",
    "ð ®Ÿ"
  ],
  [
    "8d42",
    "ð¢‡ð¨¥­ä„‚äš»ð©¹ã¼‡é¾³ðª†µäƒ¸ãŸ–ä›·ð¦±†ä…¼ð¨š²ð§¿ä•­ã£”ð¥’šä•¡ä”›ä¶‰ä±»äµ¶ä—ªã¿ˆð¤¬ã™¡ä“žä’½ä‡­å´¾åµˆåµ–ã·¼ã å¶¤å¶¹ã  ã ¸å¹‚åº½å¼¥å¾ƒã¤ˆã¤”ã¤¿ã¥æƒ—æ„½å³¥ã¦‰æ†·æ†¹æ‡ã¦¸æˆ¬æŠæ‹¥æŒ˜ã§¸åš±"
  ],
  [
    "8da1",
    "ã¨ƒæ¢æ»æ‡æ‘šã©‹æ“€å´•å˜¡é¾Ÿãª—æ–†ãª½æ—¿æ™“ã«²æš’ã¬¢æœ–ã­‚æž¤æ €ã­˜æ¡Šæ¢„ã­²ã­±ã­»æ¤‰æ¥ƒç‰œæ¥¤æ¦Ÿæ¦…ã®¼æ§–ã¯æ©¥æ©´æ©±æª‚ã¯¬æª™ã¯²æª«æªµæ«”æ«¶æ®æ¯æ¯ªæ±µæ²ªã³‹æ´‚æ´†æ´¦æ¶ã³¯æ¶¤æ¶±æ¸•æ¸˜æ¸©æº†ð¨§€æº»æ»¢æ»šé½¿æ»¨æ»©æ¼¤æ¼´ãµ†ð£½æ¾æ¾¾ãµªãµµç†·å²™ã¶Šç€¬ã¶‘çç”ç¯ç¿ç‚‰ð Œ¥äã—±ð »˜"
  ],
  [
    "8e40",
    "ð£»—åž¾ð¦»“ç„¾ð¥Ÿ ã™Žæ¦¢ð¨¯©å­´ç©‰ð¥£¡ð©“™ç©¥ç©½ð¥¦¬çª»çª°ç«‚ç«ƒç‡‘ð¦’ä‡Šç«šç«ç«ªä‡¯å’²ð¥°ç¬‹ç­•ç¬©ð¥ŒŽð¥³¾ç®¢ç­¯èŽœð¥®´ð¦±¿ç¯è¡ç®’ç®¸ð¥´ ã¶­ð¥±¥è’’ç¯ºç°†ç°µð¥³ç±„ç²ƒð¤¢‚ç²¦æ™½ð¤•¸ç³‰ç³‡ç³¦ç±´ç³³ç³µç³Ž"
  ],
  [
    "8ea1",
    "ç¹§ä”ð¦¹„çµð¦»–ç’ç¶‰ç¶«ç„µç¶³ç·’ð¤—ð¦€©ç·¤ã´“ç·µð¡Ÿ¹ç·¥ð¨­ç¸ð¦„¡ð¦…šç¹®çº’äŒ«é‘¬ç¸§ç½€ç½ç½‡ç¤¶ð¦‹é§¡ç¾—ð¦‘ç¾£ð¡™¡ð ¨ä•œð£¦ä”ƒð¨Œºç¿ºð¦’‰è€…è€ˆè€è€¨è€¯ðª‚‡ð¦³ƒè€»è€¼è¡ð¢œ”ä¦‰ð¦˜¦ð£·£ð¦›¨æœ¥è‚§ð¨©ˆè„‡è„šå¢°ð¢›¶æ±¿ð¦’˜ð¤¾¸æ“§ð¡’Šèˆ˜ð¡¡žæ©“ð¤©¥ð¤ª•ä‘ºèˆ©ð ¬ð¦©’ð£µ¾ä¿¹ð¡“½è“¢è¢ð¦¬Šð¤¦§ð£”°ð¡³ð£·¸èŠªæ¤›ð¯¦”ä‡›"
  ],
  [
    "8f40",
    "è•‹è‹èŒšð ¸–ð¡ž´ã›ð£…½ð£•šè‰»è‹¢èŒ˜ð£º‹ð¦¶£ð¦¬…ð¦®—ð£—Žã¶¿èŒå—¬èŽ…ä”‹ð¦¶¥èŽ¬èè“ã‘¾ð¦»”æ©—è•šã’–ð¦¹‚ð¢»¯è‘˜ð¥¯¤è‘±ã·“ä“¤æª§è‘Šð£²µç¥˜è’¨ð¦®–ð¦¹·ð¦¹ƒè“žèèŽ‘ä’ è’“è“¤ð¥²‘ä‰€ð¥³€ä•ƒè”´å«²ð¦º™ä”§è•³ä”–æž¿è˜–"
  ],
  [
    "8fa1",
    "ð¨˜¥ð¨˜»è—ð§‚ˆè˜‚ð¡–‚ð§ƒð¯¦²ä•ªè˜¨ã™ˆð¡¢¢å·ð§Žšè™¾è±ðªƒ¸èŸ®ð¢°§èž±èŸšè å™¡è™¬æ¡–ä˜è¡…è¡†ð§— ð£¶¹ð§—¤è¡žè¢œä™›è¢´è¢µæè£…ç·ð§œè¦‡è¦Šè¦¦è¦©è¦§è¦¼ð¨¨¥è§§ð§¤¤ð§ª½èªœçž“é‡¾èªð§©™ç«©ð§¬ºð£¾äœ“ð§¬¸ç…¼è¬Œè¬Ÿð¥°ð¥•¥è¬¿è­Œè­èª©ð¤©ºè®è®›èª¯ð¡›Ÿä˜•è¡è²›ð§µ”ð§¶ð¯§”ãœ¥ð§µ“è³–ð§¶˜ð§¶½è´’è´ƒð¡¤è³›çœè´‘ð¤³‰ã»èµ·"
  ],
  [
    "9040",
    "è¶©ð¨€‚ð¡€”ð¤¦Šã­¼ð¨†¼ð§„Œç«§èº­èº¶è»ƒé‹”è¼™è¼­ð¨¥ð¨’è¾¥éŒƒðªŠŸð ©è¾³ä¤ªð¨§žð¨”½ð£¶»å»¸ð£‰¢è¿¹ðª€”ð¨š¼ð¨”ð¢Œ¥ã¦€ð¦»—é€·ð¨”¼ð§ª¾é¡ð¨•¬ð¨˜‹é‚¨ð¨œ“éƒ„ð¨›¦é‚®éƒ½é…§ã«°é†©é‡„ç²¬ð¨¤³ð¡º‰éˆŽæ²Ÿé‰é‰¢ð¥–¹éŠ¹ð¨«†ð£²›ð¨¬Œð¥—›"
  ],
  [
    "90a1",
    "ð ´±éŒ¬é«ð¨«¡ð¨¯«ç‚å«ƒð¨«¢ð¨«¥ä¥¥é‰„ð¨¯¬ð¨°¹ð¨¯¿é³é‘›èº¼é–…é–¦é¦é– æ¿¶äŠ¹ð¢™ºð¨›˜ð¡‰¼ð£¸®ä§Ÿæ°œé™»éš–ä…¬éš£ð¦»•æ‡šéš¶ç£µð¨« éš½åŒä¦¡ð¦²¸ð ‰´ð¦ð©‚¯ð©ƒ¥ð¤«‘ð¡¤•ð£ŒŠéœ±è™‚éœ¶ä¨ä”½ä–…ð¤«©çµå­éœ›éœð©‡•é—å­Šð©‡«éŸé¥åƒð£‚·ð£‚¼éž‰éžŸéž±éž¾éŸ€éŸ’éŸ ð¥‘¬éŸ®çœð©³éŸ¿éŸµð©ð§¥ºä«‘é ´é ³é¡‹é¡¦ã¬Žð§…µãµ‘ð ˜°ð¤…œ"
  ],
  [
    "9140",
    "ð¥œ†é£Šé¢·é£ˆé£‡ä«¿ð¦´§ð¡›“å–°é£¡é£¦é£¬é¸é¤¹ð¤¨©ä­²ð©¡—ð©¤…é§µé¨Œé¨»é¨é©˜ð¥œ¥ã›„ð©‚±ð©¯•é« é«¢ð©¬…é«´ä°Žé¬”é¬­ð¨˜€å€´é¬´ð¦¦¨ã£ƒð£½é­é­€ð©´¾å©…ð¡¡£é®Žð¤‰‹é°‚é¯¿é°Œð©¹¨é·”ð©¾·ðª†’ðª†«ðªƒ¡ðª„£ðª‡Ÿéµ¾é¶ƒðª„´é¸Žæ¢ˆ"
  ],
  [
    "91a1",
    "é·„ð¢…›ðª†“ðªˆ ð¡¤»ðªˆ³é´¹ðª‚¹ðªŠ´éºéº•éºžéº¢ä´´éºªéº¯ð¤¤é»ã­ ã§¥ã´ä¼²ãž¾ð¨°«é¼‚é¼ˆä®–é¤ð¦¶¢é¼—é¼–é¼¹åšŸåšŠé½…é¦¸ð©‚‹éŸ²è‘¿é½¢é½©ç«œé¾Žçˆ–ä®¾ð¤¥µð¤¦»ç…·ð¤§¸ð¤ˆð¤©‘çŽžð¨¯šð¡£ºç¦Ÿð¨¥¾ð¨¸¶é©é³ð¨©„é‹¬éŽé‹ð¨¥¬ð¤’¹çˆ—ã»«ç²ç©ƒçƒð¤‘³ð¤¸ç…¾ð¡Ÿ¯ç‚£ð¡¢¾ð£–™ã»‡ð¡¢…ð¥¯ð¡Ÿ¸ãœ¢ð¡›»ð¡ ¹ã›¡ð¡´ð¡£‘ð¥½‹ãœ£ð¡›€å›ð¤¨¥ð¡¾ð¡Š¨"
  ],
  [
    "9240",
    "ð¡†ð¡’¶è”ƒð£š¦è”ƒè‘•ð¤¦”ð§…¥ð£¸±ð¥•œð£»»ð§’ä“´ð£›®ð©¦ð¦¼¦æŸ¹ãœ³ã°•ã·§å¡¬ð¡¤¢æ ä—ð£œ¿ð¤ƒ¡ð¤‚‹ð¤„ð¦°¡å“‹åšžð¦š±åš’ð ¿Ÿð ®¨ð ¸é†ð¨¬“éŽœä»¸å„«ã ™ð¤¶äº¼ð ‘¥ð ¿ä½‹ä¾Šð¥™‘å©¨ð †«ð ‹ã¦™ð ŒŠð ”ãµä¼©ð ‹€ð¨º³ð ‰µè«šð ˆŒäº˜"
  ],
  [
    "92a1",
    "åƒå„ä¾¢ä¼ƒð¤¨Žð£ºŠä½‚å€®å¬å‚ä¿Œä¿¥å˜åƒ¼å…™å…›å…å…žæ¹¶ð£–•ð£¸¹ð£º¿æµ²ð¡¢„ð£º‰å†¨å‡ƒð — ä“ð ’£ð ’’ð ’‘èµºð¨ªœð œŽå‰™åŠ¤ð ¡³å‹¡é®ä™ºç†Œð¤ŽŒð ° ð¤¦¬ð¡ƒ¤æ§‘ð ¸ç‘¹ã»žç’™ç”ç‘–çŽ˜ä®Žð¤ª¼ð¤‚åã–„çˆð¤ƒ‰å–´ð …å“ð ¯†åœé‰é›´é¦åŸåžå¿ã˜¾å£‹åª™ð¨©†ð¡›ºð¡¯ð¡œå¨¬å¦¸éŠå©¾å«å¨’ð¥¥†ð¡§³ð¡¡¡ð¤Š•ã›µæ´…ç‘ƒå¨¡ð¥ºƒ"
  ],
  [
    "9340",
    "åªð¨¯—ð “é ç’Œð¡Œƒç„…ä¥²éˆð¨§»éŽ½ãž å°žå²žå¹žå¹ˆð¡¦–ð¡¥¼ð£«®å»å­ð¡¤ƒð¡¤„ãœð¡¢ ã›ð¡›¾ã›“è„ªð¨©‡ð¡¶ºð£‘²ð¨¦¨å¼Œå¼Žð¡¤§ð¡ž«å©«ð¡œ»å­„è˜”ð§—½è¡ æ¾ð¢¡ ð¢˜«å¿›ãº¸ð¢–¯ð¢–¾ð©‚ˆð¦½³æ‡€ð €¾ð †ð¢˜›æ†™æ†˜æµð¢²›ð¢´‡ð¤›”ð©…"
  ],
  [
    "93a1",
    "æ‘±ð¤™¥ð¢­ªã¨©ð¢¬¢ð£‘ð©£ªð¢¹¸æŒ·ðª‘›æ’¶æŒ±æ‘ð¤§£ð¢µ§æŠ¤ð¢²¡æ»æ•«æ¥²ã¯´ð£‚Žð£Š­ð¤¦‰ð£Š«å”ð£‹ ð¡£™ð©¿æ›Žð£Š‰ð£†³ã« ä†ð¥–„ð¨¬¢ð¥–ð¡›¼ð¥•›ð¥¥ç£®ð£„ƒð¡ ªð£ˆ´ã‘¤ð£ˆð£†‚ð¤‹‰æšŽð¦´¤æ™«ä®“æ˜°ð§¡°ð¡·«æ™£ð£‹’ð£‹¡æ˜žð¥¡²ã£‘ð£ ºð£ž¼ã®™ð£ž¢ð£¾ç“ã®–æžð¤˜ªæ¢¶æ žã¯„æª¾ã¡£ð£Ÿ•ð¤’‡æ¨³æ©’æ«‰æ¬…ð¡¤’æ”‘æ¢˜æ©Œã¯—æ©ºæ­—ð£¿€ð£²šéŽ é‹²ð¨¯ªð¨«‹"
  ],
  [
    "9440",
    "éŠ‰ð¨€žð¨§œé‘§æ¶¥æ¼‹ð¤§¬æµ§ð£½¿ã¶æ¸„ð¤€¼å¨½æ¸Šå¡‡æ´¤ç¡‚ç„»ð¤Œšð¤‰¶çƒ±ç‰çŠ‡çŠ”ð¤žð¤œ¥å…¹ð¤ª¤ð —«ç‘ºð£»¸ð£™Ÿð¤©Šð¤¤—ð¥¿¡ã¼†ãº±ð¤«Ÿð¨°£ð£¼µæ‚§ã»³ç“Œç¼éŽ‡ç·ä’Ÿð¦·ªä•‘ç–ƒã½£ð¤³™ð¤´†ã½˜ç••ç™³ðª—†ã¬™ç‘¨ð¨«Œð¤¦«ð¤¦Žã«»"
  ],
  [
    "94a1",
    "ã·ð¤©Žã»¿ð¤§…ð¤£³é‡ºåœ²é‚ð¨«£ð¡¡¤åƒŸð¥ˆ¡ð¥‡§ç¸ð£ˆ²çœŽçœç»ð¤š—ð£žã©žð¤£°ç¸ç’›ãº¿ð¤ªºð¤«‡äƒˆð¤ª–ð¦†®éŒ‡ð¥–ç žç¢ç¢ˆç£’çç¥™ð§ð¥›£ä„Žç¦›è’–ç¦¥æ¨­ð£»ºç¨ºç§´ä…®ð¡›¦ä„²éˆµç§±ð µŒð¤¦Œð Š™ð£¶ºð¡®ã–—å•«ã•°ãšªð ‡”ð °ç«¢å©™ð¢›µð¥ª¯ð¥ªœå¨ð ‰›ç£°å¨ªð¥¯†ç«¾ä‡¹ç±ç±­äˆ‘ð¥®³ð¥º¼ð¥º¦ç³ð¤§¹ð¡ž°ç²Žç±¼ç²®æª²ç·œç¸‡ç·“ç½Žð¦‰¡"
  ],
  [
    "9540",
    "ð¦…œð§­ˆç¶—ð¥º‚ä‰ªð¦­µð ¤–æŸ–ð Žð£—åŸ„ð¦’ð¦¸ð¤¥¢ç¿ç¬§ð  ¬ð¥«©ð¥µƒç¬Œð¥¸Žé§¦è™…é©£æ¨œð£¿ã§¢ð¤§·ð¦–­é¨Ÿð¦– è’€ð§„§ð¦³‘ä“ªè„·ä‚èƒ†è„‰è…‚ð¦ž´é£ƒð¦©‚è‰¢è‰¥ð¦©‘è‘“ð¦¶§è˜ð§ˆ›åª†ä…¿ð¡¡€å¬«ð¡¢¡å«¤ð¡£˜èš ð¯¦¼ð£¶è ­ð§¢å¨‚"
  ],
  [
    "95a1",
    "è¡®ä½…è¢‡è¢¿è£¦è¥¥è¥ð¥šƒè¥”ð§ž…ð§ž„ð¨¯µð¨¯™ð¨®œð¨§¹ãº­è’£ä›µä›ãŸ²è¨½è¨œð©‘ˆå½éˆ«ð¤Š„æ—”ç„©çƒ„ð¡¡…éµ­è²Ÿè³©ð§·œå¦šçŸƒå§°ä®ã›”è¸ªèº§ð¤°‰è¼°è½Šä‹´æ±˜æ¾»ð¢Œ¡ä¢›æ½¹æº‹ð¡Ÿšé¯©ãšµð¤¤¯é‚»é‚—å•±ä¤†é†»é„ð¨©‹ä¢ð¨«¼é§ð¨°ð¨°»è“¥è¨«é–™é–§é–—é––ð¨´´ç‘…ã»‚ð¤£¿ð¤©‚ð¤ªã»§ð£ˆ¥éšð¨»§ð¨¹¦ð¨¹¥ã»Œð¤§­ð¤©¸ð£¿®ç’ç‘«ã»¼éð©‚°"
  ],
  [
    "9640",
    "æ¡‡ä¨ð©‚“ð¥ŸŸéé¨ð¨¦‰ð¨°¦ð¨¬¯ð¦Ž¾éŠºå¬‘è­©ä¤¼ç¹ð¤ˆ›éž›é±é¤¸ð ¼¦å·ð¨¯…ð¤ª²é Ÿð©“šé‹¶ð©——é‡¥ä“€ð¨­ð¤©§ð¨­¤é£œð¨©…ã¼€éˆªä¤¥è”é¤»é¥ð§¬†ã·½é¦›ä­¯é¦ªé©œð¨­¥ð¥£ˆæªé¨¡å«¾é¨¯ð©£±ä®ð©¥ˆé¦¼ä®½ä®—é½å¡²ð¡Œ‚å ¢ð¤¦¸"
  ],
  [
    "96a1",
    "ð¡“¨ç¡„ð¢œŸð£¶¸æ£…ãµ½é‘˜ã¤§æ…ð¢žð¢¥«æ„‡é±é±“é±»é°µé°é­¿é¯ð©¸­é®Ÿðª‡µðªƒ¾é´¡ä²®ð¤„„é¸˜ä²°é´Œðª†´ðªƒ­ðªƒ³ð©¤¯é¶¥è’½ð¦¸’ð¦¿Ÿð¦®‚è—¼ä”³ð¦¶¤ð¦º„ð¦·°è è—®ð¦¸€ð£Ÿ—ð¦¤ç§¢ð£–œð£™€ä¤­ð¤§žãµ¢é›éŠ¾éˆð Š¿ç¢¹é‰·é‘ä¿¤ã‘€é¤ð¥•ç ½ç¡”ç¢¶ç¡‹ð¡—ð£‡‰ð¤¥ãššä½²æ¿šæ¿™ç€žç€žå”ð¤†µåž»å£³åžŠé´–åŸ—ç„´ã’¯ð¤†¬ç‡«ð¦±€ð¤¾—å¬¨ð¡žµð¨©‰"
  ],
  [
    "9740",
    "æ„Œå«Žå¨‹äŠ¼ð¤’ˆãœ¬ä­»ð¨§¼éŽ»éŽ¸ð¡£–ð ¼è‘²ð¦³€ð¡“ð¤‹ºð¢°¦ð¤å¦”ð£¶·ð¦ç¶¨ð¦…›ð¦‚¤ð¤¦¹ð¤¦‹ð¨§ºé‹¥ç¢ã»©ç’´ð¨­£ð¡¢Ÿã»¡ð¤ª³æ«˜ç³ç»ã»–ð¤¨¾ð¤ª”ð¡Ÿ™ð¤©¦ð Ž§ð¡¤ð¤§¥ç‘ˆð¤¤–ç‚¥ð¤¥¶éŠ„ç¦éŸð “¾éŒ±ð¨«Žð¨¨–éŽ†ð¨¯§ð¥—•ä¤µð¨ª‚ç…«"
  ],
  [
    "97a1",
    "ð¤¥ƒð ³¿åš¤ð ˜šð ¯«ð ²¸å”‚ç§„ð¡Ÿºç·¾ð¡›‚ð¤©ð¡¡’ä”®éãœŠð¨«€ð¤¦­å¦°ð¡¢¿ð¡¢ƒð§’„åª¡ã›¢ð£µ›ãš°é‰Ÿå©¹ð¨ªð¡¡¢é´ã³ð ª´äª–ã¦Šåƒ´ãµ©ãµŒð¡Žœç…µä‹»ð¨ˆ˜æ¸ð©ƒ¤ä“«æµ—ð§¹ç§æ²¯ã³–ð£¿­ð£¸­æ¸‚æ¼Œãµ¯ð µç•‘ãš¼ã“ˆäš€ã»šä¡±å§„é‰®ä¤¾è½ð¨°œð¦¯€å ’åŸˆã›–ð¡‘’çƒ¾ð¤¢ð¤©±ð¢¿£ð¡Š°ð¢Ž½æ¢¹æ¥§ð¡Ž˜ð£“¥ð§¯´ð£›Ÿð¨ªƒð£Ÿ–ð£ºð¤²Ÿæ¨šð£š­ð¦²·è¾ä“Ÿä“Ž"
  ],
  [
    "9840",
    "ð¦´¦ð¦µ‘ð¦²‚ð¦¿žæ¼—ð§„‰èŒ½ð¡œºè­ð¦²€ð§“ð¡Ÿ›å¦‰åª‚ð¡ž³å©¡å©±ð¡¤…ð¤‡¼ãœ­å§¯ð¡œ¼ã›‡ç†ŽéŽæššð¤Š¥å©®å¨«ð¤Š“æ¨«ð£»¹ð§œ¶ð¤‘›ð¤‹Šç„ð¤‰™ð¨§¡ä¾°ð¦´¨å³‚ð¤“Žð§¹ð¤Ž½æ¨Œð¤‰–ð¡Œ„ç‚¦ç„³ð¤©ã¶¥æ³Ÿð¯ ¥ð¤©ç¹¥å§«å´¯ã·³å½œð¤©ð¡ŸŸç¶¤è¦"
  ],
  [
    "98a1",
    "å’…ð£«ºð£Œ€ð ˆ”å¾ð £•ð ˜™ã¿¥ð¡¾žðªŠ¶ç€ƒð©…›åµ°çŽç³“ð¨©™ð© ä¿ˆç¿§ç‹çŒð§«´çŒ¸çŒ¹ð¥›¶ççˆãº©ð§¬˜é¬ç‡µð¤£²ç¡è‡¶ã»ŠçœŒã»‘æ²¢å›½ç™çžçŸã»¢ã»°ã»´ã»ºç““ã¼Žã½“ç•‚ç•­ç•²ç–ã½¼ç—ˆç—œã¿€ç™ã¿—ç™´ã¿œç™ºð¤½œç†ˆå˜£è¦€å¡©ä€çƒä€¹æ¡ä…ã—›çž˜äªä¯å±žçž¾çŸ‹å£²ç ˜ç‚¹ç œä‚¨ç ¹ç¡‡ç¡‘ç¡¦è‘ˆð¥”µç¤³æ ƒç¤²ä„ƒ"
  ],
  [
    "9940",
    "ä„‰ç¦‘ç¦™è¾»ç¨†è¾¼ä…§çª‘ä†²çª¼è‰¹ä‡„ç«ç«›ä‡ä¸¡ç­¢ç­¬ç­»ç°’ç°›ä‰ ä‰ºç±»ç²œäŠŒç²¸äŠ”ç³­è¾“çƒ€ð ³ç·ç·”ç·ç·½ç¾®ç¾´çŠŸäŽ—è€ è€¥ç¬¹è€®è€±è”ã·Œåž´ç‚ è‚·èƒ©ä­è„ŒçŒªè„Žè„’ç• è„”äã¬¹è…–è…™è…š"
  ],
  [
    "99a1",
    "ä“å ºè…¼è†„ä¥è†“ä­è†¥åŸ¯è‡è‡¤è‰”ä’èŠ¦è‰¶è‹Šè‹˜è‹¿ä’°è—é™©æ¦Šè…çƒµè‘¤æƒ£è’ˆä”„è’¾è“¡è“¸è”è”¸è•’ä”»è•¯è•°è— ä•·è™²èš’èš²è›¯é™…èž‹ä˜†ä˜—è¢®è£¿è¤¤è¥‡è¦‘ð§¥§è¨©è¨¸èª”èª´è±‘è³”è³²è´œäž˜å¡Ÿè·ƒäŸ­ä»®è¸ºå—˜å”è¹±å—µèº°ä ·è»Žè»¢è»¤è»­è»²è¾·è¿è¿Šè¿Œé€³é§„ä¢­é£ éˆ“ä¤žéˆ¨é‰˜é‰«éŠ±éŠ®éŠ¿"
  ],
  [
    "9a40",
    "é‹£é‹«é‹³é‹´é‹½éƒéŽ„éŽ­ä¥…ä¥‘éº¿é—åŒéé­é¾ä¥ªé‘”é‘¹é”­é–¢ä¦§é—´é˜³ä§¥æž ä¨¤é€ä¨µéž²éŸ‚å™”ä«¤æƒ¨é¢¹ä¬™é£±å¡„é¤Žé¤™å†´é¤œé¤·é¥‚é¥é¥¢ä­°é§…ä®é¨¼é¬çªƒé­©é®é¯é¯±é¯´ä±­é° ã¯ð¡¯‚éµ‰é°º"
  ],
  [
    "9aa1",
    "é»¾å™é¶“é¶½é·€é·¼é“¶è¾¶é¹»éº¬éº±éº½é»†é“œé»¢é»±é»¸ç«ˆé½„ð ‚”ð Š·ð Ž æ¤šé“ƒå¦¬ð “—å¡€é“ãž¹ð —•ð ˜•ð ™¶ð¡šºå—ç…³ð «‚ð «ð ®¿å‘ªð¯ »ð ¯‹å’žð ¯»ð °»ð ±“ð ±¥ð ±¼æƒ§ð ²å™ºð ²µð ³ð ³­ð µ¯ð ¶²ð ·ˆæ¥•é°¯èž¥ð ¸„ð ¸Žð »—ð ¾ð ¼­ð ¹³å° ð ¾¼å¸‹ð¡œð¡ð¡¶æœžð¡»ð¡‚ˆð¡‚–ã™‡ð¡‚¿ð¡ƒ“ð¡„¯ð¡„»å¤è’­ð¡‹£ð¡µð¡Œ¶è®ð¡•·ð¡˜™ð¡Ÿƒð¡Ÿ‡ä¹¸ç‚»ð¡ ­ð¡¥ª"
  ],
  [
    "9b40",
    "ð¡¨­ð¡©…ð¡°ªð¡±°ð¡²¬ð¡»ˆæ‹ƒð¡»•ð¡¼•ç†˜æ¡•ð¢…æ§©ã›ˆð¢‰¼ð¢—ð¢ºð¢œªð¢¡±ð¢¥è‹½ð¢¥§ð¢¦“ð¢«•è¦¥ð¢«¨è¾ ð¢¬Žéž¸ð¢¬¿é¡‡éª½ð¢±Œ"
  ],
  [
    "9b62",
    "ð¢²ˆð¢²·ð¥¯¨ð¢´ˆð¢´’ð¢¶·ð¢¶•ð¢¹‚ð¢½´ð¢¿Œð£€³ð£¦ð£ŒŸð£žå¾±æ™ˆæš¿ð§©¹ð£•§ð£—³çˆð¤¦ºçŸ—ð£˜šð£œ–çº‡ð †å¢µæœŽ"
  ],
  [
    "9ba1",
    "æ¤˜ð£ª§ð§™—ð¥¿¢ð£¸‘ð£º¹ð§—¾ð¢‚šä£äª¸ð¤„™ð¨ªšð¤‹®ð¤Œð¤€»ð¤Œ´ð¤Ž–ð¤©…ð —Šå‡’ð ˜‘å¦Ÿð¡º¨ã®¾ð£³¿ð¤„ð¤“–åžˆð¤™´ã¦›ð¤œ¯ð¨—¨ð©§‰ã¢ð¢‡ƒè­žð¨­Žé§–ð¤ ’ð¤£»ð¤¨•çˆ‰ð¤«€ð ±¸å¥¥ð¤º¥ð¤¾†ð ¹è»šð¥€¬åŠåœ¿ç…±ð¥Š™ð¥™ð£½Šð¤ª§å–¼ð¥‘†ð¥‘®ð¦­’é‡”ã‘³ð¥”¿ð§˜²ð¥•žäœ˜ð¥•¢ð¥•¦ð¥Ÿ‡ð¤¤¿ð¥¡å¦ã“»ð£Œæƒžð¥¤ƒä¼ð¨¥ˆð¥ª®ð¥®‰ð¥°†ð¡¶åž¡ç…‘æ¾¶ð¦„‚ð§°’é–ð¦†²ð¤¾šè­¢ð¦‚ð¦‘Š"
  ],
  [
    "9c40",
    "åµ›ð¦¯·è¼¶ð¦’„ð¡¤œè«ªð¤§¶ð¦’ˆð£¿¯ð¦”’ä¯€ð¦–¿ð¦šµð¢œ›é‘¥ð¥Ÿ¡æ†•å¨§ð¯£ä¾»åš¹ð¤”¡ð¦›¼ä¹ªð¤¤´é™–æ¶ð¦²½ã˜˜è¥·ð¦ž™ð¦¡®ð¦‘ð¦¡žç‡Ÿð¦£‡ç­‚ð©ƒ€ð ¨‘ð¦¤¦é„„ð¦¤¹ç©…é·°ð¦§ºé¨¦ð¦¨­ã™Ÿð¦‘©ð €¡ç¦ƒð¦¨´ð¦­›å´¬ð£”™èð¦®ä›ð¦²¤ç”»è¡¥ð¦¶®å¢¶"
  ],
  [
    "9ca1",
    "ãœœð¢–ð§‹ð§‡ã±”ð§Š€ð§Š…éŠð¢…ºð§Š‹éŒ°ð§‹¦ð¤§æ°¹é’Ÿð§‘ð »¸è §è£µð¢¤¦ð¨‘³ð¡ž±æº¸ð¤¨ªð¡  ã¦¤ãš¹å°ç§£ä”¿æš¶ð©²­ð©¢¤è¥ƒð§ŸŒð§¡˜å›–äƒŸð¡˜Šã¦¡ð£œ¯ð¨ƒ¨ð¡…ç†­è¦ð§§ð©†¨å©§ä²·ð§‚¯ð¨¦«ð§§½ð§¨Šð§¬‹ð§µ¦ð¤…ºç­ƒç¥¾ð¨€‰æ¾µðª‹Ÿæ¨ƒð¨Œ˜åŽ¢ð¦¸‡éŽ¿æ ¶éð¨…¯ð¨€£ð¦¦µð¡­ð£ˆ¯ð¨ˆå¶…ð¨°°ð¨‚ƒåœ•é £ð¨¥‰å¶«ð¤¦ˆæ–¾æ§•å’ð¤ª¥ð£¾ã°‘æœ¶ð¨‚ð¨ƒ´ð¨„®ð¡¾¡ð¨…"
  ],
  [
    "9d40",
    "ð¨†‰ð¨†¯ð¨ˆšð¨Œ†ð¨Œ¯ð¨ŽŠã—Šð¨‘¨ð¨šªä£ºæ¦ð¨¥–ç ˆé‰•ð¨¦¸ä²ð¨§§äŸð¨§¨ð¨­†ð¨¯”å§¸ð¨°‰è¼‹ð¨¿…ð©ƒ¬ç­‘ð©„ð©„¼ã··ð©…žð¤«Šè¿çŠåš‹ð©“§ð©—©ð©–°ð©–¸ð©œ²ð©£‘ð©¥‰ð©¥ªð©§ƒð©¨¨ð©¬Žð©µšð©¶›çºŸð©»¸ð©¼£ä²¤é•‡ðªŠ“ç†¢ðª‹¿ä¶‘é€’ðª—‹ä¶œð ²œè¾¾å—"
  ],
  [
    "9da1",
    "è¾ºð¢’°è¾¹ð¤ª“ä”‰ç¹¿æ½–æª±ä»ªã“¤ð¨¬¬ð§¢ãœºèº€ð¡Ÿµð¨€¤ð¨­¬ð¨®™ð§¨¾ð¦š¯ã·«ð§™•ð£²·ð¥˜µð¥¥–äºšð¥ºð¦‰˜åš¿ð ¹­è¸Žå­­ð£ºˆð¤²žæžæ‹ð¡Ÿ¶ð¡¡»æ”°å˜­ð¥±Šåšð¥Œ‘ã·†ð©¶˜ä±½å˜¢å˜žç½‰ð¥»˜å¥µð£µ€è°ä¸œð ¿ªð µ‰ð£šºè„—éµžè´˜ç˜»é±…ç™Žçž¹é…å²è…ˆè‹·å˜¥è„²è˜è‚½å—ªç¥¢å™ƒå–ð ºã—Žå˜…å—±æ›±ð¨‹¢ã˜­ç”´å—°å–ºå’—å•²ð ±ð ²–å»ð¥…ˆð ¹¶ð¢±¢"
  ],
  [
    "9e40",
    "ð º¢éº«çµšå—žð¡µæŠé­å’”è³ç‡¶é…¶æ¼æŽ¹æ¾å•©ð¢­ƒé±²ð¢º³å†šã“Ÿð ¶§å†§å‘å”žå”“ç™¦è¸­ð¦¢Šç–±è‚¶è „èž†è£‡è†¶èœð¡ƒä“¬çŒ„ð¤œ†å®èŒ‹ð¦¢“å™»ð¢›´ð§´¯ð¤†£ð§µ³ð¦»ð§Š¶é…°ð¡‡™éˆˆð£³¼ðªš©ð º¬ð »¹ç‰¦ð¡²¢äŽð¤¿‚ð§¿¹ð ¿«äƒº"
  ],
  [
    "9ea1",
    "é±æ”Ÿð¢¶ ä£³ð¤Ÿ ð©µ¼ð ¿¬ð ¸Šæ¢ð§–£ð ¿­"
  ],
  [
    "9ead",
    "ð¦ˆð¡†‡ç†£çºŽéµä¸šä¸„ã•·å¬æ²²å§ãš¬ã§œå½ãš¥ð¤˜˜å¢šð¤­®èˆ­å‘‹åžªð¥ª•ð ¥¹"
  ],
  [
    "9ec5",
    "ã©’ð¢‘¥ç´ð©º¬ä´‰é¯­ð£³¾ð©¼°ä±›ð¤¾©ð©–žð©¿žè‘œð£¶¶ð§Š²ð¦ž³ð£œ æŒ®ç´¥ð£»·ð£¸¬ã¨ªé€ˆå‹Œã¹´ã™ºä—©ð ’Žç™€å«°ð º¶ç¡ºð§¼®å¢§ä‚¿å™¼é®‹åµ´ç™”ðª´éº…ä³¡ç—¹ãŸ»æ„™ð£ƒšð¤²"
  ],
  [
    "9ef5",
    "å™ð¡Š©åž§ð¤¥£ð©¸†åˆ´ð§‚®ã–­æ±Šéµ¼"
  ],
  [
    "9f40",
    "ç±–é¬¹åŸžð¡¬å±“æ““ð©“ð¦Œµð§…¤èš­ð ´¨ð¦´¢ð¤«¢ð µ±"
  ],
  [
    "9f4f",
    "å‡¾ð¡¼å¶Žéœƒð¡·‘éºéŒç¬Ÿé¬‚å³‘ç®£æ‰¨æŒµé«¿ç¯é¬ªç±¾é¬®ç±‚ç²†é°•ç¯¼é¬‰é¼—é°›ð¤¤¾é½šå•³å¯ƒä¿½éº˜ä¿²å‰ ã¸†å‹‘å§å–å¦·å¸’éŸˆé¶«è½œå‘©éž´é¥€éžºåŒ¬æ„°"
  ],
  [
    "9fa1",
    "æ¤¬åšé°Šé´‚ä°»é™æ¦€å‚¦ç•†ð¡­é§šå‰³"
  ],
  [
    "9fae",
    "é…™éšé…œ"
  ],
  [
    "9fb2",
    "é…‘ð¨º—æ¿ð¦´£æ«Šå˜‘é†Žç•ºæŠ…ð ¼çç±°ð¥°¡ð£³½"
  ],
  [
    "9fc1",
    "ð¤¤™ç›–é®ä¸ªð ³”èŽ¾è¡‚"
  ],
  [
    "9fc9",
    "å±Šæ§€åƒ­åºåˆŸå·µä»Žæ°±ð ‡²ä¼¹å’œå“šåŠšè¶‚ã—¾å¼Œã—³"
  ],
  [
    "9fdb",
    "æ­’é…¼é¾¥é®—é ®é¢´éªºéº¨éº„ç…ºç¬”"
  ],
  [
    "9fe7",
    "æ¯ºè ˜ç½¸"
  ],
  [
    "9feb",
    "å˜ ðª™Šè¹·é½“"
  ],
  [
    "9ff0",
    "è·”è¹é¸œè¸æŠ‚ð¨½è¸¨è¹µç«“ð¤©·ç¨¾ç£˜æ³ªè©§ç˜‡"
  ],
  [
    "a040",
    "ð¨©šé¼¦æ³ŽèŸ–ç—ƒðªŠ²ç¡“ð¯¡€è´Œç‹¢ç±è¬­çŒ‚ç“±è³«ð¤ª»è˜¯å¾ºè¢ ä’·"
  ],
  [
    "a055",
    "ð¡ »ð¦¸…"
  ],
  [
    "a058",
    "è©¾ð¢”›"
  ],
  [
    "a05b",
    "æƒ½ç™§é«—éµ„é®é®èŸµ"
  ],
  [
    "a063",
    "è è³·çŒ¬éœ¡é®°ã—–çŠ²ä°‡ç±‘é¥Šð¦…™æ…™ä°„éº–æ…½"
  ],
  [
    "a073",
    "åŸæ…¯æŠ¦æˆ¹æ‹Žã©œæ‡¢åŽªð£µæ¤æ ‚ã—’"
  ],
  [
    "a0a1",
    "åµ—ð¨¯‚è¿šð¨¸¹"
  ],
  [
    "a0a6",
    "åƒ™ð¡µ†ç¤†åŒ²é˜¸ð ¼»ä¥"
  ],
  [
    "a0ae",
    "çŸ¾"
  ],
  [
    "a0b0",
    "ç³‚ð¥¼šç³šç¨­è¦è£çµç”…ç“²è¦”èˆšæœŒè¢ð§’†è›ç“°è„ƒçœ¤è¦‰ð¦ŸŒç•“ð¦»‘èž©èŸŽè‡ˆèžŒè©‰è²­è­ƒçœ«ç“¸è“šã˜µæ¦²è¶¦"
  ],
  [
    "a0d4",
    "è¦©ç‘¨æ¶¹èŸð¤€‘ç“§ã·›ç…¶æ‚¤æ†œã³‘ç…¢æ·"
  ],
  [
    "a0e2",
    "ç½±ð¨¬­ç‰æƒ©ä­¾åˆ ã°˜ð£³‡ð¥»—ð§™–ð¥”±ð¡¥„ð¡‹¾ð©¤ƒð¦·œð§‚­å³ð¦†­ð¨¨ð£™·ð ƒ®ð¦¡†ð¤¼Žä•¢å¬Ÿð¦Œé½éº¦ð¦‰«"
  ],
  [
    "a3c0",
    "â€",
    31,
    "â¡"
  ],
  [
    "c6a1",
    "â‘ ",
    9,
    "â‘´",
    9,
    "â…°",
    9,
    "ä¸¶ä¸¿äº…äº å†‚å†–å†«å‹¹åŒ¸å©åŽ¶å¤Šå®€å·›â¼³å¹¿å»´å½å½¡æ”´æ— ç–’ç™¶è¾µéš¶Â¨Ë†ãƒ½ãƒ¾ã‚ã‚žã€ƒä»ã€…ã€†ã€‡ãƒ¼ï¼»ï¼½âœ½ã",
    23
  ],
  [
    "c740",
    "ã™",
    58,
    "ã‚¡ã‚¢ã‚£ã‚¤"
  ],
  [
    "c7a1",
    "ã‚¥",
    81,
    "Ð",
    5,
    "ÐÐ–",
    4
  ],
  [
    "c840",
    "Ð›",
    26,
    "Ñ‘Ð¶",
    25,
    "â‡§â†¸â†¹ã‡ð ƒŒä¹šð ‚Šåˆ‚ä’‘"
  ],
  [
    "c8a1",
    "é¾°å†ˆé¾±ð§˜‡"
  ],
  [
    "c8cd",
    "ï¿¢ï¿¤ï¼‡ï¼‚ãˆ±â„–â„¡ã‚›ã‚œâº€âº„âº†âº‡âºˆâºŠâºŒâºâº•âºœâºâº¥âº§âºªâº¬âº®âº¶âº¼âº¾â»†â»Šâ»Œâ»â»â»–â»—â»žâ»£"
  ],
  [
    "c8f5",
    "ÊƒÉÉ›É”ÉµÅ“Ã¸Å‹ÊŠÉª"
  ],
  [
    "f9fe",
    "ï¿­"
  ],
  [
    "fa40",
    "ð •‡é‹›ð —Ÿð£¿…è•ŒäŠµç¯å†µã™‰ð¤¥‚ð¨§¤é„ð¡§›è‹®ð£³ˆç ¼æ„æ‹Ÿð¤¤³ð¨¦ªð Š ð¦®³ð¡Œ…ä¾«ð¢“­å€ˆð¦´©ð§ª„ð£˜€ð¤ª±ð¢”“å€©ð ¾å¾¤ð Ž€ð ‡æ»›ð Ÿå½å„ã‘ºå„Žé¡¬ãƒè–ð¤¦¤ð ’‡å… ð£Ž´å…ªð ¯¿ð¢ƒ¼ð ‹¥ð¢”°ð –Žð£ˆ³ð¡¦ƒå®‚è½ð –³ð£²™å†²å†¸"
  ],
  [
    "faa1",
    "é´´å‡‰å‡å‡‘ã³œå‡“ð¤ª¦å†³å‡¢å‚å‡­èæ¤¾ð£œ­å½»åˆ‹åˆ¦åˆ¼åŠµå‰—åŠ”åŠ¹å‹…ç°•è•‚å‹ è˜ð¦¬“åŒ…ð¨«žå•‰æ»™ð£¾€ð ¥”ð£¿¬åŒ³å„ð ¯¢æ³‹ð¡œ¦æ ›ç•æŠãºªã£Œð¡›¨ç‡ä’¢å­å´ð¨š«å¾å¿ð¡––ð¡˜“çŸ¦åŽ“ð¨ª›åŽ åŽ«åŽ®çŽ§ð¥²ã½™çŽœåå…æ±‰ä¹‰åŸ¾å™ãª«ð ®å ð£¿«ð¢¶£å¶ð ±·å“ç¹å”«æ™—æµ›å‘­ð¦­“ð µ´å•å’å’¤äž¦ð¡œð »ã¶´ð µ"
  ],
  [
    "fb40",
    "ð¨¦¼ð¢š˜å•‡ä³­å¯ç—å–†å–©å˜…ð¡£—ð¤€ºä•’ð¤µæš³ð¡‚´å˜·æ›ð£ŠŠæš¤æš­å™å™ç£±å›±éž‡å¾åœ€å›¯å›­ð¨­¦ã˜£ð¡‰å†ð¤†¥æ±®ç‚‹å‚ãš±ð¦±¾åŸ¦ð¡–å ƒð¡‘”ð¤£å ¦ð¤¯µå¡œå¢ªã•¡å£ å£œð¡ˆ¼å£»å¯¿åƒðª…ð¤‰¸é“ã–¡å¤Ÿæ¢¦ã›ƒæ¹™"
  ],
  [
    "fba1",
    "ð¡˜¾å¨¤å•“ð¡š’è”…å§‰ð µŽð¦²ð¦´ªð¡Ÿœå§™ð¡Ÿ»ð¡ž²ð¦¶¦æµ±ð¡ ¨ð¡›•å§¹ð¦¹…åª«å©£ã›¦ð¤¦©å©·ãœˆåª–ç‘¥å«“ð¦¾¡ð¢•”ã¶…ð¡¤‘ãœ²ð¡š¸åºƒå‹å­¶æ–ˆå­¼ð§¨Žä€„ä¡ð ˆ„å¯•æ… ð¡¨´ð¥§Œð –¥å¯³å®ä´å°…ð¡­„å°“çŽå°”ð¡²¥ð¦¬¨å±‰ä£å²…å³©å³¯å¶‹ð¡·¹ð¡¸·å´å´˜åµ†ð¡º¤å²ºå·—è‹¼ã ­ð¤¤ð¢‰ð¢…³èŠ‡ã ¶ã¯‚å¸®æªŠå¹µå¹ºð¤’¼ð ³“åŽ¦äº·å»åŽ¨ð¡±å¸‰å»´ð¨’‚"
  ],
  [
    "fc40",
    "å»¹å»»ã¢ å»¼æ ¾é›å¼ð ‡ð¯¢”ã«žä¢®ð¡Œºå¼ºð¦¢ˆð¢å½˜ð¢‘±å½£éž½ð¦¹®å½²é€ð¨¨¶å¾§å¶¶ãµŸð¥‰ð¡½ªð§ƒ¸ð¢™¨é‡–ð Šžð¨¨©æ€±æš…ð¡¡·ã¥£ã·‡ã˜¹åžð¢ž´ç¥±ã¹€æ‚žæ‚¤æ‚³ð¤¦‚ð¤¦ð§©“ç’¤åƒ¡åª æ…¤è¤æ…‚ð¯¢¦ð¦»’æ†å‡´ð ™–æ†‡å®ªð£¾·"
  ],
  [
    "fca1",
    "ð¢¡Ÿæ‡“ð¨®ð©¥æ‡ã¤²ð¢¦€ð¢£æ€£æ…œæ”žæŽ‹ð „˜æ‹…ð¡°æ‹•ð¢¸æ¬ð¤§Ÿã¨—æ¸æ¸ð¡ŽŽð¡Ÿ¼æ’æ¾Šð¢¸¶é ”ð¤‚Œð¥œæ“¡æ“¥é‘»ã©¦æºã©—æ•æ¼–ð¤¨¨ð¤¨£æ–…æ•­æ•Ÿð£¾æ–µð¤¥€ä¬·æ—‘äƒ˜ð¡ ©æ— æ—£å¿Ÿð£€æ˜˜ð£‡·ð£‡¸æ™„ð£†¤ð£†¥æ™‹ð ¹µæ™§ð¥‡¦æ™³æ™´ð¡¸½ð£ˆ±ð¨—´ð£‡ˆð¥Œ“çŸ…ð¢£·é¦¤æœ‚ð¤Žœð¤¨¡ã¬«æ§ºð£Ÿ‚æžæ§æ¢ð¤‡ð©ƒ­æŸ—ä“©æ ¢æ¹éˆ¼æ ð£¦ð¦¶ æ¡"
  ],
  [
    "fd40",
    "ð£‘¯æ§¡æ¨‹ð¨«Ÿæ¥³æ£ƒð£—æ¤æ¤€ã´²ã¨ð£˜¼ã®€æž¬æ¥¡ð¨©Šä‹¼æ¤¶æ¦˜ã®¡ð ‰è£å‚æ§¹ð£™™ð¢„ªæ©…ð£œƒæªã¯³æž±æ«ˆð©†œã°æ¬ð ¤£æƒžæ¬µæ­´ð¢Ÿæºµð£«›ð Žµð¡¥˜ã€å¡ð£­šæ¯¡ð£»¼æ¯œæ°·ð¢’‹ð¤£±ð¦­‘æ±šèˆ¦æ±¹ð£¶¼ä“…ð£¶½ð¤†¤ð¤¤Œð¤¤€"
  ],
  [
    "fda1",
    "ð£³‰ã›¥ã³«ð ´²é®ƒð£‡¹ð¢’‘ç¾æ ·ð¦´¥ð¦¶¡ð¦·«æ¶–æµœæ¹¼æ¼„ð¤¥¿ð¤‚…ð¦¹²è”³ð¦½´å‡‡æ²œæ¸è®ð¨¬¡æ¸¯ð£¸¯ç‘“ð£¾‚ç§Œæ¹åª‘ð£‹æ¿¸ãœæ¾ð£¸°æ»ºð¡’—ð¤€½ä••é°æ½„æ½œãµŽæ½´ð©…°ã´»æ¾Ÿð¤…„æ¿“ð¤‚‘ð¤…•ð¤€¹ð£¿°ð£¾´ð¤„¿å‡Ÿð¤…–ð¤…—ð¤…€ð¦‡ç‹ç¾ç‚§ç‚çƒŒçƒ•çƒ–çƒŸä„„ã·¨ç†´ç†–ð¤‰·ç„«ç……åªˆç…Šç…®å²œð¤¥ç…é¢ð¤‹ç„¬ð¤‘šð¤¨§ð¤¨¢ç†ºð¨¯¨ç‚½çˆŽ"
  ],
  [
    "fe40",
    "é‘‚çˆ•å¤‘é‘ƒçˆ¤éð¥˜…çˆ®ç‰€ð¤¥´æ¢½ç‰•ç‰—ã¹•ð£„æ æ¼½çŠ‚çŒªçŒ«ð¤ £ð¨ «ä£­ð¨ „çŒ¨çŒ®ççŽªð °ºð¦¨®ç‰ç‘‰ð¤‡¢ð¡›§ð¤¨¤æ˜£ã›…ð¤¦·ð¤¦ð¤§»ç·ç•æ¤ƒð¤¨¦ç¹ð —ƒã»—ç‘œð¢¢­ç‘ ð¨º²ç‘‡ç¤ç‘¶èŽ¹ç‘¬ãœ°ç‘´é±æ¨¬ç’‚ä¥“ð¤ªŒ"
  ],
  [
    "fea1",
    "ð¤…Ÿð¤©¹ð¨®å­†ð¨°ƒð¡¢žç“ˆð¡¦ˆç”Žç“©ç”žð¨»™ð¡©‹å¯—ð¨º¬éŽ…ç•ç•Šç•§ç•®ð¤¾‚ã¼„ð¤´“ç–Žç‘ç–žç–´ç˜‚ç˜¬ç™‘ç™ç™¯ç™¶ð¦µçšè‡¯ãŸ¸ð¦¤‘ð¦¤Žçš¡çš¥çš·ç›Œð¦¾Ÿè‘¢ð¥‚ð¥…½ð¡¸œçœžçœ¦ç€æ’¯ð¥ˆ ç˜ð£Š¬çž¯ð¨¥¤ð¨¥¨ð¡›çŸ´ç ‰ð¡¶ð¤¨’æ£Šç¢¯ç£‡ç£“éš¥ç¤®ð¥— ç£—ç¤´ç¢±ð§˜Œè¾¸è¢„ð¨¬«ð¦‚ƒð¢˜œç¦†è¤€æ¤‚ç¦€ð¥¡—ç¦ð§¬¹ç¤¼ç¦©æ¸ªð§„¦ãº¨ç§†ð©„ç§”"
  ]
];
var dbcsData;
var hasRequiredDbcsData;
function requireDbcsData() {
  if (hasRequiredDbcsData) return dbcsData;
  hasRequiredDbcsData = 1;
  dbcsData = {
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII + Â¥ + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
    "shiftjis": {
      type: "_dbcs",
      table: function() {
        return require$$0$2;
      },
      encodeAdd: { "Â¥": 92, "â€¾": 126 },
      encodeSkipVals: [{ from: 60736, to: 63808 }]
    },
    "csshiftjis": "shiftjis",
    "mskanji": "shiftjis",
    "sjis": "shiftjis",
    "windows31j": "shiftjis",
    "ms31j": "shiftjis",
    "xsjis": "shiftjis",
    "windows932": "shiftjis",
    "ms932": "shiftjis",
    "932": "shiftjis",
    "cp932": "shiftjis",
    "eucjp": {
      type: "_dbcs",
      table: function() {
        return require$$1$1;
      },
      encodeAdd: { "Â¥": 92, "â€¾": 126 }
    },
    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    "gb2312": "cp936",
    "gb231280": "cp936",
    "gb23121980": "cp936",
    "csgb2312": "cp936",
    "csiso58gb231280": "cp936",
    "euccn": "cp936",
    // Microsoft's CP936 is a subset and approximation of GBK.
    "windows936": "cp936",
    "ms936": "cp936",
    "936": "cp936",
    "cp936": {
      type: "_dbcs",
      table: function() {
        return require$$2$1;
      }
    },
    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    "gbk": {
      type: "_dbcs",
      table: function() {
        return require$$2$1.concat(require$$3$2);
      }
    },
    "xgbk": "gbk",
    "isoir58": "gbk",
    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    "gb18030": {
      type: "_dbcs",
      table: function() {
        return require$$2$1.concat(require$$3$2);
      },
      gb18030: function() {
        return require$$4$1;
      },
      encodeSkipVals: [128],
      encodeAdd: { "â‚¬": 41699 }
    },
    "chinese": "gb18030",
    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    "windows949": "cp949",
    "ms949": "cp949",
    "949": "cp949",
    "cp949": {
      type: "_dbcs",
      table: function() {
        return require$$5$1;
      }
    },
    "cseuckr": "cp949",
    "csksc56011987": "cp949",
    "euckr": "cp949",
    "isoir149": "cp949",
    "korean": "cp949",
    "ksc56011987": "cp949",
    "ksc56011989": "cp949",
    "ksc5601": "cp949",
    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
    "windows950": "cp950",
    "ms950": "cp950",
    "950": "cp950",
    "cp950": {
      type: "_dbcs",
      table: function() {
        return require$$6$1;
      }
    },
    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    "big5": "big5hkscs",
    "big5hkscs": {
      type: "_dbcs",
      table: function() {
        return require$$6$1.concat(require$$7$1);
      },
      encodeSkipVals: [
        // Although Encoding Standard says we should avoid encoding to HKSCS area (See Step 1 of
        // https://encoding.spec.whatwg.org/#index-big5-pointer), we still do it to increase compatibility with ICU.
        // But if a single unicode point can be encoded both as HKSCS and regular Big5, we prefer the latter.
        36457,
        36463,
        36478,
        36523,
        36532,
        36557,
        36560,
        36695,
        36713,
        36718,
        36811,
        36862,
        36973,
        36986,
        37060,
        37084,
        37105,
        37311,
        37551,
        37552,
        37553,
        37554,
        37585,
        37959,
        38090,
        38361,
        38652,
        39285,
        39798,
        39800,
        39803,
        39878,
        39902,
        39916,
        39926,
        40002,
        40019,
        40034,
        40040,
        40043,
        40055,
        40124,
        40125,
        40144,
        40279,
        40282,
        40388,
        40431,
        40443,
        40617,
        40687,
        40701,
        40800,
        40907,
        41079,
        41180,
        41183,
        36812,
        37576,
        38468,
        38637,
        // Step 2 of https://encoding.spec.whatwg.org/#index-big5-pointer: Use last pointer for U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345
        41636,
        41637,
        41639,
        41638,
        41676,
        41678
      ]
    },
    "cnbig5": "big5hkscs",
    "csbig5": "big5hkscs",
    "xxbig5": "big5hkscs"
  };
  return dbcsData;
}
var hasRequiredEncodings;
function requireEncodings() {
  if (hasRequiredEncodings) return encodings;
  hasRequiredEncodings = 1;
  (function(exports$1) {
    var modules = [
      requireInternal(),
      requireUtf32(),
      requireUtf16(),
      requireUtf7(),
      requireSbcsCodec(),
      requireSbcsData(),
      requireSbcsDataGenerated(),
      requireDbcsCodec(),
      requireDbcsData()
    ];
    for (var i = 0; i < modules.length; i++) {
      var module = modules[i];
      for (var enc in module)
        if (Object.prototype.hasOwnProperty.call(module, enc))
          exports$1[enc] = module[enc];
    }
  })(encodings);
  return encodings;
}
var streams;
var hasRequiredStreams;
function requireStreams() {
  if (hasRequiredStreams) return streams;
  hasRequiredStreams = 1;
  var Buffer2 = requireSafer().Buffer;
  streams = function(stream_module) {
    var Transform = stream_module.Transform;
    function IconvLiteEncoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.decodeStrings = false;
      Transform.call(this, options);
    }
    IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
      constructor: { value: IconvLiteEncoderStream }
    });
    IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
      if (typeof chunk != "string")
        return done(new Error("Iconv encoding stream needs strings as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length) this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype.collect = function(cb) {
      var chunks = [];
      this.on("error", cb);
      this.on("data", function(chunk) {
        chunks.push(chunk);
      });
      this.on("end", function() {
        cb(null, Buffer2.concat(chunks));
      });
      return this;
    };
    function IconvLiteDecoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.encoding = this.encoding = "utf8";
      Transform.call(this, options);
    }
    IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
      constructor: { value: IconvLiteDecoderStream }
    });
    IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
      if (!Buffer2.isBuffer(chunk) && !(chunk instanceof Uint8Array))
        return done(new Error("Iconv decoding stream needs buffers as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length) this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype.collect = function(cb) {
      var res = "";
      this.on("error", cb);
      this.on("data", function(chunk) {
        res += chunk;
      });
      this.on("end", function() {
        cb(null, res);
      });
      return this;
    };
    return {
      IconvLiteEncoderStream,
      IconvLiteDecoderStream
    };
  };
  return streams;
}
var hasRequiredLib$5;
function requireLib$5() {
  if (hasRequiredLib$5) return lib$5.exports;
  hasRequiredLib$5 = 1;
  (function(module) {
    var Buffer2 = requireSafer().Buffer;
    var bomHandling2 = requireBomHandling(), iconv = module.exports;
    iconv.encodings = null;
    iconv.defaultCharUnicode = "ï¿½";
    iconv.defaultCharSingleByte = "?";
    iconv.encode = function encode(str, encoding, options) {
      str = "" + (str || "");
      var encoder2 = iconv.getEncoder(encoding, options);
      var res = encoder2.write(str);
      var trail = encoder2.end();
      return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
    };
    iconv.decode = function decode(buf, encoding, options) {
      if (typeof buf === "string") {
        if (!iconv.skipDecodeWarning) {
          console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
          iconv.skipDecodeWarning = true;
        }
        buf = Buffer2.from("" + (buf || ""), "binary");
      }
      var decoder2 = iconv.getDecoder(encoding, options);
      var res = decoder2.write(buf);
      var trail = decoder2.end();
      return trail ? res + trail : res;
    };
    iconv.encodingExists = function encodingExists(enc) {
      try {
        iconv.getCodec(enc);
        return true;
      } catch (e) {
        return false;
      }
    };
    iconv.toEncoding = iconv.encode;
    iconv.fromEncoding = iconv.decode;
    iconv._codecDataCache = {};
    iconv.getCodec = function getCodec(encoding) {
      if (!iconv.encodings)
        iconv.encodings = requireEncodings();
      var enc = iconv._canonicalizeEncoding(encoding);
      var codecOptions = {};
      while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
          return codec;
        var codecDef = iconv.encodings[enc];
        switch (typeof codecDef) {
          case "string":
            enc = codecDef;
            break;
          case "object":
            for (var key2 in codecDef)
              codecOptions[key2] = codecDef[key2];
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            enc = codecDef.type;
            break;
          case "function":
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            codec = new codecDef(codecOptions, iconv);
            iconv._codecDataCache[codecOptions.encodingName] = codec;
            return codec;
          default:
            throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
        }
      }
    };
    iconv._canonicalizeEncoding = function(encoding) {
      return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    };
    iconv.getEncoder = function getEncoder(encoding, options) {
      var codec = iconv.getCodec(encoding), encoder2 = new codec.encoder(options, codec);
      if (codec.bomAware && options && options.addBOM)
        encoder2 = new bomHandling2.PrependBOM(encoder2, options);
      return encoder2;
    };
    iconv.getDecoder = function getDecoder(encoding, options) {
      var codec = iconv.getCodec(encoding), decoder2 = new codec.decoder(options, codec);
      if (codec.bomAware && !(options && options.stripBOM === false))
        decoder2 = new bomHandling2.StripBOM(decoder2, options);
      return decoder2;
    };
    iconv.enableStreamingAPI = function enableStreamingAPI(stream_module2) {
      if (iconv.supportsStreams)
        return;
      var streams2 = requireStreams()(stream_module2);
      iconv.IconvLiteEncoderStream = streams2.IconvLiteEncoderStream;
      iconv.IconvLiteDecoderStream = streams2.IconvLiteDecoderStream;
      iconv.encodeStream = function encodeStream(encoding, options) {
        return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
      };
      iconv.decodeStream = function decodeStream(encoding, options) {
        return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
      };
      iconv.supportsStreams = true;
    };
    var stream_module;
    try {
      stream_module = require("stream");
    } catch (e) {
    }
    if (stream_module && stream_module.Transform) {
      iconv.enableStreamingAPI(stream_module);
    } else {
      iconv.encodeStream = iconv.decodeStream = function() {
        throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
      };
    }
  })(lib$5);
  return lib$5.exports;
}
var iota_1;
var hasRequiredIota;
function requireIota() {
  if (hasRequiredIota) return iota_1;
  hasRequiredIota = 1;
  function iota(n) {
    var result = new Array(n);
    for (var i = 0; i < n; ++i) {
      result[i] = i;
    }
    return result;
  }
  iota_1 = iota;
  return iota_1;
}
var isBuffer_1;
var hasRequiredIsBuffer;
function requireIsBuffer() {
  if (hasRequiredIsBuffer) return isBuffer_1;
  hasRequiredIsBuffer = 1;
  isBuffer_1 = function(obj) {
    return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
  };
  function isBuffer(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
  }
  function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
  }
  return isBuffer_1;
}
var ndarray;
var hasRequiredNdarray;
function requireNdarray() {
  if (hasRequiredNdarray) return ndarray;
  hasRequiredNdarray = 1;
  var iota = requireIota();
  var isBuffer = requireIsBuffer();
  var hasTypedArrays = typeof Float64Array !== "undefined";
  function compare1st(a, b) {
    return a[0] - b[0];
  }
  function order() {
    var stride = this.stride;
    var terms = new Array(stride.length);
    var i;
    for (i = 0; i < terms.length; ++i) {
      terms[i] = [Math.abs(stride[i]), i];
    }
    terms.sort(compare1st);
    var result = new Array(terms.length);
    for (i = 0; i < result.length; ++i) {
      result[i] = terms[i][1];
    }
    return result;
  }
  function compileConstructor(dtype, dimension) {
    var className = ["View", dimension, "d", dtype].join("");
    if (dimension < 0) {
      className = "View_Nil" + dtype;
    }
    var useGetters = dtype === "generic";
    if (dimension === -1) {
      var code = "function " + className + "(a){this.data=a;};	var proto=" + className + ".prototype;	proto.dtype='" + dtype + "';	proto.index=function(){return -1};	proto.size=0;	proto.dimension=-1;	proto.shape=proto.stride=proto.order=[];	proto.lo=proto.hi=proto.transpose=proto.step=	function(){return new " + className + "(this.data);};	proto.get=proto.set=function(){};	proto.pick=function(){return null};	return function construct_" + className + "(a){return new " + className + "(a);}";
      var procedure = new Function(code);
      return procedure();
    } else if (dimension === 0) {
      var code = "function " + className + "(a,d) {	this.data = a;	this.offset = d	};	var proto=" + className + ".prototype;	proto.dtype='" + dtype + "';	proto.index=function(){return this.offset};	proto.dimension=0;	proto.size=1;	proto.shape=	proto.stride=	proto.order=[];	proto.lo=	proto.hi=	proto.transpose=	proto.step=function " + className + "_copy() {	return new " + className + "(this.data,this.offset)	};	proto.pick=function " + className + "_pick(){	return TrivialArray(this.data);	};	proto.valueOf=proto.get=function " + className + "_get(){	return " + (useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]") + "};	proto.set=function " + className + "_set(v){	return " + (useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v") + "	};	return function construct_" + className + "(a,b,c,d){return new " + className + "(a,d)}";
      var procedure = new Function("TrivialArray", code);
      return procedure(CACHED_CONSTRUCTORS[dtype][0]);
    }
    var code = ["'use strict'"];
    var indices = iota(dimension);
    var args = indices.map(function(i2) {
      return "i" + i2;
    });
    var index_str = "this.offset+" + indices.map(function(i2) {
      return "this.stride[" + i2 + "]*i" + i2;
    }).join("+");
    var shapeArg = indices.map(function(i2) {
      return "b" + i2;
    }).join(",");
    var strideArg = indices.map(function(i2) {
      return "c" + i2;
    }).join(",");
    code.push(
      "function " + className + "(a," + shapeArg + "," + strideArg + ",d){this.data=a",
      "this.shape=[" + shapeArg + "]",
      "this.stride=[" + strideArg + "]",
      "this.offset=d|0}",
      "var proto=" + className + ".prototype",
      "proto.dtype='" + dtype + "'",
      "proto.dimension=" + dimension
    );
    code.push(
      "Object.defineProperty(proto,'size',{get:function " + className + "_size(){	return " + indices.map(function(i2) {
        return "this.shape[" + i2 + "]";
      }).join("*"),
      "}})"
    );
    if (dimension === 1) {
      code.push("proto.order=[0]");
    } else {
      code.push("Object.defineProperty(proto,'order',{get:");
      if (dimension < 4) {
        code.push("function " + className + "_order(){");
        if (dimension === 2) {
          code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})");
        } else if (dimension === 3) {
          code.push(
            "var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);	if(s0>s1){	if(s1>s2){	return [2,1,0];	}else if(s0>s2){	return [1,2,0];	}else{	return [1,0,2];	}	}else if(s0>s2){	return [2,0,1];	}else if(s2>s1){	return [0,1,2];	}else{	return [0,2,1];	}}})"
          );
        }
      } else {
        code.push("ORDER})");
      }
    }
    code.push(
      "proto.set=function " + className + "_set(" + args.join(",") + ",v){"
    );
    if (useGetters) {
      code.push("return this.data.set(" + index_str + ",v)}");
    } else {
      code.push("return this.data[" + index_str + "]=v}");
    }
    code.push("proto.get=function " + className + "_get(" + args.join(",") + "){");
    if (useGetters) {
      code.push("return this.data.get(" + index_str + ")}");
    } else {
      code.push("return this.data[" + index_str + "]}");
    }
    code.push(
      "proto.index=function " + className + "_index(",
      args.join(),
      "){return " + index_str + "}"
    );
    code.push("proto.hi=function " + className + "_hi(" + args.join(",") + "){return new " + className + "(this.data," + indices.map(function(i2) {
      return ["(typeof i", i2, "!=='number'||i", i2, "<0)?this.shape[", i2, "]:i", i2, "|0"].join("");
    }).join(",") + "," + indices.map(function(i2) {
      return "this.stride[" + i2 + "]";
    }).join(",") + ",this.offset)}");
    var a_vars = indices.map(function(i2) {
      return "a" + i2 + "=this.shape[" + i2 + "]";
    });
    var c_vars = indices.map(function(i2) {
      return "c" + i2 + "=this.stride[" + i2 + "]";
    });
    code.push("proto.lo=function " + className + "_lo(" + args.join(",") + "){var b=this.offset,d=0," + a_vars.join(",") + "," + c_vars.join(","));
    for (var i = 0; i < dimension; ++i) {
      code.push(
        "if(typeof i" + i + "==='number'&&i" + i + ">=0){	d=i" + i + "|0;	b+=c" + i + "*d;	a" + i + "-=d}"
      );
    }
    code.push("return new " + className + "(this.data," + indices.map(function(i2) {
      return "a" + i2;
    }).join(",") + "," + indices.map(function(i2) {
      return "c" + i2;
    }).join(",") + ",b)}");
    code.push("proto.step=function " + className + "_step(" + args.join(",") + "){var " + indices.map(function(i2) {
      return "a" + i2 + "=this.shape[" + i2 + "]";
    }).join(",") + "," + indices.map(function(i2) {
      return "b" + i2 + "=this.stride[" + i2 + "]";
    }).join(",") + ",c=this.offset,d=0,ceil=Math.ceil");
    for (var i = 0; i < dimension; ++i) {
      code.push(
        "if(typeof i" + i + "==='number'){	d=i" + i + "|0;	if(d<0){	c+=b" + i + "*(a" + i + "-1);	a" + i + "=ceil(-a" + i + "/d)	}else{	a" + i + "=ceil(a" + i + "/d)	}	b" + i + "*=d	}"
      );
    }
    code.push("return new " + className + "(this.data," + indices.map(function(i2) {
      return "a" + i2;
    }).join(",") + "," + indices.map(function(i2) {
      return "b" + i2;
    }).join(",") + ",c)}");
    var tShape = new Array(dimension);
    var tStride = new Array(dimension);
    for (var i = 0; i < dimension; ++i) {
      tShape[i] = "a[i" + i + "]";
      tStride[i] = "b[i" + i + "]";
    }
    code.push(
      "proto.transpose=function " + className + "_transpose(" + args + "){" + args.map(function(n, idx) {
        return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)";
      }).join(";"),
      "var a=this.shape,b=this.stride;return new " + className + "(this.data," + tShape.join(",") + "," + tStride.join(",") + ",this.offset)}"
    );
    code.push("proto.pick=function " + className + "_pick(" + args + "){var a=[],b=[],c=this.offset");
    for (var i = 0; i < dimension; ++i) {
      code.push("if(typeof i" + i + "==='number'&&i" + i + ">=0){c=(c+this.stride[" + i + "]*i" + i + ")|0}else{a.push(this.shape[" + i + "]);b.push(this.stride[" + i + "])}");
    }
    code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}");
    code.push("return function construct_" + className + "(data,shape,stride,offset){return new " + className + "(data," + indices.map(function(i2) {
      return "shape[" + i2 + "]";
    }).join(",") + "," + indices.map(function(i2) {
      return "stride[" + i2 + "]";
    }).join(",") + ",offset)}");
    var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"));
    return procedure(CACHED_CONSTRUCTORS[dtype], order);
  }
  function arrayDType(data2) {
    if (isBuffer(data2)) {
      return "buffer";
    }
    if (hasTypedArrays) {
      switch (Object.prototype.toString.call(data2)) {
        case "[object Float64Array]":
          return "float64";
        case "[object Float32Array]":
          return "float32";
        case "[object Int8Array]":
          return "int8";
        case "[object Int16Array]":
          return "int16";
        case "[object Int32Array]":
          return "int32";
        case "[object Uint8Array]":
          return "uint8";
        case "[object Uint16Array]":
          return "uint16";
        case "[object Uint32Array]":
          return "uint32";
        case "[object Uint8ClampedArray]":
          return "uint8_clamped";
        case "[object BigInt64Array]":
          return "bigint64";
        case "[object BigUint64Array]":
          return "biguint64";
      }
    }
    if (Array.isArray(data2)) {
      return "array";
    }
    return "generic";
  }
  var CACHED_CONSTRUCTORS = {
    "float32": [],
    "float64": [],
    "int8": [],
    "int16": [],
    "int32": [],
    "uint8": [],
    "uint16": [],
    "uint32": [],
    "array": [],
    "uint8_clamped": [],
    "bigint64": [],
    "biguint64": [],
    "buffer": [],
    "generic": []
  };
  function wrappedNDArrayCtor(data2, shape, stride, offset) {
    if (data2 === void 0) {
      var ctor = CACHED_CONSTRUCTORS.array[0];
      return ctor([]);
    } else if (typeof data2 === "number") {
      data2 = [data2];
    }
    if (shape === void 0) {
      shape = [data2.length];
    }
    var d = shape.length;
    if (stride === void 0) {
      stride = new Array(d);
      for (var i = d - 1, sz = 1; i >= 0; --i) {
        stride[i] = sz;
        sz *= shape[i];
      }
    }
    if (offset === void 0) {
      offset = 0;
      for (var i = 0; i < d; ++i) {
        if (stride[i] < 0) {
          offset -= (shape[i] - 1) * stride[i];
        }
      }
    }
    var dtype = arrayDType(data2);
    var ctor_list = CACHED_CONSTRUCTORS[dtype];
    while (ctor_list.length <= d + 1) {
      ctor_list.push(compileConstructor(dtype, ctor_list.length - 1));
    }
    var ctor = ctor_list[d + 1];
    return ctor(data2, shape, stride, offset);
  }
  ndarray = wrappedNDArrayCtor;
  return ndarray;
}
var png = {};
var parserAsync = { exports: {} };
var chunkstream = { exports: {} };
var hasRequiredChunkstream;
function requireChunkstream() {
  if (hasRequiredChunkstream) return chunkstream.exports;
  hasRequiredChunkstream = 1;
  var util2 = require$$0$5;
  var Stream = require$$1$2;
  var ChunkStream = chunkstream.exports = function() {
    Stream.call(this);
    this._buffers = [];
    this._buffered = 0;
    this._reads = [];
    this._paused = false;
    this._encoding = "utf8";
    this.writable = true;
  };
  util2.inherits(ChunkStream, Stream);
  ChunkStream.prototype.read = function(length, callback) {
    this._reads.push({
      length: Math.abs(length),
      // if length < 0 then at most this length
      allowLess: length < 0,
      func: callback
    });
    process.nextTick((function() {
      this._process();
      if (this._paused && this._reads.length > 0) {
        this._paused = false;
        this.emit("drain");
      }
    }).bind(this));
  };
  ChunkStream.prototype.write = function(data2, encoding) {
    if (!this.writable) {
      this.emit("error", new Error("Stream not writable"));
      return false;
    }
    var dataBuffer;
    if (Buffer.isBuffer(data2)) {
      dataBuffer = data2;
    } else {
      dataBuffer = new Buffer(data2, encoding || this._encoding);
    }
    this._buffers.push(dataBuffer);
    this._buffered += dataBuffer.length;
    this._process();
    if (this._reads && this._reads.length === 0) {
      this._paused = true;
    }
    return this.writable && !this._paused;
  };
  ChunkStream.prototype.end = function(data2, encoding) {
    if (data2) {
      this.write(data2, encoding);
    }
    this.writable = false;
    if (!this._buffers) {
      return;
    }
    if (this._buffers.length === 0) {
      this._end();
    } else {
      this._buffers.push(null);
      this._process();
    }
  };
  ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;
  ChunkStream.prototype._end = function() {
    if (this._reads.length > 0) {
      this.emit(
        "error",
        new Error("Unexpected end of input")
      );
    }
    this.destroy();
  };
  ChunkStream.prototype.destroy = function() {
    if (!this._buffers) {
      return;
    }
    this.writable = false;
    this._reads = null;
    this._buffers = null;
    this.emit("close");
  };
  ChunkStream.prototype._processReadAllowingLess = function(read) {
    this._reads.shift();
    var smallerBuf = this._buffers[0];
    if (smallerBuf.length > read.length) {
      this._buffered -= read.length;
      this._buffers[0] = smallerBuf.slice(read.length);
      read.func.call(this, smallerBuf.slice(0, read.length));
    } else {
      this._buffered -= smallerBuf.length;
      this._buffers.shift();
      read.func.call(this, smallerBuf);
    }
  };
  ChunkStream.prototype._processRead = function(read) {
    this._reads.shift();
    var pos = 0;
    var count = 0;
    var data2 = new Buffer(read.length);
    while (pos < read.length) {
      var buf = this._buffers[count++];
      var len = Math.min(buf.length, read.length - pos);
      buf.copy(data2, pos, 0, len);
      pos += len;
      if (len !== buf.length) {
        this._buffers[--count] = buf.slice(len);
      }
    }
    if (count > 0) {
      this._buffers.splice(0, count);
    }
    this._buffered -= read.length;
    read.func.call(this, data2);
  };
  ChunkStream.prototype._process = function() {
    try {
      while (this._buffered > 0 && this._reads && this._reads.length > 0) {
        var read = this._reads[0];
        if (read.allowLess) {
          this._processReadAllowingLess(read);
        } else if (this._buffered >= read.length) {
          this._processRead(read);
        } else {
          break;
        }
      }
      if (this._buffers && !this.writable) {
        this._end();
      }
    } catch (ex) {
      this.emit("error", ex);
    }
  };
  return chunkstream.exports;
}
var filterParseAsync = { exports: {} };
var filterParse = { exports: {} };
var interlace = {};
var hasRequiredInterlace;
function requireInterlace() {
  if (hasRequiredInterlace) return interlace;
  hasRequiredInterlace = 1;
  var imagePasses = [
    {
      // pass 1 - 1px
      x: [0],
      y: [0]
    },
    {
      // pass 2 - 1px
      x: [4],
      y: [0]
    },
    {
      // pass 3 - 2px
      x: [0, 4],
      y: [4]
    },
    {
      // pass 4 - 4px
      x: [2, 6],
      y: [0, 4]
    },
    {
      // pass 5 - 8px
      x: [0, 2, 4, 6],
      y: [2, 6]
    },
    {
      // pass 6 - 16px
      x: [1, 3, 5, 7],
      y: [0, 2, 4, 6]
    },
    {
      // pass 7 - 32px
      x: [0, 1, 2, 3, 4, 5, 6, 7],
      y: [1, 3, 5, 7]
    }
  ];
  interlace.getImagePasses = function(width, height) {
    var images = [];
    var xLeftOver = width % 8;
    var yLeftOver = height % 8;
    var xRepeats = (width - xLeftOver) / 8;
    var yRepeats = (height - yLeftOver) / 8;
    for (var i = 0; i < imagePasses.length; i++) {
      var pass = imagePasses[i];
      var passWidth = xRepeats * pass.x.length;
      var passHeight = yRepeats * pass.y.length;
      for (var j = 0; j < pass.x.length; j++) {
        if (pass.x[j] < xLeftOver) {
          passWidth++;
        } else {
          break;
        }
      }
      for (j = 0; j < pass.y.length; j++) {
        if (pass.y[j] < yLeftOver) {
          passHeight++;
        } else {
          break;
        }
      }
      if (passWidth > 0 && passHeight > 0) {
        images.push({ width: passWidth, height: passHeight, index: i });
      }
    }
    return images;
  };
  interlace.getInterlaceIterator = function(width) {
    return function(x, y, pass) {
      var outerXLeftOver = x % imagePasses[pass].x.length;
      var outerX = (x - outerXLeftOver) / imagePasses[pass].x.length * 8 + imagePasses[pass].x[outerXLeftOver];
      var outerYLeftOver = y % imagePasses[pass].y.length;
      var outerY = (y - outerYLeftOver) / imagePasses[pass].y.length * 8 + imagePasses[pass].y[outerYLeftOver];
      return outerX * 4 + outerY * width * 4;
    };
  };
  return interlace;
}
var paethPredictor;
var hasRequiredPaethPredictor;
function requirePaethPredictor() {
  if (hasRequiredPaethPredictor) return paethPredictor;
  hasRequiredPaethPredictor = 1;
  paethPredictor = function paethPredictor2(left, above, upLeft) {
    var paeth = left + above - upLeft;
    var pLeft = Math.abs(paeth - left);
    var pAbove = Math.abs(paeth - above);
    var pUpLeft = Math.abs(paeth - upLeft);
    if (pLeft <= pAbove && pLeft <= pUpLeft) {
      return left;
    }
    if (pAbove <= pUpLeft) {
      return above;
    }
    return upLeft;
  };
  return paethPredictor;
}
var hasRequiredFilterParse;
function requireFilterParse() {
  if (hasRequiredFilterParse) return filterParse.exports;
  hasRequiredFilterParse = 1;
  var interlaceUtils = requireInterlace();
  var paethPredictor2 = requirePaethPredictor();
  function getByteWidth(width, bpp, depth) {
    var byteWidth = width * bpp;
    if (depth !== 8) {
      byteWidth = Math.ceil(byteWidth / (8 / depth));
    }
    return byteWidth;
  }
  var Filter = filterParse.exports = function(bitmapInfo, dependencies2) {
    var width = bitmapInfo.width;
    var height = bitmapInfo.height;
    var interlace2 = bitmapInfo.interlace;
    var bpp = bitmapInfo.bpp;
    var depth = bitmapInfo.depth;
    this.read = dependencies2.read;
    this.write = dependencies2.write;
    this.complete = dependencies2.complete;
    this._imageIndex = 0;
    this._images = [];
    if (interlace2) {
      var passes = interlaceUtils.getImagePasses(width, height);
      for (var i = 0; i < passes.length; i++) {
        this._images.push({
          byteWidth: getByteWidth(passes[i].width, bpp, depth),
          height: passes[i].height,
          lineIndex: 0
        });
      }
    } else {
      this._images.push({
        byteWidth: getByteWidth(width, bpp, depth),
        height,
        lineIndex: 0
      });
    }
    if (depth === 8) {
      this._xComparison = bpp;
    } else if (depth === 16) {
      this._xComparison = bpp * 2;
    } else {
      this._xComparison = 1;
    }
  };
  Filter.prototype.start = function() {
    this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
  };
  Filter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {
    var xComparison = this._xComparison;
    var xBiggerThan = xComparison - 1;
    for (var x = 0; x < byteWidth; x++) {
      var rawByte = rawData[1 + x];
      var f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
      unfilteredLine[x] = rawByte + f1Left;
    }
  };
  Filter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {
    var lastLine = this._lastLine;
    for (var x = 0; x < byteWidth; x++) {
      var rawByte = rawData[1 + x];
      var f2Up = lastLine ? lastLine[x] : 0;
      unfilteredLine[x] = rawByte + f2Up;
    }
  };
  Filter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {
    var xComparison = this._xComparison;
    var xBiggerThan = xComparison - 1;
    var lastLine = this._lastLine;
    for (var x = 0; x < byteWidth; x++) {
      var rawByte = rawData[1 + x];
      var f3Up = lastLine ? lastLine[x] : 0;
      var f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
      var f3Add = Math.floor((f3Left + f3Up) / 2);
      unfilteredLine[x] = rawByte + f3Add;
    }
  };
  Filter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {
    var xComparison = this._xComparison;
    var xBiggerThan = xComparison - 1;
    var lastLine = this._lastLine;
    for (var x = 0; x < byteWidth; x++) {
      var rawByte = rawData[1 + x];
      var f4Up = lastLine ? lastLine[x] : 0;
      var f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
      var f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;
      var f4Add = paethPredictor2(f4Left, f4Up, f4UpLeft);
      unfilteredLine[x] = rawByte + f4Add;
    }
  };
  Filter.prototype._reverseFilterLine = function(rawData) {
    var filter = rawData[0];
    var unfilteredLine;
    var currentImage = this._images[this._imageIndex];
    var byteWidth = currentImage.byteWidth;
    if (filter === 0) {
      unfilteredLine = rawData.slice(1, byteWidth + 1);
    } else {
      unfilteredLine = new Buffer(byteWidth);
      switch (filter) {
        case 1:
          this._unFilterType1(rawData, unfilteredLine, byteWidth);
          break;
        case 2:
          this._unFilterType2(rawData, unfilteredLine, byteWidth);
          break;
        case 3:
          this._unFilterType3(rawData, unfilteredLine, byteWidth);
          break;
        case 4:
          this._unFilterType4(rawData, unfilteredLine, byteWidth);
          break;
        default:
          throw new Error("Unrecognised filter type - " + filter);
      }
    }
    this.write(unfilteredLine);
    currentImage.lineIndex++;
    if (currentImage.lineIndex >= currentImage.height) {
      this._lastLine = null;
      this._imageIndex++;
      currentImage = this._images[this._imageIndex];
    } else {
      this._lastLine = unfilteredLine;
    }
    if (currentImage) {
      this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
    } else {
      this._lastLine = null;
      this.complete();
    }
  };
  return filterParse.exports;
}
var hasRequiredFilterParseAsync;
function requireFilterParseAsync() {
  if (hasRequiredFilterParseAsync) return filterParseAsync.exports;
  hasRequiredFilterParseAsync = 1;
  var util2 = require$$0$5;
  var ChunkStream = requireChunkstream();
  var Filter = requireFilterParse();
  var FilterAsync = filterParseAsync.exports = function(bitmapInfo) {
    ChunkStream.call(this);
    var buffers = [];
    var that = this;
    this._filter = new Filter(bitmapInfo, {
      read: this.read.bind(this),
      write: function(buffer) {
        buffers.push(buffer);
      },
      complete: function() {
        that.emit("complete", Buffer.concat(buffers));
      }
    });
    this._filter.start();
  };
  util2.inherits(FilterAsync, ChunkStream);
  return filterParseAsync.exports;
}
var parser$1 = { exports: {} };
var constants;
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  constants = {
    PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
    TYPE_IHDR: 1229472850,
    TYPE_IEND: 1229278788,
    TYPE_IDAT: 1229209940,
    TYPE_PLTE: 1347179589,
    TYPE_tRNS: 1951551059,
    // eslint-disable-line camelcase
    TYPE_gAMA: 1732332865,
    // eslint-disable-line camelcase
    // color-type bits
    COLORTYPE_GRAYSCALE: 0,
    COLORTYPE_PALETTE: 1,
    COLORTYPE_COLOR: 2,
    COLORTYPE_ALPHA: 4,
    // e.g. grayscale and alpha
    // color-type combinations
    COLORTYPE_PALETTE_COLOR: 3,
    COLORTYPE_COLOR_ALPHA: 6,
    COLORTYPE_TO_BPP_MAP: {
      0: 1,
      2: 3,
      3: 1,
      4: 2,
      6: 4
    },
    GAMMA_DIVISION: 1e5
  };
  return constants;
}
var crc = { exports: {} };
var hasRequiredCrc;
function requireCrc() {
  if (hasRequiredCrc) return crc.exports;
  hasRequiredCrc = 1;
  var crcTable = [];
  (function() {
    for (var i = 0; i < 256; i++) {
      var currentCrc = i;
      for (var j = 0; j < 8; j++) {
        if (currentCrc & 1) {
          currentCrc = 3988292384 ^ currentCrc >>> 1;
        } else {
          currentCrc = currentCrc >>> 1;
        }
      }
      crcTable[i] = currentCrc;
    }
  })();
  var CrcCalculator = crc.exports = function() {
    this._crc = -1;
  };
  CrcCalculator.prototype.write = function(data2) {
    for (var i = 0; i < data2.length; i++) {
      this._crc = crcTable[(this._crc ^ data2[i]) & 255] ^ this._crc >>> 8;
    }
    return true;
  };
  CrcCalculator.prototype.crc32 = function() {
    return this._crc ^ -1;
  };
  CrcCalculator.crc32 = function(buf) {
    var crc2 = -1;
    for (var i = 0; i < buf.length; i++) {
      crc2 = crcTable[(crc2 ^ buf[i]) & 255] ^ crc2 >>> 8;
    }
    return crc2 ^ -1;
  };
  return crc.exports;
}
var hasRequiredParser$1;
function requireParser$1() {
  if (hasRequiredParser$1) return parser$1.exports;
  hasRequiredParser$1 = 1;
  var constants2 = requireConstants();
  var CrcCalculator = requireCrc();
  var Parser = parser$1.exports = function(options, dependencies2) {
    this._options = options;
    options.checkCRC = options.checkCRC !== false;
    this._hasIHDR = false;
    this._hasIEND = false;
    this._emittedHeadersFinished = false;
    this._palette = [];
    this._colorType = 0;
    this._chunks = {};
    this._chunks[constants2.TYPE_IHDR] = this._handleIHDR.bind(this);
    this._chunks[constants2.TYPE_IEND] = this._handleIEND.bind(this);
    this._chunks[constants2.TYPE_IDAT] = this._handleIDAT.bind(this);
    this._chunks[constants2.TYPE_PLTE] = this._handlePLTE.bind(this);
    this._chunks[constants2.TYPE_tRNS] = this._handleTRNS.bind(this);
    this._chunks[constants2.TYPE_gAMA] = this._handleGAMA.bind(this);
    this.read = dependencies2.read;
    this.error = dependencies2.error;
    this.metadata = dependencies2.metadata;
    this.gamma = dependencies2.gamma;
    this.transColor = dependencies2.transColor;
    this.palette = dependencies2.palette;
    this.parsed = dependencies2.parsed;
    this.inflateData = dependencies2.inflateData;
    this.finished = dependencies2.finished;
    this.simpleTransparency = dependencies2.simpleTransparency;
    this.headersFinished = dependencies2.headersFinished || function() {
    };
  };
  Parser.prototype.start = function() {
    this.read(
      constants2.PNG_SIGNATURE.length,
      this._parseSignature.bind(this)
    );
  };
  Parser.prototype._parseSignature = function(data2) {
    var signature2 = constants2.PNG_SIGNATURE;
    for (var i = 0; i < signature2.length; i++) {
      if (data2[i] !== signature2[i]) {
        this.error(new Error("Invalid file signature"));
        return;
      }
    }
    this.read(8, this._parseChunkBegin.bind(this));
  };
  Parser.prototype._parseChunkBegin = function(data2) {
    var length = data2.readUInt32BE(0);
    var type2 = data2.readUInt32BE(4);
    var name = "";
    for (var i = 4; i < 8; i++) {
      name += String.fromCharCode(data2[i]);
    }
    var ancillary = Boolean(data2[4] & 32);
    if (!this._hasIHDR && type2 !== constants2.TYPE_IHDR) {
      this.error(new Error("Expected IHDR on beggining"));
      return;
    }
    this._crc = new CrcCalculator();
    this._crc.write(new Buffer(name));
    if (this._chunks[type2]) {
      return this._chunks[type2](length);
    }
    if (!ancillary) {
      this.error(new Error("Unsupported critical chunk type " + name));
      return;
    }
    this.read(length + 4, this._skipChunk.bind(this));
  };
  Parser.prototype._skipChunk = function() {
    this.read(8, this._parseChunkBegin.bind(this));
  };
  Parser.prototype._handleChunkEnd = function() {
    this.read(4, this._parseChunkEnd.bind(this));
  };
  Parser.prototype._parseChunkEnd = function(data2) {
    var fileCrc = data2.readInt32BE(0);
    var calcCrc = this._crc.crc32();
    if (this._options.checkCRC && calcCrc !== fileCrc) {
      this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc));
      return;
    }
    if (!this._hasIEND) {
      this.read(8, this._parseChunkBegin.bind(this));
    }
  };
  Parser.prototype._handleIHDR = function(length) {
    this.read(length, this._parseIHDR.bind(this));
  };
  Parser.prototype._parseIHDR = function(data2) {
    this._crc.write(data2);
    var width = data2.readUInt32BE(0);
    var height = data2.readUInt32BE(4);
    var depth = data2[8];
    var colorType = data2[9];
    var compr = data2[10];
    var filter = data2[11];
    var interlace2 = data2[12];
    if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
      this.error(new Error("Unsupported bit depth " + depth));
      return;
    }
    if (!(colorType in constants2.COLORTYPE_TO_BPP_MAP)) {
      this.error(new Error("Unsupported color type"));
      return;
    }
    if (compr !== 0) {
      this.error(new Error("Unsupported compression method"));
      return;
    }
    if (filter !== 0) {
      this.error(new Error("Unsupported filter method"));
      return;
    }
    if (interlace2 !== 0 && interlace2 !== 1) {
      this.error(new Error("Unsupported interlace method"));
      return;
    }
    this._colorType = colorType;
    var bpp = constants2.COLORTYPE_TO_BPP_MAP[this._colorType];
    this._hasIHDR = true;
    this.metadata({
      width,
      height,
      depth,
      interlace: Boolean(interlace2),
      palette: Boolean(colorType & constants2.COLORTYPE_PALETTE),
      color: Boolean(colorType & constants2.COLORTYPE_COLOR),
      alpha: Boolean(colorType & constants2.COLORTYPE_ALPHA),
      bpp,
      colorType
    });
    this._handleChunkEnd();
  };
  Parser.prototype._handlePLTE = function(length) {
    this.read(length, this._parsePLTE.bind(this));
  };
  Parser.prototype._parsePLTE = function(data2) {
    this._crc.write(data2);
    var entries = Math.floor(data2.length / 3);
    for (var i = 0; i < entries; i++) {
      this._palette.push([
        data2[i * 3],
        data2[i * 3 + 1],
        data2[i * 3 + 2],
        255
      ]);
    }
    this.palette(this._palette);
    this._handleChunkEnd();
  };
  Parser.prototype._handleTRNS = function(length) {
    this.simpleTransparency();
    this.read(length, this._parseTRNS.bind(this));
  };
  Parser.prototype._parseTRNS = function(data2) {
    this._crc.write(data2);
    if (this._colorType === constants2.COLORTYPE_PALETTE_COLOR) {
      if (this._palette.length === 0) {
        this.error(new Error("Transparency chunk must be after palette"));
        return;
      }
      if (data2.length > this._palette.length) {
        this.error(new Error("More transparent colors than palette size"));
        return;
      }
      for (var i = 0; i < data2.length; i++) {
        this._palette[i][3] = data2[i];
      }
      this.palette(this._palette);
    }
    if (this._colorType === constants2.COLORTYPE_GRAYSCALE) {
      this.transColor([data2.readUInt16BE(0)]);
    }
    if (this._colorType === constants2.COLORTYPE_COLOR) {
      this.transColor([data2.readUInt16BE(0), data2.readUInt16BE(2), data2.readUInt16BE(4)]);
    }
    this._handleChunkEnd();
  };
  Parser.prototype._handleGAMA = function(length) {
    this.read(length, this._parseGAMA.bind(this));
  };
  Parser.prototype._parseGAMA = function(data2) {
    this._crc.write(data2);
    this.gamma(data2.readUInt32BE(0) / constants2.GAMMA_DIVISION);
    this._handleChunkEnd();
  };
  Parser.prototype._handleIDAT = function(length) {
    if (!this._emittedHeadersFinished) {
      this._emittedHeadersFinished = true;
      this.headersFinished();
    }
    this.read(-length, this._parseIDAT.bind(this, length));
  };
  Parser.prototype._parseIDAT = function(length, data2) {
    this._crc.write(data2);
    if (this._colorType === constants2.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {
      throw new Error("Expected palette not found");
    }
    this.inflateData(data2);
    var leftOverLength = length - data2.length;
    if (leftOverLength > 0) {
      this._handleIDAT(leftOverLength);
    } else {
      this._handleChunkEnd();
    }
  };
  Parser.prototype._handleIEND = function(length) {
    this.read(length, this._parseIEND.bind(this));
  };
  Parser.prototype._parseIEND = function(data2) {
    this._crc.write(data2);
    this._hasIEND = true;
    this._handleChunkEnd();
    if (this.finished) {
      this.finished();
    }
  };
  return parser$1.exports;
}
var bitmapper = {};
var hasRequiredBitmapper;
function requireBitmapper() {
  if (hasRequiredBitmapper) return bitmapper;
  hasRequiredBitmapper = 1;
  var interlaceUtils = requireInterlace();
  var pixelBppMapper = [
    // 0 - dummy entry
    function() {
    },
    // 1 - L
    // 0: 0, 1: 0, 2: 0, 3: 0xff
    function(pxData, data2, pxPos, rawPos) {
      if (rawPos === data2.length) {
        throw new Error("Ran out of data");
      }
      var pixel = data2[rawPos];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = 255;
    },
    // 2 - LA
    // 0: 0, 1: 0, 2: 0, 3: 1
    function(pxData, data2, pxPos, rawPos) {
      if (rawPos + 1 >= data2.length) {
        throw new Error("Ran out of data");
      }
      var pixel = data2[rawPos];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = data2[rawPos + 1];
    },
    // 3 - RGB
    // 0: 0, 1: 1, 2: 2, 3: 0xff
    function(pxData, data2, pxPos, rawPos) {
      if (rawPos + 2 >= data2.length) {
        throw new Error("Ran out of data");
      }
      pxData[pxPos] = data2[rawPos];
      pxData[pxPos + 1] = data2[rawPos + 1];
      pxData[pxPos + 2] = data2[rawPos + 2];
      pxData[pxPos + 3] = 255;
    },
    // 4 - RGBA
    // 0: 0, 1: 1, 2: 2, 3: 3
    function(pxData, data2, pxPos, rawPos) {
      if (rawPos + 3 >= data2.length) {
        throw new Error("Ran out of data");
      }
      pxData[pxPos] = data2[rawPos];
      pxData[pxPos + 1] = data2[rawPos + 1];
      pxData[pxPos + 2] = data2[rawPos + 2];
      pxData[pxPos + 3] = data2[rawPos + 3];
    }
  ];
  var pixelBppCustomMapper = [
    // 0 - dummy entry
    function() {
    },
    // 1 - L
    // 0: 0, 1: 0, 2: 0, 3: 0xff
    function(pxData, pixelData, pxPos, maxBit) {
      var pixel = pixelData[0];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = maxBit;
    },
    // 2 - LA
    // 0: 0, 1: 0, 2: 0, 3: 1
    function(pxData, pixelData, pxPos) {
      var pixel = pixelData[0];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = pixelData[1];
    },
    // 3 - RGB
    // 0: 0, 1: 1, 2: 2, 3: 0xff
    function(pxData, pixelData, pxPos, maxBit) {
      pxData[pxPos] = pixelData[0];
      pxData[pxPos + 1] = pixelData[1];
      pxData[pxPos + 2] = pixelData[2];
      pxData[pxPos + 3] = maxBit;
    },
    // 4 - RGBA
    // 0: 0, 1: 1, 2: 2, 3: 3
    function(pxData, pixelData, pxPos) {
      pxData[pxPos] = pixelData[0];
      pxData[pxPos + 1] = pixelData[1];
      pxData[pxPos + 2] = pixelData[2];
      pxData[pxPos + 3] = pixelData[3];
    }
  ];
  function bitRetriever(data2, depth) {
    var leftOver = [];
    var i = 0;
    function split() {
      if (i === data2.length) {
        throw new Error("Ran out of data");
      }
      var byte = data2[i];
      i++;
      var byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
      switch (depth) {
        default:
          throw new Error("unrecognised depth");
        case 16:
          byte2 = data2[i];
          i++;
          leftOver.push((byte << 8) + byte2);
          break;
        case 4:
          byte2 = byte & 15;
          byte1 = byte >> 4;
          leftOver.push(byte1, byte2);
          break;
        case 2:
          byte4 = byte & 3;
          byte3 = byte >> 2 & 3;
          byte2 = byte >> 4 & 3;
          byte1 = byte >> 6 & 3;
          leftOver.push(byte1, byte2, byte3, byte4);
          break;
        case 1:
          byte8 = byte & 1;
          byte7 = byte >> 1 & 1;
          byte6 = byte >> 2 & 1;
          byte5 = byte >> 3 & 1;
          byte4 = byte >> 4 & 1;
          byte3 = byte >> 5 & 1;
          byte2 = byte >> 6 & 1;
          byte1 = byte >> 7 & 1;
          leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
          break;
      }
    }
    return {
      get: function(count) {
        while (leftOver.length < count) {
          split();
        }
        var returner = leftOver.slice(0, count);
        leftOver = leftOver.slice(count);
        return returner;
      },
      resetAfterLine: function() {
        leftOver.length = 0;
      },
      end: function() {
        if (i !== data2.length) {
          throw new Error("extra data found");
        }
      }
    };
  }
  function mapImage8Bit(image2, pxData, getPxPos, bpp, data2, rawPos) {
    var imageWidth = image2.width;
    var imageHeight = image2.height;
    var imagePass = image2.index;
    for (var y = 0; y < imageHeight; y++) {
      for (var x = 0; x < imageWidth; x++) {
        var pxPos = getPxPos(x, y, imagePass);
        pixelBppMapper[bpp](pxData, data2, pxPos, rawPos);
        rawPos += bpp;
      }
    }
    return rawPos;
  }
  function mapImageCustomBit(image2, pxData, getPxPos, bpp, bits, maxBit) {
    var imageWidth = image2.width;
    var imageHeight = image2.height;
    var imagePass = image2.index;
    for (var y = 0; y < imageHeight; y++) {
      for (var x = 0; x < imageWidth; x++) {
        var pixelData = bits.get(bpp);
        var pxPos = getPxPos(x, y, imagePass);
        pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);
      }
      bits.resetAfterLine();
    }
  }
  bitmapper.dataToBitMap = function(data2, bitmapInfo) {
    var width = bitmapInfo.width;
    var height = bitmapInfo.height;
    var depth = bitmapInfo.depth;
    var bpp = bitmapInfo.bpp;
    var interlace2 = bitmapInfo.interlace;
    if (depth !== 8) {
      var bits = bitRetriever(data2, depth);
    }
    var pxData;
    if (depth <= 8) {
      pxData = new Buffer(width * height * 4);
    } else {
      pxData = new Uint16Array(width * height * 4);
    }
    var maxBit = Math.pow(2, depth) - 1;
    var rawPos = 0;
    var images;
    var getPxPos;
    if (interlace2) {
      images = interlaceUtils.getImagePasses(width, height);
      getPxPos = interlaceUtils.getInterlaceIterator(width, height);
    } else {
      var nonInterlacedPxPos = 0;
      getPxPos = function() {
        var returner = nonInterlacedPxPos;
        nonInterlacedPxPos += 4;
        return returner;
      };
      images = [{ width, height }];
    }
    for (var imageIndex = 0; imageIndex < images.length; imageIndex++) {
      if (depth === 8) {
        rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data2, rawPos);
      } else {
        mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);
      }
    }
    if (depth === 8) {
      if (rawPos !== data2.length) {
        throw new Error("extra data found");
      }
    } else {
      bits.end();
    }
    return pxData;
  };
  return bitmapper;
}
var formatNormaliser;
var hasRequiredFormatNormaliser;
function requireFormatNormaliser() {
  if (hasRequiredFormatNormaliser) return formatNormaliser;
  hasRequiredFormatNormaliser = 1;
  function dePalette(indata, outdata, width, height, palette) {
    var pxPos = 0;
    for (var y = 0; y < height; y++) {
      for (var x = 0; x < width; x++) {
        var color = palette[indata[pxPos]];
        if (!color) {
          throw new Error("index " + indata[pxPos] + " not in palette");
        }
        for (var i = 0; i < 4; i++) {
          outdata[pxPos + i] = color[i];
        }
        pxPos += 4;
      }
    }
  }
  function replaceTransparentColor(indata, outdata, width, height, transColor) {
    var pxPos = 0;
    for (var y = 0; y < height; y++) {
      for (var x = 0; x < width; x++) {
        var makeTrans = false;
        if (transColor.length === 1) {
          if (transColor[0] === indata[pxPos]) {
            makeTrans = true;
          }
        } else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {
          makeTrans = true;
        }
        if (makeTrans) {
          for (var i = 0; i < 4; i++) {
            outdata[pxPos + i] = 0;
          }
        }
        pxPos += 4;
      }
    }
  }
  function scaleDepth(indata, outdata, width, height, depth) {
    var maxOutSample = 255;
    var maxInSample = Math.pow(2, depth) - 1;
    var pxPos = 0;
    for (var y = 0; y < height; y++) {
      for (var x = 0; x < width; x++) {
        for (var i = 0; i < 4; i++) {
          outdata[pxPos + i] = Math.floor(indata[pxPos + i] * maxOutSample / maxInSample + 0.5);
        }
        pxPos += 4;
      }
    }
  }
  formatNormaliser = function(indata, imageData) {
    var depth = imageData.depth;
    var width = imageData.width;
    var height = imageData.height;
    var colorType = imageData.colorType;
    var transColor = imageData.transColor;
    var palette = imageData.palette;
    var outdata = indata;
    if (colorType === 3) {
      dePalette(indata, outdata, width, height, palette);
    } else {
      if (transColor) {
        replaceTransparentColor(indata, outdata, width, height, transColor);
      }
      if (depth !== 8) {
        if (depth === 16) {
          outdata = new Buffer(width * height * 4);
        }
        scaleDepth(indata, outdata, width, height, depth);
      }
    }
    return outdata;
  };
  return formatNormaliser;
}
var hasRequiredParserAsync;
function requireParserAsync() {
  if (hasRequiredParserAsync) return parserAsync.exports;
  hasRequiredParserAsync = 1;
  var util2 = require$$0$5;
  var zlib = require$$0$3;
  var ChunkStream = requireChunkstream();
  var FilterAsync = requireFilterParseAsync();
  var Parser = requireParser$1();
  var bitmapper2 = requireBitmapper();
  var formatNormaliser2 = requireFormatNormaliser();
  var ParserAsync = parserAsync.exports = function(options) {
    ChunkStream.call(this);
    this._parser = new Parser(options, {
      read: this.read.bind(this),
      error: this._handleError.bind(this),
      metadata: this._handleMetaData.bind(this),
      gamma: this.emit.bind(this, "gamma"),
      palette: this._handlePalette.bind(this),
      transColor: this._handleTransColor.bind(this),
      finished: this._finished.bind(this),
      inflateData: this._inflateData.bind(this),
      simpleTransparency: this._simpleTransparency.bind(this),
      headersFinished: this._headersFinished.bind(this)
    });
    this._options = options;
    this.writable = true;
    this._parser.start();
  };
  util2.inherits(ParserAsync, ChunkStream);
  ParserAsync.prototype._handleError = function(err) {
    this.emit("error", err);
    this.writable = false;
    this.destroy();
    if (this._inflate && this._inflate.destroy) {
      this._inflate.destroy();
    }
    if (this._filter) {
      this._filter.destroy();
      this._filter.on("error", function() {
      });
    }
    this.errord = true;
  };
  ParserAsync.prototype._inflateData = function(data2) {
    if (!this._inflate) {
      if (this._bitmapInfo.interlace) {
        this._inflate = zlib.createInflate();
        this._inflate.on("error", this.emit.bind(this, "error"));
        this._filter.on("complete", this._complete.bind(this));
        this._inflate.pipe(this._filter);
      } else {
        var rowSize = (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1;
        var imageSize = rowSize * this._bitmapInfo.height;
        var chunkSize = Math.max(imageSize, zlib.Z_MIN_CHUNK);
        this._inflate = zlib.createInflate({ chunkSize });
        var leftToInflate = imageSize;
        var emitError = this.emit.bind(this, "error");
        this._inflate.on("error", function(err) {
          if (!leftToInflate) {
            return;
          }
          emitError(err);
        });
        this._filter.on("complete", this._complete.bind(this));
        var filterWrite = this._filter.write.bind(this._filter);
        this._inflate.on("data", function(chunk) {
          if (!leftToInflate) {
            return;
          }
          if (chunk.length > leftToInflate) {
            chunk = chunk.slice(0, leftToInflate);
          }
          leftToInflate -= chunk.length;
          filterWrite(chunk);
        });
        this._inflate.on("end", this._filter.end.bind(this._filter));
      }
    }
    this._inflate.write(data2);
  };
  ParserAsync.prototype._handleMetaData = function(metaData) {
    this._metaData = metaData;
    this._bitmapInfo = Object.create(metaData);
    this._filter = new FilterAsync(this._bitmapInfo);
  };
  ParserAsync.prototype._handleTransColor = function(transColor) {
    this._bitmapInfo.transColor = transColor;
  };
  ParserAsync.prototype._handlePalette = function(palette) {
    this._bitmapInfo.palette = palette;
  };
  ParserAsync.prototype._simpleTransparency = function() {
    this._metaData.alpha = true;
  };
  ParserAsync.prototype._headersFinished = function() {
    this.emit("metadata", this._metaData);
  };
  ParserAsync.prototype._finished = function() {
    if (this.errord) {
      return;
    }
    if (!this._inflate) {
      this.emit("error", "No Inflate block");
    } else {
      this._inflate.end();
    }
    this.destroySoon();
  };
  ParserAsync.prototype._complete = function(filteredData) {
    if (this.errord) {
      return;
    }
    try {
      var bitmapData = bitmapper2.dataToBitMap(filteredData, this._bitmapInfo);
      var normalisedBitmapData = formatNormaliser2(bitmapData, this._bitmapInfo);
      bitmapData = null;
    } catch (ex) {
      this._handleError(ex);
      return;
    }
    this.emit("parsed", normalisedBitmapData);
  };
  return parserAsync.exports;
}
var packerAsync = { exports: {} };
var packer = { exports: {} };
var bitpacker;
var hasRequiredBitpacker;
function requireBitpacker() {
  if (hasRequiredBitpacker) return bitpacker;
  hasRequiredBitpacker = 1;
  var constants2 = requireConstants();
  bitpacker = function(dataIn, width, height, options) {
    var outHasAlpha = [constants2.COLORTYPE_COLOR_ALPHA, constants2.COLORTYPE_ALPHA].indexOf(options.colorType) !== -1;
    if (options.colorType === options.inputColorType) {
      var bigEndian = (function() {
        var buffer = new ArrayBuffer(2);
        new DataView(buffer).setInt16(
          0,
          256,
          true
          /* littleEndian */
        );
        return new Int16Array(buffer)[0] !== 256;
      })();
      if (options.bitDepth === 8 || options.bitDepth === 16 && bigEndian) {
        return dataIn;
      }
    }
    var data2 = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);
    var maxValue = 255;
    var inBpp = constants2.COLORTYPE_TO_BPP_MAP[options.inputColorType];
    if (inBpp === 4 && !options.inputHasAlpha) {
      inBpp = 3;
    }
    var outBpp = constants2.COLORTYPE_TO_BPP_MAP[options.colorType];
    if (options.bitDepth === 16) {
      maxValue = 65535;
      outBpp *= 2;
    }
    var outData = new Buffer(width * height * outBpp);
    var inIndex = 0;
    var outIndex = 0;
    var bgColor = options.bgColor || {};
    if (bgColor.red === void 0) {
      bgColor.red = maxValue;
    }
    if (bgColor.green === void 0) {
      bgColor.green = maxValue;
    }
    if (bgColor.blue === void 0) {
      bgColor.blue = maxValue;
    }
    function getRGBA() {
      var red;
      var green;
      var blue;
      var alpha = maxValue;
      switch (options.inputColorType) {
        case constants2.COLORTYPE_COLOR_ALPHA:
          alpha = data2[inIndex + 3];
          red = data2[inIndex];
          green = data2[inIndex + 1];
          blue = data2[inIndex + 2];
          break;
        case constants2.COLORTYPE_COLOR:
          red = data2[inIndex];
          green = data2[inIndex + 1];
          blue = data2[inIndex + 2];
          break;
        case constants2.COLORTYPE_ALPHA:
          alpha = data2[inIndex + 1];
          red = data2[inIndex];
          green = red;
          blue = red;
          break;
        case constants2.COLORTYPE_GRAYSCALE:
          red = data2[inIndex];
          green = red;
          blue = red;
          break;
        default:
          throw new Error("input color type:" + options.inputColorType + " is not supported at present");
      }
      if (options.inputHasAlpha) {
        if (!outHasAlpha) {
          alpha /= maxValue;
          red = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0), maxValue);
          green = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0), maxValue);
          blue = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0), maxValue);
        }
      }
      return { red, green, blue, alpha };
    }
    for (var y = 0; y < height; y++) {
      for (var x = 0; x < width; x++) {
        var rgba = getRGBA();
        switch (options.colorType) {
          case constants2.COLORTYPE_COLOR_ALPHA:
          case constants2.COLORTYPE_COLOR:
            if (options.bitDepth === 8) {
              outData[outIndex] = rgba.red;
              outData[outIndex + 1] = rgba.green;
              outData[outIndex + 2] = rgba.blue;
              if (outHasAlpha) {
                outData[outIndex + 3] = rgba.alpha;
              }
            } else {
              outData.writeUInt16BE(rgba.red, outIndex);
              outData.writeUInt16BE(rgba.green, outIndex + 2);
              outData.writeUInt16BE(rgba.blue, outIndex + 4);
              if (outHasAlpha) {
                outData.writeUInt16BE(rgba.alpha, outIndex + 6);
              }
            }
            break;
          case constants2.COLORTYPE_ALPHA:
          case constants2.COLORTYPE_GRAYSCALE:
            var grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
            if (options.bitDepth === 8) {
              outData[outIndex] = grayscale;
              if (outHasAlpha) {
                outData[outIndex + 1] = rgba.alpha;
              }
            } else {
              outData.writeUInt16BE(grayscale, outIndex);
              if (outHasAlpha) {
                outData.writeUInt16BE(rgba.alpha, outIndex + 2);
              }
            }
            break;
          default:
            throw new Error("unrecognised color Type " + options.colorType);
        }
        inIndex += inBpp;
        outIndex += outBpp;
      }
    }
    return outData;
  };
  return bitpacker;
}
var filterPack;
var hasRequiredFilterPack;
function requireFilterPack() {
  if (hasRequiredFilterPack) return filterPack;
  hasRequiredFilterPack = 1;
  var paethPredictor2 = requirePaethPredictor();
  function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
    for (var x = 0; x < byteWidth; x++) {
      rawData[rawPos + x] = pxData[pxPos + x];
    }
  }
  function filterSumNone(pxData, pxPos, byteWidth) {
    var sum = 0;
    var length = pxPos + byteWidth;
    for (var i = pxPos; i < length; i++) {
      sum += Math.abs(pxData[i]);
    }
    return sum;
  }
  function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    for (var x = 0; x < byteWidth; x++) {
      var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      var val = pxData[pxPos + x] - left;
      rawData[rawPos + x] = val;
    }
  }
  function filterSumSub(pxData, pxPos, byteWidth, bpp) {
    var sum = 0;
    for (var x = 0; x < byteWidth; x++) {
      var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      var val = pxData[pxPos + x] - left;
      sum += Math.abs(val);
    }
    return sum;
  }
  function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
    for (var x = 0; x < byteWidth; x++) {
      var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      var val = pxData[pxPos + x] - up;
      rawData[rawPos + x] = val;
    }
  }
  function filterSumUp(pxData, pxPos, byteWidth) {
    var sum = 0;
    var length = pxPos + byteWidth;
    for (var x = pxPos; x < length; x++) {
      var up = pxPos > 0 ? pxData[x - byteWidth] : 0;
      var val = pxData[x] - up;
      sum += Math.abs(val);
    }
    return sum;
  }
  function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    for (var x = 0; x < byteWidth; x++) {
      var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      var val = pxData[pxPos + x] - (left + up >> 1);
      rawData[rawPos + x] = val;
    }
  }
  function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
    var sum = 0;
    for (var x = 0; x < byteWidth; x++) {
      var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      var val = pxData[pxPos + x] - (left + up >> 1);
      sum += Math.abs(val);
    }
    return sum;
  }
  function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    for (var x = 0; x < byteWidth; x++) {
      var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      var upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
      var val = pxData[pxPos + x] - paethPredictor2(left, up, upleft);
      rawData[rawPos + x] = val;
    }
  }
  function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
    var sum = 0;
    for (var x = 0; x < byteWidth; x++) {
      var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      var upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
      var val = pxData[pxPos + x] - paethPredictor2(left, up, upleft);
      sum += Math.abs(val);
    }
    return sum;
  }
  var filters = {
    0: filterNone,
    1: filterSub,
    2: filterUp,
    3: filterAvg,
    4: filterPaeth
  };
  var filterSums = {
    0: filterSumNone,
    1: filterSumSub,
    2: filterSumUp,
    3: filterSumAvg,
    4: filterSumPaeth
  };
  filterPack = function(pxData, width, height, options, bpp) {
    var filterTypes;
    if (!("filterType" in options) || options.filterType === -1) {
      filterTypes = [0, 1, 2, 3, 4];
    } else if (typeof options.filterType === "number") {
      filterTypes = [options.filterType];
    } else {
      throw new Error("unrecognised filter types");
    }
    if (options.bitDepth === 16) {
      bpp *= 2;
    }
    var byteWidth = width * bpp;
    var rawPos = 0;
    var pxPos = 0;
    var rawData = new Buffer((byteWidth + 1) * height);
    var sel = filterTypes[0];
    for (var y = 0; y < height; y++) {
      if (filterTypes.length > 1) {
        var min = Infinity;
        for (var i = 0; i < filterTypes.length; i++) {
          var sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);
          if (sum < min) {
            sel = filterTypes[i];
            min = sum;
          }
        }
      }
      rawData[rawPos] = sel;
      rawPos++;
      filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
      rawPos += byteWidth;
      pxPos += byteWidth;
    }
    return rawData;
  };
  return filterPack;
}
var hasRequiredPacker;
function requirePacker() {
  if (hasRequiredPacker) return packer.exports;
  hasRequiredPacker = 1;
  var constants2 = requireConstants();
  var CrcStream = requireCrc();
  var bitPacker = requireBitpacker();
  var filter = requireFilterPack();
  var zlib = require$$0$3;
  var Packer = packer.exports = function(options) {
    this._options = options;
    options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;
    options.deflateLevel = options.deflateLevel != null ? options.deflateLevel : 9;
    options.deflateStrategy = options.deflateStrategy != null ? options.deflateStrategy : 3;
    options.inputHasAlpha = options.inputHasAlpha != null ? options.inputHasAlpha : true;
    options.deflateFactory = options.deflateFactory || zlib.createDeflate;
    options.bitDepth = options.bitDepth || 8;
    options.colorType = typeof options.colorType === "number" ? options.colorType : constants2.COLORTYPE_COLOR_ALPHA;
    options.inputColorType = typeof options.inputColorType === "number" ? options.inputColorType : constants2.COLORTYPE_COLOR_ALPHA;
    if ([
      constants2.COLORTYPE_GRAYSCALE,
      constants2.COLORTYPE_COLOR,
      constants2.COLORTYPE_COLOR_ALPHA,
      constants2.COLORTYPE_ALPHA
    ].indexOf(options.colorType) === -1) {
      throw new Error("option color type:" + options.colorType + " is not supported at present");
    }
    if ([
      constants2.COLORTYPE_GRAYSCALE,
      constants2.COLORTYPE_COLOR,
      constants2.COLORTYPE_COLOR_ALPHA,
      constants2.COLORTYPE_ALPHA
    ].indexOf(options.inputColorType) === -1) {
      throw new Error("option input color type:" + options.inputColorType + " is not supported at present");
    }
    if (options.bitDepth !== 8 && options.bitDepth !== 16) {
      throw new Error("option bit depth:" + options.bitDepth + " is not supported at present");
    }
  };
  Packer.prototype.getDeflateOptions = function() {
    return {
      chunkSize: this._options.deflateChunkSize,
      level: this._options.deflateLevel,
      strategy: this._options.deflateStrategy
    };
  };
  Packer.prototype.createDeflate = function() {
    return this._options.deflateFactory(this.getDeflateOptions());
  };
  Packer.prototype.filterData = function(data2, width, height) {
    var packedData = bitPacker(data2, width, height, this._options);
    var bpp = constants2.COLORTYPE_TO_BPP_MAP[this._options.colorType];
    var filteredData = filter(packedData, width, height, this._options, bpp);
    return filteredData;
  };
  Packer.prototype._packChunk = function(type2, data2) {
    var len = data2 ? data2.length : 0;
    var buf = new Buffer(len + 12);
    buf.writeUInt32BE(len, 0);
    buf.writeUInt32BE(type2, 4);
    if (data2) {
      data2.copy(buf, 8);
    }
    buf.writeInt32BE(CrcStream.crc32(buf.slice(4, buf.length - 4)), buf.length - 4);
    return buf;
  };
  Packer.prototype.packGAMA = function(gamma) {
    var buf = new Buffer(4);
    buf.writeUInt32BE(Math.floor(gamma * constants2.GAMMA_DIVISION), 0);
    return this._packChunk(constants2.TYPE_gAMA, buf);
  };
  Packer.prototype.packIHDR = function(width, height) {
    var buf = new Buffer(13);
    buf.writeUInt32BE(width, 0);
    buf.writeUInt32BE(height, 4);
    buf[8] = this._options.bitDepth;
    buf[9] = this._options.colorType;
    buf[10] = 0;
    buf[11] = 0;
    buf[12] = 0;
    return this._packChunk(constants2.TYPE_IHDR, buf);
  };
  Packer.prototype.packIDAT = function(data2) {
    return this._packChunk(constants2.TYPE_IDAT, data2);
  };
  Packer.prototype.packIEND = function() {
    return this._packChunk(constants2.TYPE_IEND, null);
  };
  return packer.exports;
}
var hasRequiredPackerAsync;
function requirePackerAsync() {
  if (hasRequiredPackerAsync) return packerAsync.exports;
  hasRequiredPackerAsync = 1;
  var util2 = require$$0$5;
  var Stream = require$$1$2;
  var constants2 = requireConstants();
  var Packer = requirePacker();
  var PackerAsync = packerAsync.exports = function(opt) {
    Stream.call(this);
    var options = opt || {};
    this._packer = new Packer(options);
    this._deflate = this._packer.createDeflate();
    this.readable = true;
  };
  util2.inherits(PackerAsync, Stream);
  PackerAsync.prototype.pack = function(data2, width, height, gamma) {
    this.emit("data", new Buffer(constants2.PNG_SIGNATURE));
    this.emit("data", this._packer.packIHDR(width, height));
    if (gamma) {
      this.emit("data", this._packer.packGAMA(gamma));
    }
    var filteredData = this._packer.filterData(data2, width, height);
    this._deflate.on("error", this.emit.bind(this, "error"));
    this._deflate.on("data", (function(compressedData) {
      this.emit("data", this._packer.packIDAT(compressedData));
    }).bind(this));
    this._deflate.on("end", (function() {
      this.emit("data", this._packer.packIEND());
      this.emit("end");
    }).bind(this));
    this._deflate.end(filteredData);
  };
  return packerAsync.exports;
}
var pngSync = {};
var syncInflate = { exports: {} };
var hasRequiredSyncInflate;
function requireSyncInflate() {
  if (hasRequiredSyncInflate) return syncInflate.exports;
  hasRequiredSyncInflate = 1;
  (function(module, exports$1) {
    var assert = require$$0$6.ok;
    var zlib = require$$0$3;
    var util2 = require$$0$5;
    var kMaxLength = require$$0$4.kMaxLength;
    function Inflate(opts) {
      if (!(this instanceof Inflate)) {
        return new Inflate(opts);
      }
      if (opts && opts.chunkSize < zlib.Z_MIN_CHUNK) {
        opts.chunkSize = zlib.Z_MIN_CHUNK;
      }
      zlib.Inflate.call(this, opts);
      this._offset = this._offset === void 0 ? this._outOffset : this._offset;
      this._buffer = this._buffer || this._outBuffer;
      if (opts && opts.maxLength != null) {
        this._maxLength = opts.maxLength;
      }
    }
    function createInflate(opts) {
      return new Inflate(opts);
    }
    function _close(engine, callback) {
      if (!engine._handle) {
        return;
      }
      engine._handle.close();
      engine._handle = null;
    }
    Inflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {
      if (typeof asyncCb === "function") {
        return zlib.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
      }
      var self2 = this;
      var availInBefore = chunk && chunk.length;
      var availOutBefore = this._chunkSize - this._offset;
      var leftToInflate = this._maxLength;
      var inOff = 0;
      var buffers = [];
      var nread = 0;
      var error2;
      this.on("error", function(err) {
        error2 = err;
      });
      function handleChunk(availInAfter, availOutAfter) {
        if (self2._hadError) {
          return;
        }
        var have = availOutBefore - availOutAfter;
        assert(have >= 0, "have should not go down");
        if (have > 0) {
          var out = self2._buffer.slice(self2._offset, self2._offset + have);
          self2._offset += have;
          if (out.length > leftToInflate) {
            out = out.slice(0, leftToInflate);
          }
          buffers.push(out);
          nread += out.length;
          leftToInflate -= out.length;
          if (leftToInflate === 0) {
            return false;
          }
        }
        if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
          availOutBefore = self2._chunkSize;
          self2._offset = 0;
          self2._buffer = Buffer.allocUnsafe(self2._chunkSize);
        }
        if (availOutAfter === 0) {
          inOff += availInBefore - availInAfter;
          availInBefore = availInAfter;
          return true;
        }
        return false;
      }
      assert(this._handle, "zlib binding closed");
      do {
        var res = this._handle.writeSync(
          flushFlag,
          chunk,
          // in
          inOff,
          // in_off
          availInBefore,
          // in_len
          this._buffer,
          // out
          this._offset,
          //out_off
          availOutBefore
        );
        res = res || this._writeState;
      } while (!this._hadError && handleChunk(res[0], res[1]));
      if (this._hadError) {
        throw error2;
      }
      if (nread >= kMaxLength) {
        _close(this);
        throw new RangeError("Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes");
      }
      var buf = Buffer.concat(buffers, nread);
      _close(this);
      return buf;
    };
    util2.inherits(Inflate, zlib.Inflate);
    function zlibBufferSync(engine, buffer) {
      if (typeof buffer === "string") {
        buffer = Buffer.from(buffer);
      }
      if (!(buffer instanceof Buffer)) {
        throw new TypeError("Not a string or buffer");
      }
      var flushFlag = engine._finishFlushFlag;
      if (flushFlag == null) {
        flushFlag = zlib.Z_FINISH;
      }
      return engine._processChunk(buffer, flushFlag);
    }
    function inflateSync(buffer, opts) {
      return zlibBufferSync(new Inflate(opts), buffer);
    }
    module.exports = exports$1 = inflateSync;
    exports$1.Inflate = Inflate;
    exports$1.createInflate = createInflate;
    exports$1.inflateSync = inflateSync;
  })(syncInflate, syncInflate.exports);
  return syncInflate.exports;
}
var syncReader = { exports: {} };
var hasRequiredSyncReader;
function requireSyncReader() {
  if (hasRequiredSyncReader) return syncReader.exports;
  hasRequiredSyncReader = 1;
  var SyncReader = syncReader.exports = function(buffer) {
    this._buffer = buffer;
    this._reads = [];
  };
  SyncReader.prototype.read = function(length, callback) {
    this._reads.push({
      length: Math.abs(length),
      // if length < 0 then at most this length
      allowLess: length < 0,
      func: callback
    });
  };
  SyncReader.prototype.process = function() {
    while (this._reads.length > 0 && this._buffer.length) {
      var read = this._reads[0];
      if (this._buffer.length && (this._buffer.length >= read.length || read.allowLess)) {
        this._reads.shift();
        var buf = this._buffer;
        this._buffer = buf.slice(read.length);
        read.func.call(this, buf.slice(0, read.length));
      } else {
        break;
      }
    }
    if (this._reads.length > 0) {
      return new Error("There are some read requests waitng on finished stream");
    }
    if (this._buffer.length > 0) {
      return new Error("unrecognised content at end of stream");
    }
  };
  return syncReader.exports;
}
var filterParseSync = {};
var hasRequiredFilterParseSync;
function requireFilterParseSync() {
  if (hasRequiredFilterParseSync) return filterParseSync;
  hasRequiredFilterParseSync = 1;
  var SyncReader = requireSyncReader();
  var Filter = requireFilterParse();
  filterParseSync.process = function(inBuffer, bitmapInfo) {
    var outBuffers = [];
    var reader2 = new SyncReader(inBuffer);
    var filter = new Filter(bitmapInfo, {
      read: reader2.read.bind(reader2),
      write: function(bufferPart) {
        outBuffers.push(bufferPart);
      },
      complete: function() {
      }
    });
    filter.start();
    reader2.process();
    return Buffer.concat(outBuffers);
  };
  return filterParseSync;
}
var parserSync;
var hasRequiredParserSync;
function requireParserSync() {
  if (hasRequiredParserSync) return parserSync;
  hasRequiredParserSync = 1;
  var hasSyncZlib = true;
  var zlib = require$$0$3;
  var inflateSync = requireSyncInflate();
  if (!zlib.deflateSync) {
    hasSyncZlib = false;
  }
  var SyncReader = requireSyncReader();
  var FilterSync = requireFilterParseSync();
  var Parser = requireParser$1();
  var bitmapper2 = requireBitmapper();
  var formatNormaliser2 = requireFormatNormaliser();
  parserSync = function(buffer, options) {
    if (!hasSyncZlib) {
      throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
    }
    var err;
    function handleError(_err_) {
      err = _err_;
    }
    var metaData;
    function handleMetaData(_metaData_) {
      metaData = _metaData_;
    }
    function handleTransColor(transColor) {
      metaData.transColor = transColor;
    }
    function handlePalette(palette) {
      metaData.palette = palette;
    }
    function handleSimpleTransparency() {
      metaData.alpha = true;
    }
    var gamma;
    function handleGamma(_gamma_) {
      gamma = _gamma_;
    }
    var inflateDataList = [];
    function handleInflateData(inflatedData2) {
      inflateDataList.push(inflatedData2);
    }
    var reader2 = new SyncReader(buffer);
    var parser2 = new Parser(options, {
      read: reader2.read.bind(reader2),
      error: handleError,
      metadata: handleMetaData,
      gamma: handleGamma,
      palette: handlePalette,
      transColor: handleTransColor,
      inflateData: handleInflateData,
      simpleTransparency: handleSimpleTransparency
    });
    parser2.start();
    reader2.process();
    if (err) {
      throw err;
    }
    var inflateData = Buffer.concat(inflateDataList);
    inflateDataList.length = 0;
    var inflatedData;
    if (metaData.interlace) {
      inflatedData = zlib.inflateSync(inflateData);
    } else {
      var rowSize = (metaData.width * metaData.bpp * metaData.depth + 7 >> 3) + 1;
      var imageSize = rowSize * metaData.height;
      inflatedData = inflateSync(inflateData, { chunkSize: imageSize, maxLength: imageSize });
    }
    inflateData = null;
    if (!inflatedData || !inflatedData.length) {
      throw new Error("bad png - invalid inflate data response");
    }
    var unfilteredData = FilterSync.process(inflatedData, metaData);
    inflateData = null;
    var bitmapData = bitmapper2.dataToBitMap(unfilteredData, metaData);
    unfilteredData = null;
    var normalisedBitmapData = formatNormaliser2(bitmapData, metaData);
    metaData.data = normalisedBitmapData;
    metaData.gamma = gamma || 0;
    return metaData;
  };
  return parserSync;
}
var packerSync;
var hasRequiredPackerSync;
function requirePackerSync() {
  if (hasRequiredPackerSync) return packerSync;
  hasRequiredPackerSync = 1;
  var hasSyncZlib = true;
  var zlib = require$$0$3;
  if (!zlib.deflateSync) {
    hasSyncZlib = false;
  }
  var constants2 = requireConstants();
  var Packer = requirePacker();
  packerSync = function(metaData, opt) {
    if (!hasSyncZlib) {
      throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
    }
    var options = opt || {};
    var packer2 = new Packer(options);
    var chunks = [];
    chunks.push(new Buffer(constants2.PNG_SIGNATURE));
    chunks.push(packer2.packIHDR(metaData.width, metaData.height));
    if (metaData.gamma) {
      chunks.push(packer2.packGAMA(metaData.gamma));
    }
    var filteredData = packer2.filterData(metaData.data, metaData.width, metaData.height);
    var compressedData = zlib.deflateSync(filteredData, packer2.getDeflateOptions());
    filteredData = null;
    if (!compressedData || !compressedData.length) {
      throw new Error("bad png - invalid compressed data response");
    }
    chunks.push(packer2.packIDAT(compressedData));
    chunks.push(packer2.packIEND());
    return Buffer.concat(chunks);
  };
  return packerSync;
}
var hasRequiredPngSync;
function requirePngSync() {
  if (hasRequiredPngSync) return pngSync;
  hasRequiredPngSync = 1;
  var parse2 = requireParserSync();
  var pack = requirePackerSync();
  pngSync.read = function(buffer, options) {
    return parse2(buffer, options || {});
  };
  pngSync.write = function(png2, options) {
    return pack(png2, options);
  };
  return pngSync;
}
var hasRequiredPng;
function requirePng() {
  if (hasRequiredPng) return png;
  hasRequiredPng = 1;
  var util2 = require$$0$5;
  var Stream = require$$1$2;
  var Parser = requireParserAsync();
  var Packer = requirePackerAsync();
  var PNGSync = requirePngSync();
  var PNG = png.PNG = function(options) {
    Stream.call(this);
    options = options || {};
    this.width = options.width | 0;
    this.height = options.height | 0;
    this.data = this.width > 0 && this.height > 0 ? new Buffer(4 * this.width * this.height) : null;
    if (options.fill && this.data) {
      this.data.fill(0);
    }
    this.gamma = 0;
    this.readable = this.writable = true;
    this._parser = new Parser(options);
    this._parser.on("error", this.emit.bind(this, "error"));
    this._parser.on("close", this._handleClose.bind(this));
    this._parser.on("metadata", this._metadata.bind(this));
    this._parser.on("gamma", this._gamma.bind(this));
    this._parser.on("parsed", (function(data2) {
      this.data = data2;
      this.emit("parsed", data2);
    }).bind(this));
    this._packer = new Packer(options);
    this._packer.on("data", this.emit.bind(this, "data"));
    this._packer.on("end", this.emit.bind(this, "end"));
    this._parser.on("close", this._handleClose.bind(this));
    this._packer.on("error", this.emit.bind(this, "error"));
  };
  util2.inherits(PNG, Stream);
  PNG.sync = PNGSync;
  PNG.prototype.pack = function() {
    if (!this.data || !this.data.length) {
      this.emit("error", "No data provided");
      return this;
    }
    process.nextTick((function() {
      this._packer.pack(this.data, this.width, this.height, this.gamma);
    }).bind(this));
    return this;
  };
  PNG.prototype.parse = function(data2, callback) {
    if (callback) {
      var onParsed, onError;
      onParsed = (function(parsedData) {
        this.removeListener("error", onError);
        this.data = parsedData;
        callback(null, this);
      }).bind(this);
      onError = (function(err) {
        this.removeListener("parsed", onParsed);
        callback(err, null);
      }).bind(this);
      this.once("parsed", onParsed);
      this.once("error", onError);
    }
    this.end(data2);
    return this;
  };
  PNG.prototype.write = function(data2) {
    this._parser.write(data2);
    return true;
  };
  PNG.prototype.end = function(data2) {
    this._parser.end(data2);
  };
  PNG.prototype._metadata = function(metadata) {
    this.width = metadata.width;
    this.height = metadata.height;
    this.emit("metadata", metadata);
  };
  PNG.prototype._gamma = function(gamma) {
    this.gamma = gamma;
  };
  PNG.prototype._handleClose = function() {
    if (!this._parser.writable && !this._packer.readable) {
      this.emit("close");
    }
  };
  PNG.bitblt = function(src, dst, srcX, srcY, width, height, deltaX, deltaY) {
    srcX |= 0;
    srcY |= 0;
    width |= 0;
    height |= 0;
    deltaX |= 0;
    deltaY |= 0;
    if (srcX > src.width || srcY > src.height || srcX + width > src.width || srcY + height > src.height) {
      throw new Error("bitblt reading outside image");
    }
    if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {
      throw new Error("bitblt writing outside image");
    }
    for (var y = 0; y < height; y++) {
      src.data.copy(
        dst.data,
        (deltaY + y) * dst.width + deltaX << 2,
        (srcY + y) * src.width + srcX << 2,
        (srcY + y) * src.width + srcX + width << 2
      );
    }
  };
  PNG.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) {
    PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
    return this;
  };
  PNG.adjustGamma = function(src) {
    if (src.gamma) {
      for (var y = 0; y < src.height; y++) {
        for (var x = 0; x < src.width; x++) {
          var idx = src.width * y + x << 2;
          for (var i = 0; i < 3; i++) {
            var sample = src.data[idx + i] / 255;
            sample = Math.pow(sample, 1 / 2.2 / src.gamma);
            src.data[idx + i] = Math.round(sample * 255);
          }
        }
      }
      src.gamma = 0;
    }
  };
  PNG.prototype.adjustGamma = function() {
    PNG.adjustGamma(this);
  };
  return png;
}
var encoder = { exports: {} };
var hasRequiredEncoder;
function requireEncoder() {
  if (hasRequiredEncoder) return encoder.exports;
  hasRequiredEncoder = 1;
  (function(module) {
    function JPEGEncoder(quality) {
      var ffloor = Math.floor;
      var YTable = new Array(64);
      var UVTable = new Array(64);
      var fdtbl_Y = new Array(64);
      var fdtbl_UV = new Array(64);
      var YDC_HT;
      var UVDC_HT;
      var YAC_HT;
      var UVAC_HT;
      var bitcode = new Array(65535);
      var category = new Array(65535);
      var outputfDCTQuant = new Array(64);
      var DU = new Array(64);
      var byteout = [];
      var bytenew = 0;
      var bytepos = 7;
      var YDU = new Array(64);
      var UDU = new Array(64);
      var VDU = new Array(64);
      var clt = new Array(256);
      var RGB_YUV_TABLE = new Array(2048);
      var currentQuality;
      var ZigZag = [
        0,
        1,
        5,
        6,
        14,
        15,
        27,
        28,
        2,
        4,
        7,
        13,
        16,
        26,
        29,
        42,
        3,
        8,
        12,
        17,
        25,
        30,
        41,
        43,
        9,
        11,
        18,
        24,
        31,
        40,
        44,
        53,
        10,
        19,
        23,
        32,
        39,
        45,
        52,
        54,
        20,
        22,
        33,
        38,
        46,
        51,
        55,
        60,
        21,
        34,
        37,
        47,
        50,
        56,
        59,
        61,
        35,
        36,
        48,
        49,
        57,
        58,
        62,
        63
      ];
      var std_dc_luminance_nrcodes = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];
      var std_dc_luminance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      var std_ac_luminance_nrcodes = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125];
      var std_ac_luminance_values = [
        1,
        2,
        3,
        0,
        4,
        17,
        5,
        18,
        33,
        49,
        65,
        6,
        19,
        81,
        97,
        7,
        34,
        113,
        20,
        50,
        129,
        145,
        161,
        8,
        35,
        66,
        177,
        193,
        21,
        82,
        209,
        240,
        36,
        51,
        98,
        114,
        130,
        9,
        10,
        22,
        23,
        24,
        25,
        26,
        37,
        38,
        39,
        40,
        41,
        42,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        241,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ];
      var std_dc_chrominance_nrcodes = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];
      var std_dc_chrominance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      var std_ac_chrominance_nrcodes = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119];
      var std_ac_chrominance_values = [
        0,
        1,
        2,
        3,
        17,
        4,
        5,
        33,
        49,
        6,
        18,
        65,
        81,
        7,
        97,
        113,
        19,
        34,
        50,
        129,
        8,
        20,
        66,
        145,
        161,
        177,
        193,
        9,
        35,
        51,
        82,
        240,
        21,
        98,
        114,
        209,
        10,
        22,
        36,
        52,
        225,
        37,
        241,
        23,
        24,
        25,
        26,
        38,
        39,
        40,
        41,
        42,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        130,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ];
      function initQuantTables(sf) {
        var YQT = [
          16,
          11,
          10,
          16,
          24,
          40,
          51,
          61,
          12,
          12,
          14,
          19,
          26,
          58,
          60,
          55,
          14,
          13,
          16,
          24,
          40,
          57,
          69,
          56,
          14,
          17,
          22,
          29,
          51,
          87,
          80,
          62,
          18,
          22,
          37,
          56,
          68,
          109,
          103,
          77,
          24,
          35,
          55,
          64,
          81,
          104,
          113,
          92,
          49,
          64,
          78,
          87,
          103,
          121,
          120,
          101,
          72,
          92,
          95,
          98,
          112,
          100,
          103,
          99
        ];
        for (var i = 0; i < 64; i++) {
          var t = ffloor((YQT[i] * sf + 50) / 100);
          if (t < 1) {
            t = 1;
          } else if (t > 255) {
            t = 255;
          }
          YTable[ZigZag[i]] = t;
        }
        var UVQT = [
          17,
          18,
          24,
          47,
          99,
          99,
          99,
          99,
          18,
          21,
          26,
          66,
          99,
          99,
          99,
          99,
          24,
          26,
          56,
          99,
          99,
          99,
          99,
          99,
          47,
          66,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99
        ];
        for (var j = 0; j < 64; j++) {
          var u = ffloor((UVQT[j] * sf + 50) / 100);
          if (u < 1) {
            u = 1;
          } else if (u > 255) {
            u = 255;
          }
          UVTable[ZigZag[j]] = u;
        }
        var aasf = [
          1,
          1.387039845,
          1.306562965,
          1.175875602,
          1,
          0.785694958,
          0.5411961,
          0.275899379
        ];
        var k = 0;
        for (var row = 0; row < 8; row++) {
          for (var col = 0; col < 8; col++) {
            fdtbl_Y[k] = 1 / (YTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
            fdtbl_UV[k] = 1 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
            k++;
          }
        }
      }
      function computeHuffmanTbl(nrcodes, std_table) {
        var codevalue = 0;
        var pos_in_table = 0;
        var HT = new Array();
        for (var k = 1; k <= 16; k++) {
          for (var j = 1; j <= nrcodes[k]; j++) {
            HT[std_table[pos_in_table]] = [];
            HT[std_table[pos_in_table]][0] = codevalue;
            HT[std_table[pos_in_table]][1] = k;
            pos_in_table++;
            codevalue++;
          }
          codevalue *= 2;
        }
        return HT;
      }
      function initHuffmanTbl() {
        YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes, std_dc_luminance_values);
        UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes, std_dc_chrominance_values);
        YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes, std_ac_luminance_values);
        UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes, std_ac_chrominance_values);
      }
      function initCategoryNumber() {
        var nrlower = 1;
        var nrupper = 2;
        for (var cat = 1; cat <= 15; cat++) {
          for (var nr = nrlower; nr < nrupper; nr++) {
            category[32767 + nr] = cat;
            bitcode[32767 + nr] = [];
            bitcode[32767 + nr][1] = cat;
            bitcode[32767 + nr][0] = nr;
          }
          for (var nrneg = -(nrupper - 1); nrneg <= -nrlower; nrneg++) {
            category[32767 + nrneg] = cat;
            bitcode[32767 + nrneg] = [];
            bitcode[32767 + nrneg][1] = cat;
            bitcode[32767 + nrneg][0] = nrupper - 1 + nrneg;
          }
          nrlower <<= 1;
          nrupper <<= 1;
        }
      }
      function initRGBYUVTable() {
        for (var i = 0; i < 256; i++) {
          RGB_YUV_TABLE[i] = 19595 * i;
          RGB_YUV_TABLE[i + 256 >> 0] = 38470 * i;
          RGB_YUV_TABLE[i + 512 >> 0] = 7471 * i + 32768;
          RGB_YUV_TABLE[i + 768 >> 0] = -11059 * i;
          RGB_YUV_TABLE[i + 1024 >> 0] = -21709 * i;
          RGB_YUV_TABLE[i + 1280 >> 0] = 32768 * i + 8421375;
          RGB_YUV_TABLE[i + 1536 >> 0] = -27439 * i;
          RGB_YUV_TABLE[i + 1792 >> 0] = -5329 * i;
        }
      }
      function writeBits(bs) {
        var value = bs[0];
        var posval = bs[1] - 1;
        while (posval >= 0) {
          if (value & 1 << posval) {
            bytenew |= 1 << bytepos;
          }
          posval--;
          bytepos--;
          if (bytepos < 0) {
            if (bytenew == 255) {
              writeByte(255);
              writeByte(0);
            } else {
              writeByte(bytenew);
            }
            bytepos = 7;
            bytenew = 0;
          }
        }
      }
      function writeByte(value) {
        byteout.push(value);
      }
      function writeWord(value) {
        writeByte(value >> 8 & 255);
        writeByte(value & 255);
      }
      function fDCTQuant(data2, fdtbl) {
        var d0, d1, d2, d3, d4, d5, d6, d7;
        var dataOff = 0;
        var i;
        var I8 = 8;
        var I64 = 64;
        for (i = 0; i < I8; ++i) {
          d0 = data2[dataOff];
          d1 = data2[dataOff + 1];
          d2 = data2[dataOff + 2];
          d3 = data2[dataOff + 3];
          d4 = data2[dataOff + 4];
          d5 = data2[dataOff + 5];
          d6 = data2[dataOff + 6];
          d7 = data2[dataOff + 7];
          var tmp0 = d0 + d7;
          var tmp7 = d0 - d7;
          var tmp1 = d1 + d6;
          var tmp6 = d1 - d6;
          var tmp2 = d2 + d5;
          var tmp5 = d2 - d5;
          var tmp3 = d3 + d4;
          var tmp4 = d3 - d4;
          var tmp10 = tmp0 + tmp3;
          var tmp13 = tmp0 - tmp3;
          var tmp11 = tmp1 + tmp2;
          var tmp12 = tmp1 - tmp2;
          data2[dataOff] = tmp10 + tmp11;
          data2[dataOff + 4] = tmp10 - tmp11;
          var z1 = (tmp12 + tmp13) * 0.707106781;
          data2[dataOff + 2] = tmp13 + z1;
          data2[dataOff + 6] = tmp13 - z1;
          tmp10 = tmp4 + tmp5;
          tmp11 = tmp5 + tmp6;
          tmp12 = tmp6 + tmp7;
          var z5 = (tmp10 - tmp12) * 0.382683433;
          var z2 = 0.5411961 * tmp10 + z5;
          var z4 = 1.306562965 * tmp12 + z5;
          var z3 = tmp11 * 0.707106781;
          var z11 = tmp7 + z3;
          var z13 = tmp7 - z3;
          data2[dataOff + 5] = z13 + z2;
          data2[dataOff + 3] = z13 - z2;
          data2[dataOff + 1] = z11 + z4;
          data2[dataOff + 7] = z11 - z4;
          dataOff += 8;
        }
        dataOff = 0;
        for (i = 0; i < I8; ++i) {
          d0 = data2[dataOff];
          d1 = data2[dataOff + 8];
          d2 = data2[dataOff + 16];
          d3 = data2[dataOff + 24];
          d4 = data2[dataOff + 32];
          d5 = data2[dataOff + 40];
          d6 = data2[dataOff + 48];
          d7 = data2[dataOff + 56];
          var tmp0p2 = d0 + d7;
          var tmp7p2 = d0 - d7;
          var tmp1p2 = d1 + d6;
          var tmp6p2 = d1 - d6;
          var tmp2p2 = d2 + d5;
          var tmp5p2 = d2 - d5;
          var tmp3p2 = d3 + d4;
          var tmp4p2 = d3 - d4;
          var tmp10p2 = tmp0p2 + tmp3p2;
          var tmp13p2 = tmp0p2 - tmp3p2;
          var tmp11p2 = tmp1p2 + tmp2p2;
          var tmp12p2 = tmp1p2 - tmp2p2;
          data2[dataOff] = tmp10p2 + tmp11p2;
          data2[dataOff + 32] = tmp10p2 - tmp11p2;
          var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781;
          data2[dataOff + 16] = tmp13p2 + z1p2;
          data2[dataOff + 48] = tmp13p2 - z1p2;
          tmp10p2 = tmp4p2 + tmp5p2;
          tmp11p2 = tmp5p2 + tmp6p2;
          tmp12p2 = tmp6p2 + tmp7p2;
          var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433;
          var z2p2 = 0.5411961 * tmp10p2 + z5p2;
          var z4p2 = 1.306562965 * tmp12p2 + z5p2;
          var z3p2 = tmp11p2 * 0.707106781;
          var z11p2 = tmp7p2 + z3p2;
          var z13p2 = tmp7p2 - z3p2;
          data2[dataOff + 40] = z13p2 + z2p2;
          data2[dataOff + 24] = z13p2 - z2p2;
          data2[dataOff + 8] = z11p2 + z4p2;
          data2[dataOff + 56] = z11p2 - z4p2;
          dataOff++;
        }
        var fDCTQuant2;
        for (i = 0; i < I64; ++i) {
          fDCTQuant2 = data2[i] * fdtbl[i];
          outputfDCTQuant[i] = fDCTQuant2 > 0 ? fDCTQuant2 + 0.5 | 0 : fDCTQuant2 - 0.5 | 0;
        }
        return outputfDCTQuant;
      }
      function writeAPP0() {
        writeWord(65504);
        writeWord(16);
        writeByte(74);
        writeByte(70);
        writeByte(73);
        writeByte(70);
        writeByte(0);
        writeByte(1);
        writeByte(1);
        writeByte(0);
        writeWord(1);
        writeWord(1);
        writeByte(0);
        writeByte(0);
      }
      function writeAPP1(exifBuffer) {
        if (!exifBuffer) return;
        writeWord(65505);
        if (exifBuffer[0] === 69 && exifBuffer[1] === 120 && exifBuffer[2] === 105 && exifBuffer[3] === 102) {
          writeWord(exifBuffer.length + 2);
        } else {
          writeWord(exifBuffer.length + 5 + 2);
          writeByte(69);
          writeByte(120);
          writeByte(105);
          writeByte(102);
          writeByte(0);
        }
        for (var i = 0; i < exifBuffer.length; i++) {
          writeByte(exifBuffer[i]);
        }
      }
      function writeSOF0(width, height) {
        writeWord(65472);
        writeWord(17);
        writeByte(8);
        writeWord(height);
        writeWord(width);
        writeByte(3);
        writeByte(1);
        writeByte(17);
        writeByte(0);
        writeByte(2);
        writeByte(17);
        writeByte(1);
        writeByte(3);
        writeByte(17);
        writeByte(1);
      }
      function writeDQT() {
        writeWord(65499);
        writeWord(132);
        writeByte(0);
        for (var i = 0; i < 64; i++) {
          writeByte(YTable[i]);
        }
        writeByte(1);
        for (var j = 0; j < 64; j++) {
          writeByte(UVTable[j]);
        }
      }
      function writeDHT() {
        writeWord(65476);
        writeWord(418);
        writeByte(0);
        for (var i = 0; i < 16; i++) {
          writeByte(std_dc_luminance_nrcodes[i + 1]);
        }
        for (var j = 0; j <= 11; j++) {
          writeByte(std_dc_luminance_values[j]);
        }
        writeByte(16);
        for (var k = 0; k < 16; k++) {
          writeByte(std_ac_luminance_nrcodes[k + 1]);
        }
        for (var l = 0; l <= 161; l++) {
          writeByte(std_ac_luminance_values[l]);
        }
        writeByte(1);
        for (var m = 0; m < 16; m++) {
          writeByte(std_dc_chrominance_nrcodes[m + 1]);
        }
        for (var n = 0; n <= 11; n++) {
          writeByte(std_dc_chrominance_values[n]);
        }
        writeByte(17);
        for (var o = 0; o < 16; o++) {
          writeByte(std_ac_chrominance_nrcodes[o + 1]);
        }
        for (var p = 0; p <= 161; p++) {
          writeByte(std_ac_chrominance_values[p]);
        }
      }
      function writeCOM(comments) {
        if (typeof comments === "undefined" || comments.constructor !== Array) return;
        comments.forEach((e) => {
          if (typeof e !== "string") return;
          writeWord(65534);
          var l = e.length;
          writeWord(l + 2);
          var i;
          for (i = 0; i < l; i++)
            writeByte(e.charCodeAt(i));
        });
      }
      function writeSOS() {
        writeWord(65498);
        writeWord(12);
        writeByte(3);
        writeByte(1);
        writeByte(0);
        writeByte(2);
        writeByte(17);
        writeByte(3);
        writeByte(17);
        writeByte(0);
        writeByte(63);
        writeByte(0);
      }
      function processDU(CDU, fdtbl, DC, HTDC, HTAC) {
        var EOB = HTAC[0];
        var M16zeroes = HTAC[240];
        var pos;
        var I16 = 16;
        var I63 = 63;
        var I64 = 64;
        var DU_DCT = fDCTQuant(CDU, fdtbl);
        for (var j = 0; j < I64; ++j) {
          DU[ZigZag[j]] = DU_DCT[j];
        }
        var Diff = DU[0] - DC;
        DC = DU[0];
        if (Diff == 0) {
          writeBits(HTDC[0]);
        } else {
          pos = 32767 + Diff;
          writeBits(HTDC[category[pos]]);
          writeBits(bitcode[pos]);
        }
        var end0pos = 63;
        for (; end0pos > 0 && DU[end0pos] == 0; end0pos--) {
        }
        if (end0pos == 0) {
          writeBits(EOB);
          return DC;
        }
        var i = 1;
        var lng;
        while (i <= end0pos) {
          var startpos = i;
          for (; DU[i] == 0 && i <= end0pos; ++i) {
          }
          var nrzeroes = i - startpos;
          if (nrzeroes >= I16) {
            lng = nrzeroes >> 4;
            for (var nrmarker = 1; nrmarker <= lng; ++nrmarker)
              writeBits(M16zeroes);
            nrzeroes = nrzeroes & 15;
          }
          pos = 32767 + DU[i];
          writeBits(HTAC[(nrzeroes << 4) + category[pos]]);
          writeBits(bitcode[pos]);
          i++;
        }
        if (end0pos != I63) {
          writeBits(EOB);
        }
        return DC;
      }
      function initCharLookupTable() {
        var sfcc = String.fromCharCode;
        for (var i = 0; i < 256; i++) {
          clt[i] = sfcc(i);
        }
      }
      this.encode = function(image2, quality2) {
        (/* @__PURE__ */ new Date()).getTime();
        if (quality2) setQuality(quality2);
        byteout = new Array();
        bytenew = 0;
        bytepos = 7;
        writeWord(65496);
        writeAPP0();
        writeCOM(image2.comments);
        writeAPP1(image2.exifBuffer);
        writeDQT();
        writeSOF0(image2.width, image2.height);
        writeDHT();
        writeSOS();
        var DCY = 0;
        var DCU = 0;
        var DCV = 0;
        bytenew = 0;
        bytepos = 7;
        this.encode.displayName = "_encode_";
        var imageData = image2.data;
        var width = image2.width;
        var height = image2.height;
        var quadWidth = width * 4;
        var x, y = 0;
        var r, g, b;
        var start, p, col, row, pos;
        while (y < height) {
          x = 0;
          while (x < quadWidth) {
            start = quadWidth * y + x;
            p = start;
            col = -1;
            row = 0;
            for (pos = 0; pos < 64; pos++) {
              row = pos >> 3;
              col = (pos & 7) * 4;
              p = start + row * quadWidth + col;
              if (y + row >= height) {
                p -= quadWidth * (y + 1 + row - height);
              }
              if (x + col >= quadWidth) {
                p -= x + col - quadWidth + 4;
              }
              r = imageData[p++];
              g = imageData[p++];
              b = imageData[p++];
              YDU[pos] = (RGB_YUV_TABLE[r] + RGB_YUV_TABLE[g + 256 >> 0] + RGB_YUV_TABLE[b + 512 >> 0] >> 16) - 128;
              UDU[pos] = (RGB_YUV_TABLE[r + 768 >> 0] + RGB_YUV_TABLE[g + 1024 >> 0] + RGB_YUV_TABLE[b + 1280 >> 0] >> 16) - 128;
              VDU[pos] = (RGB_YUV_TABLE[r + 1280 >> 0] + RGB_YUV_TABLE[g + 1536 >> 0] + RGB_YUV_TABLE[b + 1792 >> 0] >> 16) - 128;
            }
            DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
            DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
            DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
            x += 32;
          }
          y += 8;
        }
        if (bytepos >= 0) {
          var fillbits = [];
          fillbits[1] = bytepos + 1;
          fillbits[0] = (1 << bytepos + 1) - 1;
          writeBits(fillbits);
        }
        writeWord(65497);
        return Buffer.from(byteout);
      };
      function setQuality(quality2) {
        if (quality2 <= 0) {
          quality2 = 1;
        }
        if (quality2 > 100) {
          quality2 = 100;
        }
        if (currentQuality == quality2) return;
        var sf = 0;
        if (quality2 < 50) {
          sf = Math.floor(5e3 / quality2);
        } else {
          sf = Math.floor(200 - quality2 * 2);
        }
        initQuantTables(sf);
        currentQuality = quality2;
      }
      function init() {
        var time_start = (/* @__PURE__ */ new Date()).getTime();
        if (!quality) quality = 50;
        initCharLookupTable();
        initHuffmanTbl();
        initCategoryNumber();
        initRGBYUVTable();
        setQuality(quality);
        (/* @__PURE__ */ new Date()).getTime() - time_start;
      }
      init();
    }
    {
      module.exports = encode;
    }
    function encode(imgData, qu) {
      if (typeof qu === "undefined") qu = 50;
      var encoder2 = new JPEGEncoder(qu);
      var data2 = encoder2.encode(imgData, qu);
      return {
        data: data2,
        width: imgData.width,
        height: imgData.height
      };
    }
  })(encoder);
  return encoder.exports;
}
var decoder = { exports: {} };
var hasRequiredDecoder;
function requireDecoder() {
  if (hasRequiredDecoder) return decoder.exports;
  hasRequiredDecoder = 1;
  (function(module) {
    var JpegImage = (function jpegImage() {
      var dctZigZag = new Int32Array([
        0,
        1,
        8,
        16,
        9,
        2,
        3,
        10,
        17,
        24,
        32,
        25,
        18,
        11,
        4,
        5,
        12,
        19,
        26,
        33,
        40,
        48,
        41,
        34,
        27,
        20,
        13,
        6,
        7,
        14,
        21,
        28,
        35,
        42,
        49,
        56,
        57,
        50,
        43,
        36,
        29,
        22,
        15,
        23,
        30,
        37,
        44,
        51,
        58,
        59,
        52,
        45,
        38,
        31,
        39,
        46,
        53,
        60,
        61,
        54,
        47,
        55,
        62,
        63
      ]);
      var dctCos1 = 4017;
      var dctSin1 = 799;
      var dctCos3 = 3406;
      var dctSin3 = 2276;
      var dctCos6 = 1567;
      var dctSin6 = 3784;
      var dctSqrt2 = 5793;
      var dctSqrt1d2 = 2896;
      function constructor() {
      }
      function buildHuffmanTable(codeLengths, values) {
        var k = 0, code = [], i, j, length = 16;
        while (length > 0 && !codeLengths[length - 1])
          length--;
        code.push({ children: [], index: 0 });
        var p = code[0], q2;
        for (i = 0; i < length; i++) {
          for (j = 0; j < codeLengths[i]; j++) {
            p = code.pop();
            p.children[p.index] = values[k];
            while (p.index > 0) {
              if (code.length === 0)
                throw new Error("Could not recreate Huffman Table");
              p = code.pop();
            }
            p.index++;
            code.push(p);
            while (code.length <= i) {
              code.push(q2 = { children: [], index: 0 });
              p.children[p.index] = q2.children;
              p = q2;
            }
            k++;
          }
          if (i + 1 < length) {
            code.push(q2 = { children: [], index: 0 });
            p.children[p.index] = q2.children;
            p = q2;
          }
        }
        return code[0].children;
      }
      function decodeScan(data2, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, opts) {
        frame.precision;
        frame.samplesPerLine;
        frame.scanLines;
        var mcusPerLine = frame.mcusPerLine;
        var progressive = frame.progressive;
        frame.maxH;
        frame.maxV;
        var startOffset = offset, bitsData = 0, bitsCount = 0;
        function readBit() {
          if (bitsCount > 0) {
            bitsCount--;
            return bitsData >> bitsCount & 1;
          }
          bitsData = data2[offset++];
          if (bitsData == 255) {
            var nextByte = data2[offset++];
            if (nextByte) {
              throw new Error("unexpected marker: " + (bitsData << 8 | nextByte).toString(16));
            }
          }
          bitsCount = 7;
          return bitsData >>> 7;
        }
        function decodeHuffman(tree) {
          var node = tree, bit;
          while ((bit = readBit()) !== null) {
            node = node[bit];
            if (typeof node === "number")
              return node;
            if (typeof node !== "object")
              throw new Error("invalid huffman sequence");
          }
          return null;
        }
        function receive(length) {
          var n2 = 0;
          while (length > 0) {
            var bit = readBit();
            if (bit === null) return;
            n2 = n2 << 1 | bit;
            length--;
          }
          return n2;
        }
        function receiveAndExtend(length) {
          var n2 = receive(length);
          if (n2 >= 1 << length - 1)
            return n2;
          return n2 + (-1 << length) + 1;
        }
        function decodeBaseline(component2, zz) {
          var t = decodeHuffman(component2.huffmanTableDC);
          var diff = t === 0 ? 0 : receiveAndExtend(t);
          zz[0] = component2.pred += diff;
          var k2 = 1;
          while (k2 < 64) {
            var rs = decodeHuffman(component2.huffmanTableAC);
            var s = rs & 15, r = rs >> 4;
            if (s === 0) {
              if (r < 15)
                break;
              k2 += 16;
              continue;
            }
            k2 += r;
            var z = dctZigZag[k2];
            zz[z] = receiveAndExtend(s);
            k2++;
          }
        }
        function decodeDCFirst(component2, zz) {
          var t = decodeHuffman(component2.huffmanTableDC);
          var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
          zz[0] = component2.pred += diff;
        }
        function decodeDCSuccessive(component2, zz) {
          zz[0] |= readBit() << successive;
        }
        var eobrun = 0;
        function decodeACFirst(component2, zz) {
          if (eobrun > 0) {
            eobrun--;
            return;
          }
          var k2 = spectralStart, e = spectralEnd;
          while (k2 <= e) {
            var rs = decodeHuffman(component2.huffmanTableAC);
            var s = rs & 15, r = rs >> 4;
            if (s === 0) {
              if (r < 15) {
                eobrun = receive(r) + (1 << r) - 1;
                break;
              }
              k2 += 16;
              continue;
            }
            k2 += r;
            var z = dctZigZag[k2];
            zz[z] = receiveAndExtend(s) * (1 << successive);
            k2++;
          }
        }
        var successiveACState = 0, successiveACNextValue;
        function decodeACSuccessive(component2, zz) {
          var k2 = spectralStart, e = spectralEnd, r = 0;
          while (k2 <= e) {
            var z = dctZigZag[k2];
            var direction = zz[z] < 0 ? -1 : 1;
            switch (successiveACState) {
              case 0:
                var rs = decodeHuffman(component2.huffmanTableAC);
                var s = rs & 15, r = rs >> 4;
                if (s === 0) {
                  if (r < 15) {
                    eobrun = receive(r) + (1 << r);
                    successiveACState = 4;
                  } else {
                    r = 16;
                    successiveACState = 1;
                  }
                } else {
                  if (s !== 1)
                    throw new Error("invalid ACn encoding");
                  successiveACNextValue = receiveAndExtend(s);
                  successiveACState = r ? 2 : 3;
                }
                continue;
              case 1:
              // skipping r zero items
              case 2:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                else {
                  r--;
                  if (r === 0)
                    successiveACState = successiveACState == 2 ? 3 : 0;
                }
                break;
              case 3:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                else {
                  zz[z] = successiveACNextValue << successive;
                  successiveACState = 0;
                }
                break;
              case 4:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                break;
            }
            k2++;
          }
          if (successiveACState === 4) {
            eobrun--;
            if (eobrun === 0)
              successiveACState = 0;
          }
        }
        function decodeMcu(component2, decode2, mcu2, row, col) {
          var mcuRow = mcu2 / mcusPerLine | 0;
          var mcuCol = mcu2 % mcusPerLine;
          var blockRow = mcuRow * component2.v + row;
          var blockCol = mcuCol * component2.h + col;
          if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
            return;
          decode2(component2, component2.blocks[blockRow][blockCol]);
        }
        function decodeBlock(component2, decode2, mcu2) {
          var blockRow = mcu2 / component2.blocksPerLine | 0;
          var blockCol = mcu2 % component2.blocksPerLine;
          if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
            return;
          decode2(component2, component2.blocks[blockRow][blockCol]);
        }
        var componentsLength = components.length;
        var component, i, j, k, n;
        var decodeFn;
        if (progressive) {
          if (spectralStart === 0)
            decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
          else
            decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
        } else {
          decodeFn = decodeBaseline;
        }
        var mcu = 0, marker;
        var mcuExpected;
        if (componentsLength == 1) {
          mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
        } else {
          mcuExpected = mcusPerLine * frame.mcusPerColumn;
        }
        if (!resetInterval) resetInterval = mcuExpected;
        var h, v;
        while (mcu < mcuExpected) {
          for (i = 0; i < componentsLength; i++)
            components[i].pred = 0;
          eobrun = 0;
          if (componentsLength == 1) {
            component = components[0];
            for (n = 0; n < resetInterval; n++) {
              decodeBlock(component, decodeFn, mcu);
              mcu++;
            }
          } else {
            for (n = 0; n < resetInterval; n++) {
              for (i = 0; i < componentsLength; i++) {
                component = components[i];
                h = component.h;
                v = component.v;
                for (j = 0; j < v; j++) {
                  for (k = 0; k < h; k++) {
                    decodeMcu(component, decodeFn, mcu, j, k);
                  }
                }
              }
              mcu++;
              if (mcu === mcuExpected) break;
            }
          }
          if (mcu === mcuExpected) {
            do {
              if (data2[offset] === 255) {
                if (data2[offset + 1] !== 0) {
                  break;
                }
              }
              offset += 1;
            } while (offset < data2.length - 2);
          }
          bitsCount = 0;
          marker = data2[offset] << 8 | data2[offset + 1];
          if (marker < 65280) {
            throw new Error("marker was not found");
          }
          if (marker >= 65488 && marker <= 65495) {
            offset += 2;
          } else
            break;
        }
        return offset - startOffset;
      }
      function buildComponentData(frame, component) {
        var lines = [];
        var blocksPerLine = component.blocksPerLine;
        var blocksPerColumn = component.blocksPerColumn;
        var samplesPerLine = blocksPerLine << 3;
        var R = new Int32Array(64), r = new Uint8Array(64);
        function quantizeAndInverse(zz, dataOut, dataIn) {
          var qt = component.quantizationTable;
          var v0, v1, v2, v3, v4, v5, v6, v7, t;
          var p = dataIn;
          var i2;
          for (i2 = 0; i2 < 64; i2++)
            p[i2] = zz[i2] * qt[i2];
          for (i2 = 0; i2 < 8; ++i2) {
            var row = 8 * i2;
            if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 && p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 && p[7 + row] == 0) {
              t = dctSqrt2 * p[0 + row] + 512 >> 10;
              p[0 + row] = t;
              p[1 + row] = t;
              p[2 + row] = t;
              p[3 + row] = t;
              p[4 + row] = t;
              p[5 + row] = t;
              p[6 + row] = t;
              p[7 + row] = t;
              continue;
            }
            v0 = dctSqrt2 * p[0 + row] + 128 >> 8;
            v1 = dctSqrt2 * p[4 + row] + 128 >> 8;
            v2 = p[2 + row];
            v3 = p[6 + row];
            v4 = dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128 >> 8;
            v7 = dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128 >> 8;
            v5 = p[3 + row] << 4;
            v6 = p[5 + row] << 4;
            t = v0 - v1 + 1 >> 1;
            v0 = v0 + v1 + 1 >> 1;
            v1 = t;
            t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
            v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
            v3 = t;
            t = v4 - v6 + 1 >> 1;
            v4 = v4 + v6 + 1 >> 1;
            v6 = t;
            t = v7 + v5 + 1 >> 1;
            v5 = v7 - v5 + 1 >> 1;
            v7 = t;
            t = v0 - v3 + 1 >> 1;
            v0 = v0 + v3 + 1 >> 1;
            v3 = t;
            t = v1 - v2 + 1 >> 1;
            v1 = v1 + v2 + 1 >> 1;
            v2 = t;
            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
            v7 = t;
            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
            v6 = t;
            p[0 + row] = v0 + v7;
            p[7 + row] = v0 - v7;
            p[1 + row] = v1 + v6;
            p[6 + row] = v1 - v6;
            p[2 + row] = v2 + v5;
            p[5 + row] = v2 - v5;
            p[3 + row] = v3 + v4;
            p[4 + row] = v3 - v4;
          }
          for (i2 = 0; i2 < 8; ++i2) {
            var col = i2;
            if (p[1 * 8 + col] == 0 && p[2 * 8 + col] == 0 && p[3 * 8 + col] == 0 && p[4 * 8 + col] == 0 && p[5 * 8 + col] == 0 && p[6 * 8 + col] == 0 && p[7 * 8 + col] == 0) {
              t = dctSqrt2 * dataIn[i2 + 0] + 8192 >> 14;
              p[0 * 8 + col] = t;
              p[1 * 8 + col] = t;
              p[2 * 8 + col] = t;
              p[3 * 8 + col] = t;
              p[4 * 8 + col] = t;
              p[5 * 8 + col] = t;
              p[6 * 8 + col] = t;
              p[7 * 8 + col] = t;
              continue;
            }
            v0 = dctSqrt2 * p[0 * 8 + col] + 2048 >> 12;
            v1 = dctSqrt2 * p[4 * 8 + col] + 2048 >> 12;
            v2 = p[2 * 8 + col];
            v3 = p[6 * 8 + col];
            v4 = dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048 >> 12;
            v7 = dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048 >> 12;
            v5 = p[3 * 8 + col];
            v6 = p[5 * 8 + col];
            t = v0 - v1 + 1 >> 1;
            v0 = v0 + v1 + 1 >> 1;
            v1 = t;
            t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
            v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
            v3 = t;
            t = v4 - v6 + 1 >> 1;
            v4 = v4 + v6 + 1 >> 1;
            v6 = t;
            t = v7 + v5 + 1 >> 1;
            v5 = v7 - v5 + 1 >> 1;
            v7 = t;
            t = v0 - v3 + 1 >> 1;
            v0 = v0 + v3 + 1 >> 1;
            v3 = t;
            t = v1 - v2 + 1 >> 1;
            v1 = v1 + v2 + 1 >> 1;
            v2 = t;
            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
            v7 = t;
            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
            v6 = t;
            p[0 * 8 + col] = v0 + v7;
            p[7 * 8 + col] = v0 - v7;
            p[1 * 8 + col] = v1 + v6;
            p[6 * 8 + col] = v1 - v6;
            p[2 * 8 + col] = v2 + v5;
            p[5 * 8 + col] = v2 - v5;
            p[3 * 8 + col] = v3 + v4;
            p[4 * 8 + col] = v3 - v4;
          }
          for (i2 = 0; i2 < 64; ++i2) {
            var sample2 = 128 + (p[i2] + 8 >> 4);
            dataOut[i2] = sample2 < 0 ? 0 : sample2 > 255 ? 255 : sample2;
          }
        }
        requestMemoryAllocation(samplesPerLine * blocksPerColumn * 8);
        var i, j;
        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
          var scanLine = blockRow << 3;
          for (i = 0; i < 8; i++)
            lines.push(new Uint8Array(samplesPerLine));
          for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
            quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);
            var offset = 0, sample = blockCol << 3;
            for (j = 0; j < 8; j++) {
              var line = lines[scanLine + j];
              for (i = 0; i < 8; i++)
                line[sample + i] = r[offset++];
            }
          }
        }
        return lines;
      }
      function clampTo8bit(a) {
        return a < 0 ? 0 : a > 255 ? 255 : a;
      }
      constructor.prototype = {
        load: function load(path) {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", path, true);
          xhr.responseType = "arraybuffer";
          xhr.onload = (function() {
            var data2 = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
            this.parse(data2);
            if (this.onload)
              this.onload();
          }).bind(this);
          xhr.send(null);
        },
        parse: function parse2(data2) {
          var maxResolutionInPixels = this.opts.maxResolutionInMP * 1e3 * 1e3;
          var offset = 0;
          data2.length;
          function readUint16() {
            var value = data2[offset] << 8 | data2[offset + 1];
            offset += 2;
            return value;
          }
          function readDataBlock() {
            var length = readUint16();
            var array = data2.subarray(offset, offset + length - 2);
            offset += array.length;
            return array;
          }
          function prepareComponents(frame2) {
            var maxH = 1, maxV = 1;
            var component2, componentId2;
            for (componentId2 in frame2.components) {
              if (frame2.components.hasOwnProperty(componentId2)) {
                component2 = frame2.components[componentId2];
                if (maxH < component2.h) maxH = component2.h;
                if (maxV < component2.v) maxV = component2.v;
              }
            }
            var mcusPerLine = Math.ceil(frame2.samplesPerLine / 8 / maxH);
            var mcusPerColumn = Math.ceil(frame2.scanLines / 8 / maxV);
            for (componentId2 in frame2.components) {
              if (frame2.components.hasOwnProperty(componentId2)) {
                component2 = frame2.components[componentId2];
                var blocksPerLine = Math.ceil(Math.ceil(frame2.samplesPerLine / 8) * component2.h / maxH);
                var blocksPerColumn = Math.ceil(Math.ceil(frame2.scanLines / 8) * component2.v / maxV);
                var blocksPerLineForMcu = mcusPerLine * component2.h;
                var blocksPerColumnForMcu = mcusPerColumn * component2.v;
                var blocksToAllocate = blocksPerColumnForMcu * blocksPerLineForMcu;
                var blocks = [];
                requestMemoryAllocation(blocksToAllocate * 256);
                for (var i2 = 0; i2 < blocksPerColumnForMcu; i2++) {
                  var row = [];
                  for (var j2 = 0; j2 < blocksPerLineForMcu; j2++)
                    row.push(new Int32Array(64));
                  blocks.push(row);
                }
                component2.blocksPerLine = blocksPerLine;
                component2.blocksPerColumn = blocksPerColumn;
                component2.blocks = blocks;
              }
            }
            frame2.maxH = maxH;
            frame2.maxV = maxV;
            frame2.mcusPerLine = mcusPerLine;
            frame2.mcusPerColumn = mcusPerColumn;
          }
          var jfif = null;
          var adobe = null;
          var frame, resetInterval;
          var quantizationTables = [], frames = [];
          var huffmanTablesAC = [], huffmanTablesDC = [];
          var fileMarker = readUint16();
          var malformedDataOffset = -1;
          this.comments = [];
          if (fileMarker != 65496) {
            throw new Error("SOI not found");
          }
          fileMarker = readUint16();
          while (fileMarker != 65497) {
            var i, j;
            switch (fileMarker) {
              case 65280:
                break;
              case 65504:
              // APP0 (Application Specific)
              case 65505:
              // APP1
              case 65506:
              // APP2
              case 65507:
              // APP3
              case 65508:
              // APP4
              case 65509:
              // APP5
              case 65510:
              // APP6
              case 65511:
              // APP7
              case 65512:
              // APP8
              case 65513:
              // APP9
              case 65514:
              // APP10
              case 65515:
              // APP11
              case 65516:
              // APP12
              case 65517:
              // APP13
              case 65518:
              // APP14
              case 65519:
              // APP15
              case 65534:
                var appData = readDataBlock();
                if (fileMarker === 65534) {
                  var comment2 = String.fromCharCode.apply(null, appData);
                  this.comments.push(comment2);
                }
                if (fileMarker === 65504) {
                  if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
                    jfif = {
                      version: { major: appData[5], minor: appData[6] },
                      densityUnits: appData[7],
                      xDensity: appData[8] << 8 | appData[9],
                      yDensity: appData[10] << 8 | appData[11],
                      thumbWidth: appData[12],
                      thumbHeight: appData[13],
                      thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                    };
                  }
                }
                if (fileMarker === 65505) {
                  if (appData[0] === 69 && appData[1] === 120 && appData[2] === 105 && appData[3] === 102 && appData[4] === 0) {
                    this.exifBuffer = appData.subarray(5, appData.length);
                  }
                }
                if (fileMarker === 65518) {
                  if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101 && appData[5] === 0) {
                    adobe = {
                      version: appData[6],
                      flags0: appData[7] << 8 | appData[8],
                      flags1: appData[9] << 8 | appData[10],
                      transformCode: appData[11]
                    };
                  }
                }
                break;
              case 65499:
                var quantizationTablesLength = readUint16();
                var quantizationTablesEnd = quantizationTablesLength + offset - 2;
                while (offset < quantizationTablesEnd) {
                  var quantizationTableSpec = data2[offset++];
                  requestMemoryAllocation(64 * 4);
                  var tableData = new Int32Array(64);
                  if (quantizationTableSpec >> 4 === 0) {
                    for (j = 0; j < 64; j++) {
                      var z = dctZigZag[j];
                      tableData[z] = data2[offset++];
                    }
                  } else if (quantizationTableSpec >> 4 === 1) {
                    for (j = 0; j < 64; j++) {
                      var z = dctZigZag[j];
                      tableData[z] = readUint16();
                    }
                  } else
                    throw new Error("DQT: invalid table spec");
                  quantizationTables[quantizationTableSpec & 15] = tableData;
                }
                break;
              case 65472:
              // SOF0 (Start of Frame, Baseline DCT)
              case 65473:
              // SOF1 (Start of Frame, Extended DCT)
              case 65474:
                readUint16();
                frame = {};
                frame.extended = fileMarker === 65473;
                frame.progressive = fileMarker === 65474;
                frame.precision = data2[offset++];
                frame.scanLines = readUint16();
                frame.samplesPerLine = readUint16();
                frame.components = {};
                frame.componentsOrder = [];
                var pixelsInFrame = frame.scanLines * frame.samplesPerLine;
                if (pixelsInFrame > maxResolutionInPixels) {
                  var exceededAmount = Math.ceil((pixelsInFrame - maxResolutionInPixels) / 1e6);
                  throw new Error(`maxResolutionInMP limit exceeded by ${exceededAmount}MP`);
                }
                var componentsCount = data2[offset++], componentId;
                for (i = 0; i < componentsCount; i++) {
                  componentId = data2[offset];
                  var h = data2[offset + 1] >> 4;
                  var v = data2[offset + 1] & 15;
                  var qId = data2[offset + 2];
                  if (h <= 0 || v <= 0) {
                    throw new Error("Invalid sampling factor, expected values above 0");
                  }
                  frame.componentsOrder.push(componentId);
                  frame.components[componentId] = {
                    h,
                    v,
                    quantizationIdx: qId
                  };
                  offset += 3;
                }
                prepareComponents(frame);
                frames.push(frame);
                break;
              case 65476:
                var huffmanLength = readUint16();
                for (i = 2; i < huffmanLength; ) {
                  var huffmanTableSpec = data2[offset++];
                  var codeLengths = new Uint8Array(16);
                  var codeLengthSum = 0;
                  for (j = 0; j < 16; j++, offset++) {
                    codeLengthSum += codeLengths[j] = data2[offset];
                  }
                  requestMemoryAllocation(16 + codeLengthSum);
                  var huffmanValues = new Uint8Array(codeLengthSum);
                  for (j = 0; j < codeLengthSum; j++, offset++)
                    huffmanValues[j] = data2[offset];
                  i += 17 + codeLengthSum;
                  (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
                }
                break;
              case 65501:
                readUint16();
                resetInterval = readUint16();
                break;
              case 65500:
                readUint16();
                readUint16();
                break;
              case 65498:
                readUint16();
                var selectorsCount = data2[offset++];
                var components = [], component;
                for (i = 0; i < selectorsCount; i++) {
                  component = frame.components[data2[offset++]];
                  var tableSpec = data2[offset++];
                  component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                  component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                  components.push(component);
                }
                var spectralStart = data2[offset++];
                var spectralEnd = data2[offset++];
                var successiveApproximation = data2[offset++];
                var processed = decodeScan(
                  data2,
                  offset,
                  frame,
                  components,
                  resetInterval,
                  spectralStart,
                  spectralEnd,
                  successiveApproximation >> 4,
                  successiveApproximation & 15,
                  this.opts
                );
                offset += processed;
                break;
              case 65535:
                if (data2[offset] !== 255) {
                  offset--;
                }
                break;
              default:
                if (data2[offset - 3] == 255 && data2[offset - 2] >= 192 && data2[offset - 2] <= 254) {
                  offset -= 3;
                  break;
                } else if (fileMarker === 224 || fileMarker == 225) {
                  if (malformedDataOffset !== -1) {
                    throw new Error(`first unknown JPEG marker at offset ${malformedDataOffset.toString(16)}, second unknown JPEG marker ${fileMarker.toString(16)} at offset ${(offset - 1).toString(16)}`);
                  }
                  malformedDataOffset = offset - 1;
                  const nextOffset = readUint16();
                  if (data2[offset + nextOffset - 2] === 255) {
                    offset += nextOffset - 2;
                    break;
                  }
                }
                throw new Error("unknown JPEG marker " + fileMarker.toString(16));
            }
            fileMarker = readUint16();
          }
          if (frames.length != 1)
            throw new Error("only single frame JPEGs supported");
          for (var i = 0; i < frames.length; i++) {
            var cp = frames[i].components;
            for (var j in cp) {
              cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];
              delete cp[j].quantizationIdx;
            }
          }
          this.width = frame.samplesPerLine;
          this.height = frame.scanLines;
          this.jfif = jfif;
          this.adobe = adobe;
          this.components = [];
          for (var i = 0; i < frame.componentsOrder.length; i++) {
            var component = frame.components[frame.componentsOrder[i]];
            this.components.push({
              lines: buildComponentData(frame, component),
              scaleX: component.h / frame.maxH,
              scaleY: component.v / frame.maxV
            });
          }
        },
        getData: function getData(width, height) {
          var scaleX = this.width / width, scaleY = this.height / height;
          var component1, component2, component3, component4;
          var component1Line, component2Line, component3Line, component4Line;
          var x, y;
          var offset = 0;
          var Y, Cb, Cr, K, C, M, Ye, R, G, B;
          var colorTransform;
          var dataLength = width * height * this.components.length;
          requestMemoryAllocation(dataLength);
          var data2 = new Uint8Array(dataLength);
          switch (this.components.length) {
            case 1:
              component1 = this.components[0];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  data2[offset++] = Y;
                }
              }
              break;
            case 2:
              component1 = this.components[0];
              component2 = this.components[1];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  data2[offset++] = Y;
                  Y = component2Line[0 | x * component2.scaleX * scaleX];
                  data2[offset++] = Y;
                }
              }
              break;
            case 3:
              colorTransform = true;
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.opts.colorTransform !== "undefined")
                colorTransform = !!this.opts.colorTransform;
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  if (!colorTransform) {
                    R = component1Line[0 | x * component1.scaleX * scaleX];
                    G = component2Line[0 | x * component2.scaleX * scaleX];
                    B = component3Line[0 | x * component3.scaleX * scaleX];
                  } else {
                    Y = component1Line[0 | x * component1.scaleX * scaleX];
                    Cb = component2Line[0 | x * component2.scaleX * scaleX];
                    Cr = component3Line[0 | x * component3.scaleX * scaleX];
                    R = clampTo8bit(Y + 1.402 * (Cr - 128));
                    G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    B = clampTo8bit(Y + 1.772 * (Cb - 128));
                  }
                  data2[offset++] = R;
                  data2[offset++] = G;
                  data2[offset++] = B;
                }
              }
              break;
            case 4:
              if (!this.adobe)
                throw new Error("Unsupported color mode (4 components)");
              colorTransform = false;
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.opts.colorTransform !== "undefined")
                colorTransform = !!this.opts.colorTransform;
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              component4 = this.components[3];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                component4Line = component4.lines[0 | y * component4.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  if (!colorTransform) {
                    C = component1Line[0 | x * component1.scaleX * scaleX];
                    M = component2Line[0 | x * component2.scaleX * scaleX];
                    Ye = component3Line[0 | x * component3.scaleX * scaleX];
                    K = component4Line[0 | x * component4.scaleX * scaleX];
                  } else {
                    Y = component1Line[0 | x * component1.scaleX * scaleX];
                    Cb = component2Line[0 | x * component2.scaleX * scaleX];
                    Cr = component3Line[0 | x * component3.scaleX * scaleX];
                    K = component4Line[0 | x * component4.scaleX * scaleX];
                    C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));
                    M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));
                  }
                  data2[offset++] = 255 - C;
                  data2[offset++] = 255 - M;
                  data2[offset++] = 255 - Ye;
                  data2[offset++] = 255 - K;
                }
              }
              break;
            default:
              throw new Error("Unsupported color mode");
          }
          return data2;
        },
        copyToImageData: function copyToImageData(imageData, formatAsRGBA) {
          var width = imageData.width, height = imageData.height;
          var imageDataArray = imageData.data;
          var data2 = this.getData(width, height);
          var i = 0, j = 0, x, y;
          var Y, K, C, M, R, G, B;
          switch (this.components.length) {
            case 1:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  Y = data2[i++];
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = Y;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            case 3:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  R = data2[i++];
                  G = data2[i++];
                  B = data2[i++];
                  imageDataArray[j++] = R;
                  imageDataArray[j++] = G;
                  imageDataArray[j++] = B;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            case 4:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  C = data2[i++];
                  M = data2[i++];
                  Y = data2[i++];
                  K = data2[i++];
                  R = 255 - clampTo8bit(C * (1 - K / 255) + K);
                  G = 255 - clampTo8bit(M * (1 - K / 255) + K);
                  B = 255 - clampTo8bit(Y * (1 - K / 255) + K);
                  imageDataArray[j++] = R;
                  imageDataArray[j++] = G;
                  imageDataArray[j++] = B;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            default:
              throw new Error("Unsupported color mode");
          }
        }
      };
      var totalBytesAllocated = 0;
      var maxMemoryUsageBytes = 0;
      function requestMemoryAllocation(increaseAmount = 0) {
        var totalMemoryImpactBytes = totalBytesAllocated + increaseAmount;
        if (totalMemoryImpactBytes > maxMemoryUsageBytes) {
          var exceededAmount = Math.ceil((totalMemoryImpactBytes - maxMemoryUsageBytes) / 1024 / 1024);
          throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${exceededAmount}MB`);
        }
        totalBytesAllocated = totalMemoryImpactBytes;
      }
      constructor.resetMaxMemoryUsage = function(maxMemoryUsageBytes_) {
        totalBytesAllocated = 0;
        maxMemoryUsageBytes = maxMemoryUsageBytes_;
      };
      constructor.getBytesAllocated = function() {
        return totalBytesAllocated;
      };
      constructor.requestMemoryAllocation = requestMemoryAllocation;
      return constructor;
    })();
    {
      module.exports = decode;
    }
    function decode(jpegData, userOpts = {}) {
      var defaultOpts = {
        // "undefined" means "Choose whether to transform colors based on the imageâ€™s color model."
        colorTransform: void 0,
        useTArray: false,
        formatAsRGBA: true,
        tolerantDecoding: true,
        maxResolutionInMP: 100,
        // Don't decode more than 100 megapixels
        maxMemoryUsageInMB: 512
        // Don't decode if memory footprint is more than 512MB
      };
      var opts = { ...defaultOpts, ...userOpts };
      var arr = new Uint8Array(jpegData);
      var decoder2 = new JpegImage();
      decoder2.opts = opts;
      JpegImage.resetMaxMemoryUsage(opts.maxMemoryUsageInMB * 1024 * 1024);
      decoder2.parse(arr);
      var channels = opts.formatAsRGBA ? 4 : 3;
      var bytesNeeded = decoder2.width * decoder2.height * channels;
      try {
        JpegImage.requestMemoryAllocation(bytesNeeded);
        var image2 = {
          width: decoder2.width,
          height: decoder2.height,
          exifBuffer: decoder2.exifBuffer,
          data: opts.useTArray ? new Uint8Array(bytesNeeded) : Buffer.alloc(bytesNeeded)
        };
        if (decoder2.comments.length > 0) {
          image2["comments"] = decoder2.comments;
        }
      } catch (err) {
        if (err instanceof RangeError) {
          throw new Error("Could not allocate enough memory for the image. Required: " + bytesNeeded);
        }
        if (err instanceof ReferenceError) {
          if (err.message === "Buffer is not defined") {
            throw new Error("Buffer is not globally defined in this environment. Consider setting useTArray to true");
          }
        }
        throw err;
      }
      decoder2.copyToImageData(image2, opts.formatAsRGBA);
      return image2;
    }
  })(decoder);
  return decoder.exports;
}
var jpegJs;
var hasRequiredJpegJs;
function requireJpegJs() {
  if (hasRequiredJpegJs) return jpegJs;
  hasRequiredJpegJs = 1;
  var encode = requireEncoder(), decode = requireDecoder();
  jpegJs = {
    encode,
    decode
  };
  return jpegJs;
}
var uniq;
var hasRequiredUniq;
function requireUniq() {
  if (hasRequiredUniq) return uniq;
  hasRequiredUniq = 1;
  function unique_pred(list, compare) {
    var ptr = 1, len = list.length, a = list[0], b = list[0];
    for (var i = 1; i < len; ++i) {
      b = a;
      a = list[i];
      if (compare(a, b)) {
        if (i === ptr) {
          ptr++;
          continue;
        }
        list[ptr++] = a;
      }
    }
    list.length = ptr;
    return list;
  }
  function unique_eq(list) {
    var ptr = 1, len = list.length, a = list[0], b = list[0];
    for (var i = 1; i < len; ++i, b = a) {
      b = a;
      a = list[i];
      if (a !== b) {
        if (i === ptr) {
          ptr++;
          continue;
        }
        list[ptr++] = a;
      }
    }
    list.length = ptr;
    return list;
  }
  function unique(list, compare, sorted) {
    if (list.length === 0) {
      return list;
    }
    if (compare) {
      if (!sorted) {
        list.sort(compare);
      }
      return unique_pred(list, compare);
    }
    if (!sorted) {
      list.sort();
    }
    return unique_eq(list);
  }
  uniq = unique;
  return uniq;
}
var compile;
var hasRequiredCompile$1;
function requireCompile$1() {
  if (hasRequiredCompile$1) return compile;
  hasRequiredCompile$1 = 1;
  var uniq2 = requireUniq();
  function innerFill(order, proc, body) {
    var dimension = order.length, nargs = proc.arrayArgs.length, has_index = proc.indexArgs.length > 0, code = [], vars = [], idx = 0, pidx = 0, i, j;
    for (i = 0; i < dimension; ++i) {
      vars.push(["i", i, "=0"].join(""));
    }
    for (j = 0; j < nargs; ++j) {
      for (i = 0; i < dimension; ++i) {
        pidx = idx;
        idx = order[i];
        if (i === 0) {
          vars.push(["d", j, "s", i, "=t", j, "p", idx].join(""));
        } else {
          vars.push(["d", j, "s", i, "=(t", j, "p", idx, "-s", pidx, "*t", j, "p", pidx, ")"].join(""));
        }
      }
    }
    if (vars.length > 0) {
      code.push("var " + vars.join(","));
    }
    for (i = dimension - 1; i >= 0; --i) {
      idx = order[i];
      code.push(["for(i", i, "=0;i", i, "<s", idx, ";++i", i, "){"].join(""));
    }
    code.push(body);
    for (i = 0; i < dimension; ++i) {
      pidx = idx;
      idx = order[i];
      for (j = 0; j < nargs; ++j) {
        code.push(["p", j, "+=d", j, "s", i].join(""));
      }
      if (has_index) {
        if (i > 0) {
          code.push(["index[", pidx, "]-=s", pidx].join(""));
        }
        code.push(["++index[", idx, "]"].join(""));
      }
      code.push("}");
    }
    return code.join("\n");
  }
  function outerFill(matched, order, proc, body) {
    var dimension = order.length, nargs = proc.arrayArgs.length, blockSize = proc.blockSize, has_index = proc.indexArgs.length > 0, code = [];
    for (var i = 0; i < nargs; ++i) {
      code.push(["var offset", i, "=p", i].join(""));
    }
    for (var i = matched; i < dimension; ++i) {
      code.push(["for(var j" + i + "=SS[", order[i], "]|0;j", i, ">0;){"].join(""));
      code.push(["if(j", i, "<", blockSize, "){"].join(""));
      code.push(["s", order[i], "=j", i].join(""));
      code.push(["j", i, "=0"].join(""));
      code.push(["}else{s", order[i], "=", blockSize].join(""));
      code.push(["j", i, "-=", blockSize, "}"].join(""));
      if (has_index) {
        code.push(["index[", order[i], "]=j", i].join(""));
      }
    }
    for (var i = 0; i < nargs; ++i) {
      var indexStr = ["offset" + i];
      for (var j = matched; j < dimension; ++j) {
        indexStr.push(["j", j, "*t", i, "p", order[j]].join(""));
      }
      code.push(["p", i, "=(", indexStr.join("+"), ")"].join(""));
    }
    code.push(innerFill(order, proc, body));
    for (var i = matched; i < dimension; ++i) {
      code.push("}");
    }
    return code.join("\n");
  }
  function countMatches(orders) {
    var matched = 0, dimension = orders[0].length;
    while (matched < dimension) {
      for (var j = 1; j < orders.length; ++j) {
        if (orders[j][matched] !== orders[0][matched]) {
          return matched;
        }
      }
      ++matched;
    }
    return matched;
  }
  function processBlock(block, proc, dtypes) {
    var code = block.body;
    var pre = [];
    var post = [];
    for (var i = 0; i < block.args.length; ++i) {
      var carg = block.args[i];
      if (carg.count <= 0) {
        continue;
      }
      var re = new RegExp(carg.name, "g");
      var ptrStr = "";
      var arrNum = proc.arrayArgs.indexOf(i);
      switch (proc.argTypes[i]) {
        case "offset":
          var offArgIndex = proc.offsetArgIndex.indexOf(i);
          var offArg = proc.offsetArgs[offArgIndex];
          arrNum = offArg.array;
          ptrStr = "+q" + offArgIndex;
        // Adds offset to the "pointer" in the array
        case "array":
          ptrStr = "p" + arrNum + ptrStr;
          var localStr = "l" + i;
          var arrStr = "a" + arrNum;
          if (proc.arrayBlockIndices[arrNum] === 0) {
            if (carg.count === 1) {
              if (dtypes[arrNum] === "generic") {
                if (carg.lvalue) {
                  pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join(""));
                  code = code.replace(re, localStr);
                  post.push([arrStr, ".set(", ptrStr, ",", localStr, ")"].join(""));
                } else {
                  code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""));
                }
              } else {
                code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""));
              }
            } else if (dtypes[arrNum] === "generic") {
              pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join(""));
              code = code.replace(re, localStr);
              if (carg.lvalue) {
                post.push([arrStr, ".set(", ptrStr, ",", localStr, ")"].join(""));
              }
            } else {
              pre.push(["var ", localStr, "=", arrStr, "[", ptrStr, "]"].join(""));
              code = code.replace(re, localStr);
              if (carg.lvalue) {
                post.push([arrStr, "[", ptrStr, "]=", localStr].join(""));
              }
            }
          } else {
            var reStrArr = [carg.name], ptrStrArr = [ptrStr];
            for (var j = 0; j < Math.abs(proc.arrayBlockIndices[arrNum]); j++) {
              reStrArr.push("\\s*\\[([^\\]]+)\\]");
              ptrStrArr.push("$" + (j + 1) + "*t" + arrNum + "b" + j);
            }
            re = new RegExp(reStrArr.join(""), "g");
            ptrStr = ptrStrArr.join("+");
            if (dtypes[arrNum] === "generic") {
              throw new Error("cwise: Generic arrays not supported in combination with blocks!");
            } else {
              code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""));
            }
          }
          break;
        case "scalar":
          code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i));
          break;
        case "index":
          code = code.replace(re, "index");
          break;
        case "shape":
          code = code.replace(re, "shape");
          break;
      }
    }
    return [pre.join("\n"), code, post.join("\n")].join("\n").trim();
  }
  function typeSummary(dtypes) {
    var summary = new Array(dtypes.length);
    var allEqual = true;
    for (var i = 0; i < dtypes.length; ++i) {
      var t = dtypes[i];
      var digits = t.match(/\d+/);
      if (!digits) {
        digits = "";
      } else {
        digits = digits[0];
      }
      if (t.charAt(0) === 0) {
        summary[i] = "u" + t.charAt(1) + digits;
      } else {
        summary[i] = t.charAt(0) + digits;
      }
      if (i > 0) {
        allEqual = allEqual && summary[i] === summary[i - 1];
      }
    }
    if (allEqual) {
      return summary[0];
    }
    return summary.join("");
  }
  function generateCWiseOp(proc, typesig) {
    var dimension = typesig[1].length - Math.abs(proc.arrayBlockIndices[0]) | 0;
    var orders = new Array(proc.arrayArgs.length);
    var dtypes = new Array(proc.arrayArgs.length);
    for (var i = 0; i < proc.arrayArgs.length; ++i) {
      dtypes[i] = typesig[2 * i];
      orders[i] = typesig[2 * i + 1];
    }
    var blockBegin = [], blockEnd = [];
    var loopBegin = [], loopEnd = [];
    var loopOrders = [];
    for (var i = 0; i < proc.arrayArgs.length; ++i) {
      if (proc.arrayBlockIndices[i] < 0) {
        loopBegin.push(0);
        loopEnd.push(dimension);
        blockBegin.push(dimension);
        blockEnd.push(dimension + proc.arrayBlockIndices[i]);
      } else {
        loopBegin.push(proc.arrayBlockIndices[i]);
        loopEnd.push(proc.arrayBlockIndices[i] + dimension);
        blockBegin.push(0);
        blockEnd.push(proc.arrayBlockIndices[i]);
      }
      var newOrder = [];
      for (var j = 0; j < orders[i].length; j++) {
        if (loopBegin[i] <= orders[i][j] && orders[i][j] < loopEnd[i]) {
          newOrder.push(orders[i][j] - loopBegin[i]);
        }
      }
      loopOrders.push(newOrder);
    }
    var arglist = ["SS"];
    var code = ["'use strict'"];
    var vars = [];
    for (var j = 0; j < dimension; ++j) {
      vars.push(["s", j, "=SS[", j, "]"].join(""));
    }
    for (var i = 0; i < proc.arrayArgs.length; ++i) {
      arglist.push("a" + i);
      arglist.push("t" + i);
      arglist.push("p" + i);
      for (var j = 0; j < dimension; ++j) {
        vars.push(["t", i, "p", j, "=t", i, "[", loopBegin[i] + j, "]"].join(""));
      }
      for (var j = 0; j < Math.abs(proc.arrayBlockIndices[i]); ++j) {
        vars.push(["t", i, "b", j, "=t", i, "[", blockBegin[i] + j, "]"].join(""));
      }
    }
    for (var i = 0; i < proc.scalarArgs.length; ++i) {
      arglist.push("Y" + i);
    }
    if (proc.shapeArgs.length > 0) {
      vars.push("shape=SS.slice(0)");
    }
    if (proc.indexArgs.length > 0) {
      var zeros = new Array(dimension);
      for (var i = 0; i < dimension; ++i) {
        zeros[i] = "0";
      }
      vars.push(["index=[", zeros.join(","), "]"].join(""));
    }
    for (var i = 0; i < proc.offsetArgs.length; ++i) {
      var off_arg = proc.offsetArgs[i];
      var init_string = [];
      for (var j = 0; j < off_arg.offset.length; ++j) {
        if (off_arg.offset[j] === 0) {
          continue;
        } else if (off_arg.offset[j] === 1) {
          init_string.push(["t", off_arg.array, "p", j].join(""));
        } else {
          init_string.push([off_arg.offset[j], "*t", off_arg.array, "p", j].join(""));
        }
      }
      if (init_string.length === 0) {
        vars.push("q" + i + "=0");
      } else {
        vars.push(["q", i, "=", init_string.join("+")].join(""));
      }
    }
    var thisVars = uniq2([].concat(proc.pre.thisVars).concat(proc.body.thisVars).concat(proc.post.thisVars));
    vars = vars.concat(thisVars);
    if (vars.length > 0) {
      code.push("var " + vars.join(","));
    }
    for (var i = 0; i < proc.arrayArgs.length; ++i) {
      code.push("p" + i + "|=0");
    }
    if (proc.pre.body.length > 3) {
      code.push(processBlock(proc.pre, proc, dtypes));
    }
    var body = processBlock(proc.body, proc, dtypes);
    var matched = countMatches(loopOrders);
    if (matched < dimension) {
      code.push(outerFill(matched, loopOrders[0], proc, body));
    } else {
      code.push(innerFill(loopOrders[0], proc, body));
    }
    if (proc.post.body.length > 3) {
      code.push(processBlock(proc.post, proc, dtypes));
    }
    if (proc.debug) {
      console.log("-----Generated cwise routine for ", typesig, ":\n" + code.join("\n") + "\n----------");
    }
    var loopName = [proc.funcName || "unnamed", "_cwise_loop_", orders[0].join("s"), "m", matched, typeSummary(dtypes)].join("");
    var f = new Function(["function ", loopName, "(", arglist.join(","), "){", code.join("\n"), "} return ", loopName].join(""));
    return f();
  }
  compile = generateCWiseOp;
  return compile;
}
var thunk;
var hasRequiredThunk;
function requireThunk() {
  if (hasRequiredThunk) return thunk;
  hasRequiredThunk = 1;
  var compile2 = requireCompile$1();
  function createThunk(proc) {
    var code = ["'use strict'", "var CACHED={}"];
    var vars = [];
    var thunkName = proc.funcName + "_cwise_thunk";
    code.push(["return function ", thunkName, "(", proc.shimArgs.join(","), "){"].join(""));
    var typesig = [];
    var string_typesig = [];
    var proc_args = [[
      "array",
      proc.arrayArgs[0],
      ".shape.slice(",
      // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).
      Math.max(0, proc.arrayBlockIndices[0]),
      proc.arrayBlockIndices[0] < 0 ? "," + proc.arrayBlockIndices[0] + ")" : ")"
    ].join("")];
    var shapeLengthConditions = [], shapeConditions = [];
    for (var i = 0; i < proc.arrayArgs.length; ++i) {
      var j = proc.arrayArgs[i];
      vars.push([
        "t",
        j,
        "=array",
        j,
        ".dtype,",
        "r",
        j,
        "=array",
        j,
        ".order"
      ].join(""));
      typesig.push("t" + j);
      typesig.push("r" + j);
      string_typesig.push("t" + j);
      string_typesig.push("r" + j + ".join()");
      proc_args.push("array" + j + ".data");
      proc_args.push("array" + j + ".stride");
      proc_args.push("array" + j + ".offset|0");
      if (i > 0) {
        shapeLengthConditions.push("array" + proc.arrayArgs[0] + ".shape.length===array" + j + ".shape.length+" + (Math.abs(proc.arrayBlockIndices[0]) - Math.abs(proc.arrayBlockIndices[i])));
        shapeConditions.push("array" + proc.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0, proc.arrayBlockIndices[0]) + "]===array" + j + ".shape[shapeIndex+" + Math.max(0, proc.arrayBlockIndices[i]) + "]");
      }
    }
    if (proc.arrayArgs.length > 1) {
      code.push("if (!(" + shapeLengthConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')");
      code.push("for(var shapeIndex=array" + proc.arrayArgs[0] + ".shape.length-" + Math.abs(proc.arrayBlockIndices[0]) + "; shapeIndex-->0;) {");
      code.push("if (!(" + shapeConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')");
      code.push("}");
    }
    for (var i = 0; i < proc.scalarArgs.length; ++i) {
      proc_args.push("scalar" + proc.scalarArgs[i]);
    }
    vars.push(["type=[", string_typesig.join(","), "].join()"].join(""));
    vars.push("proc=CACHED[type]");
    code.push("var " + vars.join(","));
    code.push([
      "if(!proc){",
      "CACHED[type]=proc=compile([",
      typesig.join(","),
      "])}",
      "return proc(",
      proc_args.join(","),
      ")}"
    ].join(""));
    if (proc.debug) {
      console.log("-----Generated thunk:\n" + code.join("\n") + "\n----------");
    }
    var thunk2 = new Function("compile", code.join("\n"));
    return thunk2(compile2.bind(void 0, proc));
  }
  thunk = createThunk;
  return thunk;
}
var compiler;
var hasRequiredCompiler;
function requireCompiler() {
  if (hasRequiredCompiler) return compiler;
  hasRequiredCompiler = 1;
  var createThunk = requireThunk();
  function Procedure() {
    this.argTypes = [];
    this.shimArgs = [];
    this.arrayArgs = [];
    this.arrayBlockIndices = [];
    this.scalarArgs = [];
    this.offsetArgs = [];
    this.offsetArgIndex = [];
    this.indexArgs = [];
    this.shapeArgs = [];
    this.funcName = "";
    this.pre = null;
    this.body = null;
    this.post = null;
    this.debug = false;
  }
  function compileCwise(user_args) {
    var proc = new Procedure();
    proc.pre = user_args.pre;
    proc.body = user_args.body;
    proc.post = user_args.post;
    var proc_args = user_args.args.slice(0);
    proc.argTypes = proc_args;
    for (var i = 0; i < proc_args.length; ++i) {
      var arg_type = proc_args[i];
      if (arg_type === "array" || typeof arg_type === "object" && arg_type.blockIndices) {
        proc.argTypes[i] = "array";
        proc.arrayArgs.push(i);
        proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0);
        proc.shimArgs.push("array" + i);
        if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {
          throw new Error("cwise: pre() block may not reference array args");
        }
        if (i < proc.post.args.length && proc.post.args[i].count > 0) {
          throw new Error("cwise: post() block may not reference array args");
        }
      } else if (arg_type === "scalar") {
        proc.scalarArgs.push(i);
        proc.shimArgs.push("scalar" + i);
      } else if (arg_type === "index") {
        proc.indexArgs.push(i);
        if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {
          throw new Error("cwise: pre() block may not reference array index");
        }
        if (i < proc.body.args.length && proc.body.args[i].lvalue) {
          throw new Error("cwise: body() block may not write to array index");
        }
        if (i < proc.post.args.length && proc.post.args[i].count > 0) {
          throw new Error("cwise: post() block may not reference array index");
        }
      } else if (arg_type === "shape") {
        proc.shapeArgs.push(i);
        if (i < proc.pre.args.length && proc.pre.args[i].lvalue) {
          throw new Error("cwise: pre() block may not write to array shape");
        }
        if (i < proc.body.args.length && proc.body.args[i].lvalue) {
          throw new Error("cwise: body() block may not write to array shape");
        }
        if (i < proc.post.args.length && proc.post.args[i].lvalue) {
          throw new Error("cwise: post() block may not write to array shape");
        }
      } else if (typeof arg_type === "object" && arg_type.offset) {
        proc.argTypes[i] = "offset";
        proc.offsetArgs.push({ array: arg_type.array, offset: arg_type.offset });
        proc.offsetArgIndex.push(i);
      } else {
        throw new Error("cwise: Unknown argument type " + proc_args[i]);
      }
    }
    if (proc.arrayArgs.length <= 0) {
      throw new Error("cwise: No array arguments specified");
    }
    if (proc.pre.args.length > proc_args.length) {
      throw new Error("cwise: Too many arguments in pre() block");
    }
    if (proc.body.args.length > proc_args.length) {
      throw new Error("cwise: Too many arguments in body() block");
    }
    if (proc.post.args.length > proc_args.length) {
      throw new Error("cwise: Too many arguments in post() block");
    }
    proc.debug = !!user_args.printCode || !!user_args.debug;
    proc.funcName = user_args.funcName || "cwise";
    proc.blockSize = user_args.blockSize || 64;
    return createThunk(proc);
  }
  compiler = compileCwise;
  return compiler;
}
var doConvert;
var hasRequiredDoConvert;
function requireDoConvert() {
  if (hasRequiredDoConvert) return doConvert;
  hasRequiredDoConvert = 1;
  doConvert = requireCompiler()({ "args": ["array", "scalar", "index"], "pre": { "body": "{}", "args": [], "thisVars": [], "localVars": [] }, "body": { "body": "{\nvar _inline_1_v=_inline_1_arg1_,_inline_1_i\nfor(_inline_1_i=0;_inline_1_i<_inline_1_arg2_.length-1;++_inline_1_i) {\n_inline_1_v=_inline_1_v[_inline_1_arg2_[_inline_1_i]]\n}\n_inline_1_arg0_=_inline_1_v[_inline_1_arg2_[_inline_1_arg2_.length-1]]\n}", "args": [{ "name": "_inline_1_arg0_", "lvalue": true, "rvalue": false, "count": 1 }, { "name": "_inline_1_arg1_", "lvalue": false, "rvalue": true, "count": 1 }, { "name": "_inline_1_arg2_", "lvalue": false, "rvalue": true, "count": 4 }], "thisVars": [], "localVars": ["_inline_1_i", "_inline_1_v"] }, "post": { "body": "{}", "args": [], "thisVars": [], "localVars": [] }, "funcName": "convert", "blockSize": 64 });
  return doConvert;
}
var convert;
var hasRequiredConvert;
function requireConvert() {
  if (hasRequiredConvert) return convert;
  hasRequiredConvert = 1;
  var ndarray2 = requireNdarray();
  var do_convert = requireDoConvert();
  convert = function convert2(arr, result) {
    var shape = [], c = arr, sz = 1;
    while (Array.isArray(c)) {
      shape.push(c.length);
      sz *= c.length;
      c = c[0];
    }
    if (shape.length === 0) {
      return ndarray2();
    }
    if (!result) {
      result = ndarray2(new Float64Array(sz), shape);
    }
    do_convert(result, arr);
    return result;
  };
  return convert;
}
var omggif = {};
var hasRequiredOmggif;
function requireOmggif() {
  if (hasRequiredOmggif) return omggif;
  hasRequiredOmggif = 1;
  function GifWriter(buf, width, height, gopts) {
    var p = 0;
    var gopts = gopts === void 0 ? {} : gopts;
    var loop_count = gopts.loop === void 0 ? null : gopts.loop;
    var global_palette = gopts.palette === void 0 ? null : gopts.palette;
    if (width <= 0 || height <= 0 || width > 65535 || height > 65535)
      throw new Error("Width/Height invalid.");
    function check_palette_and_num_colors(palette) {
      var num_colors = palette.length;
      if (num_colors < 2 || num_colors > 256 || num_colors & num_colors - 1) {
        throw new Error(
          "Invalid code/color length, must be power of 2 and 2 .. 256."
        );
      }
      return num_colors;
    }
    buf[p++] = 71;
    buf[p++] = 73;
    buf[p++] = 70;
    buf[p++] = 56;
    buf[p++] = 57;
    buf[p++] = 97;
    var gp_num_colors_pow2 = 0;
    var background = 0;
    if (global_palette !== null) {
      var gp_num_colors = check_palette_and_num_colors(global_palette);
      while (gp_num_colors >>= 1) ++gp_num_colors_pow2;
      gp_num_colors = 1 << gp_num_colors_pow2;
      --gp_num_colors_pow2;
      if (gopts.background !== void 0) {
        background = gopts.background;
        if (background >= gp_num_colors)
          throw new Error("Background index out of range.");
        if (background === 0)
          throw new Error("Background index explicitly passed as 0.");
      }
    }
    buf[p++] = width & 255;
    buf[p++] = width >> 8 & 255;
    buf[p++] = height & 255;
    buf[p++] = height >> 8 & 255;
    buf[p++] = (global_palette !== null ? 128 : 0) | // Global Color Table Flag.
    gp_num_colors_pow2;
    buf[p++] = background;
    buf[p++] = 0;
    if (global_palette !== null) {
      for (var i = 0, il = global_palette.length; i < il; ++i) {
        var rgb = global_palette[i];
        buf[p++] = rgb >> 16 & 255;
        buf[p++] = rgb >> 8 & 255;
        buf[p++] = rgb & 255;
      }
    }
    if (loop_count !== null) {
      if (loop_count < 0 || loop_count > 65535)
        throw new Error("Loop count invalid.");
      buf[p++] = 33;
      buf[p++] = 255;
      buf[p++] = 11;
      buf[p++] = 78;
      buf[p++] = 69;
      buf[p++] = 84;
      buf[p++] = 83;
      buf[p++] = 67;
      buf[p++] = 65;
      buf[p++] = 80;
      buf[p++] = 69;
      buf[p++] = 50;
      buf[p++] = 46;
      buf[p++] = 48;
      buf[p++] = 3;
      buf[p++] = 1;
      buf[p++] = loop_count & 255;
      buf[p++] = loop_count >> 8 & 255;
      buf[p++] = 0;
    }
    var ended = false;
    this.addFrame = function(x, y, w, h, indexed_pixels, opts) {
      if (ended === true) {
        --p;
        ended = false;
      }
      opts = opts === void 0 ? {} : opts;
      if (x < 0 || y < 0 || x > 65535 || y > 65535)
        throw new Error("x/y invalid.");
      if (w <= 0 || h <= 0 || w > 65535 || h > 65535)
        throw new Error("Width/Height invalid.");
      if (indexed_pixels.length < w * h)
        throw new Error("Not enough pixels for the frame size.");
      var using_local_palette = true;
      var palette = opts.palette;
      if (palette === void 0 || palette === null) {
        using_local_palette = false;
        palette = global_palette;
      }
      if (palette === void 0 || palette === null)
        throw new Error("Must supply either a local or global palette.");
      var num_colors = check_palette_and_num_colors(palette);
      var min_code_size = 0;
      while (num_colors >>= 1) ++min_code_size;
      num_colors = 1 << min_code_size;
      var delay = opts.delay === void 0 ? 0 : opts.delay;
      var disposal = opts.disposal === void 0 ? 0 : opts.disposal;
      if (disposal < 0 || disposal > 3)
        throw new Error("Disposal out of range.");
      var use_transparency = false;
      var transparent_index = 0;
      if (opts.transparent !== void 0 && opts.transparent !== null) {
        use_transparency = true;
        transparent_index = opts.transparent;
        if (transparent_index < 0 || transparent_index >= num_colors)
          throw new Error("Transparent color index.");
      }
      if (disposal !== 0 || use_transparency || delay !== 0) {
        buf[p++] = 33;
        buf[p++] = 249;
        buf[p++] = 4;
        buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);
        buf[p++] = delay & 255;
        buf[p++] = delay >> 8 & 255;
        buf[p++] = transparent_index;
        buf[p++] = 0;
      }
      buf[p++] = 44;
      buf[p++] = x & 255;
      buf[p++] = x >> 8 & 255;
      buf[p++] = y & 255;
      buf[p++] = y >> 8 & 255;
      buf[p++] = w & 255;
      buf[p++] = w >> 8 & 255;
      buf[p++] = h & 255;
      buf[p++] = h >> 8 & 255;
      buf[p++] = using_local_palette === true ? 128 | min_code_size - 1 : 0;
      if (using_local_palette === true) {
        for (var i2 = 0, il2 = palette.length; i2 < il2; ++i2) {
          var rgb2 = palette[i2];
          buf[p++] = rgb2 >> 16 & 255;
          buf[p++] = rgb2 >> 8 & 255;
          buf[p++] = rgb2 & 255;
        }
      }
      p = GifWriterOutputLZWCodeStream(
        buf,
        p,
        min_code_size < 2 ? 2 : min_code_size,
        indexed_pixels
      );
      return p;
    };
    this.end = function() {
      if (ended === false) {
        buf[p++] = 59;
        ended = true;
      }
      return p;
    };
    this.getOutputBuffer = function() {
      return buf;
    };
    this.setOutputBuffer = function(v) {
      buf = v;
    };
    this.getOutputBufferPosition = function() {
      return p;
    };
    this.setOutputBufferPosition = function(v) {
      p = v;
    };
  }
  function GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {
    buf[p++] = min_code_size;
    var cur_subblock = p++;
    var clear_code = 1 << min_code_size;
    var code_mask = clear_code - 1;
    var eoi_code = clear_code + 1;
    var next_code = eoi_code + 1;
    var cur_code_size = min_code_size + 1;
    var cur_shift = 0;
    var cur = 0;
    function emit_bytes_to_buffer(bit_block_size) {
      while (cur_shift >= bit_block_size) {
        buf[p++] = cur & 255;
        cur >>= 8;
        cur_shift -= 8;
        if (p === cur_subblock + 256) {
          buf[cur_subblock] = 255;
          cur_subblock = p++;
        }
      }
    }
    function emit_code(c) {
      cur |= c << cur_shift;
      cur_shift += cur_code_size;
      emit_bytes_to_buffer(8);
    }
    var ib_code = index_stream[0] & code_mask;
    var code_table = {};
    emit_code(clear_code);
    for (var i = 1, il = index_stream.length; i < il; ++i) {
      var k = index_stream[i] & code_mask;
      var cur_key = ib_code << 8 | k;
      var cur_code = code_table[cur_key];
      if (cur_code === void 0) {
        cur |= ib_code << cur_shift;
        cur_shift += cur_code_size;
        while (cur_shift >= 8) {
          buf[p++] = cur & 255;
          cur >>= 8;
          cur_shift -= 8;
          if (p === cur_subblock + 256) {
            buf[cur_subblock] = 255;
            cur_subblock = p++;
          }
        }
        if (next_code === 4096) {
          emit_code(clear_code);
          next_code = eoi_code + 1;
          cur_code_size = min_code_size + 1;
          code_table = {};
        } else {
          if (next_code >= 1 << cur_code_size) ++cur_code_size;
          code_table[cur_key] = next_code++;
        }
        ib_code = k;
      } else {
        ib_code = cur_code;
      }
    }
    emit_code(ib_code);
    emit_code(eoi_code);
    emit_bytes_to_buffer(1);
    if (cur_subblock + 1 === p) {
      buf[cur_subblock] = 0;
    } else {
      buf[cur_subblock] = p - cur_subblock - 1;
      buf[p++] = 0;
    }
    return p;
  }
  function GifReader(buf) {
    var p = 0;
    if (buf[p++] !== 71 || buf[p++] !== 73 || buf[p++] !== 70 || buf[p++] !== 56 || (buf[p++] + 1 & 253) !== 56 || buf[p++] !== 97) {
      throw new Error("Invalid GIF 87a/89a header.");
    }
    var width = buf[p++] | buf[p++] << 8;
    var height = buf[p++] | buf[p++] << 8;
    var pf0 = buf[p++];
    var global_palette_flag = pf0 >> 7;
    var num_global_colors_pow2 = pf0 & 7;
    var num_global_colors = 1 << num_global_colors_pow2 + 1;
    buf[p++];
    buf[p++];
    var global_palette_offset = null;
    var global_palette_size = null;
    if (global_palette_flag) {
      global_palette_offset = p;
      global_palette_size = num_global_colors;
      p += num_global_colors * 3;
    }
    var no_eof = true;
    var frames = [];
    var delay = 0;
    var transparent_index = null;
    var disposal = 0;
    var loop_count = null;
    this.width = width;
    this.height = height;
    while (no_eof && p < buf.length) {
      switch (buf[p++]) {
        case 33:
          switch (buf[p++]) {
            case 255:
              if (buf[p] !== 11 || // 21 FF already read, check block size.
              // NETSCAPE2.0
              buf[p + 1] == 78 && buf[p + 2] == 69 && buf[p + 3] == 84 && buf[p + 4] == 83 && buf[p + 5] == 67 && buf[p + 6] == 65 && buf[p + 7] == 80 && buf[p + 8] == 69 && buf[p + 9] == 50 && buf[p + 10] == 46 && buf[p + 11] == 48 && // Sub-block
              buf[p + 12] == 3 && buf[p + 13] == 1 && buf[p + 16] == 0) {
                p += 14;
                loop_count = buf[p++] | buf[p++] << 8;
                p++;
              } else {
                p += 12;
                while (true) {
                  var block_size = buf[p++];
                  if (!(block_size >= 0)) throw Error("Invalid block size");
                  if (block_size === 0) break;
                  p += block_size;
                }
              }
              break;
            case 249:
              if (buf[p++] !== 4 || buf[p + 4] !== 0)
                throw new Error("Invalid graphics extension block.");
              var pf1 = buf[p++];
              delay = buf[p++] | buf[p++] << 8;
              transparent_index = buf[p++];
              if ((pf1 & 1) === 0) transparent_index = null;
              disposal = pf1 >> 2 & 7;
              p++;
              break;
            case 254:
              while (true) {
                var block_size = buf[p++];
                if (!(block_size >= 0)) throw Error("Invalid block size");
                if (block_size === 0) break;
                p += block_size;
              }
              break;
            default:
              throw new Error(
                "Unknown graphic control label: 0x" + buf[p - 1].toString(16)
              );
          }
          break;
        case 44:
          var x = buf[p++] | buf[p++] << 8;
          var y = buf[p++] | buf[p++] << 8;
          var w = buf[p++] | buf[p++] << 8;
          var h = buf[p++] | buf[p++] << 8;
          var pf2 = buf[p++];
          var local_palette_flag = pf2 >> 7;
          var interlace_flag = pf2 >> 6 & 1;
          var num_local_colors_pow2 = pf2 & 7;
          var num_local_colors = 1 << num_local_colors_pow2 + 1;
          var palette_offset = global_palette_offset;
          var palette_size = global_palette_size;
          var has_local_palette = false;
          if (local_palette_flag) {
            var has_local_palette = true;
            palette_offset = p;
            palette_size = num_local_colors;
            p += num_local_colors * 3;
          }
          var data_offset = p;
          p++;
          while (true) {
            var block_size = buf[p++];
            if (!(block_size >= 0)) throw Error("Invalid block size");
            if (block_size === 0) break;
            p += block_size;
          }
          frames.push({
            x,
            y,
            width: w,
            height: h,
            has_local_palette,
            palette_offset,
            palette_size,
            data_offset,
            data_length: p - data_offset,
            transparent_index,
            interlaced: !!interlace_flag,
            delay,
            disposal
          });
          break;
        case 59:
          no_eof = false;
          break;
        default:
          throw new Error("Unknown gif block: 0x" + buf[p - 1].toString(16));
      }
    }
    this.numFrames = function() {
      return frames.length;
    };
    this.loopCount = function() {
      return loop_count;
    };
    this.frameInfo = function(frame_num) {
      if (frame_num < 0 || frame_num >= frames.length)
        throw new Error("Frame index out of range.");
      return frames[frame_num];
    };
    this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {
      var frame = this.frameInfo(frame_num);
      var num_pixels = frame.width * frame.height;
      var index_stream = new Uint8Array(num_pixels);
      GifReaderLZWOutputIndexStream(
        buf,
        frame.data_offset,
        index_stream,
        num_pixels
      );
      var palette_offset2 = frame.palette_offset;
      var trans = frame.transparent_index;
      if (trans === null) trans = 256;
      var framewidth = frame.width;
      var framestride = width - framewidth;
      var xleft = framewidth;
      var opbeg = (frame.y * width + frame.x) * 4;
      var opend = ((frame.y + frame.height) * width + frame.x) * 4;
      var op = opbeg;
      var scanstride = framestride * 4;
      if (frame.interlaced === true) {
        scanstride += width * 4 * 7;
      }
      var interlaceskip = 8;
      for (var i = 0, il = index_stream.length; i < il; ++i) {
        var index = index_stream[i];
        if (xleft === 0) {
          op += scanstride;
          xleft = framewidth;
          if (op >= opend) {
            scanstride = framestride * 4 + width * 4 * (interlaceskip - 1);
            op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
            interlaceskip >>= 1;
          }
        }
        if (index === trans) {
          op += 4;
        } else {
          var r = buf[palette_offset2 + index * 3];
          var g = buf[palette_offset2 + index * 3 + 1];
          var b = buf[palette_offset2 + index * 3 + 2];
          pixels[op++] = b;
          pixels[op++] = g;
          pixels[op++] = r;
          pixels[op++] = 255;
        }
        --xleft;
      }
    };
    this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {
      var frame = this.frameInfo(frame_num);
      var num_pixels = frame.width * frame.height;
      var index_stream = new Uint8Array(num_pixels);
      GifReaderLZWOutputIndexStream(
        buf,
        frame.data_offset,
        index_stream,
        num_pixels
      );
      var palette_offset2 = frame.palette_offset;
      var trans = frame.transparent_index;
      if (trans === null) trans = 256;
      var framewidth = frame.width;
      var framestride = width - framewidth;
      var xleft = framewidth;
      var opbeg = (frame.y * width + frame.x) * 4;
      var opend = ((frame.y + frame.height) * width + frame.x) * 4;
      var op = opbeg;
      var scanstride = framestride * 4;
      if (frame.interlaced === true) {
        scanstride += width * 4 * 7;
      }
      var interlaceskip = 8;
      for (var i = 0, il = index_stream.length; i < il; ++i) {
        var index = index_stream[i];
        if (xleft === 0) {
          op += scanstride;
          xleft = framewidth;
          if (op >= opend) {
            scanstride = framestride * 4 + width * 4 * (interlaceskip - 1);
            op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
            interlaceskip >>= 1;
          }
        }
        if (index === trans) {
          op += 4;
        } else {
          var r = buf[palette_offset2 + index * 3];
          var g = buf[palette_offset2 + index * 3 + 1];
          var b = buf[palette_offset2 + index * 3 + 2];
          pixels[op++] = r;
          pixels[op++] = g;
          pixels[op++] = b;
          pixels[op++] = 255;
        }
        --xleft;
      }
    };
  }
  function GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {
    var min_code_size = code_stream[p++];
    var clear_code = 1 << min_code_size;
    var eoi_code = clear_code + 1;
    var next_code = eoi_code + 1;
    var cur_code_size = min_code_size + 1;
    var code_mask = (1 << cur_code_size) - 1;
    var cur_shift = 0;
    var cur = 0;
    var op = 0;
    var subblock_size = code_stream[p++];
    var code_table = new Int32Array(4096);
    var prev_code = null;
    while (true) {
      while (cur_shift < 16) {
        if (subblock_size === 0) break;
        cur |= code_stream[p++] << cur_shift;
        cur_shift += 8;
        if (subblock_size === 1) {
          subblock_size = code_stream[p++];
        } else {
          --subblock_size;
        }
      }
      if (cur_shift < cur_code_size)
        break;
      var code = cur & code_mask;
      cur >>= cur_code_size;
      cur_shift -= cur_code_size;
      if (code === clear_code) {
        next_code = eoi_code + 1;
        cur_code_size = min_code_size + 1;
        code_mask = (1 << cur_code_size) - 1;
        prev_code = null;
        continue;
      } else if (code === eoi_code) {
        break;
      }
      var chase_code = code < next_code ? code : prev_code;
      var chase_length = 0;
      var chase = chase_code;
      while (chase > clear_code) {
        chase = code_table[chase] >> 8;
        ++chase_length;
      }
      var k = chase;
      var op_end = op + chase_length + (chase_code !== code ? 1 : 0);
      if (op_end > output_length) {
        console.log("Warning, gif stream longer than expected.");
        return;
      }
      output[op++] = k;
      op += chase_length;
      var b = op;
      if (chase_code !== code)
        output[op++] = k;
      chase = chase_code;
      while (chase_length--) {
        chase = code_table[chase];
        output[--b] = chase & 255;
        chase >>= 8;
      }
      if (prev_code !== null && next_code < 4096) {
        code_table[next_code++] = prev_code << 8 | k;
        if (next_code >= code_mask + 1 && cur_code_size < 12) {
          ++cur_code_size;
          code_mask = code_mask << 1 | 1;
        }
      }
      prev_code = code;
    }
    if (op !== output_length) {
      console.log("Warning, gif stream shorter than expected.");
    }
    return output;
  }
  try {
    omggif.GifWriter = GifWriter;
    omggif.GifReader = GifReader;
  } catch (e) {
  }
  return omggif;
}
var bitmap = { exports: {} };
var hasRequiredBitmap;
function requireBitmap() {
  if (hasRequiredBitmap) return bitmap.exports;
  hasRequiredBitmap = 1;
  (function(module, exports$1) {
    var Bitmap = module.exports = function(buffer) {
      this.buffer = buffer;
      this.initialized = false;
      this.fileHeader = null;
      this.infoHeader = null;
      this.coreHeader = null;
      this.colorPalette = null;
      this.dataPos = -1;
    };
    Bitmap.prototype.CORE_TYPE_WINDOWS_V3 = 40;
    Bitmap.prototype.CORE_TYPE_WINDOWS_V4 = 108;
    Bitmap.prototype.CORE_TYPE_WINDOWS_V5 = 124;
    Bitmap.prototype.CORE_TYPE_OS2_V1 = 12;
    Bitmap.prototype.CORE_TYPE_OS2_V2 = 64;
    Bitmap.prototype.BITMAPCOREHEADER = Bitmap.prototype.CORE_TYPE_OS2_V1;
    Bitmap.prototype.BITMAPINFOHEADER = Bitmap.prototype.CORE_TYPE_WINDOWS_V3;
    Bitmap.prototype.BITMAPINFOHEADER2 = Bitmap.prototype.CORE_TYPE_OS2_V2;
    Bitmap.prototype.BITMAPV4HEADER = Bitmap.prototype.CORE_TYPE_WINDOWS_V4;
    Bitmap.prototype.BITMAPV5HEADER = Bitmap.prototype.CORE_TYPE_WINDOWS_V5;
    Bitmap.prototype.COMPRESSION_BI_RGB = 0;
    Bitmap.prototype.COMPRESSION_BI_RLE8 = 1;
    Bitmap.prototype.COMPRESSION_BI_RLE4 = 2;
    Bitmap.prototype.COMPRESSION_BI_BITFIELDS = 3;
    Bitmap.prototype.COMPRESSION_BI_JPEG = 4;
    Bitmap.prototype.COMPRESSION_BI_PNG = 5;
    Bitmap.prototype.BITCOUNT_2 = 1;
    Bitmap.prototype.BITCOUNT_16 = 4;
    Bitmap.prototype.BITCOUNT_256 = 8;
    Bitmap.prototype.BITCOUNT_16bit = 16;
    Bitmap.prototype.BITCOUNT_24bit = 24;
    Bitmap.prototype.BITCOUNT_32bit = 32;
    Bitmap.prototype.init = function() {
      this.readFileHeader();
      this.readInfoHeader();
      this.readCoreHeader();
      this.readColorPalette();
      this.initDataPos();
      this.initialized = true;
    };
    Bitmap.prototype.checkInit = function() {
      if (!this.initialized) {
        throw new Error("not initialized");
      }
    };
    Bitmap.prototype.isBitmap = function() {
      this.checkInit();
      if ("BM" == this.fileHeader.bfType) {
        return true;
      }
      return false;
    };
    Bitmap.prototype.getData = function() {
      this.checkInit();
      if (this.COMPRESSION_BI_RGB !== this.coreHeader.__copmression__) {
        throw new Error("not supported compression: " + this.coreHeader.__copmression__);
      }
      var bitCount = this.coreHeader.__bitCount__;
      var width = this.getWidth();
      var height = this.getHeight();
      var line = width * bitCount / 8;
      if (0 != line % 4) {
        line = (line / 4 + 1) * 4;
      }
      var rgbaData = [];
      var dataPos = this.dataPos;
      for (var i = 0; i < height; ++i) {
        var pos = dataPos + line * (height - (i + 1));
        var buf = this.buffer.slice(pos, pos + line);
        var color = this.mapColor(buf, bitCount);
        rgbaData.push(color);
      }
      return rgbaData;
    };
    Bitmap.prototype.getWidth = function() {
      this.checkInit();
      return this.coreHeader.__width__;
    };
    Bitmap.prototype.getHeight = function() {
      this.checkInit();
      return this.coreHeader.__height__;
    };
    Bitmap.prototype.read = function(buf, offset, limit) {
      var read = [];
      for (var i = offset, len = offset + limit; i < len; ++i) {
        read.push(buf.readInt8(i));
      }
      return new Buffer(read);
    };
    Bitmap.prototype.readFileHeader = function() {
      var bfType = this.read(this.buffer, 0, 2);
      var bfSize = this.read(this.buffer, 2, 4);
      this.read(this.buffer, 6, 2);
      this.read(this.buffer, 8, 2);
      var bfOffBits = this.read(this.buffer, 10, 4);
      this.fileHeader = {
        bfType: bfType.toString("ascii"),
        _bfType: bfType,
        bfSize: bfSize.readUInt16LE(0),
        _bfSize: bfSize,
        bfReserved1: 0,
        bfReserved2: 0,
        bfOffBits: bfOffBits.readUInt16LE(0),
        _bfOffBits: bfOffBits
      };
    };
    Bitmap.prototype.readInfoHeader = function() {
      this.infoHeader = this.read(this.buffer, 14, 4);
    };
    Bitmap.prototype.readCoreHeader = function() {
      var coreType = this.infoHeader.readUInt16LE(0);
      switch (coreType) {
        case this.BITMAPCOREHEADER:
          return this.readCoreHeaderOS2_V1();
        case this.BITMAPINFOHEADER2:
          return this.readCoreHeaderOS2_V2();
        case this.BITMAPV4HEADER:
          return this.readCoreHeaderWINDOWS_V4();
        case this.BITMAPV5HEADER:
          return this.readCoreHeaderWINDOWS_V5();
        case this.BITMAPINFOHEADER:
          return this.readCoreHeaderWINDOWS_V3();
        default:
          throw new Error("unknown coreType: " + coreType);
      }
    };
    Bitmap.prototype.readCoreHeaderWINDOWS_V3 = function() {
      var biWidth = this.read(this.buffer, 18, 4);
      var biHeight = this.read(this.buffer, 22, 4);
      var biPlanes = this.read(this.buffer, 26, 2);
      var biBitCount = this.read(this.buffer, 28, 2);
      var biCopmression = this.read(this.buffer, 30, 4);
      var biSizeImage = this.read(this.buffer, 34, 4);
      var biXPixPerMeter = this.read(this.buffer, 38, 4);
      var biYPixPerMeter = this.read(this.buffer, 42, 4);
      var biClrUsed = this.read(this.buffer, 46, 4);
      var biCirImportant = this.read(this.buffer, 50, 4);
      this.coreHeader = {
        __copmression__: biCopmression.readUInt16LE(0),
        __bitCount__: biBitCount.readUInt8(0),
        __width__: biWidth.readUInt16LE(0),
        __height__: biHeight.readUInt16LE(0),
        biWidth: biWidth.readUInt16LE(0),
        _biWidth: biWidth,
        biHeight: biHeight.readUInt16LE(0),
        _biHeight: biHeight,
        biPlanes: biPlanes.readUInt8(0),
        _biPlanes: biPlanes,
        biBitCount: biBitCount.readUInt8(0),
        _biBitCount: biBitCount,
        biCopmression: biCopmression.readUInt16LE(0),
        _biCopmression: biCopmression,
        biSizeImage: biSizeImage.readUInt16LE(0),
        _biSizeImage: biSizeImage,
        biXPixPerMeter: biXPixPerMeter.readUInt16LE(0),
        _biXPixPerMeter: biXPixPerMeter,
        biYPixPerMeter: biYPixPerMeter.readUInt16LE(0),
        _biYPixPerMeter: biYPixPerMeter,
        biClrUsed: biClrUsed.readUInt16LE(0),
        _biClrUsed: biClrUsed,
        biCirImportant: biCirImportant.readUInt16LE(0),
        _biCirImportant: biCirImportant
      };
    };
    Bitmap.prototype.readCoreHeaderWINDOWS_V4 = function() {
      throw new Error("not yet impl");
    };
    Bitmap.prototype.readCoreHeaderWINDOWS_V5 = function() {
      throw new Error("not yet impl");
    };
    Bitmap.prototype.readCoreHeaderOS2_V1 = function() {
      throw new Error("not yet impl");
    };
    Bitmap.prototype.readCoreHeaderOS2_V2 = function() {
      throw new Error("not yet impl");
    };
    Bitmap.prototype.readColorPalette = function() {
      var bitCount = this.coreHeader.__bitCount__;
      if (this.BITCOUNT_16bit == bitCount) {
        return;
      }
      if (this.BITCOUNT_24bit == bitCount) {
        return;
      }
      if (this.BITCOUNT_32bit == bitCount) {
        return;
      }
      var coreType = this.infoHeader.readUInt16LE(0);
      switch (coreType) {
        case this.BITMAPCOREHEADER:
          return this.readColorPalette_RGBTRIPLE(bitCount, 26);
        case this.BITMAPINFOHEADER2:
          return this.readColorPalette_RGBTRIPLE(bitCount, 78);
        case this.BITMAPV4HEADER:
          return this.readColorPalette_RGBQUAD(bitCount, 122);
        case this.BITMAPV5HEADER:
          return this.readColorPalette_RGBQUAD(bitCount, 138);
        case this.BITMAPINFOHEADER:
          return this.readColorPalette_RGBQUAD(bitCount, 54);
        default:
          throw new Error("unknown colorPalette: " + coreType + "," + bitCount);
      }
    };
    Bitmap.prototype.readColorPalette_RGBTRIPLE = function(bitCount, startPos) {
      throw new Error("not yet impl");
    };
    Bitmap.prototype.readColorPalette_RGBQUAD = function(bitCount, startPos) {
      if (this.BITCOUNT_2 == bitCount) {
        return this.readRGBQUAD(1 << this.BITCOUNT_2, startPos);
      }
      if (this.BITCOUNT_16 == bitCount) {
        return this.readRGBQUAD(1 << this.BITCOUNT_16, startPos);
      }
      if (this.BITCOUNT_256 == bitCount) {
        return this.readRGBQUAD(1 << this.BITCOUNT_256, startPos);
      }
      throw new Error("unknown bitCount: " + bitCount);
    };
    Bitmap.prototype.readRGBQUAD = function(count, startPos) {
      var palette = [];
      for (var i = startPos, len = startPos + 4 * count; i < len; i += 4) {
        palette.push({
          rgbBlue: this.read(this.buffer, i, 1).readUInt8(0),
          rgbGreen: this.read(this.buffer, i + 1, 1).readUInt8(0),
          rgbRed: this.read(this.buffer, i + 2, 1).readUInt8(0),
          rgbReserved: this.read(this.buffer, i + 3, 1).readUInt8(0)
        });
      }
      this.colorPalette = palette;
    };
    Bitmap.prototype.initDataPos = function() {
      var bitCount = this.coreHeader.__bitCount__;
      var hasPalette = true;
      if (this.BITCOUNT_16bit == bitCount) {
        hasPalette = true;
      }
      if (this.BITCOUNT_24bit == bitCount) {
        hasPalette = true;
      }
      if (this.BITCOUNT_32bit == bitCount) {
        hasPalette = true;
      }
      var coreType = this.infoHeader.readUInt16LE(0);
      switch (coreType) {
        case this.BITMAPCOREHEADER:
          this.dataPos = 26;
          if (hasPalette) {
            this.dataPos = this.dataPos + 3 * (1 << bitCount);
          }
          break;
        case this.BITMAPINFOHEADER2:
          this.dataPos = 78;
          if (hasPalette) {
            this.dataPos = this.dataPos + 3 * (1 << bitCount);
          }
          break;
        case this.BITMAPV4HEADER:
          this.dataPos = 122;
          if (hasPalette) {
            this.dataPos = this.dataPos + 4 * (1 << bitCount);
          }
          break;
        case this.BITMAPV5HEADER:
          this.dataPos = 138;
          if (hasPalette) {
            this.dataPos = this.dataPos + 4 * (1 << bitCount);
          }
        case this.BITMAPINFOHEADER:
          this.dataPos = 54;
          if (hasPalette) {
            this.dataPos = this.dataPos + 4 * (1 << bitCount);
          }
          break;
        default:
          throw new Error("unknown colorPalette: " + coreType + "," + bitCount);
      }
    };
    Bitmap.prototype.mapRGBA = function(r, g, b, a) {
      var hex = [];
      var padHex = function(value) {
        var h = value.toString(16);
        if (value < 15) {
          return "0" + h;
        }
        return h;
      };
      hex.push(padHex(r));
      hex.push(padHex(g));
      hex.push(padHex(b));
      return "#" + hex.join("");
    };
    Bitmap.prototype.mapColor = function(bmpBuf, bitCount) {
      var b, g, r, a;
      var length = bmpBuf.length;
      var colorData = [];
      if (this.BITCOUNT_2 == bitCount) {
        for (var i = 0; i < length; ++i) {
          var paletteValue = bmpBuf[i];
          var bin = paletteValue.toString(2);
          bin = new Array(8 - bin.length).join("0") + bin;
          for (var j = 0; j < bin.length; ++j) {
            var paletteIndex = parseInt(bin.substring(j, j + 1), 10);
            var palette = this.colorPalette[paletteIndex];
            colorData.push(this.mapRGBA(palette.rgbRed, palette.rgbGreen, palette.rgbBlue, -1));
          }
        }
        return colorData;
      }
      if (this.BITCOUNT_16 == bitCount) {
        for (var i = 0; i < length; i += 2) {
          var paletteHigh = bmpBuf.readUInt8(i);
          var paletteLow = bmpBuf.readUInt8(i + 1);
          var indexes = [paletteHigh, paletteLow];
          indexes.forEach(function(paletteIndex2) {
            var palette2 = this.colorPalette[paletteIndex2];
            colorData.push(this.mapRGBA(palette2.rgbRed, palette2.rgbGreen, palette2.rgbBlue, -1));
          });
        }
        return colorData;
      }
      if (this.BITCOUNT_256 == bitCount) {
        for (var i = 0; i < length; ++i) {
          var paletteIndex = bmpBuf.readUInt16LE(i);
          var palette = this.colorPalette[paletteIndex];
          colorData.push(this.mapRGBA(palette.rgbRed, palette.rgbGreen, palette.rgbBlue, -1));
        }
        return colorData;
      }
      if (this.BITCOUNT_16bit == bitCount) {
        for (var i = 0; i < length; i += 3) {
          b = bmpBuf[i];
          g = bmpBuf[i + 1];
          r = bmpBuf[i + 2];
          colorData.push(this.mapRGBA(r, g, b, -1));
        }
        return colorData;
      }
      if (this.BITCOUNT_24bit == bitCount) {
        for (var i = 0; i < length; i += 3) {
          b = bmpBuf[i];
          g = bmpBuf[i + 1];
          r = bmpBuf[i + 2];
          colorData.push(this.mapRGBA(r, g, b, -1));
        }
        return colorData;
      }
      if (this.BITCOUNT_32bit == bitCount) {
        for (var i = 0; i < length; i += 4) {
          b = bmpBuf[i];
          g = bmpBuf[i + 1];
          r = bmpBuf[i + 2];
          a = bmpBuf[i + 3];
          colorData.push(this.mapRGBA(r, g, b, a));
        }
        return colorData;
      }
      throw new Error("unknown bitCount: " + bitCount);
    };
  })(bitmap);
  return bitmap.exports;
}
var nodeBitmap;
var hasRequiredNodeBitmap;
function requireNodeBitmap() {
  if (hasRequiredNodeBitmap) return nodeBitmap;
  hasRequiredNodeBitmap = 1;
  nodeBitmap = requireBitmap();
  return nodeBitmap;
}
var extend;
var hasRequiredExtend;
function requireExtend() {
  if (hasRequiredExtend) return extend;
  hasRequiredExtend = 1;
  var hasOwn = Object.prototype.hasOwnProperty;
  var toStr = Object.prototype.toString;
  var defineProperty = Object.defineProperty;
  var gOPD = Object.getOwnPropertyDescriptor;
  var isArray = function isArray2(arr) {
    if (typeof Array.isArray === "function") {
      return Array.isArray(arr);
    }
    return toStr.call(arr) === "[object Array]";
  };
  var isPlainObject = function isPlainObject2(obj) {
    if (!obj || toStr.call(obj) !== "[object Object]") {
      return false;
    }
    var hasOwnConstructor = hasOwn.call(obj, "constructor");
    var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
    if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
      return false;
    }
    var key2;
    for (key2 in obj) {
    }
    return typeof key2 === "undefined" || hasOwn.call(obj, key2);
  };
  var setProperty = function setProperty2(target, options) {
    if (defineProperty && options.name === "__proto__") {
      defineProperty(target, options.name, {
        enumerable: true,
        configurable: true,
        value: options.newValue,
        writable: true
      });
    } else {
      target[options.name] = options.newValue;
    }
  };
  var getProperty = function getProperty2(obj, name) {
    if (name === "__proto__") {
      if (!hasOwn.call(obj, name)) {
        return void 0;
      } else if (gOPD) {
        return gOPD(obj, name).value;
      }
    }
    return obj[name];
  };
  extend = function extend2() {
    var options, name, src, copy, copyIsArray, clone;
    var target = arguments[0];
    var i = 1;
    var length = arguments.length;
    var deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[1] || {};
      i = 2;
    }
    if (target == null || typeof target !== "object" && typeof target !== "function") {
      target = {};
    }
    for (; i < length; ++i) {
      options = arguments[i];
      if (options != null) {
        for (name in options) {
          src = getProperty(target, name);
          copy = getProperty(options, name);
          if (target !== copy) {
            if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && isArray(src) ? src : [];
              } else {
                clone = src && isPlainObject(src) ? src : {};
              }
              setProperty(target, { name, newValue: extend2(deep, clone, copy) });
            } else if (typeof copy !== "undefined") {
              setProperty(target, { name, newValue: copy });
            }
          }
        }
      }
    }
    return target;
  };
  return extend;
}
var cookies = {};
var cookie = {};
var pubsuffixPsl = {};
var psl = {};
var hasRequiredPsl;
function requirePsl() {
  if (hasRequiredPsl) return psl;
  hasRequiredPsl = 1;
  (function(exports$1) {
    Object.defineProperties(exports$1, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
    function K(e) {
      return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
    }
    var O, F;
    function Q() {
      if (F) return O;
      F = 1;
      const e = 2147483647, s = 36, c = 1, o = 26, t = 38, d = 700, z = 72, y = 128, g = "-", P = /^xn--/, V = /[^\0-\x7F]/, G = /[\x2E\u3002\uFF0E\uFF61]/g, W = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, C = s - c, h = Math.floor, I = String.fromCharCode;
      function v(a) {
        throw new RangeError(W[a]);
      }
      function U(a, i) {
        const m = [];
        let n = a.length;
        for (; n--; ) m[n] = i(a[n]);
        return m;
      }
      function S(a, i) {
        const m = a.split("@");
        let n = "";
        m.length > 1 && (n = m[0] + "@", a = m[1]), a = a.replace(G, ".");
        const r = a.split("."), p = U(r, i).join(".");
        return n + p;
      }
      function L(a) {
        const i = [];
        let m = 0;
        const n = a.length;
        for (; m < n; ) {
          const r = a.charCodeAt(m++);
          if (r >= 55296 && r <= 56319 && m < n) {
            const p = a.charCodeAt(m++);
            (p & 64512) == 56320 ? i.push(((r & 1023) << 10) + (p & 1023) + 65536) : (i.push(r), m--);
          } else i.push(r);
        }
        return i;
      }
      const $ = (a) => String.fromCodePoint(...a), J = function(a) {
        return a >= 48 && a < 58 ? 26 + (a - 48) : a >= 65 && a < 91 ? a - 65 : a >= 97 && a < 123 ? a - 97 : s;
      }, D = function(a, i) {
        return a + 22 + 75 * (a < 26) - ((i != 0) << 5);
      }, T = function(a, i, m) {
        let n = 0;
        for (a = m ? h(a / d) : a >> 1, a += h(a / i); a > C * o >> 1; n += s) a = h(a / C);
        return h(n + (C + 1) * a / (a + t));
      }, E = function(a) {
        const i = [], m = a.length;
        let n = 0, r = y, p = z, j = a.lastIndexOf(g);
        j < 0 && (j = 0);
        for (let u = 0; u < j; ++u) a.charCodeAt(u) >= 128 && v("not-basic"), i.push(a.charCodeAt(u));
        for (let u = j > 0 ? j + 1 : 0; u < m; ) {
          const k = n;
          for (let l = 1, b = s; ; b += s) {
            u >= m && v("invalid-input");
            const w = J(a.charCodeAt(u++));
            w >= s && v("invalid-input"), w > h((e - n) / l) && v("overflow"), n += w * l;
            const x = b <= p ? c : b >= p + o ? o : b - p;
            if (w < x) break;
            const q2 = s - x;
            l > h(e / q2) && v("overflow"), l *= q2;
          }
          const f = i.length + 1;
          p = T(n - k, f, k == 0), h(n / f) > e - r && v("overflow"), r += h(n / f), n %= f, i.splice(n++, 0, r);
        }
        return String.fromCodePoint(...i);
      }, B = function(a) {
        const i = [];
        a = L(a);
        const m = a.length;
        let n = y, r = 0, p = z;
        for (const k of a) k < 128 && i.push(I(k));
        const j = i.length;
        let u = j;
        for (j && i.push(g); u < m; ) {
          let k = e;
          for (const l of a) l >= n && l < k && (k = l);
          const f = u + 1;
          k - n > h((e - r) / f) && v("overflow"), r += (k - n) * f, n = k;
          for (const l of a) if (l < n && ++r > e && v("overflow"), l === n) {
            let b = r;
            for (let w = s; ; w += s) {
              const x = w <= p ? c : w >= p + o ? o : w - p;
              if (b < x) break;
              const q2 = b - x, M = s - x;
              i.push(I(D(x + q2 % M, 0))), b = h(q2 / M);
            }
            i.push(I(D(b, 0))), p = T(r, f, u === j), r = 0, ++u;
          }
          ++r, ++n;
        }
        return i.join("");
      };
      return O = { version: "2.3.1", ucs2: { decode: L, encode: $ }, decode: E, encode: B, toASCII: function(a) {
        return S(a, function(i) {
          return V.test(i) ? "xn--" + B(i) : i;
        });
      }, toUnicode: function(a) {
        return S(a, function(i) {
          return P.test(i) ? E(i.slice(4).toLowerCase()) : i;
        });
      } }, O;
    }
    var X = Q();
    const A = K(X), Y = ["ac", "com.ac", "edu.ac", "gov.ac", "mil.ac", "net.ac", "org.ac", "ad", "ae", "ac.ae", "co.ae", "gov.ae", "mil.ae", "net.ae", "org.ae", "sch.ae", "aero", "airline.aero", "airport.aero", "accident-investigation.aero", "accident-prevention.aero", "aerobatic.aero", "aeroclub.aero", "aerodrome.aero", "agents.aero", "air-surveillance.aero", "air-traffic-control.aero", "aircraft.aero", "airtraffic.aero", "ambulance.aero", "association.aero", "author.aero", "ballooning.aero", "broker.aero", "caa.aero", "cargo.aero", "catering.aero", "certification.aero", "championship.aero", "charter.aero", "civilaviation.aero", "club.aero", "conference.aero", "consultant.aero", "consulting.aero", "control.aero", "council.aero", "crew.aero", "design.aero", "dgca.aero", "educator.aero", "emergency.aero", "engine.aero", "engineer.aero", "entertainment.aero", "equipment.aero", "exchange.aero", "express.aero", "federation.aero", "flight.aero", "freight.aero", "fuel.aero", "gliding.aero", "government.aero", "groundhandling.aero", "group.aero", "hanggliding.aero", "homebuilt.aero", "insurance.aero", "journal.aero", "journalist.aero", "leasing.aero", "logistics.aero", "magazine.aero", "maintenance.aero", "marketplace.aero", "media.aero", "microlight.aero", "modelling.aero", "navigation.aero", "parachuting.aero", "paragliding.aero", "passenger-association.aero", "pilot.aero", "press.aero", "production.aero", "recreation.aero", "repbody.aero", "res.aero", "research.aero", "rotorcraft.aero", "safety.aero", "scientist.aero", "services.aero", "show.aero", "skydiving.aero", "software.aero", "student.aero", "taxi.aero", "trader.aero", "trading.aero", "trainer.aero", "union.aero", "workinggroup.aero", "works.aero", "af", "com.af", "edu.af", "gov.af", "net.af", "org.af", "ag", "co.ag", "com.ag", "net.ag", "nom.ag", "org.ag", "ai", "com.ai", "net.ai", "off.ai", "org.ai", "al", "com.al", "edu.al", "gov.al", "mil.al", "net.al", "org.al", "am", "co.am", "com.am", "commune.am", "net.am", "org.am", "ao", "co.ao", "ed.ao", "edu.ao", "gov.ao", "gv.ao", "it.ao", "og.ao", "org.ao", "pb.ao", "aq", "ar", "bet.ar", "com.ar", "coop.ar", "edu.ar", "gob.ar", "gov.ar", "int.ar", "mil.ar", "musica.ar", "mutual.ar", "net.ar", "org.ar", "senasa.ar", "tur.ar", "arpa", "e164.arpa", "home.arpa", "in-addr.arpa", "ip6.arpa", "iris.arpa", "uri.arpa", "urn.arpa", "as", "gov.as", "asia", "at", "ac.at", "sth.ac.at", "co.at", "gv.at", "or.at", "au", "asn.au", "com.au", "edu.au", "gov.au", "id.au", "net.au", "org.au", "conf.au", "oz.au", "act.au", "nsw.au", "nt.au", "qld.au", "sa.au", "tas.au", "vic.au", "wa.au", "act.edu.au", "catholic.edu.au", "nsw.edu.au", "nt.edu.au", "qld.edu.au", "sa.edu.au", "tas.edu.au", "vic.edu.au", "wa.edu.au", "qld.gov.au", "sa.gov.au", "tas.gov.au", "vic.gov.au", "wa.gov.au", "schools.nsw.edu.au", "aw", "com.aw", "ax", "az", "biz.az", "com.az", "edu.az", "gov.az", "info.az", "int.az", "mil.az", "name.az", "net.az", "org.az", "pp.az", "pro.az", "ba", "com.ba", "edu.ba", "gov.ba", "mil.ba", "net.ba", "org.ba", "bb", "biz.bb", "co.bb", "com.bb", "edu.bb", "gov.bb", "info.bb", "net.bb", "org.bb", "store.bb", "tv.bb", "*.bd", "be", "ac.be", "bf", "gov.bf", "bg", "0.bg", "1.bg", "2.bg", "3.bg", "4.bg", "5.bg", "6.bg", "7.bg", "8.bg", "9.bg", "a.bg", "b.bg", "c.bg", "d.bg", "e.bg", "f.bg", "g.bg", "h.bg", "i.bg", "j.bg", "k.bg", "l.bg", "m.bg", "n.bg", "o.bg", "p.bg", "q.bg", "r.bg", "s.bg", "t.bg", "u.bg", "v.bg", "w.bg", "x.bg", "y.bg", "z.bg", "bh", "com.bh", "edu.bh", "gov.bh", "net.bh", "org.bh", "bi", "co.bi", "com.bi", "edu.bi", "or.bi", "org.bi", "biz", "bj", "africa.bj", "agro.bj", "architectes.bj", "assur.bj", "avocats.bj", "co.bj", "com.bj", "eco.bj", "econo.bj", "edu.bj", "info.bj", "loisirs.bj", "money.bj", "net.bj", "org.bj", "ote.bj", "restaurant.bj", "resto.bj", "tourism.bj", "univ.bj", "bm", "com.bm", "edu.bm", "gov.bm", "net.bm", "org.bm", "bn", "com.bn", "edu.bn", "gov.bn", "net.bn", "org.bn", "bo", "com.bo", "edu.bo", "gob.bo", "int.bo", "mil.bo", "net.bo", "org.bo", "tv.bo", "web.bo", "academia.bo", "agro.bo", "arte.bo", "blog.bo", "bolivia.bo", "ciencia.bo", "cooperativa.bo", "democracia.bo", "deporte.bo", "ecologia.bo", "economia.bo", "empresa.bo", "indigena.bo", "industria.bo", "info.bo", "medicina.bo", "movimiento.bo", "musica.bo", "natural.bo", "nombre.bo", "noticias.bo", "patria.bo", "plurinacional.bo", "politica.bo", "profesional.bo", "pueblo.bo", "revista.bo", "salud.bo", "tecnologia.bo", "tksat.bo", "transporte.bo", "wiki.bo", "br", "9guacu.br", "abc.br", "adm.br", "adv.br", "agr.br", "aju.br", "am.br", "anani.br", "aparecida.br", "app.br", "arq.br", "art.br", "ato.br", "b.br", "barueri.br", "belem.br", "bet.br", "bhz.br", "bib.br", "bio.br", "blog.br", "bmd.br", "boavista.br", "bsb.br", "campinagrande.br", "campinas.br", "caxias.br", "cim.br", "cng.br", "cnt.br", "com.br", "contagem.br", "coop.br", "coz.br", "cri.br", "cuiaba.br", "curitiba.br", "def.br", "des.br", "det.br", "dev.br", "ecn.br", "eco.br", "edu.br", "emp.br", "enf.br", "eng.br", "esp.br", "etc.br", "eti.br", "far.br", "feira.br", "flog.br", "floripa.br", "fm.br", "fnd.br", "fortal.br", "fot.br", "foz.br", "fst.br", "g12.br", "geo.br", "ggf.br", "goiania.br", "gov.br", "ac.gov.br", "al.gov.br", "am.gov.br", "ap.gov.br", "ba.gov.br", "ce.gov.br", "df.gov.br", "es.gov.br", "go.gov.br", "ma.gov.br", "mg.gov.br", "ms.gov.br", "mt.gov.br", "pa.gov.br", "pb.gov.br", "pe.gov.br", "pi.gov.br", "pr.gov.br", "rj.gov.br", "rn.gov.br", "ro.gov.br", "rr.gov.br", "rs.gov.br", "sc.gov.br", "se.gov.br", "sp.gov.br", "to.gov.br", "gru.br", "imb.br", "ind.br", "inf.br", "jab.br", "jampa.br", "jdf.br", "joinville.br", "jor.br", "jus.br", "leg.br", "leilao.br", "lel.br", "log.br", "londrina.br", "macapa.br", "maceio.br", "manaus.br", "maringa.br", "mat.br", "med.br", "mil.br", "morena.br", "mp.br", "mus.br", "natal.br", "net.br", "niteroi.br", "*.nom.br", "not.br", "ntr.br", "odo.br", "ong.br", "org.br", "osasco.br", "palmas.br", "poa.br", "ppg.br", "pro.br", "psc.br", "psi.br", "pvh.br", "qsl.br", "radio.br", "rec.br", "recife.br", "rep.br", "ribeirao.br", "rio.br", "riobranco.br", "riopreto.br", "salvador.br", "sampa.br", "santamaria.br", "santoandre.br", "saobernardo.br", "saogonca.br", "seg.br", "sjc.br", "slg.br", "slz.br", "sorocaba.br", "srv.br", "taxi.br", "tc.br", "tec.br", "teo.br", "the.br", "tmp.br", "trd.br", "tur.br", "tv.br", "udi.br", "vet.br", "vix.br", "vlog.br", "wiki.br", "zlg.br", "bs", "com.bs", "edu.bs", "gov.bs", "net.bs", "org.bs", "bt", "com.bt", "edu.bt", "gov.bt", "net.bt", "org.bt", "bv", "bw", "co.bw", "org.bw", "by", "gov.by", "mil.by", "com.by", "of.by", "bz", "co.bz", "com.bz", "edu.bz", "gov.bz", "net.bz", "org.bz", "ca", "ab.ca", "bc.ca", "mb.ca", "nb.ca", "nf.ca", "nl.ca", "ns.ca", "nt.ca", "nu.ca", "on.ca", "pe.ca", "qc.ca", "sk.ca", "yk.ca", "gc.ca", "cat", "cc", "cd", "gov.cd", "cf", "cg", "ch", "ci", "ac.ci", "aÃ©roport.ci", "asso.ci", "co.ci", "com.ci", "ed.ci", "edu.ci", "go.ci", "gouv.ci", "int.ci", "net.ci", "or.ci", "org.ci", "*.ck", "!www.ck", "cl", "co.cl", "gob.cl", "gov.cl", "mil.cl", "cm", "co.cm", "com.cm", "gov.cm", "net.cm", "cn", "ac.cn", "com.cn", "edu.cn", "gov.cn", "mil.cn", "net.cn", "org.cn", "å…¬å¸.cn", "ç¶²çµ¡.cn", "ç½‘ç»œ.cn", "ah.cn", "bj.cn", "cq.cn", "fj.cn", "gd.cn", "gs.cn", "gx.cn", "gz.cn", "ha.cn", "hb.cn", "he.cn", "hi.cn", "hk.cn", "hl.cn", "hn.cn", "jl.cn", "js.cn", "jx.cn", "ln.cn", "mo.cn", "nm.cn", "nx.cn", "qh.cn", "sc.cn", "sd.cn", "sh.cn", "sn.cn", "sx.cn", "tj.cn", "tw.cn", "xj.cn", "xz.cn", "yn.cn", "zj.cn", "co", "com.co", "edu.co", "gov.co", "mil.co", "net.co", "nom.co", "org.co", "com", "coop", "cr", "ac.cr", "co.cr", "ed.cr", "fi.cr", "go.cr", "or.cr", "sa.cr", "cu", "com.cu", "edu.cu", "gob.cu", "inf.cu", "nat.cu", "net.cu", "org.cu", "cv", "com.cv", "edu.cv", "id.cv", "int.cv", "net.cv", "nome.cv", "org.cv", "publ.cv", "cw", "com.cw", "edu.cw", "net.cw", "org.cw", "cx", "gov.cx", "cy", "ac.cy", "biz.cy", "com.cy", "ekloges.cy", "gov.cy", "ltd.cy", "mil.cy", "net.cy", "org.cy", "press.cy", "pro.cy", "tm.cy", "cz", "de", "dj", "dk", "dm", "co.dm", "com.dm", "edu.dm", "gov.dm", "net.dm", "org.dm", "do", "art.do", "com.do", "edu.do", "gob.do", "gov.do", "mil.do", "net.do", "org.do", "sld.do", "web.do", "dz", "art.dz", "asso.dz", "com.dz", "edu.dz", "gov.dz", "net.dz", "org.dz", "pol.dz", "soc.dz", "tm.dz", "ec", "com.ec", "edu.ec", "fin.ec", "gob.ec", "gov.ec", "info.ec", "k12.ec", "med.ec", "mil.ec", "net.ec", "org.ec", "pro.ec", "edu", "ee", "aip.ee", "com.ee", "edu.ee", "fie.ee", "gov.ee", "lib.ee", "med.ee", "org.ee", "pri.ee", "riik.ee", "eg", "ac.eg", "com.eg", "edu.eg", "eun.eg", "gov.eg", "info.eg", "me.eg", "mil.eg", "name.eg", "net.eg", "org.eg", "sci.eg", "sport.eg", "tv.eg", "*.er", "es", "com.es", "edu.es", "gob.es", "nom.es", "org.es", "et", "biz.et", "com.et", "edu.et", "gov.et", "info.et", "name.et", "net.et", "org.et", "eu", "fi", "aland.fi", "fj", "ac.fj", "biz.fj", "com.fj", "gov.fj", "info.fj", "mil.fj", "name.fj", "net.fj", "org.fj", "pro.fj", "*.fk", "fm", "com.fm", "edu.fm", "net.fm", "org.fm", "fo", "fr", "asso.fr", "com.fr", "gouv.fr", "nom.fr", "prd.fr", "tm.fr", "avoues.fr", "cci.fr", "greta.fr", "huissier-justice.fr", "ga", "gb", "gd", "edu.gd", "gov.gd", "ge", "com.ge", "edu.ge", "gov.ge", "net.ge", "org.ge", "pvt.ge", "school.ge", "gf", "gg", "co.gg", "net.gg", "org.gg", "gh", "com.gh", "edu.gh", "gov.gh", "mil.gh", "org.gh", "gi", "com.gi", "edu.gi", "gov.gi", "ltd.gi", "mod.gi", "org.gi", "gl", "co.gl", "com.gl", "edu.gl", "net.gl", "org.gl", "gm", "gn", "ac.gn", "com.gn", "edu.gn", "gov.gn", "net.gn", "org.gn", "gov", "gp", "asso.gp", "com.gp", "edu.gp", "mobi.gp", "net.gp", "org.gp", "gq", "gr", "com.gr", "edu.gr", "gov.gr", "net.gr", "org.gr", "gs", "gt", "com.gt", "edu.gt", "gob.gt", "ind.gt", "mil.gt", "net.gt", "org.gt", "gu", "com.gu", "edu.gu", "gov.gu", "guam.gu", "info.gu", "net.gu", "org.gu", "web.gu", "gw", "gy", "co.gy", "com.gy", "edu.gy", "gov.gy", "net.gy", "org.gy", "hk", "com.hk", "edu.hk", "gov.hk", "idv.hk", "net.hk", "org.hk", "ä¸ªäºº.hk", "å€‹äºº.hk", "å…¬å¸.hk", "æ”¿åºœ.hk", "æ•Žè‚².hk", "æ•™è‚².hk", "ç®‡äºº.hk", "çµ„ç¹”.hk", "çµ„ç»‡.hk", "ç¶²çµ¡.hk", "ç¶²ç»œ.hk", "ç»„ç¹”.hk", "ç»„ç»‡.hk", "ç½‘çµ¡.hk", "ç½‘ç»œ.hk", "hm", "hn", "com.hn", "edu.hn", "gob.hn", "mil.hn", "net.hn", "org.hn", "hr", "com.hr", "from.hr", "iz.hr", "name.hr", "ht", "adult.ht", "art.ht", "asso.ht", "com.ht", "coop.ht", "edu.ht", "firm.ht", "gouv.ht", "info.ht", "med.ht", "net.ht", "org.ht", "perso.ht", "pol.ht", "pro.ht", "rel.ht", "shop.ht", "hu", "2000.hu", "agrar.hu", "bolt.hu", "casino.hu", "city.hu", "co.hu", "erotica.hu", "erotika.hu", "film.hu", "forum.hu", "games.hu", "hotel.hu", "info.hu", "ingatlan.hu", "jogasz.hu", "konyvelo.hu", "lakas.hu", "media.hu", "news.hu", "org.hu", "priv.hu", "reklam.hu", "sex.hu", "shop.hu", "sport.hu", "suli.hu", "szex.hu", "tm.hu", "tozsde.hu", "utazas.hu", "video.hu", "id", "ac.id", "biz.id", "co.id", "desa.id", "go.id", "mil.id", "my.id", "net.id", "or.id", "ponpes.id", "sch.id", "web.id", "ie", "gov.ie", "il", "ac.il", "co.il", "gov.il", "idf.il", "k12.il", "muni.il", "net.il", "org.il", "×™×©×¨××œ", "××§×“×ž×™×”.×™×©×¨××œ", "×™×©×•×‘.×™×©×¨××œ", "×¦×”×œ.×™×©×¨××œ", "×ž×ž×©×œ.×™×©×¨××œ", "im", "ac.im", "co.im", "ltd.co.im", "plc.co.im", "com.im", "net.im", "org.im", "tt.im", "tv.im", "in", "5g.in", "6g.in", "ac.in", "ai.in", "am.in", "bihar.in", "biz.in", "business.in", "ca.in", "cn.in", "co.in", "com.in", "coop.in", "cs.in", "delhi.in", "dr.in", "edu.in", "er.in", "firm.in", "gen.in", "gov.in", "gujarat.in", "ind.in", "info.in", "int.in", "internet.in", "io.in", "me.in", "mil.in", "net.in", "nic.in", "org.in", "pg.in", "post.in", "pro.in", "res.in", "travel.in", "tv.in", "uk.in", "up.in", "us.in", "info", "int", "eu.int", "io", "co.io", "com.io", "edu.io", "gov.io", "mil.io", "net.io", "nom.io", "org.io", "iq", "com.iq", "edu.iq", "gov.iq", "mil.iq", "net.iq", "org.iq", "ir", "ac.ir", "co.ir", "gov.ir", "id.ir", "net.ir", "org.ir", "sch.ir", "Ø§ÛŒØ±Ø§Ù†.ir", "Ø§ÙŠØ±Ø§Ù†.ir", "is", "it", "edu.it", "gov.it", "abr.it", "abruzzo.it", "aosta-valley.it", "aostavalley.it", "bas.it", "basilicata.it", "cal.it", "calabria.it", "cam.it", "campania.it", "emilia-romagna.it", "emiliaromagna.it", "emr.it", "friuli-v-giulia.it", "friuli-ve-giulia.it", "friuli-vegiulia.it", "friuli-venezia-giulia.it", "friuli-veneziagiulia.it", "friuli-vgiulia.it", "friuliv-giulia.it", "friulive-giulia.it", "friulivegiulia.it", "friulivenezia-giulia.it", "friuliveneziagiulia.it", "friulivgiulia.it", "fvg.it", "laz.it", "lazio.it", "lig.it", "liguria.it", "lom.it", "lombardia.it", "lombardy.it", "lucania.it", "mar.it", "marche.it", "mol.it", "molise.it", "piedmont.it", "piemonte.it", "pmn.it", "pug.it", "puglia.it", "sar.it", "sardegna.it", "sardinia.it", "sic.it", "sicilia.it", "sicily.it", "taa.it", "tos.it", "toscana.it", "trentin-sud-tirol.it", "trentin-sÃ¼d-tirol.it", "trentin-sudtirol.it", "trentin-sÃ¼dtirol.it", "trentin-sued-tirol.it", "trentin-suedtirol.it", "trentino.it", "trentino-a-adige.it", "trentino-aadige.it", "trentino-alto-adige.it", "trentino-altoadige.it", "trentino-s-tirol.it", "trentino-stirol.it", "trentino-sud-tirol.it", "trentino-sÃ¼d-tirol.it", "trentino-sudtirol.it", "trentino-sÃ¼dtirol.it", "trentino-sued-tirol.it", "trentino-suedtirol.it", "trentinoa-adige.it", "trentinoaadige.it", "trentinoalto-adige.it", "trentinoaltoadige.it", "trentinos-tirol.it", "trentinostirol.it", "trentinosud-tirol.it", "trentinosÃ¼d-tirol.it", "trentinosudtirol.it", "trentinosÃ¼dtirol.it", "trentinosued-tirol.it", "trentinosuedtirol.it", "trentinsud-tirol.it", "trentinsÃ¼d-tirol.it", "trentinsudtirol.it", "trentinsÃ¼dtirol.it", "trentinsued-tirol.it", "trentinsuedtirol.it", "tuscany.it", "umb.it", "umbria.it", "val-d-aosta.it", "val-daosta.it", "vald-aosta.it", "valdaosta.it", "valle-aosta.it", "valle-d-aosta.it", "valle-daosta.it", "valleaosta.it", "valled-aosta.it", "valledaosta.it", "vallee-aoste.it", "vallÃ©e-aoste.it", "vallee-d-aoste.it", "vallÃ©e-d-aoste.it", "valleeaoste.it", "vallÃ©eaoste.it", "valleedaoste.it", "vallÃ©edaoste.it", "vao.it", "vda.it", "ven.it", "veneto.it", "ag.it", "agrigento.it", "al.it", "alessandria.it", "alto-adige.it", "altoadige.it", "an.it", "ancona.it", "andria-barletta-trani.it", "andria-trani-barletta.it", "andriabarlettatrani.it", "andriatranibarletta.it", "ao.it", "aosta.it", "aoste.it", "ap.it", "aq.it", "aquila.it", "ar.it", "arezzo.it", "ascoli-piceno.it", "ascolipiceno.it", "asti.it", "at.it", "av.it", "avellino.it", "ba.it", "balsan.it", "balsan-sudtirol.it", "balsan-sÃ¼dtirol.it", "balsan-suedtirol.it", "bari.it", "barletta-trani-andria.it", "barlettatraniandria.it", "belluno.it", "benevento.it", "bergamo.it", "bg.it", "bi.it", "biella.it", "bl.it", "bn.it", "bo.it", "bologna.it", "bolzano.it", "bolzano-altoadige.it", "bozen.it", "bozen-sudtirol.it", "bozen-sÃ¼dtirol.it", "bozen-suedtirol.it", "br.it", "brescia.it", "brindisi.it", "bs.it", "bt.it", "bulsan.it", "bulsan-sudtirol.it", "bulsan-sÃ¼dtirol.it", "bulsan-suedtirol.it", "bz.it", "ca.it", "cagliari.it", "caltanissetta.it", "campidano-medio.it", "campidanomedio.it", "campobasso.it", "carbonia-iglesias.it", "carboniaiglesias.it", "carrara-massa.it", "carraramassa.it", "caserta.it", "catania.it", "catanzaro.it", "cb.it", "ce.it", "cesena-forli.it", "cesena-forlÃ¬.it", "cesenaforli.it", "cesenaforlÃ¬.it", "ch.it", "chieti.it", "ci.it", "cl.it", "cn.it", "co.it", "como.it", "cosenza.it", "cr.it", "cremona.it", "crotone.it", "cs.it", "ct.it", "cuneo.it", "cz.it", "dell-ogliastra.it", "dellogliastra.it", "en.it", "enna.it", "fc.it", "fe.it", "fermo.it", "ferrara.it", "fg.it", "fi.it", "firenze.it", "florence.it", "fm.it", "foggia.it", "forli-cesena.it", "forlÃ¬-cesena.it", "forlicesena.it", "forlÃ¬cesena.it", "fr.it", "frosinone.it", "ge.it", "genoa.it", "genova.it", "go.it", "gorizia.it", "gr.it", "grosseto.it", "iglesias-carbonia.it", "iglesiascarbonia.it", "im.it", "imperia.it", "is.it", "isernia.it", "kr.it", "la-spezia.it", "laquila.it", "laspezia.it", "latina.it", "lc.it", "le.it", "lecce.it", "lecco.it", "li.it", "livorno.it", "lo.it", "lodi.it", "lt.it", "lu.it", "lucca.it", "macerata.it", "mantova.it", "massa-carrara.it", "massacarrara.it", "matera.it", "mb.it", "mc.it", "me.it", "medio-campidano.it", "mediocampidano.it", "messina.it", "mi.it", "milan.it", "milano.it", "mn.it", "mo.it", "modena.it", "monza.it", "monza-brianza.it", "monza-e-della-brianza.it", "monzabrianza.it", "monzaebrianza.it", "monzaedellabrianza.it", "ms.it", "mt.it", "na.it", "naples.it", "napoli.it", "no.it", "novara.it", "nu.it", "nuoro.it", "og.it", "ogliastra.it", "olbia-tempio.it", "olbiatempio.it", "or.it", "oristano.it", "ot.it", "pa.it", "padova.it", "padua.it", "palermo.it", "parma.it", "pavia.it", "pc.it", "pd.it", "pe.it", "perugia.it", "pesaro-urbino.it", "pesarourbino.it", "pescara.it", "pg.it", "pi.it", "piacenza.it", "pisa.it", "pistoia.it", "pn.it", "po.it", "pordenone.it", "potenza.it", "pr.it", "prato.it", "pt.it", "pu.it", "pv.it", "pz.it", "ra.it", "ragusa.it", "ravenna.it", "rc.it", "re.it", "reggio-calabria.it", "reggio-emilia.it", "reggiocalabria.it", "reggioemilia.it", "rg.it", "ri.it", "rieti.it", "rimini.it", "rm.it", "rn.it", "ro.it", "roma.it", "rome.it", "rovigo.it", "sa.it", "salerno.it", "sassari.it", "savona.it", "si.it", "siena.it", "siracusa.it", "so.it", "sondrio.it", "sp.it", "sr.it", "ss.it", "sÃ¼dtirol.it", "suedtirol.it", "sv.it", "ta.it", "taranto.it", "te.it", "tempio-olbia.it", "tempioolbia.it", "teramo.it", "terni.it", "tn.it", "to.it", "torino.it", "tp.it", "tr.it", "trani-andria-barletta.it", "trani-barletta-andria.it", "traniandriabarletta.it", "tranibarlettaandria.it", "trapani.it", "trento.it", "treviso.it", "trieste.it", "ts.it", "turin.it", "tv.it", "ud.it", "udine.it", "urbino-pesaro.it", "urbinopesaro.it", "va.it", "varese.it", "vb.it", "vc.it", "ve.it", "venezia.it", "venice.it", "verbania.it", "vercelli.it", "verona.it", "vi.it", "vibo-valentia.it", "vibovalentia.it", "vicenza.it", "viterbo.it", "vr.it", "vs.it", "vt.it", "vv.it", "je", "co.je", "net.je", "org.je", "*.jm", "jo", "agri.jo", "ai.jo", "com.jo", "edu.jo", "eng.jo", "fm.jo", "gov.jo", "mil.jo", "net.jo", "org.jo", "per.jo", "phd.jo", "sch.jo", "tv.jo", "jobs", "jp", "ac.jp", "ad.jp", "co.jp", "ed.jp", "go.jp", "gr.jp", "lg.jp", "ne.jp", "or.jp", "aichi.jp", "akita.jp", "aomori.jp", "chiba.jp", "ehime.jp", "fukui.jp", "fukuoka.jp", "fukushima.jp", "gifu.jp", "gunma.jp", "hiroshima.jp", "hokkaido.jp", "hyogo.jp", "ibaraki.jp", "ishikawa.jp", "iwate.jp", "kagawa.jp", "kagoshima.jp", "kanagawa.jp", "kochi.jp", "kumamoto.jp", "kyoto.jp", "mie.jp", "miyagi.jp", "miyazaki.jp", "nagano.jp", "nagasaki.jp", "nara.jp", "niigata.jp", "oita.jp", "okayama.jp", "okinawa.jp", "osaka.jp", "saga.jp", "saitama.jp", "shiga.jp", "shimane.jp", "shizuoka.jp", "tochigi.jp", "tokushima.jp", "tokyo.jp", "tottori.jp", "toyama.jp", "wakayama.jp", "yamagata.jp", "yamaguchi.jp", "yamanashi.jp", "ä¸‰é‡.jp", "äº¬éƒ½.jp", "ä½è³€.jp", "å…µåº«.jp", "åŒ—æµ·é“.jp", "åƒè‘‰.jp", "å’Œæ­Œå±±.jp", "åŸ¼çŽ‰.jp", "å¤§åˆ†.jp", "å¤§é˜ª.jp", "å¥ˆè‰¯.jp", "å®®åŸŽ.jp", "å®®å´Ž.jp", "å¯Œå±±.jp", "å±±å£.jp", "å±±å½¢.jp", "å±±æ¢¨.jp", "å²é˜œ.jp", "å²¡å±±.jp", "å²©æ‰‹.jp", "å³¶æ ¹.jp", "åºƒå³¶.jp", "å¾³å³¶.jp", "æ„›åª›.jp", "æ„›çŸ¥.jp", "æ–°æ½Ÿ.jp", "æ±äº¬.jp", "æ ƒæœ¨.jp", "æ²–ç¸„.jp", "æ»‹è³€.jp", "ç†Šæœ¬.jp", "çŸ³å·.jp", "ç¥žå¥ˆå·.jp", "ç¦äº•.jp", "ç¦å²¡.jp", "ç¦å³¶.jp", "ç§‹ç”°.jp", "ç¾¤é¦¬.jp", "èŒ¨åŸŽ.jp", "é•·å´Ž.jp", "é•·é‡Ž.jp", "é’æ£®.jp", "é™å²¡.jp", "é¦™å·.jp", "é«˜çŸ¥.jp", "é³¥å–.jp", "é¹¿å…å³¶.jp", "*.kawasaki.jp", "!city.kawasaki.jp", "*.kitakyushu.jp", "!city.kitakyushu.jp", "*.kobe.jp", "!city.kobe.jp", "*.nagoya.jp", "!city.nagoya.jp", "*.sapporo.jp", "!city.sapporo.jp", "*.sendai.jp", "!city.sendai.jp", "*.yokohama.jp", "!city.yokohama.jp", "aisai.aichi.jp", "ama.aichi.jp", "anjo.aichi.jp", "asuke.aichi.jp", "chiryu.aichi.jp", "chita.aichi.jp", "fuso.aichi.jp", "gamagori.aichi.jp", "handa.aichi.jp", "hazu.aichi.jp", "hekinan.aichi.jp", "higashiura.aichi.jp", "ichinomiya.aichi.jp", "inazawa.aichi.jp", "inuyama.aichi.jp", "isshiki.aichi.jp", "iwakura.aichi.jp", "kanie.aichi.jp", "kariya.aichi.jp", "kasugai.aichi.jp", "kira.aichi.jp", "kiyosu.aichi.jp", "komaki.aichi.jp", "konan.aichi.jp", "kota.aichi.jp", "mihama.aichi.jp", "miyoshi.aichi.jp", "nishio.aichi.jp", "nisshin.aichi.jp", "obu.aichi.jp", "oguchi.aichi.jp", "oharu.aichi.jp", "okazaki.aichi.jp", "owariasahi.aichi.jp", "seto.aichi.jp", "shikatsu.aichi.jp", "shinshiro.aichi.jp", "shitara.aichi.jp", "tahara.aichi.jp", "takahama.aichi.jp", "tobishima.aichi.jp", "toei.aichi.jp", "togo.aichi.jp", "tokai.aichi.jp", "tokoname.aichi.jp", "toyoake.aichi.jp", "toyohashi.aichi.jp", "toyokawa.aichi.jp", "toyone.aichi.jp", "toyota.aichi.jp", "tsushima.aichi.jp", "yatomi.aichi.jp", "akita.akita.jp", "daisen.akita.jp", "fujisato.akita.jp", "gojome.akita.jp", "hachirogata.akita.jp", "happou.akita.jp", "higashinaruse.akita.jp", "honjo.akita.jp", "honjyo.akita.jp", "ikawa.akita.jp", "kamikoani.akita.jp", "kamioka.akita.jp", "katagami.akita.jp", "kazuno.akita.jp", "kitaakita.akita.jp", "kosaka.akita.jp", "kyowa.akita.jp", "misato.akita.jp", "mitane.akita.jp", "moriyoshi.akita.jp", "nikaho.akita.jp", "noshiro.akita.jp", "odate.akita.jp", "oga.akita.jp", "ogata.akita.jp", "semboku.akita.jp", "yokote.akita.jp", "yurihonjo.akita.jp", "aomori.aomori.jp", "gonohe.aomori.jp", "hachinohe.aomori.jp", "hashikami.aomori.jp", "hiranai.aomori.jp", "hirosaki.aomori.jp", "itayanagi.aomori.jp", "kuroishi.aomori.jp", "misawa.aomori.jp", "mutsu.aomori.jp", "nakadomari.aomori.jp", "noheji.aomori.jp", "oirase.aomori.jp", "owani.aomori.jp", "rokunohe.aomori.jp", "sannohe.aomori.jp", "shichinohe.aomori.jp", "shingo.aomori.jp", "takko.aomori.jp", "towada.aomori.jp", "tsugaru.aomori.jp", "tsuruta.aomori.jp", "abiko.chiba.jp", "asahi.chiba.jp", "chonan.chiba.jp", "chosei.chiba.jp", "choshi.chiba.jp", "chuo.chiba.jp", "funabashi.chiba.jp", "futtsu.chiba.jp", "hanamigawa.chiba.jp", "ichihara.chiba.jp", "ichikawa.chiba.jp", "ichinomiya.chiba.jp", "inzai.chiba.jp", "isumi.chiba.jp", "kamagaya.chiba.jp", "kamogawa.chiba.jp", "kashiwa.chiba.jp", "katori.chiba.jp", "katsuura.chiba.jp", "kimitsu.chiba.jp", "kisarazu.chiba.jp", "kozaki.chiba.jp", "kujukuri.chiba.jp", "kyonan.chiba.jp", "matsudo.chiba.jp", "midori.chiba.jp", "mihama.chiba.jp", "minamiboso.chiba.jp", "mobara.chiba.jp", "mutsuzawa.chiba.jp", "nagara.chiba.jp", "nagareyama.chiba.jp", "narashino.chiba.jp", "narita.chiba.jp", "noda.chiba.jp", "oamishirasato.chiba.jp", "omigawa.chiba.jp", "onjuku.chiba.jp", "otaki.chiba.jp", "sakae.chiba.jp", "sakura.chiba.jp", "shimofusa.chiba.jp", "shirako.chiba.jp", "shiroi.chiba.jp", "shisui.chiba.jp", "sodegaura.chiba.jp", "sosa.chiba.jp", "tako.chiba.jp", "tateyama.chiba.jp", "togane.chiba.jp", "tohnosho.chiba.jp", "tomisato.chiba.jp", "urayasu.chiba.jp", "yachimata.chiba.jp", "yachiyo.chiba.jp", "yokaichiba.chiba.jp", "yokoshibahikari.chiba.jp", "yotsukaido.chiba.jp", "ainan.ehime.jp", "honai.ehime.jp", "ikata.ehime.jp", "imabari.ehime.jp", "iyo.ehime.jp", "kamijima.ehime.jp", "kihoku.ehime.jp", "kumakogen.ehime.jp", "masaki.ehime.jp", "matsuno.ehime.jp", "matsuyama.ehime.jp", "namikata.ehime.jp", "niihama.ehime.jp", "ozu.ehime.jp", "saijo.ehime.jp", "seiyo.ehime.jp", "shikokuchuo.ehime.jp", "tobe.ehime.jp", "toon.ehime.jp", "uchiko.ehime.jp", "uwajima.ehime.jp", "yawatahama.ehime.jp", "echizen.fukui.jp", "eiheiji.fukui.jp", "fukui.fukui.jp", "ikeda.fukui.jp", "katsuyama.fukui.jp", "mihama.fukui.jp", "minamiechizen.fukui.jp", "obama.fukui.jp", "ohi.fukui.jp", "ono.fukui.jp", "sabae.fukui.jp", "sakai.fukui.jp", "takahama.fukui.jp", "tsuruga.fukui.jp", "wakasa.fukui.jp", "ashiya.fukuoka.jp", "buzen.fukuoka.jp", "chikugo.fukuoka.jp", "chikuho.fukuoka.jp", "chikujo.fukuoka.jp", "chikushino.fukuoka.jp", "chikuzen.fukuoka.jp", "chuo.fukuoka.jp", "dazaifu.fukuoka.jp", "fukuchi.fukuoka.jp", "hakata.fukuoka.jp", "higashi.fukuoka.jp", "hirokawa.fukuoka.jp", "hisayama.fukuoka.jp", "iizuka.fukuoka.jp", "inatsuki.fukuoka.jp", "kaho.fukuoka.jp", "kasuga.fukuoka.jp", "kasuya.fukuoka.jp", "kawara.fukuoka.jp", "keisen.fukuoka.jp", "koga.fukuoka.jp", "kurate.fukuoka.jp", "kurogi.fukuoka.jp", "kurume.fukuoka.jp", "minami.fukuoka.jp", "miyako.fukuoka.jp", "miyama.fukuoka.jp", "miyawaka.fukuoka.jp", "mizumaki.fukuoka.jp", "munakata.fukuoka.jp", "nakagawa.fukuoka.jp", "nakama.fukuoka.jp", "nishi.fukuoka.jp", "nogata.fukuoka.jp", "ogori.fukuoka.jp", "okagaki.fukuoka.jp", "okawa.fukuoka.jp", "oki.fukuoka.jp", "omuta.fukuoka.jp", "onga.fukuoka.jp", "onojo.fukuoka.jp", "oto.fukuoka.jp", "saigawa.fukuoka.jp", "sasaguri.fukuoka.jp", "shingu.fukuoka.jp", "shinyoshitomi.fukuoka.jp", "shonai.fukuoka.jp", "soeda.fukuoka.jp", "sue.fukuoka.jp", "tachiarai.fukuoka.jp", "tagawa.fukuoka.jp", "takata.fukuoka.jp", "toho.fukuoka.jp", "toyotsu.fukuoka.jp", "tsuiki.fukuoka.jp", "ukiha.fukuoka.jp", "umi.fukuoka.jp", "usui.fukuoka.jp", "yamada.fukuoka.jp", "yame.fukuoka.jp", "yanagawa.fukuoka.jp", "yukuhashi.fukuoka.jp", "aizubange.fukushima.jp", "aizumisato.fukushima.jp", "aizuwakamatsu.fukushima.jp", "asakawa.fukushima.jp", "bandai.fukushima.jp", "date.fukushima.jp", "fukushima.fukushima.jp", "furudono.fukushima.jp", "futaba.fukushima.jp", "hanawa.fukushima.jp", "higashi.fukushima.jp", "hirata.fukushima.jp", "hirono.fukushima.jp", "iitate.fukushima.jp", "inawashiro.fukushima.jp", "ishikawa.fukushima.jp", "iwaki.fukushima.jp", "izumizaki.fukushima.jp", "kagamiishi.fukushima.jp", "kaneyama.fukushima.jp", "kawamata.fukushima.jp", "kitakata.fukushima.jp", "kitashiobara.fukushima.jp", "koori.fukushima.jp", "koriyama.fukushima.jp", "kunimi.fukushima.jp", "miharu.fukushima.jp", "mishima.fukushima.jp", "namie.fukushima.jp", "nango.fukushima.jp", "nishiaizu.fukushima.jp", "nishigo.fukushima.jp", "okuma.fukushima.jp", "omotego.fukushima.jp", "ono.fukushima.jp", "otama.fukushima.jp", "samegawa.fukushima.jp", "shimogo.fukushima.jp", "shirakawa.fukushima.jp", "showa.fukushima.jp", "soma.fukushima.jp", "sukagawa.fukushima.jp", "taishin.fukushima.jp", "tamakawa.fukushima.jp", "tanagura.fukushima.jp", "tenei.fukushima.jp", "yabuki.fukushima.jp", "yamato.fukushima.jp", "yamatsuri.fukushima.jp", "yanaizu.fukushima.jp", "yugawa.fukushima.jp", "anpachi.gifu.jp", "ena.gifu.jp", "gifu.gifu.jp", "ginan.gifu.jp", "godo.gifu.jp", "gujo.gifu.jp", "hashima.gifu.jp", "hichiso.gifu.jp", "hida.gifu.jp", "higashishirakawa.gifu.jp", "ibigawa.gifu.jp", "ikeda.gifu.jp", "kakamigahara.gifu.jp", "kani.gifu.jp", "kasahara.gifu.jp", "kasamatsu.gifu.jp", "kawaue.gifu.jp", "kitagata.gifu.jp", "mino.gifu.jp", "minokamo.gifu.jp", "mitake.gifu.jp", "mizunami.gifu.jp", "motosu.gifu.jp", "nakatsugawa.gifu.jp", "ogaki.gifu.jp", "sakahogi.gifu.jp", "seki.gifu.jp", "sekigahara.gifu.jp", "shirakawa.gifu.jp", "tajimi.gifu.jp", "takayama.gifu.jp", "tarui.gifu.jp", "toki.gifu.jp", "tomika.gifu.jp", "wanouchi.gifu.jp", "yamagata.gifu.jp", "yaotsu.gifu.jp", "yoro.gifu.jp", "annaka.gunma.jp", "chiyoda.gunma.jp", "fujioka.gunma.jp", "higashiagatsuma.gunma.jp", "isesaki.gunma.jp", "itakura.gunma.jp", "kanna.gunma.jp", "kanra.gunma.jp", "katashina.gunma.jp", "kawaba.gunma.jp", "kiryu.gunma.jp", "kusatsu.gunma.jp", "maebashi.gunma.jp", "meiwa.gunma.jp", "midori.gunma.jp", "minakami.gunma.jp", "naganohara.gunma.jp", "nakanojo.gunma.jp", "nanmoku.gunma.jp", "numata.gunma.jp", "oizumi.gunma.jp", "ora.gunma.jp", "ota.gunma.jp", "shibukawa.gunma.jp", "shimonita.gunma.jp", "shinto.gunma.jp", "showa.gunma.jp", "takasaki.gunma.jp", "takayama.gunma.jp", "tamamura.gunma.jp", "tatebayashi.gunma.jp", "tomioka.gunma.jp", "tsukiyono.gunma.jp", "tsumagoi.gunma.jp", "ueno.gunma.jp", "yoshioka.gunma.jp", "asaminami.hiroshima.jp", "daiwa.hiroshima.jp", "etajima.hiroshima.jp", "fuchu.hiroshima.jp", "fukuyama.hiroshima.jp", "hatsukaichi.hiroshima.jp", "higashihiroshima.hiroshima.jp", "hongo.hiroshima.jp", "jinsekikogen.hiroshima.jp", "kaita.hiroshima.jp", "kui.hiroshima.jp", "kumano.hiroshima.jp", "kure.hiroshima.jp", "mihara.hiroshima.jp", "miyoshi.hiroshima.jp", "naka.hiroshima.jp", "onomichi.hiroshima.jp", "osakikamijima.hiroshima.jp", "otake.hiroshima.jp", "saka.hiroshima.jp", "sera.hiroshima.jp", "seranishi.hiroshima.jp", "shinichi.hiroshima.jp", "shobara.hiroshima.jp", "takehara.hiroshima.jp", "abashiri.hokkaido.jp", "abira.hokkaido.jp", "aibetsu.hokkaido.jp", "akabira.hokkaido.jp", "akkeshi.hokkaido.jp", "asahikawa.hokkaido.jp", "ashibetsu.hokkaido.jp", "ashoro.hokkaido.jp", "assabu.hokkaido.jp", "atsuma.hokkaido.jp", "bibai.hokkaido.jp", "biei.hokkaido.jp", "bifuka.hokkaido.jp", "bihoro.hokkaido.jp", "biratori.hokkaido.jp", "chippubetsu.hokkaido.jp", "chitose.hokkaido.jp", "date.hokkaido.jp", "ebetsu.hokkaido.jp", "embetsu.hokkaido.jp", "eniwa.hokkaido.jp", "erimo.hokkaido.jp", "esan.hokkaido.jp", "esashi.hokkaido.jp", "fukagawa.hokkaido.jp", "fukushima.hokkaido.jp", "furano.hokkaido.jp", "furubira.hokkaido.jp", "haboro.hokkaido.jp", "hakodate.hokkaido.jp", "hamatonbetsu.hokkaido.jp", "hidaka.hokkaido.jp", "higashikagura.hokkaido.jp", "higashikawa.hokkaido.jp", "hiroo.hokkaido.jp", "hokuryu.hokkaido.jp", "hokuto.hokkaido.jp", "honbetsu.hokkaido.jp", "horokanai.hokkaido.jp", "horonobe.hokkaido.jp", "ikeda.hokkaido.jp", "imakane.hokkaido.jp", "ishikari.hokkaido.jp", "iwamizawa.hokkaido.jp", "iwanai.hokkaido.jp", "kamifurano.hokkaido.jp", "kamikawa.hokkaido.jp", "kamishihoro.hokkaido.jp", "kamisunagawa.hokkaido.jp", "kamoenai.hokkaido.jp", "kayabe.hokkaido.jp", "kembuchi.hokkaido.jp", "kikonai.hokkaido.jp", "kimobetsu.hokkaido.jp", "kitahiroshima.hokkaido.jp", "kitami.hokkaido.jp", "kiyosato.hokkaido.jp", "koshimizu.hokkaido.jp", "kunneppu.hokkaido.jp", "kuriyama.hokkaido.jp", "kuromatsunai.hokkaido.jp", "kushiro.hokkaido.jp", "kutchan.hokkaido.jp", "kyowa.hokkaido.jp", "mashike.hokkaido.jp", "matsumae.hokkaido.jp", "mikasa.hokkaido.jp", "minamifurano.hokkaido.jp", "mombetsu.hokkaido.jp", "moseushi.hokkaido.jp", "mukawa.hokkaido.jp", "muroran.hokkaido.jp", "naie.hokkaido.jp", "nakagawa.hokkaido.jp", "nakasatsunai.hokkaido.jp", "nakatombetsu.hokkaido.jp", "nanae.hokkaido.jp", "nanporo.hokkaido.jp", "nayoro.hokkaido.jp", "nemuro.hokkaido.jp", "niikappu.hokkaido.jp", "niki.hokkaido.jp", "nishiokoppe.hokkaido.jp", "noboribetsu.hokkaido.jp", "numata.hokkaido.jp", "obihiro.hokkaido.jp", "obira.hokkaido.jp", "oketo.hokkaido.jp", "okoppe.hokkaido.jp", "otaru.hokkaido.jp", "otobe.hokkaido.jp", "otofuke.hokkaido.jp", "otoineppu.hokkaido.jp", "oumu.hokkaido.jp", "ozora.hokkaido.jp", "pippu.hokkaido.jp", "rankoshi.hokkaido.jp", "rebun.hokkaido.jp", "rikubetsu.hokkaido.jp", "rishiri.hokkaido.jp", "rishirifuji.hokkaido.jp", "saroma.hokkaido.jp", "sarufutsu.hokkaido.jp", "shakotan.hokkaido.jp", "shari.hokkaido.jp", "shibecha.hokkaido.jp", "shibetsu.hokkaido.jp", "shikabe.hokkaido.jp", "shikaoi.hokkaido.jp", "shimamaki.hokkaido.jp", "shimizu.hokkaido.jp", "shimokawa.hokkaido.jp", "shinshinotsu.hokkaido.jp", "shintoku.hokkaido.jp", "shiranuka.hokkaido.jp", "shiraoi.hokkaido.jp", "shiriuchi.hokkaido.jp", "sobetsu.hokkaido.jp", "sunagawa.hokkaido.jp", "taiki.hokkaido.jp", "takasu.hokkaido.jp", "takikawa.hokkaido.jp", "takinoue.hokkaido.jp", "teshikaga.hokkaido.jp", "tobetsu.hokkaido.jp", "tohma.hokkaido.jp", "tomakomai.hokkaido.jp", "tomari.hokkaido.jp", "toya.hokkaido.jp", "toyako.hokkaido.jp", "toyotomi.hokkaido.jp", "toyoura.hokkaido.jp", "tsubetsu.hokkaido.jp", "tsukigata.hokkaido.jp", "urakawa.hokkaido.jp", "urausu.hokkaido.jp", "uryu.hokkaido.jp", "utashinai.hokkaido.jp", "wakkanai.hokkaido.jp", "wassamu.hokkaido.jp", "yakumo.hokkaido.jp", "yoichi.hokkaido.jp", "aioi.hyogo.jp", "akashi.hyogo.jp", "ako.hyogo.jp", "amagasaki.hyogo.jp", "aogaki.hyogo.jp", "asago.hyogo.jp", "ashiya.hyogo.jp", "awaji.hyogo.jp", "fukusaki.hyogo.jp", "goshiki.hyogo.jp", "harima.hyogo.jp", "himeji.hyogo.jp", "ichikawa.hyogo.jp", "inagawa.hyogo.jp", "itami.hyogo.jp", "kakogawa.hyogo.jp", "kamigori.hyogo.jp", "kamikawa.hyogo.jp", "kasai.hyogo.jp", "kasuga.hyogo.jp", "kawanishi.hyogo.jp", "miki.hyogo.jp", "minamiawaji.hyogo.jp", "nishinomiya.hyogo.jp", "nishiwaki.hyogo.jp", "ono.hyogo.jp", "sanda.hyogo.jp", "sannan.hyogo.jp", "sasayama.hyogo.jp", "sayo.hyogo.jp", "shingu.hyogo.jp", "shinonsen.hyogo.jp", "shiso.hyogo.jp", "sumoto.hyogo.jp", "taishi.hyogo.jp", "taka.hyogo.jp", "takarazuka.hyogo.jp", "takasago.hyogo.jp", "takino.hyogo.jp", "tamba.hyogo.jp", "tatsuno.hyogo.jp", "toyooka.hyogo.jp", "yabu.hyogo.jp", "yashiro.hyogo.jp", "yoka.hyogo.jp", "yokawa.hyogo.jp", "ami.ibaraki.jp", "asahi.ibaraki.jp", "bando.ibaraki.jp", "chikusei.ibaraki.jp", "daigo.ibaraki.jp", "fujishiro.ibaraki.jp", "hitachi.ibaraki.jp", "hitachinaka.ibaraki.jp", "hitachiomiya.ibaraki.jp", "hitachiota.ibaraki.jp", "ibaraki.ibaraki.jp", "ina.ibaraki.jp", "inashiki.ibaraki.jp", "itako.ibaraki.jp", "iwama.ibaraki.jp", "joso.ibaraki.jp", "kamisu.ibaraki.jp", "kasama.ibaraki.jp", "kashima.ibaraki.jp", "kasumigaura.ibaraki.jp", "koga.ibaraki.jp", "miho.ibaraki.jp", "mito.ibaraki.jp", "moriya.ibaraki.jp", "naka.ibaraki.jp", "namegata.ibaraki.jp", "oarai.ibaraki.jp", "ogawa.ibaraki.jp", "omitama.ibaraki.jp", "ryugasaki.ibaraki.jp", "sakai.ibaraki.jp", "sakuragawa.ibaraki.jp", "shimodate.ibaraki.jp", "shimotsuma.ibaraki.jp", "shirosato.ibaraki.jp", "sowa.ibaraki.jp", "suifu.ibaraki.jp", "takahagi.ibaraki.jp", "tamatsukuri.ibaraki.jp", "tokai.ibaraki.jp", "tomobe.ibaraki.jp", "tone.ibaraki.jp", "toride.ibaraki.jp", "tsuchiura.ibaraki.jp", "tsukuba.ibaraki.jp", "uchihara.ibaraki.jp", "ushiku.ibaraki.jp", "yachiyo.ibaraki.jp", "yamagata.ibaraki.jp", "yawara.ibaraki.jp", "yuki.ibaraki.jp", "anamizu.ishikawa.jp", "hakui.ishikawa.jp", "hakusan.ishikawa.jp", "kaga.ishikawa.jp", "kahoku.ishikawa.jp", "kanazawa.ishikawa.jp", "kawakita.ishikawa.jp", "komatsu.ishikawa.jp", "nakanoto.ishikawa.jp", "nanao.ishikawa.jp", "nomi.ishikawa.jp", "nonoichi.ishikawa.jp", "noto.ishikawa.jp", "shika.ishikawa.jp", "suzu.ishikawa.jp", "tsubata.ishikawa.jp", "tsurugi.ishikawa.jp", "uchinada.ishikawa.jp", "wajima.ishikawa.jp", "fudai.iwate.jp", "fujisawa.iwate.jp", "hanamaki.iwate.jp", "hiraizumi.iwate.jp", "hirono.iwate.jp", "ichinohe.iwate.jp", "ichinoseki.iwate.jp", "iwaizumi.iwate.jp", "iwate.iwate.jp", "joboji.iwate.jp", "kamaishi.iwate.jp", "kanegasaki.iwate.jp", "karumai.iwate.jp", "kawai.iwate.jp", "kitakami.iwate.jp", "kuji.iwate.jp", "kunohe.iwate.jp", "kuzumaki.iwate.jp", "miyako.iwate.jp", "mizusawa.iwate.jp", "morioka.iwate.jp", "ninohe.iwate.jp", "noda.iwate.jp", "ofunato.iwate.jp", "oshu.iwate.jp", "otsuchi.iwate.jp", "rikuzentakata.iwate.jp", "shiwa.iwate.jp", "shizukuishi.iwate.jp", "sumita.iwate.jp", "tanohata.iwate.jp", "tono.iwate.jp", "yahaba.iwate.jp", "yamada.iwate.jp", "ayagawa.kagawa.jp", "higashikagawa.kagawa.jp", "kanonji.kagawa.jp", "kotohira.kagawa.jp", "manno.kagawa.jp", "marugame.kagawa.jp", "mitoyo.kagawa.jp", "naoshima.kagawa.jp", "sanuki.kagawa.jp", "tadotsu.kagawa.jp", "takamatsu.kagawa.jp", "tonosho.kagawa.jp", "uchinomi.kagawa.jp", "utazu.kagawa.jp", "zentsuji.kagawa.jp", "akune.kagoshima.jp", "amami.kagoshima.jp", "hioki.kagoshima.jp", "isa.kagoshima.jp", "isen.kagoshima.jp", "izumi.kagoshima.jp", "kagoshima.kagoshima.jp", "kanoya.kagoshima.jp", "kawanabe.kagoshima.jp", "kinko.kagoshima.jp", "kouyama.kagoshima.jp", "makurazaki.kagoshima.jp", "matsumoto.kagoshima.jp", "minamitane.kagoshima.jp", "nakatane.kagoshima.jp", "nishinoomote.kagoshima.jp", "satsumasendai.kagoshima.jp", "soo.kagoshima.jp", "tarumizu.kagoshima.jp", "yusui.kagoshima.jp", "aikawa.kanagawa.jp", "atsugi.kanagawa.jp", "ayase.kanagawa.jp", "chigasaki.kanagawa.jp", "ebina.kanagawa.jp", "fujisawa.kanagawa.jp", "hadano.kanagawa.jp", "hakone.kanagawa.jp", "hiratsuka.kanagawa.jp", "isehara.kanagawa.jp", "kaisei.kanagawa.jp", "kamakura.kanagawa.jp", "kiyokawa.kanagawa.jp", "matsuda.kanagawa.jp", "minamiashigara.kanagawa.jp", "miura.kanagawa.jp", "nakai.kanagawa.jp", "ninomiya.kanagawa.jp", "odawara.kanagawa.jp", "oi.kanagawa.jp", "oiso.kanagawa.jp", "sagamihara.kanagawa.jp", "samukawa.kanagawa.jp", "tsukui.kanagawa.jp", "yamakita.kanagawa.jp", "yamato.kanagawa.jp", "yokosuka.kanagawa.jp", "yugawara.kanagawa.jp", "zama.kanagawa.jp", "zushi.kanagawa.jp", "aki.kochi.jp", "geisei.kochi.jp", "hidaka.kochi.jp", "higashitsuno.kochi.jp", "ino.kochi.jp", "kagami.kochi.jp", "kami.kochi.jp", "kitagawa.kochi.jp", "kochi.kochi.jp", "mihara.kochi.jp", "motoyama.kochi.jp", "muroto.kochi.jp", "nahari.kochi.jp", "nakamura.kochi.jp", "nankoku.kochi.jp", "nishitosa.kochi.jp", "niyodogawa.kochi.jp", "ochi.kochi.jp", "okawa.kochi.jp", "otoyo.kochi.jp", "otsuki.kochi.jp", "sakawa.kochi.jp", "sukumo.kochi.jp", "susaki.kochi.jp", "tosa.kochi.jp", "tosashimizu.kochi.jp", "toyo.kochi.jp", "tsuno.kochi.jp", "umaji.kochi.jp", "yasuda.kochi.jp", "yusuhara.kochi.jp", "amakusa.kumamoto.jp", "arao.kumamoto.jp", "aso.kumamoto.jp", "choyo.kumamoto.jp", "gyokuto.kumamoto.jp", "kamiamakusa.kumamoto.jp", "kikuchi.kumamoto.jp", "kumamoto.kumamoto.jp", "mashiki.kumamoto.jp", "mifune.kumamoto.jp", "minamata.kumamoto.jp", "minamioguni.kumamoto.jp", "nagasu.kumamoto.jp", "nishihara.kumamoto.jp", "oguni.kumamoto.jp", "ozu.kumamoto.jp", "sumoto.kumamoto.jp", "takamori.kumamoto.jp", "uki.kumamoto.jp", "uto.kumamoto.jp", "yamaga.kumamoto.jp", "yamato.kumamoto.jp", "yatsushiro.kumamoto.jp", "ayabe.kyoto.jp", "fukuchiyama.kyoto.jp", "higashiyama.kyoto.jp", "ide.kyoto.jp", "ine.kyoto.jp", "joyo.kyoto.jp", "kameoka.kyoto.jp", "kamo.kyoto.jp", "kita.kyoto.jp", "kizu.kyoto.jp", "kumiyama.kyoto.jp", "kyotamba.kyoto.jp", "kyotanabe.kyoto.jp", "kyotango.kyoto.jp", "maizuru.kyoto.jp", "minami.kyoto.jp", "minamiyamashiro.kyoto.jp", "miyazu.kyoto.jp", "muko.kyoto.jp", "nagaokakyo.kyoto.jp", "nakagyo.kyoto.jp", "nantan.kyoto.jp", "oyamazaki.kyoto.jp", "sakyo.kyoto.jp", "seika.kyoto.jp", "tanabe.kyoto.jp", "uji.kyoto.jp", "ujitawara.kyoto.jp", "wazuka.kyoto.jp", "yamashina.kyoto.jp", "yawata.kyoto.jp", "asahi.mie.jp", "inabe.mie.jp", "ise.mie.jp", "kameyama.mie.jp", "kawagoe.mie.jp", "kiho.mie.jp", "kisosaki.mie.jp", "kiwa.mie.jp", "komono.mie.jp", "kumano.mie.jp", "kuwana.mie.jp", "matsusaka.mie.jp", "meiwa.mie.jp", "mihama.mie.jp", "minamiise.mie.jp", "misugi.mie.jp", "miyama.mie.jp", "nabari.mie.jp", "shima.mie.jp", "suzuka.mie.jp", "tado.mie.jp", "taiki.mie.jp", "taki.mie.jp", "tamaki.mie.jp", "toba.mie.jp", "tsu.mie.jp", "udono.mie.jp", "ureshino.mie.jp", "watarai.mie.jp", "yokkaichi.mie.jp", "furukawa.miyagi.jp", "higashimatsushima.miyagi.jp", "ishinomaki.miyagi.jp", "iwanuma.miyagi.jp", "kakuda.miyagi.jp", "kami.miyagi.jp", "kawasaki.miyagi.jp", "marumori.miyagi.jp", "matsushima.miyagi.jp", "minamisanriku.miyagi.jp", "misato.miyagi.jp", "murata.miyagi.jp", "natori.miyagi.jp", "ogawara.miyagi.jp", "ohira.miyagi.jp", "onagawa.miyagi.jp", "osaki.miyagi.jp", "rifu.miyagi.jp", "semine.miyagi.jp", "shibata.miyagi.jp", "shichikashuku.miyagi.jp", "shikama.miyagi.jp", "shiogama.miyagi.jp", "shiroishi.miyagi.jp", "tagajo.miyagi.jp", "taiwa.miyagi.jp", "tome.miyagi.jp", "tomiya.miyagi.jp", "wakuya.miyagi.jp", "watari.miyagi.jp", "yamamoto.miyagi.jp", "zao.miyagi.jp", "aya.miyazaki.jp", "ebino.miyazaki.jp", "gokase.miyazaki.jp", "hyuga.miyazaki.jp", "kadogawa.miyazaki.jp", "kawaminami.miyazaki.jp", "kijo.miyazaki.jp", "kitagawa.miyazaki.jp", "kitakata.miyazaki.jp", "kitaura.miyazaki.jp", "kobayashi.miyazaki.jp", "kunitomi.miyazaki.jp", "kushima.miyazaki.jp", "mimata.miyazaki.jp", "miyakonojo.miyazaki.jp", "miyazaki.miyazaki.jp", "morotsuka.miyazaki.jp", "nichinan.miyazaki.jp", "nishimera.miyazaki.jp", "nobeoka.miyazaki.jp", "saito.miyazaki.jp", "shiiba.miyazaki.jp", "shintomi.miyazaki.jp", "takaharu.miyazaki.jp", "takanabe.miyazaki.jp", "takazaki.miyazaki.jp", "tsuno.miyazaki.jp", "achi.nagano.jp", "agematsu.nagano.jp", "anan.nagano.jp", "aoki.nagano.jp", "asahi.nagano.jp", "azumino.nagano.jp", "chikuhoku.nagano.jp", "chikuma.nagano.jp", "chino.nagano.jp", "fujimi.nagano.jp", "hakuba.nagano.jp", "hara.nagano.jp", "hiraya.nagano.jp", "iida.nagano.jp", "iijima.nagano.jp", "iiyama.nagano.jp", "iizuna.nagano.jp", "ikeda.nagano.jp", "ikusaka.nagano.jp", "ina.nagano.jp", "karuizawa.nagano.jp", "kawakami.nagano.jp", "kiso.nagano.jp", "kisofukushima.nagano.jp", "kitaaiki.nagano.jp", "komagane.nagano.jp", "komoro.nagano.jp", "matsukawa.nagano.jp", "matsumoto.nagano.jp", "miasa.nagano.jp", "minamiaiki.nagano.jp", "minamimaki.nagano.jp", "minamiminowa.nagano.jp", "minowa.nagano.jp", "miyada.nagano.jp", "miyota.nagano.jp", "mochizuki.nagano.jp", "nagano.nagano.jp", "nagawa.nagano.jp", "nagiso.nagano.jp", "nakagawa.nagano.jp", "nakano.nagano.jp", "nozawaonsen.nagano.jp", "obuse.nagano.jp", "ogawa.nagano.jp", "okaya.nagano.jp", "omachi.nagano.jp", "omi.nagano.jp", "ookuwa.nagano.jp", "ooshika.nagano.jp", "otaki.nagano.jp", "otari.nagano.jp", "sakae.nagano.jp", "sakaki.nagano.jp", "saku.nagano.jp", "sakuho.nagano.jp", "shimosuwa.nagano.jp", "shinanomachi.nagano.jp", "shiojiri.nagano.jp", "suwa.nagano.jp", "suzaka.nagano.jp", "takagi.nagano.jp", "takamori.nagano.jp", "takayama.nagano.jp", "tateshina.nagano.jp", "tatsuno.nagano.jp", "togakushi.nagano.jp", "togura.nagano.jp", "tomi.nagano.jp", "ueda.nagano.jp", "wada.nagano.jp", "yamagata.nagano.jp", "yamanouchi.nagano.jp", "yasaka.nagano.jp", "yasuoka.nagano.jp", "chijiwa.nagasaki.jp", "futsu.nagasaki.jp", "goto.nagasaki.jp", "hasami.nagasaki.jp", "hirado.nagasaki.jp", "iki.nagasaki.jp", "isahaya.nagasaki.jp", "kawatana.nagasaki.jp", "kuchinotsu.nagasaki.jp", "matsuura.nagasaki.jp", "nagasaki.nagasaki.jp", "obama.nagasaki.jp", "omura.nagasaki.jp", "oseto.nagasaki.jp", "saikai.nagasaki.jp", "sasebo.nagasaki.jp", "seihi.nagasaki.jp", "shimabara.nagasaki.jp", "shinkamigoto.nagasaki.jp", "togitsu.nagasaki.jp", "tsushima.nagasaki.jp", "unzen.nagasaki.jp", "ando.nara.jp", "gose.nara.jp", "heguri.nara.jp", "higashiyoshino.nara.jp", "ikaruga.nara.jp", "ikoma.nara.jp", "kamikitayama.nara.jp", "kanmaki.nara.jp", "kashiba.nara.jp", "kashihara.nara.jp", "katsuragi.nara.jp", "kawai.nara.jp", "kawakami.nara.jp", "kawanishi.nara.jp", "koryo.nara.jp", "kurotaki.nara.jp", "mitsue.nara.jp", "miyake.nara.jp", "nara.nara.jp", "nosegawa.nara.jp", "oji.nara.jp", "ouda.nara.jp", "oyodo.nara.jp", "sakurai.nara.jp", "sango.nara.jp", "shimoichi.nara.jp", "shimokitayama.nara.jp", "shinjo.nara.jp", "soni.nara.jp", "takatori.nara.jp", "tawaramoto.nara.jp", "tenkawa.nara.jp", "tenri.nara.jp", "uda.nara.jp", "yamatokoriyama.nara.jp", "yamatotakada.nara.jp", "yamazoe.nara.jp", "yoshino.nara.jp", "aga.niigata.jp", "agano.niigata.jp", "gosen.niigata.jp", "itoigawa.niigata.jp", "izumozaki.niigata.jp", "joetsu.niigata.jp", "kamo.niigata.jp", "kariwa.niigata.jp", "kashiwazaki.niigata.jp", "minamiuonuma.niigata.jp", "mitsuke.niigata.jp", "muika.niigata.jp", "murakami.niigata.jp", "myoko.niigata.jp", "nagaoka.niigata.jp", "niigata.niigata.jp", "ojiya.niigata.jp", "omi.niigata.jp", "sado.niigata.jp", "sanjo.niigata.jp", "seiro.niigata.jp", "seirou.niigata.jp", "sekikawa.niigata.jp", "shibata.niigata.jp", "tagami.niigata.jp", "tainai.niigata.jp", "tochio.niigata.jp", "tokamachi.niigata.jp", "tsubame.niigata.jp", "tsunan.niigata.jp", "uonuma.niigata.jp", "yahiko.niigata.jp", "yoita.niigata.jp", "yuzawa.niigata.jp", "beppu.oita.jp", "bungoono.oita.jp", "bungotakada.oita.jp", "hasama.oita.jp", "hiji.oita.jp", "himeshima.oita.jp", "hita.oita.jp", "kamitsue.oita.jp", "kokonoe.oita.jp", "kuju.oita.jp", "kunisaki.oita.jp", "kusu.oita.jp", "oita.oita.jp", "saiki.oita.jp", "taketa.oita.jp", "tsukumi.oita.jp", "usa.oita.jp", "usuki.oita.jp", "yufu.oita.jp", "akaiwa.okayama.jp", "asakuchi.okayama.jp", "bizen.okayama.jp", "hayashima.okayama.jp", "ibara.okayama.jp", "kagamino.okayama.jp", "kasaoka.okayama.jp", "kibichuo.okayama.jp", "kumenan.okayama.jp", "kurashiki.okayama.jp", "maniwa.okayama.jp", "misaki.okayama.jp", "nagi.okayama.jp", "niimi.okayama.jp", "nishiawakura.okayama.jp", "okayama.okayama.jp", "satosho.okayama.jp", "setouchi.okayama.jp", "shinjo.okayama.jp", "shoo.okayama.jp", "soja.okayama.jp", "takahashi.okayama.jp", "tamano.okayama.jp", "tsuyama.okayama.jp", "wake.okayama.jp", "yakage.okayama.jp", "aguni.okinawa.jp", "ginowan.okinawa.jp", "ginoza.okinawa.jp", "gushikami.okinawa.jp", "haebaru.okinawa.jp", "higashi.okinawa.jp", "hirara.okinawa.jp", "iheya.okinawa.jp", "ishigaki.okinawa.jp", "ishikawa.okinawa.jp", "itoman.okinawa.jp", "izena.okinawa.jp", "kadena.okinawa.jp", "kin.okinawa.jp", "kitadaito.okinawa.jp", "kitanakagusuku.okinawa.jp", "kumejima.okinawa.jp", "kunigami.okinawa.jp", "minamidaito.okinawa.jp", "motobu.okinawa.jp", "nago.okinawa.jp", "naha.okinawa.jp", "nakagusuku.okinawa.jp", "nakijin.okinawa.jp", "nanjo.okinawa.jp", "nishihara.okinawa.jp", "ogimi.okinawa.jp", "okinawa.okinawa.jp", "onna.okinawa.jp", "shimoji.okinawa.jp", "taketomi.okinawa.jp", "tarama.okinawa.jp", "tokashiki.okinawa.jp", "tomigusuku.okinawa.jp", "tonaki.okinawa.jp", "urasoe.okinawa.jp", "uruma.okinawa.jp", "yaese.okinawa.jp", "yomitan.okinawa.jp", "yonabaru.okinawa.jp", "yonaguni.okinawa.jp", "zamami.okinawa.jp", "abeno.osaka.jp", "chihayaakasaka.osaka.jp", "chuo.osaka.jp", "daito.osaka.jp", "fujiidera.osaka.jp", "habikino.osaka.jp", "hannan.osaka.jp", "higashiosaka.osaka.jp", "higashisumiyoshi.osaka.jp", "higashiyodogawa.osaka.jp", "hirakata.osaka.jp", "ibaraki.osaka.jp", "ikeda.osaka.jp", "izumi.osaka.jp", "izumiotsu.osaka.jp", "izumisano.osaka.jp", "kadoma.osaka.jp", "kaizuka.osaka.jp", "kanan.osaka.jp", "kashiwara.osaka.jp", "katano.osaka.jp", "kawachinagano.osaka.jp", "kishiwada.osaka.jp", "kita.osaka.jp", "kumatori.osaka.jp", "matsubara.osaka.jp", "minato.osaka.jp", "minoh.osaka.jp", "misaki.osaka.jp", "moriguchi.osaka.jp", "neyagawa.osaka.jp", "nishi.osaka.jp", "nose.osaka.jp", "osakasayama.osaka.jp", "sakai.osaka.jp", "sayama.osaka.jp", "sennan.osaka.jp", "settsu.osaka.jp", "shijonawate.osaka.jp", "shimamoto.osaka.jp", "suita.osaka.jp", "tadaoka.osaka.jp", "taishi.osaka.jp", "tajiri.osaka.jp", "takaishi.osaka.jp", "takatsuki.osaka.jp", "tondabayashi.osaka.jp", "toyonaka.osaka.jp", "toyono.osaka.jp", "yao.osaka.jp", "ariake.saga.jp", "arita.saga.jp", "fukudomi.saga.jp", "genkai.saga.jp", "hamatama.saga.jp", "hizen.saga.jp", "imari.saga.jp", "kamimine.saga.jp", "kanzaki.saga.jp", "karatsu.saga.jp", "kashima.saga.jp", "kitagata.saga.jp", "kitahata.saga.jp", "kiyama.saga.jp", "kouhoku.saga.jp", "kyuragi.saga.jp", "nishiarita.saga.jp", "ogi.saga.jp", "omachi.saga.jp", "ouchi.saga.jp", "saga.saga.jp", "shiroishi.saga.jp", "taku.saga.jp", "tara.saga.jp", "tosu.saga.jp", "yoshinogari.saga.jp", "arakawa.saitama.jp", "asaka.saitama.jp", "chichibu.saitama.jp", "fujimi.saitama.jp", "fujimino.saitama.jp", "fukaya.saitama.jp", "hanno.saitama.jp", "hanyu.saitama.jp", "hasuda.saitama.jp", "hatogaya.saitama.jp", "hatoyama.saitama.jp", "hidaka.saitama.jp", "higashichichibu.saitama.jp", "higashimatsuyama.saitama.jp", "honjo.saitama.jp", "ina.saitama.jp", "iruma.saitama.jp", "iwatsuki.saitama.jp", "kamiizumi.saitama.jp", "kamikawa.saitama.jp", "kamisato.saitama.jp", "kasukabe.saitama.jp", "kawagoe.saitama.jp", "kawaguchi.saitama.jp", "kawajima.saitama.jp", "kazo.saitama.jp", "kitamoto.saitama.jp", "koshigaya.saitama.jp", "kounosu.saitama.jp", "kuki.saitama.jp", "kumagaya.saitama.jp", "matsubushi.saitama.jp", "minano.saitama.jp", "misato.saitama.jp", "miyashiro.saitama.jp", "miyoshi.saitama.jp", "moroyama.saitama.jp", "nagatoro.saitama.jp", "namegawa.saitama.jp", "niiza.saitama.jp", "ogano.saitama.jp", "ogawa.saitama.jp", "ogose.saitama.jp", "okegawa.saitama.jp", "omiya.saitama.jp", "otaki.saitama.jp", "ranzan.saitama.jp", "ryokami.saitama.jp", "saitama.saitama.jp", "sakado.saitama.jp", "satte.saitama.jp", "sayama.saitama.jp", "shiki.saitama.jp", "shiraoka.saitama.jp", "soka.saitama.jp", "sugito.saitama.jp", "toda.saitama.jp", "tokigawa.saitama.jp", "tokorozawa.saitama.jp", "tsurugashima.saitama.jp", "urawa.saitama.jp", "warabi.saitama.jp", "yashio.saitama.jp", "yokoze.saitama.jp", "yono.saitama.jp", "yorii.saitama.jp", "yoshida.saitama.jp", "yoshikawa.saitama.jp", "yoshimi.saitama.jp", "aisho.shiga.jp", "gamo.shiga.jp", "higashiomi.shiga.jp", "hikone.shiga.jp", "koka.shiga.jp", "konan.shiga.jp", "kosei.shiga.jp", "koto.shiga.jp", "kusatsu.shiga.jp", "maibara.shiga.jp", "moriyama.shiga.jp", "nagahama.shiga.jp", "nishiazai.shiga.jp", "notogawa.shiga.jp", "omihachiman.shiga.jp", "otsu.shiga.jp", "ritto.shiga.jp", "ryuoh.shiga.jp", "takashima.shiga.jp", "takatsuki.shiga.jp", "torahime.shiga.jp", "toyosato.shiga.jp", "yasu.shiga.jp", "akagi.shimane.jp", "ama.shimane.jp", "gotsu.shimane.jp", "hamada.shimane.jp", "higashiizumo.shimane.jp", "hikawa.shimane.jp", "hikimi.shimane.jp", "izumo.shimane.jp", "kakinoki.shimane.jp", "masuda.shimane.jp", "matsue.shimane.jp", "misato.shimane.jp", "nishinoshima.shimane.jp", "ohda.shimane.jp", "okinoshima.shimane.jp", "okuizumo.shimane.jp", "shimane.shimane.jp", "tamayu.shimane.jp", "tsuwano.shimane.jp", "unnan.shimane.jp", "yakumo.shimane.jp", "yasugi.shimane.jp", "yatsuka.shimane.jp", "arai.shizuoka.jp", "atami.shizuoka.jp", "fuji.shizuoka.jp", "fujieda.shizuoka.jp", "fujikawa.shizuoka.jp", "fujinomiya.shizuoka.jp", "fukuroi.shizuoka.jp", "gotemba.shizuoka.jp", "haibara.shizuoka.jp", "hamamatsu.shizuoka.jp", "higashiizu.shizuoka.jp", "ito.shizuoka.jp", "iwata.shizuoka.jp", "izu.shizuoka.jp", "izunokuni.shizuoka.jp", "kakegawa.shizuoka.jp", "kannami.shizuoka.jp", "kawanehon.shizuoka.jp", "kawazu.shizuoka.jp", "kikugawa.shizuoka.jp", "kosai.shizuoka.jp", "makinohara.shizuoka.jp", "matsuzaki.shizuoka.jp", "minamiizu.shizuoka.jp", "mishima.shizuoka.jp", "morimachi.shizuoka.jp", "nishiizu.shizuoka.jp", "numazu.shizuoka.jp", "omaezaki.shizuoka.jp", "shimada.shizuoka.jp", "shimizu.shizuoka.jp", "shimoda.shizuoka.jp", "shizuoka.shizuoka.jp", "susono.shizuoka.jp", "yaizu.shizuoka.jp", "yoshida.shizuoka.jp", "ashikaga.tochigi.jp", "bato.tochigi.jp", "haga.tochigi.jp", "ichikai.tochigi.jp", "iwafune.tochigi.jp", "kaminokawa.tochigi.jp", "kanuma.tochigi.jp", "karasuyama.tochigi.jp", "kuroiso.tochigi.jp", "mashiko.tochigi.jp", "mibu.tochigi.jp", "moka.tochigi.jp", "motegi.tochigi.jp", "nasu.tochigi.jp", "nasushiobara.tochigi.jp", "nikko.tochigi.jp", "nishikata.tochigi.jp", "nogi.tochigi.jp", "ohira.tochigi.jp", "ohtawara.tochigi.jp", "oyama.tochigi.jp", "sakura.tochigi.jp", "sano.tochigi.jp", "shimotsuke.tochigi.jp", "shioya.tochigi.jp", "takanezawa.tochigi.jp", "tochigi.tochigi.jp", "tsuga.tochigi.jp", "ujiie.tochigi.jp", "utsunomiya.tochigi.jp", "yaita.tochigi.jp", "aizumi.tokushima.jp", "anan.tokushima.jp", "ichiba.tokushima.jp", "itano.tokushima.jp", "kainan.tokushima.jp", "komatsushima.tokushima.jp", "matsushige.tokushima.jp", "mima.tokushima.jp", "minami.tokushima.jp", "miyoshi.tokushima.jp", "mugi.tokushima.jp", "nakagawa.tokushima.jp", "naruto.tokushima.jp", "sanagochi.tokushima.jp", "shishikui.tokushima.jp", "tokushima.tokushima.jp", "wajiki.tokushima.jp", "adachi.tokyo.jp", "akiruno.tokyo.jp", "akishima.tokyo.jp", "aogashima.tokyo.jp", "arakawa.tokyo.jp", "bunkyo.tokyo.jp", "chiyoda.tokyo.jp", "chofu.tokyo.jp", "chuo.tokyo.jp", "edogawa.tokyo.jp", "fuchu.tokyo.jp", "fussa.tokyo.jp", "hachijo.tokyo.jp", "hachioji.tokyo.jp", "hamura.tokyo.jp", "higashikurume.tokyo.jp", "higashimurayama.tokyo.jp", "higashiyamato.tokyo.jp", "hino.tokyo.jp", "hinode.tokyo.jp", "hinohara.tokyo.jp", "inagi.tokyo.jp", "itabashi.tokyo.jp", "katsushika.tokyo.jp", "kita.tokyo.jp", "kiyose.tokyo.jp", "kodaira.tokyo.jp", "koganei.tokyo.jp", "kokubunji.tokyo.jp", "komae.tokyo.jp", "koto.tokyo.jp", "kouzushima.tokyo.jp", "kunitachi.tokyo.jp", "machida.tokyo.jp", "meguro.tokyo.jp", "minato.tokyo.jp", "mitaka.tokyo.jp", "mizuho.tokyo.jp", "musashimurayama.tokyo.jp", "musashino.tokyo.jp", "nakano.tokyo.jp", "nerima.tokyo.jp", "ogasawara.tokyo.jp", "okutama.tokyo.jp", "ome.tokyo.jp", "oshima.tokyo.jp", "ota.tokyo.jp", "setagaya.tokyo.jp", "shibuya.tokyo.jp", "shinagawa.tokyo.jp", "shinjuku.tokyo.jp", "suginami.tokyo.jp", "sumida.tokyo.jp", "tachikawa.tokyo.jp", "taito.tokyo.jp", "tama.tokyo.jp", "toshima.tokyo.jp", "chizu.tottori.jp", "hino.tottori.jp", "kawahara.tottori.jp", "koge.tottori.jp", "kotoura.tottori.jp", "misasa.tottori.jp", "nanbu.tottori.jp", "nichinan.tottori.jp", "sakaiminato.tottori.jp", "tottori.tottori.jp", "wakasa.tottori.jp", "yazu.tottori.jp", "yonago.tottori.jp", "asahi.toyama.jp", "fuchu.toyama.jp", "fukumitsu.toyama.jp", "funahashi.toyama.jp", "himi.toyama.jp", "imizu.toyama.jp", "inami.toyama.jp", "johana.toyama.jp", "kamiichi.toyama.jp", "kurobe.toyama.jp", "nakaniikawa.toyama.jp", "namerikawa.toyama.jp", "nanto.toyama.jp", "nyuzen.toyama.jp", "oyabe.toyama.jp", "taira.toyama.jp", "takaoka.toyama.jp", "tateyama.toyama.jp", "toga.toyama.jp", "tonami.toyama.jp", "toyama.toyama.jp", "unazuki.toyama.jp", "uozu.toyama.jp", "yamada.toyama.jp", "arida.wakayama.jp", "aridagawa.wakayama.jp", "gobo.wakayama.jp", "hashimoto.wakayama.jp", "hidaka.wakayama.jp", "hirogawa.wakayama.jp", "inami.wakayama.jp", "iwade.wakayama.jp", "kainan.wakayama.jp", "kamitonda.wakayama.jp", "katsuragi.wakayama.jp", "kimino.wakayama.jp", "kinokawa.wakayama.jp", "kitayama.wakayama.jp", "koya.wakayama.jp", "koza.wakayama.jp", "kozagawa.wakayama.jp", "kudoyama.wakayama.jp", "kushimoto.wakayama.jp", "mihama.wakayama.jp", "misato.wakayama.jp", "nachikatsuura.wakayama.jp", "shingu.wakayama.jp", "shirahama.wakayama.jp", "taiji.wakayama.jp", "tanabe.wakayama.jp", "wakayama.wakayama.jp", "yuasa.wakayama.jp", "yura.wakayama.jp", "asahi.yamagata.jp", "funagata.yamagata.jp", "higashine.yamagata.jp", "iide.yamagata.jp", "kahoku.yamagata.jp", "kaminoyama.yamagata.jp", "kaneyama.yamagata.jp", "kawanishi.yamagata.jp", "mamurogawa.yamagata.jp", "mikawa.yamagata.jp", "murayama.yamagata.jp", "nagai.yamagata.jp", "nakayama.yamagata.jp", "nanyo.yamagata.jp", "nishikawa.yamagata.jp", "obanazawa.yamagata.jp", "oe.yamagata.jp", "oguni.yamagata.jp", "ohkura.yamagata.jp", "oishida.yamagata.jp", "sagae.yamagata.jp", "sakata.yamagata.jp", "sakegawa.yamagata.jp", "shinjo.yamagata.jp", "shirataka.yamagata.jp", "shonai.yamagata.jp", "takahata.yamagata.jp", "tendo.yamagata.jp", "tozawa.yamagata.jp", "tsuruoka.yamagata.jp", "yamagata.yamagata.jp", "yamanobe.yamagata.jp", "yonezawa.yamagata.jp", "yuza.yamagata.jp", "abu.yamaguchi.jp", "hagi.yamaguchi.jp", "hikari.yamaguchi.jp", "hofu.yamaguchi.jp", "iwakuni.yamaguchi.jp", "kudamatsu.yamaguchi.jp", "mitou.yamaguchi.jp", "nagato.yamaguchi.jp", "oshima.yamaguchi.jp", "shimonoseki.yamaguchi.jp", "shunan.yamaguchi.jp", "tabuse.yamaguchi.jp", "tokuyama.yamaguchi.jp", "toyota.yamaguchi.jp", "ube.yamaguchi.jp", "yuu.yamaguchi.jp", "chuo.yamanashi.jp", "doshi.yamanashi.jp", "fuefuki.yamanashi.jp", "fujikawa.yamanashi.jp", "fujikawaguchiko.yamanashi.jp", "fujiyoshida.yamanashi.jp", "hayakawa.yamanashi.jp", "hokuto.yamanashi.jp", "ichikawamisato.yamanashi.jp", "kai.yamanashi.jp", "kofu.yamanashi.jp", "koshu.yamanashi.jp", "kosuge.yamanashi.jp", "minami-alps.yamanashi.jp", "minobu.yamanashi.jp", "nakamichi.yamanashi.jp", "nanbu.yamanashi.jp", "narusawa.yamanashi.jp", "nirasaki.yamanashi.jp", "nishikatsura.yamanashi.jp", "oshino.yamanashi.jp", "otsuki.yamanashi.jp", "showa.yamanashi.jp", "tabayama.yamanashi.jp", "tsuru.yamanashi.jp", "uenohara.yamanashi.jp", "yamanakako.yamanashi.jp", "yamanashi.yamanashi.jp", "ke", "ac.ke", "co.ke", "go.ke", "info.ke", "me.ke", "mobi.ke", "ne.ke", "or.ke", "sc.ke", "kg", "com.kg", "edu.kg", "gov.kg", "mil.kg", "net.kg", "org.kg", "*.kh", "ki", "biz.ki", "com.ki", "edu.ki", "gov.ki", "info.ki", "net.ki", "org.ki", "km", "ass.km", "com.km", "edu.km", "gov.km", "mil.km", "nom.km", "org.km", "prd.km", "tm.km", "asso.km", "coop.km", "gouv.km", "medecin.km", "notaires.km", "pharmaciens.km", "presse.km", "veterinaire.km", "kn", "edu.kn", "gov.kn", "net.kn", "org.kn", "kp", "com.kp", "edu.kp", "gov.kp", "org.kp", "rep.kp", "tra.kp", "kr", "ac.kr", "co.kr", "es.kr", "go.kr", "hs.kr", "kg.kr", "mil.kr", "ms.kr", "ne.kr", "or.kr", "pe.kr", "re.kr", "sc.kr", "busan.kr", "chungbuk.kr", "chungnam.kr", "daegu.kr", "daejeon.kr", "gangwon.kr", "gwangju.kr", "gyeongbuk.kr", "gyeonggi.kr", "gyeongnam.kr", "incheon.kr", "jeju.kr", "jeonbuk.kr", "jeonnam.kr", "seoul.kr", "ulsan.kr", "kw", "com.kw", "edu.kw", "emb.kw", "gov.kw", "ind.kw", "net.kw", "org.kw", "ky", "com.ky", "edu.ky", "net.ky", "org.ky", "kz", "com.kz", "edu.kz", "gov.kz", "mil.kz", "net.kz", "org.kz", "la", "com.la", "edu.la", "gov.la", "info.la", "int.la", "net.la", "org.la", "per.la", "lb", "com.lb", "edu.lb", "gov.lb", "net.lb", "org.lb", "lc", "co.lc", "com.lc", "edu.lc", "gov.lc", "net.lc", "org.lc", "li", "lk", "ac.lk", "assn.lk", "com.lk", "edu.lk", "gov.lk", "grp.lk", "hotel.lk", "int.lk", "ltd.lk", "net.lk", "ngo.lk", "org.lk", "sch.lk", "soc.lk", "web.lk", "lr", "com.lr", "edu.lr", "gov.lr", "net.lr", "org.lr", "ls", "ac.ls", "biz.ls", "co.ls", "edu.ls", "gov.ls", "info.ls", "net.ls", "org.ls", "sc.ls", "lt", "gov.lt", "lu", "lv", "asn.lv", "com.lv", "conf.lv", "edu.lv", "gov.lv", "id.lv", "mil.lv", "net.lv", "org.lv", "ly", "com.ly", "edu.ly", "gov.ly", "id.ly", "med.ly", "net.ly", "org.ly", "plc.ly", "sch.ly", "ma", "ac.ma", "co.ma", "gov.ma", "net.ma", "org.ma", "press.ma", "mc", "asso.mc", "tm.mc", "md", "me", "ac.me", "co.me", "edu.me", "gov.me", "its.me", "net.me", "org.me", "priv.me", "mg", "co.mg", "com.mg", "edu.mg", "gov.mg", "mil.mg", "nom.mg", "org.mg", "prd.mg", "mh", "mil", "mk", "com.mk", "edu.mk", "gov.mk", "inf.mk", "name.mk", "net.mk", "org.mk", "ml", "com.ml", "edu.ml", "gouv.ml", "gov.ml", "net.ml", "org.ml", "presse.ml", "*.mm", "mn", "edu.mn", "gov.mn", "org.mn", "mo", "com.mo", "edu.mo", "gov.mo", "net.mo", "org.mo", "mobi", "mp", "mq", "mr", "gov.mr", "ms", "com.ms", "edu.ms", "gov.ms", "net.ms", "org.ms", "mt", "com.mt", "edu.mt", "net.mt", "org.mt", "mu", "ac.mu", "co.mu", "com.mu", "gov.mu", "net.mu", "or.mu", "org.mu", "museum", "mv", "aero.mv", "biz.mv", "com.mv", "coop.mv", "edu.mv", "gov.mv", "info.mv", "int.mv", "mil.mv", "museum.mv", "name.mv", "net.mv", "org.mv", "pro.mv", "mw", "ac.mw", "biz.mw", "co.mw", "com.mw", "coop.mw", "edu.mw", "gov.mw", "int.mw", "net.mw", "org.mw", "mx", "com.mx", "edu.mx", "gob.mx", "net.mx", "org.mx", "my", "biz.my", "com.my", "edu.my", "gov.my", "mil.my", "name.my", "net.my", "org.my", "mz", "ac.mz", "adv.mz", "co.mz", "edu.mz", "gov.mz", "mil.mz", "net.mz", "org.mz", "na", "alt.na", "co.na", "com.na", "gov.na", "net.na", "org.na", "name", "nc", "asso.nc", "nom.nc", "ne", "net", "nf", "arts.nf", "com.nf", "firm.nf", "info.nf", "net.nf", "other.nf", "per.nf", "rec.nf", "store.nf", "web.nf", "ng", "com.ng", "edu.ng", "gov.ng", "i.ng", "mil.ng", "mobi.ng", "name.ng", "net.ng", "org.ng", "sch.ng", "ni", "ac.ni", "biz.ni", "co.ni", "com.ni", "edu.ni", "gob.ni", "in.ni", "info.ni", "int.ni", "mil.ni", "net.ni", "nom.ni", "org.ni", "web.ni", "nl", "no", "fhs.no", "folkebibl.no", "fylkesbibl.no", "idrett.no", "museum.no", "priv.no", "vgs.no", "dep.no", "herad.no", "kommune.no", "mil.no", "stat.no", "aa.no", "ah.no", "bu.no", "fm.no", "hl.no", "hm.no", "jan-mayen.no", "mr.no", "nl.no", "nt.no", "of.no", "ol.no", "oslo.no", "rl.no", "sf.no", "st.no", "svalbard.no", "tm.no", "tr.no", "va.no", "vf.no", "gs.aa.no", "gs.ah.no", "gs.bu.no", "gs.fm.no", "gs.hl.no", "gs.hm.no", "gs.jan-mayen.no", "gs.mr.no", "gs.nl.no", "gs.nt.no", "gs.of.no", "gs.ol.no", "gs.oslo.no", "gs.rl.no", "gs.sf.no", "gs.st.no", "gs.svalbard.no", "gs.tm.no", "gs.tr.no", "gs.va.no", "gs.vf.no", "akrehamn.no", "Ã¥krehamn.no", "algard.no", "Ã¥lgÃ¥rd.no", "arna.no", "bronnoysund.no", "brÃ¸nnÃ¸ysund.no", "brumunddal.no", "bryne.no", "drobak.no", "drÃ¸bak.no", "egersund.no", "fetsund.no", "floro.no", "florÃ¸.no", "fredrikstad.no", "hokksund.no", "honefoss.no", "hÃ¸nefoss.no", "jessheim.no", "jorpeland.no", "jÃ¸rpeland.no", "kirkenes.no", "kopervik.no", "krokstadelva.no", "langevag.no", "langevÃ¥g.no", "leirvik.no", "mjondalen.no", "mjÃ¸ndalen.no", "mo-i-rana.no", "mosjoen.no", "mosjÃ¸en.no", "nesoddtangen.no", "orkanger.no", "osoyro.no", "osÃ¸yro.no", "raholt.no", "rÃ¥holt.no", "sandnessjoen.no", "sandnessjÃ¸en.no", "skedsmokorset.no", "slattum.no", "spjelkavik.no", "stathelle.no", "stavern.no", "stjordalshalsen.no", "stjÃ¸rdalshalsen.no", "tananger.no", "tranby.no", "vossevangen.no", "aarborte.no", "aejrie.no", "afjord.no", "Ã¥fjord.no", "agdenes.no", "nes.akershus.no", "aknoluokta.no", "Ã¡kÅ‹oluokta.no", "al.no", "Ã¥l.no", "alaheadju.no", "Ã¡laheadju.no", "alesund.no", "Ã¥lesund.no", "alstahaug.no", "alta.no", "Ã¡ltÃ¡.no", "alvdal.no", "amli.no", "Ã¥mli.no", "amot.no", "Ã¥mot.no", "andasuolo.no", "andebu.no", "andoy.no", "andÃ¸y.no", "ardal.no", "Ã¥rdal.no", "aremark.no", "arendal.no", "Ã¥s.no", "aseral.no", "Ã¥seral.no", "asker.no", "askim.no", "askoy.no", "askÃ¸y.no", "askvoll.no", "asnes.no", "Ã¥snes.no", "audnedaln.no", "aukra.no", "aure.no", "aurland.no", "aurskog-holand.no", "aurskog-hÃ¸land.no", "austevoll.no", "austrheim.no", "averoy.no", "averÃ¸y.no", "badaddja.no", "bÃ¥dÃ¥ddjÃ¥.no", "bÃ¦rum.no", "bahcavuotna.no", "bÃ¡hcavuotna.no", "bahccavuotna.no", "bÃ¡hccavuotna.no", "baidar.no", "bÃ¡idÃ¡r.no", "bajddar.no", "bÃ¡jddar.no", "balat.no", "bÃ¡lÃ¡t.no", "balestrand.no", "ballangen.no", "balsfjord.no", "bamble.no", "bardu.no", "barum.no", "batsfjord.no", "bÃ¥tsfjord.no", "bearalvahki.no", "bearalvÃ¡hki.no", "beardu.no", "beiarn.no", "berg.no", "bergen.no", "berlevag.no", "berlevÃ¥g.no", "bievat.no", "bievÃ¡t.no", "bindal.no", "birkenes.no", "bjarkoy.no", "bjarkÃ¸y.no", "bjerkreim.no", "bjugn.no", "bodo.no", "bodÃ¸.no", "bokn.no", "bomlo.no", "bÃ¸mlo.no", "bremanger.no", "bronnoy.no", "brÃ¸nnÃ¸y.no", "budejju.no", "nes.buskerud.no", "bygland.no", "bykle.no", "cahcesuolo.no", "ÄÃ¡hcesuolo.no", "davvenjarga.no", "davvenjÃ¡rga.no", "davvesiida.no", "deatnu.no", "dielddanuorri.no", "divtasvuodna.no", "divttasvuotna.no", "donna.no", "dÃ¸nna.no", "dovre.no", "drammen.no", "drangedal.no", "dyroy.no", "dyrÃ¸y.no", "eid.no", "eidfjord.no", "eidsberg.no", "eidskog.no", "eidsvoll.no", "eigersund.no", "elverum.no", "enebakk.no", "engerdal.no", "etne.no", "etnedal.no", "evenassi.no", "evenÃ¡Å¡Å¡i.no", "evenes.no", "evje-og-hornnes.no", "farsund.no", "fauske.no", "fedje.no", "fet.no", "finnoy.no", "finnÃ¸y.no", "fitjar.no", "fjaler.no", "fjell.no", "fla.no", "flÃ¥.no", "flakstad.no", "flatanger.no", "flekkefjord.no", "flesberg.no", "flora.no", "folldal.no", "forde.no", "fÃ¸rde.no", "forsand.no", "fosnes.no", "frÃ¦na.no", "frana.no", "frei.no", "frogn.no", "froland.no", "frosta.no", "froya.no", "frÃ¸ya.no", "fuoisku.no", "fuossko.no", "fusa.no", "fyresdal.no", "gaivuotna.no", "gÃ¡ivuotna.no", "galsa.no", "gÃ¡lsÃ¡.no", "gamvik.no", "gangaviika.no", "gÃ¡Å‹gaviika.no", "gaular.no", "gausdal.no", "giehtavuoatna.no", "gildeskal.no", "gildeskÃ¥l.no", "giske.no", "gjemnes.no", "gjerdrum.no", "gjerstad.no", "gjesdal.no", "gjovik.no", "gjÃ¸vik.no", "gloppen.no", "gol.no", "gran.no", "grane.no", "granvin.no", "gratangen.no", "grimstad.no", "grong.no", "grue.no", "gulen.no", "guovdageaidnu.no", "ha.no", "hÃ¥.no", "habmer.no", "hÃ¡bmer.no", "hadsel.no", "hÃ¦gebostad.no", "hagebostad.no", "halden.no", "halsa.no", "hamar.no", "hamaroy.no", "hammarfeasta.no", "hÃ¡mmÃ¡rfeasta.no", "hammerfest.no", "hapmir.no", "hÃ¡pmir.no", "haram.no", "hareid.no", "harstad.no", "hasvik.no", "hattfjelldal.no", "haugesund.no", "os.hedmark.no", "valer.hedmark.no", "vÃ¥ler.hedmark.no", "hemne.no", "hemnes.no", "hemsedal.no", "hitra.no", "hjartdal.no", "hjelmeland.no", "hobol.no", "hobÃ¸l.no", "hof.no", "hol.no", "hole.no", "holmestrand.no", "holtalen.no", "holtÃ¥len.no", "os.hordaland.no", "hornindal.no", "horten.no", "hoyanger.no", "hÃ¸yanger.no", "hoylandet.no", "hÃ¸ylandet.no", "hurdal.no", "hurum.no", "hvaler.no", "hyllestad.no", "ibestad.no", "inderoy.no", "inderÃ¸y.no", "iveland.no", "ivgu.no", "jevnaker.no", "jolster.no", "jÃ¸lster.no", "jondal.no", "kafjord.no", "kÃ¥fjord.no", "karasjohka.no", "kÃ¡rÃ¡Å¡johka.no", "karasjok.no", "karlsoy.no", "karmoy.no", "karmÃ¸y.no", "kautokeino.no", "klabu.no", "klÃ¦bu.no", "klepp.no", "kongsberg.no", "kongsvinger.no", "kraanghke.no", "krÃ¥anghke.no", "kragero.no", "kragerÃ¸.no", "kristiansand.no", "kristiansund.no", "krodsherad.no", "krÃ¸dsherad.no", "kvÃ¦fjord.no", "kvÃ¦nangen.no", "kvafjord.no", "kvalsund.no", "kvam.no", "kvanangen.no", "kvinesdal.no", "kvinnherad.no", "kviteseid.no", "kvitsoy.no", "kvitsÃ¸y.no", "laakesvuemie.no", "lÃ¦rdal.no", "lahppi.no", "lÃ¡hppi.no", "lardal.no", "larvik.no", "lavagis.no", "lavangen.no", "leangaviika.no", "leaÅ‹gaviika.no", "lebesby.no", "leikanger.no", "leirfjord.no", "leka.no", "leksvik.no", "lenvik.no", "lerdal.no", "lesja.no", "levanger.no", "lier.no", "lierne.no", "lillehammer.no", "lillesand.no", "lindas.no", "lindÃ¥s.no", "lindesnes.no", "loabat.no", "loabÃ¡t.no", "lodingen.no", "lÃ¸dingen.no", "lom.no", "loppa.no", "lorenskog.no", "lÃ¸renskog.no", "loten.no", "lÃ¸ten.no", "lund.no", "lunner.no", "luroy.no", "lurÃ¸y.no", "luster.no", "lyngdal.no", "lyngen.no", "malatvuopmi.no", "mÃ¡latvuopmi.no", "malselv.no", "mÃ¥lselv.no", "malvik.no", "mandal.no", "marker.no", "marnardal.no", "masfjorden.no", "masoy.no", "mÃ¥sÃ¸y.no", "matta-varjjat.no", "mÃ¡tta-vÃ¡rjjat.no", "meland.no", "meldal.no", "melhus.no", "meloy.no", "melÃ¸y.no", "meraker.no", "merÃ¥ker.no", "midsund.no", "midtre-gauldal.no", "moareke.no", "moÃ¥reke.no", "modalen.no", "modum.no", "molde.no", "heroy.more-og-romsdal.no", "sande.more-og-romsdal.no", "herÃ¸y.mÃ¸re-og-romsdal.no", "sande.mÃ¸re-og-romsdal.no", "moskenes.no", "moss.no", "mosvik.no", "muosat.no", "muosÃ¡t.no", "naamesjevuemie.no", "nÃ¥Ã¥mesjevuemie.no", "nÃ¦rÃ¸y.no", "namdalseid.no", "namsos.no", "namsskogan.no", "nannestad.no", "naroy.no", "narviika.no", "narvik.no", "naustdal.no", "navuotna.no", "nÃ¡vuotna.no", "nedre-eiker.no", "nesna.no", "nesodden.no", "nesseby.no", "nesset.no", "nissedal.no", "nittedal.no", "nord-aurdal.no", "nord-fron.no", "nord-odal.no", "norddal.no", "nordkapp.no", "bo.nordland.no", "bÃ¸.nordland.no", "heroy.nordland.no", "herÃ¸y.nordland.no", "nordre-land.no", "nordreisa.no", "nore-og-uvdal.no", "notodden.no", "notteroy.no", "nÃ¸tterÃ¸y.no", "odda.no", "oksnes.no", "Ã¸ksnes.no", "omasvuotna.no", "oppdal.no", "oppegard.no", "oppegÃ¥rd.no", "orkdal.no", "orland.no", "Ã¸rland.no", "orskog.no", "Ã¸rskog.no", "orsta.no", "Ã¸rsta.no", "osen.no", "osteroy.no", "osterÃ¸y.no", "valer.ostfold.no", "vÃ¥ler.Ã¸stfold.no", "ostre-toten.no", "Ã¸stre-toten.no", "overhalla.no", "ovre-eiker.no", "Ã¸vre-eiker.no", "oyer.no", "Ã¸yer.no", "oygarden.no", "Ã¸ygarden.no", "oystre-slidre.no", "Ã¸ystre-slidre.no", "porsanger.no", "porsangu.no", "porsÃ¡Å‹gu.no", "porsgrunn.no", "rade.no", "rÃ¥de.no", "radoy.no", "radÃ¸y.no", "rÃ¦lingen.no", "rahkkeravju.no", "rÃ¡hkkerÃ¡vju.no", "raisa.no", "rÃ¡isa.no", "rakkestad.no", "ralingen.no", "rana.no", "randaberg.no", "rauma.no", "rendalen.no", "rennebu.no", "rennesoy.no", "rennesÃ¸y.no", "rindal.no", "ringebu.no", "ringerike.no", "ringsaker.no", "risor.no", "risÃ¸r.no", "rissa.no", "roan.no", "rodoy.no", "rÃ¸dÃ¸y.no", "rollag.no", "romsa.no", "romskog.no", "rÃ¸mskog.no", "roros.no", "rÃ¸ros.no", "rost.no", "rÃ¸st.no", "royken.no", "rÃ¸yken.no", "royrvik.no", "rÃ¸yrvik.no", "ruovat.no", "rygge.no", "salangen.no", "salat.no", "sÃ¡lat.no", "sÃ¡lÃ¡t.no", "saltdal.no", "samnanger.no", "sandefjord.no", "sandnes.no", "sandoy.no", "sandÃ¸y.no", "sarpsborg.no", "sauda.no", "sauherad.no", "sel.no", "selbu.no", "selje.no", "seljord.no", "siellak.no", "sigdal.no", "siljan.no", "sirdal.no", "skanit.no", "skÃ¡nit.no", "skanland.no", "skÃ¥nland.no", "skaun.no", "skedsmo.no", "ski.no", "skien.no", "skierva.no", "skiervÃ¡.no", "skiptvet.no", "skjak.no", "skjÃ¥k.no", "skjervoy.no", "skjervÃ¸y.no", "skodje.no", "smola.no", "smÃ¸la.no", "snaase.no", "snÃ¥ase.no", "snasa.no", "snÃ¥sa.no", "snillfjord.no", "snoasa.no", "sogndal.no", "sogne.no", "sÃ¸gne.no", "sokndal.no", "sola.no", "solund.no", "somna.no", "sÃ¸mna.no", "sondre-land.no", "sÃ¸ndre-land.no", "songdalen.no", "sor-aurdal.no", "sÃ¸r-aurdal.no", "sor-fron.no", "sÃ¸r-fron.no", "sor-odal.no", "sÃ¸r-odal.no", "sor-varanger.no", "sÃ¸r-varanger.no", "sorfold.no", "sÃ¸rfold.no", "sorreisa.no", "sÃ¸rreisa.no", "sortland.no", "sorum.no", "sÃ¸rum.no", "spydeberg.no", "stange.no", "stavanger.no", "steigen.no", "steinkjer.no", "stjordal.no", "stjÃ¸rdal.no", "stokke.no", "stor-elvdal.no", "stord.no", "stordal.no", "storfjord.no", "strand.no", "stranda.no", "stryn.no", "sula.no", "suldal.no", "sund.no", "sunndal.no", "surnadal.no", "sveio.no", "svelvik.no", "sykkylven.no", "tana.no", "bo.telemark.no", "bÃ¸.telemark.no", "time.no", "tingvoll.no", "tinn.no", "tjeldsund.no", "tjome.no", "tjÃ¸me.no", "tokke.no", "tolga.no", "tonsberg.no", "tÃ¸nsberg.no", "torsken.no", "trÃ¦na.no", "trana.no", "tranoy.no", "tranÃ¸y.no", "troandin.no", "trogstad.no", "trÃ¸gstad.no", "tromsa.no", "tromso.no", "tromsÃ¸.no", "trondheim.no", "trysil.no", "tvedestrand.no", "tydal.no", "tynset.no", "tysfjord.no", "tysnes.no", "tysvÃ¦r.no", "tysvar.no", "ullensaker.no", "ullensvang.no", "ulvik.no", "unjarga.no", "unjÃ¡rga.no", "utsira.no", "vaapste.no", "vadso.no", "vadsÃ¸.no", "vÃ¦rÃ¸y.no", "vaga.no", "vÃ¥gÃ¥.no", "vagan.no", "vÃ¥gan.no", "vagsoy.no", "vÃ¥gsÃ¸y.no", "vaksdal.no", "valle.no", "vang.no", "vanylven.no", "vardo.no", "vardÃ¸.no", "varggat.no", "vÃ¡rggÃ¡t.no", "varoy.no", "vefsn.no", "vega.no", "vegarshei.no", "vegÃ¥rshei.no", "vennesla.no", "verdal.no", "verran.no", "vestby.no", "sande.vestfold.no", "vestnes.no", "vestre-slidre.no", "vestre-toten.no", "vestvagoy.no", "vestvÃ¥gÃ¸y.no", "vevelstad.no", "vik.no", "vikna.no", "vindafjord.no", "voagat.no", "volda.no", "voss.no", "*.np", "nr", "biz.nr", "com.nr", "edu.nr", "gov.nr", "info.nr", "net.nr", "org.nr", "nu", "nz", "ac.nz", "co.nz", "cri.nz", "geek.nz", "gen.nz", "govt.nz", "health.nz", "iwi.nz", "kiwi.nz", "maori.nz", "mÄori.nz", "mil.nz", "net.nz", "org.nz", "parliament.nz", "school.nz", "om", "co.om", "com.om", "edu.om", "gov.om", "med.om", "museum.om", "net.om", "org.om", "pro.om", "onion", "org", "pa", "abo.pa", "ac.pa", "com.pa", "edu.pa", "gob.pa", "ing.pa", "med.pa", "net.pa", "nom.pa", "org.pa", "sld.pa", "pe", "com.pe", "edu.pe", "gob.pe", "mil.pe", "net.pe", "nom.pe", "org.pe", "pf", "com.pf", "edu.pf", "org.pf", "*.pg", "ph", "com.ph", "edu.ph", "gov.ph", "i.ph", "mil.ph", "net.ph", "ngo.ph", "org.ph", "pk", "ac.pk", "biz.pk", "com.pk", "edu.pk", "fam.pk", "gkp.pk", "gob.pk", "gog.pk", "gok.pk", "gon.pk", "gop.pk", "gos.pk", "gov.pk", "net.pk", "org.pk", "web.pk", "pl", "com.pl", "net.pl", "org.pl", "agro.pl", "aid.pl", "atm.pl", "auto.pl", "biz.pl", "edu.pl", "gmina.pl", "gsm.pl", "info.pl", "mail.pl", "media.pl", "miasta.pl", "mil.pl", "nieruchomosci.pl", "nom.pl", "pc.pl", "powiat.pl", "priv.pl", "realestate.pl", "rel.pl", "sex.pl", "shop.pl", "sklep.pl", "sos.pl", "szkola.pl", "targi.pl", "tm.pl", "tourism.pl", "travel.pl", "turystyka.pl", "gov.pl", "ap.gov.pl", "griw.gov.pl", "ic.gov.pl", "is.gov.pl", "kmpsp.gov.pl", "konsulat.gov.pl", "kppsp.gov.pl", "kwp.gov.pl", "kwpsp.gov.pl", "mup.gov.pl", "mw.gov.pl", "oia.gov.pl", "oirm.gov.pl", "oke.gov.pl", "oow.gov.pl", "oschr.gov.pl", "oum.gov.pl", "pa.gov.pl", "pinb.gov.pl", "piw.gov.pl", "po.gov.pl", "pr.gov.pl", "psp.gov.pl", "psse.gov.pl", "pup.gov.pl", "rzgw.gov.pl", "sa.gov.pl", "sdn.gov.pl", "sko.gov.pl", "so.gov.pl", "sr.gov.pl", "starostwo.gov.pl", "ug.gov.pl", "ugim.gov.pl", "um.gov.pl", "umig.gov.pl", "upow.gov.pl", "uppo.gov.pl", "us.gov.pl", "uw.gov.pl", "uzs.gov.pl", "wif.gov.pl", "wiih.gov.pl", "winb.gov.pl", "wios.gov.pl", "witd.gov.pl", "wiw.gov.pl", "wkz.gov.pl", "wsa.gov.pl", "wskr.gov.pl", "wsse.gov.pl", "wuoz.gov.pl", "wzmiuw.gov.pl", "zp.gov.pl", "zpisdn.gov.pl", "augustow.pl", "babia-gora.pl", "bedzin.pl", "beskidy.pl", "bialowieza.pl", "bialystok.pl", "bielawa.pl", "bieszczady.pl", "boleslawiec.pl", "bydgoszcz.pl", "bytom.pl", "cieszyn.pl", "czeladz.pl", "czest.pl", "dlugoleka.pl", "elblag.pl", "elk.pl", "glogow.pl", "gniezno.pl", "gorlice.pl", "grajewo.pl", "ilawa.pl", "jaworzno.pl", "jelenia-gora.pl", "jgora.pl", "kalisz.pl", "karpacz.pl", "kartuzy.pl", "kaszuby.pl", "katowice.pl", "kazimierz-dolny.pl", "kepno.pl", "ketrzyn.pl", "klodzko.pl", "kobierzyce.pl", "kolobrzeg.pl", "konin.pl", "konskowola.pl", "kutno.pl", "lapy.pl", "lebork.pl", "legnica.pl", "lezajsk.pl", "limanowa.pl", "lomza.pl", "lowicz.pl", "lubin.pl", "lukow.pl", "malbork.pl", "malopolska.pl", "mazowsze.pl", "mazury.pl", "mielec.pl", "mielno.pl", "mragowo.pl", "naklo.pl", "nowaruda.pl", "nysa.pl", "olawa.pl", "olecko.pl", "olkusz.pl", "olsztyn.pl", "opoczno.pl", "opole.pl", "ostroda.pl", "ostroleka.pl", "ostrowiec.pl", "ostrowwlkp.pl", "pila.pl", "pisz.pl", "podhale.pl", "podlasie.pl", "polkowice.pl", "pomorskie.pl", "pomorze.pl", "prochowice.pl", "pruszkow.pl", "przeworsk.pl", "pulawy.pl", "radom.pl", "rawa-maz.pl", "rybnik.pl", "rzeszow.pl", "sanok.pl", "sejny.pl", "skoczow.pl", "slask.pl", "slupsk.pl", "sosnowiec.pl", "stalowa-wola.pl", "starachowice.pl", "stargard.pl", "suwalki.pl", "swidnica.pl", "swiebodzin.pl", "swinoujscie.pl", "szczecin.pl", "szczytno.pl", "tarnobrzeg.pl", "tgory.pl", "turek.pl", "tychy.pl", "ustka.pl", "walbrzych.pl", "warmia.pl", "warszawa.pl", "waw.pl", "wegrow.pl", "wielun.pl", "wlocl.pl", "wloclawek.pl", "wodzislaw.pl", "wolomin.pl", "wroclaw.pl", "zachpomor.pl", "zagan.pl", "zarow.pl", "zgora.pl", "zgorzelec.pl", "pm", "pn", "co.pn", "edu.pn", "gov.pn", "net.pn", "org.pn", "post", "pr", "biz.pr", "com.pr", "edu.pr", "gov.pr", "info.pr", "isla.pr", "name.pr", "net.pr", "org.pr", "pro.pr", "ac.pr", "est.pr", "prof.pr", "pro", "aaa.pro", "aca.pro", "acct.pro", "avocat.pro", "bar.pro", "cpa.pro", "eng.pro", "jur.pro", "law.pro", "med.pro", "recht.pro", "ps", "com.ps", "edu.ps", "gov.ps", "net.ps", "org.ps", "plo.ps", "sec.ps", "pt", "com.pt", "edu.pt", "gov.pt", "int.pt", "net.pt", "nome.pt", "org.pt", "publ.pt", "pw", "belau.pw", "co.pw", "ed.pw", "go.pw", "or.pw", "py", "com.py", "coop.py", "edu.py", "gov.py", "mil.py", "net.py", "org.py", "qa", "com.qa", "edu.qa", "gov.qa", "mil.qa", "name.qa", "net.qa", "org.qa", "sch.qa", "re", "asso.re", "com.re", "ro", "arts.ro", "com.ro", "firm.ro", "info.ro", "nom.ro", "nt.ro", "org.ro", "rec.ro", "store.ro", "tm.ro", "www.ro", "rs", "ac.rs", "co.rs", "edu.rs", "gov.rs", "in.rs", "org.rs", "ru", "rw", "ac.rw", "co.rw", "coop.rw", "gov.rw", "mil.rw", "net.rw", "org.rw", "sa", "com.sa", "edu.sa", "gov.sa", "med.sa", "net.sa", "org.sa", "pub.sa", "sch.sa", "sb", "com.sb", "edu.sb", "gov.sb", "net.sb", "org.sb", "sc", "com.sc", "edu.sc", "gov.sc", "net.sc", "org.sc", "sd", "com.sd", "edu.sd", "gov.sd", "info.sd", "med.sd", "net.sd", "org.sd", "tv.sd", "se", "a.se", "ac.se", "b.se", "bd.se", "brand.se", "c.se", "d.se", "e.se", "f.se", "fh.se", "fhsk.se", "fhv.se", "g.se", "h.se", "i.se", "k.se", "komforb.se", "kommunalforbund.se", "komvux.se", "l.se", "lanbib.se", "m.se", "n.se", "naturbruksgymn.se", "o.se", "org.se", "p.se", "parti.se", "pp.se", "press.se", "r.se", "s.se", "t.se", "tm.se", "u.se", "w.se", "x.se", "y.se", "z.se", "sg", "com.sg", "edu.sg", "gov.sg", "net.sg", "org.sg", "sh", "com.sh", "gov.sh", "mil.sh", "net.sh", "org.sh", "si", "sj", "sk", "sl", "com.sl", "edu.sl", "gov.sl", "net.sl", "org.sl", "sm", "sn", "art.sn", "com.sn", "edu.sn", "gouv.sn", "org.sn", "perso.sn", "univ.sn", "so", "com.so", "edu.so", "gov.so", "me.so", "net.so", "org.so", "sr", "ss", "biz.ss", "co.ss", "com.ss", "edu.ss", "gov.ss", "me.ss", "net.ss", "org.ss", "sch.ss", "st", "co.st", "com.st", "consulado.st", "edu.st", "embaixada.st", "mil.st", "net.st", "org.st", "principe.st", "saotome.st", "store.st", "su", "sv", "com.sv", "edu.sv", "gob.sv", "org.sv", "red.sv", "sx", "gov.sx", "sy", "com.sy", "edu.sy", "gov.sy", "mil.sy", "net.sy", "org.sy", "sz", "ac.sz", "co.sz", "org.sz", "tc", "td", "tel", "tf", "tg", "th", "ac.th", "co.th", "go.th", "in.th", "mi.th", "net.th", "or.th", "tj", "ac.tj", "biz.tj", "co.tj", "com.tj", "edu.tj", "go.tj", "gov.tj", "int.tj", "mil.tj", "name.tj", "net.tj", "nic.tj", "org.tj", "test.tj", "web.tj", "tk", "tl", "gov.tl", "tm", "co.tm", "com.tm", "edu.tm", "gov.tm", "mil.tm", "net.tm", "nom.tm", "org.tm", "tn", "com.tn", "ens.tn", "fin.tn", "gov.tn", "ind.tn", "info.tn", "intl.tn", "mincom.tn", "nat.tn", "net.tn", "org.tn", "perso.tn", "tourism.tn", "to", "com.to", "edu.to", "gov.to", "mil.to", "net.to", "org.to", "tr", "av.tr", "bbs.tr", "bel.tr", "biz.tr", "com.tr", "dr.tr", "edu.tr", "gen.tr", "gov.tr", "info.tr", "k12.tr", "kep.tr", "mil.tr", "name.tr", "net.tr", "org.tr", "pol.tr", "tel.tr", "tsk.tr", "tv.tr", "web.tr", "nc.tr", "gov.nc.tr", "tt", "biz.tt", "co.tt", "com.tt", "edu.tt", "gov.tt", "info.tt", "mil.tt", "name.tt", "net.tt", "org.tt", "pro.tt", "tv", "tw", "club.tw", "com.tw", "ebiz.tw", "edu.tw", "game.tw", "gov.tw", "idv.tw", "mil.tw", "net.tw", "org.tw", "tz", "ac.tz", "co.tz", "go.tz", "hotel.tz", "info.tz", "me.tz", "mil.tz", "mobi.tz", "ne.tz", "or.tz", "sc.tz", "tv.tz", "ua", "com.ua", "edu.ua", "gov.ua", "in.ua", "net.ua", "org.ua", "cherkassy.ua", "cherkasy.ua", "chernigov.ua", "chernihiv.ua", "chernivtsi.ua", "chernovtsy.ua", "ck.ua", "cn.ua", "cr.ua", "crimea.ua", "cv.ua", "dn.ua", "dnepropetrovsk.ua", "dnipropetrovsk.ua", "donetsk.ua", "dp.ua", "if.ua", "ivano-frankivsk.ua", "kh.ua", "kharkiv.ua", "kharkov.ua", "kherson.ua", "khmelnitskiy.ua", "khmelnytskyi.ua", "kiev.ua", "kirovograd.ua", "km.ua", "kr.ua", "kropyvnytskyi.ua", "krym.ua", "ks.ua", "kv.ua", "kyiv.ua", "lg.ua", "lt.ua", "lugansk.ua", "luhansk.ua", "lutsk.ua", "lv.ua", "lviv.ua", "mk.ua", "mykolaiv.ua", "nikolaev.ua", "od.ua", "odesa.ua", "odessa.ua", "pl.ua", "poltava.ua", "rivne.ua", "rovno.ua", "rv.ua", "sb.ua", "sebastopol.ua", "sevastopol.ua", "sm.ua", "sumy.ua", "te.ua", "ternopil.ua", "uz.ua", "uzhgorod.ua", "uzhhorod.ua", "vinnica.ua", "vinnytsia.ua", "vn.ua", "volyn.ua", "yalta.ua", "zakarpattia.ua", "zaporizhzhe.ua", "zaporizhzhia.ua", "zhitomir.ua", "zhytomyr.ua", "zp.ua", "zt.ua", "ug", "ac.ug", "co.ug", "com.ug", "go.ug", "ne.ug", "or.ug", "org.ug", "sc.ug", "uk", "ac.uk", "co.uk", "gov.uk", "ltd.uk", "me.uk", "net.uk", "nhs.uk", "org.uk", "plc.uk", "police.uk", "*.sch.uk", "us", "dni.us", "fed.us", "isa.us", "kids.us", "nsn.us", "ak.us", "al.us", "ar.us", "as.us", "az.us", "ca.us", "co.us", "ct.us", "dc.us", "de.us", "fl.us", "ga.us", "gu.us", "hi.us", "ia.us", "id.us", "il.us", "in.us", "ks.us", "ky.us", "la.us", "ma.us", "md.us", "me.us", "mi.us", "mn.us", "mo.us", "ms.us", "mt.us", "nc.us", "nd.us", "ne.us", "nh.us", "nj.us", "nm.us", "nv.us", "ny.us", "oh.us", "ok.us", "or.us", "pa.us", "pr.us", "ri.us", "sc.us", "sd.us", "tn.us", "tx.us", "ut.us", "va.us", "vi.us", "vt.us", "wa.us", "wi.us", "wv.us", "wy.us", "k12.ak.us", "k12.al.us", "k12.ar.us", "k12.as.us", "k12.az.us", "k12.ca.us", "k12.co.us", "k12.ct.us", "k12.dc.us", "k12.fl.us", "k12.ga.us", "k12.gu.us", "k12.ia.us", "k12.id.us", "k12.il.us", "k12.in.us", "k12.ks.us", "k12.ky.us", "k12.la.us", "k12.ma.us", "k12.md.us", "k12.me.us", "k12.mi.us", "k12.mn.us", "k12.mo.us", "k12.ms.us", "k12.mt.us", "k12.nc.us", "k12.ne.us", "k12.nh.us", "k12.nj.us", "k12.nm.us", "k12.nv.us", "k12.ny.us", "k12.oh.us", "k12.ok.us", "k12.or.us", "k12.pa.us", "k12.pr.us", "k12.sc.us", "k12.tn.us", "k12.tx.us", "k12.ut.us", "k12.va.us", "k12.vi.us", "k12.vt.us", "k12.wa.us", "k12.wi.us", "cc.ak.us", "lib.ak.us", "cc.al.us", "lib.al.us", "cc.ar.us", "lib.ar.us", "cc.as.us", "lib.as.us", "cc.az.us", "lib.az.us", "cc.ca.us", "lib.ca.us", "cc.co.us", "lib.co.us", "cc.ct.us", "lib.ct.us", "cc.dc.us", "lib.dc.us", "cc.de.us", "cc.fl.us", "cc.ga.us", "cc.gu.us", "cc.hi.us", "cc.ia.us", "cc.id.us", "cc.il.us", "cc.in.us", "cc.ks.us", "cc.ky.us", "cc.la.us", "cc.ma.us", "cc.md.us", "cc.me.us", "cc.mi.us", "cc.mn.us", "cc.mo.us", "cc.ms.us", "cc.mt.us", "cc.nc.us", "cc.nd.us", "cc.ne.us", "cc.nh.us", "cc.nj.us", "cc.nm.us", "cc.nv.us", "cc.ny.us", "cc.oh.us", "cc.ok.us", "cc.or.us", "cc.pa.us", "cc.pr.us", "cc.ri.us", "cc.sc.us", "cc.sd.us", "cc.tn.us", "cc.tx.us", "cc.ut.us", "cc.va.us", "cc.vi.us", "cc.vt.us", "cc.wa.us", "cc.wi.us", "cc.wv.us", "cc.wy.us", "k12.wy.us", "lib.fl.us", "lib.ga.us", "lib.gu.us", "lib.hi.us", "lib.ia.us", "lib.id.us", "lib.il.us", "lib.in.us", "lib.ks.us", "lib.ky.us", "lib.la.us", "lib.ma.us", "lib.md.us", "lib.me.us", "lib.mi.us", "lib.mn.us", "lib.mo.us", "lib.ms.us", "lib.mt.us", "lib.nc.us", "lib.nd.us", "lib.ne.us", "lib.nh.us", "lib.nj.us", "lib.nm.us", "lib.nv.us", "lib.ny.us", "lib.oh.us", "lib.ok.us", "lib.or.us", "lib.pa.us", "lib.pr.us", "lib.ri.us", "lib.sc.us", "lib.sd.us", "lib.tn.us", "lib.tx.us", "lib.ut.us", "lib.va.us", "lib.vi.us", "lib.vt.us", "lib.wa.us", "lib.wi.us", "lib.wy.us", "chtr.k12.ma.us", "paroch.k12.ma.us", "pvt.k12.ma.us", "ann-arbor.mi.us", "cog.mi.us", "dst.mi.us", "eaton.mi.us", "gen.mi.us", "mus.mi.us", "tec.mi.us", "washtenaw.mi.us", "uy", "com.uy", "edu.uy", "gub.uy", "mil.uy", "net.uy", "org.uy", "uz", "co.uz", "com.uz", "net.uz", "org.uz", "va", "vc", "com.vc", "edu.vc", "gov.vc", "mil.vc", "net.vc", "org.vc", "ve", "arts.ve", "bib.ve", "co.ve", "com.ve", "e12.ve", "edu.ve", "firm.ve", "gob.ve", "gov.ve", "info.ve", "int.ve", "mil.ve", "net.ve", "nom.ve", "org.ve", "rar.ve", "rec.ve", "store.ve", "tec.ve", "web.ve", "vg", "vi", "co.vi", "com.vi", "k12.vi", "net.vi", "org.vi", "vn", "ac.vn", "ai.vn", "biz.vn", "com.vn", "edu.vn", "gov.vn", "health.vn", "id.vn", "info.vn", "int.vn", "io.vn", "name.vn", "net.vn", "org.vn", "pro.vn", "angiang.vn", "bacgiang.vn", "backan.vn", "baclieu.vn", "bacninh.vn", "baria-vungtau.vn", "bentre.vn", "binhdinh.vn", "binhduong.vn", "binhphuoc.vn", "binhthuan.vn", "camau.vn", "cantho.vn", "caobang.vn", "daklak.vn", "daknong.vn", "danang.vn", "dienbien.vn", "dongnai.vn", "dongthap.vn", "gialai.vn", "hagiang.vn", "haiduong.vn", "haiphong.vn", "hanam.vn", "hanoi.vn", "hatinh.vn", "haugiang.vn", "hoabinh.vn", "hungyen.vn", "khanhhoa.vn", "kiengiang.vn", "kontum.vn", "laichau.vn", "lamdong.vn", "langson.vn", "laocai.vn", "longan.vn", "namdinh.vn", "nghean.vn", "ninhbinh.vn", "ninhthuan.vn", "phutho.vn", "phuyen.vn", "quangbinh.vn", "quangnam.vn", "quangngai.vn", "quangninh.vn", "quangtri.vn", "soctrang.vn", "sonla.vn", "tayninh.vn", "thaibinh.vn", "thainguyen.vn", "thanhhoa.vn", "thanhphohochiminh.vn", "thuathienhue.vn", "tiengiang.vn", "travinh.vn", "tuyenquang.vn", "vinhlong.vn", "vinhphuc.vn", "yenbai.vn", "vu", "com.vu", "edu.vu", "net.vu", "org.vu", "wf", "ws", "com.ws", "edu.ws", "gov.ws", "net.ws", "org.ws", "yt", "Ø§Ù…Ø§Ø±Ø§Øª", "Õ°Õ¡Õµ", "à¦¬à¦¾à¦‚à¦²à¦¾", "Ð±Ð³", "Ø§Ù„Ø¨Ø­Ø±ÙŠÙ†", "Ð±ÐµÐ»", "ä¸­å›½", "ä¸­åœ‹", "Ø§Ù„Ø¬Ø²Ø§Ø¦Ø±", "Ù…ØµØ±", "ÐµÑŽ", "ÎµÏ…", "Ù…ÙˆØ±ÙŠØªØ§Ù†ÙŠØ§", "áƒ’áƒ”", "ÎµÎ»", "é¦™æ¸¯", "å€‹äºº.é¦™æ¸¯", "å…¬å¸.é¦™æ¸¯", "æ”¿åºœ.é¦™æ¸¯", "æ•™è‚².é¦™æ¸¯", "çµ„ç¹”.é¦™æ¸¯", "ç¶²çµ¡.é¦™æ¸¯", "à²­à²¾à²°à²¤", "à¬­à¬¾à¬°à¬¤", "à¦­à¦¾à§°à¦¤", "à¤­à¤¾à¤°à¤¤à¤®à¥", "à¤­à¤¾à¤°à¥‹à¤¤", "Ú€Ø§Ø±Øª", "à´­à´¾à´°à´¤à´‚", "à¤­à¤¾à¤°à¤¤", "Ø¨Ø§Ø±Øª", "Ø¨Ú¾Ø§Ø±Øª", "à°­à°¾à°°à°¤à±", "àª­àª¾àª°àª¤", "à¨­à¨¾à¨°à¨¤", "à¦­à¦¾à¦°à¦¤", "à®‡à®¨à¯à®¤à®¿à®¯à®¾", "Ø§ÛŒØ±Ø§Ù†", "Ø§ÙŠØ±Ø§Ù†", "Ø¹Ø±Ø§Ù‚", "Ø§Ù„Ø§Ø±Ø¯Ù†", "í•œêµ­", "Ò›Ð°Ð·", "àº¥àº²àº§", "à¶½à¶‚à¶šà·", "à®‡à®²à®™à¯à®•à¯ˆ", "Ø§Ù„Ù…ØºØ±Ø¨", "Ð¼ÐºÐ´", "Ð¼Ð¾Ð½", "æ¾³é–€", "æ¾³é—¨", "Ù…Ù„ÙŠØ³ÙŠØ§", "Ø¹Ù…Ø§Ù†", "Ù¾Ø§Ú©Ø³ØªØ§Ù†", "Ù¾Ø§ÙƒØ³ØªØ§Ù†", "ÙÙ„Ø³Ø·ÙŠÙ†", "ÑÑ€Ð±", "Ð°Ðº.ÑÑ€Ð±", "Ð¾Ð±Ñ€.ÑÑ€Ð±", "Ð¾Ð´.ÑÑ€Ð±", "Ð¾Ñ€Ð³.ÑÑ€Ð±", "Ð¿Ñ€.ÑÑ€Ð±", "ÑƒÐ¿Ñ€.ÑÑ€Ð±", "Ñ€Ñ„", "Ù‚Ø·Ø±", "Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ©", "Ø§Ù„Ø³Ø¹ÙˆØ¯ÛŒØ©", "Ø§Ù„Ø³Ø¹ÙˆØ¯ÛŒÛƒ", "Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠÙ‡", "Ø³ÙˆØ¯Ø§Ù†", "æ–°åŠ å¡", "à®šà®¿à®™à¯à®•à®ªà¯à®ªà¯‚à®°à¯", "Ø³ÙˆØ±ÙŠØ©", "Ø³ÙˆØ±ÙŠØ§", "à¹„à¸—à¸¢", "à¸—à¸«à¸²à¸£.à¹„à¸—à¸¢", "à¸˜à¸¸à¸£à¸à¸´à¸ˆ.à¹„à¸—à¸¢", "à¹€à¸™à¹‡à¸•.à¹„à¸—à¸¢", "à¸£à¸±à¸à¸šà¸²à¸¥.à¹„à¸—à¸¢", "à¸¨à¸¶à¸à¸©à¸².à¹„à¸—à¸¢", "à¸­à¸‡à¸„à¹Œà¸à¸£.à¹„à¸—à¸¢", "ØªÙˆÙ†Ø³", "å°ç£", "å°æ¹¾", "è‡ºç£", "ÑƒÐºÑ€", "Ø§Ù„ÙŠÙ…Ù†", "xxx", "ye", "com.ye", "edu.ye", "gov.ye", "mil.ye", "net.ye", "org.ye", "ac.za", "agric.za", "alt.za", "co.za", "edu.za", "gov.za", "grondar.za", "law.za", "mil.za", "net.za", "ngo.za", "nic.za", "nis.za", "nom.za", "org.za", "school.za", "tm.za", "web.za", "zm", "ac.zm", "biz.zm", "co.zm", "com.zm", "edu.zm", "gov.zm", "info.zm", "mil.zm", "net.zm", "org.zm", "sch.zm", "zw", "ac.zw", "co.zw", "gov.zw", "mil.zw", "org.zw", "aaa", "aarp", "abb", "abbott", "abbvie", "abc", "able", "abogado", "abudhabi", "academy", "accenture", "accountant", "accountants", "aco", "actor", "ads", "adult", "aeg", "aetna", "afl", "africa", "agakhan", "agency", "aig", "airbus", "airforce", "airtel", "akdn", "alibaba", "alipay", "allfinanz", "allstate", "ally", "alsace", "alstom", "amazon", "americanexpress", "americanfamily", "amex", "amfam", "amica", "amsterdam", "analytics", "android", "anquan", "anz", "aol", "apartments", "app", "apple", "aquarelle", "arab", "aramco", "archi", "army", "art", "arte", "asda", "associates", "athleta", "attorney", "auction", "audi", "audible", "audio", "auspost", "author", "auto", "autos", "aws", "axa", "azure", "baby", "baidu", "banamex", "band", "bank", "bar", "barcelona", "barclaycard", "barclays", "barefoot", "bargains", "baseball", "basketball", "bauhaus", "bayern", "bbc", "bbt", "bbva", "bcg", "bcn", "beats", "beauty", "beer", "bentley", "berlin", "best", "bestbuy", "bet", "bharti", "bible", "bid", "bike", "bing", "bingo", "bio", "black", "blackfriday", "blockbuster", "blog", "bloomberg", "blue", "bms", "bmw", "bnpparibas", "boats", "boehringer", "bofa", "bom", "bond", "boo", "book", "booking", "bosch", "bostik", "boston", "bot", "boutique", "box", "bradesco", "bridgestone", "broadway", "broker", "brother", "brussels", "build", "builders", "business", "buy", "buzz", "bzh", "cab", "cafe", "cal", "call", "calvinklein", "cam", "camera", "camp", "canon", "capetown", "capital", "capitalone", "car", "caravan", "cards", "care", "career", "careers", "cars", "casa", "case", "cash", "casino", "catering", "catholic", "cba", "cbn", "cbre", "center", "ceo", "cern", "cfa", "cfd", "chanel", "channel", "charity", "chase", "chat", "cheap", "chintai", "christmas", "chrome", "church", "cipriani", "circle", "cisco", "citadel", "citi", "citic", "city", "claims", "cleaning", "click", "clinic", "clinique", "clothing", "cloud", "club", "clubmed", "coach", "codes", "coffee", "college", "cologne", "commbank", "community", "company", "compare", "computer", "comsec", "condos", "construction", "consulting", "contact", "contractors", "cooking", "cool", "corsica", "country", "coupon", "coupons", "courses", "cpa", "credit", "creditcard", "creditunion", "cricket", "crown", "crs", "cruise", "cruises", "cuisinella", "cymru", "cyou", "dad", "dance", "data", "date", "dating", "datsun", "day", "dclk", "dds", "deal", "dealer", "deals", "degree", "delivery", "dell", "deloitte", "delta", "democrat", "dental", "dentist", "desi", "design", "dev", "dhl", "diamonds", "diet", "digital", "direct", "directory", "discount", "discover", "dish", "diy", "dnp", "docs", "doctor", "dog", "domains", "dot", "download", "drive", "dtv", "dubai", "dunlop", "dupont", "durban", "dvag", "dvr", "earth", "eat", "eco", "edeka", "education", "email", "emerck", "energy", "engineer", "engineering", "enterprises", "epson", "equipment", "ericsson", "erni", "esq", "estate", "eurovision", "eus", "events", "exchange", "expert", "exposed", "express", "extraspace", "fage", "fail", "fairwinds", "faith", "family", "fan", "fans", "farm", "farmers", "fashion", "fast", "fedex", "feedback", "ferrari", "ferrero", "fidelity", "fido", "film", "final", "finance", "financial", "fire", "firestone", "firmdale", "fish", "fishing", "fit", "fitness", "flickr", "flights", "flir", "florist", "flowers", "fly", "foo", "food", "football", "ford", "forex", "forsale", "forum", "foundation", "fox", "free", "fresenius", "frl", "frogans", "frontier", "ftr", "fujitsu", "fun", "fund", "furniture", "futbol", "fyi", "gal", "gallery", "gallo", "gallup", "game", "games", "gap", "garden", "gay", "gbiz", "gdn", "gea", "gent", "genting", "george", "ggee", "gift", "gifts", "gives", "giving", "glass", "gle", "global", "globo", "gmail", "gmbh", "gmo", "gmx", "godaddy", "gold", "goldpoint", "golf", "goo", "goodyear", "goog", "google", "gop", "got", "grainger", "graphics", "gratis", "green", "gripe", "grocery", "group", "gucci", "guge", "guide", "guitars", "guru", "hair", "hamburg", "hangout", "haus", "hbo", "hdfc", "hdfcbank", "health", "healthcare", "help", "helsinki", "here", "hermes", "hiphop", "hisamitsu", "hitachi", "hiv", "hkt", "hockey", "holdings", "holiday", "homedepot", "homegoods", "homes", "homesense", "honda", "horse", "hospital", "host", "hosting", "hot", "hotels", "hotmail", "house", "how", "hsbc", "hughes", "hyatt", "hyundai", "ibm", "icbc", "ice", "icu", "ieee", "ifm", "ikano", "imamat", "imdb", "immo", "immobilien", "inc", "industries", "infiniti", "ing", "ink", "institute", "insurance", "insure", "international", "intuit", "investments", "ipiranga", "irish", "ismaili", "ist", "istanbul", "itau", "itv", "jaguar", "java", "jcb", "jeep", "jetzt", "jewelry", "jio", "jll", "jmp", "jnj", "joburg", "jot", "joy", "jpmorgan", "jprs", "juegos", "juniper", "kaufen", "kddi", "kerryhotels", "kerrylogistics", "kerryproperties", "kfh", "kia", "kids", "kim", "kindle", "kitchen", "kiwi", "koeln", "komatsu", "kosher", "kpmg", "kpn", "krd", "kred", "kuokgroup", "kyoto", "lacaixa", "lamborghini", "lamer", "lancaster", "land", "landrover", "lanxess", "lasalle", "lat", "latino", "latrobe", "law", "lawyer", "lds", "lease", "leclerc", "lefrak", "legal", "lego", "lexus", "lgbt", "lidl", "life", "lifeinsurance", "lifestyle", "lighting", "like", "lilly", "limited", "limo", "lincoln", "link", "lipsy", "live", "living", "llc", "llp", "loan", "loans", "locker", "locus", "lol", "london", "lotte", "lotto", "love", "lpl", "lplfinancial", "ltd", "ltda", "lundbeck", "luxe", "luxury", "madrid", "maif", "maison", "makeup", "man", "management", "mango", "map", "market", "marketing", "markets", "marriott", "marshalls", "mattel", "mba", "mckinsey", "med", "media", "meet", "melbourne", "meme", "memorial", "men", "menu", "merck", "merckmsd", "miami", "microsoft", "mini", "mint", "mit", "mitsubishi", "mlb", "mls", "mma", "mobile", "moda", "moe", "moi", "mom", "monash", "money", "monster", "mormon", "mortgage", "moscow", "moto", "motorcycles", "mov", "movie", "msd", "mtn", "mtr", "music", "nab", "nagoya", "navy", "nba", "nec", "netbank", "netflix", "network", "neustar", "new", "news", "next", "nextdirect", "nexus", "nfl", "ngo", "nhk", "nico", "nike", "nikon", "ninja", "nissan", "nissay", "nokia", "norton", "now", "nowruz", "nowtv", "nra", "nrw", "ntt", "nyc", "obi", "observer", "office", "okinawa", "olayan", "olayangroup", "ollo", "omega", "one", "ong", "onl", "online", "ooo", "open", "oracle", "orange", "organic", "origins", "osaka", "otsuka", "ott", "ovh", "page", "panasonic", "paris", "pars", "partners", "parts", "party", "pay", "pccw", "pet", "pfizer", "pharmacy", "phd", "philips", "phone", "photo", "photography", "photos", "physio", "pics", "pictet", "pictures", "pid", "pin", "ping", "pink", "pioneer", "pizza", "place", "play", "playstation", "plumbing", "plus", "pnc", "pohl", "poker", "politie", "porn", "pramerica", "praxi", "press", "prime", "prod", "productions", "prof", "progressive", "promo", "properties", "property", "protection", "pru", "prudential", "pub", "pwc", "qpon", "quebec", "quest", "racing", "radio", "read", "realestate", "realtor", "realty", "recipes", "red", "redstone", "redumbrella", "rehab", "reise", "reisen", "reit", "reliance", "ren", "rent", "rentals", "repair", "report", "republican", "rest", "restaurant", "review", "reviews", "rexroth", "rich", "richardli", "ricoh", "ril", "rio", "rip", "rocks", "rodeo", "rogers", "room", "rsvp", "rugby", "ruhr", "run", "rwe", "ryukyu", "saarland", "safe", "safety", "sakura", "sale", "salon", "samsclub", "samsung", "sandvik", "sandvikcoromant", "sanofi", "sap", "sarl", "sas", "save", "saxo", "sbi", "sbs", "scb", "schaeffler", "schmidt", "scholarships", "school", "schule", "schwarz", "science", "scot", "search", "seat", "secure", "security", "seek", "select", "sener", "services", "seven", "sew", "sex", "sexy", "sfr", "shangrila", "sharp", "shell", "shia", "shiksha", "shoes", "shop", "shopping", "shouji", "show", "silk", "sina", "singles", "site", "ski", "skin", "sky", "skype", "sling", "smart", "smile", "sncf", "soccer", "social", "softbank", "software", "sohu", "solar", "solutions", "song", "sony", "soy", "spa", "space", "sport", "spot", "srl", "stada", "staples", "star", "statebank", "statefarm", "stc", "stcgroup", "stockholm", "storage", "store", "stream", "studio", "study", "style", "sucks", "supplies", "supply", "support", "surf", "surgery", "suzuki", "swatch", "swiss", "sydney", "systems", "tab", "taipei", "talk", "taobao", "target", "tatamotors", "tatar", "tattoo", "tax", "taxi", "tci", "tdk", "team", "tech", "technology", "temasek", "tennis", "teva", "thd", "theater", "theatre", "tiaa", "tickets", "tienda", "tips", "tires", "tirol", "tjmaxx", "tjx", "tkmaxx", "tmall", "today", "tokyo", "tools", "top", "toray", "toshiba", "total", "tours", "town", "toyota", "toys", "trade", "trading", "training", "travel", "travelers", "travelersinsurance", "trust", "trv", "tube", "tui", "tunes", "tushu", "tvs", "ubank", "ubs", "unicom", "university", "uno", "uol", "ups", "vacations", "vana", "vanguard", "vegas", "ventures", "verisign", "versicherung", "vet", "viajes", "video", "vig", "viking", "villas", "vin", "vip", "virgin", "visa", "vision", "viva", "vivo", "vlaanderen", "vodka", "volvo", "vote", "voting", "voto", "voyage", "wales", "walmart", "walter", "wang", "wanggou", "watch", "watches", "weather", "weatherchannel", "webcam", "weber", "website", "wed", "wedding", "weibo", "weir", "whoswho", "wien", "wiki", "williamhill", "win", "windows", "wine", "winners", "wme", "wolterskluwer", "woodside", "work", "works", "world", "wow", "wtc", "wtf", "xbox", "xerox", "xihuan", "xin", "à¤•à¥‰à¤®", "ã‚»ãƒ¼ãƒ«", "ä½›å±±", "æ…ˆå–„", "é›†å›¢", "åœ¨çº¿", "ç‚¹çœ‹", "à¸„à¸­à¸¡", "å…«å¦", "Ù…ÙˆÙ‚Ø¹", "å…¬ç›Š", "å…¬å¸", "é¦™æ ¼é‡Œæ‹‰", "ç½‘ç«™", "ç§»åŠ¨", "æˆ‘çˆ±ä½ ", "Ð¼Ð¾ÑÐºÐ²Ð°", "ÐºÐ°Ñ‚Ð¾Ð»Ð¸Ðº", "Ð¾Ð½Ð»Ð°Ð¹Ð½", "ÑÐ°Ð¹Ñ‚", "è”é€š", "×§×•×", "æ—¶å°š", "å¾®åš", "æ·¡é©¬é”¡", "ãƒ•ã‚¡ãƒƒã‚·ãƒ§ãƒ³", "Ð¾Ñ€Ð³", "à¤¨à¥‡à¤Ÿ", "ã‚¹ãƒˆã‚¢", "ã‚¢ãƒžã‚¾ãƒ³", "ì‚¼ì„±", "å•†æ ‡", "å•†åº—", "å•†åŸŽ", "Ð´ÐµÑ‚Ð¸", "ãƒã‚¤ãƒ³ãƒˆ", "æ–°é—»", "å®¶é›»", "ÙƒÙˆÙ…", "ä¸­æ–‡ç½‘", "ä¸­ä¿¡", "å¨±ä¹", "è°·æ­Œ", "é›»è¨Šç›ˆç§‘", "è´­ç‰©", "ã‚¯ãƒ©ã‚¦ãƒ‰", "é€šè²©", "ç½‘åº—", "à¤¸à¤‚à¤—à¤ à¤¨", "é¤åŽ…", "ç½‘ç»œ", "ÐºÐ¾Ð¼", "äºšé©¬é€Š", "é£Ÿå“", "é£žåˆ©æµ¦", "æ‰‹æœº", "Ø§Ø±Ø§Ù…ÙƒÙˆ", "Ø§Ù„Ø¹Ù„ÙŠØ§Ù†", "Ø¨Ø§Ø²Ø§Ø±", "Ø§Ø¨ÙˆØ¸Ø¨ÙŠ", "ÙƒØ§Ø«ÙˆÙ„ÙŠÙƒ", "Ù‡Ù…Ø±Ø§Ù‡", "ë‹·ì»´", "æ”¿åºœ", "Ø´Ø¨ÙƒØ©", "Ø¨ÙŠØªÙƒ", "Ø¹Ø±Ø¨", "æœºæž„", "ç»„ç»‡æœºæž„", "å¥åº·", "æ‹›è˜", "Ñ€ÑƒÑ", "å¤§æ‹¿", "ã¿ã‚“ãª", "ã‚°ãƒ¼ã‚°ãƒ«", "ä¸–ç•Œ", "æ›¸ç±", "ç½‘å€", "ë‹·ë„·", "ã‚³ãƒ ", "å¤©ä¸»æ•™", "æ¸¸æˆ", "vermÃ¶gensberater", "vermÃ¶gensberatung", "ä¼ä¸š", "ä¿¡æ¯", "å˜‰é‡Œå¤§é…’åº—", "å˜‰é‡Œ", "å¹¿ä¸œ", "æ”¿åŠ¡", "xyz", "yachts", "yahoo", "yamaxun", "yandex", "yodobashi", "yoga", "yokohama", "you", "youtube", "yun", "zappos", "zara", "zero", "zip", "zone", "zuerich", "co.krd", "edu.krd", "art.pl", "gliwice.pl", "krakow.pl", "poznan.pl", "wroc.pl", "zakopane.pl", "lib.de.us", "12chars.dev", "12chars.it", "12chars.pro", "cc.ua", "inf.ua", "ltd.ua", "611.to", "a2hosted.com", "cpserver.com", "aaa.vodka", "*.on-acorn.io", "activetrail.biz", "adaptable.app", "adobeaemcloud.com", "*.dev.adobeaemcloud.com", "aem.live", "hlx.live", "adobeaemcloud.net", "aem.page", "hlx.page", "hlx3.page", "adobeio-static.net", "adobeioruntime.net", "africa.com", "beep.pl", "airkitapps.com", "airkitapps-au.com", "airkitapps.eu", "aivencloud.com", "akadns.net", "akamai.net", "akamai-staging.net", "akamaiedge.net", "akamaiedge-staging.net", "akamaihd.net", "akamaihd-staging.net", "akamaiorigin.net", "akamaiorigin-staging.net", "akamaized.net", "akamaized-staging.net", "edgekey.net", "edgekey-staging.net", "edgesuite.net", "edgesuite-staging.net", "barsy.ca", "*.compute.estate", "*.alces.network", "kasserver.com", "altervista.org", "alwaysdata.net", "myamaze.net", "execute-api.cn-north-1.amazonaws.com.cn", "execute-api.cn-northwest-1.amazonaws.com.cn", "execute-api.af-south-1.amazonaws.com", "execute-api.ap-east-1.amazonaws.com", "execute-api.ap-northeast-1.amazonaws.com", "execute-api.ap-northeast-2.amazonaws.com", "execute-api.ap-northeast-3.amazonaws.com", "execute-api.ap-south-1.amazonaws.com", "execute-api.ap-south-2.amazonaws.com", "execute-api.ap-southeast-1.amazonaws.com", "execute-api.ap-southeast-2.amazonaws.com", "execute-api.ap-southeast-3.amazonaws.com", "execute-api.ap-southeast-4.amazonaws.com", "execute-api.ap-southeast-5.amazonaws.com", "execute-api.ca-central-1.amazonaws.com", "execute-api.ca-west-1.amazonaws.com", "execute-api.eu-central-1.amazonaws.com", "execute-api.eu-central-2.amazonaws.com", "execute-api.eu-north-1.amazonaws.com", "execute-api.eu-south-1.amazonaws.com", "execute-api.eu-south-2.amazonaws.com", "execute-api.eu-west-1.amazonaws.com", "execute-api.eu-west-2.amazonaws.com", "execute-api.eu-west-3.amazonaws.com", "execute-api.il-central-1.amazonaws.com", "execute-api.me-central-1.amazonaws.com", "execute-api.me-south-1.amazonaws.com", "execute-api.sa-east-1.amazonaws.com", "execute-api.us-east-1.amazonaws.com", "execute-api.us-east-2.amazonaws.com", "execute-api.us-gov-east-1.amazonaws.com", "execute-api.us-gov-west-1.amazonaws.com", "execute-api.us-west-1.amazonaws.com", "execute-api.us-west-2.amazonaws.com", "cloudfront.net", "auth.af-south-1.amazoncognito.com", "auth.ap-east-1.amazoncognito.com", "auth.ap-northeast-1.amazoncognito.com", "auth.ap-northeast-2.amazoncognito.com", "auth.ap-northeast-3.amazoncognito.com", "auth.ap-south-1.amazoncognito.com", "auth.ap-south-2.amazoncognito.com", "auth.ap-southeast-1.amazoncognito.com", "auth.ap-southeast-2.amazoncognito.com", "auth.ap-southeast-3.amazoncognito.com", "auth.ap-southeast-4.amazoncognito.com", "auth.ca-central-1.amazoncognito.com", "auth.ca-west-1.amazoncognito.com", "auth.eu-central-1.amazoncognito.com", "auth.eu-central-2.amazoncognito.com", "auth.eu-north-1.amazoncognito.com", "auth.eu-south-1.amazoncognito.com", "auth.eu-south-2.amazoncognito.com", "auth.eu-west-1.amazoncognito.com", "auth.eu-west-2.amazoncognito.com", "auth.eu-west-3.amazoncognito.com", "auth.il-central-1.amazoncognito.com", "auth.me-central-1.amazoncognito.com", "auth.me-south-1.amazoncognito.com", "auth.sa-east-1.amazoncognito.com", "auth.us-east-1.amazoncognito.com", "auth-fips.us-east-1.amazoncognito.com", "auth.us-east-2.amazoncognito.com", "auth-fips.us-east-2.amazoncognito.com", "auth-fips.us-gov-west-1.amazoncognito.com", "auth.us-west-1.amazoncognito.com", "auth-fips.us-west-1.amazoncognito.com", "auth.us-west-2.amazoncognito.com", "auth-fips.us-west-2.amazoncognito.com", "*.compute.amazonaws.com.cn", "*.compute.amazonaws.com", "*.compute-1.amazonaws.com", "us-east-1.amazonaws.com", "emrappui-prod.cn-north-1.amazonaws.com.cn", "emrnotebooks-prod.cn-north-1.amazonaws.com.cn", "emrstudio-prod.cn-north-1.amazonaws.com.cn", "emrappui-prod.cn-northwest-1.amazonaws.com.cn", "emrnotebooks-prod.cn-northwest-1.amazonaws.com.cn", "emrstudio-prod.cn-northwest-1.amazonaws.com.cn", "emrappui-prod.af-south-1.amazonaws.com", "emrnotebooks-prod.af-south-1.amazonaws.com", "emrstudio-prod.af-south-1.amazonaws.com", "emrappui-prod.ap-east-1.amazonaws.com", "emrnotebooks-prod.ap-east-1.amazonaws.com", "emrstudio-prod.ap-east-1.amazonaws.com", "emrappui-prod.ap-northeast-1.amazonaws.com", "emrnotebooks-prod.ap-northeast-1.amazonaws.com", "emrstudio-prod.ap-northeast-1.amazonaws.com", "emrappui-prod.ap-northeast-2.amazonaws.com", "emrnotebooks-prod.ap-northeast-2.amazonaws.com", "emrstudio-prod.ap-northeast-2.amazonaws.com", "emrappui-prod.ap-northeast-3.amazonaws.com", "emrnotebooks-prod.ap-northeast-3.amazonaws.com", "emrstudio-prod.ap-northeast-3.amazonaws.com", "emrappui-prod.ap-south-1.amazonaws.com", "emrnotebooks-prod.ap-south-1.amazonaws.com", "emrstudio-prod.ap-south-1.amazonaws.com", "emrappui-prod.ap-south-2.amazonaws.com", "emrnotebooks-prod.ap-south-2.amazonaws.com", "emrstudio-prod.ap-south-2.amazonaws.com", "emrappui-prod.ap-southeast-1.amazonaws.com", "emrnotebooks-prod.ap-southeast-1.amazonaws.com", "emrstudio-prod.ap-southeast-1.amazonaws.com", "emrappui-prod.ap-southeast-2.amazonaws.com", "emrnotebooks-prod.ap-southeast-2.amazonaws.com", "emrstudio-prod.ap-southeast-2.amazonaws.com", "emrappui-prod.ap-southeast-3.amazonaws.com", "emrnotebooks-prod.ap-southeast-3.amazonaws.com", "emrstudio-prod.ap-southeast-3.amazonaws.com", "emrappui-prod.ap-southeast-4.amazonaws.com", "emrnotebooks-prod.ap-southeast-4.amazonaws.com", "emrstudio-prod.ap-southeast-4.amazonaws.com", "emrappui-prod.ca-central-1.amazonaws.com", "emrnotebooks-prod.ca-central-1.amazonaws.com", "emrstudio-prod.ca-central-1.amazonaws.com", "emrappui-prod.ca-west-1.amazonaws.com", "emrnotebooks-prod.ca-west-1.amazonaws.com", "emrstudio-prod.ca-west-1.amazonaws.com", "emrappui-prod.eu-central-1.amazonaws.com", "emrnotebooks-prod.eu-central-1.amazonaws.com", "emrstudio-prod.eu-central-1.amazonaws.com", "emrappui-prod.eu-central-2.amazonaws.com", "emrnotebooks-prod.eu-central-2.amazonaws.com", "emrstudio-prod.eu-central-2.amazonaws.com", "emrappui-prod.eu-north-1.amazonaws.com", "emrnotebooks-prod.eu-north-1.amazonaws.com", "emrstudio-prod.eu-north-1.amazonaws.com", "emrappui-prod.eu-south-1.amazonaws.com", "emrnotebooks-prod.eu-south-1.amazonaws.com", "emrstudio-prod.eu-south-1.amazonaws.com", "emrappui-prod.eu-south-2.amazonaws.com", "emrnotebooks-prod.eu-south-2.amazonaws.com", "emrstudio-prod.eu-south-2.amazonaws.com", "emrappui-prod.eu-west-1.amazonaws.com", "emrnotebooks-prod.eu-west-1.amazonaws.com", "emrstudio-prod.eu-west-1.amazonaws.com", "emrappui-prod.eu-west-2.amazonaws.com", "emrnotebooks-prod.eu-west-2.amazonaws.com", "emrstudio-prod.eu-west-2.amazonaws.com", "emrappui-prod.eu-west-3.amazonaws.com", "emrnotebooks-prod.eu-west-3.amazonaws.com", "emrstudio-prod.eu-west-3.amazonaws.com", "emrappui-prod.il-central-1.amazonaws.com", "emrnotebooks-prod.il-central-1.amazonaws.com", "emrstudio-prod.il-central-1.amazonaws.com", "emrappui-prod.me-central-1.amazonaws.com", "emrnotebooks-prod.me-central-1.amazonaws.com", "emrstudio-prod.me-central-1.amazonaws.com", "emrappui-prod.me-south-1.amazonaws.com", "emrnotebooks-prod.me-south-1.amazonaws.com", "emrstudio-prod.me-south-1.amazonaws.com", "emrappui-prod.sa-east-1.amazonaws.com", "emrnotebooks-prod.sa-east-1.amazonaws.com", "emrstudio-prod.sa-east-1.amazonaws.com", "emrappui-prod.us-east-1.amazonaws.com", "emrnotebooks-prod.us-east-1.amazonaws.com", "emrstudio-prod.us-east-1.amazonaws.com", "emrappui-prod.us-east-2.amazonaws.com", "emrnotebooks-prod.us-east-2.amazonaws.com", "emrstudio-prod.us-east-2.amazonaws.com", "emrappui-prod.us-gov-east-1.amazonaws.com", "emrnotebooks-prod.us-gov-east-1.amazonaws.com", "emrstudio-prod.us-gov-east-1.amazonaws.com", "emrappui-prod.us-gov-west-1.amazonaws.com", "emrnotebooks-prod.us-gov-west-1.amazonaws.com", "emrstudio-prod.us-gov-west-1.amazonaws.com", "emrappui-prod.us-west-1.amazonaws.com", "emrnotebooks-prod.us-west-1.amazonaws.com", "emrstudio-prod.us-west-1.amazonaws.com", "emrappui-prod.us-west-2.amazonaws.com", "emrnotebooks-prod.us-west-2.amazonaws.com", "emrstudio-prod.us-west-2.amazonaws.com", "*.cn-north-1.airflow.amazonaws.com.cn", "*.cn-northwest-1.airflow.amazonaws.com.cn", "*.af-south-1.airflow.amazonaws.com", "*.ap-east-1.airflow.amazonaws.com", "*.ap-northeast-1.airflow.amazonaws.com", "*.ap-northeast-2.airflow.amazonaws.com", "*.ap-northeast-3.airflow.amazonaws.com", "*.ap-south-1.airflow.amazonaws.com", "*.ap-south-2.airflow.amazonaws.com", "*.ap-southeast-1.airflow.amazonaws.com", "*.ap-southeast-2.airflow.amazonaws.com", "*.ap-southeast-3.airflow.amazonaws.com", "*.ap-southeast-4.airflow.amazonaws.com", "*.ca-central-1.airflow.amazonaws.com", "*.ca-west-1.airflow.amazonaws.com", "*.eu-central-1.airflow.amazonaws.com", "*.eu-central-2.airflow.amazonaws.com", "*.eu-north-1.airflow.amazonaws.com", "*.eu-south-1.airflow.amazonaws.com", "*.eu-south-2.airflow.amazonaws.com", "*.eu-west-1.airflow.amazonaws.com", "*.eu-west-2.airflow.amazonaws.com", "*.eu-west-3.airflow.amazonaws.com", "*.il-central-1.airflow.amazonaws.com", "*.me-central-1.airflow.amazonaws.com", "*.me-south-1.airflow.amazonaws.com", "*.sa-east-1.airflow.amazonaws.com", "*.us-east-1.airflow.amazonaws.com", "*.us-east-2.airflow.amazonaws.com", "*.us-west-1.airflow.amazonaws.com", "*.us-west-2.airflow.amazonaws.com", "s3.dualstack.cn-north-1.amazonaws.com.cn", "s3-accesspoint.dualstack.cn-north-1.amazonaws.com.cn", "s3-website.dualstack.cn-north-1.amazonaws.com.cn", "s3.cn-north-1.amazonaws.com.cn", "s3-accesspoint.cn-north-1.amazonaws.com.cn", "s3-deprecated.cn-north-1.amazonaws.com.cn", "s3-object-lambda.cn-north-1.amazonaws.com.cn", "s3-website.cn-north-1.amazonaws.com.cn", "s3.dualstack.cn-northwest-1.amazonaws.com.cn", "s3-accesspoint.dualstack.cn-northwest-1.amazonaws.com.cn", "s3.cn-northwest-1.amazonaws.com.cn", "s3-accesspoint.cn-northwest-1.amazonaws.com.cn", "s3-object-lambda.cn-northwest-1.amazonaws.com.cn", "s3-website.cn-northwest-1.amazonaws.com.cn", "s3.dualstack.af-south-1.amazonaws.com", "s3-accesspoint.dualstack.af-south-1.amazonaws.com", "s3-website.dualstack.af-south-1.amazonaws.com", "s3.af-south-1.amazonaws.com", "s3-accesspoint.af-south-1.amazonaws.com", "s3-object-lambda.af-south-1.amazonaws.com", "s3-website.af-south-1.amazonaws.com", "s3.dualstack.ap-east-1.amazonaws.com", "s3-accesspoint.dualstack.ap-east-1.amazonaws.com", "s3.ap-east-1.amazonaws.com", "s3-accesspoint.ap-east-1.amazonaws.com", "s3-object-lambda.ap-east-1.amazonaws.com", "s3-website.ap-east-1.amazonaws.com", "s3.dualstack.ap-northeast-1.amazonaws.com", "s3-accesspoint.dualstack.ap-northeast-1.amazonaws.com", "s3-website.dualstack.ap-northeast-1.amazonaws.com", "s3.ap-northeast-1.amazonaws.com", "s3-accesspoint.ap-northeast-1.amazonaws.com", "s3-object-lambda.ap-northeast-1.amazonaws.com", "s3-website.ap-northeast-1.amazonaws.com", "s3.dualstack.ap-northeast-2.amazonaws.com", "s3-accesspoint.dualstack.ap-northeast-2.amazonaws.com", "s3-website.dualstack.ap-northeast-2.amazonaws.com", "s3.ap-northeast-2.amazonaws.com", "s3-accesspoint.ap-northeast-2.amazonaws.com", "s3-object-lambda.ap-northeast-2.amazonaws.com", "s3-website.ap-northeast-2.amazonaws.com", "s3.dualstack.ap-northeast-3.amazonaws.com", "s3-accesspoint.dualstack.ap-northeast-3.amazonaws.com", "s3-website.dualstack.ap-northeast-3.amazonaws.com", "s3.ap-northeast-3.amazonaws.com", "s3-accesspoint.ap-northeast-3.amazonaws.com", "s3-object-lambda.ap-northeast-3.amazonaws.com", "s3-website.ap-northeast-3.amazonaws.com", "s3.dualstack.ap-south-1.amazonaws.com", "s3-accesspoint.dualstack.ap-south-1.amazonaws.com", "s3-website.dualstack.ap-south-1.amazonaws.com", "s3.ap-south-1.amazonaws.com", "s3-accesspoint.ap-south-1.amazonaws.com", "s3-object-lambda.ap-south-1.amazonaws.com", "s3-website.ap-south-1.amazonaws.com", "s3.dualstack.ap-south-2.amazonaws.com", "s3-accesspoint.dualstack.ap-south-2.amazonaws.com", "s3-website.dualstack.ap-south-2.amazonaws.com", "s3.ap-south-2.amazonaws.com", "s3-accesspoint.ap-south-2.amazonaws.com", "s3-object-lambda.ap-south-2.amazonaws.com", "s3-website.ap-south-2.amazonaws.com", "s3.dualstack.ap-southeast-1.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-1.amazonaws.com", "s3-website.dualstack.ap-southeast-1.amazonaws.com", "s3.ap-southeast-1.amazonaws.com", "s3-accesspoint.ap-southeast-1.amazonaws.com", "s3-object-lambda.ap-southeast-1.amazonaws.com", "s3-website.ap-southeast-1.amazonaws.com", "s3.dualstack.ap-southeast-2.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-2.amazonaws.com", "s3-website.dualstack.ap-southeast-2.amazonaws.com", "s3.ap-southeast-2.amazonaws.com", "s3-accesspoint.ap-southeast-2.amazonaws.com", "s3-object-lambda.ap-southeast-2.amazonaws.com", "s3-website.ap-southeast-2.amazonaws.com", "s3.dualstack.ap-southeast-3.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-3.amazonaws.com", "s3-website.dualstack.ap-southeast-3.amazonaws.com", "s3.ap-southeast-3.amazonaws.com", "s3-accesspoint.ap-southeast-3.amazonaws.com", "s3-object-lambda.ap-southeast-3.amazonaws.com", "s3-website.ap-southeast-3.amazonaws.com", "s3.dualstack.ap-southeast-4.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-4.amazonaws.com", "s3-website.dualstack.ap-southeast-4.amazonaws.com", "s3.ap-southeast-4.amazonaws.com", "s3-accesspoint.ap-southeast-4.amazonaws.com", "s3-object-lambda.ap-southeast-4.amazonaws.com", "s3-website.ap-southeast-4.amazonaws.com", "s3.dualstack.ap-southeast-5.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-5.amazonaws.com", "s3-website.dualstack.ap-southeast-5.amazonaws.com", "s3.ap-southeast-5.amazonaws.com", "s3-accesspoint.ap-southeast-5.amazonaws.com", "s3-deprecated.ap-southeast-5.amazonaws.com", "s3-object-lambda.ap-southeast-5.amazonaws.com", "s3-website.ap-southeast-5.amazonaws.com", "s3.dualstack.ca-central-1.amazonaws.com", "s3-accesspoint.dualstack.ca-central-1.amazonaws.com", "s3-accesspoint-fips.dualstack.ca-central-1.amazonaws.com", "s3-fips.dualstack.ca-central-1.amazonaws.com", "s3-website.dualstack.ca-central-1.amazonaws.com", "s3.ca-central-1.amazonaws.com", "s3-accesspoint.ca-central-1.amazonaws.com", "s3-accesspoint-fips.ca-central-1.amazonaws.com", "s3-fips.ca-central-1.amazonaws.com", "s3-object-lambda.ca-central-1.amazonaws.com", "s3-website.ca-central-1.amazonaws.com", "s3.dualstack.ca-west-1.amazonaws.com", "s3-accesspoint.dualstack.ca-west-1.amazonaws.com", "s3-accesspoint-fips.dualstack.ca-west-1.amazonaws.com", "s3-fips.dualstack.ca-west-1.amazonaws.com", "s3-website.dualstack.ca-west-1.amazonaws.com", "s3.ca-west-1.amazonaws.com", "s3-accesspoint.ca-west-1.amazonaws.com", "s3-accesspoint-fips.ca-west-1.amazonaws.com", "s3-fips.ca-west-1.amazonaws.com", "s3-object-lambda.ca-west-1.amazonaws.com", "s3-website.ca-west-1.amazonaws.com", "s3.dualstack.eu-central-1.amazonaws.com", "s3-accesspoint.dualstack.eu-central-1.amazonaws.com", "s3-website.dualstack.eu-central-1.amazonaws.com", "s3.eu-central-1.amazonaws.com", "s3-accesspoint.eu-central-1.amazonaws.com", "s3-object-lambda.eu-central-1.amazonaws.com", "s3-website.eu-central-1.amazonaws.com", "s3.dualstack.eu-central-2.amazonaws.com", "s3-accesspoint.dualstack.eu-central-2.amazonaws.com", "s3-website.dualstack.eu-central-2.amazonaws.com", "s3.eu-central-2.amazonaws.com", "s3-accesspoint.eu-central-2.amazonaws.com", "s3-object-lambda.eu-central-2.amazonaws.com", "s3-website.eu-central-2.amazonaws.com", "s3.dualstack.eu-north-1.amazonaws.com", "s3-accesspoint.dualstack.eu-north-1.amazonaws.com", "s3.eu-north-1.amazonaws.com", "s3-accesspoint.eu-north-1.amazonaws.com", "s3-object-lambda.eu-north-1.amazonaws.com", "s3-website.eu-north-1.amazonaws.com", "s3.dualstack.eu-south-1.amazonaws.com", "s3-accesspoint.dualstack.eu-south-1.amazonaws.com", "s3-website.dualstack.eu-south-1.amazonaws.com", "s3.eu-south-1.amazonaws.com", "s3-accesspoint.eu-south-1.amazonaws.com", "s3-object-lambda.eu-south-1.amazonaws.com", "s3-website.eu-south-1.amazonaws.com", "s3.dualstack.eu-south-2.amazonaws.com", "s3-accesspoint.dualstack.eu-south-2.amazonaws.com", "s3-website.dualstack.eu-south-2.amazonaws.com", "s3.eu-south-2.amazonaws.com", "s3-accesspoint.eu-south-2.amazonaws.com", "s3-object-lambda.eu-south-2.amazonaws.com", "s3-website.eu-south-2.amazonaws.com", "s3.dualstack.eu-west-1.amazonaws.com", "s3-accesspoint.dualstack.eu-west-1.amazonaws.com", "s3-website.dualstack.eu-west-1.amazonaws.com", "s3.eu-west-1.amazonaws.com", "s3-accesspoint.eu-west-1.amazonaws.com", "s3-deprecated.eu-west-1.amazonaws.com", "s3-object-lambda.eu-west-1.amazonaws.com", "s3-website.eu-west-1.amazonaws.com", "s3.dualstack.eu-west-2.amazonaws.com", "s3-accesspoint.dualstack.eu-west-2.amazonaws.com", "s3.eu-west-2.amazonaws.com", "s3-accesspoint.eu-west-2.amazonaws.com", "s3-object-lambda.eu-west-2.amazonaws.com", "s3-website.eu-west-2.amazonaws.com", "s3.dualstack.eu-west-3.amazonaws.com", "s3-accesspoint.dualstack.eu-west-3.amazonaws.com", "s3-website.dualstack.eu-west-3.amazonaws.com", "s3.eu-west-3.amazonaws.com", "s3-accesspoint.eu-west-3.amazonaws.com", "s3-object-lambda.eu-west-3.amazonaws.com", "s3-website.eu-west-3.amazonaws.com", "s3.dualstack.il-central-1.amazonaws.com", "s3-accesspoint.dualstack.il-central-1.amazonaws.com", "s3-website.dualstack.il-central-1.amazonaws.com", "s3.il-central-1.amazonaws.com", "s3-accesspoint.il-central-1.amazonaws.com", "s3-object-lambda.il-central-1.amazonaws.com", "s3-website.il-central-1.amazonaws.com", "s3.dualstack.me-central-1.amazonaws.com", "s3-accesspoint.dualstack.me-central-1.amazonaws.com", "s3-website.dualstack.me-central-1.amazonaws.com", "s3.me-central-1.amazonaws.com", "s3-accesspoint.me-central-1.amazonaws.com", "s3-object-lambda.me-central-1.amazonaws.com", "s3-website.me-central-1.amazonaws.com", "s3.dualstack.me-south-1.amazonaws.com", "s3-accesspoint.dualstack.me-south-1.amazonaws.com", "s3.me-south-1.amazonaws.com", "s3-accesspoint.me-south-1.amazonaws.com", "s3-object-lambda.me-south-1.amazonaws.com", "s3-website.me-south-1.amazonaws.com", "s3.amazonaws.com", "s3-1.amazonaws.com", "s3-ap-east-1.amazonaws.com", "s3-ap-northeast-1.amazonaws.com", "s3-ap-northeast-2.amazonaws.com", "s3-ap-northeast-3.amazonaws.com", "s3-ap-south-1.amazonaws.com", "s3-ap-southeast-1.amazonaws.com", "s3-ap-southeast-2.amazonaws.com", "s3-ca-central-1.amazonaws.com", "s3-eu-central-1.amazonaws.com", "s3-eu-north-1.amazonaws.com", "s3-eu-west-1.amazonaws.com", "s3-eu-west-2.amazonaws.com", "s3-eu-west-3.amazonaws.com", "s3-external-1.amazonaws.com", "s3-fips-us-gov-east-1.amazonaws.com", "s3-fips-us-gov-west-1.amazonaws.com", "mrap.accesspoint.s3-global.amazonaws.com", "s3-me-south-1.amazonaws.com", "s3-sa-east-1.amazonaws.com", "s3-us-east-2.amazonaws.com", "s3-us-gov-east-1.amazonaws.com", "s3-us-gov-west-1.amazonaws.com", "s3-us-west-1.amazonaws.com", "s3-us-west-2.amazonaws.com", "s3-website-ap-northeast-1.amazonaws.com", "s3-website-ap-southeast-1.amazonaws.com", "s3-website-ap-southeast-2.amazonaws.com", "s3-website-eu-west-1.amazonaws.com", "s3-website-sa-east-1.amazonaws.com", "s3-website-us-east-1.amazonaws.com", "s3-website-us-gov-west-1.amazonaws.com", "s3-website-us-west-1.amazonaws.com", "s3-website-us-west-2.amazonaws.com", "s3.dualstack.sa-east-1.amazonaws.com", "s3-accesspoint.dualstack.sa-east-1.amazonaws.com", "s3-website.dualstack.sa-east-1.amazonaws.com", "s3.sa-east-1.amazonaws.com", "s3-accesspoint.sa-east-1.amazonaws.com", "s3-object-lambda.sa-east-1.amazonaws.com", "s3-website.sa-east-1.amazonaws.com", "s3.dualstack.us-east-1.amazonaws.com", "s3-accesspoint.dualstack.us-east-1.amazonaws.com", "s3-accesspoint-fips.dualstack.us-east-1.amazonaws.com", "s3-fips.dualstack.us-east-1.amazonaws.com", "s3-website.dualstack.us-east-1.amazonaws.com", "s3.us-east-1.amazonaws.com", "s3-accesspoint.us-east-1.amazonaws.com", "s3-accesspoint-fips.us-east-1.amazonaws.com", "s3-deprecated.us-east-1.amazonaws.com", "s3-fips.us-east-1.amazonaws.com", "s3-object-lambda.us-east-1.amazonaws.com", "s3-website.us-east-1.amazonaws.com", "s3.dualstack.us-east-2.amazonaws.com", "s3-accesspoint.dualstack.us-east-2.amazonaws.com", "s3-accesspoint-fips.dualstack.us-east-2.amazonaws.com", "s3-fips.dualstack.us-east-2.amazonaws.com", "s3-website.dualstack.us-east-2.amazonaws.com", "s3.us-east-2.amazonaws.com", "s3-accesspoint.us-east-2.amazonaws.com", "s3-accesspoint-fips.us-east-2.amazonaws.com", "s3-deprecated.us-east-2.amazonaws.com", "s3-fips.us-east-2.amazonaws.com", "s3-object-lambda.us-east-2.amazonaws.com", "s3-website.us-east-2.amazonaws.com", "s3.dualstack.us-gov-east-1.amazonaws.com", "s3-accesspoint.dualstack.us-gov-east-1.amazonaws.com", "s3-accesspoint-fips.dualstack.us-gov-east-1.amazonaws.com", "s3-fips.dualstack.us-gov-east-1.amazonaws.com", "s3.us-gov-east-1.amazonaws.com", "s3-accesspoint.us-gov-east-1.amazonaws.com", "s3-accesspoint-fips.us-gov-east-1.amazonaws.com", "s3-fips.us-gov-east-1.amazonaws.com", "s3-object-lambda.us-gov-east-1.amazonaws.com", "s3-website.us-gov-east-1.amazonaws.com", "s3.dualstack.us-gov-west-1.amazonaws.com", "s3-accesspoint.dualstack.us-gov-west-1.amazonaws.com", "s3-accesspoint-fips.dualstack.us-gov-west-1.amazonaws.com", "s3-fips.dualstack.us-gov-west-1.amazonaws.com", "s3.us-gov-west-1.amazonaws.com", "s3-accesspoint.us-gov-west-1.amazonaws.com", "s3-accesspoint-fips.us-gov-west-1.amazonaws.com", "s3-fips.us-gov-west-1.amazonaws.com", "s3-object-lambda.us-gov-west-1.amazonaws.com", "s3-website.us-gov-west-1.amazonaws.com", "s3.dualstack.us-west-1.amazonaws.com", "s3-accesspoint.dualstack.us-west-1.amazonaws.com", "s3-accesspoint-fips.dualstack.us-west-1.amazonaws.com", "s3-fips.dualstack.us-west-1.amazonaws.com", "s3-website.dualstack.us-west-1.amazonaws.com", "s3.us-west-1.amazonaws.com", "s3-accesspoint.us-west-1.amazonaws.com", "s3-accesspoint-fips.us-west-1.amazonaws.com", "s3-fips.us-west-1.amazonaws.com", "s3-object-lambda.us-west-1.amazonaws.com", "s3-website.us-west-1.amazonaws.com", "s3.dualstack.us-west-2.amazonaws.com", "s3-accesspoint.dualstack.us-west-2.amazonaws.com", "s3-accesspoint-fips.dualstack.us-west-2.amazonaws.com", "s3-fips.dualstack.us-west-2.amazonaws.com", "s3-website.dualstack.us-west-2.amazonaws.com", "s3.us-west-2.amazonaws.com", "s3-accesspoint.us-west-2.amazonaws.com", "s3-accesspoint-fips.us-west-2.amazonaws.com", "s3-deprecated.us-west-2.amazonaws.com", "s3-fips.us-west-2.amazonaws.com", "s3-object-lambda.us-west-2.amazonaws.com", "s3-website.us-west-2.amazonaws.com", "labeling.ap-northeast-1.sagemaker.aws", "labeling.ap-northeast-2.sagemaker.aws", "labeling.ap-south-1.sagemaker.aws", "labeling.ap-southeast-1.sagemaker.aws", "labeling.ap-southeast-2.sagemaker.aws", "labeling.ca-central-1.sagemaker.aws", "labeling.eu-central-1.sagemaker.aws", "labeling.eu-west-1.sagemaker.aws", "labeling.eu-west-2.sagemaker.aws", "labeling.us-east-1.sagemaker.aws", "labeling.us-east-2.sagemaker.aws", "labeling.us-west-2.sagemaker.aws", "notebook.af-south-1.sagemaker.aws", "notebook.ap-east-1.sagemaker.aws", "notebook.ap-northeast-1.sagemaker.aws", "notebook.ap-northeast-2.sagemaker.aws", "notebook.ap-northeast-3.sagemaker.aws", "notebook.ap-south-1.sagemaker.aws", "notebook.ap-south-2.sagemaker.aws", "notebook.ap-southeast-1.sagemaker.aws", "notebook.ap-southeast-2.sagemaker.aws", "notebook.ap-southeast-3.sagemaker.aws", "notebook.ap-southeast-4.sagemaker.aws", "notebook.ca-central-1.sagemaker.aws", "notebook-fips.ca-central-1.sagemaker.aws", "notebook.ca-west-1.sagemaker.aws", "notebook-fips.ca-west-1.sagemaker.aws", "notebook.eu-central-1.sagemaker.aws", "notebook.eu-central-2.sagemaker.aws", "notebook.eu-north-1.sagemaker.aws", "notebook.eu-south-1.sagemaker.aws", "notebook.eu-south-2.sagemaker.aws", "notebook.eu-west-1.sagemaker.aws", "notebook.eu-west-2.sagemaker.aws", "notebook.eu-west-3.sagemaker.aws", "notebook.il-central-1.sagemaker.aws", "notebook.me-central-1.sagemaker.aws", "notebook.me-south-1.sagemaker.aws", "notebook.sa-east-1.sagemaker.aws", "notebook.us-east-1.sagemaker.aws", "notebook-fips.us-east-1.sagemaker.aws", "notebook.us-east-2.sagemaker.aws", "notebook-fips.us-east-2.sagemaker.aws", "notebook.us-gov-east-1.sagemaker.aws", "notebook-fips.us-gov-east-1.sagemaker.aws", "notebook.us-gov-west-1.sagemaker.aws", "notebook-fips.us-gov-west-1.sagemaker.aws", "notebook.us-west-1.sagemaker.aws", "notebook-fips.us-west-1.sagemaker.aws", "notebook.us-west-2.sagemaker.aws", "notebook-fips.us-west-2.sagemaker.aws", "notebook.cn-north-1.sagemaker.com.cn", "notebook.cn-northwest-1.sagemaker.com.cn", "studio.af-south-1.sagemaker.aws", "studio.ap-east-1.sagemaker.aws", "studio.ap-northeast-1.sagemaker.aws", "studio.ap-northeast-2.sagemaker.aws", "studio.ap-northeast-3.sagemaker.aws", "studio.ap-south-1.sagemaker.aws", "studio.ap-southeast-1.sagemaker.aws", "studio.ap-southeast-2.sagemaker.aws", "studio.ap-southeast-3.sagemaker.aws", "studio.ca-central-1.sagemaker.aws", "studio.eu-central-1.sagemaker.aws", "studio.eu-north-1.sagemaker.aws", "studio.eu-south-1.sagemaker.aws", "studio.eu-south-2.sagemaker.aws", "studio.eu-west-1.sagemaker.aws", "studio.eu-west-2.sagemaker.aws", "studio.eu-west-3.sagemaker.aws", "studio.il-central-1.sagemaker.aws", "studio.me-central-1.sagemaker.aws", "studio.me-south-1.sagemaker.aws", "studio.sa-east-1.sagemaker.aws", "studio.us-east-1.sagemaker.aws", "studio.us-east-2.sagemaker.aws", "studio.us-gov-east-1.sagemaker.aws", "studio-fips.us-gov-east-1.sagemaker.aws", "studio.us-gov-west-1.sagemaker.aws", "studio-fips.us-gov-west-1.sagemaker.aws", "studio.us-west-1.sagemaker.aws", "studio.us-west-2.sagemaker.aws", "studio.cn-north-1.sagemaker.com.cn", "studio.cn-northwest-1.sagemaker.com.cn", "*.experiments.sagemaker.aws", "analytics-gateway.ap-northeast-1.amazonaws.com", "analytics-gateway.ap-northeast-2.amazonaws.com", "analytics-gateway.ap-south-1.amazonaws.com", "analytics-gateway.ap-southeast-1.amazonaws.com", "analytics-gateway.ap-southeast-2.amazonaws.com", "analytics-gateway.eu-central-1.amazonaws.com", "analytics-gateway.eu-west-1.amazonaws.com", "analytics-gateway.us-east-1.amazonaws.com", "analytics-gateway.us-east-2.amazonaws.com", "analytics-gateway.us-west-2.amazonaws.com", "amplifyapp.com", "*.awsapprunner.com", "webview-assets.aws-cloud9.af-south-1.amazonaws.com", "vfs.cloud9.af-south-1.amazonaws.com", "webview-assets.cloud9.af-south-1.amazonaws.com", "webview-assets.aws-cloud9.ap-east-1.amazonaws.com", "vfs.cloud9.ap-east-1.amazonaws.com", "webview-assets.cloud9.ap-east-1.amazonaws.com", "webview-assets.aws-cloud9.ap-northeast-1.amazonaws.com", "vfs.cloud9.ap-northeast-1.amazonaws.com", "webview-assets.cloud9.ap-northeast-1.amazonaws.com", "webview-assets.aws-cloud9.ap-northeast-2.amazonaws.com", "vfs.cloud9.ap-northeast-2.amazonaws.com", "webview-assets.cloud9.ap-northeast-2.amazonaws.com", "webview-assets.aws-cloud9.ap-northeast-3.amazonaws.com", "vfs.cloud9.ap-northeast-3.amazonaws.com", "webview-assets.cloud9.ap-northeast-3.amazonaws.com", "webview-assets.aws-cloud9.ap-south-1.amazonaws.com", "vfs.cloud9.ap-south-1.amazonaws.com", "webview-assets.cloud9.ap-south-1.amazonaws.com", "webview-assets.aws-cloud9.ap-southeast-1.amazonaws.com", "vfs.cloud9.ap-southeast-1.amazonaws.com", "webview-assets.cloud9.ap-southeast-1.amazonaws.com", "webview-assets.aws-cloud9.ap-southeast-2.amazonaws.com", "vfs.cloud9.ap-southeast-2.amazonaws.com", "webview-assets.cloud9.ap-southeast-2.amazonaws.com", "webview-assets.aws-cloud9.ca-central-1.amazonaws.com", "vfs.cloud9.ca-central-1.amazonaws.com", "webview-assets.cloud9.ca-central-1.amazonaws.com", "webview-assets.aws-cloud9.eu-central-1.amazonaws.com", "vfs.cloud9.eu-central-1.amazonaws.com", "webview-assets.cloud9.eu-central-1.amazonaws.com", "webview-assets.aws-cloud9.eu-north-1.amazonaws.com", "vfs.cloud9.eu-north-1.amazonaws.com", "webview-assets.cloud9.eu-north-1.amazonaws.com", "webview-assets.aws-cloud9.eu-south-1.amazonaws.com", "vfs.cloud9.eu-south-1.amazonaws.com", "webview-assets.cloud9.eu-south-1.amazonaws.com", "webview-assets.aws-cloud9.eu-west-1.amazonaws.com", "vfs.cloud9.eu-west-1.amazonaws.com", "webview-assets.cloud9.eu-west-1.amazonaws.com", "webview-assets.aws-cloud9.eu-west-2.amazonaws.com", "vfs.cloud9.eu-west-2.amazonaws.com", "webview-assets.cloud9.eu-west-2.amazonaws.com", "webview-assets.aws-cloud9.eu-west-3.amazonaws.com", "vfs.cloud9.eu-west-3.amazonaws.com", "webview-assets.cloud9.eu-west-3.amazonaws.com", "webview-assets.aws-cloud9.il-central-1.amazonaws.com", "vfs.cloud9.il-central-1.amazonaws.com", "webview-assets.aws-cloud9.me-south-1.amazonaws.com", "vfs.cloud9.me-south-1.amazonaws.com", "webview-assets.cloud9.me-south-1.amazonaws.com", "webview-assets.aws-cloud9.sa-east-1.amazonaws.com", "vfs.cloud9.sa-east-1.amazonaws.com", "webview-assets.cloud9.sa-east-1.amazonaws.com", "webview-assets.aws-cloud9.us-east-1.amazonaws.com", "vfs.cloud9.us-east-1.amazonaws.com", "webview-assets.cloud9.us-east-1.amazonaws.com", "webview-assets.aws-cloud9.us-east-2.amazonaws.com", "vfs.cloud9.us-east-2.amazonaws.com", "webview-assets.cloud9.us-east-2.amazonaws.com", "webview-assets.aws-cloud9.us-west-1.amazonaws.com", "vfs.cloud9.us-west-1.amazonaws.com", "webview-assets.cloud9.us-west-1.amazonaws.com", "webview-assets.aws-cloud9.us-west-2.amazonaws.com", "vfs.cloud9.us-west-2.amazonaws.com", "webview-assets.cloud9.us-west-2.amazonaws.com", "awsapps.com", "cn-north-1.eb.amazonaws.com.cn", "cn-northwest-1.eb.amazonaws.com.cn", "elasticbeanstalk.com", "af-south-1.elasticbeanstalk.com", "ap-east-1.elasticbeanstalk.com", "ap-northeast-1.elasticbeanstalk.com", "ap-northeast-2.elasticbeanstalk.com", "ap-northeast-3.elasticbeanstalk.com", "ap-south-1.elasticbeanstalk.com", "ap-southeast-1.elasticbeanstalk.com", "ap-southeast-2.elasticbeanstalk.com", "ap-southeast-3.elasticbeanstalk.com", "ca-central-1.elasticbeanstalk.com", "eu-central-1.elasticbeanstalk.com", "eu-north-1.elasticbeanstalk.com", "eu-south-1.elasticbeanstalk.com", "eu-west-1.elasticbeanstalk.com", "eu-west-2.elasticbeanstalk.com", "eu-west-3.elasticbeanstalk.com", "il-central-1.elasticbeanstalk.com", "me-south-1.elasticbeanstalk.com", "sa-east-1.elasticbeanstalk.com", "us-east-1.elasticbeanstalk.com", "us-east-2.elasticbeanstalk.com", "us-gov-east-1.elasticbeanstalk.com", "us-gov-west-1.elasticbeanstalk.com", "us-west-1.elasticbeanstalk.com", "us-west-2.elasticbeanstalk.com", "*.elb.amazonaws.com.cn", "*.elb.amazonaws.com", "awsglobalaccelerator.com", "*.private.repost.aws", "eero.online", "eero-stage.online", "apigee.io", "panel.dev", "siiites.com", "appspacehosted.com", "appspaceusercontent.com", "appudo.net", "on-aptible.com", "f5.si", "arvanedge.ir", "user.aseinet.ne.jp", "gv.vc", "d.gv.vc", "user.party.eus", "pimienta.org", "poivron.org", "potager.org", "sweetpepper.org", "myasustor.com", "cdn.prod.atlassian-dev.net", "translated.page", "myfritz.link", "myfritz.net", "onavstack.net", "*.awdev.ca", "*.advisor.ws", "ecommerce-shop.pl", "b-data.io", "balena-devices.com", "base.ec", "official.ec", "buyshop.jp", "fashionstore.jp", "handcrafted.jp", "kawaiishop.jp", "supersale.jp", "theshop.jp", "shopselect.net", "base.shop", "beagleboard.io", "*.beget.app", "pages.gay", "bnr.la", "bitbucket.io", "blackbaudcdn.net", "of.je", "bluebite.io", "boomla.net", "boutir.com", "boxfuse.io", "square7.ch", "bplaced.com", "bplaced.de", "square7.de", "bplaced.net", "square7.net", "*.s.brave.io", "shop.brendly.hr", "shop.brendly.rs", "browsersafetymark.io", "radio.am", "radio.fm", "uk0.bigv.io", "dh.bytemark.co.uk", "vm.bytemark.co.uk", "cafjs.com", "canva-apps.cn", "*.my.canvasite.cn", "canva-apps.com", "*.my.canva.site", "drr.ac", "uwu.ai", "carrd.co", "crd.co", "ju.mp", "api.gov.uk", "cdn77-storage.com", "rsc.contentproxy9.cz", "r.cdn77.net", "cdn77-ssl.net", "c.cdn77.org", "rsc.cdn77.org", "ssl.origin.cdn77-secure.org", "za.bz", "br.com", "cn.com", "de.com", "eu.com", "jpn.com", "mex.com", "ru.com", "sa.com", "uk.com", "us.com", "za.com", "com.de", "gb.net", "hu.net", "jp.net", "se.net", "uk.net", "ae.org", "com.se", "cx.ua", "discourse.group", "discourse.team", "clerk.app", "clerkstage.app", "*.lcl.dev", "*.lclstage.dev", "*.stg.dev", "*.stgstage.dev", "cleverapps.cc", "*.services.clever-cloud.com", "cleverapps.io", "cleverapps.tech", "clickrising.net", "cloudns.asia", "cloudns.be", "cloud-ip.biz", "cloudns.biz", "cloudns.cc", "cloudns.ch", "cloudns.cl", "cloudns.club", "dnsabr.com", "ip-ddns.com", "cloudns.cx", "cloudns.eu", "cloudns.in", "cloudns.info", "ddns-ip.net", "dns-cloud.net", "dns-dynamic.net", "cloudns.nz", "cloudns.org", "ip-dynamic.org", "cloudns.ph", "cloudns.pro", "cloudns.pw", "cloudns.us", "c66.me", "cloud66.ws", "cloud66.zone", "jdevcloud.com", "wpdevcloud.com", "cloudaccess.host", "freesite.host", "cloudaccess.net", "*.cloudera.site", "cf-ipfs.com", "cloudflare-ipfs.com", "trycloudflare.com", "pages.dev", "r2.dev", "workers.dev", "cloudflare.net", "cdn.cloudflare.net", "cdn.cloudflareanycast.net", "cdn.cloudflarecn.net", "cdn.cloudflareglobal.net", "cust.cloudscale.ch", "objects.lpg.cloudscale.ch", "objects.rma.cloudscale.ch", "wnext.app", "cnpy.gdn", "*.otap.co", "co.ca", "co.com", "codeberg.page", "csb.app", "preview.csb.app", "co.nl", "co.no", "webhosting.be", "hosting-cluster.nl", "ctfcloud.net", "convex.site", "ac.ru", "edu.ru", "gov.ru", "int.ru", "mil.ru", "test.ru", "dyn.cosidns.de", "dnsupdater.de", "dynamisches-dns.de", "internet-dns.de", "l-o-g-i-n.de", "dynamic-dns.info", "feste-ip.net", "knx-server.net", "static-access.net", "craft.me", "realm.cz", "on.crisp.email", "*.cryptonomic.net", "curv.dev", "cfolks.pl", "cyon.link", "cyon.site", "platform0.app", "fnwk.site", "folionetwork.site", "biz.dk", "co.dk", "firm.dk", "reg.dk", "store.dk", "dyndns.dappnode.io", "builtwithdark.com", "darklang.io", "demo.datadetect.com", "instance.datadetect.com", "edgestack.me", "dattolocal.com", "dattorelay.com", "dattoweb.com", "mydatto.com", "dattolocal.net", "mydatto.net", "ddnss.de", "dyn.ddnss.de", "dyndns.ddnss.de", "dyn-ip24.de", "dyndns1.de", "home-webserver.de", "dyn.home-webserver.de", "myhome-server.de", "ddnss.org", "debian.net", "definima.io", "definima.net", "deno.dev", "deno-staging.dev", "dedyn.io", "deta.app", "deta.dev", "dfirma.pl", "dkonto.pl", "you2.pl", "ondigitalocean.app", "*.digitaloceanspaces.com", "us.kg", "rss.my.id", "diher.solutions", "discordsays.com", "discordsez.com", "jozi.biz", "dnshome.de", "online.th", "shop.th", "drayddns.com", "shoparena.pl", "dreamhosters.com", "durumis.com", "mydrobo.com", "drud.io", "drud.us", "duckdns.org", "dy.fi", "tunk.org", "dyndns.biz", "for-better.biz", "for-more.biz", "for-some.biz", "for-the.biz", "selfip.biz", "webhop.biz", "ftpaccess.cc", "game-server.cc", "myphotos.cc", "scrapping.cc", "blogdns.com", "cechire.com", "dnsalias.com", "dnsdojo.com", "doesntexist.com", "dontexist.com", "doomdns.com", "dyn-o-saur.com", "dynalias.com", "dyndns-at-home.com", "dyndns-at-work.com", "dyndns-blog.com", "dyndns-free.com", "dyndns-home.com", "dyndns-ip.com", "dyndns-mail.com", "dyndns-office.com", "dyndns-pics.com", "dyndns-remote.com", "dyndns-server.com", "dyndns-web.com", "dyndns-wiki.com", "dyndns-work.com", "est-a-la-maison.com", "est-a-la-masion.com", "est-le-patron.com", "est-mon-blogueur.com", "from-ak.com", "from-al.com", "from-ar.com", "from-ca.com", "from-ct.com", "from-dc.com", "from-de.com", "from-fl.com", "from-ga.com", "from-hi.com", "from-ia.com", "from-id.com", "from-il.com", "from-in.com", "from-ks.com", "from-ky.com", "from-ma.com", "from-md.com", "from-mi.com", "from-mn.com", "from-mo.com", "from-ms.com", "from-mt.com", "from-nc.com", "from-nd.com", "from-ne.com", "from-nh.com", "from-nj.com", "from-nm.com", "from-nv.com", "from-oh.com", "from-ok.com", "from-or.com", "from-pa.com", "from-pr.com", "from-ri.com", "from-sc.com", "from-sd.com", "from-tn.com", "from-tx.com", "from-ut.com", "from-va.com", "from-vt.com", "from-wa.com", "from-wi.com", "from-wv.com", "from-wy.com", "getmyip.com", "gotdns.com", "hobby-site.com", "homelinux.com", "homeunix.com", "iamallama.com", "is-a-anarchist.com", "is-a-blogger.com", "is-a-bookkeeper.com", "is-a-bulls-fan.com", "is-a-caterer.com", "is-a-chef.com", "is-a-conservative.com", "is-a-cpa.com", "is-a-cubicle-slave.com", "is-a-democrat.com", "is-a-designer.com", "is-a-doctor.com", "is-a-financialadvisor.com", "is-a-geek.com", "is-a-green.com", "is-a-guru.com", "is-a-hard-worker.com", "is-a-hunter.com", "is-a-landscaper.com", "is-a-lawyer.com", "is-a-liberal.com", "is-a-libertarian.com", "is-a-llama.com", "is-a-musician.com", "is-a-nascarfan.com", "is-a-nurse.com", "is-a-painter.com", "is-a-personaltrainer.com", "is-a-photographer.com", "is-a-player.com", "is-a-republican.com", "is-a-rockstar.com", "is-a-socialist.com", "is-a-student.com", "is-a-teacher.com", "is-a-techie.com", "is-a-therapist.com", "is-an-accountant.com", "is-an-actor.com", "is-an-actress.com", "is-an-anarchist.com", "is-an-artist.com", "is-an-engineer.com", "is-an-entertainer.com", "is-certified.com", "is-gone.com", "is-into-anime.com", "is-into-cars.com", "is-into-cartoons.com", "is-into-games.com", "is-leet.com", "is-not-certified.com", "is-slick.com", "is-uberleet.com", "is-with-theband.com", "isa-geek.com", "isa-hockeynut.com", "issmarterthanyou.com", "likes-pie.com", "likescandy.com", "neat-url.com", "saves-the-whales.com", "selfip.com", "sells-for-less.com", "sells-for-u.com", "servebbs.com", "simple-url.com", "space-to-rent.com", "teaches-yoga.com", "writesthisblog.com", "ath.cx", "fuettertdasnetz.de", "isteingeek.de", "istmein.de", "lebtimnetz.de", "leitungsen.de", "traeumtgerade.de", "barrel-of-knowledge.info", "barrell-of-knowledge.info", "dyndns.info", "for-our.info", "groks-the.info", "groks-this.info", "here-for-more.info", "knowsitall.info", "selfip.info", "webhop.info", "forgot.her.name", "forgot.his.name", "at-band-camp.net", "blogdns.net", "broke-it.net", "buyshouses.net", "dnsalias.net", "dnsdojo.net", "does-it.net", "dontexist.net", "dynalias.net", "dynathome.net", "endofinternet.net", "from-az.net", "from-co.net", "from-la.net", "from-ny.net", "gets-it.net", "ham-radio-op.net", "homeftp.net", "homeip.net", "homelinux.net", "homeunix.net", "in-the-band.net", "is-a-chef.net", "is-a-geek.net", "isa-geek.net", "kicks-ass.net", "office-on-the.net", "podzone.net", "scrapper-site.net", "selfip.net", "sells-it.net", "servebbs.net", "serveftp.net", "thruhere.net", "webhop.net", "merseine.nu", "mine.nu", "shacknet.nu", "blogdns.org", "blogsite.org", "boldlygoingnowhere.org", "dnsalias.org", "dnsdojo.org", "doesntexist.org", "dontexist.org", "doomdns.org", "dvrdns.org", "dynalias.org", "dyndns.org", "go.dyndns.org", "home.dyndns.org", "endofinternet.org", "endoftheinternet.org", "from-me.org", "game-host.org", "gotdns.org", "hobby-site.org", "homedns.org", "homeftp.org", "homelinux.org", "homeunix.org", "is-a-bruinsfan.org", "is-a-candidate.org", "is-a-celticsfan.org", "is-a-chef.org", "is-a-geek.org", "is-a-knight.org", "is-a-linux-user.org", "is-a-patsfan.org", "is-a-soxfan.org", "is-found.org", "is-lost.org", "is-saved.org", "is-very-bad.org", "is-very-evil.org", "is-very-good.org", "is-very-nice.org", "is-very-sweet.org", "isa-geek.org", "kicks-ass.org", "misconfused.org", "podzone.org", "readmyblog.org", "selfip.org", "sellsyourhome.org", "servebbs.org", "serveftp.org", "servegame.org", "stuff-4-sale.org", "webhop.org", "better-than.tv", "dyndns.tv", "on-the-web.tv", "worse-than.tv", "is-by.us", "land-4-sale.us", "stuff-4-sale.us", "dyndns.ws", "mypets.ws", "ddnsfree.com", "ddnsgeek.com", "giize.com", "gleeze.com", "kozow.com", "loseyourip.com", "ooguy.com", "theworkpc.com", "casacam.net", "dynu.net", "accesscam.org", "camdvr.org", "freeddns.org", "mywire.org", "webredirect.org", "myddns.rocks", "dynv6.net", "e4.cz", "easypanel.app", "easypanel.host", "*.ewp.live", "twmail.cc", "twmail.net", "twmail.org", "mymailer.com.tw", "url.tw", "at.emf.camp", "rt.ht", "elementor.cloud", "elementor.cool", "en-root.fr", "mytuleap.com", "tuleap-partners.com", "encr.app", "encoreapi.com", "eu.encoway.cloud", "eu.org", "al.eu.org", "asso.eu.org", "at.eu.org", "au.eu.org", "be.eu.org", "bg.eu.org", "ca.eu.org", "cd.eu.org", "ch.eu.org", "cn.eu.org", "cy.eu.org", "cz.eu.org", "de.eu.org", "dk.eu.org", "edu.eu.org", "ee.eu.org", "es.eu.org", "fi.eu.org", "fr.eu.org", "gr.eu.org", "hr.eu.org", "hu.eu.org", "ie.eu.org", "il.eu.org", "in.eu.org", "int.eu.org", "is.eu.org", "it.eu.org", "jp.eu.org", "kr.eu.org", "lt.eu.org", "lu.eu.org", "lv.eu.org", "me.eu.org", "mk.eu.org", "mt.eu.org", "my.eu.org", "net.eu.org", "ng.eu.org", "nl.eu.org", "no.eu.org", "nz.eu.org", "pl.eu.org", "pt.eu.org", "ro.eu.org", "ru.eu.org", "se.eu.org", "si.eu.org", "sk.eu.org", "tr.eu.org", "uk.eu.org", "us.eu.org", "eurodir.ru", "eu-1.evennode.com", "eu-2.evennode.com", "eu-3.evennode.com", "eu-4.evennode.com", "us-1.evennode.com", "us-2.evennode.com", "us-3.evennode.com", "us-4.evennode.com", "relay.evervault.app", "relay.evervault.dev", "expo.app", "staging.expo.app", "onfabrica.com", "ru.net", "adygeya.ru", "bashkiria.ru", "bir.ru", "cbg.ru", "com.ru", "dagestan.ru", "grozny.ru", "kalmykia.ru", "kustanai.ru", "marine.ru", "mordovia.ru", "msk.ru", "mytis.ru", "nalchik.ru", "nov.ru", "pyatigorsk.ru", "spb.ru", "vladikavkaz.ru", "vladimir.ru", "abkhazia.su", "adygeya.su", "aktyubinsk.su", "arkhangelsk.su", "armenia.su", "ashgabad.su", "azerbaijan.su", "balashov.su", "bashkiria.su", "bryansk.su", "bukhara.su", "chimkent.su", "dagestan.su", "east-kazakhstan.su", "exnet.su", "georgia.su", "grozny.su", "ivanovo.su", "jambyl.su", "kalmykia.su", "kaluga.su", "karacol.su", "karaganda.su", "karelia.su", "khakassia.su", "krasnodar.su", "kurgan.su", "kustanai.su", "lenug.su", "mangyshlak.su", "mordovia.su", "msk.su", "murmansk.su", "nalchik.su", "navoi.su", "north-kazakhstan.su", "nov.su", "obninsk.su", "penza.su", "pokrovsk.su", "sochi.su", "spb.su", "tashkent.su", "termez.su", "togliatti.su", "troitsk.su", "tselinograd.su", "tula.su", "tuva.su", "vladikavkaz.su", "vladimir.su", "vologda.su", "channelsdvr.net", "u.channelsdvr.net", "edgecompute.app", "fastly-edge.com", "fastly-terrarium.com", "freetls.fastly.net", "map.fastly.net", "a.prod.fastly.net", "global.prod.fastly.net", "a.ssl.fastly.net", "b.ssl.fastly.net", "global.ssl.fastly.net", "fastlylb.net", "map.fastlylb.net", "*.user.fm", "fastvps-server.com", "fastvps.host", "myfast.host", "fastvps.site", "myfast.space", "conn.uk", "copro.uk", "hosp.uk", "fedorainfracloud.org", "fedorapeople.org", "cloud.fedoraproject.org", "app.os.fedoraproject.org", "app.os.stg.fedoraproject.org", "mydobiss.com", "fh-muenster.io", "filegear.me", "firebaseapp.com", "fldrv.com", "flutterflow.app", "fly.dev", "shw.io", "edgeapp.net", "forgeblocks.com", "id.forgerock.io", "framer.ai", "framer.app", "framercanvas.com", "framer.media", "framer.photos", "framer.website", "framer.wiki", "0e.vc", "freebox-os.com", "freeboxos.com", "fbx-os.fr", "fbxos.fr", "freebox-os.fr", "freeboxos.fr", "freedesktop.org", "freemyip.com", "*.frusky.de", "wien.funkfeuer.at", "daemon.asia", "dix.asia", "mydns.bz", "0am.jp", "0g0.jp", "0j0.jp", "0t0.jp", "mydns.jp", "pgw.jp", "wjg.jp", "keyword-on.net", "live-on.net", "server-on.net", "mydns.tw", "mydns.vc", "*.futurecms.at", "*.ex.futurecms.at", "*.in.futurecms.at", "futurehosting.at", "futuremailing.at", "*.ex.ortsinfo.at", "*.kunden.ortsinfo.at", "*.statics.cloud", "aliases121.com", "campaign.gov.uk", "service.gov.uk", "independent-commission.uk", "independent-inquest.uk", "independent-inquiry.uk", "independent-panel.uk", "independent-review.uk", "public-inquiry.uk", "royal-commission.uk", "gehirn.ne.jp", "usercontent.jp", "gentapps.com", "gentlentapis.com", "lab.ms", "cdn-edges.net", "localcert.net", "localhostcert.net", "gsj.bz", "githubusercontent.com", "githubpreview.dev", "github.io", "gitlab.io", "gitapp.si", "gitpage.si", "glitch.me", "nog.community", "co.ro", "shop.ro", "lolipop.io", "angry.jp", "babyblue.jp", "babymilk.jp", "backdrop.jp", "bambina.jp", "bitter.jp", "blush.jp", "boo.jp", "boy.jp", "boyfriend.jp", "but.jp", "candypop.jp", "capoo.jp", "catfood.jp", "cheap.jp", "chicappa.jp", "chillout.jp", "chips.jp", "chowder.jp", "chu.jp", "ciao.jp", "cocotte.jp", "coolblog.jp", "cranky.jp", "cutegirl.jp", "daa.jp", "deca.jp", "deci.jp", "digick.jp", "egoism.jp", "fakefur.jp", "fem.jp", "flier.jp", "floppy.jp", "fool.jp", "frenchkiss.jp", "girlfriend.jp", "girly.jp", "gloomy.jp", "gonna.jp", "greater.jp", "hacca.jp", "heavy.jp", "her.jp", "hiho.jp", "hippy.jp", "holy.jp", "hungry.jp", "icurus.jp", "itigo.jp", "jellybean.jp", "kikirara.jp", "kill.jp", "kilo.jp", "kuron.jp", "littlestar.jp", "lolipopmc.jp", "lolitapunk.jp", "lomo.jp", "lovepop.jp", "lovesick.jp", "main.jp", "mods.jp", "mond.jp", "mongolian.jp", "moo.jp", "namaste.jp", "nikita.jp", "nobushi.jp", "noor.jp", "oops.jp", "parallel.jp", "parasite.jp", "pecori.jp", "peewee.jp", "penne.jp", "pepper.jp", "perma.jp", "pigboat.jp", "pinoko.jp", "punyu.jp", "pupu.jp", "pussycat.jp", "pya.jp", "raindrop.jp", "readymade.jp", "sadist.jp", "schoolbus.jp", "secret.jp", "staba.jp", "stripper.jp", "sub.jp", "sunnyday.jp", "thick.jp", "tonkotsu.jp", "under.jp", "upper.jp", "velvet.jp", "verse.jp", "versus.jp", "vivian.jp", "watson.jp", "weblike.jp", "whitesnow.jp", "zombie.jp", "heteml.net", "graphic.design", "goip.de", "blogspot.ae", "blogspot.al", "blogspot.am", "*.hosted.app", "*.run.app", "web.app", "blogspot.com.ar", "blogspot.co.at", "blogspot.com.au", "blogspot.ba", "blogspot.be", "blogspot.bg", "blogspot.bj", "blogspot.com.br", "blogspot.com.by", "blogspot.ca", "blogspot.cf", "blogspot.ch", "blogspot.cl", "blogspot.com.co", "*.0emm.com", "appspot.com", "*.r.appspot.com", "blogspot.com", "codespot.com", "googleapis.com", "googlecode.com", "pagespeedmobilizer.com", "withgoogle.com", "withyoutube.com", "blogspot.cv", "blogspot.com.cy", "blogspot.cz", "blogspot.de", "*.gateway.dev", "blogspot.dk", "blogspot.com.ee", "blogspot.com.eg", "blogspot.com.es", "blogspot.fi", "blogspot.fr", "cloud.goog", "translate.goog", "*.usercontent.goog", "blogspot.gr", "blogspot.hk", "blogspot.hr", "blogspot.hu", "blogspot.co.id", "blogspot.ie", "blogspot.co.il", "blogspot.in", "blogspot.is", "blogspot.it", "blogspot.jp", "blogspot.co.ke", "blogspot.kr", "blogspot.li", "blogspot.lt", "blogspot.lu", "blogspot.md", "blogspot.mk", "blogspot.com.mt", "blogspot.mx", "blogspot.my", "cloudfunctions.net", "blogspot.com.ng", "blogspot.nl", "blogspot.no", "blogspot.co.nz", "blogspot.pe", "blogspot.pt", "blogspot.qa", "blogspot.re", "blogspot.ro", "blogspot.rs", "blogspot.ru", "blogspot.se", "blogspot.sg", "blogspot.si", "blogspot.sk", "blogspot.sn", "blogspot.td", "blogspot.com.tr", "blogspot.tw", "blogspot.ug", "blogspot.co.uk", "blogspot.com.uy", "blogspot.vn", "blogspot.co.za", "goupile.fr", "pymnt.uk", "cloudapps.digital", "london.cloudapps.digital", "gov.nl", "grafana-dev.net", "grayjayleagues.com", "gÃ¼nstigbestellen.de", "gÃ¼nstigliefern.de", "fin.ci", "free.hr", "caa.li", "ua.rs", "conf.se", "hÃ¤kkinen.fi", "hrsn.dev", "hashbang.sh", "hasura.app", "hasura-app.io", "hatenablog.com", "hatenadiary.com", "hateblo.jp", "hatenablog.jp", "hatenadiary.jp", "hatenadiary.org", "pages.it.hs-heilbronn.de", "pages-research.it.hs-heilbronn.de", "heiyu.space", "helioho.st", "heliohost.us", "hepforge.org", "herokuapp.com", "herokussl.com", "heyflow.page", "heyflow.site", "ravendb.cloud", "ravendb.community", "development.run", "ravendb.run", "homesklep.pl", "*.kin.one", "*.id.pub", "*.kin.pub", "secaas.hk", "hoplix.shop", "orx.biz", "biz.gl", "biz.ng", "co.biz.ng", "dl.biz.ng", "go.biz.ng", "lg.biz.ng", "on.biz.ng", "col.ng", "firm.ng", "gen.ng", "ltd.ng", "ngo.ng", "plc.ng", "ie.ua", "hostyhosting.io", "hf.space", "static.hf.space", "hypernode.io", "iobb.net", "co.cz", "*.moonscale.io", "moonscale.net", "gr.com", "iki.fi", "ibxos.it", "iliadboxos.it", "smushcdn.com", "wphostedmail.com", "wpmucdn.com", "tempurl.host", "wpmudev.host", "dyn-berlin.de", "in-berlin.de", "in-brb.de", "in-butter.de", "in-dsl.de", "in-vpn.de", "in-dsl.net", "in-vpn.net", "in-dsl.org", "in-vpn.org", "biz.at", "info.at", "info.cx", "ac.leg.br", "al.leg.br", "am.leg.br", "ap.leg.br", "ba.leg.br", "ce.leg.br", "df.leg.br", "es.leg.br", "go.leg.br", "ma.leg.br", "mg.leg.br", "ms.leg.br", "mt.leg.br", "pa.leg.br", "pb.leg.br", "pe.leg.br", "pi.leg.br", "pr.leg.br", "rj.leg.br", "rn.leg.br", "ro.leg.br", "rr.leg.br", "rs.leg.br", "sc.leg.br", "se.leg.br", "sp.leg.br", "to.leg.br", "pixolino.com", "na4u.ru", "apps-1and1.com", "live-website.com", "apps-1and1.net", "websitebuilder.online", "app-ionos.space", "iopsys.se", "*.dweb.link", "ipifony.net", "ir.md", "is-a-good.dev", "is-a.dev", "iservschule.de", "mein-iserv.de", "schulplattform.de", "schulserver.de", "test-iserv.de", "iserv.dev", "mel.cloudlets.com.au", "cloud.interhostsolutions.be", "alp1.ae.flow.ch", "appengine.flow.ch", "es-1.axarnet.cloud", "diadem.cloud", "vip.jelastic.cloud", "jele.cloud", "it1.eur.aruba.jenv-aruba.cloud", "it1.jenv-aruba.cloud", "keliweb.cloud", "cs.keliweb.cloud", "oxa.cloud", "tn.oxa.cloud", "uk.oxa.cloud", "primetel.cloud", "uk.primetel.cloud", "ca.reclaim.cloud", "uk.reclaim.cloud", "us.reclaim.cloud", "ch.trendhosting.cloud", "de.trendhosting.cloud", "jele.club", "dopaas.com", "paas.hosted-by-previder.com", "rag-cloud.hosteur.com", "rag-cloud-ch.hosteur.com", "jcloud.ik-server.com", "jcloud-ver-jpc.ik-server.com", "demo.jelastic.com", "paas.massivegrid.com", "jed.wafaicloud.com", "ryd.wafaicloud.com", "j.scaleforce.com.cy", "jelastic.dogado.eu", "fi.cloudplatform.fi", "demo.datacenter.fi", "paas.datacenter.fi", "jele.host", "mircloud.host", "paas.beebyte.io", "sekd1.beebyteapp.io", "jele.io", "jc.neen.it", "jcloud.kz", "cloudjiffy.net", "fra1-de.cloudjiffy.net", "west1-us.cloudjiffy.net", "jls-sto1.elastx.net", "jls-sto2.elastx.net", "jls-sto3.elastx.net", "fr-1.paas.massivegrid.net", "lon-1.paas.massivegrid.net", "lon-2.paas.massivegrid.net", "ny-1.paas.massivegrid.net", "ny-2.paas.massivegrid.net", "sg-1.paas.massivegrid.net", "jelastic.saveincloud.net", "nordeste-idc.saveincloud.net", "j.scaleforce.net", "sdscloud.pl", "unicloud.pl", "mircloud.ru", "enscaled.sg", "jele.site", "jelastic.team", "orangecloud.tn", "j.layershift.co.uk", "phx.enscaled.us", "mircloud.us", "myjino.ru", "*.hosting.myjino.ru", "*.landing.myjino.ru", "*.spectrum.myjino.ru", "*.vps.myjino.ru", "jotelulu.cloud", "webadorsite.com", "jouwweb.site", "*.cns.joyent.com", "*.triton.zone", "js.org", "kaas.gg", "khplay.nl", "kapsi.fi", "ezproxy.kuleuven.be", "kuleuven.cloud", "keymachine.de", "kinghost.net", "uni5.net", "knightpoint.systems", "koobin.events", "webthings.io", "krellian.net", "oya.to", "git-repos.de", "lcube-server.de", "svn-repos.de", "leadpages.co", "lpages.co", "lpusercontent.com", "lelux.site", "libp2p.direct", "runcontainers.dev", "co.business", "co.education", "co.events", "co.financial", "co.network", "co.place", "co.technology", "linkyard-cloud.ch", "linkyard.cloud", "members.linode.com", "*.nodebalancer.linode.com", "*.linodeobjects.com", "ip.linodeusercontent.com", "we.bs", "filegear-sg.me", "ggff.net", "*.user.localcert.dev", "lodz.pl", "pabianice.pl", "plock.pl", "sieradz.pl", "skierniewice.pl", "zgierz.pl", "loginline.app", "loginline.dev", "loginline.io", "loginline.services", "loginline.site", "lohmus.me", "servers.run", "krasnik.pl", "leczna.pl", "lubartow.pl", "lublin.pl", "poniatowa.pl", "swidnik.pl", "glug.org.uk", "lug.org.uk", "lugs.org.uk", "barsy.bg", "barsy.club", "barsycenter.com", "barsyonline.com", "barsy.de", "barsy.dev", "barsy.eu", "barsy.gr", "barsy.in", "barsy.info", "barsy.io", "barsy.me", "barsy.menu", "barsyonline.menu", "barsy.mobi", "barsy.net", "barsy.online", "barsy.org", "barsy.pro", "barsy.pub", "barsy.ro", "barsy.rs", "barsy.shop", "barsyonline.shop", "barsy.site", "barsy.store", "barsy.support", "barsy.uk", "barsy.co.uk", "barsyonline.co.uk", "*.magentosite.cloud", "hb.cldmail.ru", "matlab.cloud", "modelscape.com", "mwcloudnonprod.com", "polyspace.com", "mayfirst.info", "mayfirst.org", "mazeplay.com", "mcdir.me", "mcdir.ru", "vps.mcdir.ru", "mcpre.ru", "mediatech.by", "mediatech.dev", "hra.health", "medusajs.app", "miniserver.com", "memset.net", "messerli.app", "atmeta.com", "apps.fbsbx.com", "*.cloud.metacentrum.cz", "custom.metacentrum.cz", "flt.cloud.muni.cz", "usr.cloud.muni.cz", "meteorapp.com", "eu.meteorapp.com", "co.pl", "*.azurecontainer.io", "azure-api.net", "azure-mobile.net", "azureedge.net", "azurefd.net", "azurestaticapps.net", "1.azurestaticapps.net", "2.azurestaticapps.net", "3.azurestaticapps.net", "4.azurestaticapps.net", "5.azurestaticapps.net", "6.azurestaticapps.net", "7.azurestaticapps.net", "centralus.azurestaticapps.net", "eastasia.azurestaticapps.net", "eastus2.azurestaticapps.net", "westeurope.azurestaticapps.net", "westus2.azurestaticapps.net", "azurewebsites.net", "cloudapp.net", "trafficmanager.net", "blob.core.windows.net", "servicebus.windows.net", "routingthecloud.com", "sn.mynetname.net", "routingthecloud.net", "routingthecloud.org", "csx.cc", "mydbserver.com", "webspaceconfig.de", "mittwald.info", "mittwaldserver.info", "typo3server.info", "project.space", "modx.dev", "bmoattachments.org", "net.ru", "org.ru", "pp.ru", "hostedpi.com", "caracal.mythic-beasts.com", "customer.mythic-beasts.com", "fentiger.mythic-beasts.com", "lynx.mythic-beasts.com", "ocelot.mythic-beasts.com", "oncilla.mythic-beasts.com", "onza.mythic-beasts.com", "sphinx.mythic-beasts.com", "vs.mythic-beasts.com", "x.mythic-beasts.com", "yali.mythic-beasts.com", "cust.retrosnub.co.uk", "ui.nabu.casa", "cloud.nospamproxy.com", "netfy.app", "netlify.app", "4u.com", "nfshost.com", "ipfs.nftstorage.link", "ngo.us", "ngrok.app", "ngrok-free.app", "ngrok.dev", "ngrok-free.dev", "ngrok.io", "ap.ngrok.io", "au.ngrok.io", "eu.ngrok.io", "in.ngrok.io", "jp.ngrok.io", "sa.ngrok.io", "us.ngrok.io", "ngrok.pizza", "ngrok.pro", "torun.pl", "nh-serv.co.uk", "nimsite.uk", "mmafan.biz", "myftp.biz", "no-ip.biz", "no-ip.ca", "fantasyleague.cc", "gotdns.ch", "3utilities.com", "blogsyte.com", "ciscofreak.com", "damnserver.com", "ddnsking.com", "ditchyourip.com", "dnsiskinky.com", "dynns.com", "geekgalaxy.com", "health-carereform.com", "homesecuritymac.com", "homesecuritypc.com", "myactivedirectory.com", "mysecuritycamera.com", "myvnc.com", "net-freaks.com", "onthewifi.com", "point2this.com", "quicksytes.com", "securitytactics.com", "servebeer.com", "servecounterstrike.com", "serveexchange.com", "serveftp.com", "servegame.com", "servehalflife.com", "servehttp.com", "servehumour.com", "serveirc.com", "servemp3.com", "servep2p.com", "servepics.com", "servequake.com", "servesarcasm.com", "stufftoread.com", "unusualperson.com", "workisboring.com", "dvrcam.info", "ilovecollege.info", "no-ip.info", "brasilia.me", "ddns.me", "dnsfor.me", "hopto.me", "loginto.me", "noip.me", "webhop.me", "bounceme.net", "ddns.net", "eating-organic.net", "mydissent.net", "myeffect.net", "mymediapc.net", "mypsx.net", "mysecuritycamera.net", "nhlfan.net", "no-ip.net", "pgafan.net", "privatizehealthinsurance.net", "redirectme.net", "serveblog.net", "serveminecraft.net", "sytes.net", "cable-modem.org", "collegefan.org", "couchpotatofries.org", "hopto.org", "mlbfan.org", "myftp.org", "mysecuritycamera.org", "nflfan.org", "no-ip.org", "read-books.org", "ufcfan.org", "zapto.org", "no-ip.co.uk", "golffan.us", "noip.us", "pointto.us", "stage.nodeart.io", "*.developer.app", "noop.app", "*.northflank.app", "*.build.run", "*.code.run", "*.database.run", "*.migration.run", "noticeable.news", "notion.site", "dnsking.ch", "mypi.co", "n4t.co", "001www.com", "myiphost.com", "forumz.info", "soundcast.me", "tcp4.me", "dnsup.net", "hicam.net", "now-dns.net", "ownip.net", "vpndns.net", "dynserv.org", "now-dns.org", "x443.pw", "now-dns.top", "ntdll.top", "freeddns.us", "nsupdate.info", "nerdpol.ovh", "nyc.mn", "prvcy.page", "obl.ong", "observablehq.cloud", "static.observableusercontent.com", "omg.lol", "cloudycluster.net", "omniwe.site", "123webseite.at", "123website.be", "simplesite.com.br", "123website.ch", "simplesite.com", "123webseite.de", "123hjemmeside.dk", "123miweb.es", "123kotisivu.fi", "123siteweb.fr", "simplesite.gr", "123homepage.it", "123website.lu", "123website.nl", "123hjemmeside.no", "service.one", "simplesite.pl", "123paginaweb.pt", "123minsida.se", "is-a-fullstack.dev", "is-cool.dev", "is-not-a.dev", "localplayer.dev", "is-local.org", "opensocial.site", "opencraft.hosting", "16-b.it", "32-b.it", "64-b.it", "orsites.com", "operaunite.com", "*.customer-oci.com", "*.oci.customer-oci.com", "*.ocp.customer-oci.com", "*.ocs.customer-oci.com", "*.oraclecloudapps.com", "*.oraclegovcloudapps.com", "*.oraclegovcloudapps.uk", "tech.orange", "can.re", "authgear-staging.com", "authgearapps.com", "skygearapp.com", "outsystemscloud.com", "*.hosting.ovh.net", "*.webpaas.ovh.net", "ownprovider.com", "own.pm", "*.owo.codes", "ox.rs", "oy.lc", "pgfog.com", "pagexl.com", "gotpantheon.com", "pantheonsite.io", "*.paywhirl.com", "*.xmit.co", "xmit.dev", "madethis.site", "srv.us", "gh.srv.us", "gl.srv.us", "lk3.ru", "mypep.link", "perspecta.cloud", "on-web.fr", "*.upsun.app", "upsunapp.com", "ent.platform.sh", "eu.platform.sh", "us.platform.sh", "*.platformsh.site", "*.tst.site", "platter-app.com", "platter-app.dev", "platterp.us", "pley.games", "onporter.run", "co.bn", "postman-echo.com", "pstmn.io", "mock.pstmn.io", "httpbin.org", "prequalifyme.today", "xen.prgmr.com", "priv.at", "protonet.io", "chirurgiens-dentistes-en-france.fr", "byen.site", "pubtls.org", "pythonanywhere.com", "eu.pythonanywhere.com", "qa2.com", "qcx.io", "*.sys.qcx.io", "myqnapcloud.cn", "alpha-myqnapcloud.com", "dev-myqnapcloud.com", "mycloudnas.com", "mynascloud.com", "myqnapcloud.com", "qoto.io", "qualifioapp.com", "ladesk.com", "qbuser.com", "*.quipelements.com", "vapor.cloud", "vaporcloud.io", "rackmaze.com", "rackmaze.net", "cloudsite.builders", "myradweb.net", "servername.us", "web.in", "in.net", "myrdbx.io", "site.rb-hosting.io", "*.on-rancher.cloud", "*.on-k3s.io", "*.on-rio.io", "ravpage.co.il", "readthedocs-hosted.com", "readthedocs.io", "rhcloud.com", "instances.spawn.cc", "onrender.com", "app.render.com", "replit.app", "id.replit.app", "firewalledreplit.co", "id.firewalledreplit.co", "repl.co", "id.repl.co", "replit.dev", "archer.replit.dev", "bones.replit.dev", "canary.replit.dev", "global.replit.dev", "hacker.replit.dev", "id.replit.dev", "janeway.replit.dev", "kim.replit.dev", "kira.replit.dev", "kirk.replit.dev", "odo.replit.dev", "paris.replit.dev", "picard.replit.dev", "pike.replit.dev", "prerelease.replit.dev", "reed.replit.dev", "riker.replit.dev", "sisko.replit.dev", "spock.replit.dev", "staging.replit.dev", "sulu.replit.dev", "tarpit.replit.dev", "teams.replit.dev", "tucker.replit.dev", "wesley.replit.dev", "worf.replit.dev", "repl.run", "resindevice.io", "devices.resinstaging.io", "hzc.io", "adimo.co.uk", "itcouldbewor.se", "aus.basketball", "nz.basketball", "git-pages.rit.edu", "rocky.page", "rub.de", "ruhr-uni-bochum.de", "io.noc.ruhr-uni-bochum.de", "Ð±Ð¸Ð·.Ñ€ÑƒÑ", "ÐºÐ¾Ð¼.Ñ€ÑƒÑ", "ÐºÑ€Ñ‹Ð¼.Ñ€ÑƒÑ", "Ð¼Ð¸Ñ€.Ñ€ÑƒÑ", "Ð¼ÑÐº.Ñ€ÑƒÑ", "Ð¾Ñ€Ð³.Ñ€ÑƒÑ", "ÑÐ°Ð¼Ð°Ñ€Ð°.Ñ€ÑƒÑ", "ÑÐ¾Ñ‡Ð¸.Ñ€ÑƒÑ", "ÑÐ¿Ð±.Ñ€ÑƒÑ", "Ñ.Ñ€ÑƒÑ", "ras.ru", "nyat.app", "180r.com", "dojin.com", "sakuratan.com", "sakuraweb.com", "x0.com", "2-d.jp", "bona.jp", "crap.jp", "daynight.jp", "eek.jp", "flop.jp", "halfmoon.jp", "jeez.jp", "matrix.jp", "mimoza.jp", "ivory.ne.jp", "mail-box.ne.jp", "mints.ne.jp", "mokuren.ne.jp", "opal.ne.jp", "sakura.ne.jp", "sumomo.ne.jp", "topaz.ne.jp", "netgamers.jp", "nyanta.jp", "o0o0.jp", "rdy.jp", "rgr.jp", "rulez.jp", "s3.isk01.sakurastorage.jp", "s3.isk02.sakurastorage.jp", "saloon.jp", "sblo.jp", "skr.jp", "tank.jp", "uh-oh.jp", "undo.jp", "rs.webaccel.jp", "user.webaccel.jp", "websozai.jp", "xii.jp", "squares.net", "jpn.org", "kirara.st", "x0.to", "from.tv", "sakura.tv", "*.builder.code.com", "*.dev-builder.code.com", "*.stg-builder.code.com", "*.001.test.code-builder-stg.platform.salesforce.com", "*.d.crm.dev", "*.w.crm.dev", "*.wa.crm.dev", "*.wb.crm.dev", "*.wc.crm.dev", "*.wd.crm.dev", "*.we.crm.dev", "*.wf.crm.dev", "sandcats.io", "logoip.com", "logoip.de", "fr-par-1.baremetal.scw.cloud", "fr-par-2.baremetal.scw.cloud", "nl-ams-1.baremetal.scw.cloud", "cockpit.fr-par.scw.cloud", "fnc.fr-par.scw.cloud", "functions.fnc.fr-par.scw.cloud", "k8s.fr-par.scw.cloud", "nodes.k8s.fr-par.scw.cloud", "s3.fr-par.scw.cloud", "s3-website.fr-par.scw.cloud", "whm.fr-par.scw.cloud", "priv.instances.scw.cloud", "pub.instances.scw.cloud", "k8s.scw.cloud", "cockpit.nl-ams.scw.cloud", "k8s.nl-ams.scw.cloud", "nodes.k8s.nl-ams.scw.cloud", "s3.nl-ams.scw.cloud", "s3-website.nl-ams.scw.cloud", "whm.nl-ams.scw.cloud", "cockpit.pl-waw.scw.cloud", "k8s.pl-waw.scw.cloud", "nodes.k8s.pl-waw.scw.cloud", "s3.pl-waw.scw.cloud", "s3-website.pl-waw.scw.cloud", "scalebook.scw.cloud", "smartlabeling.scw.cloud", "dedibox.fr", "schokokeks.net", "gov.scot", "service.gov.scot", "scrysec.com", "client.scrypted.io", "firewall-gateway.com", "firewall-gateway.de", "my-gateway.de", "my-router.de", "spdns.de", "spdns.eu", "firewall-gateway.net", "my-firewall.org", "myfirewall.org", "spdns.org", "seidat.net", "sellfy.store", "minisite.ms", "senseering.net", "servebolt.cloud", "biz.ua", "co.ua", "pp.ua", "as.sh.cn", "sheezy.games", "shiftedit.io", "myshopblocks.com", "myshopify.com", "shopitsite.com", "shopware.shop", "shopware.store", "mo-siemens.io", "1kapp.com", "appchizi.com", "applinzi.com", "sinaapp.com", "vipsinaapp.com", "siteleaf.net", "small-web.org", "aeroport.fr", "avocat.fr", "chambagri.fr", "chirurgiens-dentistes.fr", "experts-comptables.fr", "medecin.fr", "notaires.fr", "pharmacien.fr", "port.fr", "veterinaire.fr", "vp4.me", "*.snowflake.app", "*.privatelink.snowflake.app", "streamlit.app", "streamlitapp.com", "try-snowplow.com", "mafelo.net", "playstation-cloud.com", "srht.site", "apps.lair.io", "*.stolos.io", "spacekit.io", "ind.mom", "customer.speedpartner.de", "myspreadshop.at", "myspreadshop.com.au", "myspreadshop.be", "myspreadshop.ca", "myspreadshop.ch", "myspreadshop.com", "myspreadshop.de", "myspreadshop.dk", "myspreadshop.es", "myspreadshop.fi", "myspreadshop.fr", "myspreadshop.ie", "myspreadshop.it", "myspreadshop.net", "myspreadshop.nl", "myspreadshop.no", "myspreadshop.pl", "myspreadshop.se", "myspreadshop.co.uk", "w-corp-staticblitz.com", "w-credentialless-staticblitz.com", "w-staticblitz.com", "stackhero-network.com", "runs.onstackit.cloud", "stackit.gg", "stackit.rocks", "stackit.run", "stackit.zone", "musician.io", "novecore.site", "api.stdlib.com", "feedback.ac", "forms.ac", "assessments.cx", "calculators.cx", "funnels.cx", "paynow.cx", "quizzes.cx", "researched.cx", "tests.cx", "surveys.so", "storebase.store", "storipress.app", "storj.farm", "strapiapp.com", "media.strapiapp.com", "vps-host.net", "atl.jelastic.vps-host.net", "njs.jelastic.vps-host.net", "ric.jelastic.vps-host.net", "streak-link.com", "streaklinks.com", "streakusercontent.com", "soc.srcf.net", "user.srcf.net", "utwente.io", "temp-dns.com", "supabase.co", "supabase.in", "supabase.net", "syncloud.it", "dscloud.biz", "direct.quickconnect.cn", "dsmynas.com", "familyds.com", "diskstation.me", "dscloud.me", "i234.me", "myds.me", "synology.me", "dscloud.mobi", "dsmynas.net", "familyds.net", "dsmynas.org", "familyds.org", "direct.quickconnect.to", "vpnplus.to", "mytabit.com", "mytabit.co.il", "tabitorder.co.il", "taifun-dns.de", "ts.net", "*.c.ts.net", "gda.pl", "gdansk.pl", "gdynia.pl", "med.pl", "sopot.pl", "taveusercontent.com", "p.tawk.email", "p.tawkto.email", "site.tb-hosting.com", "edugit.io", "s3.teckids.org", "telebit.app", "telebit.io", "*.telebit.xyz", "*.firenet.ch", "*.svc.firenet.ch", "reservd.com", "thingdustdata.com", "cust.dev.thingdust.io", "reservd.dev.thingdust.io", "cust.disrec.thingdust.io", "reservd.disrec.thingdust.io", "cust.prod.thingdust.io", "cust.testing.thingdust.io", "reservd.testing.thingdust.io", "tickets.io", "arvo.network", "azimuth.network", "tlon.network", "torproject.net", "pages.torproject.net", "townnews-staging.com", "12hp.at", "2ix.at", "4lima.at", "lima-city.at", "12hp.ch", "2ix.ch", "4lima.ch", "lima-city.ch", "trafficplex.cloud", "de.cool", "12hp.de", "2ix.de", "4lima.de", "lima-city.de", "1337.pictures", "clan.rip", "lima-city.rocks", "webspace.rocks", "lima.zone", "*.transurl.be", "*.transurl.eu", "site.transip.me", "*.transurl.nl", "tuxfamily.org", "dd-dns.de", "dray-dns.de", "draydns.de", "dyn-vpn.de", "dynvpn.de", "mein-vigor.de", "my-vigor.de", "my-wan.de", "syno-ds.de", "synology-diskstation.de", "synology-ds.de", "diskstation.eu", "diskstation.org", "typedream.app", "pro.typeform.com", "*.uberspace.de", "uber.space", "hk.com", "inc.hk", "ltd.hk", "hk.org", "it.com", "unison-services.cloud", "virtual-user.de", "virtualuser.de", "name.pm", "sch.tf", "biz.wf", "sch.wf", "org.yt", "rs.ba", "bielsko.pl", "upli.io", "urown.cloud", "dnsupdate.info", "us.org", "v.ua", "express.val.run", "web.val.run", "vercel.app", "v0.build", "vercel.dev", "vusercontent.net", "now.sh", "2038.io", "router.management", "v-info.info", "voorloper.cloud", "*.vultrobjects.com", "wafflecell.com", "webflow.io", "webflowtest.io", "*.webhare.dev", "bookonline.app", "hotelwithflight.com", "reserve-online.com", "reserve-online.net", "cprapid.com", "pleskns.com", "wp2.host", "pdns.page", "plesk.page", "wpsquared.site", "*.wadl.top", "remotewd.com", "box.ca", "pages.wiardweb.com", "toolforge.org", "wmcloud.org", "wmflabs.org", "wdh.app", "panel.gg", "daemon.panel.gg", "wixsite.com", "wixstudio.com", "editorx.io", "wixstudio.io", "wix.run", "messwithdns.com", "woltlab-demo.com", "myforum.community", "community-pro.de", "diskussionsbereich.de", "community-pro.net", "meinforum.net", "affinitylottery.org.uk", "raffleentry.org.uk", "weeklylottery.org.uk", "wpenginepowered.com", "js.wpenginepowered.com", "half.host", "xnbay.com", "u2.xnbay.com", "u2-local.xnbay.com", "cistron.nl", "demon.nl", "xs4all.space", "yandexcloud.net", "storage.yandexcloud.net", "website.yandexcloud.net", "official.academy", "yolasite.com", "yombo.me", "ynh.fr", "nohost.me", "noho.st", "za.net", "za.org", "zap.cloud", "zeabur.app", "bss.design", "basicserver.io", "virtualserver.io", "enterprisecloud.nu"], Z = Y.reduce((e, s) => {
      const c = s.replace(/^(\*\.|\!)/, ""), o = A.toASCII(c), t = s.charAt(0);
      if (e.has(o)) throw new Error(`Multiple rules found for ${s} (${o})`);
      return e.set(o, { rule: s, suffix: c, punySuffix: o, wildcard: t === "*", exception: t === "!" }), e;
    }, /* @__PURE__ */ new Map()), aa = (e) => {
      const c = A.toASCII(e).split(".");
      for (let o = 0; o < c.length; o++) {
        const t = c.slice(o).join("."), d = Z.get(t);
        if (d) return d;
      }
      return null;
    }, H = { DOMAIN_TOO_SHORT: "Domain name too short.", DOMAIN_TOO_LONG: "Domain name too long. It should be no more than 255 chars.", LABEL_STARTS_WITH_DASH: "Domain name label can not start with a dash.", LABEL_ENDS_WITH_DASH: "Domain name label can not end with a dash.", LABEL_TOO_LONG: "Domain name label should be at most 63 chars long.", LABEL_TOO_SHORT: "Domain name label should be at least 1 character long.", LABEL_INVALID_CHARS: "Domain name label can only contain alphanumeric characters or dashes." }, oa = (e) => {
      const s = A.toASCII(e);
      if (s.length < 1) return "DOMAIN_TOO_SHORT";
      if (s.length > 255) return "DOMAIN_TOO_LONG";
      const c = s.split(".");
      let o;
      for (let t = 0; t < c.length; ++t) {
        if (o = c[t], !o.length) return "LABEL_TOO_SHORT";
        if (o.length > 63) return "LABEL_TOO_LONG";
        if (o.charAt(0) === "-") return "LABEL_STARTS_WITH_DASH";
        if (o.charAt(o.length - 1) === "-") return "LABEL_ENDS_WITH_DASH";
        if (!/^[a-z0-9\-_]+$/.test(o)) return "LABEL_INVALID_CHARS";
      }
    }, _ = (e) => {
      if (typeof e != "string") throw new TypeError("Domain name must be a string.");
      let s = e.slice(0).toLowerCase();
      s.charAt(s.length - 1) === "." && (s = s.slice(0, s.length - 1));
      const c = oa(s);
      if (c) return { input: e, error: { message: H[c], code: c } };
      const o = { input: e, tld: null, sld: null, domain: null, subdomain: null, listed: false }, t = s.split(".");
      if (t[t.length - 1] === "local") return o;
      const d = () => (/xn--/.test(s) && (o.domain && (o.domain = A.toASCII(o.domain)), o.subdomain && (o.subdomain = A.toASCII(o.subdomain))), o), z = aa(s);
      if (!z) return t.length < 2 ? o : (o.tld = t.pop(), o.sld = t.pop(), o.domain = [o.sld, o.tld].join("."), t.length && (o.subdomain = t.pop()), d());
      o.listed = true;
      const y = z.suffix.split("."), g = t.slice(0, t.length - y.length);
      return z.exception && g.push(y.shift()), o.tld = y.join("."), !g.length || (z.wildcard && (y.unshift(g.pop()), o.tld = y.join(".")), !g.length) || (o.sld = g.pop(), o.domain = [o.sld, o.tld].join("."), g.length && (o.subdomain = g.join("."))), d();
    }, N = (e) => e && _(e).domain || null, R = (e) => {
      const s = _(e);
      return !!(s.domain && s.listed);
    }, sa = { parse: _, get: N, isValid: R };
    exports$1.default = sa;
    exports$1.errorCodes = H;
    exports$1.get = N;
    exports$1.isValid = R;
    exports$1.parse = _;
  })(psl);
  return psl;
}
var hasRequiredPubsuffixPsl;
function requirePubsuffixPsl() {
  if (hasRequiredPubsuffixPsl) return pubsuffixPsl;
  hasRequiredPubsuffixPsl = 1;
  var psl2 = requirePsl();
  function getPublicSuffix(domain) {
    return psl2.get(domain);
  }
  pubsuffixPsl.getPublicSuffix = getPublicSuffix;
  return pubsuffixPsl;
}
var store = {};
var hasRequiredStore;
function requireStore() {
  if (hasRequiredStore) return store;
  hasRequiredStore = 1;
  function Store() {
  }
  store.Store = Store;
  Store.prototype.synchronous = false;
  Store.prototype.findCookie = function(domain, path, key2, cb) {
    throw new Error("findCookie is not implemented");
  };
  Store.prototype.findCookies = function(domain, path, cb) {
    throw new Error("findCookies is not implemented");
  };
  Store.prototype.putCookie = function(cookie2, cb) {
    throw new Error("putCookie is not implemented");
  };
  Store.prototype.updateCookie = function(oldCookie, newCookie, cb) {
    throw new Error("updateCookie is not implemented");
  };
  Store.prototype.removeCookie = function(domain, path, key2, cb) {
    throw new Error("removeCookie is not implemented");
  };
  Store.prototype.removeCookies = function(domain, path, cb) {
    throw new Error("removeCookies is not implemented");
  };
  Store.prototype.removeAllCookies = function(cb) {
    throw new Error("removeAllCookies is not implemented");
  };
  Store.prototype.getAllCookies = function(cb) {
    throw new Error("getAllCookies is not implemented (therefore jar cannot be serialized)");
  };
  return store;
}
var memstore = {};
var permuteDomain = {};
var hasRequiredPermuteDomain;
function requirePermuteDomain() {
  if (hasRequiredPermuteDomain) return permuteDomain;
  hasRequiredPermuteDomain = 1;
  var pubsuffix = requirePubsuffixPsl();
  function permuteDomain$1(domain) {
    var pubSuf = pubsuffix.getPublicSuffix(domain);
    if (!pubSuf) {
      return null;
    }
    if (pubSuf == domain) {
      return [domain];
    }
    var prefix = domain.slice(0, -(pubSuf.length + 1));
    var parts = prefix.split(".").reverse();
    var cur = pubSuf;
    var permutations = [cur];
    while (parts.length) {
      cur = parts.shift() + "." + cur;
      permutations.push(cur);
    }
    return permutations;
  }
  permuteDomain.permuteDomain = permuteDomain$1;
  return permuteDomain;
}
var pathMatch = {};
var hasRequiredPathMatch;
function requirePathMatch() {
  if (hasRequiredPathMatch) return pathMatch;
  hasRequiredPathMatch = 1;
  function pathMatch$1(reqPath, cookiePath) {
    if (cookiePath === reqPath) {
      return true;
    }
    var idx = reqPath.indexOf(cookiePath);
    if (idx === 0) {
      if (cookiePath.substr(-1) === "/") {
        return true;
      }
      if (reqPath.substr(cookiePath.length, 1) === "/") {
        return true;
      }
    }
    return false;
  }
  pathMatch.pathMatch = pathMatch$1;
  return pathMatch;
}
var hasRequiredMemstore;
function requireMemstore() {
  if (hasRequiredMemstore) return memstore;
  hasRequiredMemstore = 1;
  var Store = requireStore().Store;
  var permuteDomain2 = requirePermuteDomain().permuteDomain;
  var pathMatch2 = requirePathMatch().pathMatch;
  var util2 = require$$0$5;
  function MemoryCookieStore() {
    Store.call(this);
    this.idx = {};
  }
  util2.inherits(MemoryCookieStore, Store);
  memstore.MemoryCookieStore = MemoryCookieStore;
  MemoryCookieStore.prototype.idx = null;
  MemoryCookieStore.prototype.synchronous = true;
  MemoryCookieStore.prototype.inspect = function() {
    return "{ idx: " + util2.inspect(this.idx, false, 2) + " }";
  };
  if (util2.inspect.custom) {
    MemoryCookieStore.prototype[util2.inspect.custom] = MemoryCookieStore.prototype.inspect;
  }
  MemoryCookieStore.prototype.findCookie = function(domain, path, key2, cb) {
    if (!this.idx[domain]) {
      return cb(null, void 0);
    }
    if (!this.idx[domain][path]) {
      return cb(null, void 0);
    }
    return cb(null, this.idx[domain][path][key2] || null);
  };
  MemoryCookieStore.prototype.findCookies = function(domain, path, cb) {
    var results = [];
    if (!domain) {
      return cb(null, []);
    }
    var pathMatcher;
    if (!path) {
      pathMatcher = function matchAll(domainIndex) {
        for (var curPath in domainIndex) {
          var pathIndex = domainIndex[curPath];
          for (var key2 in pathIndex) {
            results.push(pathIndex[key2]);
          }
        }
      };
    } else {
      pathMatcher = function matchRFC(domainIndex) {
        Object.keys(domainIndex).forEach(function(cookiePath) {
          if (pathMatch2(path, cookiePath)) {
            var pathIndex = domainIndex[cookiePath];
            for (var key2 in pathIndex) {
              results.push(pathIndex[key2]);
            }
          }
        });
      };
    }
    var domains = permuteDomain2(domain) || [domain];
    var idx = this.idx;
    domains.forEach(function(curDomain) {
      var domainIndex = idx[curDomain];
      if (!domainIndex) {
        return;
      }
      pathMatcher(domainIndex);
    });
    cb(null, results);
  };
  MemoryCookieStore.prototype.putCookie = function(cookie2, cb) {
    if (!this.idx[cookie2.domain]) {
      this.idx[cookie2.domain] = {};
    }
    if (!this.idx[cookie2.domain][cookie2.path]) {
      this.idx[cookie2.domain][cookie2.path] = {};
    }
    this.idx[cookie2.domain][cookie2.path][cookie2.key] = cookie2;
    cb(null);
  };
  MemoryCookieStore.prototype.updateCookie = function(oldCookie, newCookie, cb) {
    this.putCookie(newCookie, cb);
  };
  MemoryCookieStore.prototype.removeCookie = function(domain, path, key2, cb) {
    if (this.idx[domain] && this.idx[domain][path] && this.idx[domain][path][key2]) {
      delete this.idx[domain][path][key2];
    }
    cb(null);
  };
  MemoryCookieStore.prototype.removeCookies = function(domain, path, cb) {
    if (this.idx[domain]) {
      if (path) {
        delete this.idx[domain][path];
      } else {
        delete this.idx[domain];
      }
    }
    return cb(null);
  };
  MemoryCookieStore.prototype.removeAllCookies = function(cb) {
    this.idx = {};
    return cb(null);
  };
  MemoryCookieStore.prototype.getAllCookies = function(cb) {
    var cookies2 = [];
    var idx = this.idx;
    var domains = Object.keys(idx);
    domains.forEach(function(domain) {
      var paths = Object.keys(idx[domain]);
      paths.forEach(function(path) {
        var keys = Object.keys(idx[domain][path]);
        keys.forEach(function(key2) {
          if (key2 !== null) {
            cookies2.push(idx[domain][path][key2]);
          }
        });
      });
    });
    cookies2.sort(function(a, b) {
      return (a.creationIndex || 0) - (b.creationIndex || 0);
    });
    cb(null, cookies2);
  };
  return memstore;
}
var version;
var hasRequiredVersion;
function requireVersion() {
  if (hasRequiredVersion) return version;
  hasRequiredVersion = 1;
  version = "2.5.0";
  return version;
}
var hasRequiredCookie;
function requireCookie() {
  if (hasRequiredCookie) return cookie;
  hasRequiredCookie = 1;
  var net = require$$0$8;
  var urlParse = require$$0$7.parse;
  var util2 = require$$0$5;
  var pubsuffix = requirePubsuffixPsl();
  var Store = requireStore().Store;
  var MemoryCookieStore = requireMemstore().MemoryCookieStore;
  var pathMatch2 = requirePathMatch().pathMatch;
  var VERSION = requireVersion();
  var punycode;
  try {
    punycode = require("punycode");
  } catch (e) {
    console.warn("tough-cookie: can't load punycode; won't use punycode for domain normalization");
  }
  var COOKIE_OCTETS = /^[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]+$/;
  var CONTROL_CHARS = /[\x00-\x1F]/;
  var TERMINATORS = ["\n", "\r", "\0"];
  var PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/;
  var DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;
  var MONTH_TO_NUM = {
    jan: 0,
    feb: 1,
    mar: 2,
    apr: 3,
    may: 4,
    jun: 5,
    jul: 6,
    aug: 7,
    sep: 8,
    oct: 9,
    nov: 10,
    dec: 11
  };
  var NUM_TO_MONTH = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  var NUM_TO_DAY = [
    "Sun",
    "Mon",
    "Tue",
    "Wed",
    "Thu",
    "Fri",
    "Sat"
  ];
  var MAX_TIME = 2147483647e3;
  var MIN_TIME = 0;
  function parseDigits(token, minDigits, maxDigits, trailingOK) {
    var count = 0;
    while (count < token.length) {
      var c = token.charCodeAt(count);
      if (c <= 47 || c >= 58) {
        break;
      }
      count++;
    }
    if (count < minDigits || count > maxDigits) {
      return null;
    }
    if (!trailingOK && count != token.length) {
      return null;
    }
    return parseInt(token.substr(0, count), 10);
  }
  function parseTime(token) {
    var parts = token.split(":");
    var result = [0, 0, 0];
    if (parts.length !== 3) {
      return null;
    }
    for (var i = 0; i < 3; i++) {
      var trailingOK = i == 2;
      var num = parseDigits(parts[i], 1, 2, trailingOK);
      if (num === null) {
        return null;
      }
      result[i] = num;
    }
    return result;
  }
  function parseMonth(token) {
    token = String(token).substr(0, 3).toLowerCase();
    var num = MONTH_TO_NUM[token];
    return num >= 0 ? num : null;
  }
  function parseDate(str) {
    if (!str) {
      return;
    }
    var tokens = str.split(DATE_DELIM);
    if (!tokens) {
      return;
    }
    var hour = null;
    var minute = null;
    var second = null;
    var dayOfMonth = null;
    var month = null;
    var year = null;
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i].trim();
      if (!token.length) {
        continue;
      }
      var result;
      if (second === null) {
        result = parseTime(token);
        if (result) {
          hour = result[0];
          minute = result[1];
          second = result[2];
          continue;
        }
      }
      if (dayOfMonth === null) {
        result = parseDigits(token, 1, 2, true);
        if (result !== null) {
          dayOfMonth = result;
          continue;
        }
      }
      if (month === null) {
        result = parseMonth(token);
        if (result !== null) {
          month = result;
          continue;
        }
      }
      if (year === null) {
        result = parseDigits(token, 2, 4, true);
        if (result !== null) {
          year = result;
          if (year >= 70 && year <= 99) {
            year += 1900;
          } else if (year >= 0 && year <= 69) {
            year += 2e3;
          }
        }
      }
    }
    if (dayOfMonth === null || month === null || year === null || second === null || dayOfMonth < 1 || dayOfMonth > 31 || year < 1601 || hour > 23 || minute > 59 || second > 59) {
      return;
    }
    return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));
  }
  function formatDate(date) {
    var d = date.getUTCDate();
    d = d >= 10 ? d : "0" + d;
    var h = date.getUTCHours();
    h = h >= 10 ? h : "0" + h;
    var m = date.getUTCMinutes();
    m = m >= 10 ? m : "0" + m;
    var s = date.getUTCSeconds();
    s = s >= 10 ? s : "0" + s;
    return NUM_TO_DAY[date.getUTCDay()] + ", " + d + " " + NUM_TO_MONTH[date.getUTCMonth()] + " " + date.getUTCFullYear() + " " + h + ":" + m + ":" + s + " GMT";
  }
  function canonicalDomain(str) {
    if (str == null) {
      return null;
    }
    str = str.trim().replace(/^\./, "");
    if (punycode && /[^\u0001-\u007f]/.test(str)) {
      str = punycode.toASCII(str);
    }
    return str.toLowerCase();
  }
  function domainMatch(str, domStr, canonicalize) {
    if (str == null || domStr == null) {
      return null;
    }
    if (canonicalize !== false) {
      str = canonicalDomain(str);
      domStr = canonicalDomain(domStr);
    }
    if (str == domStr) {
      return true;
    }
    if (net.isIP(str)) {
      return false;
    }
    var idx = str.indexOf(domStr);
    if (idx <= 0) {
      return false;
    }
    if (str.length !== domStr.length + idx) {
      return false;
    }
    if (str.substr(idx - 1, 1) !== ".") {
      return false;
    }
    return true;
  }
  function defaultPath(path) {
    if (!path || path.substr(0, 1) !== "/") {
      return "/";
    }
    if (path === "/") {
      return path;
    }
    var rightSlash = path.lastIndexOf("/");
    if (rightSlash === 0) {
      return "/";
    }
    return path.slice(0, rightSlash);
  }
  function trimTerminator(str) {
    for (var t = 0; t < TERMINATORS.length; t++) {
      var terminatorIdx = str.indexOf(TERMINATORS[t]);
      if (terminatorIdx !== -1) {
        str = str.substr(0, terminatorIdx);
      }
    }
    return str;
  }
  function parseCookiePair(cookiePair, looseMode) {
    cookiePair = trimTerminator(cookiePair);
    var firstEq = cookiePair.indexOf("=");
    if (looseMode) {
      if (firstEq === 0) {
        cookiePair = cookiePair.substr(1);
        firstEq = cookiePair.indexOf("=");
      }
    } else {
      if (firstEq <= 0) {
        return;
      }
    }
    var cookieName, cookieValue;
    if (firstEq <= 0) {
      cookieName = "";
      cookieValue = cookiePair.trim();
    } else {
      cookieName = cookiePair.substr(0, firstEq).trim();
      cookieValue = cookiePair.substr(firstEq + 1).trim();
    }
    if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {
      return;
    }
    var c = new Cookie();
    c.key = cookieName;
    c.value = cookieValue;
    return c;
  }
  function parse2(str, options) {
    if (!options || typeof options !== "object") {
      options = {};
    }
    str = str.trim();
    var firstSemi = str.indexOf(";");
    var cookiePair = firstSemi === -1 ? str : str.substr(0, firstSemi);
    var c = parseCookiePair(cookiePair, !!options.loose);
    if (!c) {
      return;
    }
    if (firstSemi === -1) {
      return c;
    }
    var unparsed = str.slice(firstSemi + 1).trim();
    if (unparsed.length === 0) {
      return c;
    }
    var cookie_avs = unparsed.split(";");
    while (cookie_avs.length) {
      var av = cookie_avs.shift().trim();
      if (av.length === 0) {
        continue;
      }
      var av_sep = av.indexOf("=");
      var av_key, av_value;
      if (av_sep === -1) {
        av_key = av;
        av_value = null;
      } else {
        av_key = av.substr(0, av_sep);
        av_value = av.substr(av_sep + 1);
      }
      av_key = av_key.trim().toLowerCase();
      if (av_value) {
        av_value = av_value.trim();
      }
      switch (av_key) {
        case "expires":
          if (av_value) {
            var exp = parseDate(av_value);
            if (exp) {
              c.expires = exp;
            }
          }
          break;
        case "max-age":
          if (av_value) {
            if (/^-?[0-9]+$/.test(av_value)) {
              var delta = parseInt(av_value, 10);
              c.setMaxAge(delta);
            }
          }
          break;
        case "domain":
          if (av_value) {
            var domain = av_value.trim().replace(/^\./, "");
            if (domain) {
              c.domain = domain.toLowerCase();
            }
          }
          break;
        case "path":
          c.path = av_value && av_value[0] === "/" ? av_value : null;
          break;
        case "secure":
          c.secure = true;
          break;
        case "httponly":
          c.httpOnly = true;
          break;
        default:
          c.extensions = c.extensions || [];
          c.extensions.push(av);
          break;
      }
    }
    return c;
  }
  function jsonParse(str) {
    var obj;
    try {
      obj = JSON.parse(str);
    } catch (e) {
      return e;
    }
    return obj;
  }
  function fromJSON(str) {
    if (!str) {
      return null;
    }
    var obj;
    if (typeof str === "string") {
      obj = jsonParse(str);
      if (obj instanceof Error) {
        return null;
      }
    } else {
      obj = str;
    }
    var c = new Cookie();
    for (var i = 0; i < Cookie.serializableProperties.length; i++) {
      var prop = Cookie.serializableProperties[i];
      if (obj[prop] === void 0 || obj[prop] === Cookie.prototype[prop]) {
        continue;
      }
      if (prop === "expires" || prop === "creation" || prop === "lastAccessed") {
        if (obj[prop] === null) {
          c[prop] = null;
        } else {
          c[prop] = obj[prop] == "Infinity" ? "Infinity" : new Date(obj[prop]);
        }
      } else {
        c[prop] = obj[prop];
      }
    }
    return c;
  }
  function cookieCompare(a, b) {
    var cmp = 0;
    var aPathLen = a.path ? a.path.length : 0;
    var bPathLen = b.path ? b.path.length : 0;
    cmp = bPathLen - aPathLen;
    if (cmp !== 0) {
      return cmp;
    }
    var aTime = a.creation ? a.creation.getTime() : MAX_TIME;
    var bTime = b.creation ? b.creation.getTime() : MAX_TIME;
    cmp = aTime - bTime;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = a.creationIndex - b.creationIndex;
    return cmp;
  }
  function permutePath(path) {
    if (path === "/") {
      return ["/"];
    }
    if (path.lastIndexOf("/") === path.length - 1) {
      path = path.substr(0, path.length - 1);
    }
    var permutations = [path];
    while (path.length > 1) {
      var lindex = path.lastIndexOf("/");
      if (lindex === 0) {
        break;
      }
      path = path.substr(0, lindex);
      permutations.push(path);
    }
    permutations.push("/");
    return permutations;
  }
  function getCookieContext(url) {
    if (url instanceof Object) {
      return url;
    }
    try {
      url = decodeURI(url);
    } catch (err) {
    }
    return urlParse(url);
  }
  function Cookie(options) {
    options = options || {};
    Object.keys(options).forEach(function(prop) {
      if (Cookie.prototype.hasOwnProperty(prop) && Cookie.prototype[prop] !== options[prop] && prop.substr(0, 1) !== "_") {
        this[prop] = options[prop];
      }
    }, this);
    this.creation = this.creation || /* @__PURE__ */ new Date();
    Object.defineProperty(this, "creationIndex", {
      configurable: false,
      enumerable: false,
      // important for assert.deepEqual checks
      writable: true,
      value: ++Cookie.cookiesCreated
    });
  }
  Cookie.cookiesCreated = 0;
  Cookie.parse = parse2;
  Cookie.fromJSON = fromJSON;
  Cookie.prototype.key = "";
  Cookie.prototype.value = "";
  Cookie.prototype.expires = "Infinity";
  Cookie.prototype.maxAge = null;
  Cookie.prototype.domain = null;
  Cookie.prototype.path = null;
  Cookie.prototype.secure = false;
  Cookie.prototype.httpOnly = false;
  Cookie.prototype.extensions = null;
  Cookie.prototype.hostOnly = null;
  Cookie.prototype.pathIsDefault = null;
  Cookie.prototype.creation = null;
  Cookie.prototype.lastAccessed = null;
  Object.defineProperty(Cookie.prototype, "creationIndex", {
    configurable: true,
    enumerable: false,
    writable: true,
    value: 0
  });
  Cookie.serializableProperties = Object.keys(Cookie.prototype).filter(function(prop) {
    return !(Cookie.prototype[prop] instanceof Function || prop === "creationIndex" || prop.substr(0, 1) === "_");
  });
  Cookie.prototype.inspect = function inspect() {
    var now = Date.now();
    return 'Cookie="' + this.toString() + "; hostOnly=" + (this.hostOnly != null ? this.hostOnly : "?") + "; aAge=" + (this.lastAccessed ? now - this.lastAccessed.getTime() + "ms" : "?") + "; cAge=" + (this.creation ? now - this.creation.getTime() + "ms" : "?") + '"';
  };
  if (util2.inspect.custom) {
    Cookie.prototype[util2.inspect.custom] = Cookie.prototype.inspect;
  }
  Cookie.prototype.toJSON = function() {
    var obj = {};
    var props = Cookie.serializableProperties;
    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      if (this[prop] === Cookie.prototype[prop]) {
        continue;
      }
      if (prop === "expires" || prop === "creation" || prop === "lastAccessed") {
        if (this[prop] === null) {
          obj[prop] = null;
        } else {
          obj[prop] = this[prop] == "Infinity" ? (
            // intentionally not ===
            "Infinity"
          ) : this[prop].toISOString();
        }
      } else if (prop === "maxAge") {
        if (this[prop] !== null) {
          obj[prop] = this[prop] == Infinity || this[prop] == -Infinity ? this[prop].toString() : this[prop];
        }
      } else {
        if (this[prop] !== Cookie.prototype[prop]) {
          obj[prop] = this[prop];
        }
      }
    }
    return obj;
  };
  Cookie.prototype.clone = function() {
    return fromJSON(this.toJSON());
  };
  Cookie.prototype.validate = function validate2() {
    if (!COOKIE_OCTETS.test(this.value)) {
      return false;
    }
    if (this.expires != Infinity && !(this.expires instanceof Date) && !parseDate(this.expires)) {
      return false;
    }
    if (this.maxAge != null && this.maxAge <= 0) {
      return false;
    }
    if (this.path != null && !PATH_VALUE.test(this.path)) {
      return false;
    }
    var cdomain = this.cdomain();
    if (cdomain) {
      if (cdomain.match(/\.$/)) {
        return false;
      }
      var suffix = pubsuffix.getPublicSuffix(cdomain);
      if (suffix == null) {
        return false;
      }
    }
    return true;
  };
  Cookie.prototype.setExpires = function setExpires(exp) {
    if (exp instanceof Date) {
      this.expires = exp;
    } else {
      this.expires = parseDate(exp) || "Infinity";
    }
  };
  Cookie.prototype.setMaxAge = function setMaxAge(age) {
    if (age === Infinity || age === -Infinity) {
      this.maxAge = age.toString();
    } else {
      this.maxAge = age;
    }
  };
  Cookie.prototype.cookieString = function cookieString() {
    var val = this.value;
    if (val == null) {
      val = "";
    }
    if (this.key === "") {
      return val;
    }
    return this.key + "=" + val;
  };
  Cookie.prototype.toString = function toString() {
    var str = this.cookieString();
    if (this.expires != Infinity) {
      if (this.expires instanceof Date) {
        str += "; Expires=" + formatDate(this.expires);
      } else {
        str += "; Expires=" + this.expires;
      }
    }
    if (this.maxAge != null && this.maxAge != Infinity) {
      str += "; Max-Age=" + this.maxAge;
    }
    if (this.domain && !this.hostOnly) {
      str += "; Domain=" + this.domain;
    }
    if (this.path) {
      str += "; Path=" + this.path;
    }
    if (this.secure) {
      str += "; Secure";
    }
    if (this.httpOnly) {
      str += "; HttpOnly";
    }
    if (this.extensions) {
      this.extensions.forEach(function(ext) {
        str += "; " + ext;
      });
    }
    return str;
  };
  Cookie.prototype.TTL = function TTL(now) {
    if (this.maxAge != null) {
      return this.maxAge <= 0 ? 0 : this.maxAge * 1e3;
    }
    var expires = this.expires;
    if (expires != Infinity) {
      if (!(expires instanceof Date)) {
        expires = parseDate(expires) || Infinity;
      }
      if (expires == Infinity) {
        return Infinity;
      }
      return expires.getTime() - (now || Date.now());
    }
    return Infinity;
  };
  Cookie.prototype.expiryTime = function expiryTime(now) {
    if (this.maxAge != null) {
      var relativeTo = now || this.creation || /* @__PURE__ */ new Date();
      var age = this.maxAge <= 0 ? -Infinity : this.maxAge * 1e3;
      return relativeTo.getTime() + age;
    }
    if (this.expires == Infinity) {
      return Infinity;
    }
    return this.expires.getTime();
  };
  Cookie.prototype.expiryDate = function expiryDate(now) {
    var millisec = this.expiryTime(now);
    if (millisec == Infinity) {
      return new Date(MAX_TIME);
    } else if (millisec == -Infinity) {
      return new Date(MIN_TIME);
    } else {
      return new Date(millisec);
    }
  };
  Cookie.prototype.isPersistent = function isPersistent() {
    return this.maxAge != null || this.expires != Infinity;
  };
  Cookie.prototype.cdomain = Cookie.prototype.canonicalizedDomain = function canonicalizedDomain() {
    if (this.domain == null) {
      return null;
    }
    return canonicalDomain(this.domain);
  };
  function CookieJar(store2, options) {
    if (typeof options === "boolean") {
      options = { rejectPublicSuffixes: options };
    } else if (options == null) {
      options = {};
    }
    if (options.rejectPublicSuffixes != null) {
      this.rejectPublicSuffixes = options.rejectPublicSuffixes;
    }
    if (options.looseMode != null) {
      this.enableLooseMode = options.looseMode;
    }
    if (!store2) {
      store2 = new MemoryCookieStore();
    }
    this.store = store2;
  }
  CookieJar.prototype.store = null;
  CookieJar.prototype.rejectPublicSuffixes = true;
  CookieJar.prototype.enableLooseMode = false;
  var CAN_BE_SYNC = [];
  CAN_BE_SYNC.push("setCookie");
  CookieJar.prototype.setCookie = function(cookie2, url, options, cb) {
    var err;
    var context = getCookieContext(url);
    if (options instanceof Function) {
      cb = options;
      options = {};
    }
    var host = canonicalDomain(context.hostname);
    var loose = this.enableLooseMode;
    if (options.loose != null) {
      loose = options.loose;
    }
    if (!(cookie2 instanceof Cookie)) {
      cookie2 = Cookie.parse(cookie2, { loose });
    }
    if (!cookie2) {
      err = new Error("Cookie failed to parse");
      return cb(options.ignoreError ? null : err);
    }
    var now = options.now || /* @__PURE__ */ new Date();
    if (this.rejectPublicSuffixes && cookie2.domain) {
      var suffix = pubsuffix.getPublicSuffix(cookie2.cdomain());
      if (suffix == null) {
        err = new Error("Cookie has domain set to a public suffix");
        return cb(options.ignoreError ? null : err);
      }
    }
    if (cookie2.domain) {
      if (!domainMatch(host, cookie2.cdomain(), false)) {
        err = new Error("Cookie not in this host's domain. Cookie:" + cookie2.cdomain() + " Request:" + host);
        return cb(options.ignoreError ? null : err);
      }
      if (cookie2.hostOnly == null) {
        cookie2.hostOnly = false;
      }
    } else {
      cookie2.hostOnly = true;
      cookie2.domain = host;
    }
    if (!cookie2.path || cookie2.path[0] !== "/") {
      cookie2.path = defaultPath(context.pathname);
      cookie2.pathIsDefault = true;
    }
    if (options.http === false && cookie2.httpOnly) {
      err = new Error("Cookie is HttpOnly and this isn't an HTTP API");
      return cb(options.ignoreError ? null : err);
    }
    var store2 = this.store;
    if (!store2.updateCookie) {
      store2.updateCookie = function(oldCookie, newCookie, cb2) {
        this.putCookie(newCookie, cb2);
      };
    }
    function withCookie(err2, oldCookie) {
      if (err2) {
        return cb(err2);
      }
      var next = function(err3) {
        if (err3) {
          return cb(err3);
        } else {
          cb(null, cookie2);
        }
      };
      if (oldCookie) {
        if (options.http === false && oldCookie.httpOnly) {
          err2 = new Error("old Cookie is HttpOnly and this isn't an HTTP API");
          return cb(options.ignoreError ? null : err2);
        }
        cookie2.creation = oldCookie.creation;
        cookie2.creationIndex = oldCookie.creationIndex;
        cookie2.lastAccessed = now;
        store2.updateCookie(oldCookie, cookie2, next);
      } else {
        cookie2.creation = cookie2.lastAccessed = now;
        store2.putCookie(cookie2, next);
      }
    }
    store2.findCookie(cookie2.domain, cookie2.path, cookie2.key, withCookie);
  };
  CAN_BE_SYNC.push("getCookies");
  CookieJar.prototype.getCookies = function(url, options, cb) {
    var context = getCookieContext(url);
    if (options instanceof Function) {
      cb = options;
      options = {};
    }
    var host = canonicalDomain(context.hostname);
    var path = context.pathname || "/";
    var secure = options.secure;
    if (secure == null && context.protocol && (context.protocol == "https:" || context.protocol == "wss:")) {
      secure = true;
    }
    var http = options.http;
    if (http == null) {
      http = true;
    }
    var now = options.now || Date.now();
    var expireCheck = options.expire !== false;
    var allPaths = !!options.allPaths;
    var store2 = this.store;
    function matchingCookie(c) {
      if (c.hostOnly) {
        if (c.domain != host) {
          return false;
        }
      } else {
        if (!domainMatch(host, c.domain, false)) {
          return false;
        }
      }
      if (!allPaths && !pathMatch2(path, c.path)) {
        return false;
      }
      if (c.secure && !secure) {
        return false;
      }
      if (c.httpOnly && !http) {
        return false;
      }
      if (expireCheck && c.expiryTime() <= now) {
        store2.removeCookie(c.domain, c.path, c.key, function() {
        });
        return false;
      }
      return true;
    }
    store2.findCookies(host, allPaths ? null : path, function(err, cookies2) {
      if (err) {
        return cb(err);
      }
      cookies2 = cookies2.filter(matchingCookie);
      if (options.sort !== false) {
        cookies2 = cookies2.sort(cookieCompare);
      }
      var now2 = /* @__PURE__ */ new Date();
      cookies2.forEach(function(c) {
        c.lastAccessed = now2;
      });
      cb(null, cookies2);
    });
  };
  CAN_BE_SYNC.push("getCookieString");
  CookieJar.prototype.getCookieString = function() {
    var args = Array.prototype.slice.call(arguments, 0);
    var cb = args.pop();
    var next = function(err, cookies2) {
      if (err) {
        cb(err);
      } else {
        cb(null, cookies2.sort(cookieCompare).map(function(c) {
          return c.cookieString();
        }).join("; "));
      }
    };
    args.push(next);
    this.getCookies.apply(this, args);
  };
  CAN_BE_SYNC.push("getSetCookieStrings");
  CookieJar.prototype.getSetCookieStrings = function() {
    var args = Array.prototype.slice.call(arguments, 0);
    var cb = args.pop();
    var next = function(err, cookies2) {
      if (err) {
        cb(err);
      } else {
        cb(null, cookies2.map(function(c) {
          return c.toString();
        }));
      }
    };
    args.push(next);
    this.getCookies.apply(this, args);
  };
  CAN_BE_SYNC.push("serialize");
  CookieJar.prototype.serialize = function(cb) {
    var type2 = this.store.constructor.name;
    if (type2 === "Object") {
      type2 = null;
    }
    var serialized = {
      // The version of tough-cookie that serialized this jar. Generally a good
      // practice since future versions can make data import decisions based on
      // known past behavior. When/if this matters, use `semver`.
      version: "tough-cookie@" + VERSION,
      // add the store type, to make humans happy:
      storeType: type2,
      // CookieJar configuration:
      rejectPublicSuffixes: !!this.rejectPublicSuffixes,
      // this gets filled from getAllCookies:
      cookies: []
    };
    if (!(this.store.getAllCookies && typeof this.store.getAllCookies === "function")) {
      return cb(new Error("store does not support getAllCookies and cannot be serialized"));
    }
    this.store.getAllCookies(function(err, cookies2) {
      if (err) {
        return cb(err);
      }
      serialized.cookies = cookies2.map(function(cookie2) {
        cookie2 = cookie2 instanceof Cookie ? cookie2.toJSON() : cookie2;
        delete cookie2.creationIndex;
        return cookie2;
      });
      return cb(null, serialized);
    });
  };
  CookieJar.prototype.toJSON = function() {
    return this.serializeSync();
  };
  CAN_BE_SYNC.push("_importCookies");
  CookieJar.prototype._importCookies = function(serialized, cb) {
    var jar = this;
    var cookies2 = serialized.cookies;
    if (!cookies2 || !Array.isArray(cookies2)) {
      return cb(new Error("serialized jar has no cookies array"));
    }
    cookies2 = cookies2.slice();
    function putNext(err) {
      if (err) {
        return cb(err);
      }
      if (!cookies2.length) {
        return cb(err, jar);
      }
      var cookie2;
      try {
        cookie2 = fromJSON(cookies2.shift());
      } catch (e) {
        return cb(e);
      }
      if (cookie2 === null) {
        return putNext(null);
      }
      jar.store.putCookie(cookie2, putNext);
    }
    putNext();
  };
  CookieJar.deserialize = function(strOrObj, store2, cb) {
    if (arguments.length !== 3) {
      cb = store2;
      store2 = null;
    }
    var serialized;
    if (typeof strOrObj === "string") {
      serialized = jsonParse(strOrObj);
      if (serialized instanceof Error) {
        return cb(serialized);
      }
    } else {
      serialized = strOrObj;
    }
    var jar = new CookieJar(store2, serialized.rejectPublicSuffixes);
    jar._importCookies(serialized, function(err) {
      if (err) {
        return cb(err);
      }
      cb(null, jar);
    });
  };
  CookieJar.deserializeSync = function(strOrObj, store2) {
    var serialized = typeof strOrObj === "string" ? JSON.parse(strOrObj) : strOrObj;
    var jar = new CookieJar(store2, serialized.rejectPublicSuffixes);
    if (!jar.store.synchronous) {
      throw new Error("CookieJar store is not synchronous; use async API instead.");
    }
    jar._importCookiesSync(serialized);
    return jar;
  };
  CookieJar.fromJSON = CookieJar.deserializeSync;
  CookieJar.prototype.clone = function(newStore, cb) {
    if (arguments.length === 1) {
      cb = newStore;
      newStore = null;
    }
    this.serialize(function(err, serialized) {
      if (err) {
        return cb(err);
      }
      CookieJar.deserialize(serialized, newStore, cb);
    });
  };
  CAN_BE_SYNC.push("removeAllCookies");
  CookieJar.prototype.removeAllCookies = function(cb) {
    var store2 = this.store;
    if (store2.removeAllCookies instanceof Function && store2.removeAllCookies !== Store.prototype.removeAllCookies) {
      return store2.removeAllCookies(cb);
    }
    store2.getAllCookies(function(err, cookies2) {
      if (err) {
        return cb(err);
      }
      if (cookies2.length === 0) {
        return cb(null);
      }
      var completedCount = 0;
      var removeErrors = [];
      function removeCookieCb(removeErr) {
        if (removeErr) {
          removeErrors.push(removeErr);
        }
        completedCount++;
        if (completedCount === cookies2.length) {
          return cb(removeErrors.length ? removeErrors[0] : null);
        }
      }
      cookies2.forEach(function(cookie2) {
        store2.removeCookie(cookie2.domain, cookie2.path, cookie2.key, removeCookieCb);
      });
    });
  };
  CookieJar.prototype._cloneSync = syncWrap("clone");
  CookieJar.prototype.cloneSync = function(newStore) {
    if (!newStore.synchronous) {
      throw new Error("CookieJar clone destination store is not synchronous; use async API instead.");
    }
    return this._cloneSync(newStore);
  };
  function syncWrap(method) {
    return function() {
      if (!this.store.synchronous) {
        throw new Error("CookieJar store is not synchronous; use async API instead.");
      }
      var args = Array.prototype.slice.call(arguments);
      var syncErr, syncResult;
      args.push(function syncCb(err, result) {
        syncErr = err;
        syncResult = result;
      });
      this[method].apply(this, args);
      if (syncErr) {
        throw syncErr;
      }
      return syncResult;
    };
  }
  CAN_BE_SYNC.forEach(function(method) {
    CookieJar.prototype[method + "Sync"] = syncWrap(method);
  });
  cookie.version = VERSION;
  cookie.CookieJar = CookieJar;
  cookie.Cookie = Cookie;
  cookie.Store = Store;
  cookie.MemoryCookieStore = MemoryCookieStore;
  cookie.parseDate = parseDate;
  cookie.formatDate = formatDate;
  cookie.parse = parse2;
  cookie.fromJSON = fromJSON;
  cookie.domainMatch = domainMatch;
  cookie.defaultPath = defaultPath;
  cookie.pathMatch = pathMatch2;
  cookie.getPublicSuffix = pubsuffix.getPublicSuffix;
  cookie.cookieCompare = cookieCompare;
  cookie.permuteDomain = requirePermuteDomain().permuteDomain;
  cookie.permutePath = permutePath;
  cookie.canonicalDomain = canonicalDomain;
  return cookie;
}
var hasRequiredCookies;
function requireCookies() {
  if (hasRequiredCookies) return cookies;
  hasRequiredCookies = 1;
  var tough = requireCookie();
  var Cookie = tough.Cookie;
  var CookieJar = tough.CookieJar;
  cookies.parse = function(str) {
    if (str && str.uri) {
      str = str.uri;
    }
    if (typeof str !== "string") {
      throw new Error("The cookie function only accepts STRING as param");
    }
    return Cookie.parse(str, { loose: true });
  };
  function RequestJar(store2) {
    var self2 = this;
    self2._jar = new CookieJar(store2, { looseMode: true });
  }
  RequestJar.prototype.setCookie = function(cookieOrStr, uri, options) {
    var self2 = this;
    return self2._jar.setCookieSync(cookieOrStr, uri, options || {});
  };
  RequestJar.prototype.getCookieString = function(uri) {
    var self2 = this;
    return self2._jar.getCookieStringSync(uri);
  };
  RequestJar.prototype.getCookies = function(uri) {
    var self2 = this;
    return self2._jar.getCookiesSync(uri);
  };
  cookies.jar = function(store2) {
    return new RequestJar(store2);
  };
  return cookies;
}
var helpers = {};
var stringify = { exports: {} };
var hasRequiredStringify$1;
function requireStringify$1() {
  if (hasRequiredStringify$1) return stringify.exports;
  hasRequiredStringify$1 = 1;
  (function(module, exports$1) {
    exports$1 = module.exports = stringify2;
    exports$1.getSerialize = serializer;
    function stringify2(obj, replacer, spaces, cycleReplacer) {
      return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces);
    }
    function serializer(replacer, cycleReplacer) {
      var stack = [], keys = [];
      if (cycleReplacer == null) cycleReplacer = function(key2, value) {
        if (stack[0] === value) return "[Circular ~]";
        return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
      };
      return function(key2, value) {
        if (stack.length > 0) {
          var thisPos = stack.indexOf(this);
          ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
          ~thisPos ? keys.splice(thisPos, Infinity, key2) : keys.push(key2);
          if (~stack.indexOf(value)) value = cycleReplacer.call(this, key2, value);
        } else stack.push(value);
        return replacer == null ? value : replacer.call(this, key2, value);
      };
    }
  })(stringify, stringify.exports);
  return stringify.exports;
}
var safeBuffer = { exports: {} };
var hasRequiredSafeBuffer;
function requireSafeBuffer() {
  if (hasRequiredSafeBuffer) return safeBuffer.exports;
  hasRequiredSafeBuffer = 1;
  (function(module, exports$1) {
    var buffer = require$$0$4;
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key2 in src) {
        dst[key2] = src[key2];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports$1);
      exports$1.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  })(safeBuffer, safeBuffer.exports);
  return safeBuffer.exports;
}
var hasRequiredHelpers;
function requireHelpers() {
  if (hasRequiredHelpers) return helpers;
  hasRequiredHelpers = 1;
  var jsonSafeStringify = requireStringify$1();
  var crypto = require$$0$9;
  var Buffer2 = requireSafeBuffer().Buffer;
  var defer = typeof setImmediate === "undefined" ? process.nextTick : setImmediate;
  function paramsHaveRequestBody(params) {
    return params.body || params.requestBodyStream || params.json && typeof params.json !== "boolean" || params.multipart;
  }
  function safeStringify(obj, replacer) {
    var ret;
    try {
      ret = JSON.stringify(obj, replacer);
    } catch (e) {
      ret = jsonSafeStringify(obj, replacer);
    }
    return ret;
  }
  function md5(str) {
    return crypto.createHash("md5").update(str).digest("hex");
  }
  function isReadStream(rs) {
    return rs.readable && rs.path && rs.mode;
  }
  function toBase64(str) {
    return Buffer2.from(str || "", "utf8").toString("base64");
  }
  function copy(obj) {
    var o = {};
    Object.keys(obj).forEach(function(i) {
      o[i] = obj[i];
    });
    return o;
  }
  function version2() {
    var numbers = process.version.replace("v", "").split(".");
    return {
      major: parseInt(numbers[0], 10),
      minor: parseInt(numbers[1], 10),
      patch: parseInt(numbers[2], 10)
    };
  }
  helpers.paramsHaveRequestBody = paramsHaveRequestBody;
  helpers.safeStringify = safeStringify;
  helpers.md5 = md5;
  helpers.isReadStream = isReadStream;
  helpers.toBase64 = toBase64;
  helpers.copy = copy;
  helpers.version = version2;
  helpers.defer = defer;
  return helpers;
}
var awsSign2 = { exports: {} };
var hasRequiredAwsSign2;
function requireAwsSign2() {
  if (hasRequiredAwsSign2) return awsSign2.exports;
  hasRequiredAwsSign2 = 1;
  var crypto = require$$0$9, parse2 = require$$0$7.parse;
  var keys = [
    "acl",
    "location",
    "logging",
    "notification",
    "partNumber",
    "policy",
    "requestPayment",
    "torrent",
    "uploadId",
    "uploads",
    "versionId",
    "versioning",
    "versions",
    "website"
  ];
  function authorization(options) {
    return "AWS " + options.key + ":" + sign(options);
  }
  awsSign2.exports = authorization;
  awsSign2.exports.authorization = authorization;
  function hmacSha1(options) {
    return crypto.createHmac("sha1", options.secret).update(options.message).digest("base64");
  }
  awsSign2.exports.hmacSha1 = hmacSha1;
  function sign(options) {
    options.message = stringToSign(options);
    return hmacSha1(options);
  }
  awsSign2.exports.sign = sign;
  function signQuery(options) {
    options.message = queryStringToSign(options);
    return hmacSha1(options);
  }
  awsSign2.exports.signQuery = signQuery;
  function stringToSign(options) {
    var headers = options.amazonHeaders || "";
    if (headers) headers += "\n";
    var r = [
      options.verb,
      options.md5,
      options.contentType,
      options.date ? options.date.toUTCString() : "",
      headers + options.resource
    ];
    return r.join("\n");
  }
  awsSign2.exports.stringToSign = stringToSign;
  function queryStringToSign(options) {
    return "GET\n\n\n" + options.date + "\n" + options.resource;
  }
  awsSign2.exports.queryStringToSign = queryStringToSign;
  function canonicalizeHeaders(headers) {
    var buf = [], fields = Object.keys(headers);
    for (var i = 0, len = fields.length; i < len; ++i) {
      var field = fields[i], val = headers[field], field = field.toLowerCase();
      if (0 !== field.indexOf("x-amz")) continue;
      buf.push(field + ":" + val);
    }
    return buf.sort().join("\n");
  }
  awsSign2.exports.canonicalizeHeaders = canonicalizeHeaders;
  function canonicalizeResource(resource) {
    var url = parse2(resource, true), path = url.pathname, buf = [];
    Object.keys(url.query).forEach(function(key2) {
      if (!~keys.indexOf(key2)) return;
      var val = "" == url.query[key2] ? "" : "=" + encodeURIComponent(url.query[key2]);
      buf.push(key2 + val);
    });
    return path + (buf.length ? "?" + buf.sort().join("&") : "");
  }
  awsSign2.exports.canonicalizeResource = canonicalizeResource;
  return awsSign2.exports;
}
var aws4 = {};
var lru;
var hasRequiredLru;
function requireLru() {
  if (hasRequiredLru) return lru;
  hasRequiredLru = 1;
  lru = function(size) {
    return new LruCache(size);
  };
  function LruCache(size) {
    this.capacity = size | 0;
    this.map = /* @__PURE__ */ Object.create(null);
    this.list = new DoublyLinkedList();
  }
  LruCache.prototype.get = function(key2) {
    var node = this.map[key2];
    if (node == null) return void 0;
    this.used(node);
    return node.val;
  };
  LruCache.prototype.set = function(key2, val) {
    var node = this.map[key2];
    if (node != null) {
      node.val = val;
    } else {
      if (!this.capacity) this.prune();
      if (!this.capacity) return false;
      node = new DoublyLinkedNode(key2, val);
      this.map[key2] = node;
      this.capacity--;
    }
    this.used(node);
    return true;
  };
  LruCache.prototype.used = function(node) {
    this.list.moveToFront(node);
  };
  LruCache.prototype.prune = function() {
    var node = this.list.pop();
    if (node != null) {
      delete this.map[node.key];
      this.capacity++;
    }
  };
  function DoublyLinkedList() {
    this.firstNode = null;
    this.lastNode = null;
  }
  DoublyLinkedList.prototype.moveToFront = function(node) {
    if (this.firstNode == node) return;
    this.remove(node);
    if (this.firstNode == null) {
      this.firstNode = node;
      this.lastNode = node;
      node.prev = null;
      node.next = null;
    } else {
      node.prev = null;
      node.next = this.firstNode;
      node.next.prev = node;
      this.firstNode = node;
    }
  };
  DoublyLinkedList.prototype.pop = function() {
    var lastNode = this.lastNode;
    if (lastNode != null) {
      this.remove(lastNode);
    }
    return lastNode;
  };
  DoublyLinkedList.prototype.remove = function(node) {
    if (this.firstNode == node) {
      this.firstNode = node.next;
    } else if (node.prev != null) {
      node.prev.next = node.next;
    }
    if (this.lastNode == node) {
      this.lastNode = node.prev;
    } else if (node.next != null) {
      node.next.prev = node.prev;
    }
  };
  function DoublyLinkedNode(key2, val) {
    this.key = key2;
    this.val = val;
    this.prev = null;
    this.next = null;
  }
  return lru;
}
var hasRequiredAws4;
function requireAws4() {
  if (hasRequiredAws4) return aws4;
  hasRequiredAws4 = 1;
  (function(exports$1) {
    var aws42 = exports$1, url = require$$0$7, querystring2 = require$$1$4, crypto = require$$0$9, lru2 = requireLru(), credentialsCache = lru2(1e3);
    function hmac(key2, string, encoding) {
      return crypto.createHmac("sha256", key2).update(string, "utf8").digest(encoding);
    }
    function hash(string, encoding) {
      return crypto.createHash("sha256").update(string, "utf8").digest(encoding);
    }
    function encodeRfc3986(urlEncodedString) {
      return urlEncodedString.replace(/[!'()*]/g, function(c) {
        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
      });
    }
    function encodeRfc3986Full(str) {
      return encodeRfc3986(encodeURIComponent(str));
    }
    var HEADERS_TO_IGNORE = {
      "authorization": true,
      "connection": true,
      "x-amzn-trace-id": true,
      "user-agent": true,
      "expect": true,
      "presigned-expires": true,
      "range": true
    };
    function RequestSigner(request2, credentials) {
      if (typeof request2 === "string") request2 = url.parse(request2);
      var headers = request2.headers = Object.assign({}, request2.headers || {}), hostParts = (!this.service || !this.region) && this.matchHost(request2.hostname || request2.host || headers.Host || headers.host);
      this.request = request2;
      this.credentials = credentials || this.defaultCredentials();
      this.service = request2.service || hostParts[0] || "";
      this.region = request2.region || hostParts[1] || "us-east-1";
      if (this.service === "email") this.service = "ses";
      if (!request2.method && request2.body)
        request2.method = "POST";
      if (!headers.Host && !headers.host) {
        headers.Host = request2.hostname || request2.host || this.createHost();
        if (request2.port)
          headers.Host += ":" + request2.port;
      }
      if (!request2.hostname && !request2.host)
        request2.hostname = headers.Host || headers.host;
      this.isCodeCommitGit = this.service === "codecommit" && request2.method === "GIT";
      this.extraHeadersToIgnore = request2.extraHeadersToIgnore || /* @__PURE__ */ Object.create(null);
      this.extraHeadersToInclude = request2.extraHeadersToInclude || /* @__PURE__ */ Object.create(null);
    }
    RequestSigner.prototype.matchHost = function(host) {
      var match = (host || "").match(/([^\.]{1,63})\.(?:([^\.]{0,63})\.)?amazonaws\.com(\.cn)?$/);
      var hostParts = (match || []).slice(1, 3);
      if (hostParts[1] === "es" || hostParts[1] === "aoss")
        hostParts = hostParts.reverse();
      if (hostParts[1] == "s3") {
        hostParts[0] = "s3";
        hostParts[1] = "us-east-1";
      } else {
        for (var i = 0; i < 2; i++) {
          if (/^s3-/.test(hostParts[i])) {
            hostParts[1] = hostParts[i].slice(3);
            hostParts[0] = "s3";
            break;
          }
        }
      }
      return hostParts;
    };
    RequestSigner.prototype.isSingleRegion = function() {
      if (["s3", "sdb"].indexOf(this.service) >= 0 && this.region === "us-east-1") return true;
      return ["cloudfront", "ls", "route53", "iam", "importexport", "sts"].indexOf(this.service) >= 0;
    };
    RequestSigner.prototype.createHost = function() {
      var region = this.isSingleRegion() ? "" : "." + this.region, subdomain = this.service === "ses" ? "email" : this.service;
      return subdomain + region + ".amazonaws.com";
    };
    RequestSigner.prototype.prepareRequest = function() {
      this.parsePath();
      var request2 = this.request, headers = request2.headers, query;
      if (request2.signQuery) {
        this.parsedPath.query = query = this.parsedPath.query || {};
        if (this.credentials.sessionToken)
          query["X-Amz-Security-Token"] = this.credentials.sessionToken;
        if (this.service === "s3" && !query["X-Amz-Expires"])
          query["X-Amz-Expires"] = 86400;
        if (query["X-Amz-Date"])
          this.datetime = query["X-Amz-Date"];
        else
          query["X-Amz-Date"] = this.getDateTime();
        query["X-Amz-Algorithm"] = "AWS4-HMAC-SHA256";
        query["X-Amz-Credential"] = this.credentials.accessKeyId + "/" + this.credentialString();
        query["X-Amz-SignedHeaders"] = this.signedHeaders();
      } else {
        if (!request2.doNotModifyHeaders && !this.isCodeCommitGit) {
          if (request2.body && !headers["Content-Type"] && !headers["content-type"])
            headers["Content-Type"] = "application/x-www-form-urlencoded; charset=utf-8";
          if (request2.body && !headers["Content-Length"] && !headers["content-length"])
            headers["Content-Length"] = Buffer.byteLength(request2.body);
          if (this.credentials.sessionToken && !headers["X-Amz-Security-Token"] && !headers["x-amz-security-token"])
            headers["X-Amz-Security-Token"] = this.credentials.sessionToken;
          if (this.service === "s3" && !headers["X-Amz-Content-Sha256"] && !headers["x-amz-content-sha256"])
            headers["X-Amz-Content-Sha256"] = hash(this.request.body || "", "hex");
          if (headers["X-Amz-Date"] || headers["x-amz-date"])
            this.datetime = headers["X-Amz-Date"] || headers["x-amz-date"];
          else
            headers["X-Amz-Date"] = this.getDateTime();
        }
        delete headers.Authorization;
        delete headers.authorization;
      }
    };
    RequestSigner.prototype.sign = function() {
      if (!this.parsedPath) this.prepareRequest();
      if (this.request.signQuery) {
        this.parsedPath.query["X-Amz-Signature"] = this.signature();
      } else {
        this.request.headers.Authorization = this.authHeader();
      }
      this.request.path = this.formatPath();
      return this.request;
    };
    RequestSigner.prototype.getDateTime = function() {
      if (!this.datetime) {
        var headers = this.request.headers, date = new Date(headers.Date || headers.date || /* @__PURE__ */ new Date());
        this.datetime = date.toISOString().replace(/[:\-]|\.\d{3}/g, "");
        if (this.isCodeCommitGit) this.datetime = this.datetime.slice(0, -1);
      }
      return this.datetime;
    };
    RequestSigner.prototype.getDate = function() {
      return this.getDateTime().substr(0, 8);
    };
    RequestSigner.prototype.authHeader = function() {
      return [
        "AWS4-HMAC-SHA256 Credential=" + this.credentials.accessKeyId + "/" + this.credentialString(),
        "SignedHeaders=" + this.signedHeaders(),
        "Signature=" + this.signature()
      ].join(", ");
    };
    RequestSigner.prototype.signature = function() {
      var date = this.getDate(), cacheKey = [this.credentials.secretAccessKey, date, this.region, this.service].join(), kDate, kRegion, kService, kCredentials = credentialsCache.get(cacheKey);
      if (!kCredentials) {
        kDate = hmac("AWS4" + this.credentials.secretAccessKey, date);
        kRegion = hmac(kDate, this.region);
        kService = hmac(kRegion, this.service);
        kCredentials = hmac(kService, "aws4_request");
        credentialsCache.set(cacheKey, kCredentials);
      }
      return hmac(kCredentials, this.stringToSign(), "hex");
    };
    RequestSigner.prototype.stringToSign = function() {
      return [
        "AWS4-HMAC-SHA256",
        this.getDateTime(),
        this.credentialString(),
        hash(this.canonicalString(), "hex")
      ].join("\n");
    };
    RequestSigner.prototype.canonicalString = function() {
      if (!this.parsedPath) this.prepareRequest();
      var pathStr = this.parsedPath.path, query = this.parsedPath.query, headers = this.request.headers, queryStr = "", normalizePath = this.service !== "s3", decodePath = this.service === "s3" || this.request.doNotEncodePath, decodeSlashesInPath = this.service === "s3", firstValOnly = this.service === "s3", bodyHash;
      if (this.service === "s3" && this.request.signQuery) {
        bodyHash = "UNSIGNED-PAYLOAD";
      } else if (this.isCodeCommitGit) {
        bodyHash = "";
      } else {
        bodyHash = headers["X-Amz-Content-Sha256"] || headers["x-amz-content-sha256"] || hash(this.request.body || "", "hex");
      }
      if (query) {
        var reducedQuery = Object.keys(query).reduce(function(obj, key2) {
          if (!key2) return obj;
          obj[encodeRfc3986Full(key2)] = !Array.isArray(query[key2]) ? query[key2] : firstValOnly ? query[key2][0] : query[key2];
          return obj;
        }, {});
        var encodedQueryPieces = [];
        Object.keys(reducedQuery).sort().forEach(function(key2) {
          if (!Array.isArray(reducedQuery[key2])) {
            encodedQueryPieces.push(key2 + "=" + encodeRfc3986Full(reducedQuery[key2]));
          } else {
            reducedQuery[key2].map(encodeRfc3986Full).sort().forEach(function(val) {
              encodedQueryPieces.push(key2 + "=" + val);
            });
          }
        });
        queryStr = encodedQueryPieces.join("&");
      }
      if (pathStr !== "/") {
        if (normalizePath) pathStr = pathStr.replace(/\/{2,}/g, "/");
        pathStr = pathStr.split("/").reduce(function(path, piece) {
          if (normalizePath && piece === "..") {
            path.pop();
          } else if (!normalizePath || piece !== ".") {
            if (decodePath) piece = decodeURIComponent(piece.replace(/\+/g, " "));
            path.push(encodeRfc3986Full(piece));
          }
          return path;
        }, []).join("/");
        if (pathStr[0] !== "/") pathStr = "/" + pathStr;
        if (decodeSlashesInPath) pathStr = pathStr.replace(/%2F/g, "/");
      }
      return [
        this.request.method || "GET",
        pathStr,
        queryStr,
        this.canonicalHeaders() + "\n",
        this.signedHeaders(),
        bodyHash
      ].join("\n");
    };
    RequestSigner.prototype.filterHeaders = function() {
      var headers = this.request.headers, extraHeadersToInclude = this.extraHeadersToInclude, extraHeadersToIgnore = this.extraHeadersToIgnore;
      this.filteredHeaders = Object.keys(headers).map(function(key2) {
        return [key2.toLowerCase(), headers[key2]];
      }).filter(function(entry) {
        return extraHeadersToInclude[entry[0]] || HEADERS_TO_IGNORE[entry[0]] == null && !extraHeadersToIgnore[entry[0]];
      }).sort(function(a, b) {
        return a[0] < b[0] ? -1 : 1;
      });
    };
    RequestSigner.prototype.canonicalHeaders = function() {
      if (!this.filteredHeaders) this.filterHeaders();
      return this.filteredHeaders.map(function(entry) {
        return entry[0] + ":" + entry[1].toString().trim().replace(/\s+/g, " ");
      }).join("\n");
    };
    RequestSigner.prototype.signedHeaders = function() {
      if (!this.filteredHeaders) this.filterHeaders();
      return this.filteredHeaders.map(function(entry) {
        return entry[0];
      }).join(";");
    };
    RequestSigner.prototype.credentialString = function() {
      return [
        this.getDate(),
        this.region,
        this.service,
        "aws4_request"
      ].join("/");
    };
    RequestSigner.prototype.defaultCredentials = function() {
      var env = process.env;
      return {
        accessKeyId: env.AWS_ACCESS_KEY_ID || env.AWS_ACCESS_KEY,
        secretAccessKey: env.AWS_SECRET_ACCESS_KEY || env.AWS_SECRET_KEY,
        sessionToken: env.AWS_SESSION_TOKEN
      };
    };
    RequestSigner.prototype.parsePath = function() {
      var path = this.request.path || "/";
      if (/[^0-9A-Za-z;,/?:@&=+$\-_.!~*'()#%]/.test(path)) {
        path = encodeURI(decodeURI(path));
      }
      var queryIx = path.indexOf("?"), query = null;
      if (queryIx >= 0) {
        query = querystring2.parse(path.slice(queryIx + 1));
        path = path.slice(0, queryIx);
      }
      this.parsedPath = {
        path,
        query
      };
    };
    RequestSigner.prototype.formatPath = function() {
      var path = this.parsedPath.path, query = this.parsedPath.query;
      if (!query) return path;
      if (query[""] != null) delete query[""];
      return path + "?" + encodeRfc3986(querystring2.stringify(query));
    };
    aws42.RequestSigner = RequestSigner;
    aws42.sign = function(request2, credentials) {
      return new RequestSigner(request2, credentials).sign();
    };
  })(aws4);
  return aws4;
}
var assert_1;
var hasRequiredAssert;
function requireAssert() {
  if (hasRequiredAssert) return assert_1;
  hasRequiredAssert = 1;
  var assert = require$$0$6;
  var Stream = require$$1$2.Stream;
  var util2 = require$$0$5;
  var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;
  function _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  function _toss(name, expected, oper, arg, actual) {
    throw new assert.AssertionError({
      message: util2.format("%s (%s) is required", name, expected),
      actual: actual === void 0 ? typeof arg : actual(arg),
      expected,
      operator: oper || "===",
      stackStartFunction: _toss.caller
    });
  }
  function _getClass(arg) {
    return Object.prototype.toString.call(arg).slice(8, -1);
  }
  function noop() {
  }
  var types2 = {
    bool: {
      check: function(arg) {
        return typeof arg === "boolean";
      }
    },
    func: {
      check: function(arg) {
        return typeof arg === "function";
      }
    },
    string: {
      check: function(arg) {
        return typeof arg === "string";
      }
    },
    object: {
      check: function(arg) {
        return typeof arg === "object" && arg !== null;
      }
    },
    number: {
      check: function(arg) {
        return typeof arg === "number" && !isNaN(arg);
      }
    },
    finite: {
      check: function(arg) {
        return typeof arg === "number" && !isNaN(arg) && isFinite(arg);
      }
    },
    buffer: {
      check: function(arg) {
        return Buffer.isBuffer(arg);
      },
      operator: "Buffer.isBuffer"
    },
    array: {
      check: function(arg) {
        return Array.isArray(arg);
      },
      operator: "Array.isArray"
    },
    stream: {
      check: function(arg) {
        return arg instanceof Stream;
      },
      operator: "instanceof",
      actual: _getClass
    },
    date: {
      check: function(arg) {
        return arg instanceof Date;
      },
      operator: "instanceof",
      actual: _getClass
    },
    regexp: {
      check: function(arg) {
        return arg instanceof RegExp;
      },
      operator: "instanceof",
      actual: _getClass
    },
    uuid: {
      check: function(arg) {
        return typeof arg === "string" && UUID_REGEXP.test(arg);
      },
      operator: "isUUID"
    }
  };
  function _setExports(ndebug) {
    var keys = Object.keys(types2);
    var out;
    if (process.env.NODE_NDEBUG) {
      out = noop;
    } else {
      out = function(arg, msg) {
        if (!arg) {
          _toss(msg, "true", arg);
        }
      };
    }
    keys.forEach(function(k) {
      if (ndebug) {
        out[k] = noop;
        return;
      }
      var type2 = types2[k];
      out[k] = function(arg, msg) {
        if (!type2.check(arg)) {
          _toss(msg, k, type2.operator, arg, type2.actual);
        }
      };
    });
    keys.forEach(function(k) {
      var name = "optional" + _capitalize(k);
      if (ndebug) {
        out[name] = noop;
        return;
      }
      var type2 = types2[k];
      out[name] = function(arg, msg) {
        if (arg === void 0 || arg === null) {
          return;
        }
        if (!type2.check(arg)) {
          _toss(msg, k, type2.operator, arg, type2.actual);
        }
      };
    });
    keys.forEach(function(k) {
      var name = "arrayOf" + _capitalize(k);
      if (ndebug) {
        out[name] = noop;
        return;
      }
      var type2 = types2[k];
      var expected = "[" + k + "]";
      out[name] = function(arg, msg) {
        if (!Array.isArray(arg)) {
          _toss(msg, expected, type2.operator, arg, type2.actual);
        }
        var i;
        for (i = 0; i < arg.length; i++) {
          if (!type2.check(arg[i])) {
            _toss(msg, expected, type2.operator, arg, type2.actual);
          }
        }
      };
    });
    keys.forEach(function(k) {
      var name = "optionalArrayOf" + _capitalize(k);
      if (ndebug) {
        out[name] = noop;
        return;
      }
      var type2 = types2[k];
      var expected = "[" + k + "]";
      out[name] = function(arg, msg) {
        if (arg === void 0 || arg === null) {
          return;
        }
        if (!Array.isArray(arg)) {
          _toss(msg, expected, type2.operator, arg, type2.actual);
        }
        var i;
        for (i = 0; i < arg.length; i++) {
          if (!type2.check(arg[i])) {
            _toss(msg, expected, type2.operator, arg, type2.actual);
          }
        }
      };
    });
    Object.keys(assert).forEach(function(k) {
      if (k === "AssertionError") {
        out[k] = assert[k];
        return;
      }
      if (ndebug) {
        out[k] = noop;
        return;
      }
      out[k] = assert[k];
    });
    out._setExports = _setExports;
    return out;
  }
  assert_1 = _setExports(process.env.NODE_NDEBUG);
  return assert_1;
}
var algs;
var hasRequiredAlgs;
function requireAlgs() {
  if (hasRequiredAlgs) return algs;
  hasRequiredAlgs = 1;
  var Buffer2 = requireSafer().Buffer;
  var algInfo = {
    "dsa": {
      parts: ["p", "q", "g", "y"],
      sizePart: "p"
    },
    "rsa": {
      parts: ["e", "n"],
      sizePart: "n"
    },
    "ecdsa": {
      parts: ["curve", "Q"],
      sizePart: "Q"
    },
    "ed25519": {
      parts: ["A"],
      sizePart: "A"
    }
  };
  algInfo["curve25519"] = algInfo["ed25519"];
  var algPrivInfo = {
    "dsa": {
      parts: ["p", "q", "g", "y", "x"]
    },
    "rsa": {
      parts: ["n", "e", "d", "iqmp", "p", "q"]
    },
    "ecdsa": {
      parts: ["curve", "Q", "d"]
    },
    "ed25519": {
      parts: ["A", "k"]
    }
  };
  algPrivInfo["curve25519"] = algPrivInfo["ed25519"];
  var hashAlgs = {
    "md5": true,
    "sha1": true,
    "sha256": true,
    "sha384": true,
    "sha512": true
  };
  var curves = {
    "nistp256": {
      size: 256,
      pkcs8oid: "1.2.840.10045.3.1.7",
      p: Buffer2.from("00ffffffff 00000001 00000000 0000000000000000 ffffffff ffffffff ffffffff".replace(/ /g, ""), "hex"),
      a: Buffer2.from("00FFFFFFFF 00000001 00000000 0000000000000000 FFFFFFFF FFFFFFFF FFFFFFFC".replace(/ /g, ""), "hex"),
      b: Buffer2.from("5ac635d8 aa3a93e7 b3ebbd55 769886bc651d06b0 cc53b0f6 3bce3c3e 27d2604b".replace(/ /g, ""), "hex"),
      s: Buffer2.from("00c49d3608 86e70493 6a6678e1 139d26b7819f7e90".replace(/ /g, ""), "hex"),
      n: Buffer2.from("00ffffffff 00000000 ffffffff ffffffffbce6faad a7179e84 f3b9cac2 fc632551".replace(/ /g, ""), "hex"),
      G: Buffer2.from("046b17d1f2 e12c4247 f8bce6e5 63a440f277037d81 2deb33a0 f4a13945 d898c2964fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e162bce3357 6b315ece cbb64068 37bf51f5".replace(/ /g, ""), "hex")
    },
    "nistp384": {
      size: 384,
      pkcs8oid: "1.3.132.0.34",
      p: Buffer2.from("00ffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff fffffffeffffffff 00000000 00000000 ffffffff".replace(/ /g, ""), "hex"),
      a: Buffer2.from("00FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFEFFFFFFFF 00000000 00000000 FFFFFFFC".replace(/ /g, ""), "hex"),
      b: Buffer2.from("b3312fa7 e23ee7e4 988e056b e3f82d19181d9c6e fe814112 0314088f 5013875ac656398d 8a2ed19d 2a85c8ed d3ec2aef".replace(/ /g, ""), "hex"),
      s: Buffer2.from("00a335926a a319a27a 1d00896a 6773a4827acdac73".replace(/ /g, ""), "hex"),
      n: Buffer2.from("00ffffffff ffffffff ffffffff ffffffffffffffff ffffffff c7634d81 f4372ddf581a0db2 48b0a77a ecec196a ccc52973".replace(/ /g, ""), "hex"),
      G: Buffer2.from("04aa87ca22 be8b0537 8eb1c71e f320ad746e1d3b62 8ba79b98 59f741e0 82542a385502f25d bf55296c 3a545e38 72760ab73617de4a 96262c6f 5d9e98bf 9292dc29f8f41dbd 289a147c e9da3113 b5f0b8c00a60b1ce 1d7e819d 7a431d7c 90ea0e5f".replace(/ /g, ""), "hex")
    },
    "nistp521": {
      size: 521,
      pkcs8oid: "1.3.132.0.35",
      p: Buffer2.from("01ffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffff".replace(/ /g, ""), "hex"),
      a: Buffer2.from("01FFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFC".replace(/ /g, ""), "hex"),
      b: Buffer2.from("51953eb961 8e1c9a1f 929a21a0 b68540eea2da725b 99b315f3 b8b48991 8ef109e156193951 ec7e937b 1652c0bd 3bb1bf073573df88 3d2c34f1 ef451fd4 6b503f00".replace(/ /g, ""), "hex"),
      s: Buffer2.from("00d09e8800 291cb853 96cc6717 393284aaa0da64ba".replace(/ /g, ""), "hex"),
      n: Buffer2.from("01ffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff fffffffa51868783 bf2f966b 7fcc0148 f709a5d03bb5c9b8 899c47ae bb6fb71e 91386409".replace(/ /g, ""), "hex"),
      G: Buffer2.from("0400c6 858e06b7 0404e9cd 9e3ecb66 2395b4429c648139 053fb521 f828af60 6b4d3dbaa14b5e77 efe75928 fe1dc127 a2ffa8de3348b3c1 856a429b f97e7e31 c2e5bd660118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd998f54449 579b4468 17afbd17 273e662c97ee7299 5ef42640 c550b901 3fad0761353c7086 a272c240 88be9476 9fd16650".replace(/ /g, ""), "hex")
    }
  };
  algs = {
    info: algInfo,
    privInfo: algPrivInfo,
    hashAlgs,
    curves
  };
  return algs;
}
var errors$1;
var hasRequiredErrors$1;
function requireErrors$1() {
  if (hasRequiredErrors$1) return errors$1;
  hasRequiredErrors$1 = 1;
  requireAssert();
  var util2 = require$$0$5;
  function FingerprintFormatError(fp, format2) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, FingerprintFormatError);
    this.name = "FingerprintFormatError";
    this.fingerprint = fp;
    this.format = format2;
    this.message = "Fingerprint format is not supported, or is invalid: ";
    if (fp !== void 0)
      this.message += " fingerprint = " + fp;
    if (format2 !== void 0)
      this.message += " format = " + format2;
  }
  util2.inherits(FingerprintFormatError, Error);
  function InvalidAlgorithmError(alg) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, InvalidAlgorithmError);
    this.name = "InvalidAlgorithmError";
    this.algorithm = alg;
    this.message = 'Algorithm "' + alg + '" is not supported';
  }
  util2.inherits(InvalidAlgorithmError, Error);
  function KeyParseError(name, format2, innerErr) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, KeyParseError);
    this.name = "KeyParseError";
    this.format = format2;
    this.keyName = name;
    this.innerErr = innerErr;
    this.message = "Failed to parse " + name + " as a valid " + format2 + " format key: " + innerErr.message;
  }
  util2.inherits(KeyParseError, Error);
  function SignatureParseError(type2, format2, innerErr) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, SignatureParseError);
    this.name = "SignatureParseError";
    this.type = type2;
    this.format = format2;
    this.innerErr = innerErr;
    this.message = "Failed to parse the given data as a " + type2 + " signature in " + format2 + " format: " + innerErr.message;
  }
  util2.inherits(SignatureParseError, Error);
  function CertificateParseError(name, format2, innerErr) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, CertificateParseError);
    this.name = "CertificateParseError";
    this.format = format2;
    this.certName = name;
    this.innerErr = innerErr;
    this.message = "Failed to parse " + name + " as a valid " + format2 + " format certificate: " + innerErr.message;
  }
  util2.inherits(CertificateParseError, Error);
  function KeyEncryptedError(name, format2) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, KeyEncryptedError);
    this.name = "KeyEncryptedError";
    this.format = format2;
    this.keyName = name;
    this.message = "The " + format2 + " format key " + name + " is encrypted (password-protected), and no passphrase was provided in `options`";
  }
  util2.inherits(KeyEncryptedError, Error);
  errors$1 = {
    FingerprintFormatError,
    InvalidAlgorithmError,
    KeyParseError,
    SignatureParseError,
    KeyEncryptedError,
    CertificateParseError
  };
  return errors$1;
}
var ber = { exports: {} };
var errors;
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  errors = {
    newInvalidAsn1Error: function(msg) {
      var e = new Error();
      e.name = "InvalidAsn1Error";
      e.message = msg || "";
      return e;
    }
  };
  return errors;
}
var types;
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types;
  hasRequiredTypes = 1;
  types = {
    EOC: 0,
    Boolean: 1,
    Integer: 2,
    BitString: 3,
    OctetString: 4,
    Null: 5,
    OID: 6,
    ObjectDescriptor: 7,
    External: 8,
    Real: 9,
    // float
    Enumeration: 10,
    PDV: 11,
    Utf8String: 12,
    RelativeOID: 13,
    Sequence: 16,
    Set: 17,
    NumericString: 18,
    PrintableString: 19,
    T61String: 20,
    VideotexString: 21,
    IA5String: 22,
    UTCTime: 23,
    GeneralizedTime: 24,
    GraphicString: 25,
    VisibleString: 26,
    GeneralString: 28,
    UniversalString: 29,
    CharacterString: 30,
    BMPString: 31,
    Constructor: 32,
    Context: 128
  };
  return types;
}
var reader;
var hasRequiredReader;
function requireReader() {
  if (hasRequiredReader) return reader;
  hasRequiredReader = 1;
  var assert = require$$0$6;
  var Buffer2 = requireSafer().Buffer;
  var ASN1 = requireTypes();
  var errors2 = requireErrors();
  var newInvalidAsn1Error = errors2.newInvalidAsn1Error;
  function Reader(data2) {
    if (!data2 || !Buffer2.isBuffer(data2))
      throw new TypeError("data must be a node Buffer");
    this._buf = data2;
    this._size = data2.length;
    this._len = 0;
    this._offset = 0;
  }
  Object.defineProperty(Reader.prototype, "length", {
    enumerable: true,
    get: function() {
      return this._len;
    }
  });
  Object.defineProperty(Reader.prototype, "offset", {
    enumerable: true,
    get: function() {
      return this._offset;
    }
  });
  Object.defineProperty(Reader.prototype, "remain", {
    get: function() {
      return this._size - this._offset;
    }
  });
  Object.defineProperty(Reader.prototype, "buffer", {
    get: function() {
      return this._buf.slice(this._offset);
    }
  });
  Reader.prototype.readByte = function(peek) {
    if (this._size - this._offset < 1)
      return null;
    var b = this._buf[this._offset] & 255;
    if (!peek)
      this._offset += 1;
    return b;
  };
  Reader.prototype.peek = function() {
    return this.readByte(true);
  };
  Reader.prototype.readLength = function(offset) {
    if (offset === void 0)
      offset = this._offset;
    if (offset >= this._size)
      return null;
    var lenB = this._buf[offset++] & 255;
    if (lenB === null)
      return null;
    if ((lenB & 128) === 128) {
      lenB &= 127;
      if (lenB === 0)
        throw newInvalidAsn1Error("Indefinite length not supported");
      if (lenB > 4)
        throw newInvalidAsn1Error("encoding too long");
      if (this._size - offset < lenB)
        return null;
      this._len = 0;
      for (var i = 0; i < lenB; i++)
        this._len = (this._len << 8) + (this._buf[offset++] & 255);
    } else {
      this._len = lenB;
    }
    return offset;
  };
  Reader.prototype.readSequence = function(tag) {
    var seq = this.peek();
    if (seq === null)
      return null;
    if (tag !== void 0 && tag !== seq)
      throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + seq.toString(16));
    var o = this.readLength(this._offset + 1);
    if (o === null)
      return null;
    this._offset = o;
    return seq;
  };
  Reader.prototype.readInt = function() {
    return this._readTag(ASN1.Integer);
  };
  Reader.prototype.readBoolean = function() {
    return this._readTag(ASN1.Boolean) === 0 ? false : true;
  };
  Reader.prototype.readEnumeration = function() {
    return this._readTag(ASN1.Enumeration);
  };
  Reader.prototype.readString = function(tag, retbuf) {
    if (!tag)
      tag = ASN1.OctetString;
    var b = this.peek();
    if (b === null)
      return null;
    if (b !== tag)
      throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
    var o = this.readLength(this._offset + 1);
    if (o === null)
      return null;
    if (this.length > this._size - o)
      return null;
    this._offset = o;
    if (this.length === 0)
      return retbuf ? Buffer2.alloc(0) : "";
    var str = this._buf.slice(this._offset, this._offset + this.length);
    this._offset += this.length;
    return retbuf ? str : str.toString("utf8");
  };
  Reader.prototype.readOID = function(tag) {
    if (!tag)
      tag = ASN1.OID;
    var b = this.readString(tag, true);
    if (b === null)
      return null;
    var values = [];
    var value = 0;
    for (var i = 0; i < b.length; i++) {
      var byte = b[i] & 255;
      value <<= 7;
      value += byte & 127;
      if ((byte & 128) === 0) {
        values.push(value);
        value = 0;
      }
    }
    value = values.shift();
    values.unshift(value % 40);
    values.unshift(value / 40 >> 0);
    return values.join(".");
  };
  Reader.prototype._readTag = function(tag) {
    assert.ok(tag !== void 0);
    var b = this.peek();
    if (b === null)
      return null;
    if (b !== tag)
      throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
    var o = this.readLength(this._offset + 1);
    if (o === null)
      return null;
    if (this.length > 4)
      throw newInvalidAsn1Error("Integer too long: " + this.length);
    if (this.length > this._size - o)
      return null;
    this._offset = o;
    var fb = this._buf[this._offset];
    var value = 0;
    for (var i = 0; i < this.length; i++) {
      value <<= 8;
      value |= this._buf[this._offset++] & 255;
    }
    if ((fb & 128) === 128 && i !== 4)
      value -= 1 << i * 8;
    return value >> 0;
  };
  reader = Reader;
  return reader;
}
var writer;
var hasRequiredWriter;
function requireWriter() {
  if (hasRequiredWriter) return writer;
  hasRequiredWriter = 1;
  var assert = require$$0$6;
  var Buffer2 = requireSafer().Buffer;
  var ASN1 = requireTypes();
  var errors2 = requireErrors();
  var newInvalidAsn1Error = errors2.newInvalidAsn1Error;
  var DEFAULT_OPTS = {
    size: 1024,
    growthFactor: 8
  };
  function merge(from, to) {
    assert.ok(from);
    assert.equal(typeof from, "object");
    assert.ok(to);
    assert.equal(typeof to, "object");
    var keys = Object.getOwnPropertyNames(from);
    keys.forEach(function(key2) {
      if (to[key2])
        return;
      var value = Object.getOwnPropertyDescriptor(from, key2);
      Object.defineProperty(to, key2, value);
    });
    return to;
  }
  function Writer(options) {
    options = merge(DEFAULT_OPTS, options || {});
    this._buf = Buffer2.alloc(options.size || 1024);
    this._size = this._buf.length;
    this._offset = 0;
    this._options = options;
    this._seq = [];
  }
  Object.defineProperty(Writer.prototype, "buffer", {
    get: function() {
      if (this._seq.length)
        throw newInvalidAsn1Error(this._seq.length + " unended sequence(s)");
      return this._buf.slice(0, this._offset);
    }
  });
  Writer.prototype.writeByte = function(b) {
    if (typeof b !== "number")
      throw new TypeError("argument must be a Number");
    this._ensure(1);
    this._buf[this._offset++] = b;
  };
  Writer.prototype.writeInt = function(i, tag) {
    if (typeof i !== "number")
      throw new TypeError("argument must be a Number");
    if (typeof tag !== "number")
      tag = ASN1.Integer;
    var sz = 4;
    while (((i & 4286578688) === 0 || (i & 4286578688) === 4286578688 >> 0) && sz > 1) {
      sz--;
      i <<= 8;
    }
    if (sz > 4)
      throw newInvalidAsn1Error("BER ints cannot be > 0xffffffff");
    this._ensure(2 + sz);
    this._buf[this._offset++] = tag;
    this._buf[this._offset++] = sz;
    while (sz-- > 0) {
      this._buf[this._offset++] = (i & 4278190080) >>> 24;
      i <<= 8;
    }
  };
  Writer.prototype.writeNull = function() {
    this.writeByte(ASN1.Null);
    this.writeByte(0);
  };
  Writer.prototype.writeEnumeration = function(i, tag) {
    if (typeof i !== "number")
      throw new TypeError("argument must be a Number");
    if (typeof tag !== "number")
      tag = ASN1.Enumeration;
    return this.writeInt(i, tag);
  };
  Writer.prototype.writeBoolean = function(b, tag) {
    if (typeof b !== "boolean")
      throw new TypeError("argument must be a Boolean");
    if (typeof tag !== "number")
      tag = ASN1.Boolean;
    this._ensure(3);
    this._buf[this._offset++] = tag;
    this._buf[this._offset++] = 1;
    this._buf[this._offset++] = b ? 255 : 0;
  };
  Writer.prototype.writeString = function(s, tag) {
    if (typeof s !== "string")
      throw new TypeError("argument must be a string (was: " + typeof s + ")");
    if (typeof tag !== "number")
      tag = ASN1.OctetString;
    var len = Buffer2.byteLength(s);
    this.writeByte(tag);
    this.writeLength(len);
    if (len) {
      this._ensure(len);
      this._buf.write(s, this._offset);
      this._offset += len;
    }
  };
  Writer.prototype.writeBuffer = function(buf, tag) {
    if (typeof tag !== "number")
      throw new TypeError("tag must be a number");
    if (!Buffer2.isBuffer(buf))
      throw new TypeError("argument must be a buffer");
    this.writeByte(tag);
    this.writeLength(buf.length);
    this._ensure(buf.length);
    buf.copy(this._buf, this._offset, 0, buf.length);
    this._offset += buf.length;
  };
  Writer.prototype.writeStringArray = function(strings) {
    if (!strings instanceof Array)
      throw new TypeError("argument must be an Array[String]");
    var self2 = this;
    strings.forEach(function(s) {
      self2.writeString(s);
    });
  };
  Writer.prototype.writeOID = function(s, tag) {
    if (typeof s !== "string")
      throw new TypeError("argument must be a string");
    if (typeof tag !== "number")
      tag = ASN1.OID;
    if (!/^([0-9]+\.){3,}[0-9]+$/.test(s))
      throw new Error("argument is not a valid OID string");
    function encodeOctet(bytes2, octet) {
      if (octet < 128) {
        bytes2.push(octet);
      } else if (octet < 16384) {
        bytes2.push(octet >>> 7 | 128);
        bytes2.push(octet & 127);
      } else if (octet < 2097152) {
        bytes2.push(octet >>> 14 | 128);
        bytes2.push((octet >>> 7 | 128) & 255);
        bytes2.push(octet & 127);
      } else if (octet < 268435456) {
        bytes2.push(octet >>> 21 | 128);
        bytes2.push((octet >>> 14 | 128) & 255);
        bytes2.push((octet >>> 7 | 128) & 255);
        bytes2.push(octet & 127);
      } else {
        bytes2.push((octet >>> 28 | 128) & 255);
        bytes2.push((octet >>> 21 | 128) & 255);
        bytes2.push((octet >>> 14 | 128) & 255);
        bytes2.push((octet >>> 7 | 128) & 255);
        bytes2.push(octet & 127);
      }
    }
    var tmp = s.split(".");
    var bytes = [];
    bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
    tmp.slice(2).forEach(function(b) {
      encodeOctet(bytes, parseInt(b, 10));
    });
    var self2 = this;
    this._ensure(2 + bytes.length);
    this.writeByte(tag);
    this.writeLength(bytes.length);
    bytes.forEach(function(b) {
      self2.writeByte(b);
    });
  };
  Writer.prototype.writeLength = function(len) {
    if (typeof len !== "number")
      throw new TypeError("argument must be a Number");
    this._ensure(4);
    if (len <= 127) {
      this._buf[this._offset++] = len;
    } else if (len <= 255) {
      this._buf[this._offset++] = 129;
      this._buf[this._offset++] = len;
    } else if (len <= 65535) {
      this._buf[this._offset++] = 130;
      this._buf[this._offset++] = len >> 8;
      this._buf[this._offset++] = len;
    } else if (len <= 16777215) {
      this._buf[this._offset++] = 131;
      this._buf[this._offset++] = len >> 16;
      this._buf[this._offset++] = len >> 8;
      this._buf[this._offset++] = len;
    } else {
      throw newInvalidAsn1Error("Length too long (> 4 bytes)");
    }
  };
  Writer.prototype.startSequence = function(tag) {
    if (typeof tag !== "number")
      tag = ASN1.Sequence | ASN1.Constructor;
    this.writeByte(tag);
    this._seq.push(this._offset);
    this._ensure(3);
    this._offset += 3;
  };
  Writer.prototype.endSequence = function() {
    var seq = this._seq.pop();
    var start = seq + 3;
    var len = this._offset - start;
    if (len <= 127) {
      this._shift(start, len, -2);
      this._buf[seq] = len;
    } else if (len <= 255) {
      this._shift(start, len, -1);
      this._buf[seq] = 129;
      this._buf[seq + 1] = len;
    } else if (len <= 65535) {
      this._buf[seq] = 130;
      this._buf[seq + 1] = len >> 8;
      this._buf[seq + 2] = len;
    } else if (len <= 16777215) {
      this._shift(start, len, 1);
      this._buf[seq] = 131;
      this._buf[seq + 1] = len >> 16;
      this._buf[seq + 2] = len >> 8;
      this._buf[seq + 3] = len;
    } else {
      throw newInvalidAsn1Error("Sequence too long");
    }
  };
  Writer.prototype._shift = function(start, len, shift) {
    assert.ok(start !== void 0);
    assert.ok(len !== void 0);
    assert.ok(shift);
    this._buf.copy(this._buf, start + shift, start, start + len);
    this._offset += shift;
  };
  Writer.prototype._ensure = function(len) {
    assert.ok(len);
    if (this._size - this._offset < len) {
      var sz = this._size * this._options.growthFactor;
      if (sz - this._offset < len)
        sz += len;
      var buf = Buffer2.alloc(sz);
      this._buf.copy(buf, 0, 0, this._offset);
      this._buf = buf;
      this._size = sz;
    }
  };
  writer = Writer;
  return writer;
}
var hasRequiredBer;
function requireBer() {
  if (hasRequiredBer) return ber.exports;
  hasRequiredBer = 1;
  (function(module) {
    var errors2 = requireErrors();
    var types2 = requireTypes();
    var Reader = requireReader();
    var Writer = requireWriter();
    module.exports = {
      Reader,
      Writer
    };
    for (var t in types2) {
      if (types2.hasOwnProperty(t))
        module.exports[t] = types2[t];
    }
    for (var e in errors2) {
      if (errors2.hasOwnProperty(e))
        module.exports[e] = errors2[e];
    }
  })(ber);
  return ber.exports;
}
var lib$4;
var hasRequiredLib$4;
function requireLib$4() {
  if (hasRequiredLib$4) return lib$4;
  hasRequiredLib$4 = 1;
  var Ber = requireBer();
  lib$4 = {
    Ber,
    BerReader: Ber.Reader,
    BerWriter: Ber.Writer
  };
  return lib$4;
}
var jsbn$1 = { exports: {} };
var jsbn = jsbn$1.exports;
var hasRequiredJsbn;
function requireJsbn() {
  if (hasRequiredJsbn) return jsbn$1.exports;
  hasRequiredJsbn = 1;
  (function(module, exports$1) {
    (function() {
      var dbits;
      var canary = 244837814094590;
      var j_lm = (canary & 16777215) == 15715070;
      function BigInteger(a, b, c) {
        if (a != null)
          if ("number" == typeof a) this.fromNumber(a, b, c);
          else if (b == null && "string" != typeof a) this.fromString(a, 256);
          else this.fromString(a, b);
      }
      function nbi() {
        return new BigInteger(null);
      }
      function am1(i, x, w, j, c, n) {
        while (--n >= 0) {
          var v = x * this[i++] + w[j] + c;
          c = Math.floor(v / 67108864);
          w[j++] = v & 67108863;
        }
        return c;
      }
      function am2(i, x, w, j, c, n) {
        var xl = x & 32767, xh = x >> 15;
        while (--n >= 0) {
          var l = this[i] & 32767;
          var h = this[i++] >> 15;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 32767) << 15) + w[j] + (c & 1073741823);
          c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
          w[j++] = l & 1073741823;
        }
        return c;
      }
      function am3(i, x, w, j, c, n) {
        var xl = x & 16383, xh = x >> 14;
        while (--n >= 0) {
          var l = this[i] & 16383;
          var h = this[i++] >> 14;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 16383) << 14) + w[j] + c;
          c = (l >> 28) + (m >> 14) + xh * h;
          w[j++] = l & 268435455;
        }
        return c;
      }
      var inBrowser = typeof navigator !== "undefined";
      if (inBrowser && j_lm && navigator.appName == "Microsoft Internet Explorer") {
        BigInteger.prototype.am = am2;
        dbits = 30;
      } else if (inBrowser && j_lm && navigator.appName != "Netscape") {
        BigInteger.prototype.am = am1;
        dbits = 26;
      } else {
        BigInteger.prototype.am = am3;
        dbits = 28;
      }
      BigInteger.prototype.DB = dbits;
      BigInteger.prototype.DM = (1 << dbits) - 1;
      BigInteger.prototype.DV = 1 << dbits;
      var BI_FP = 52;
      BigInteger.prototype.FV = Math.pow(2, BI_FP);
      BigInteger.prototype.F1 = BI_FP - dbits;
      BigInteger.prototype.F2 = 2 * dbits - BI_FP;
      var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
      var BI_RC = new Array();
      var rr, vv;
      rr = "0".charCodeAt(0);
      for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
      rr = "a".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
      rr = "A".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
      function int2char(n) {
        return BI_RM.charAt(n);
      }
      function intAt(s, i) {
        var c = BI_RC[s.charCodeAt(i)];
        return c == null ? -1 : c;
      }
      function bnpCopyTo(r) {
        for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];
        r.t = this.t;
        r.s = this.s;
      }
      function bnpFromInt(x) {
        this.t = 1;
        this.s = x < 0 ? -1 : 0;
        if (x > 0) this[0] = x;
        else if (x < -1) this[0] = x + this.DV;
        else this.t = 0;
      }
      function nbv(i) {
        var r = nbi();
        r.fromInt(i);
        return r;
      }
      function bnpFromString(s, b) {
        var k;
        if (b == 16) k = 4;
        else if (b == 8) k = 3;
        else if (b == 256) k = 8;
        else if (b == 2) k = 1;
        else if (b == 32) k = 5;
        else if (b == 4) k = 2;
        else {
          this.fromRadix(s, b);
          return;
        }
        this.t = 0;
        this.s = 0;
        var i = s.length, mi = false, sh = 0;
        while (--i >= 0) {
          var x = k == 8 ? s[i] & 255 : intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-") mi = true;
            continue;
          }
          mi = false;
          if (sh == 0)
            this[this.t++] = x;
          else if (sh + k > this.DB) {
            this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
            this[this.t++] = x >> this.DB - sh;
          } else
            this[this.t - 1] |= x << sh;
          sh += k;
          if (sh >= this.DB) sh -= this.DB;
        }
        if (k == 8 && (s[0] & 128) != 0) {
          this.s = -1;
          if (sh > 0) this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
        }
        this.clamp();
        if (mi) BigInteger.ZERO.subTo(this, this);
      }
      function bnpClamp() {
        var c = this.s & this.DM;
        while (this.t > 0 && this[this.t - 1] == c) --this.t;
      }
      function bnToString(b) {
        if (this.s < 0) return "-" + this.negate().toString(b);
        var k;
        if (b == 16) k = 4;
        else if (b == 8) k = 3;
        else if (b == 2) k = 1;
        else if (b == 32) k = 5;
        else if (b == 4) k = 2;
        else return this.toRadix(b);
        var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
        var p = this.DB - i * this.DB % k;
        if (i-- > 0) {
          if (p < this.DB && (d = this[i] >> p) > 0) {
            m = true;
            r = int2char(d);
          }
          while (i >= 0) {
            if (p < k) {
              d = (this[i] & (1 << p) - 1) << k - p;
              d |= this[--i] >> (p += this.DB - k);
            } else {
              d = this[i] >> (p -= k) & km;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if (d > 0) m = true;
            if (m) r += int2char(d);
          }
        }
        return m ? r : "0";
      }
      function bnNegate() {
        var r = nbi();
        BigInteger.ZERO.subTo(this, r);
        return r;
      }
      function bnAbs() {
        return this.s < 0 ? this.negate() : this;
      }
      function bnCompareTo(a) {
        var r = this.s - a.s;
        if (r != 0) return r;
        var i = this.t;
        r = i - a.t;
        if (r != 0) return this.s < 0 ? -r : r;
        while (--i >= 0) if ((r = this[i] - a[i]) != 0) return r;
        return 0;
      }
      function nbits(x) {
        var r = 1, t2;
        if ((t2 = x >>> 16) != 0) {
          x = t2;
          r += 16;
        }
        if ((t2 = x >> 8) != 0) {
          x = t2;
          r += 8;
        }
        if ((t2 = x >> 4) != 0) {
          x = t2;
          r += 4;
        }
        if ((t2 = x >> 2) != 0) {
          x = t2;
          r += 2;
        }
        if ((t2 = x >> 1) != 0) {
          x = t2;
          r += 1;
        }
        return r;
      }
      function bnBitLength() {
        if (this.t <= 0) return 0;
        return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
      }
      function bnpDLShiftTo(n, r) {
        var i;
        for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];
        for (i = n - 1; i >= 0; --i) r[i] = 0;
        r.t = this.t + n;
        r.s = this.s;
      }
      function bnpDRShiftTo(n, r) {
        for (var i = n; i < this.t; ++i) r[i - n] = this[i];
        r.t = Math.max(this.t - n, 0);
        r.s = this.s;
      }
      function bnpLShiftTo(n, r) {
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << cbs) - 1;
        var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
        for (i = this.t - 1; i >= 0; --i) {
          r[i + ds + 1] = this[i] >> cbs | c;
          c = (this[i] & bm) << bs;
        }
        for (i = ds - 1; i >= 0; --i) r[i] = 0;
        r[ds] = c;
        r.t = this.t + ds + 1;
        r.s = this.s;
        r.clamp();
      }
      function bnpRShiftTo(n, r) {
        r.s = this.s;
        var ds = Math.floor(n / this.DB);
        if (ds >= this.t) {
          r.t = 0;
          return;
        }
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << bs) - 1;
        r[0] = this[ds] >> bs;
        for (var i = ds + 1; i < this.t; ++i) {
          r[i - ds - 1] |= (this[i] & bm) << cbs;
          r[i - ds] = this[i] >> bs;
        }
        if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;
        r.t = this.t - ds;
        r.clamp();
      }
      function bnpSubTo(a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
          c += this[i] - a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c -= a.s;
          while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c -= a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c -= a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c < -1) r[i++] = this.DV + c;
        else if (c > 0) r[i++] = c;
        r.t = i;
        r.clamp();
      }
      function bnpMultiplyTo(a, r) {
        var x = this.abs(), y = a.abs();
        var i = x.t;
        r.t = i + y.t;
        while (--i >= 0) r[i] = 0;
        for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
        r.s = 0;
        r.clamp();
        if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
      }
      function bnpSquareTo(r) {
        var x = this.abs();
        var i = r.t = 2 * x.t;
        while (--i >= 0) r[i] = 0;
        for (i = 0; i < x.t - 1; ++i) {
          var c = x.am(i, x[i], r, 2 * i, 0, 1);
          if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
            r[i + x.t] -= x.DV;
            r[i + x.t + 1] = 1;
          }
        }
        if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
        r.s = 0;
        r.clamp();
      }
      function bnpDivRemTo(m, q2, r) {
        var pm = m.abs();
        if (pm.t <= 0) return;
        var pt = this.abs();
        if (pt.t < pm.t) {
          if (q2 != null) q2.fromInt(0);
          if (r != null) this.copyTo(r);
          return;
        }
        if (r == null) r = nbi();
        var y = nbi(), ts = this.s, ms = m.s;
        var nsh = this.DB - nbits(pm[pm.t - 1]);
        if (nsh > 0) {
          pm.lShiftTo(nsh, y);
          pt.lShiftTo(nsh, r);
        } else {
          pm.copyTo(y);
          pt.copyTo(r);
        }
        var ys = y.t;
        var y0 = y[ys - 1];
        if (y0 == 0) return;
        var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
        var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
        var i = r.t, j = i - ys, t2 = q2 == null ? nbi() : q2;
        y.dlShiftTo(j, t2);
        if (r.compareTo(t2) >= 0) {
          r[r.t++] = 1;
          r.subTo(t2, r);
        }
        BigInteger.ONE.dlShiftTo(ys, t2);
        t2.subTo(y, y);
        while (y.t < ys) y[y.t++] = 0;
        while (--j >= 0) {
          var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
          if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
            y.dlShiftTo(j, t2);
            r.subTo(t2, r);
            while (r[i] < --qd) r.subTo(t2, r);
          }
        }
        if (q2 != null) {
          r.drShiftTo(ys, q2);
          if (ts != ms) BigInteger.ZERO.subTo(q2, q2);
        }
        r.t = ys;
        r.clamp();
        if (nsh > 0) r.rShiftTo(nsh, r);
        if (ts < 0) BigInteger.ZERO.subTo(r, r);
      }
      function bnMod(a) {
        var r = nbi();
        this.abs().divRemTo(a, null, r);
        if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
        return r;
      }
      function Classic(m) {
        this.m = m;
      }
      function cConvert(x) {
        if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
        else return x;
      }
      function cRevert(x) {
        return x;
      }
      function cReduce(x) {
        x.divRemTo(this.m, null, x);
      }
      function cMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      function cSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      Classic.prototype.convert = cConvert;
      Classic.prototype.revert = cRevert;
      Classic.prototype.reduce = cReduce;
      Classic.prototype.mulTo = cMulTo;
      Classic.prototype.sqrTo = cSqrTo;
      function bnpInvDigit() {
        if (this.t < 1) return 0;
        var x = this[0];
        if ((x & 1) == 0) return 0;
        var y = x & 3;
        y = y * (2 - (x & 15) * y) & 15;
        y = y * (2 - (x & 255) * y) & 255;
        y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
        y = y * (2 - x * y % this.DV) % this.DV;
        return y > 0 ? this.DV - y : -y;
      }
      function Montgomery(m) {
        this.m = m;
        this.mp = m.invDigit();
        this.mpl = this.mp & 32767;
        this.mph = this.mp >> 15;
        this.um = (1 << m.DB - 15) - 1;
        this.mt2 = 2 * m.t;
      }
      function montConvert(x) {
        var r = nbi();
        x.abs().dlShiftTo(this.m.t, r);
        r.divRemTo(this.m, null, r);
        if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
        return r;
      }
      function montRevert(x) {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
      function montReduce(x) {
        while (x.t <= this.mt2)
          x[x.t++] = 0;
        for (var i = 0; i < this.m.t; ++i) {
          var j = x[i] & 32767;
          var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
          j = i + this.m.t;
          x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
          while (x[j] >= x.DV) {
            x[j] -= x.DV;
            x[++j]++;
          }
        }
        x.clamp();
        x.drShiftTo(this.m.t, x);
        if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
      }
      function montSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      function montMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      Montgomery.prototype.convert = montConvert;
      Montgomery.prototype.revert = montRevert;
      Montgomery.prototype.reduce = montReduce;
      Montgomery.prototype.mulTo = montMulTo;
      Montgomery.prototype.sqrTo = montSqrTo;
      function bnpIsEven() {
        return (this.t > 0 ? this[0] & 1 : this.s) == 0;
      }
      function bnpExp(e, z2) {
        if (e > 4294967295 || e < 1) return BigInteger.ONE;
        var r = nbi(), r2 = nbi(), g = z2.convert(this), i = nbits(e) - 1;
        g.copyTo(r);
        while (--i >= 0) {
          z2.sqrTo(r, r2);
          if ((e & 1 << i) > 0) z2.mulTo(r2, g, r);
          else {
            var t2 = r;
            r = r2;
            r2 = t2;
          }
        }
        return z2.revert(r);
      }
      function bnModPowInt(e, m) {
        var z2;
        if (e < 256 || m.isEven()) z2 = new Classic(m);
        else z2 = new Montgomery(m);
        return this.exp(e, z2);
      }
      BigInteger.prototype.copyTo = bnpCopyTo;
      BigInteger.prototype.fromInt = bnpFromInt;
      BigInteger.prototype.fromString = bnpFromString;
      BigInteger.prototype.clamp = bnpClamp;
      BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
      BigInteger.prototype.drShiftTo = bnpDRShiftTo;
      BigInteger.prototype.lShiftTo = bnpLShiftTo;
      BigInteger.prototype.rShiftTo = bnpRShiftTo;
      BigInteger.prototype.subTo = bnpSubTo;
      BigInteger.prototype.multiplyTo = bnpMultiplyTo;
      BigInteger.prototype.squareTo = bnpSquareTo;
      BigInteger.prototype.divRemTo = bnpDivRemTo;
      BigInteger.prototype.invDigit = bnpInvDigit;
      BigInteger.prototype.isEven = bnpIsEven;
      BigInteger.prototype.exp = bnpExp;
      BigInteger.prototype.toString = bnToString;
      BigInteger.prototype.negate = bnNegate;
      BigInteger.prototype.abs = bnAbs;
      BigInteger.prototype.compareTo = bnCompareTo;
      BigInteger.prototype.bitLength = bnBitLength;
      BigInteger.prototype.mod = bnMod;
      BigInteger.prototype.modPowInt = bnModPowInt;
      BigInteger.ZERO = nbv(0);
      BigInteger.ONE = nbv(1);
      function bnClone() {
        var r = nbi();
        this.copyTo(r);
        return r;
      }
      function bnIntValue() {
        if (this.s < 0) {
          if (this.t == 1) return this[0] - this.DV;
          else if (this.t == 0) return -1;
        } else if (this.t == 1) return this[0];
        else if (this.t == 0) return 0;
        return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
      }
      function bnByteValue() {
        return this.t == 0 ? this.s : this[0] << 24 >> 24;
      }
      function bnShortValue() {
        return this.t == 0 ? this.s : this[0] << 16 >> 16;
      }
      function bnpChunkSize(r) {
        return Math.floor(Math.LN2 * this.DB / Math.log(r));
      }
      function bnSigNum() {
        if (this.s < 0) return -1;
        else if (this.t <= 0 || this.t == 1 && this[0] <= 0) return 0;
        else return 1;
      }
      function bnpToRadix(b) {
        if (b == null) b = 10;
        if (this.signum() == 0 || b < 2 || b > 36) return "0";
        var cs = this.chunkSize(b);
        var a = Math.pow(b, cs);
        var d = nbv(a), y = nbi(), z2 = nbi(), r = "";
        this.divRemTo(d, y, z2);
        while (y.signum() > 0) {
          r = (a + z2.intValue()).toString(b).substr(1) + r;
          y.divRemTo(d, y, z2);
        }
        return z2.intValue().toString(b) + r;
      }
      function bnpFromRadix(s, b) {
        this.fromInt(0);
        if (b == null) b = 10;
        var cs = this.chunkSize(b);
        var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
        for (var i = 0; i < s.length; ++i) {
          var x = intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-" && this.signum() == 0) mi = true;
            continue;
          }
          w = b * w + x;
          if (++j >= cs) {
            this.dMultiply(d);
            this.dAddOffset(w, 0);
            j = 0;
            w = 0;
          }
        }
        if (j > 0) {
          this.dMultiply(Math.pow(b, j));
          this.dAddOffset(w, 0);
        }
        if (mi) BigInteger.ZERO.subTo(this, this);
      }
      function bnpFromNumber(a, b, c) {
        if ("number" == typeof b) {
          if (a < 2) this.fromInt(1);
          else {
            this.fromNumber(a, c);
            if (!this.testBit(a - 1))
              this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
            if (this.isEven()) this.dAddOffset(1, 0);
            while (!this.isProbablePrime(b)) {
              this.dAddOffset(2, 0);
              if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
            }
          }
        } else {
          var x = new Array(), t2 = a & 7;
          x.length = (a >> 3) + 1;
          b.nextBytes(x);
          if (t2 > 0) x[0] &= (1 << t2) - 1;
          else x[0] = 0;
          this.fromString(x, 256);
        }
      }
      function bnToByteArray() {
        var i = this.t, r = new Array();
        r[0] = this.s;
        var p = this.DB - i * this.DB % 8, d, k = 0;
        if (i-- > 0) {
          if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
            r[k++] = d | this.s << this.DB - p;
          while (i >= 0) {
            if (p < 8) {
              d = (this[i] & (1 << p) - 1) << 8 - p;
              d |= this[--i] >> (p += this.DB - 8);
            } else {
              d = this[i] >> (p -= 8) & 255;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if ((d & 128) != 0) d |= -256;
            if (k == 0 && (this.s & 128) != (d & 128)) ++k;
            if (k > 0 || d != this.s) r[k++] = d;
          }
        }
        return r;
      }
      function bnEquals(a) {
        return this.compareTo(a) == 0;
      }
      function bnMin(a) {
        return this.compareTo(a) < 0 ? this : a;
      }
      function bnMax(a) {
        return this.compareTo(a) > 0 ? this : a;
      }
      function bnpBitwiseTo(a, op, r) {
        var i, f, m = Math.min(a.t, this.t);
        for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);
        if (a.t < this.t) {
          f = a.s & this.DM;
          for (i = m; i < this.t; ++i) r[i] = op(this[i], f);
          r.t = this.t;
        } else {
          f = this.s & this.DM;
          for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);
          r.t = a.t;
        }
        r.s = op(this.s, a.s);
        r.clamp();
      }
      function op_and(x, y) {
        return x & y;
      }
      function bnAnd(a) {
        var r = nbi();
        this.bitwiseTo(a, op_and, r);
        return r;
      }
      function op_or(x, y) {
        return x | y;
      }
      function bnOr(a) {
        var r = nbi();
        this.bitwiseTo(a, op_or, r);
        return r;
      }
      function op_xor(x, y) {
        return x ^ y;
      }
      function bnXor(a) {
        var r = nbi();
        this.bitwiseTo(a, op_xor, r);
        return r;
      }
      function op_andnot(x, y) {
        return x & ~y;
      }
      function bnAndNot(a) {
        var r = nbi();
        this.bitwiseTo(a, op_andnot, r);
        return r;
      }
      function bnNot() {
        var r = nbi();
        for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];
        r.t = this.t;
        r.s = ~this.s;
        return r;
      }
      function bnShiftLeft(n) {
        var r = nbi();
        if (n < 0) this.rShiftTo(-n, r);
        else this.lShiftTo(n, r);
        return r;
      }
      function bnShiftRight(n) {
        var r = nbi();
        if (n < 0) this.lShiftTo(-n, r);
        else this.rShiftTo(n, r);
        return r;
      }
      function lbit(x) {
        if (x == 0) return -1;
        var r = 0;
        if ((x & 65535) == 0) {
          x >>= 16;
          r += 16;
        }
        if ((x & 255) == 0) {
          x >>= 8;
          r += 8;
        }
        if ((x & 15) == 0) {
          x >>= 4;
          r += 4;
        }
        if ((x & 3) == 0) {
          x >>= 2;
          r += 2;
        }
        if ((x & 1) == 0) ++r;
        return r;
      }
      function bnGetLowestSetBit() {
        for (var i = 0; i < this.t; ++i)
          if (this[i] != 0) return i * this.DB + lbit(this[i]);
        if (this.s < 0) return this.t * this.DB;
        return -1;
      }
      function cbit(x) {
        var r = 0;
        while (x != 0) {
          x &= x - 1;
          ++r;
        }
        return r;
      }
      function bnBitCount() {
        var r = 0, x = this.s & this.DM;
        for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);
        return r;
      }
      function bnTestBit(n) {
        var j = Math.floor(n / this.DB);
        if (j >= this.t) return this.s != 0;
        return (this[j] & 1 << n % this.DB) != 0;
      }
      function bnpChangeBit(n, op) {
        var r = BigInteger.ONE.shiftLeft(n);
        this.bitwiseTo(r, op, r);
        return r;
      }
      function bnSetBit(n) {
        return this.changeBit(n, op_or);
      }
      function bnClearBit(n) {
        return this.changeBit(n, op_andnot);
      }
      function bnFlipBit(n) {
        return this.changeBit(n, op_xor);
      }
      function bnpAddTo(a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
          c += this[i] + a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c += a.s;
          while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c += a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c > 0) r[i++] = c;
        else if (c < -1) r[i++] = this.DV + c;
        r.t = i;
        r.clamp();
      }
      function bnAdd(a) {
        var r = nbi();
        this.addTo(a, r);
        return r;
      }
      function bnSubtract(a) {
        var r = nbi();
        this.subTo(a, r);
        return r;
      }
      function bnMultiply(a) {
        var r = nbi();
        this.multiplyTo(a, r);
        return r;
      }
      function bnSquare() {
        var r = nbi();
        this.squareTo(r);
        return r;
      }
      function bnDivide(a) {
        var r = nbi();
        this.divRemTo(a, r, null);
        return r;
      }
      function bnRemainder(a) {
        var r = nbi();
        this.divRemTo(a, null, r);
        return r;
      }
      function bnDivideAndRemainder(a) {
        var q2 = nbi(), r = nbi();
        this.divRemTo(a, q2, r);
        return new Array(q2, r);
      }
      function bnpDMultiply(n) {
        this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
        ++this.t;
        this.clamp();
      }
      function bnpDAddOffset(n, w) {
        if (n == 0) return;
        while (this.t <= w) this[this.t++] = 0;
        this[w] += n;
        while (this[w] >= this.DV) {
          this[w] -= this.DV;
          if (++w >= this.t) this[this.t++] = 0;
          ++this[w];
        }
      }
      function NullExp() {
      }
      function nNop(x) {
        return x;
      }
      function nMulTo(x, y, r) {
        x.multiplyTo(y, r);
      }
      function nSqrTo(x, r) {
        x.squareTo(r);
      }
      NullExp.prototype.convert = nNop;
      NullExp.prototype.revert = nNop;
      NullExp.prototype.mulTo = nMulTo;
      NullExp.prototype.sqrTo = nSqrTo;
      function bnPow(e) {
        return this.exp(e, new NullExp());
      }
      function bnpMultiplyLowerTo(a, n, r) {
        var i = Math.min(this.t + a.t, n);
        r.s = 0;
        r.t = i;
        while (i > 0) r[--i] = 0;
        var j;
        for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
        for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);
        r.clamp();
      }
      function bnpMultiplyUpperTo(a, n, r) {
        --n;
        var i = r.t = this.t + a.t - n;
        r.s = 0;
        while (--i >= 0) r[i] = 0;
        for (i = Math.max(n - this.t, 0); i < a.t; ++i)
          r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
        r.clamp();
        r.drShiftTo(1, r);
      }
      function Barrett(m) {
        this.r2 = nbi();
        this.q3 = nbi();
        BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
        this.mu = this.r2.divide(m);
        this.m = m;
      }
      function barrettConvert(x) {
        if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
        else if (x.compareTo(this.m) < 0) return x;
        else {
          var r = nbi();
          x.copyTo(r);
          this.reduce(r);
          return r;
        }
      }
      function barrettRevert(x) {
        return x;
      }
      function barrettReduce(x) {
        x.drShiftTo(this.m.t - 1, this.r2);
        if (x.t > this.m.t + 1) {
          x.t = this.m.t + 1;
          x.clamp();
        }
        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
        this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
        while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
        x.subTo(this.r2, x);
        while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
      }
      function barrettSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      function barrettMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      Barrett.prototype.convert = barrettConvert;
      Barrett.prototype.revert = barrettRevert;
      Barrett.prototype.reduce = barrettReduce;
      Barrett.prototype.mulTo = barrettMulTo;
      Barrett.prototype.sqrTo = barrettSqrTo;
      function bnModPow(e, m) {
        var i = e.bitLength(), k, r = nbv(1), z2;
        if (i <= 0) return r;
        else if (i < 18) k = 1;
        else if (i < 48) k = 3;
        else if (i < 144) k = 4;
        else if (i < 768) k = 5;
        else k = 6;
        if (i < 8)
          z2 = new Classic(m);
        else if (m.isEven())
          z2 = new Barrett(m);
        else
          z2 = new Montgomery(m);
        var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
        g[1] = z2.convert(this);
        if (k > 1) {
          var g2 = nbi();
          z2.sqrTo(g[1], g2);
          while (n <= km) {
            g[n] = nbi();
            z2.mulTo(g2, g[n - 2], g[n]);
            n += 2;
          }
        }
        var j = e.t - 1, w, is1 = true, r2 = nbi(), t2;
        i = nbits(e[j]) - 1;
        while (j >= 0) {
          if (i >= k1) w = e[j] >> i - k1 & km;
          else {
            w = (e[j] & (1 << i + 1) - 1) << k1 - i;
            if (j > 0) w |= e[j - 1] >> this.DB + i - k1;
          }
          n = k;
          while ((w & 1) == 0) {
            w >>= 1;
            --n;
          }
          if ((i -= n) < 0) {
            i += this.DB;
            --j;
          }
          if (is1) {
            g[w].copyTo(r);
            is1 = false;
          } else {
            while (n > 1) {
              z2.sqrTo(r, r2);
              z2.sqrTo(r2, r);
              n -= 2;
            }
            if (n > 0) z2.sqrTo(r, r2);
            else {
              t2 = r;
              r = r2;
              r2 = t2;
            }
            z2.mulTo(r2, g[w], r);
          }
          while (j >= 0 && (e[j] & 1 << i) == 0) {
            z2.sqrTo(r, r2);
            t2 = r;
            r = r2;
            r2 = t2;
            if (--i < 0) {
              i = this.DB - 1;
              --j;
            }
          }
        }
        return z2.revert(r);
      }
      function bnGCD(a) {
        var x = this.s < 0 ? this.negate() : this.clone();
        var y = a.s < 0 ? a.negate() : a.clone();
        if (x.compareTo(y) < 0) {
          var t2 = x;
          x = y;
          y = t2;
        }
        var i = x.getLowestSetBit(), g = y.getLowestSetBit();
        if (g < 0) return x;
        if (i < g) g = i;
        if (g > 0) {
          x.rShiftTo(g, x);
          y.rShiftTo(g, y);
        }
        while (x.signum() > 0) {
          if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
          if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
          if (x.compareTo(y) >= 0) {
            x.subTo(y, x);
            x.rShiftTo(1, x);
          } else {
            y.subTo(x, y);
            y.rShiftTo(1, y);
          }
        }
        if (g > 0) y.lShiftTo(g, y);
        return y;
      }
      function bnpModInt(n) {
        if (n <= 0) return 0;
        var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
        if (this.t > 0)
          if (d == 0) r = this[0] % n;
          else for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;
        return r;
      }
      function bnModInverse(m) {
        var ac = m.isEven();
        if (this.isEven() && ac || m.signum() == 0) return BigInteger.ZERO;
        var u = m.clone(), v = this.clone();
        var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
        while (u.signum() != 0) {
          while (u.isEven()) {
            u.rShiftTo(1, u);
            if (ac) {
              if (!a.isEven() || !b.isEven()) {
                a.addTo(this, a);
                b.subTo(m, b);
              }
              a.rShiftTo(1, a);
            } else if (!b.isEven()) b.subTo(m, b);
            b.rShiftTo(1, b);
          }
          while (v.isEven()) {
            v.rShiftTo(1, v);
            if (ac) {
              if (!c.isEven() || !d.isEven()) {
                c.addTo(this, c);
                d.subTo(m, d);
              }
              c.rShiftTo(1, c);
            } else if (!d.isEven()) d.subTo(m, d);
            d.rShiftTo(1, d);
          }
          if (u.compareTo(v) >= 0) {
            u.subTo(v, u);
            if (ac) a.subTo(c, a);
            b.subTo(d, b);
          } else {
            v.subTo(u, v);
            if (ac) c.subTo(a, c);
            d.subTo(b, d);
          }
        }
        if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
        if (d.compareTo(m) >= 0) return d.subtract(m);
        if (d.signum() < 0) d.addTo(m, d);
        else return d;
        if (d.signum() < 0) return d.add(m);
        else return d;
      }
      var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
      var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
      function bnIsProbablePrime(t2) {
        var i, x = this.abs();
        if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
          for (i = 0; i < lowprimes.length; ++i)
            if (x[0] == lowprimes[i]) return true;
          return false;
        }
        if (x.isEven()) return false;
        i = 1;
        while (i < lowprimes.length) {
          var m = lowprimes[i], j = i + 1;
          while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
          m = x.modInt(m);
          while (i < j) if (m % lowprimes[i++] == 0) return false;
        }
        return x.millerRabin(t2);
      }
      function bnpMillerRabin(t2) {
        var n1 = this.subtract(BigInteger.ONE);
        var k = n1.getLowestSetBit();
        if (k <= 0) return false;
        var r = n1.shiftRight(k);
        t2 = t2 + 1 >> 1;
        if (t2 > lowprimes.length) t2 = lowprimes.length;
        var a = nbi();
        for (var i = 0; i < t2; ++i) {
          a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
          var y = a.modPow(r, this);
          if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
            var j = 1;
            while (j++ < k && y.compareTo(n1) != 0) {
              y = y.modPowInt(2, this);
              if (y.compareTo(BigInteger.ONE) == 0) return false;
            }
            if (y.compareTo(n1) != 0) return false;
          }
        }
        return true;
      }
      BigInteger.prototype.chunkSize = bnpChunkSize;
      BigInteger.prototype.toRadix = bnpToRadix;
      BigInteger.prototype.fromRadix = bnpFromRadix;
      BigInteger.prototype.fromNumber = bnpFromNumber;
      BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
      BigInteger.prototype.changeBit = bnpChangeBit;
      BigInteger.prototype.addTo = bnpAddTo;
      BigInteger.prototype.dMultiply = bnpDMultiply;
      BigInteger.prototype.dAddOffset = bnpDAddOffset;
      BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
      BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
      BigInteger.prototype.modInt = bnpModInt;
      BigInteger.prototype.millerRabin = bnpMillerRabin;
      BigInteger.prototype.clone = bnClone;
      BigInteger.prototype.intValue = bnIntValue;
      BigInteger.prototype.byteValue = bnByteValue;
      BigInteger.prototype.shortValue = bnShortValue;
      BigInteger.prototype.signum = bnSigNum;
      BigInteger.prototype.toByteArray = bnToByteArray;
      BigInteger.prototype.equals = bnEquals;
      BigInteger.prototype.min = bnMin;
      BigInteger.prototype.max = bnMax;
      BigInteger.prototype.and = bnAnd;
      BigInteger.prototype.or = bnOr;
      BigInteger.prototype.xor = bnXor;
      BigInteger.prototype.andNot = bnAndNot;
      BigInteger.prototype.not = bnNot;
      BigInteger.prototype.shiftLeft = bnShiftLeft;
      BigInteger.prototype.shiftRight = bnShiftRight;
      BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
      BigInteger.prototype.bitCount = bnBitCount;
      BigInteger.prototype.testBit = bnTestBit;
      BigInteger.prototype.setBit = bnSetBit;
      BigInteger.prototype.clearBit = bnClearBit;
      BigInteger.prototype.flipBit = bnFlipBit;
      BigInteger.prototype.add = bnAdd;
      BigInteger.prototype.subtract = bnSubtract;
      BigInteger.prototype.multiply = bnMultiply;
      BigInteger.prototype.divide = bnDivide;
      BigInteger.prototype.remainder = bnRemainder;
      BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
      BigInteger.prototype.modPow = bnModPow;
      BigInteger.prototype.modInverse = bnModInverse;
      BigInteger.prototype.pow = bnPow;
      BigInteger.prototype.gcd = bnGCD;
      BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
      BigInteger.prototype.square = bnSquare;
      BigInteger.prototype.Barrett = Barrett;
      var rng_state;
      var rng_pool;
      var rng_pptr;
      function rng_seed_int(x) {
        rng_pool[rng_pptr++] ^= x & 255;
        rng_pool[rng_pptr++] ^= x >> 8 & 255;
        rng_pool[rng_pptr++] ^= x >> 16 & 255;
        rng_pool[rng_pptr++] ^= x >> 24 & 255;
        if (rng_pptr >= rng_psize) rng_pptr -= rng_psize;
      }
      function rng_seed_time() {
        rng_seed_int((/* @__PURE__ */ new Date()).getTime());
      }
      if (rng_pool == null) {
        rng_pool = new Array();
        rng_pptr = 0;
        var t;
        if (typeof window !== "undefined" && window.crypto) {
          if (window.crypto.getRandomValues) {
            var ua = new Uint8Array(32);
            window.crypto.getRandomValues(ua);
            for (t = 0; t < 32; ++t)
              rng_pool[rng_pptr++] = ua[t];
          } else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
            var z = window.crypto.random(32);
            for (t = 0; t < z.length; ++t)
              rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
          }
        }
        while (rng_pptr < rng_psize) {
          t = Math.floor(65536 * Math.random());
          rng_pool[rng_pptr++] = t >>> 8;
          rng_pool[rng_pptr++] = t & 255;
        }
        rng_pptr = 0;
        rng_seed_time();
      }
      function rng_get_byte() {
        if (rng_state == null) {
          rng_seed_time();
          rng_state = prng_newstate();
          rng_state.init(rng_pool);
          for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
            rng_pool[rng_pptr] = 0;
          rng_pptr = 0;
        }
        return rng_state.next();
      }
      function rng_get_bytes(ba) {
        var i;
        for (i = 0; i < ba.length; ++i) ba[i] = rng_get_byte();
      }
      function SecureRandom2() {
      }
      SecureRandom2.prototype.nextBytes = rng_get_bytes;
      function Arcfour() {
        this.i = 0;
        this.j = 0;
        this.S = new Array();
      }
      function ARC4init(key2) {
        var i, j, t2;
        for (i = 0; i < 256; ++i)
          this.S[i] = i;
        j = 0;
        for (i = 0; i < 256; ++i) {
          j = j + this.S[i] + key2[i % key2.length] & 255;
          t2 = this.S[i];
          this.S[i] = this.S[j];
          this.S[j] = t2;
        }
        this.i = 0;
        this.j = 0;
      }
      function ARC4next() {
        var t2;
        this.i = this.i + 1 & 255;
        this.j = this.j + this.S[this.i] & 255;
        t2 = this.S[this.i];
        this.S[this.i] = this.S[this.j];
        this.S[this.j] = t2;
        return this.S[t2 + this.S[this.i] & 255];
      }
      Arcfour.prototype.init = ARC4init;
      Arcfour.prototype.next = ARC4next;
      function prng_newstate() {
        return new Arcfour();
      }
      var rng_psize = 256;
      BigInteger.SecureRandom = SecureRandom2;
      BigInteger.BigInteger = BigInteger;
      {
        module.exports = BigInteger;
      }
    }).call(jsbn);
  })(jsbn$1);
  return jsbn$1.exports;
}
var ec;
var hasRequiredEc;
function requireEc() {
  if (hasRequiredEc) return ec;
  hasRequiredEc = 1;
  var BigInteger = requireJsbn().BigInteger;
  var Barrett = BigInteger.prototype.Barrett;
  function ECFieldElementFp(q2, x) {
    this.x = x;
    this.q = q2;
  }
  function feFpEquals(other) {
    if (other == this) return true;
    return this.q.equals(other.q) && this.x.equals(other.x);
  }
  function feFpToBigInteger() {
    return this.x;
  }
  function feFpNegate() {
    return new ECFieldElementFp(this.q, this.x.negate().mod(this.q));
  }
  function feFpAdd(b) {
    return new ECFieldElementFp(this.q, this.x.add(b.toBigInteger()).mod(this.q));
  }
  function feFpSubtract(b) {
    return new ECFieldElementFp(this.q, this.x.subtract(b.toBigInteger()).mod(this.q));
  }
  function feFpMultiply(b) {
    return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger()).mod(this.q));
  }
  function feFpSquare() {
    return new ECFieldElementFp(this.q, this.x.square().mod(this.q));
  }
  function feFpDivide(b) {
    return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger().modInverse(this.q)).mod(this.q));
  }
  ECFieldElementFp.prototype.equals = feFpEquals;
  ECFieldElementFp.prototype.toBigInteger = feFpToBigInteger;
  ECFieldElementFp.prototype.negate = feFpNegate;
  ECFieldElementFp.prototype.add = feFpAdd;
  ECFieldElementFp.prototype.subtract = feFpSubtract;
  ECFieldElementFp.prototype.multiply = feFpMultiply;
  ECFieldElementFp.prototype.square = feFpSquare;
  ECFieldElementFp.prototype.divide = feFpDivide;
  function ECPointFp(curve, x, y, z) {
    this.curve = curve;
    this.x = x;
    this.y = y;
    if (z == null) {
      this.z = BigInteger.ONE;
    } else {
      this.z = z;
    }
    this.zinv = null;
  }
  function pointFpGetX() {
    if (this.zinv == null) {
      this.zinv = this.z.modInverse(this.curve.q);
    }
    var r = this.x.toBigInteger().multiply(this.zinv);
    this.curve.reduce(r);
    return this.curve.fromBigInteger(r);
  }
  function pointFpGetY() {
    if (this.zinv == null) {
      this.zinv = this.z.modInverse(this.curve.q);
    }
    var r = this.y.toBigInteger().multiply(this.zinv);
    this.curve.reduce(r);
    return this.curve.fromBigInteger(r);
  }
  function pointFpEquals(other) {
    if (other == this) return true;
    if (this.isInfinity()) return other.isInfinity();
    if (other.isInfinity()) return this.isInfinity();
    var u, v;
    u = other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.q);
    if (!u.equals(BigInteger.ZERO)) return false;
    v = other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.q);
    return v.equals(BigInteger.ZERO);
  }
  function pointFpIsInfinity() {
    if (this.x == null && this.y == null) return true;
    return this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO);
  }
  function pointFpNegate() {
    return new ECPointFp(this.curve, this.x, this.y.negate(), this.z);
  }
  function pointFpAdd(b) {
    if (this.isInfinity()) return b;
    if (b.isInfinity()) return this;
    var u = b.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(b.z)).mod(this.curve.q);
    var v = b.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(b.z)).mod(this.curve.q);
    if (BigInteger.ZERO.equals(v)) {
      if (BigInteger.ZERO.equals(u)) {
        return this.twice();
      }
      return this.curve.getInfinity();
    }
    var THREE = new BigInteger("3");
    var x1 = this.x.toBigInteger();
    var y1 = this.y.toBigInteger();
    b.x.toBigInteger();
    b.y.toBigInteger();
    var v2 = v.square();
    var v3 = v2.multiply(v);
    var x1v2 = x1.multiply(v2);
    var zu2 = u.square().multiply(this.z);
    var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.q);
    var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.q);
    var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.q);
    return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
  }
  function pointFpTwice() {
    if (this.isInfinity()) return this;
    if (this.y.toBigInteger().signum() == 0) return this.curve.getInfinity();
    var THREE = new BigInteger("3");
    var x1 = this.x.toBigInteger();
    var y1 = this.y.toBigInteger();
    var y1z1 = y1.multiply(this.z);
    var y1sqz1 = y1z1.multiply(y1).mod(this.curve.q);
    var a = this.curve.a.toBigInteger();
    var w = x1.square().multiply(THREE);
    if (!BigInteger.ZERO.equals(a)) {
      w = w.add(this.z.square().multiply(a));
    }
    w = w.mod(this.curve.q);
    var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.q);
    var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.square().multiply(w)).mod(this.curve.q);
    var z3 = y1z1.square().multiply(y1z1).shiftLeft(3).mod(this.curve.q);
    return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
  }
  function pointFpMultiply(k) {
    if (this.isInfinity()) return this;
    if (k.signum() == 0) return this.curve.getInfinity();
    var e = k;
    var h = e.multiply(new BigInteger("3"));
    var neg = this.negate();
    var R = this;
    var i;
    for (i = h.bitLength() - 2; i > 0; --i) {
      R = R.twice();
      var hBit = h.testBit(i);
      var eBit = e.testBit(i);
      if (hBit != eBit) {
        R = R.add(hBit ? this : neg);
      }
    }
    return R;
  }
  function pointFpMultiplyTwo(j, x, k) {
    var i;
    if (j.bitLength() > k.bitLength())
      i = j.bitLength() - 1;
    else
      i = k.bitLength() - 1;
    var R = this.curve.getInfinity();
    var both = this.add(x);
    while (i >= 0) {
      R = R.twice();
      if (j.testBit(i)) {
        if (k.testBit(i)) {
          R = R.add(both);
        } else {
          R = R.add(this);
        }
      } else {
        if (k.testBit(i)) {
          R = R.add(x);
        }
      }
      --i;
    }
    return R;
  }
  ECPointFp.prototype.getX = pointFpGetX;
  ECPointFp.prototype.getY = pointFpGetY;
  ECPointFp.prototype.equals = pointFpEquals;
  ECPointFp.prototype.isInfinity = pointFpIsInfinity;
  ECPointFp.prototype.negate = pointFpNegate;
  ECPointFp.prototype.add = pointFpAdd;
  ECPointFp.prototype.twice = pointFpTwice;
  ECPointFp.prototype.multiply = pointFpMultiply;
  ECPointFp.prototype.multiplyTwo = pointFpMultiplyTwo;
  function ECCurveFp(q2, a, b) {
    this.q = q2;
    this.a = this.fromBigInteger(a);
    this.b = this.fromBigInteger(b);
    this.infinity = new ECPointFp(this, null, null);
    this.reducer = new Barrett(this.q);
  }
  function curveFpGetQ() {
    return this.q;
  }
  function curveFpGetA() {
    return this.a;
  }
  function curveFpGetB() {
    return this.b;
  }
  function curveFpEquals(other) {
    if (other == this) return true;
    return this.q.equals(other.q) && this.a.equals(other.a) && this.b.equals(other.b);
  }
  function curveFpGetInfinity() {
    return this.infinity;
  }
  function curveFpFromBigInteger(x) {
    return new ECFieldElementFp(this.q, x);
  }
  function curveReduce(x) {
    this.reducer.reduce(x);
  }
  function curveFpEncodePointHex(p) {
    if (p.isInfinity()) return "00";
    var xHex = p.getX().toBigInteger().toString(16);
    var yHex = p.getY().toBigInteger().toString(16);
    var oLen = this.getQ().toString(16).length;
    if (oLen % 2 != 0) oLen++;
    while (xHex.length < oLen) {
      xHex = "0" + xHex;
    }
    while (yHex.length < oLen) {
      yHex = "0" + yHex;
    }
    return "04" + xHex + yHex;
  }
  ECCurveFp.prototype.getQ = curveFpGetQ;
  ECCurveFp.prototype.getA = curveFpGetA;
  ECCurveFp.prototype.getB = curveFpGetB;
  ECCurveFp.prototype.equals = curveFpEquals;
  ECCurveFp.prototype.getInfinity = curveFpGetInfinity;
  ECCurveFp.prototype.fromBigInteger = curveFpFromBigInteger;
  ECCurveFp.prototype.reduce = curveReduce;
  ECCurveFp.prototype.encodePointHex = curveFpEncodePointHex;
  ECCurveFp.prototype.decodePointHex = function(s) {
    var yIsEven;
    switch (parseInt(s.substr(0, 2), 16)) {
      // first byte
      case 0:
        return this.infinity;
      case 2:
        yIsEven = false;
      case 3:
        if (yIsEven == void 0) yIsEven = true;
        var len = s.length - 2;
        var xHex = s.substr(2, len);
        var x = this.fromBigInteger(new BigInteger(xHex, 16));
        var alpha = x.multiply(x.square().add(this.getA())).add(this.getB());
        var beta = alpha.sqrt();
        if (beta == null) throw "Invalid point compression";
        var betaValue = beta.toBigInteger();
        if (betaValue.testBit(0) != yIsEven) {
          beta = this.fromBigInteger(this.getQ().subtract(betaValue));
        }
        return new ECPointFp(this, x, beta);
      case 4:
      case 6:
      case 7:
        var len = (s.length - 2) / 2;
        var xHex = s.substr(2, len);
        var yHex = s.substr(len + 2, len);
        return new ECPointFp(
          this,
          this.fromBigInteger(new BigInteger(xHex, 16)),
          this.fromBigInteger(new BigInteger(yHex, 16))
        );
      default:
        return null;
    }
  };
  ECCurveFp.prototype.encodeCompressedPointHex = function(p) {
    if (p.isInfinity()) return "00";
    var xHex = p.getX().toBigInteger().toString(16);
    var oLen = this.getQ().toString(16).length;
    if (oLen % 2 != 0) oLen++;
    while (xHex.length < oLen)
      xHex = "0" + xHex;
    var yPrefix;
    if (p.getY().toBigInteger().isEven()) yPrefix = "02";
    else yPrefix = "03";
    return yPrefix + xHex;
  };
  ECFieldElementFp.prototype.getR = function() {
    if (this.r != void 0) return this.r;
    this.r = null;
    var bitLength = this.q.bitLength();
    if (bitLength > 128) {
      var firstWord = this.q.shiftRight(bitLength - 64);
      if (firstWord.intValue() == -1) {
        this.r = BigInteger.ONE.shiftLeft(bitLength).subtract(this.q);
      }
    }
    return this.r;
  };
  ECFieldElementFp.prototype.modMult = function(x1, x2) {
    return this.modReduce(x1.multiply(x2));
  };
  ECFieldElementFp.prototype.modReduce = function(x) {
    if (this.getR() != null) {
      var qLen = q.bitLength();
      while (x.bitLength() > qLen + 1) {
        var u = x.shiftRight(qLen);
        var v = x.subtract(u.shiftLeft(qLen));
        if (!this.getR().equals(BigInteger.ONE)) {
          u = u.multiply(this.getR());
        }
        x = u.add(v);
      }
      while (x.compareTo(q) >= 0) {
        x = x.subtract(q);
      }
    } else {
      x = x.mod(q);
    }
    return x;
  };
  ECFieldElementFp.prototype.sqrt = function() {
    if (!this.q.testBit(0)) throw "unsupported";
    if (this.q.testBit(1)) {
      var z = new ECFieldElementFp(this.q, this.x.modPow(this.q.shiftRight(2).add(BigInteger.ONE), this.q));
      return z.square().equals(this) ? z : null;
    }
    var qMinusOne = this.q.subtract(BigInteger.ONE);
    var legendreExponent = qMinusOne.shiftRight(1);
    if (!this.x.modPow(legendreExponent, this.q).equals(BigInteger.ONE)) {
      return null;
    }
    var u = qMinusOne.shiftRight(2);
    var k = u.shiftLeft(1).add(BigInteger.ONE);
    var Q = this.x;
    var fourQ = modDouble(modDouble(Q));
    var U, V;
    do {
      var P;
      do {
        P = new BigInteger(this.q.bitLength(), new SecureRandom());
      } while (P.compareTo(this.q) >= 0 || !P.multiply(P).subtract(fourQ).modPow(legendreExponent, this.q).equals(qMinusOne));
      var result = this.lucasSequence(P, Q, k);
      U = result[0];
      V = result[1];
      if (this.modMult(V, V).equals(fourQ)) {
        if (V.testBit(0)) {
          V = V.add(q);
        }
        V = V.shiftRight(1);
        return new ECFieldElementFp(q, V);
      }
    } while (U.equals(BigInteger.ONE) || U.equals(qMinusOne));
    return null;
  };
  ECFieldElementFp.prototype.lucasSequence = function(P, Q, k) {
    var n = k.bitLength();
    var s = k.getLowestSetBit();
    var Uh = BigInteger.ONE;
    var Vl = BigInteger.TWO;
    var Vh = P;
    var Ql = BigInteger.ONE;
    var Qh = BigInteger.ONE;
    for (var j = n - 1; j >= s + 1; --j) {
      Ql = this.modMult(Ql, Qh);
      if (k.testBit(j)) {
        Qh = this.modMult(Ql, Q);
        Uh = this.modMult(Uh, Vh);
        Vl = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
        Vh = this.modReduce(Vh.multiply(Vh).subtract(Qh.shiftLeft(1)));
      } else {
        Qh = Ql;
        Uh = this.modReduce(Uh.multiply(Vl).subtract(Ql));
        Vh = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
        Vl = this.modReduce(Vl.multiply(Vl).subtract(Ql.shiftLeft(1)));
      }
    }
    Ql = this.modMult(Ql, Qh);
    Qh = this.modMult(Ql, Q);
    Uh = this.modReduce(Uh.multiply(Vl).subtract(Ql));
    Vl = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
    Ql = this.modMult(Ql, Qh);
    for (var j = 1; j <= s; ++j) {
      Uh = this.modMult(Uh, Vl);
      Vl = this.modReduce(Vl.multiply(Vl).subtract(Ql.shiftLeft(1)));
      Ql = this.modMult(Ql, Ql);
    }
    return [Uh, Vl];
  };
  var exports$1 = {
    ECCurveFp,
    ECPointFp,
    ECFieldElementFp
  };
  ec = exports$1;
  return ec;
}
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var naclFast = { exports: {} };
var hasRequiredNaclFast;
function requireNaclFast() {
  if (hasRequiredNaclFast) return naclFast.exports;
  hasRequiredNaclFast = 1;
  (function(module) {
    (function(nacl) {
      var gf = function(init) {
        var i, r = new Float64Array(16);
        if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
        return r;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x, i, h, l) {
        x[i] = h >> 24 & 255;
        x[i + 1] = h >> 16 & 255;
        x[i + 2] = h >> 8 & 255;
        x[i + 3] = h & 255;
        x[i + 4] = l >> 24 & 255;
        x[i + 5] = l >> 16 & 255;
        x[i + 6] = l >> 8 & 255;
        x[i + 7] = l & 255;
      }
      function vn(x, xi, y, yi, n) {
        var i, d = 0;
        for (i = 0; i < n; i++) d |= x[xi + i] ^ y[yi + i];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x, xi, y, yi) {
        return vn(x, xi, y, yi, 16);
      }
      function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
      }
      function core_salsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x1 >>> 0 & 255;
        o[5] = x1 >>> 8 & 255;
        o[6] = x1 >>> 16 & 255;
        o[7] = x1 >>> 24 & 255;
        o[8] = x2 >>> 0 & 255;
        o[9] = x2 >>> 8 & 255;
        o[10] = x2 >>> 16 & 255;
        o[11] = x2 >>> 24 & 255;
        o[12] = x3 >>> 0 & 255;
        o[13] = x3 >>> 8 & 255;
        o[14] = x3 >>> 16 & 255;
        o[15] = x3 >>> 24 & 255;
        o[16] = x4 >>> 0 & 255;
        o[17] = x4 >>> 8 & 255;
        o[18] = x4 >>> 16 & 255;
        o[19] = x4 >>> 24 & 255;
        o[20] = x5 >>> 0 & 255;
        o[21] = x5 >>> 8 & 255;
        o[22] = x5 >>> 16 & 255;
        o[23] = x5 >>> 24 & 255;
        o[24] = x6 >>> 0 & 255;
        o[25] = x6 >>> 8 & 255;
        o[26] = x6 >>> 16 & 255;
        o[27] = x6 >>> 24 & 255;
        o[28] = x7 >>> 0 & 255;
        o[29] = x7 >>> 8 & 255;
        o[30] = x7 >>> 16 & 255;
        o[31] = x7 >>> 24 & 255;
        o[32] = x8 >>> 0 & 255;
        o[33] = x8 >>> 8 & 255;
        o[34] = x8 >>> 16 & 255;
        o[35] = x8 >>> 24 & 255;
        o[36] = x9 >>> 0 & 255;
        o[37] = x9 >>> 8 & 255;
        o[38] = x9 >>> 16 & 255;
        o[39] = x9 >>> 24 & 255;
        o[40] = x10 >>> 0 & 255;
        o[41] = x10 >>> 8 & 255;
        o[42] = x10 >>> 16 & 255;
        o[43] = x10 >>> 24 & 255;
        o[44] = x11 >>> 0 & 255;
        o[45] = x11 >>> 8 & 255;
        o[46] = x11 >>> 16 & 255;
        o[47] = x11 >>> 24 & 255;
        o[48] = x12 >>> 0 & 255;
        o[49] = x12 >>> 8 & 255;
        o[50] = x12 >>> 16 & 255;
        o[51] = x12 >>> 24 & 255;
        o[52] = x13 >>> 0 & 255;
        o[53] = x13 >>> 8 & 255;
        o[54] = x13 >>> 16 & 255;
        o[55] = x13 >>> 24 & 255;
        o[56] = x14 >>> 0 & 255;
        o[57] = x14 >>> 8 & 255;
        o[58] = x14 >>> 16 & 255;
        o[59] = x14 >>> 24 & 255;
        o[60] = x15 >>> 0 & 255;
        o[61] = x15 >>> 8 & 255;
        o[62] = x15 >>> 16 & 255;
        o[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x5 >>> 0 & 255;
        o[5] = x5 >>> 8 & 255;
        o[6] = x5 >>> 16 & 255;
        o[7] = x5 >>> 24 & 255;
        o[8] = x10 >>> 0 & 255;
        o[9] = x10 >>> 8 & 255;
        o[10] = x10 >>> 16 & 255;
        o[11] = x10 >>> 24 & 255;
        o[12] = x15 >>> 0 & 255;
        o[13] = x15 >>> 8 & 255;
        o[14] = x15 >>> 16 & 255;
        o[15] = x15 >>> 24 & 255;
        o[16] = x6 >>> 0 & 255;
        o[17] = x6 >>> 8 & 255;
        o[18] = x6 >>> 16 & 255;
        o[19] = x6 >>> 24 & 255;
        o[20] = x7 >>> 0 & 255;
        o[21] = x7 >>> 8 & 255;
        o[22] = x7 >>> 16 & 255;
        o[23] = x7 >>> 24 & 255;
        o[24] = x8 >>> 0 & 255;
        o[25] = x8 >>> 8 & 255;
        o[26] = x8 >>> 16 & 255;
        o[27] = x8 >>> 24 & 255;
        o[28] = x9 >>> 0 & 255;
        o[29] = x9 >>> 8 & 255;
        o[30] = x9 >>> 16 & 255;
        o[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
      }
      function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++) z[i] = 0;
        for (i = 0; i < 8; i++) z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++) c[cpos + i] = m[mpos + i] ^ x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++) c[cpos + i] = m[mpos + i] ^ x[i];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++) z[i] = 0;
        for (i = 0; i < 8; i++) z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++) c[cpos + i] = x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++) c[cpos + i] = x[i];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++) sn[i] = n[i + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
      }
      function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++) sn[i] = n[i + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
      }
      var poly1305 = function(key2) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key2[0] & 255 | (key2[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key2[2] & 255 | (key2[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key2[4] & 255 | (key2[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key2[6] & 255 | (key2[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key2[8] & 255 | (key2[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key2[10] & 255 | (key2[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key2[12] & 255 | (key2[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key2[14] & 255 | (key2[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key2[16] & 255 | (key2[17] & 255) << 8;
        this.pad[1] = key2[18] & 255 | (key2[19] & 255) << 8;
        this.pad[2] = key2[20] & 255 | (key2[21] & 255) << 8;
        this.pad[3] = key2[22] & 255 | (key2[23] & 255) << 8;
        this.pad[4] = key2[24] & 255 | (key2[25] & 255) << 8;
        this.pad[5] = key2[26] & 255 | (key2[27] & 255) << 8;
        this.pad[6] = key2[28] & 255 | (key2[29] & 255) << 8;
        this.pad[7] = key2[30] & 255 | (key2[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g = new Uint16Array(10);
        var c, mask, f, i;
        if (this.leftover) {
          i = this.leftover;
          this.buffer[i++] = 1;
          for (; i < 16; i++) this.buffer[i] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this.h[i] += c;
          c = this.h[i] >>> 13;
          this.h[i] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g[i] = this.h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++) g[i] &= mask;
        mask = ~mask;
        for (i = 0; i < 10; i++) this.h[i] = this.h[i] & mask | g[i];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 65535;
        for (i = 1; i < 8; i++) {
          f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
          this.h[i] = f & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m, mpos, bytes) {
        var i, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i = 0; i < want; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i = 0; i < bytes; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
        var s = new poly1305(k);
        s.update(m, mpos, n);
        s.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
        var x = new Uint8Array(16);
        crypto_onetimeauth(x, 0, m, mpos, n, k);
        return crypto_verify_16(h, hpos, x, 0);
      }
      function crypto_secretbox(c, m, d, n, k) {
        var i;
        if (d < 32) return -1;
        crypto_stream_xor(c, 0, m, 0, d, n, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i = 0; i < 16; i++) c[i] = 0;
        return 0;
      }
      function crypto_secretbox_open(m, c, d, n, k) {
        var i;
        var x = new Uint8Array(32);
        if (d < 32) return -1;
        crypto_stream(x, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;
        crypto_stream_xor(m, 0, c, 0, d, n, k);
        for (i = 0; i < 32; i++) m[i] = 0;
        return 0;
      }
      function set25519(r, a) {
        var i;
        for (i = 0; i < 16; i++) r[i] = a[i] | 0;
      }
      function car25519(o) {
        var i, v, c = 1;
        for (i = 0; i < 16; i++) {
          v = o[i] + c + 65535;
          c = Math.floor(v / 65536);
          o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q2, b) {
        var t, c = ~(b - 1);
        for (var i = 0; i < 16; i++) {
          t = c & (p[i] ^ q2[i]);
          p[i] ^= t;
          q2[i] ^= t;
        }
      }
      function pack25519(o, n) {
        var i, j, b;
        var m = gf(), t = gf();
        for (i = 0; i < 16; i++) t[i] = n[i];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; j++) {
          m[0] = t[0] - 65517;
          for (i = 1; i < 15; i++) {
            m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
            m[i - 1] &= 65535;
          }
          m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
          b = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t, m, 1 - b);
        }
        for (i = 0; i < 16; i++) {
          o[2 * i] = t[i] & 255;
          o[2 * i + 1] = t[i] >> 8;
        }
      }
      function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      function unpack25519(o, n) {
        var i;
        for (i = 0; i < 16; i++) o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o[15] &= 32767;
      }
      function A(o, a, b) {
        for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
      }
      function Z(o, a, b) {
        for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
      }
      function M(o, a, b) {
        var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a[0];
        t0 += v * b0;
        t1 += v * b1;
        t2 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a[1];
        t1 += v * b0;
        t2 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a[2];
        t2 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t22 += v * b15;
        v = a[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t22 += v * b14;
        t23 += v * b15;
        v = a[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t22 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t22 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t22 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t22 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t22 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t22 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t22 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
      }
      function S(o, a) {
        M(o, a, a);
      }
      function inv25519(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++) c[a] = i[a];
        for (a = 253; a >= 0; a--) {
          S(c, c);
          if (a !== 2 && a !== 4) M(c, c, i);
        }
        for (a = 0; a < 16; a++) o[a] = c[a];
      }
      function pow2523(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++) c[a] = i[a];
        for (a = 250; a >= 0; a--) {
          S(c, c);
          if (a !== 1) M(c, c, i);
        }
        for (a = 0; a < 16; a++) o[a] = c[a];
      }
      function crypto_scalarmult(q2, n, p) {
        var z = new Uint8Array(32);
        var x = new Float64Array(80), r, i;
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
        for (i = 0; i < 31; i++) z[i] = n[i];
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x, p);
        for (i = 0; i < 16; i++) {
          b[i] = x[i];
          d[i] = a[i] = c[i] = 0;
        }
        a[0] = d[0] = 1;
        for (i = 254; i >= 0; --i) {
          r = z[i >>> 3] >>> (i & 7) & 1;
          sel25519(a, b, r);
          sel25519(c, d, r);
          A(e, a, c);
          Z(a, a, c);
          A(c, b, d);
          Z(b, b, d);
          S(d, e);
          S(f, a);
          M(a, c, a);
          M(c, b, e);
          A(e, a, c);
          Z(a, a, c);
          S(b, a);
          Z(c, d, f);
          M(a, c, _121665);
          A(a, a, d);
          M(c, c, a);
          M(a, d, f);
          M(d, b, x);
          S(b, e);
          sel25519(a, b, r);
          sel25519(c, d, r);
        }
        for (i = 0; i < 16; i++) {
          x[i + 16] = a[i];
          x[i + 32] = c[i];
          x[i + 48] = b[i];
          x[i + 64] = d[i];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q2, x16);
        return 0;
      }
      function crypto_scalarmult_base(q2, n) {
        return crypto_scalarmult(q2, n, _9);
      }
      function crypto_box_keypair(y, x) {
        randombytes(x, 32);
        return crypto_scalarmult_base(y, x);
      }
      function crypto_box_beforenm(k, y, x) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_afternm(c, m, d, n, k);
      }
      function crypto_box_open(m, c, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_open_afternm(m, c, d, n, k);
      }
      var K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n >= 128) {
          for (i = 0; i < 16; i++) {
            j = 8 * i + pos;
            wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
            wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
          }
          for (i = 0; i < 80; i++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = K[i * 2];
            l = K[i * 2 + 1];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = wh[i % 16];
            l = wl[i % 16];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a & 65535 | b << 16;
            h = th;
            l = tl;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a & 65535 | b << 16;
            h = bh3;
            l = bl3;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = th;
            l = tl;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a & 65535 | b << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h = wh[j];
                l = wl[j];
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = wh[(j + 9) % 16];
                l = wl[(j + 9) % 16];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 1) % 16];
                tl = wl[(j + 1) % 16];
                h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 14) % 16];
                tl = wl[(j + 14) % 16];
                h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                wh[j] = c & 65535 | d << 16;
                wl[j] = a & 65535 | b << 16;
              }
            }
          }
          h = ah0;
          l = al0;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[0];
          l = hl[0];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl[0] = al0 = a & 65535 | b << 16;
          h = ah1;
          l = al1;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[1];
          l = hl[1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl[1] = al1 = a & 65535 | b << 16;
          h = ah2;
          l = al2;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[2];
          l = hl[2];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl[2] = al2 = a & 65535 | b << 16;
          h = ah3;
          l = al3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[3];
          l = hl[3];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl[3] = al3 = a & 65535 | b << 16;
          h = ah4;
          l = al4;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[4];
          l = hl[4];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl[4] = al4 = a & 65535 | b << 16;
          h = ah5;
          l = al5;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[5];
          l = hl[5];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl[5] = al5 = a & 65535 | b << 16;
          h = ah6;
          l = al6;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[6];
          l = hl[6];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl[6] = al6 = a & 65535 | b << 16;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[7];
          l = hl[7];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl[7] = al7 = a & 65535 | b << 16;
          pos += 128;
          n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m, n);
        n %= 128;
        for (i = 0; i < n; i++) x[i] = m[b - n + i];
        x[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x[n - 9] = 0;
        ts64(x, n - 8, b / 536870912 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x, n);
        for (i = 0; i < 8; i++) ts64(out, 8 * i, hh[i], hl[i]);
        return 0;
      }
      function add(p, q2) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q2[1], q2[0]);
        M(a, a, t);
        A(b, p[0], p[1]);
        A(t, q2[0], q2[1]);
        M(b, b, t);
        M(c, p[3], q2[3]);
        M(c, c, D2);
        M(d, p[2], q2[2]);
        A(d, d, d);
        Z(e, b, a);
        Z(f, d, c);
        A(g, d, c);
        A(h, b, a);
        M(p[0], e, f);
        M(p[1], h, g);
        M(p[2], g, f);
        M(p[3], e, h);
      }
      function cswap(p, q2, b) {
        var i;
        for (i = 0; i < 4; i++) {
          sel25519(p[i], q2[i], b);
        }
      }
      function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M(tx, p[0], zi);
        M(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p, q2, s) {
        var b, i;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i = 255; i >= 0; --i) {
          b = s[i / 8 | 0] >> (i & 7) & 1;
          cswap(p, q2, b);
          add(q2, p);
          add(p, p);
          cswap(p, q2, b);
        }
      }
      function scalarbase(p, s) {
        var q2 = [gf(), gf(), gf(), gf()];
        set25519(q2[0], X);
        set25519(q2[1], Y);
        set25519(q2[2], gf1);
        M(q2[3], X, Y);
        scalarmult(p, q2, s);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()];
        var i;
        if (!seeded) randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for (i = 0; i < 32; i++) sk[i + 32] = pk[i];
        return 0;
      }
      var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r, x) {
        var carry, i, j, k;
        for (i = 63; i >= 32; --i) {
          carry = 0;
          for (j = i - 32, k = i - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i] * L[j - (i - 32)];
            carry = x[j] + 128 >> 8;
            x[j] -= carry * 256;
          }
          x[j] += carry;
          x[i] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x[j] += carry - (x[31] >> 4) * L[j];
          carry = x[j] >> 8;
          x[j] &= 255;
        }
        for (j = 0; j < 32; j++) x[j] -= carry * L[j];
        for (i = 0; i < 32; i++) {
          x[i + 1] += x[i] >> 8;
          r[i] = x[i] & 255;
        }
      }
      function reduce(r) {
        var x = new Float64Array(64), i;
        for (i = 0; i < 64; i++) x[i] = r[i];
        for (i = 0; i < 64; i++) r[i] = 0;
        modL(r, x);
      }
      function crypto_sign(sm, m, n, sk) {
        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
        var i, j, x = new Float64Array(64);
        var p = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i = 0; i < n; i++) sm[64 + i] = m[i];
        for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for (i = 32; i < 64; i++) sm[i] = sk[i];
        crypto_hash(h, sm, n + 64);
        reduce(h);
        for (i = 0; i < 64; i++) x[i] = 0;
        for (i = 0; i < 32; i++) x[i] = r[i];
        for (i = 0; i < 32; i++) {
          for (j = 0; j < 32; j++) {
            x[i + j] += h[i] * d[j];
          }
        }
        modL(sm.subarray(32), x);
        return smlen;
      }
      function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r[0], t, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) return -1;
        if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return 0;
      }
      function crypto_sign_open(m, sm, n, pk) {
        var i, mlen;
        var t = new Uint8Array(32), h = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()], q2 = [gf(), gf(), gf(), gf()];
        mlen = -1;
        if (n < 64) return -1;
        if (unpackneg(q2, pk)) return -1;
        for (i = 0; i < n; i++) m[i] = sm[i];
        for (i = 0; i < 32; i++) m[i + 32] = pk[i];
        crypto_hash(h, m, n);
        reduce(h);
        scalarmult(p, q2, h);
        scalarbase(q2, sm.subarray(32));
        add(p, q2);
        pack(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i = 0; i < n; i++) m[i] = 0;
          return -1;
        }
        for (i = 0; i < n; i++) m[i] = sm[i + 64];
        mlen = n;
        return mlen;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES
      };
      function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES) throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        var t, i;
        for (i = 0; i < arguments.length; i++) {
          if ((t = Object.prototype.toString.call(arguments[i])) !== "[object Uint8Array]")
            throw new TypeError("unexpected type " + t + ", use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i = 0; i < arr.length; i++) arr[i] = 0;
      }
      if (!nacl.util) {
        nacl.util = {};
        nacl.util.decodeUTF8 = nacl.util.encodeUTF8 = nacl.util.encodeBase64 = nacl.util.decodeBase64 = function() {
          throw new Error("nacl.util moved into separate package: https://github.com/dchest/tweetnacl-util-js");
        };
      }
      nacl.randomBytes = function(n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
      };
      nacl.secretbox = function(msg, nonce, key2) {
        checkArrayTypes(msg, nonce, key2);
        checkLengths(key2, nonce);
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m.length);
        for (var i = 0; i < msg.length; i++) m[i + crypto_secretbox_ZEROBYTES] = msg[i];
        crypto_secretbox(c, m, m.length, nonce, key2);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl.secretbox.open = function(box, nonce, key2) {
        checkArrayTypes(box, nonce, key2);
        checkLengths(key2, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m = new Uint8Array(c.length);
        for (var i = 0; i < box.length; i++) c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
        if (c.length < 32) return false;
        if (crypto_secretbox_open(m, c, c.length, nonce, key2) !== 0) return false;
        return m.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl.scalarMult = function(n, p) {
        checkArrayTypes(n, p);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES) throw new Error("bad p size");
        var q2 = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q2, n, p);
        return q2;
      };
      nacl.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        var q2 = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q2, n);
        return q2;
      };
      nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox(msg, nonce, k);
      };
      nacl.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
      };
      nacl.box.after = nacl.secretbox;
      nacl.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox.open(msg, nonce, k);
      };
      nacl.box.open.after = nacl.secretbox.open;
      nacl.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl.box.nonceLength = crypto_box_NONCEBYTES;
      nacl.box.overheadLength = nacl.secretbox.overheadLength;
      nacl.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl.sign.open = function(signedMsg, publicKey) {
        if (arguments.length !== 2)
          throw new Error("nacl.sign.open accepts 2 arguments; did you mean to use nacl.sign.detached.verify?");
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0) return null;
        var m = new Uint8Array(mlen);
        for (var i = 0; i < m.length; i++) m[i] = tmp[i];
        return m;
      };
      nacl.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
        return sig;
      };
      nacl.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i;
        for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
        for (i = 0; i < msg.length; i++) sm[i + crypto_sign_BYTES] = msg[i];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
      };
      nacl.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32 + i];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i = 0; i < 32; i++) sk[i] = seed[i];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl.sign.signatureLength = crypto_sign_BYTES;
      nacl.hash = function(msg) {
        checkArrayTypes(msg);
        var h = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h, msg, msg.length);
        return h;
      };
      nacl.hash.hashLength = crypto_hash_BYTES;
      nacl.verify = function(x, y) {
        checkArrayTypes(x, y);
        if (x.length === 0 || y.length === 0) return false;
        if (x.length !== y.length) return false;
        return vn(x, 0, y, 0, x.length) === 0 ? true : false;
      };
      nacl.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto && crypto.getRandomValues) {
          var QUOTA = 65536;
          nacl.setPRNG(function(x, n) {
            var i, v = new Uint8Array(n);
            for (i = 0; i < n; i += QUOTA) {
              crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
            }
            for (i = 0; i < n; i++) x[i] = v[i];
            cleanup(v);
          });
        } else if (typeof commonjsRequire !== "undefined") {
          crypto = require$$0$9;
          if (crypto && crypto.randomBytes) {
            nacl.setPRNG(function(x, n) {
              var i, v = crypto.randomBytes(n);
              for (i = 0; i < n; i++) x[i] = v[i];
              cleanup(v);
            });
          }
        }
      })();
    })(module.exports ? module.exports : self.nacl = self.nacl || {});
  })(naclFast);
  return naclFast.exports;
}
var utils$3;
var hasRequiredUtils$3;
function requireUtils$3() {
  if (hasRequiredUtils$3) return utils$3;
  hasRequiredUtils$3 = 1;
  utils$3 = {
    bufferSplit,
    addRSAMissing,
    calculateDSAPublic,
    calculateED25519Public,
    calculateX25519Public,
    mpNormalize,
    mpDenormalize,
    ecNormalize,
    countZeros,
    assertCompatible,
    isCompatible,
    opensslKeyDeriv,
    opensshCipherInfo,
    publicFromPrivateECDSA,
    zeroPadToLength,
    writeBitString,
    readBitString,
    pbkdf2
  };
  var assert = requireAssert();
  var Buffer2 = requireSafer().Buffer;
  var PrivateKey = requirePrivateKey();
  var Key = requireKey();
  var crypto = require$$0$9;
  var algs2 = requireAlgs();
  var asn1 = requireLib$4();
  var ec2 = requireEc();
  var jsbn2 = requireJsbn().BigInteger;
  var nacl = requireNaclFast();
  var MAX_CLASS_DEPTH = 3;
  function isCompatible(obj, klass, needVer) {
    if (obj === null || typeof obj !== "object")
      return false;
    if (needVer === void 0)
      needVer = klass.prototype._sshpkApiVersion;
    if (obj instanceof klass && klass.prototype._sshpkApiVersion[0] == needVer[0])
      return true;
    var proto = Object.getPrototypeOf(obj);
    var depth = 0;
    while (proto.constructor.name !== klass.name) {
      proto = Object.getPrototypeOf(proto);
      if (!proto || ++depth > MAX_CLASS_DEPTH)
        return false;
    }
    if (proto.constructor.name !== klass.name)
      return false;
    var ver = proto._sshpkApiVersion;
    if (ver === void 0)
      ver = klass._oldVersionDetect(obj);
    if (ver[0] != needVer[0] || ver[1] < needVer[1])
      return false;
    return true;
  }
  function assertCompatible(obj, klass, needVer, name) {
    if (name === void 0)
      name = "object";
    assert.ok(obj, name + " must not be null");
    assert.object(obj, name + " must be an object");
    if (needVer === void 0)
      needVer = klass.prototype._sshpkApiVersion;
    if (obj instanceof klass && klass.prototype._sshpkApiVersion[0] == needVer[0])
      return;
    var proto = Object.getPrototypeOf(obj);
    var depth = 0;
    while (proto.constructor.name !== klass.name) {
      proto = Object.getPrototypeOf(proto);
      assert.ok(
        proto && ++depth <= MAX_CLASS_DEPTH,
        name + " must be a " + klass.name + " instance"
      );
    }
    assert.strictEqual(
      proto.constructor.name,
      klass.name,
      name + " must be a " + klass.name + " instance"
    );
    var ver = proto._sshpkApiVersion;
    if (ver === void 0)
      ver = klass._oldVersionDetect(obj);
    assert.ok(
      ver[0] == needVer[0] && ver[1] >= needVer[1],
      name + " must be compatible with " + klass.name + " klass version " + needVer[0] + "." + needVer[1]
    );
  }
  var CIPHER_LEN = {
    "des-ede3-cbc": { key: 24, iv: 8 },
    "aes-128-cbc": { key: 16, iv: 16 },
    "aes-256-cbc": { key: 32, iv: 16 }
  };
  var PKCS5_SALT_LEN = 8;
  function opensslKeyDeriv(cipher, salt, passphrase, count) {
    assert.buffer(salt, "salt");
    assert.buffer(passphrase, "passphrase");
    assert.number(count, "iteration count");
    var clen = CIPHER_LEN[cipher];
    assert.object(clen, "supported cipher");
    salt = salt.slice(0, PKCS5_SALT_LEN);
    var D, D_prev, bufs;
    var material = Buffer2.alloc(0);
    while (material.length < clen.key + clen.iv) {
      bufs = [];
      if (D_prev)
        bufs.push(D_prev);
      bufs.push(passphrase);
      bufs.push(salt);
      D = Buffer2.concat(bufs);
      for (var j = 0; j < count; ++j)
        D = crypto.createHash("md5").update(D).digest();
      material = Buffer2.concat([material, D]);
      D_prev = D;
    }
    return {
      key: material.slice(0, clen.key),
      iv: material.slice(clen.key, clen.key + clen.iv)
    };
  }
  function pbkdf2(hashAlg, salt, iterations, size, passphrase) {
    var hkey = Buffer2.alloc(salt.length + 4);
    salt.copy(hkey);
    var gen = 0, ts = [];
    var i = 1;
    while (gen < size) {
      var t = T(i++);
      gen += t.length;
      ts.push(t);
    }
    return Buffer2.concat(ts).slice(0, size);
    function T(I) {
      hkey.writeUInt32BE(I, hkey.length - 4);
      var hmac = crypto.createHmac(hashAlg, passphrase);
      hmac.update(hkey);
      var Ti = hmac.digest();
      var Uc = Ti;
      var c = 1;
      while (c++ < iterations) {
        hmac = crypto.createHmac(hashAlg, passphrase);
        hmac.update(Uc);
        Uc = hmac.digest();
        for (var x = 0; x < Ti.length; ++x)
          Ti[x] ^= Uc[x];
      }
      return Ti;
    }
  }
  function countZeros(buf) {
    var o = 0, obit = 8;
    while (o < buf.length) {
      var mask = 1 << obit;
      if ((buf[o] & mask) === mask)
        break;
      obit--;
      if (obit < 0) {
        o++;
        obit = 8;
      }
    }
    return o * 8 + (8 - obit) - 1;
  }
  function bufferSplit(buf, chr) {
    assert.buffer(buf);
    assert.string(chr);
    var parts = [];
    var lastPart = 0;
    var matches = 0;
    for (var i = 0; i < buf.length; ++i) {
      if (buf[i] === chr.charCodeAt(matches))
        ++matches;
      else if (buf[i] === chr.charCodeAt(0))
        matches = 1;
      else
        matches = 0;
      if (matches >= chr.length) {
        var newPart = i + 1;
        parts.push(buf.slice(lastPart, newPart - matches));
        lastPart = newPart;
        matches = 0;
      }
    }
    if (lastPart <= buf.length)
      parts.push(buf.slice(lastPart, buf.length));
    return parts;
  }
  function ecNormalize(buf, addZero) {
    assert.buffer(buf);
    if (buf[0] === 0 && buf[1] === 4) {
      if (addZero)
        return buf;
      return buf.slice(1);
    } else if (buf[0] === 4) {
      if (!addZero)
        return buf;
    } else {
      while (buf[0] === 0)
        buf = buf.slice(1);
      if (buf[0] === 2 || buf[0] === 3)
        throw new Error("Compressed elliptic curve points are not supported");
      if (buf[0] !== 4)
        throw new Error("Not a valid elliptic curve point");
      if (!addZero)
        return buf;
    }
    var b = Buffer2.alloc(buf.length + 1);
    b[0] = 0;
    buf.copy(b, 1);
    return b;
  }
  function readBitString(der, tag) {
    if (tag === void 0)
      tag = asn1.Ber.BitString;
    var buf = der.readString(tag, true);
    assert.strictEqual(buf[0], 0, "bit strings with unused bits are not supported (0x" + buf[0].toString(16) + ")");
    return buf.slice(1);
  }
  function writeBitString(der, buf, tag) {
    if (tag === void 0)
      tag = asn1.Ber.BitString;
    var b = Buffer2.alloc(buf.length + 1);
    b[0] = 0;
    buf.copy(b, 1);
    der.writeBuffer(b, tag);
  }
  function mpNormalize(buf) {
    assert.buffer(buf);
    while (buf.length > 1 && buf[0] === 0 && (buf[1] & 128) === 0)
      buf = buf.slice(1);
    if ((buf[0] & 128) === 128) {
      var b = Buffer2.alloc(buf.length + 1);
      b[0] = 0;
      buf.copy(b, 1);
      buf = b;
    }
    return buf;
  }
  function mpDenormalize(buf) {
    assert.buffer(buf);
    while (buf.length > 1 && buf[0] === 0)
      buf = buf.slice(1);
    return buf;
  }
  function zeroPadToLength(buf, len) {
    assert.buffer(buf);
    assert.number(len);
    while (buf.length > len) {
      assert.equal(buf[0], 0);
      buf = buf.slice(1);
    }
    while (buf.length < len) {
      var b = Buffer2.alloc(buf.length + 1);
      b[0] = 0;
      buf.copy(b, 1);
      buf = b;
    }
    return buf;
  }
  function bigintToMpBuf(bigint) {
    var buf = Buffer2.from(bigint.toByteArray());
    buf = mpNormalize(buf);
    return buf;
  }
  function calculateDSAPublic(g, p, x) {
    assert.buffer(g);
    assert.buffer(p);
    assert.buffer(x);
    g = new jsbn2(g);
    p = new jsbn2(p);
    x = new jsbn2(x);
    var y = g.modPow(x, p);
    var ybuf = bigintToMpBuf(y);
    return ybuf;
  }
  function calculateED25519Public(k) {
    assert.buffer(k);
    var kp = nacl.sign.keyPair.fromSeed(new Uint8Array(k));
    return Buffer2.from(kp.publicKey);
  }
  function calculateX25519Public(k) {
    assert.buffer(k);
    var kp = nacl.box.keyPair.fromSeed(new Uint8Array(k));
    return Buffer2.from(kp.publicKey);
  }
  function addRSAMissing(key2) {
    assert.object(key2);
    assertCompatible(key2, PrivateKey, [1, 1]);
    var d = new jsbn2(key2.part.d.data);
    var buf;
    if (!key2.part.dmodp) {
      var p = new jsbn2(key2.part.p.data);
      var dmodp = d.mod(p.subtract(1));
      buf = bigintToMpBuf(dmodp);
      key2.part.dmodp = { name: "dmodp", data: buf };
      key2.parts.push(key2.part.dmodp);
    }
    if (!key2.part.dmodq) {
      var q2 = new jsbn2(key2.part.q.data);
      var dmodq = d.mod(q2.subtract(1));
      buf = bigintToMpBuf(dmodq);
      key2.part.dmodq = { name: "dmodq", data: buf };
      key2.parts.push(key2.part.dmodq);
    }
  }
  function publicFromPrivateECDSA(curveName, priv) {
    assert.string(curveName, "curveName");
    assert.buffer(priv);
    var params = algs2.curves[curveName];
    var p = new jsbn2(params.p);
    var a = new jsbn2(params.a);
    var b = new jsbn2(params.b);
    var curve = new ec2.ECCurveFp(p, a, b);
    var G = curve.decodePointHex(params.G.toString("hex"));
    var d = new jsbn2(mpNormalize(priv));
    var pub = G.multiply(d);
    pub = Buffer2.from(curve.encodePointHex(pub), "hex");
    var parts = [];
    parts.push({ name: "curve", data: Buffer2.from(curveName) });
    parts.push({ name: "Q", data: pub });
    var key2 = new Key({ type: "ecdsa", curve, parts });
    return key2;
  }
  function opensshCipherInfo(cipher) {
    var inf = {};
    switch (cipher) {
      case "3des-cbc":
        inf.keySize = 24;
        inf.blockSize = 8;
        inf.opensslName = "des-ede3-cbc";
        break;
      case "blowfish-cbc":
        inf.keySize = 16;
        inf.blockSize = 8;
        inf.opensslName = "bf-cbc";
        break;
      case "aes128-cbc":
      case "aes128-ctr":
      case "aes128-gcm@openssh.com":
        inf.keySize = 16;
        inf.blockSize = 16;
        inf.opensslName = "aes-128-" + cipher.slice(7, 10);
        break;
      case "aes192-cbc":
      case "aes192-ctr":
      case "aes192-gcm@openssh.com":
        inf.keySize = 24;
        inf.blockSize = 16;
        inf.opensslName = "aes-192-" + cipher.slice(7, 10);
        break;
      case "aes256-cbc":
      case "aes256-ctr":
      case "aes256-gcm@openssh.com":
        inf.keySize = 32;
        inf.blockSize = 16;
        inf.opensslName = "aes-256-" + cipher.slice(7, 10);
        break;
      default:
        throw new Error(
          'Unsupported openssl cipher "' + cipher + '"'
        );
    }
    return inf;
  }
  return utils$3;
}
var sshBuffer;
var hasRequiredSshBuffer;
function requireSshBuffer() {
  if (hasRequiredSshBuffer) return sshBuffer;
  hasRequiredSshBuffer = 1;
  sshBuffer = SSHBuffer;
  var assert = requireAssert();
  var Buffer2 = requireSafer().Buffer;
  function SSHBuffer(opts) {
    assert.object(opts, "options");
    if (opts.buffer !== void 0)
      assert.buffer(opts.buffer, "options.buffer");
    this._size = opts.buffer ? opts.buffer.length : 1024;
    this._buffer = opts.buffer || Buffer2.alloc(this._size);
    this._offset = 0;
  }
  SSHBuffer.prototype.toBuffer = function() {
    return this._buffer.slice(0, this._offset);
  };
  SSHBuffer.prototype.atEnd = function() {
    return this._offset >= this._buffer.length;
  };
  SSHBuffer.prototype.remainder = function() {
    return this._buffer.slice(this._offset);
  };
  SSHBuffer.prototype.skip = function(n) {
    this._offset += n;
  };
  SSHBuffer.prototype.expand = function() {
    this._size *= 2;
    var buf = Buffer2.alloc(this._size);
    this._buffer.copy(buf, 0);
    this._buffer = buf;
  };
  SSHBuffer.prototype.readPart = function() {
    return { data: this.readBuffer() };
  };
  SSHBuffer.prototype.readBuffer = function() {
    var len = this._buffer.readUInt32BE(this._offset);
    this._offset += 4;
    assert.ok(
      this._offset + len <= this._buffer.length,
      "length out of bounds at +0x" + this._offset.toString(16) + " (data truncated?)"
    );
    var buf = this._buffer.slice(this._offset, this._offset + len);
    this._offset += len;
    return buf;
  };
  SSHBuffer.prototype.readString = function() {
    return this.readBuffer().toString();
  };
  SSHBuffer.prototype.readCString = function() {
    var offset = this._offset;
    while (offset < this._buffer.length && this._buffer[offset] !== 0)
      offset++;
    assert.ok(offset < this._buffer.length, "c string does not terminate");
    var str = this._buffer.slice(this._offset, offset).toString();
    this._offset = offset + 1;
    return str;
  };
  SSHBuffer.prototype.readInt = function() {
    var v = this._buffer.readUInt32BE(this._offset);
    this._offset += 4;
    return v;
  };
  SSHBuffer.prototype.readInt64 = function() {
    assert.ok(
      this._offset + 8 < this._buffer.length,
      "buffer not long enough to read Int64"
    );
    var v = this._buffer.slice(this._offset, this._offset + 8);
    this._offset += 8;
    return v;
  };
  SSHBuffer.prototype.readChar = function() {
    var v = this._buffer[this._offset++];
    return v;
  };
  SSHBuffer.prototype.writeBuffer = function(buf) {
    while (this._offset + 4 + buf.length > this._size)
      this.expand();
    this._buffer.writeUInt32BE(buf.length, this._offset);
    this._offset += 4;
    buf.copy(this._buffer, this._offset);
    this._offset += buf.length;
  };
  SSHBuffer.prototype.writeString = function(str) {
    this.writeBuffer(Buffer2.from(str, "utf8"));
  };
  SSHBuffer.prototype.writeCString = function(str) {
    while (this._offset + 1 + str.length > this._size)
      this.expand();
    this._buffer.write(str, this._offset);
    this._offset += str.length;
    this._buffer[this._offset++] = 0;
  };
  SSHBuffer.prototype.writeInt = function(v) {
    while (this._offset + 4 > this._size)
      this.expand();
    this._buffer.writeUInt32BE(v, this._offset);
    this._offset += 4;
  };
  SSHBuffer.prototype.writeInt64 = function(v) {
    assert.buffer(v, "value");
    if (v.length > 8) {
      var lead = v.slice(0, v.length - 8);
      for (var i = 0; i < lead.length; ++i) {
        assert.strictEqual(
          lead[i],
          0,
          "must fit in 64 bits of precision"
        );
      }
      v = v.slice(v.length - 8, v.length);
    }
    while (this._offset + 8 > this._size)
      this.expand();
    v.copy(this._buffer, this._offset);
    this._offset += 8;
  };
  SSHBuffer.prototype.writeChar = function(v) {
    while (this._offset + 1 > this._size)
      this.expand();
    this._buffer[this._offset++] = v;
  };
  SSHBuffer.prototype.writePart = function(p) {
    this.writeBuffer(p.data);
  };
  SSHBuffer.prototype.write = function(buf) {
    while (this._offset + buf.length > this._size)
      this.expand();
    buf.copy(this._buffer, this._offset);
    this._offset += buf.length;
  };
  return sshBuffer;
}
var signature;
var hasRequiredSignature;
function requireSignature() {
  if (hasRequiredSignature) return signature;
  hasRequiredSignature = 1;
  signature = Signature;
  var assert = requireAssert();
  var Buffer2 = requireSafer().Buffer;
  requireAlgs();
  var errs = requireErrors$1();
  var utils2 = requireUtils$3();
  var asn1 = requireLib$4();
  var SSHBuffer = requireSshBuffer();
  var InvalidAlgorithmError = errs.InvalidAlgorithmError;
  var SignatureParseError = errs.SignatureParseError;
  function Signature(opts) {
    assert.object(opts, "options");
    assert.arrayOfObject(opts.parts, "options.parts");
    assert.string(opts.type, "options.type");
    var partLookup = {};
    for (var i = 0; i < opts.parts.length; ++i) {
      var part = opts.parts[i];
      partLookup[part.name] = part;
    }
    this.type = opts.type;
    this.hashAlgorithm = opts.hashAlgo;
    this.curve = opts.curve;
    this.parts = opts.parts;
    this.part = partLookup;
  }
  Signature.prototype.toBuffer = function(format2) {
    if (format2 === void 0)
      format2 = "asn1";
    assert.string(format2, "format");
    var buf;
    var stype = "ssh-" + this.type;
    switch (this.type) {
      case "rsa":
        switch (this.hashAlgorithm) {
          case "sha256":
            stype = "rsa-sha2-256";
            break;
          case "sha512":
            stype = "rsa-sha2-512";
            break;
          case "sha1":
          case void 0:
            break;
          default:
            throw new Error("SSH signature format does not support hash algorithm " + this.hashAlgorithm);
        }
        if (format2 === "ssh") {
          buf = new SSHBuffer({});
          buf.writeString(stype);
          buf.writePart(this.part.sig);
          return buf.toBuffer();
        } else {
          return this.part.sig.data;
        }
      case "ed25519":
        if (format2 === "ssh") {
          buf = new SSHBuffer({});
          buf.writeString(stype);
          buf.writePart(this.part.sig);
          return buf.toBuffer();
        } else {
          return this.part.sig.data;
        }
      case "dsa":
      case "ecdsa":
        var r, s;
        if (format2 === "asn1") {
          var der = new asn1.BerWriter();
          der.startSequence();
          r = utils2.mpNormalize(this.part.r.data);
          s = utils2.mpNormalize(this.part.s.data);
          der.writeBuffer(r, asn1.Ber.Integer);
          der.writeBuffer(s, asn1.Ber.Integer);
          der.endSequence();
          return der.buffer;
        } else if (format2 === "ssh" && this.type === "dsa") {
          buf = new SSHBuffer({});
          buf.writeString("ssh-dss");
          r = this.part.r.data;
          if (r.length > 20 && r[0] === 0)
            r = r.slice(1);
          s = this.part.s.data;
          if (s.length > 20 && s[0] === 0)
            s = s.slice(1);
          if (this.hashAlgorithm && this.hashAlgorithm !== "sha1" || r.length + s.length !== 40) {
            throw new Error("OpenSSH only supports DSA signatures with SHA1 hash");
          }
          buf.writeBuffer(Buffer2.concat([r, s]));
          return buf.toBuffer();
        } else if (format2 === "ssh" && this.type === "ecdsa") {
          var inner = new SSHBuffer({});
          r = this.part.r.data;
          inner.writeBuffer(r);
          inner.writePart(this.part.s);
          buf = new SSHBuffer({});
          var curve;
          if (r[0] === 0)
            r = r.slice(1);
          var sz = r.length * 8;
          if (sz === 256)
            curve = "nistp256";
          else if (sz === 384)
            curve = "nistp384";
          else if (sz === 528)
            curve = "nistp521";
          buf.writeString("ecdsa-sha2-" + curve);
          buf.writeBuffer(inner.toBuffer());
          return buf.toBuffer();
        }
        throw new Error("Invalid signature format");
      default:
        throw new Error("Invalid signature data");
    }
  };
  Signature.prototype.toString = function(format2) {
    assert.optionalString(format2, "format");
    return this.toBuffer(format2).toString("base64");
  };
  Signature.parse = function(data2, type2, format2) {
    if (typeof data2 === "string")
      data2 = Buffer2.from(data2, "base64");
    assert.buffer(data2, "data");
    assert.string(format2, "format");
    assert.string(type2, "type");
    var opts = {};
    opts.type = type2.toLowerCase();
    opts.parts = [];
    try {
      assert.ok(data2.length > 0, "signature must not be empty");
      switch (opts.type) {
        case "rsa":
          return parseOneNum(data2, type2, format2, opts);
        case "ed25519":
          return parseOneNum(data2, type2, format2, opts);
        case "dsa":
        case "ecdsa":
          if (format2 === "asn1")
            return parseDSAasn1(data2, type2, format2, opts);
          else if (opts.type === "dsa")
            return parseDSA(data2, type2, format2, opts);
          else
            return parseECDSA(data2, type2, format2, opts);
        default:
          throw new InvalidAlgorithmError(type2);
      }
    } catch (e) {
      if (e instanceof InvalidAlgorithmError)
        throw e;
      throw new SignatureParseError(type2, format2, e);
    }
  };
  function parseOneNum(data2, type2, format2, opts) {
    if (format2 === "ssh") {
      try {
        var buf = new SSHBuffer({ buffer: data2 });
        var head = buf.readString();
      } catch (e) {
      }
      if (buf !== void 0) {
        var msg = "SSH signature does not match expected type (expected " + type2 + ", got " + head + ")";
        switch (head) {
          case "ssh-rsa":
            assert.strictEqual(type2, "rsa", msg);
            opts.hashAlgo = "sha1";
            break;
          case "rsa-sha2-256":
            assert.strictEqual(type2, "rsa", msg);
            opts.hashAlgo = "sha256";
            break;
          case "rsa-sha2-512":
            assert.strictEqual(type2, "rsa", msg);
            opts.hashAlgo = "sha512";
            break;
          case "ssh-ed25519":
            assert.strictEqual(type2, "ed25519", msg);
            opts.hashAlgo = "sha512";
            break;
          default:
            throw new Error("Unknown SSH signature type: " + head);
        }
        var sig = buf.readPart();
        assert.ok(buf.atEnd(), "extra trailing bytes");
        sig.name = "sig";
        opts.parts.push(sig);
        return new Signature(opts);
      }
    }
    opts.parts.push({ name: "sig", data: data2 });
    return new Signature(opts);
  }
  function parseDSAasn1(data2, type2, format2, opts) {
    var der = new asn1.BerReader(data2);
    der.readSequence();
    var r = der.readString(asn1.Ber.Integer, true);
    var s = der.readString(asn1.Ber.Integer, true);
    opts.parts.push({ name: "r", data: utils2.mpNormalize(r) });
    opts.parts.push({ name: "s", data: utils2.mpNormalize(s) });
    return new Signature(opts);
  }
  function parseDSA(data2, type2, format2, opts) {
    if (data2.length != 40) {
      var buf = new SSHBuffer({ buffer: data2 });
      var d = buf.readBuffer();
      if (d.toString("ascii") === "ssh-dss")
        d = buf.readBuffer();
      assert.ok(buf.atEnd(), "extra trailing bytes");
      assert.strictEqual(d.length, 40, "invalid inner length");
      data2 = d;
    }
    opts.parts.push({ name: "r", data: data2.slice(0, 20) });
    opts.parts.push({ name: "s", data: data2.slice(20, 40) });
    return new Signature(opts);
  }
  function parseECDSA(data2, type2, format2, opts) {
    var buf = new SSHBuffer({ buffer: data2 });
    var r, s;
    var inner = buf.readBuffer();
    var stype = inner.toString("ascii");
    if (stype.slice(0, 6) === "ecdsa-") {
      var parts = stype.split("-");
      assert.strictEqual(parts[0], "ecdsa");
      assert.strictEqual(parts[1], "sha2");
      opts.curve = parts[2];
      switch (opts.curve) {
        case "nistp256":
          opts.hashAlgo = "sha256";
          break;
        case "nistp384":
          opts.hashAlgo = "sha384";
          break;
        case "nistp521":
          opts.hashAlgo = "sha512";
          break;
        default:
          throw new Error("Unsupported ECDSA curve: " + opts.curve);
      }
      inner = buf.readBuffer();
      assert.ok(buf.atEnd(), "extra trailing bytes on outer");
      buf = new SSHBuffer({ buffer: inner });
      r = buf.readPart();
    } else {
      r = { data: inner };
    }
    s = buf.readPart();
    assert.ok(buf.atEnd(), "extra trailing bytes");
    r.name = "r";
    s.name = "s";
    opts.parts.push(r);
    opts.parts.push(s);
    return new Signature(opts);
  }
  Signature.isSignature = function(obj, ver) {
    return utils2.isCompatible(obj, Signature, ver);
  };
  Signature.prototype._sshpkApiVersion = [2, 1];
  Signature._oldVersionDetect = function(obj) {
    assert.func(obj.toBuffer);
    if (obj.hasOwnProperty("hashAlgorithm"))
      return [2, 0];
    return [1, 0];
  };
  return signature;
}
var eccJsbn = {};
var sec;
var hasRequiredSec;
function requireSec() {
  if (hasRequiredSec) return sec;
  hasRequiredSec = 1;
  var BigInteger = requireJsbn().BigInteger;
  var ECCurveFp = requireEc().ECCurveFp;
  function X9ECParameters(curve, g, n, h) {
    this.curve = curve;
    this.g = g;
    this.n = n;
    this.h = h;
  }
  function x9getCurve() {
    return this.curve;
  }
  function x9getG() {
    return this.g;
  }
  function x9getN() {
    return this.n;
  }
  function x9getH() {
    return this.h;
  }
  X9ECParameters.prototype.getCurve = x9getCurve;
  X9ECParameters.prototype.getG = x9getG;
  X9ECParameters.prototype.getN = x9getN;
  X9ECParameters.prototype.getH = x9getH;
  function fromHex(s) {
    return new BigInteger(s, 16);
  }
  function secp128r1() {
    var p = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF");
    var a = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC");
    var b = fromHex("E87579C11079F43DD824993C2CEE5ED3");
    var n = fromHex("FFFFFFFE0000000075A30D1B9038A115");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04161FF7528B899B2D0C28607CA52C5B86CF5AC8395BAFEB13C02DA292DDED7A83");
    return new X9ECParameters(curve, G, n, h);
  }
  function secp160k1() {
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73");
    var a = BigInteger.ZERO;
    var b = fromHex("7");
    var n = fromHex("0100000000000000000001B8FA16DFAB9ACA16B6B3");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("043B4C382CE37AA192A4019E763036F4F5DD4D7EBB938CF935318FDCED6BC28286531733C3F03C4FEE");
    return new X9ECParameters(curve, G, n, h);
  }
  function secp160r1() {
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF");
    var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC");
    var b = fromHex("1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45");
    var n = fromHex("0100000000000000000001F4C8F927AED3CA752257");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("044A96B5688EF573284664698968C38BB913CBFC8223A628553168947D59DCC912042351377AC5FB32");
    return new X9ECParameters(curve, G, n, h);
  }
  function secp192k1() {
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37");
    var a = BigInteger.ZERO;
    var b = fromHex("3");
    var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D");
    return new X9ECParameters(curve, G, n, h);
  }
  function secp192r1() {
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF");
    var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC");
    var b = fromHex("64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1");
    var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF101207192B95FFC8DA78631011ED6B24CDD573F977A11E794811");
    return new X9ECParameters(curve, G, n, h);
  }
  function secp224r1() {
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001");
    var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE");
    var b = fromHex("B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4");
    var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34");
    return new X9ECParameters(curve, G, n, h);
  }
  function secp256r1() {
    var p = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF");
    var a = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC");
    var b = fromHex("5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B");
    var n = fromHex("FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("046B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C2964FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5");
    return new X9ECParameters(curve, G, n, h);
  }
  sec = {
    "secp128r1": secp128r1,
    "secp160k1": secp160k1,
    "secp160r1": secp160r1,
    "secp192k1": secp192k1,
    "secp192r1": secp192r1,
    "secp224r1": secp224r1,
    "secp256r1": secp256r1
  };
  return sec;
}
var hasRequiredEccJsbn;
function requireEccJsbn() {
  if (hasRequiredEccJsbn) return eccJsbn;
  hasRequiredEccJsbn = 1;
  var crypto = require$$0$9;
  var BigInteger = requireJsbn().BigInteger;
  requireEc().ECPointFp;
  var Buffer2 = requireSafer().Buffer;
  eccJsbn.ECCurves = requireSec();
  function unstupid(hex, len) {
    return hex.length >= len ? hex : unstupid("0" + hex, len);
  }
  eccJsbn.ECKey = function(curve, key2, isPublic) {
    var priv;
    var c = curve();
    var n = c.getN();
    var bytes = Math.floor(n.bitLength() / 8);
    if (key2) {
      if (isPublic) {
        var curve = c.getCurve();
        this.P = curve.decodePointHex(key2.toString("hex"));
      } else {
        if (key2.length != bytes) return false;
        priv = new BigInteger(key2.toString("hex"), 16);
      }
    } else {
      var n1 = n.subtract(BigInteger.ONE);
      var r = new BigInteger(crypto.randomBytes(n.bitLength()));
      priv = r.mod(n1).add(BigInteger.ONE);
      this.P = c.getG().multiply(priv);
    }
    if (this.P) {
      this.PublicKey = Buffer2.from(c.getCurve().encodeCompressedPointHex(this.P), "hex");
    }
    if (priv) {
      this.PrivateKey = Buffer2.from(unstupid(priv.toString(16), bytes * 2), "hex");
      this.deriveSharedSecret = function(key3) {
        if (!key3 || !key3.P) return false;
        var S = key3.P.multiply(priv);
        return Buffer2.from(unstupid(S.getX().toBigInteger().toString(16), bytes * 2), "hex");
      };
    }
  };
  return eccJsbn;
}
var dhe;
var hasRequiredDhe;
function requireDhe() {
  if (hasRequiredDhe) return dhe;
  hasRequiredDhe = 1;
  dhe = {
    DiffieHellman,
    generateECDSA,
    generateED25519
  };
  var assert = requireAssert();
  var crypto = require$$0$9;
  var Buffer2 = requireSafer().Buffer;
  var algs2 = requireAlgs();
  var utils2 = requireUtils$3();
  var nacl = requireNaclFast();
  var Key = requireKey();
  var PrivateKey = requirePrivateKey();
  var CRYPTO_HAVE_ECDH = crypto.createECDH !== void 0;
  requireEccJsbn();
  var ec2 = requireEc();
  var jsbn2 = requireJsbn().BigInteger;
  function DiffieHellman(key2) {
    utils2.assertCompatible(key2, Key, [1, 4], "key");
    this._isPriv = PrivateKey.isPrivateKey(key2, [1, 3]);
    this._algo = key2.type;
    this._curve = key2.curve;
    this._key = key2;
    if (key2.type === "dsa") {
      if (!CRYPTO_HAVE_ECDH) {
        throw new Error("Due to bugs in the node 0.10 crypto API, node 0.12.x or later is required to use DH");
      }
      this._dh = crypto.createDiffieHellman(
        key2.part.p.data,
        void 0,
        key2.part.g.data,
        void 0
      );
      this._p = key2.part.p;
      this._g = key2.part.g;
      if (this._isPriv)
        this._dh.setPrivateKey(key2.part.x.data);
      this._dh.setPublicKey(key2.part.y.data);
    } else if (key2.type === "ecdsa") {
      if (!CRYPTO_HAVE_ECDH) {
        this._ecParams = new X9ECParameters(this._curve);
        if (this._isPriv) {
          this._priv = new ECPrivate(
            this._ecParams,
            key2.part.d.data
          );
        }
        return;
      }
      var curve = {
        "nistp256": "prime256v1",
        "nistp384": "secp384r1",
        "nistp521": "secp521r1"
      }[key2.curve];
      this._dh = crypto.createECDH(curve);
      if (typeof this._dh !== "object" || typeof this._dh.setPrivateKey !== "function") {
        CRYPTO_HAVE_ECDH = false;
        DiffieHellman.call(this, key2);
        return;
      }
      if (this._isPriv)
        this._dh.setPrivateKey(key2.part.d.data);
      this._dh.setPublicKey(key2.part.Q.data);
    } else if (key2.type === "curve25519") {
      if (this._isPriv) {
        utils2.assertCompatible(key2, PrivateKey, [1, 5], "key");
        this._priv = key2.part.k.data;
      }
    } else {
      throw new Error("DH not supported for " + key2.type + " keys");
    }
  }
  DiffieHellman.prototype.getPublicKey = function() {
    if (this._isPriv)
      return this._key.toPublic();
    return this._key;
  };
  DiffieHellman.prototype.getPrivateKey = function() {
    if (this._isPriv)
      return this._key;
    else
      return void 0;
  };
  DiffieHellman.prototype.getKey = DiffieHellman.prototype.getPrivateKey;
  DiffieHellman.prototype._keyCheck = function(pk, isPub) {
    assert.object(pk, "key");
    if (!isPub)
      utils2.assertCompatible(pk, PrivateKey, [1, 3], "key");
    utils2.assertCompatible(pk, Key, [1, 4], "key");
    if (pk.type !== this._algo) {
      throw new Error("A " + pk.type + " key cannot be used in " + this._algo + " Diffie-Hellman");
    }
    if (pk.curve !== this._curve) {
      throw new Error("A key from the " + pk.curve + " curve cannot be used with a " + this._curve + " Diffie-Hellman");
    }
    if (pk.type === "dsa") {
      assert.deepEqual(
        pk.part.p,
        this._p,
        "DSA key prime does not match"
      );
      assert.deepEqual(
        pk.part.g,
        this._g,
        "DSA key generator does not match"
      );
    }
  };
  DiffieHellman.prototype.setKey = function(pk) {
    this._keyCheck(pk);
    if (pk.type === "dsa") {
      this._dh.setPrivateKey(pk.part.x.data);
      this._dh.setPublicKey(pk.part.y.data);
    } else if (pk.type === "ecdsa") {
      if (CRYPTO_HAVE_ECDH) {
        this._dh.setPrivateKey(pk.part.d.data);
        this._dh.setPublicKey(pk.part.Q.data);
      } else {
        this._priv = new ECPrivate(
          this._ecParams,
          pk.part.d.data
        );
      }
    } else if (pk.type === "curve25519") {
      var k = pk.part.k;
      if (!pk.part.k)
        k = pk.part.r;
      this._priv = k.data;
      if (this._priv[0] === 0)
        this._priv = this._priv.slice(1);
      this._priv = this._priv.slice(0, 32);
    }
    this._key = pk;
    this._isPriv = true;
  };
  DiffieHellman.prototype.setPrivateKey = DiffieHellman.prototype.setKey;
  DiffieHellman.prototype.computeSecret = function(otherpk) {
    this._keyCheck(otherpk, true);
    if (!this._isPriv)
      throw new Error("DH exchange has not been initialized with a private key yet");
    var pub;
    if (this._algo === "dsa") {
      return this._dh.computeSecret(
        otherpk.part.y.data
      );
    } else if (this._algo === "ecdsa") {
      if (CRYPTO_HAVE_ECDH) {
        return this._dh.computeSecret(
          otherpk.part.Q.data
        );
      } else {
        pub = new ECPublic(
          this._ecParams,
          otherpk.part.Q.data
        );
        return this._priv.deriveSharedSecret(pub);
      }
    } else if (this._algo === "curve25519") {
      pub = otherpk.part.A.data;
      while (pub[0] === 0 && pub.length > 32)
        pub = pub.slice(1);
      var priv = this._priv;
      assert.strictEqual(pub.length, 32);
      assert.strictEqual(priv.length, 32);
      var secret = nacl.box.before(
        new Uint8Array(pub),
        new Uint8Array(priv)
      );
      return Buffer2.from(secret);
    }
    throw new Error("Invalid algorithm: " + this._algo);
  };
  DiffieHellman.prototype.generateKey = function() {
    var parts = [];
    var priv, pub;
    if (this._algo === "dsa") {
      this._dh.generateKeys();
      parts.push({ name: "p", data: this._p.data });
      parts.push({ name: "q", data: this._key.part.q.data });
      parts.push({ name: "g", data: this._g.data });
      parts.push({ name: "y", data: this._dh.getPublicKey() });
      parts.push({ name: "x", data: this._dh.getPrivateKey() });
      this._key = new PrivateKey({
        type: "dsa",
        parts
      });
      this._isPriv = true;
      return this._key;
    } else if (this._algo === "ecdsa") {
      if (CRYPTO_HAVE_ECDH) {
        this._dh.generateKeys();
        parts.push({
          name: "curve",
          data: Buffer2.from(this._curve)
        });
        parts.push({ name: "Q", data: this._dh.getPublicKey() });
        parts.push({ name: "d", data: this._dh.getPrivateKey() });
        this._key = new PrivateKey({
          type: "ecdsa",
          curve: this._curve,
          parts
        });
        this._isPriv = true;
        return this._key;
      } else {
        var n = this._ecParams.getN();
        var r = new jsbn2(crypto.randomBytes(n.bitLength()));
        var n1 = n.subtract(jsbn2.ONE);
        priv = r.mod(n1).add(jsbn2.ONE);
        pub = this._ecParams.getG().multiply(priv);
        priv = Buffer2.from(priv.toByteArray());
        pub = Buffer2.from(this._ecParams.getCurve().encodePointHex(pub), "hex");
        this._priv = new ECPrivate(this._ecParams, priv);
        parts.push({
          name: "curve",
          data: Buffer2.from(this._curve)
        });
        parts.push({ name: "Q", data: pub });
        parts.push({ name: "d", data: priv });
        this._key = new PrivateKey({
          type: "ecdsa",
          curve: this._curve,
          parts
        });
        this._isPriv = true;
        return this._key;
      }
    } else if (this._algo === "curve25519") {
      var pair = nacl.box.keyPair();
      priv = Buffer2.from(pair.secretKey);
      pub = Buffer2.from(pair.publicKey);
      priv = Buffer2.concat([priv, pub]);
      assert.strictEqual(priv.length, 64);
      assert.strictEqual(pub.length, 32);
      parts.push({ name: "A", data: pub });
      parts.push({ name: "k", data: priv });
      this._key = new PrivateKey({
        type: "curve25519",
        parts
      });
      this._isPriv = true;
      return this._key;
    }
    throw new Error("Invalid algorithm: " + this._algo);
  };
  DiffieHellman.prototype.generateKeys = DiffieHellman.prototype.generateKey;
  function X9ECParameters(name) {
    var params = algs2.curves[name];
    assert.object(params);
    var p = new jsbn2(params.p);
    var a = new jsbn2(params.a);
    var b = new jsbn2(params.b);
    var n = new jsbn2(params.n);
    var h = jsbn2.ONE;
    var curve = new ec2.ECCurveFp(p, a, b);
    var G = curve.decodePointHex(params.G.toString("hex"));
    this.curve = curve;
    this.g = G;
    this.n = n;
    this.h = h;
  }
  X9ECParameters.prototype.getCurve = function() {
    return this.curve;
  };
  X9ECParameters.prototype.getG = function() {
    return this.g;
  };
  X9ECParameters.prototype.getN = function() {
    return this.n;
  };
  X9ECParameters.prototype.getH = function() {
    return this.h;
  };
  function ECPublic(params, buffer) {
    this._params = params;
    if (buffer[0] === 0)
      buffer = buffer.slice(1);
    this._pub = params.getCurve().decodePointHex(buffer.toString("hex"));
  }
  function ECPrivate(params, buffer) {
    this._params = params;
    this._priv = new jsbn2(utils2.mpNormalize(buffer));
  }
  ECPrivate.prototype.deriveSharedSecret = function(pubKey) {
    assert.ok(pubKey instanceof ECPublic);
    var S = pubKey._pub.multiply(this._priv);
    return Buffer2.from(S.getX().toBigInteger().toByteArray());
  };
  function generateED25519() {
    var pair = nacl.sign.keyPair();
    var priv = Buffer2.from(pair.secretKey);
    var pub = Buffer2.from(pair.publicKey);
    assert.strictEqual(priv.length, 64);
    assert.strictEqual(pub.length, 32);
    var parts = [];
    parts.push({ name: "A", data: pub });
    parts.push({ name: "k", data: priv.slice(0, 32) });
    var key2 = new PrivateKey({
      type: "ed25519",
      parts
    });
    return key2;
  }
  function generateECDSA(curve) {
    var parts = [];
    var key2;
    if (CRYPTO_HAVE_ECDH) {
      var osCurve = {
        "nistp256": "prime256v1",
        "nistp384": "secp384r1",
        "nistp521": "secp521r1"
      }[curve];
      var dh = crypto.createECDH(osCurve);
      dh.generateKeys();
      parts.push({
        name: "curve",
        data: Buffer2.from(curve)
      });
      parts.push({ name: "Q", data: dh.getPublicKey() });
      parts.push({ name: "d", data: dh.getPrivateKey() });
      key2 = new PrivateKey({
        type: "ecdsa",
        curve,
        parts
      });
      return key2;
    } else {
      var ecParams = new X9ECParameters(curve);
      var n = ecParams.getN();
      var cByteLen = Math.ceil((n.bitLength() + 64) / 8);
      var c = new jsbn2(crypto.randomBytes(cByteLen));
      var n1 = n.subtract(jsbn2.ONE);
      var priv = c.mod(n1).add(jsbn2.ONE);
      var pub = ecParams.getG().multiply(priv);
      priv = Buffer2.from(priv.toByteArray());
      pub = Buffer2.from(ecParams.getCurve().encodePointHex(pub), "hex");
      parts.push({ name: "curve", data: Buffer2.from(curve) });
      parts.push({ name: "Q", data: pub });
      parts.push({ name: "d", data: priv });
      key2 = new PrivateKey({
        type: "ecdsa",
        curve,
        parts
      });
      return key2;
    }
  }
  return dhe;
}
var edCompat;
var hasRequiredEdCompat;
function requireEdCompat() {
  if (hasRequiredEdCompat) return edCompat;
  hasRequiredEdCompat = 1;
  edCompat = {
    Verifier,
    Signer
  };
  var nacl = requireNaclFast();
  var stream = require$$1$2;
  var util2 = require$$0$5;
  var assert = requireAssert();
  var Buffer2 = requireSafer().Buffer;
  var Signature = requireSignature();
  function Verifier(key2, hashAlgo) {
    if (hashAlgo.toLowerCase() !== "sha512")
      throw new Error("ED25519 only supports the use of SHA-512 hashes");
    this.key = key2;
    this.chunks = [];
    stream.Writable.call(this, {});
  }
  util2.inherits(Verifier, stream.Writable);
  Verifier.prototype._write = function(chunk, enc, cb) {
    this.chunks.push(chunk);
    cb();
  };
  Verifier.prototype.update = function(chunk) {
    if (typeof chunk === "string")
      chunk = Buffer2.from(chunk, "binary");
    this.chunks.push(chunk);
  };
  Verifier.prototype.verify = function(signature2, fmt) {
    var sig;
    if (Signature.isSignature(signature2, [2, 0])) {
      if (signature2.type !== "ed25519")
        return false;
      sig = signature2.toBuffer("raw");
    } else if (typeof signature2 === "string") {
      sig = Buffer2.from(signature2, "base64");
    } else if (Signature.isSignature(signature2, [1, 0])) {
      throw new Error("signature was created by too old a version of sshpk and cannot be verified");
    }
    assert.buffer(sig);
    return nacl.sign.detached.verify(
      new Uint8Array(Buffer2.concat(this.chunks)),
      new Uint8Array(sig),
      new Uint8Array(this.key.part.A.data)
    );
  };
  function Signer(key2, hashAlgo) {
    if (hashAlgo.toLowerCase() !== "sha512")
      throw new Error("ED25519 only supports the use of SHA-512 hashes");
    this.key = key2;
    this.chunks = [];
    stream.Writable.call(this, {});
  }
  util2.inherits(Signer, stream.Writable);
  Signer.prototype._write = function(chunk, enc, cb) {
    this.chunks.push(chunk);
    cb();
  };
  Signer.prototype.update = function(chunk) {
    if (typeof chunk === "string")
      chunk = Buffer2.from(chunk, "binary");
    this.chunks.push(chunk);
  };
  Signer.prototype.sign = function() {
    var sig = nacl.sign.detached(
      new Uint8Array(Buffer2.concat(this.chunks)),
      new Uint8Array(Buffer2.concat([
        this.key.part.k.data,
        this.key.part.A.data
      ]))
    );
    var sigBuf = Buffer2.from(sig);
    var sigObj = Signature.parse(sigBuf, "ed25519", "raw");
    sigObj.hashAlgorithm = "sha512";
    return sigObj;
  };
  return edCompat;
}
var pkcs8;
var hasRequiredPkcs8;
function requirePkcs8() {
  if (hasRequiredPkcs8) return pkcs8;
  hasRequiredPkcs8 = 1;
  pkcs8 = {
    read,
    readPkcs8,
    write,
    writePkcs8,
    pkcs8ToBuffer,
    readECDSACurve,
    writeECDSACurve
  };
  var assert = requireAssert();
  var asn1 = requireLib$4();
  var Buffer2 = requireSafer().Buffer;
  var algs2 = requireAlgs();
  var utils2 = requireUtils$3();
  var Key = requireKey();
  var PrivateKey = requirePrivateKey();
  var pem2 = requirePem();
  function read(buf, options) {
    return pem2.read(buf, options, "pkcs8");
  }
  function write(key2, options) {
    return pem2.write(key2, options, "pkcs8");
  }
  function readMPInt(der, nm) {
    assert.strictEqual(
      der.peek(),
      asn1.Ber.Integer,
      nm + " is not an Integer"
    );
    return utils2.mpNormalize(der.readString(asn1.Ber.Integer, true));
  }
  function readPkcs8(alg, type2, der) {
    if (der.peek() === asn1.Ber.Integer) {
      assert.strictEqual(
        type2,
        "private",
        "unexpected Integer at start of public key"
      );
      der.readString(asn1.Ber.Integer, true);
    }
    der.readSequence();
    var next = der.offset + der.length;
    var oid = der.readOID();
    switch (oid) {
      case "1.2.840.113549.1.1.1":
        der._offset = next;
        if (type2 === "public")
          return readPkcs8RSAPublic(der);
        else
          return readPkcs8RSAPrivate(der);
      case "1.2.840.10040.4.1":
        if (type2 === "public")
          return readPkcs8DSAPublic(der);
        else
          return readPkcs8DSAPrivate(der);
      case "1.2.840.10045.2.1":
        if (type2 === "public")
          return readPkcs8ECDSAPublic(der);
        else
          return readPkcs8ECDSAPrivate(der);
      case "1.3.101.112":
        if (type2 === "public") {
          return readPkcs8EdDSAPublic(der);
        } else {
          return readPkcs8EdDSAPrivate(der);
        }
      case "1.3.101.110":
        if (type2 === "public") {
          return readPkcs8X25519Public(der);
        } else {
          return readPkcs8X25519Private(der);
        }
      default:
        throw new Error("Unknown key type OID " + oid);
    }
  }
  function readPkcs8RSAPublic(der) {
    der.readSequence(asn1.Ber.BitString);
    der.readByte();
    der.readSequence();
    var n = readMPInt(der, "modulus");
    var e = readMPInt(der, "exponent");
    var key2 = {
      type: "rsa",
      source: der.originalInput,
      parts: [
        { name: "e", data: e },
        { name: "n", data: n }
      ]
    };
    return new Key(key2);
  }
  function readPkcs8RSAPrivate(der) {
    der.readSequence(asn1.Ber.OctetString);
    der.readSequence();
    var ver = readMPInt(der, "version");
    assert.equal(ver[0], 0, "unknown RSA private key version");
    var n = readMPInt(der, "modulus");
    var e = readMPInt(der, "public exponent");
    var d = readMPInt(der, "private exponent");
    var p = readMPInt(der, "prime1");
    var q2 = readMPInt(der, "prime2");
    var dmodp = readMPInt(der, "exponent1");
    var dmodq = readMPInt(der, "exponent2");
    var iqmp = readMPInt(der, "iqmp");
    var key2 = {
      type: "rsa",
      parts: [
        { name: "n", data: n },
        { name: "e", data: e },
        { name: "d", data: d },
        { name: "iqmp", data: iqmp },
        { name: "p", data: p },
        { name: "q", data: q2 },
        { name: "dmodp", data: dmodp },
        { name: "dmodq", data: dmodq }
      ]
    };
    return new PrivateKey(key2);
  }
  function readPkcs8DSAPublic(der) {
    der.readSequence();
    var p = readMPInt(der, "p");
    var q2 = readMPInt(der, "q");
    var g = readMPInt(der, "g");
    der.readSequence(asn1.Ber.BitString);
    der.readByte();
    var y = readMPInt(der, "y");
    var key2 = {
      type: "dsa",
      parts: [
        { name: "p", data: p },
        { name: "q", data: q2 },
        { name: "g", data: g },
        { name: "y", data: y }
      ]
    };
    return new Key(key2);
  }
  function readPkcs8DSAPrivate(der) {
    der.readSequence();
    var p = readMPInt(der, "p");
    var q2 = readMPInt(der, "q");
    var g = readMPInt(der, "g");
    der.readSequence(asn1.Ber.OctetString);
    var x = readMPInt(der, "x");
    var y = utils2.calculateDSAPublic(g, p, x);
    var key2 = {
      type: "dsa",
      parts: [
        { name: "p", data: p },
        { name: "q", data: q2 },
        { name: "g", data: g },
        { name: "y", data: y },
        { name: "x", data: x }
      ]
    };
    return new PrivateKey(key2);
  }
  function readECDSACurve(der) {
    var curveName, curveNames;
    var j, c, cd;
    if (der.peek() === asn1.Ber.OID) {
      var oid = der.readOID();
      curveNames = Object.keys(algs2.curves);
      for (j = 0; j < curveNames.length; ++j) {
        c = curveNames[j];
        cd = algs2.curves[c];
        if (cd.pkcs8oid === oid) {
          curveName = c;
          break;
        }
      }
    } else {
      der.readSequence();
      var version2 = der.readString(asn1.Ber.Integer, true);
      assert.strictEqual(version2[0], 1, "ECDSA key not version 1");
      var curve = {};
      der.readSequence();
      var fieldTypeOid = der.readOID();
      assert.strictEqual(
        fieldTypeOid,
        "1.2.840.10045.1.1",
        "ECDSA key is not from a prime-field"
      );
      var p = curve.p = utils2.mpNormalize(
        der.readString(asn1.Ber.Integer, true)
      );
      curve.size = p.length * 8 - utils2.countZeros(p);
      der.readSequence();
      curve.a = utils2.mpNormalize(
        der.readString(asn1.Ber.OctetString, true)
      );
      curve.b = utils2.mpNormalize(
        der.readString(asn1.Ber.OctetString, true)
      );
      if (der.peek() === asn1.Ber.BitString)
        curve.s = der.readString(asn1.Ber.BitString, true);
      curve.G = der.readString(asn1.Ber.OctetString, true);
      assert.strictEqual(
        curve.G[0],
        4,
        "uncompressed G is required"
      );
      curve.n = utils2.mpNormalize(
        der.readString(asn1.Ber.Integer, true)
      );
      curve.h = utils2.mpNormalize(
        der.readString(asn1.Ber.Integer, true)
      );
      assert.strictEqual(curve.h[0], 1, "a cofactor=1 curve is required");
      curveNames = Object.keys(algs2.curves);
      var ks = Object.keys(curve);
      for (j = 0; j < curveNames.length; ++j) {
        c = curveNames[j];
        cd = algs2.curves[c];
        var equal = true;
        for (var i = 0; i < ks.length; ++i) {
          var k = ks[i];
          if (cd[k] === void 0)
            continue;
          if (typeof cd[k] === "object" && cd[k].equals !== void 0) {
            if (!cd[k].equals(curve[k])) {
              equal = false;
              break;
            }
          } else if (Buffer2.isBuffer(cd[k])) {
            if (cd[k].toString("binary") !== curve[k].toString("binary")) {
              equal = false;
              break;
            }
          } else {
            if (cd[k] !== curve[k]) {
              equal = false;
              break;
            }
          }
        }
        if (equal) {
          curveName = c;
          break;
        }
      }
    }
    return curveName;
  }
  function readPkcs8ECDSAPrivate(der) {
    var curveName = readECDSACurve(der);
    assert.string(curveName, "a known elliptic curve");
    der.readSequence(asn1.Ber.OctetString);
    der.readSequence();
    var version2 = readMPInt(der, "version");
    assert.equal(version2[0], 1, "unknown version of ECDSA key");
    var d = der.readString(asn1.Ber.OctetString, true);
    var Q;
    if (der.peek() == 160) {
      der.readSequence(160);
      der._offset += der.length;
    }
    if (der.peek() == 161) {
      der.readSequence(161);
      Q = der.readString(asn1.Ber.BitString, true);
      Q = utils2.ecNormalize(Q);
    }
    if (Q === void 0) {
      var pub = utils2.publicFromPrivateECDSA(curveName, d);
      Q = pub.part.Q.data;
    }
    var key2 = {
      type: "ecdsa",
      parts: [
        { name: "curve", data: Buffer2.from(curveName) },
        { name: "Q", data: Q },
        { name: "d", data: d }
      ]
    };
    return new PrivateKey(key2);
  }
  function readPkcs8ECDSAPublic(der) {
    var curveName = readECDSACurve(der);
    assert.string(curveName, "a known elliptic curve");
    var Q = der.readString(asn1.Ber.BitString, true);
    Q = utils2.ecNormalize(Q);
    var key2 = {
      type: "ecdsa",
      parts: [
        { name: "curve", data: Buffer2.from(curveName) },
        { name: "Q", data: Q }
      ]
    };
    return new Key(key2);
  }
  function readPkcs8EdDSAPublic(der) {
    if (der.peek() === 0)
      der.readByte();
    var A = utils2.readBitString(der);
    var key2 = {
      type: "ed25519",
      parts: [
        { name: "A", data: utils2.zeroPadToLength(A, 32) }
      ]
    };
    return new Key(key2);
  }
  function readPkcs8X25519Public(der) {
    var A = utils2.readBitString(der);
    var key2 = {
      type: "curve25519",
      parts: [
        { name: "A", data: utils2.zeroPadToLength(A, 32) }
      ]
    };
    return new Key(key2);
  }
  function readPkcs8EdDSAPrivate(der) {
    if (der.peek() === 0)
      der.readByte();
    der.readSequence(asn1.Ber.OctetString);
    var k = der.readString(asn1.Ber.OctetString, true);
    k = utils2.zeroPadToLength(k, 32);
    var A, tag;
    while ((tag = der.peek()) !== null) {
      if (tag === (asn1.Ber.Context | 1)) {
        A = utils2.readBitString(der, tag);
      } else {
        der.readSequence(tag);
        der._offset += der.length;
      }
    }
    if (A === void 0)
      A = utils2.calculateED25519Public(k);
    var key2 = {
      type: "ed25519",
      parts: [
        { name: "A", data: utils2.zeroPadToLength(A, 32) },
        { name: "k", data: utils2.zeroPadToLength(k, 32) }
      ]
    };
    return new PrivateKey(key2);
  }
  function readPkcs8X25519Private(der) {
    if (der.peek() === 0)
      der.readByte();
    der.readSequence(asn1.Ber.OctetString);
    var k = der.readString(asn1.Ber.OctetString, true);
    k = utils2.zeroPadToLength(k, 32);
    var A = utils2.calculateX25519Public(k);
    var key2 = {
      type: "curve25519",
      parts: [
        { name: "A", data: utils2.zeroPadToLength(A, 32) },
        { name: "k", data: utils2.zeroPadToLength(k, 32) }
      ]
    };
    return new PrivateKey(key2);
  }
  function pkcs8ToBuffer(key2) {
    var der = new asn1.BerWriter();
    writePkcs8(der, key2);
    return der.buffer;
  }
  function writePkcs8(der, key2) {
    der.startSequence();
    if (PrivateKey.isPrivateKey(key2)) {
      var version2 = 0;
      if (key2.type === "ed25519")
        version2 = 1;
      var vbuf = Buffer2.from([version2]);
      der.writeBuffer(vbuf, asn1.Ber.Integer);
    }
    der.startSequence();
    switch (key2.type) {
      case "rsa":
        der.writeOID("1.2.840.113549.1.1.1");
        if (PrivateKey.isPrivateKey(key2))
          writePkcs8RSAPrivate(key2, der);
        else
          writePkcs8RSAPublic(key2, der);
        break;
      case "dsa":
        der.writeOID("1.2.840.10040.4.1");
        if (PrivateKey.isPrivateKey(key2))
          writePkcs8DSAPrivate(key2, der);
        else
          writePkcs8DSAPublic(key2, der);
        break;
      case "ecdsa":
        der.writeOID("1.2.840.10045.2.1");
        if (PrivateKey.isPrivateKey(key2))
          writePkcs8ECDSAPrivate(key2, der);
        else
          writePkcs8ECDSAPublic(key2, der);
        break;
      case "ed25519":
        der.writeOID("1.3.101.112");
        if (PrivateKey.isPrivateKey(key2))
          writePkcs8EdDSAPrivate(key2, der);
        else
          writePkcs8EdDSAPublic(key2, der);
        break;
      default:
        throw new Error("Unsupported key type: " + key2.type);
    }
    der.endSequence();
  }
  function writePkcs8RSAPrivate(key2, der) {
    der.writeNull();
    der.endSequence();
    der.startSequence(asn1.Ber.OctetString);
    der.startSequence();
    var version2 = Buffer2.from([0]);
    der.writeBuffer(version2, asn1.Ber.Integer);
    der.writeBuffer(key2.part.n.data, asn1.Ber.Integer);
    der.writeBuffer(key2.part.e.data, asn1.Ber.Integer);
    der.writeBuffer(key2.part.d.data, asn1.Ber.Integer);
    der.writeBuffer(key2.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key2.part.q.data, asn1.Ber.Integer);
    if (!key2.part.dmodp || !key2.part.dmodq)
      utils2.addRSAMissing(key2);
    der.writeBuffer(key2.part.dmodp.data, asn1.Ber.Integer);
    der.writeBuffer(key2.part.dmodq.data, asn1.Ber.Integer);
    der.writeBuffer(key2.part.iqmp.data, asn1.Ber.Integer);
    der.endSequence();
    der.endSequence();
  }
  function writePkcs8RSAPublic(key2, der) {
    der.writeNull();
    der.endSequence();
    der.startSequence(asn1.Ber.BitString);
    der.writeByte(0);
    der.startSequence();
    der.writeBuffer(key2.part.n.data, asn1.Ber.Integer);
    der.writeBuffer(key2.part.e.data, asn1.Ber.Integer);
    der.endSequence();
    der.endSequence();
  }
  function writePkcs8DSAPrivate(key2, der) {
    der.startSequence();
    der.writeBuffer(key2.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key2.part.q.data, asn1.Ber.Integer);
    der.writeBuffer(key2.part.g.data, asn1.Ber.Integer);
    der.endSequence();
    der.endSequence();
    der.startSequence(asn1.Ber.OctetString);
    der.writeBuffer(key2.part.x.data, asn1.Ber.Integer);
    der.endSequence();
  }
  function writePkcs8DSAPublic(key2, der) {
    der.startSequence();
    der.writeBuffer(key2.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key2.part.q.data, asn1.Ber.Integer);
    der.writeBuffer(key2.part.g.data, asn1.Ber.Integer);
    der.endSequence();
    der.endSequence();
    der.startSequence(asn1.Ber.BitString);
    der.writeByte(0);
    der.writeBuffer(key2.part.y.data, asn1.Ber.Integer);
    der.endSequence();
  }
  function writeECDSACurve(key2, der) {
    var curve = algs2.curves[key2.curve];
    if (curve.pkcs8oid) {
      der.writeOID(curve.pkcs8oid);
    } else {
      der.startSequence();
      var version2 = Buffer2.from([1]);
      der.writeBuffer(version2, asn1.Ber.Integer);
      der.startSequence();
      der.writeOID("1.2.840.10045.1.1");
      der.writeBuffer(curve.p, asn1.Ber.Integer);
      der.endSequence();
      der.startSequence();
      var a = curve.p;
      if (a[0] === 0)
        a = a.slice(1);
      der.writeBuffer(a, asn1.Ber.OctetString);
      der.writeBuffer(curve.b, asn1.Ber.OctetString);
      der.writeBuffer(curve.s, asn1.Ber.BitString);
      der.endSequence();
      der.writeBuffer(curve.G, asn1.Ber.OctetString);
      der.writeBuffer(curve.n, asn1.Ber.Integer);
      var h = curve.h;
      if (!h) {
        h = Buffer2.from([1]);
      }
      der.writeBuffer(h, asn1.Ber.Integer);
      der.endSequence();
    }
  }
  function writePkcs8ECDSAPublic(key2, der) {
    writeECDSACurve(key2, der);
    der.endSequence();
    var Q = utils2.ecNormalize(key2.part.Q.data, true);
    der.writeBuffer(Q, asn1.Ber.BitString);
  }
  function writePkcs8ECDSAPrivate(key2, der) {
    writeECDSACurve(key2, der);
    der.endSequence();
    der.startSequence(asn1.Ber.OctetString);
    der.startSequence();
    var version2 = Buffer2.from([1]);
    der.writeBuffer(version2, asn1.Ber.Integer);
    der.writeBuffer(key2.part.d.data, asn1.Ber.OctetString);
    der.startSequence(161);
    var Q = utils2.ecNormalize(key2.part.Q.data, true);
    der.writeBuffer(Q, asn1.Ber.BitString);
    der.endSequence();
    der.endSequence();
    der.endSequence();
  }
  function writePkcs8EdDSAPublic(key2, der) {
    der.endSequence();
    utils2.writeBitString(der, key2.part.A.data);
  }
  function writePkcs8EdDSAPrivate(key2, der) {
    der.endSequence();
    der.startSequence(asn1.Ber.OctetString);
    var k = utils2.mpNormalize(key2.part.k.data);
    while (k.length > 32 && k[0] === 0)
      k = k.slice(1);
    der.writeBuffer(k, asn1.Ber.OctetString);
    der.endSequence();
    utils2.writeBitString(der, key2.part.A.data, asn1.Ber.Context | 1);
  }
  return pkcs8;
}
var pkcs1;
var hasRequiredPkcs1;
function requirePkcs1() {
  if (hasRequiredPkcs1) return pkcs1;
  hasRequiredPkcs1 = 1;
  pkcs1 = {
    read,
    readPkcs1,
    write,
    writePkcs1
  };
  var assert = requireAssert();
  var asn1 = requireLib$4();
  var Buffer2 = requireSafer().Buffer;
  var algs2 = requireAlgs();
  var utils2 = requireUtils$3();
  var Key = requireKey();
  var PrivateKey = requirePrivateKey();
  var pem2 = requirePem();
  var pkcs82 = requirePkcs8();
  var readECDSACurve = pkcs82.readECDSACurve;
  function read(buf, options) {
    return pem2.read(buf, options, "pkcs1");
  }
  function write(key2, options) {
    return pem2.write(key2, options, "pkcs1");
  }
  function readMPInt(der, nm) {
    assert.strictEqual(
      der.peek(),
      asn1.Ber.Integer,
      nm + " is not an Integer"
    );
    return utils2.mpNormalize(der.readString(asn1.Ber.Integer, true));
  }
  function readPkcs1(alg, type2, der) {
    switch (alg) {
      case "RSA":
        if (type2 === "public")
          return readPkcs1RSAPublic(der);
        else if (type2 === "private")
          return readPkcs1RSAPrivate(der);
        throw new Error("Unknown key type: " + type2);
      case "DSA":
        if (type2 === "public")
          return readPkcs1DSAPublic(der);
        else if (type2 === "private")
          return readPkcs1DSAPrivate(der);
        throw new Error("Unknown key type: " + type2);
      case "EC":
      case "ECDSA":
        if (type2 === "private")
          return readPkcs1ECDSAPrivate(der);
        else if (type2 === "public")
          return readPkcs1ECDSAPublic(der);
        throw new Error("Unknown key type: " + type2);
      case "EDDSA":
      case "EdDSA":
        if (type2 === "private")
          return readPkcs1EdDSAPrivate(der);
        throw new Error(type2 + " keys not supported with EdDSA");
      default:
        throw new Error("Unknown key algo: " + alg);
    }
  }
  function readPkcs1RSAPublic(der) {
    var n = readMPInt(der, "modulus");
    var e = readMPInt(der, "exponent");
    var key2 = {
      type: "rsa",
      parts: [
        { name: "e", data: e },
        { name: "n", data: n }
      ]
    };
    return new Key(key2);
  }
  function readPkcs1RSAPrivate(der) {
    var version2 = readMPInt(der, "version");
    assert.strictEqual(version2[0], 0);
    var n = readMPInt(der, "modulus");
    var e = readMPInt(der, "public exponent");
    var d = readMPInt(der, "private exponent");
    var p = readMPInt(der, "prime1");
    var q2 = readMPInt(der, "prime2");
    var dmodp = readMPInt(der, "exponent1");
    var dmodq = readMPInt(der, "exponent2");
    var iqmp = readMPInt(der, "iqmp");
    var key2 = {
      type: "rsa",
      parts: [
        { name: "n", data: n },
        { name: "e", data: e },
        { name: "d", data: d },
        { name: "iqmp", data: iqmp },
        { name: "p", data: p },
        { name: "q", data: q2 },
        { name: "dmodp", data: dmodp },
        { name: "dmodq", data: dmodq }
      ]
    };
    return new PrivateKey(key2);
  }
  function readPkcs1DSAPrivate(der) {
    var version2 = readMPInt(der, "version");
    assert.strictEqual(version2.readUInt8(0), 0);
    var p = readMPInt(der, "p");
    var q2 = readMPInt(der, "q");
    var g = readMPInt(der, "g");
    var y = readMPInt(der, "y");
    var x = readMPInt(der, "x");
    var key2 = {
      type: "dsa",
      parts: [
        { name: "p", data: p },
        { name: "q", data: q2 },
        { name: "g", data: g },
        { name: "y", data: y },
        { name: "x", data: x }
      ]
    };
    return new PrivateKey(key2);
  }
  function readPkcs1EdDSAPrivate(der) {
    var version2 = readMPInt(der, "version");
    assert.strictEqual(version2.readUInt8(0), 1);
    var k = der.readString(asn1.Ber.OctetString, true);
    der.readSequence(160);
    var oid = der.readOID();
    assert.strictEqual(oid, "1.3.101.112", "the ed25519 curve identifier");
    der.readSequence(161);
    var A = utils2.readBitString(der);
    var key2 = {
      type: "ed25519",
      parts: [
        { name: "A", data: utils2.zeroPadToLength(A, 32) },
        { name: "k", data: k }
      ]
    };
    return new PrivateKey(key2);
  }
  function readPkcs1DSAPublic(der) {
    var y = readMPInt(der, "y");
    var p = readMPInt(der, "p");
    var q2 = readMPInt(der, "q");
    var g = readMPInt(der, "g");
    var key2 = {
      type: "dsa",
      parts: [
        { name: "y", data: y },
        { name: "p", data: p },
        { name: "q", data: q2 },
        { name: "g", data: g }
      ]
    };
    return new Key(key2);
  }
  function readPkcs1ECDSAPublic(der) {
    der.readSequence();
    var oid = der.readOID();
    assert.strictEqual(oid, "1.2.840.10045.2.1", "must be ecPublicKey");
    var curveOid = der.readOID();
    var curve;
    var curves = Object.keys(algs2.curves);
    for (var j = 0; j < curves.length; ++j) {
      var c = curves[j];
      var cd = algs2.curves[c];
      if (cd.pkcs8oid === curveOid) {
        curve = c;
        break;
      }
    }
    assert.string(curve, "a known ECDSA named curve");
    var Q = der.readString(asn1.Ber.BitString, true);
    Q = utils2.ecNormalize(Q);
    var key2 = {
      type: "ecdsa",
      parts: [
        { name: "curve", data: Buffer2.from(curve) },
        { name: "Q", data: Q }
      ]
    };
    return new Key(key2);
  }
  function readPkcs1ECDSAPrivate(der) {
    var version2 = readMPInt(der, "version");
    assert.strictEqual(version2.readUInt8(0), 1);
    var d = der.readString(asn1.Ber.OctetString, true);
    der.readSequence(160);
    var curve = readECDSACurve(der);
    assert.string(curve, "a known elliptic curve");
    der.readSequence(161);
    var Q = der.readString(asn1.Ber.BitString, true);
    Q = utils2.ecNormalize(Q);
    var key2 = {
      type: "ecdsa",
      parts: [
        { name: "curve", data: Buffer2.from(curve) },
        { name: "Q", data: Q },
        { name: "d", data: d }
      ]
    };
    return new PrivateKey(key2);
  }
  function writePkcs1(der, key2) {
    der.startSequence();
    switch (key2.type) {
      case "rsa":
        if (PrivateKey.isPrivateKey(key2))
          writePkcs1RSAPrivate(der, key2);
        else
          writePkcs1RSAPublic(der, key2);
        break;
      case "dsa":
        if (PrivateKey.isPrivateKey(key2))
          writePkcs1DSAPrivate(der, key2);
        else
          writePkcs1DSAPublic(der, key2);
        break;
      case "ecdsa":
        if (PrivateKey.isPrivateKey(key2))
          writePkcs1ECDSAPrivate(der, key2);
        else
          writePkcs1ECDSAPublic(der, key2);
        break;
      case "ed25519":
        if (PrivateKey.isPrivateKey(key2))
          writePkcs1EdDSAPrivate(der, key2);
        else
          writePkcs1EdDSAPublic();
        break;
      default:
        throw new Error("Unknown key algo: " + key2.type);
    }
    der.endSequence();
  }
  function writePkcs1RSAPublic(der, key2) {
    der.writeBuffer(key2.part.n.data, asn1.Ber.Integer);
    der.writeBuffer(key2.part.e.data, asn1.Ber.Integer);
  }
  function writePkcs1RSAPrivate(der, key2) {
    var ver = Buffer2.from([0]);
    der.writeBuffer(ver, asn1.Ber.Integer);
    der.writeBuffer(key2.part.n.data, asn1.Ber.Integer);
    der.writeBuffer(key2.part.e.data, asn1.Ber.Integer);
    der.writeBuffer(key2.part.d.data, asn1.Ber.Integer);
    der.writeBuffer(key2.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key2.part.q.data, asn1.Ber.Integer);
    if (!key2.part.dmodp || !key2.part.dmodq)
      utils2.addRSAMissing(key2);
    der.writeBuffer(key2.part.dmodp.data, asn1.Ber.Integer);
    der.writeBuffer(key2.part.dmodq.data, asn1.Ber.Integer);
    der.writeBuffer(key2.part.iqmp.data, asn1.Ber.Integer);
  }
  function writePkcs1DSAPrivate(der, key2) {
    var ver = Buffer2.from([0]);
    der.writeBuffer(ver, asn1.Ber.Integer);
    der.writeBuffer(key2.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key2.part.q.data, asn1.Ber.Integer);
    der.writeBuffer(key2.part.g.data, asn1.Ber.Integer);
    der.writeBuffer(key2.part.y.data, asn1.Ber.Integer);
    der.writeBuffer(key2.part.x.data, asn1.Ber.Integer);
  }
  function writePkcs1DSAPublic(der, key2) {
    der.writeBuffer(key2.part.y.data, asn1.Ber.Integer);
    der.writeBuffer(key2.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key2.part.q.data, asn1.Ber.Integer);
    der.writeBuffer(key2.part.g.data, asn1.Ber.Integer);
  }
  function writePkcs1ECDSAPublic(der, key2) {
    der.startSequence();
    der.writeOID("1.2.840.10045.2.1");
    var curve = key2.part.curve.data.toString();
    var curveOid = algs2.curves[curve].pkcs8oid;
    assert.string(curveOid, "a known ECDSA named curve");
    der.writeOID(curveOid);
    der.endSequence();
    var Q = utils2.ecNormalize(key2.part.Q.data, true);
    der.writeBuffer(Q, asn1.Ber.BitString);
  }
  function writePkcs1ECDSAPrivate(der, key2) {
    var ver = Buffer2.from([1]);
    der.writeBuffer(ver, asn1.Ber.Integer);
    der.writeBuffer(key2.part.d.data, asn1.Ber.OctetString);
    der.startSequence(160);
    var curve = key2.part.curve.data.toString();
    var curveOid = algs2.curves[curve].pkcs8oid;
    assert.string(curveOid, "a known ECDSA named curve");
    der.writeOID(curveOid);
    der.endSequence();
    der.startSequence(161);
    var Q = utils2.ecNormalize(key2.part.Q.data, true);
    der.writeBuffer(Q, asn1.Ber.BitString);
    der.endSequence();
  }
  function writePkcs1EdDSAPrivate(der, key2) {
    var ver = Buffer2.from([1]);
    der.writeBuffer(ver, asn1.Ber.Integer);
    der.writeBuffer(key2.part.k.data, asn1.Ber.OctetString);
    der.startSequence(160);
    der.writeOID("1.3.101.112");
    der.endSequence();
    der.startSequence(161);
    utils2.writeBitString(der, key2.part.A.data);
    der.endSequence();
  }
  function writePkcs1EdDSAPublic(der, key2) {
    throw new Error("Public keys are not supported for EdDSA PKCS#1");
  }
  return pkcs1;
}
var rfc4253;
var hasRequiredRfc4253;
function requireRfc4253() {
  if (hasRequiredRfc4253) return rfc4253;
  hasRequiredRfc4253 = 1;
  rfc4253 = {
    read: read.bind(void 0, false, void 0),
    readType: read.bind(void 0, false),
    write,
    /* semi-private api, used by sshpk-agent */
    readPartial: read.bind(void 0, true),
    /* shared with ssh format */
    readInternal: read,
    keyTypeToAlg,
    algToKeyType
  };
  var assert = requireAssert();
  var Buffer2 = requireSafer().Buffer;
  var algs2 = requireAlgs();
  var utils2 = requireUtils$3();
  var Key = requireKey();
  var PrivateKey = requirePrivateKey();
  var SSHBuffer = requireSshBuffer();
  function algToKeyType(alg) {
    assert.string(alg);
    if (alg === "ssh-dss")
      return "dsa";
    else if (alg === "ssh-rsa")
      return "rsa";
    else if (alg === "ssh-ed25519")
      return "ed25519";
    else if (alg === "ssh-curve25519")
      return "curve25519";
    else if (alg.match(/^ecdsa-sha2-/))
      return "ecdsa";
    else
      throw new Error("Unknown algorithm " + alg);
  }
  function keyTypeToAlg(key2) {
    assert.object(key2);
    if (key2.type === "dsa")
      return "ssh-dss";
    else if (key2.type === "rsa")
      return "ssh-rsa";
    else if (key2.type === "ed25519")
      return "ssh-ed25519";
    else if (key2.type === "curve25519")
      return "ssh-curve25519";
    else if (key2.type === "ecdsa")
      return "ecdsa-sha2-" + key2.part.curve.data.toString();
    else
      throw new Error("Unknown key type " + key2.type);
  }
  function read(partial, type2, buf, options) {
    if (typeof buf === "string")
      buf = Buffer2.from(buf);
    assert.buffer(buf, "buf");
    var key2 = {};
    var parts = key2.parts = [];
    var sshbuf = new SSHBuffer({ buffer: buf });
    var alg = sshbuf.readString();
    assert.ok(!sshbuf.atEnd(), "key must have at least one part");
    key2.type = algToKeyType(alg);
    var partCount = algs2.info[key2.type].parts.length;
    if (type2 && type2 === "private")
      partCount = algs2.privInfo[key2.type].parts.length;
    while (!sshbuf.atEnd() && parts.length < partCount)
      parts.push(sshbuf.readPart());
    while (!partial && !sshbuf.atEnd())
      parts.push(sshbuf.readPart());
    assert.ok(
      parts.length >= 1,
      "key must have at least one part"
    );
    assert.ok(
      partial || sshbuf.atEnd(),
      "leftover bytes at end of key"
    );
    var Constructor = Key;
    var algInfo = algs2.info[key2.type];
    if (type2 === "private" || algInfo.parts.length !== parts.length) {
      algInfo = algs2.privInfo[key2.type];
      Constructor = PrivateKey;
    }
    assert.strictEqual(algInfo.parts.length, parts.length);
    if (key2.type === "ecdsa") {
      var res = /^ecdsa-sha2-(.+)$/.exec(alg);
      assert.ok(res !== null);
      assert.strictEqual(res[1], parts[0].data.toString());
    }
    var normalized = true;
    for (var i = 0; i < algInfo.parts.length; ++i) {
      var p = parts[i];
      p.name = algInfo.parts[i];
      if (key2.type === "ed25519" && p.name === "k")
        p.data = p.data.slice(0, 32);
      if (p.name !== "curve" && algInfo.normalize !== false) {
        var nd;
        if (key2.type === "ed25519") {
          nd = utils2.zeroPadToLength(p.data, 32);
        } else {
          nd = utils2.mpNormalize(p.data);
        }
        if (nd.toString("binary") !== p.data.toString("binary")) {
          p.data = nd;
          normalized = false;
        }
      }
    }
    if (normalized)
      key2._rfc4253Cache = sshbuf.toBuffer();
    if (partial && typeof partial === "object") {
      partial.remainder = sshbuf.remainder();
      partial.consumed = sshbuf._offset;
    }
    return new Constructor(key2);
  }
  function write(key2, options) {
    assert.object(key2);
    var alg = keyTypeToAlg(key2);
    var i;
    var algInfo = algs2.info[key2.type];
    if (PrivateKey.isPrivateKey(key2))
      algInfo = algs2.privInfo[key2.type];
    var parts = algInfo.parts;
    var buf = new SSHBuffer({});
    buf.writeString(alg);
    for (i = 0; i < parts.length; ++i) {
      var data2 = key2.part[parts[i]].data;
      if (algInfo.normalize !== false) {
        if (key2.type === "ed25519")
          data2 = utils2.zeroPadToLength(data2, 32);
        else
          data2 = utils2.mpNormalize(data2);
      }
      if (key2.type === "ed25519" && parts[i] === "k")
        data2 = Buffer2.concat([data2, key2.part.A.data]);
      buf.writeBuffer(data2);
    }
    return buf.toBuffer();
  }
  return rfc4253;
}
var bcryptPbkdf;
var hasRequiredBcryptPbkdf;
function requireBcryptPbkdf() {
  if (hasRequiredBcryptPbkdf) return bcryptPbkdf;
  hasRequiredBcryptPbkdf = 1;
  var crypto_hash_sha512 = requireNaclFast().lowlevel.crypto_hash;
  var BLF_J = 0;
  var Blowfish = function() {
    this.S = [
      new Uint32Array([
        3509652390,
        2564797868,
        805139163,
        3491422135,
        3101798381,
        1780907670,
        3128725573,
        4046225305,
        614570311,
        3012652279,
        134345442,
        2240740374,
        1667834072,
        1901547113,
        2757295779,
        4103290238,
        227898511,
        1921955416,
        1904987480,
        2182433518,
        2069144605,
        3260701109,
        2620446009,
        720527379,
        3318853667,
        677414384,
        3393288472,
        3101374703,
        2390351024,
        1614419982,
        1822297739,
        2954791486,
        3608508353,
        3174124327,
        2024746970,
        1432378464,
        3864339955,
        2857741204,
        1464375394,
        1676153920,
        1439316330,
        715854006,
        3033291828,
        289532110,
        2706671279,
        2087905683,
        3018724369,
        1668267050,
        732546397,
        1947742710,
        3462151702,
        2609353502,
        2950085171,
        1814351708,
        2050118529,
        680887927,
        999245976,
        1800124847,
        3300911131,
        1713906067,
        1641548236,
        4213287313,
        1216130144,
        1575780402,
        4018429277,
        3917837745,
        3693486850,
        3949271944,
        596196993,
        3549867205,
        258830323,
        2213823033,
        772490370,
        2760122372,
        1774776394,
        2652871518,
        566650946,
        4142492826,
        1728879713,
        2882767088,
        1783734482,
        3629395816,
        2517608232,
        2874225571,
        1861159788,
        326777828,
        3124490320,
        2130389656,
        2716951837,
        967770486,
        1724537150,
        2185432712,
        2364442137,
        1164943284,
        2105845187,
        998989502,
        3765401048,
        2244026483,
        1075463327,
        1455516326,
        1322494562,
        910128902,
        469688178,
        1117454909,
        936433444,
        3490320968,
        3675253459,
        1240580251,
        122909385,
        2157517691,
        634681816,
        4142456567,
        3825094682,
        3061402683,
        2540495037,
        79693498,
        3249098678,
        1084186820,
        1583128258,
        426386531,
        1761308591,
        1047286709,
        322548459,
        995290223,
        1845252383,
        2603652396,
        3431023940,
        2942221577,
        3202600964,
        3727903485,
        1712269319,
        422464435,
        3234572375,
        1170764815,
        3523960633,
        3117677531,
        1434042557,
        442511882,
        3600875718,
        1076654713,
        1738483198,
        4213154764,
        2393238008,
        3677496056,
        1014306527,
        4251020053,
        793779912,
        2902807211,
        842905082,
        4246964064,
        1395751752,
        1040244610,
        2656851899,
        3396308128,
        445077038,
        3742853595,
        3577915638,
        679411651,
        2892444358,
        2354009459,
        1767581616,
        3150600392,
        3791627101,
        3102740896,
        284835224,
        4246832056,
        1258075500,
        768725851,
        2589189241,
        3069724005,
        3532540348,
        1274779536,
        3789419226,
        2764799539,
        1660621633,
        3471099624,
        4011903706,
        913787905,
        3497959166,
        737222580,
        2514213453,
        2928710040,
        3937242737,
        1804850592,
        3499020752,
        2949064160,
        2386320175,
        2390070455,
        2415321851,
        4061277028,
        2290661394,
        2416832540,
        1336762016,
        1754252060,
        3520065937,
        3014181293,
        791618072,
        3188594551,
        3933548030,
        2332172193,
        3852520463,
        3043980520,
        413987798,
        3465142937,
        3030929376,
        4245938359,
        2093235073,
        3534596313,
        375366246,
        2157278981,
        2479649556,
        555357303,
        3870105701,
        2008414854,
        3344188149,
        4221384143,
        3956125452,
        2067696032,
        3594591187,
        2921233993,
        2428461,
        544322398,
        577241275,
        1471733935,
        610547355,
        4027169054,
        1432588573,
        1507829418,
        2025931657,
        3646575487,
        545086370,
        48609733,
        2200306550,
        1653985193,
        298326376,
        1316178497,
        3007786442,
        2064951626,
        458293330,
        2589141269,
        3591329599,
        3164325604,
        727753846,
        2179363840,
        146436021,
        1461446943,
        4069977195,
        705550613,
        3059967265,
        3887724982,
        4281599278,
        3313849956,
        1404054877,
        2845806497,
        146425753,
        1854211946
      ]),
      new Uint32Array([
        1266315497,
        3048417604,
        3681880366,
        3289982499,
        290971e4,
        1235738493,
        2632868024,
        2414719590,
        3970600049,
        1771706367,
        1449415276,
        3266420449,
        422970021,
        1963543593,
        2690192192,
        3826793022,
        1062508698,
        1531092325,
        1804592342,
        2583117782,
        2714934279,
        4024971509,
        1294809318,
        4028980673,
        1289560198,
        2221992742,
        1669523910,
        35572830,
        157838143,
        1052438473,
        1016535060,
        1802137761,
        1753167236,
        1386275462,
        3080475397,
        2857371447,
        1040679964,
        2145300060,
        2390574316,
        1461121720,
        2956646967,
        4031777805,
        4028374788,
        33600511,
        2920084762,
        1018524850,
        629373528,
        3691585981,
        3515945977,
        2091462646,
        2486323059,
        586499841,
        988145025,
        935516892,
        3367335476,
        2599673255,
        2839830854,
        265290510,
        3972581182,
        2759138881,
        3795373465,
        1005194799,
        847297441,
        406762289,
        1314163512,
        1332590856,
        1866599683,
        4127851711,
        750260880,
        613907577,
        1450815602,
        3165620655,
        3734664991,
        3650291728,
        3012275730,
        3704569646,
        1427272223,
        778793252,
        1343938022,
        2676280711,
        2052605720,
        1946737175,
        3164576444,
        3914038668,
        3967478842,
        3682934266,
        1661551462,
        3294938066,
        4011595847,
        840292616,
        3712170807,
        616741398,
        312560963,
        711312465,
        1351876610,
        322626781,
        1910503582,
        271666773,
        2175563734,
        1594956187,
        70604529,
        3617834859,
        1007753275,
        1495573769,
        4069517037,
        2549218298,
        2663038764,
        504708206,
        2263041392,
        3941167025,
        2249088522,
        1514023603,
        1998579484,
        1312622330,
        694541497,
        2582060303,
        2151582166,
        1382467621,
        776784248,
        2618340202,
        3323268794,
        2497899128,
        2784771155,
        503983604,
        4076293799,
        907881277,
        423175695,
        432175456,
        1378068232,
        4145222326,
        3954048622,
        3938656102,
        3820766613,
        2793130115,
        2977904593,
        26017576,
        3274890735,
        3194772133,
        1700274565,
        1756076034,
        4006520079,
        3677328699,
        720338349,
        1533947780,
        354530856,
        688349552,
        3973924725,
        1637815568,
        332179504,
        3949051286,
        53804574,
        2852348879,
        3044236432,
        1282449977,
        3583942155,
        3416972820,
        4006381244,
        1617046695,
        2628476075,
        3002303598,
        1686838959,
        431878346,
        2686675385,
        1700445008,
        1080580658,
        1009431731,
        832498133,
        3223435511,
        2605976345,
        2271191193,
        2516031870,
        1648197032,
        4164389018,
        2548247927,
        300782431,
        375919233,
        238389289,
        3353747414,
        2531188641,
        2019080857,
        1475708069,
        455242339,
        2609103871,
        448939670,
        3451063019,
        1395535956,
        2413381860,
        1841049896,
        1491858159,
        885456874,
        4264095073,
        4001119347,
        1565136089,
        3898914787,
        1108368660,
        540939232,
        1173283510,
        2745871338,
        3681308437,
        4207628240,
        3343053890,
        4016749493,
        1699691293,
        1103962373,
        3625875870,
        2256883143,
        3830138730,
        1031889488,
        3479347698,
        1535977030,
        4236805024,
        3251091107,
        2132092099,
        1774941330,
        1199868427,
        1452454533,
        157007616,
        2904115357,
        342012276,
        595725824,
        1480756522,
        206960106,
        497939518,
        591360097,
        863170706,
        2375253569,
        3596610801,
        1814182875,
        2094937945,
        3421402208,
        1082520231,
        3463918190,
        2785509508,
        435703966,
        3908032597,
        1641649973,
        2842273706,
        3305899714,
        1510255612,
        2148256476,
        2655287854,
        3276092548,
        4258621189,
        236887753,
        3681803219,
        274041037,
        1734335097,
        3815195456,
        3317970021,
        1899903192,
        1026095262,
        4050517792,
        356393447,
        2410691914,
        3873677099,
        3682840055
      ]),
      new Uint32Array([
        3913112168,
        2491498743,
        4132185628,
        2489919796,
        1091903735,
        1979897079,
        3170134830,
        3567386728,
        3557303409,
        857797738,
        1136121015,
        1342202287,
        507115054,
        2535736646,
        337727348,
        3213592640,
        1301675037,
        2528481711,
        1895095763,
        1721773893,
        3216771564,
        62756741,
        2142006736,
        835421444,
        2531993523,
        1442658625,
        3659876326,
        2882144922,
        676362277,
        1392781812,
        170690266,
        3921047035,
        1759253602,
        3611846912,
        1745797284,
        664899054,
        1329594018,
        3901205900,
        3045908486,
        2062866102,
        2865634940,
        3543621612,
        3464012697,
        1080764994,
        553557557,
        3656615353,
        3996768171,
        991055499,
        499776247,
        1265440854,
        648242737,
        3940784050,
        980351604,
        3713745714,
        1749149687,
        3396870395,
        4211799374,
        3640570775,
        1161844396,
        3125318951,
        1431517754,
        545492359,
        4268468663,
        3499529547,
        1437099964,
        2702547544,
        3433638243,
        2581715763,
        2787789398,
        1060185593,
        1593081372,
        2418618748,
        4260947970,
        69676912,
        2159744348,
        86519011,
        2512459080,
        3838209314,
        1220612927,
        3339683548,
        133810670,
        1090789135,
        1078426020,
        1569222167,
        845107691,
        3583754449,
        4072456591,
        1091646820,
        628848692,
        1613405280,
        3757631651,
        526609435,
        236106946,
        48312990,
        2942717905,
        3402727701,
        1797494240,
        859738849,
        992217954,
        4005476642,
        2243076622,
        3870952857,
        3732016268,
        765654824,
        3490871365,
        2511836413,
        1685915746,
        3888969200,
        1414112111,
        2273134842,
        3281911079,
        4080962846,
        172450625,
        2569994100,
        980381355,
        4109958455,
        2819808352,
        2716589560,
        2568741196,
        3681446669,
        3329971472,
        1835478071,
        660984891,
        3704678404,
        4045999559,
        3422617507,
        3040415634,
        1762651403,
        1719377915,
        3470491036,
        2693910283,
        3642056355,
        3138596744,
        1364962596,
        2073328063,
        1983633131,
        926494387,
        3423689081,
        2150032023,
        4096667949,
        1749200295,
        3328846651,
        309677260,
        2016342300,
        1779581495,
        3079819751,
        111262694,
        1274766160,
        443224088,
        298511866,
        1025883608,
        3806446537,
        1145181785,
        168956806,
        3641502830,
        3584813610,
        1689216846,
        3666258015,
        3200248200,
        1692713982,
        2646376535,
        4042768518,
        1618508792,
        1610833997,
        3523052358,
        4130873264,
        2001055236,
        3610705100,
        2202168115,
        4028541809,
        2961195399,
        1006657119,
        2006996926,
        3186142756,
        1430667929,
        3210227297,
        1314452623,
        4074634658,
        4101304120,
        2273951170,
        1399257539,
        3367210612,
        3027628629,
        1190975929,
        2062231137,
        2333990788,
        2221543033,
        2438960610,
        1181637006,
        548689776,
        2362791313,
        3372408396,
        3104550113,
        3145860560,
        296247880,
        1970579870,
        3078560182,
        3769228297,
        1714227617,
        3291629107,
        3898220290,
        166772364,
        1251581989,
        493813264,
        448347421,
        195405023,
        2709975567,
        677966185,
        3703036547,
        1463355134,
        2715995803,
        1338867538,
        1343315457,
        2802222074,
        2684532164,
        233230375,
        2599980071,
        2000651841,
        3277868038,
        1638401717,
        4028070440,
        3237316320,
        6314154,
        819756386,
        300326615,
        590932579,
        1405279636,
        3267499572,
        3150704214,
        2428286686,
        3959192993,
        3461946742,
        1862657033,
        1266418056,
        963775037,
        2089974820,
        2263052895,
        1917689273,
        448879540,
        3550394620,
        3981727096,
        150775221,
        3627908307,
        1303187396,
        508620638,
        2975983352,
        2726630617,
        1817252668,
        1876281319,
        1457606340,
        908771278,
        3720792119,
        3617206836,
        2455994898,
        1729034894,
        1080033504
      ]),
      new Uint32Array([
        976866871,
        3556439503,
        2881648439,
        1522871579,
        1555064734,
        1336096578,
        3548522304,
        2579274686,
        3574697629,
        3205460757,
        3593280638,
        3338716283,
        3079412587,
        564236357,
        2993598910,
        1781952180,
        1464380207,
        3163844217,
        3332601554,
        1699332808,
        1393555694,
        1183702653,
        3581086237,
        1288719814,
        691649499,
        2847557200,
        2895455976,
        3193889540,
        2717570544,
        1781354906,
        1676643554,
        2592534050,
        3230253752,
        1126444790,
        2770207658,
        2633158820,
        2210423226,
        2615765581,
        2414155088,
        3127139286,
        673620729,
        2805611233,
        1269405062,
        4015350505,
        3341807571,
        4149409754,
        1057255273,
        2012875353,
        2162469141,
        2276492801,
        2601117357,
        993977747,
        3918593370,
        2654263191,
        753973209,
        36408145,
        2530585658,
        25011837,
        3520020182,
        2088578344,
        530523599,
        2918365339,
        1524020338,
        1518925132,
        3760827505,
        3759777254,
        1202760957,
        3985898139,
        3906192525,
        674977740,
        4174734889,
        2031300136,
        2019492241,
        3983892565,
        4153806404,
        3822280332,
        352677332,
        2297720250,
        60907813,
        90501309,
        3286998549,
        1016092578,
        2535922412,
        2839152426,
        457141659,
        509813237,
        4120667899,
        652014361,
        1966332200,
        2975202805,
        55981186,
        2327461051,
        676427537,
        3255491064,
        2882294119,
        3433927263,
        1307055953,
        942726286,
        933058658,
        2468411793,
        3933900994,
        4215176142,
        1361170020,
        2001714738,
        2830558078,
        3274259782,
        1222529897,
        1679025792,
        2729314320,
        3714953764,
        1770335741,
        151462246,
        3013232138,
        1682292957,
        1483529935,
        471910574,
        1539241949,
        458788160,
        3436315007,
        1807016891,
        3718408830,
        978976581,
        1043663428,
        3165965781,
        1927990952,
        4200891579,
        2372276910,
        3208408903,
        3533431907,
        1412390302,
        2931980059,
        4132332400,
        1947078029,
        3881505623,
        4168226417,
        2941484381,
        1077988104,
        1320477388,
        886195818,
        18198404,
        3786409e3,
        2509781533,
        112762804,
        3463356488,
        1866414978,
        891333506,
        18488651,
        661792760,
        1628790961,
        3885187036,
        3141171499,
        876946877,
        2693282273,
        1372485963,
        791857591,
        2686433993,
        3759982718,
        3167212022,
        3472953795,
        2716379847,
        445679433,
        3561995674,
        3504004811,
        3574258232,
        54117162,
        3331405415,
        2381918588,
        3769707343,
        4154350007,
        1140177722,
        4074052095,
        668550556,
        3214352940,
        367459370,
        261225585,
        2610173221,
        4209349473,
        3468074219,
        3265815641,
        314222801,
        3066103646,
        3808782860,
        282218597,
        3406013506,
        3773591054,
        379116347,
        1285071038,
        846784868,
        2669647154,
        3771962079,
        3550491691,
        2305946142,
        453669953,
        1268987020,
        3317592352,
        3279303384,
        3744833421,
        2610507566,
        3859509063,
        266596637,
        3847019092,
        517658769,
        3462560207,
        3443424879,
        370717030,
        4247526661,
        2224018117,
        4143653529,
        4112773975,
        2788324899,
        2477274417,
        1456262402,
        2901442914,
        1517677493,
        1846949527,
        2295493580,
        3734397586,
        2176403920,
        1280348187,
        1908823572,
        3871786941,
        846861322,
        1172426758,
        3287448474,
        3383383037,
        1655181056,
        3139813346,
        901632758,
        1897031941,
        2986607138,
        3066810236,
        3447102507,
        1393639104,
        373351379,
        950779232,
        625454576,
        3124240540,
        4148612726,
        2007998917,
        544563296,
        2244738638,
        2330496472,
        2058025392,
        1291430526,
        424198748,
        50039436,
        29584100,
        3605783033,
        2429876329,
        2791104160,
        1057563949,
        3255363231,
        3075367218,
        3463963227,
        1469046755,
        985887462
      ])
    ];
    this.P = new Uint32Array([
      608135816,
      2242054355,
      320440878,
      57701188,
      2752067618,
      698298832,
      137296536,
      3964562569,
      1160258022,
      953160567,
      3193202383,
      887688300,
      3232508343,
      3380367581,
      1065670069,
      3041331479,
      2450970073,
      2306472731
    ]);
  };
  function F(S, x8, i) {
    return (S[0][x8[i + 3]] + S[1][x8[i + 2]] ^ S[2][x8[i + 1]]) + S[3][x8[i]];
  }
  Blowfish.prototype.encipher = function(x, x8) {
    if (x8 === void 0) {
      x8 = new Uint8Array(x.buffer);
      if (x.byteOffset !== 0)
        x8 = x8.subarray(x.byteOffset);
    }
    x[0] ^= this.P[0];
    for (var i = 1; i < 16; i += 2) {
      x[1] ^= F(this.S, x8, 0) ^ this.P[i];
      x[0] ^= F(this.S, x8, 4) ^ this.P[i + 1];
    }
    var t = x[0];
    x[0] = x[1] ^ this.P[17];
    x[1] = t;
  };
  Blowfish.prototype.decipher = function(x) {
    var x8 = new Uint8Array(x.buffer);
    if (x.byteOffset !== 0)
      x8 = x8.subarray(x.byteOffset);
    x[0] ^= this.P[17];
    for (var i = 16; i > 0; i -= 2) {
      x[1] ^= F(this.S, x8, 0) ^ this.P[i];
      x[0] ^= F(this.S, x8, 4) ^ this.P[i - 1];
    }
    var t = x[0];
    x[0] = x[1] ^ this.P[0];
    x[1] = t;
  };
  function stream2word(data2, databytes) {
    var i, temp = 0;
    for (i = 0; i < 4; i++, BLF_J++) {
      if (BLF_J >= databytes) BLF_J = 0;
      temp = temp << 8 | data2[BLF_J];
    }
    return temp;
  }
  Blowfish.prototype.expand0state = function(key2, keybytes) {
    var d = new Uint32Array(2), i, k;
    var d8 = new Uint8Array(d.buffer);
    for (i = 0, BLF_J = 0; i < 18; i++) {
      this.P[i] ^= stream2word(key2, keybytes);
    }
    BLF_J = 0;
    for (i = 0; i < 18; i += 2) {
      this.encipher(d, d8);
      this.P[i] = d[0];
      this.P[i + 1] = d[1];
    }
    for (i = 0; i < 4; i++) {
      for (k = 0; k < 256; k += 2) {
        this.encipher(d, d8);
        this.S[i][k] = d[0];
        this.S[i][k + 1] = d[1];
      }
    }
  };
  Blowfish.prototype.expandstate = function(data2, databytes, key2, keybytes) {
    var d = new Uint32Array(2), i, k;
    for (i = 0, BLF_J = 0; i < 18; i++) {
      this.P[i] ^= stream2word(key2, keybytes);
    }
    for (i = 0, BLF_J = 0; i < 18; i += 2) {
      d[0] ^= stream2word(data2, databytes);
      d[1] ^= stream2word(data2, databytes);
      this.encipher(d);
      this.P[i] = d[0];
      this.P[i + 1] = d[1];
    }
    for (i = 0; i < 4; i++) {
      for (k = 0; k < 256; k += 2) {
        d[0] ^= stream2word(data2, databytes);
        d[1] ^= stream2word(data2, databytes);
        this.encipher(d);
        this.S[i][k] = d[0];
        this.S[i][k + 1] = d[1];
      }
    }
    BLF_J = 0;
  };
  Blowfish.prototype.enc = function(data2, blocks) {
    for (var i = 0; i < blocks; i++) {
      this.encipher(data2.subarray(i * 2));
    }
  };
  Blowfish.prototype.dec = function(data2, blocks) {
    for (var i = 0; i < blocks; i++) {
      this.decipher(data2.subarray(i * 2));
    }
  };
  var BCRYPT_BLOCKS = 8, BCRYPT_HASHSIZE = 32;
  function bcrypt_hash(sha2pass, sha2salt, out) {
    var state = new Blowfish(), cdata = new Uint32Array(BCRYPT_BLOCKS), i, ciphertext = new Uint8Array([
      79,
      120,
      121,
      99,
      104,
      114,
      111,
      109,
      97,
      116,
      105,
      99,
      66,
      108,
      111,
      119,
      102,
      105,
      115,
      104,
      83,
      119,
      97,
      116,
      68,
      121,
      110,
      97,
      109,
      105,
      116,
      101
    ]);
    state.expandstate(sha2salt, 64, sha2pass, 64);
    for (i = 0; i < 64; i++) {
      state.expand0state(sha2salt, 64);
      state.expand0state(sha2pass, 64);
    }
    for (i = 0; i < BCRYPT_BLOCKS; i++)
      cdata[i] = stream2word(ciphertext, ciphertext.byteLength);
    for (i = 0; i < 64; i++)
      state.enc(cdata, cdata.byteLength / 8);
    for (i = 0; i < BCRYPT_BLOCKS; i++) {
      out[4 * i + 3] = cdata[i] >>> 24;
      out[4 * i + 2] = cdata[i] >>> 16;
      out[4 * i + 1] = cdata[i] >>> 8;
      out[4 * i + 0] = cdata[i];
    }
  }
  function bcrypt_pbkdf(pass, passlen, salt, saltlen, key2, keylen, rounds) {
    var sha2pass = new Uint8Array(64), sha2salt = new Uint8Array(64), out = new Uint8Array(BCRYPT_HASHSIZE), tmpout = new Uint8Array(BCRYPT_HASHSIZE), countsalt = new Uint8Array(saltlen + 4), i, j, amt, stride, dest, count, origkeylen = keylen;
    if (rounds < 1)
      return -1;
    if (passlen === 0 || saltlen === 0 || keylen === 0 || keylen > out.byteLength * out.byteLength || saltlen > 1 << 20)
      return -1;
    stride = Math.floor((keylen + out.byteLength - 1) / out.byteLength);
    amt = Math.floor((keylen + stride - 1) / stride);
    for (i = 0; i < saltlen; i++)
      countsalt[i] = salt[i];
    crypto_hash_sha512(sha2pass, pass, passlen);
    for (count = 1; keylen > 0; count++) {
      countsalt[saltlen + 0] = count >>> 24;
      countsalt[saltlen + 1] = count >>> 16;
      countsalt[saltlen + 2] = count >>> 8;
      countsalt[saltlen + 3] = count;
      crypto_hash_sha512(sha2salt, countsalt, saltlen + 4);
      bcrypt_hash(sha2pass, sha2salt, tmpout);
      for (i = out.byteLength; i--; )
        out[i] = tmpout[i];
      for (i = 1; i < rounds; i++) {
        crypto_hash_sha512(sha2salt, tmpout, tmpout.byteLength);
        bcrypt_hash(sha2pass, sha2salt, tmpout);
        for (j = 0; j < out.byteLength; j++)
          out[j] ^= tmpout[j];
      }
      amt = Math.min(amt, keylen);
      for (i = 0; i < amt; i++) {
        dest = i * stride + (count - 1);
        if (dest >= origkeylen)
          break;
        key2[dest] = out[i];
      }
      keylen -= i;
    }
    return 0;
  }
  bcryptPbkdf = {
    BLOCKS: BCRYPT_BLOCKS,
    HASHSIZE: BCRYPT_HASHSIZE,
    hash: bcrypt_hash,
    pbkdf: bcrypt_pbkdf
  };
  return bcryptPbkdf;
}
var sshPrivate;
var hasRequiredSshPrivate;
function requireSshPrivate() {
  if (hasRequiredSshPrivate) return sshPrivate;
  hasRequiredSshPrivate = 1;
  sshPrivate = {
    read,
    readSSHPrivate,
    write
  };
  var assert = requireAssert();
  requireLib$4();
  var Buffer2 = requireSafer().Buffer;
  requireAlgs();
  var utils2 = requireUtils$3();
  var crypto = require$$0$9;
  requireKey();
  var PrivateKey = requirePrivateKey();
  var pem2 = requirePem();
  var rfc42532 = requireRfc4253();
  var SSHBuffer = requireSshBuffer();
  var errors2 = requireErrors$1();
  var bcrypt;
  function read(buf, options) {
    return pem2.read(buf, options);
  }
  var MAGIC = "openssh-key-v1";
  function readSSHPrivate(type2, buf, options) {
    buf = new SSHBuffer({ buffer: buf });
    var magic = buf.readCString();
    assert.strictEqual(magic, MAGIC, "bad magic string");
    var cipher = buf.readString();
    var kdf = buf.readString();
    var kdfOpts = buf.readBuffer();
    var nkeys = buf.readInt();
    if (nkeys !== 1) {
      throw new Error("OpenSSH-format key file contains multiple keys: this is unsupported.");
    }
    var pubKey = buf.readBuffer();
    if (type2 === "public") {
      assert.ok(buf.atEnd(), "excess bytes left after key");
      return rfc42532.read(pubKey);
    }
    var privKeyBlob = buf.readBuffer();
    assert.ok(buf.atEnd(), "excess bytes left after key");
    var kdfOptsBuf = new SSHBuffer({ buffer: kdfOpts });
    switch (kdf) {
      case "none":
        if (cipher !== "none") {
          throw new Error('OpenSSH-format key uses KDF "none" but specifies a cipher other than "none"');
        }
        break;
      case "bcrypt":
        var salt = kdfOptsBuf.readBuffer();
        var rounds = kdfOptsBuf.readInt();
        var cinf = utils2.opensshCipherInfo(cipher);
        if (bcrypt === void 0) {
          bcrypt = requireBcryptPbkdf();
        }
        if (typeof options.passphrase === "string") {
          options.passphrase = Buffer2.from(
            options.passphrase,
            "utf-8"
          );
        }
        if (!Buffer2.isBuffer(options.passphrase)) {
          throw new errors2.KeyEncryptedError(
            options.filename,
            "OpenSSH"
          );
        }
        var pass = new Uint8Array(options.passphrase);
        var salti = new Uint8Array(salt);
        var out = new Uint8Array(cinf.keySize + cinf.blockSize);
        var res = bcrypt.pbkdf(
          pass,
          pass.length,
          salti,
          salti.length,
          out,
          out.length,
          rounds
        );
        if (res !== 0) {
          throw new Error("bcrypt_pbkdf function returned failure, parameters invalid");
        }
        out = Buffer2.from(out);
        var ckey = out.slice(0, cinf.keySize);
        var iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize);
        var cipherStream = crypto.createDecipheriv(
          cinf.opensslName,
          ckey,
          iv
        );
        cipherStream.setAutoPadding(false);
        var chunk, chunks = [];
        cipherStream.once("error", function(e) {
          if (e.toString().indexOf("bad decrypt") !== -1) {
            throw new Error("Incorrect passphrase supplied, could not decrypt key");
          }
          throw e;
        });
        cipherStream.write(privKeyBlob);
        cipherStream.end();
        while ((chunk = cipherStream.read()) !== null)
          chunks.push(chunk);
        privKeyBlob = Buffer2.concat(chunks);
        break;
      default:
        throw new Error(
          'OpenSSH-format key uses unknown KDF "' + kdf + '"'
        );
    }
    buf = new SSHBuffer({ buffer: privKeyBlob });
    var checkInt1 = buf.readInt();
    var checkInt2 = buf.readInt();
    if (checkInt1 !== checkInt2) {
      throw new Error("Incorrect passphrase supplied, could not decrypt key");
    }
    var ret = {};
    var key2 = rfc42532.readInternal(ret, "private", buf.remainder());
    buf.skip(ret.consumed);
    var comment2 = buf.readString();
    key2.comment = comment2;
    return key2;
  }
  function write(key2, options) {
    var pubKey;
    if (PrivateKey.isPrivateKey(key2))
      pubKey = key2.toPublic();
    else
      pubKey = key2;
    var cipher = "none";
    var kdf = "none";
    var kdfopts = Buffer2.alloc(0);
    var cinf = { blockSize: 8 };
    var passphrase;
    if (options !== void 0) {
      passphrase = options.passphrase;
      if (typeof passphrase === "string")
        passphrase = Buffer2.from(passphrase, "utf-8");
      if (passphrase !== void 0) {
        assert.buffer(passphrase, "options.passphrase");
        assert.optionalString(options.cipher, "options.cipher");
        cipher = options.cipher;
        if (cipher === void 0)
          cipher = "aes128-ctr";
        cinf = utils2.opensshCipherInfo(cipher);
        kdf = "bcrypt";
      }
    }
    var privBuf;
    if (PrivateKey.isPrivateKey(key2)) {
      privBuf = new SSHBuffer({});
      var checkInt = crypto.randomBytes(4).readUInt32BE(0);
      privBuf.writeInt(checkInt);
      privBuf.writeInt(checkInt);
      privBuf.write(key2.toBuffer("rfc4253"));
      privBuf.writeString(key2.comment || "");
      var n = 1;
      while (privBuf._offset % cinf.blockSize !== 0)
        privBuf.writeChar(n++);
      privBuf = privBuf.toBuffer();
    }
    switch (kdf) {
      case "none":
        break;
      case "bcrypt":
        var salt = crypto.randomBytes(16);
        var rounds = 16;
        var kdfssh = new SSHBuffer({});
        kdfssh.writeBuffer(salt);
        kdfssh.writeInt(rounds);
        kdfopts = kdfssh.toBuffer();
        if (bcrypt === void 0) {
          bcrypt = requireBcryptPbkdf();
        }
        var pass = new Uint8Array(passphrase);
        var salti = new Uint8Array(salt);
        var out = new Uint8Array(cinf.keySize + cinf.blockSize);
        var res = bcrypt.pbkdf(
          pass,
          pass.length,
          salti,
          salti.length,
          out,
          out.length,
          rounds
        );
        if (res !== 0) {
          throw new Error("bcrypt_pbkdf function returned failure, parameters invalid");
        }
        out = Buffer2.from(out);
        var ckey = out.slice(0, cinf.keySize);
        var iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize);
        var cipherStream = crypto.createCipheriv(
          cinf.opensslName,
          ckey,
          iv
        );
        cipherStream.setAutoPadding(false);
        var chunk, chunks = [];
        cipherStream.once("error", function(e) {
          throw e;
        });
        cipherStream.write(privBuf);
        cipherStream.end();
        while ((chunk = cipherStream.read()) !== null)
          chunks.push(chunk);
        privBuf = Buffer2.concat(chunks);
        break;
      default:
        throw new Error("Unsupported kdf " + kdf);
    }
    var buf = new SSHBuffer({});
    buf.writeCString(MAGIC);
    buf.writeString(cipher);
    buf.writeString(kdf);
    buf.writeBuffer(kdfopts);
    buf.writeInt(1);
    buf.writeBuffer(pubKey.toBuffer("rfc4253"));
    if (privBuf)
      buf.writeBuffer(privBuf);
    buf = buf.toBuffer();
    var header;
    if (PrivateKey.isPrivateKey(key2))
      header = "OPENSSH PRIVATE KEY";
    else
      header = "OPENSSH PUBLIC KEY";
    var tmp = buf.toString("base64");
    var len = tmp.length + tmp.length / 70 + 18 + 16 + header.length * 2 + 10;
    buf = Buffer2.alloc(len);
    var o = 0;
    o += buf.write("-----BEGIN " + header + "-----\n", o);
    for (var i = 0; i < tmp.length; ) {
      var limit = i + 70;
      if (limit > tmp.length)
        limit = tmp.length;
      o += buf.write(tmp.slice(i, limit), o);
      buf[o++] = 10;
      i = limit;
    }
    o += buf.write("-----END " + header + "-----\n", o);
    return buf.slice(0, o);
  }
  return sshPrivate;
}
var pem;
var hasRequiredPem;
function requirePem() {
  if (hasRequiredPem) return pem;
  hasRequiredPem = 1;
  pem = {
    read,
    write
  };
  var assert = requireAssert();
  var asn1 = requireLib$4();
  var crypto = require$$0$9;
  var Buffer2 = requireSafer().Buffer;
  requireAlgs();
  var utils2 = requireUtils$3();
  var Key = requireKey();
  var PrivateKey = requirePrivateKey();
  var pkcs12 = requirePkcs1();
  var pkcs82 = requirePkcs8();
  var sshpriv = requireSshPrivate();
  var rfc42532 = requireRfc4253();
  var errors2 = requireErrors$1();
  var OID_PBES2 = "1.2.840.113549.1.5.13";
  var OID_PBKDF2 = "1.2.840.113549.1.5.12";
  var OID_TO_CIPHER = {
    "1.2.840.113549.3.7": "3des-cbc",
    "2.16.840.1.101.3.4.1.2": "aes128-cbc",
    "2.16.840.1.101.3.4.1.42": "aes256-cbc"
  };
  Object.keys(OID_TO_CIPHER).forEach(function(k) {
  });
  var OID_TO_HASH = {
    "1.2.840.113549.2.7": "sha1",
    "1.2.840.113549.2.9": "sha256",
    "1.2.840.113549.2.11": "sha512"
  };
  Object.keys(OID_TO_HASH).forEach(function(k) {
  });
  function read(buf, options, forceType) {
    var input = buf;
    if (typeof buf !== "string") {
      assert.buffer(buf, "buf");
      buf = buf.toString("ascii");
    }
    var lines = buf.trim().split(/[\r\n]+/g);
    var m;
    var si = -1;
    while (!m && si < lines.length) {
      m = lines[++si].match(
        /*JSSTYLED*/
        /[-]+[ ]*BEGIN ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/
      );
    }
    assert.ok(m, "invalid PEM header");
    var m2;
    var ei = lines.length;
    while (!m2 && ei > 0) {
      m2 = lines[--ei].match(
        /*JSSTYLED*/
        /[-]+[ ]*END ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/
      );
    }
    assert.ok(m2, "invalid PEM footer");
    assert.equal(m[2], m2[2]);
    var type2 = m[2].toLowerCase();
    var alg;
    if (m[1]) {
      assert.equal(m[1], m2[1], "PEM header and footer mismatch");
      alg = m[1].trim();
    }
    lines = lines.slice(si, ei + 1);
    var headers = {};
    while (true) {
      lines = lines.slice(1);
      m = lines[0].match(
        /*JSSTYLED*/
        /^([A-Za-z0-9-]+): (.+)$/
      );
      if (!m)
        break;
      headers[m[1].toLowerCase()] = m[2];
    }
    lines = lines.slice(0, -1).join("");
    buf = Buffer2.from(lines, "base64");
    var cipher, key2, iv;
    if (headers["proc-type"]) {
      var parts = headers["proc-type"].split(",");
      if (parts[0] === "4" && parts[1] === "ENCRYPTED") {
        if (typeof options.passphrase === "string") {
          options.passphrase = Buffer2.from(
            options.passphrase,
            "utf-8"
          );
        }
        if (!Buffer2.isBuffer(options.passphrase)) {
          throw new errors2.KeyEncryptedError(
            options.filename,
            "PEM"
          );
        } else {
          parts = headers["dek-info"].split(",");
          assert.ok(parts.length === 2);
          cipher = parts[0].toLowerCase();
          iv = Buffer2.from(parts[1], "hex");
          key2 = utils2.opensslKeyDeriv(
            cipher,
            iv,
            options.passphrase,
            1
          ).key;
        }
      }
    }
    if (alg && alg.toLowerCase() === "encrypted") {
      var eder = new asn1.BerReader(buf);
      var pbesEnd;
      eder.readSequence();
      eder.readSequence();
      pbesEnd = eder.offset + eder.length;
      var method = eder.readOID();
      if (method !== OID_PBES2) {
        throw new Error("Unsupported PEM/PKCS8 encryption scheme: " + method);
      }
      eder.readSequence();
      eder.readSequence();
      var kdfEnd = eder.offset + eder.length;
      var kdfOid = eder.readOID();
      if (kdfOid !== OID_PBKDF2)
        throw new Error("Unsupported PBES2 KDF: " + kdfOid);
      eder.readSequence();
      var salt = eder.readString(asn1.Ber.OctetString, true);
      var iterations = eder.readInt();
      var hashAlg = "sha1";
      if (eder.offset < kdfEnd) {
        eder.readSequence();
        var hashAlgOid = eder.readOID();
        hashAlg = OID_TO_HASH[hashAlgOid];
        if (hashAlg === void 0) {
          throw new Error("Unsupported PBKDF2 hash: " + hashAlgOid);
        }
      }
      eder._offset = kdfEnd;
      eder.readSequence();
      var cipherOid = eder.readOID();
      cipher = OID_TO_CIPHER[cipherOid];
      if (cipher === void 0) {
        throw new Error("Unsupported PBES2 cipher: " + cipherOid);
      }
      iv = eder.readString(asn1.Ber.OctetString, true);
      eder._offset = pbesEnd;
      buf = eder.readString(asn1.Ber.OctetString, true);
      if (typeof options.passphrase === "string") {
        options.passphrase = Buffer2.from(
          options.passphrase,
          "utf-8"
        );
      }
      if (!Buffer2.isBuffer(options.passphrase)) {
        throw new errors2.KeyEncryptedError(
          options.filename,
          "PEM"
        );
      }
      var cinfo = utils2.opensshCipherInfo(cipher);
      cipher = cinfo.opensslName;
      key2 = utils2.pbkdf2(
        hashAlg,
        salt,
        iterations,
        cinfo.keySize,
        options.passphrase
      );
      alg = void 0;
    }
    if (cipher && key2 && iv) {
      var cipherStream = crypto.createDecipheriv(cipher, key2, iv);
      var chunk, chunks = [];
      cipherStream.once("error", function(e) {
        if (e.toString().indexOf("bad decrypt") !== -1) {
          throw new Error("Incorrect passphrase supplied, could not decrypt key");
        }
        throw e;
      });
      cipherStream.write(buf);
      cipherStream.end();
      while ((chunk = cipherStream.read()) !== null)
        chunks.push(chunk);
      buf = Buffer2.concat(chunks);
    }
    if (alg && alg.toLowerCase() === "openssh")
      return sshpriv.readSSHPrivate(type2, buf, options);
    if (alg && alg.toLowerCase() === "ssh2")
      return rfc42532.readType(type2, buf, options);
    var der = new asn1.BerReader(buf);
    der.originalInput = input;
    der.readSequence();
    if (alg) {
      if (forceType)
        assert.strictEqual(forceType, "pkcs1");
      return pkcs12.readPkcs1(alg, type2, der);
    } else {
      if (forceType)
        assert.strictEqual(forceType, "pkcs8");
      return pkcs82.readPkcs8(alg, type2, der);
    }
  }
  function write(key2, options, type2) {
    assert.object(key2);
    var alg = {
      "ecdsa": "EC",
      "rsa": "RSA",
      "dsa": "DSA",
      "ed25519": "EdDSA"
    }[key2.type];
    var header;
    var der = new asn1.BerWriter();
    if (PrivateKey.isPrivateKey(key2)) {
      if (type2 && type2 === "pkcs8") {
        header = "PRIVATE KEY";
        pkcs82.writePkcs8(der, key2);
      } else {
        if (type2)
          assert.strictEqual(type2, "pkcs1");
        header = alg + " PRIVATE KEY";
        pkcs12.writePkcs1(der, key2);
      }
    } else if (Key.isKey(key2)) {
      if (type2 && type2 === "pkcs1") {
        header = alg + " PUBLIC KEY";
        pkcs12.writePkcs1(der, key2);
      } else {
        if (type2)
          assert.strictEqual(type2, "pkcs8");
        header = "PUBLIC KEY";
        pkcs82.writePkcs8(der, key2);
      }
    } else {
      throw new Error("key is not a Key or PrivateKey");
    }
    var tmp = der.buffer.toString("base64");
    var len = tmp.length + tmp.length / 64 + 18 + 16 + header.length * 2 + 10;
    var buf = Buffer2.alloc(len);
    var o = 0;
    o += buf.write("-----BEGIN " + header + "-----\n", o);
    for (var i = 0; i < tmp.length; ) {
      var limit = i + 64;
      if (limit > tmp.length)
        limit = tmp.length;
      o += buf.write(tmp.slice(i, limit), o);
      buf[o++] = 10;
      i = limit;
    }
    o += buf.write("-----END " + header + "-----\n", o);
    return buf.slice(0, o);
  }
  return pem;
}
var ssh;
var hasRequiredSsh;
function requireSsh() {
  if (hasRequiredSsh) return ssh;
  hasRequiredSsh = 1;
  ssh = {
    read,
    write
  };
  var assert = requireAssert();
  var Buffer2 = requireSafer().Buffer;
  var rfc42532 = requireRfc4253();
  requireUtils$3();
  var Key = requireKey();
  requirePrivateKey();
  requireSshPrivate();
  var SSHKEY_RE = /^([a-z0-9-]+)[ \t]+([a-zA-Z0-9+\/]+[=]*)([ \t]+([^ \t][^\n]*[\n]*)?)?$/;
  var SSHKEY_RE2 = /^([a-z0-9-]+)[ \t\n]+([a-zA-Z0-9+\/][a-zA-Z0-9+\/ \t\n=]*)([^a-zA-Z0-9+\/ \t\n=].*)?$/;
  function read(buf, options) {
    if (typeof buf !== "string") {
      assert.buffer(buf, "buf");
      buf = buf.toString("ascii");
    }
    var trimmed = buf.trim().replace(/[\\\r]/g, "");
    var m = trimmed.match(SSHKEY_RE);
    if (!m)
      m = trimmed.match(SSHKEY_RE2);
    assert.ok(m, "key must match regex");
    var type2 = rfc42532.algToKeyType(m[1]);
    var kbuf = Buffer2.from(m[2], "base64");
    var key2;
    var ret = {};
    if (m[4]) {
      try {
        key2 = rfc42532.read(kbuf);
      } catch (e) {
        m = trimmed.match(SSHKEY_RE2);
        assert.ok(m, "key must match regex");
        kbuf = Buffer2.from(m[2], "base64");
        key2 = rfc42532.readInternal(ret, "public", kbuf);
      }
    } else {
      key2 = rfc42532.readInternal(ret, "public", kbuf);
    }
    assert.strictEqual(type2, key2.type);
    if (m[4] && m[4].length > 0) {
      key2.comment = m[4];
    } else if (ret.consumed) {
      var data2 = m[2] + (m[3] ? m[3] : "");
      var realOffset = Math.ceil(ret.consumed / 3) * 4;
      data2 = data2.slice(0, realOffset - 2).replace(/[^a-zA-Z0-9+\/=]/g, "") + data2.slice(realOffset - 2);
      var padding = ret.consumed % 3;
      if (padding > 0 && data2.slice(realOffset - 1, realOffset) !== "=")
        realOffset--;
      while (data2.slice(realOffset, realOffset + 1) === "=")
        realOffset++;
      var trailer = data2.slice(realOffset);
      trailer = trailer.replace(/[\r\n]/g, " ").replace(/^\s+/, "");
      if (trailer.match(/^[a-zA-Z0-9]/))
        key2.comment = trailer;
    }
    return key2;
  }
  function write(key2, options) {
    assert.object(key2);
    if (!Key.isKey(key2))
      throw new Error("Must be a public key");
    var parts = [];
    var alg = rfc42532.keyTypeToAlg(key2);
    parts.push(alg);
    var buf = rfc42532.write(key2);
    parts.push(buf.toString("base64"));
    if (key2.comment)
      parts.push(key2.comment);
    return Buffer2.from(parts.join(" "));
  }
  return ssh;
}
var dnssec;
var hasRequiredDnssec;
function requireDnssec() {
  if (hasRequiredDnssec) return dnssec;
  hasRequiredDnssec = 1;
  dnssec = {
    read,
    write
  };
  var assert = requireAssert();
  var Buffer2 = requireSafer().Buffer;
  var Key = requireKey();
  var PrivateKey = requirePrivateKey();
  var utils2 = requireUtils$3();
  requireSshBuffer();
  requireDhe();
  var supportedAlgos = {
    "rsa-sha1": 5,
    "rsa-sha256": 8,
    "rsa-sha512": 10,
    "ecdsa-p256-sha256": 13,
    "ecdsa-p384-sha384": 14
    /*
     * ed25519 is hypothetically supported with id 15
     * but the common tools available don't appear to be
     * capable of generating/using ed25519 keys
     */
  };
  var supportedAlgosById = {};
  Object.keys(supportedAlgos).forEach(function(k) {
    supportedAlgosById[supportedAlgos[k]] = k.toUpperCase();
  });
  function read(buf, options) {
    if (typeof buf !== "string") {
      assert.buffer(buf, "buf");
      buf = buf.toString("ascii");
    }
    var lines = buf.split("\n");
    if (lines[0].match(/^Private-key-format\: v1/)) {
      var algElems = lines[1].split(" ");
      var algoNum = parseInt(algElems[1], 10);
      var algoName = algElems[2];
      if (!supportedAlgosById[algoNum])
        throw new Error("Unsupported algorithm: " + algoName);
      return readDNSSECPrivateKey(algoNum, lines.slice(2));
    }
    var line = 0;
    while (lines[line].match(/^\;/))
      line++;
    if ((lines[line].match(/\. IN KEY /) || lines[line].match(/\. IN DNSKEY /)) && lines[line + 1].length === 0) {
      return readRFC3110(lines[line]);
    }
    throw new Error("Cannot parse dnssec key");
  }
  function readRFC3110(keyString) {
    var elems = keyString.split(" ");
    var algorithm = parseInt(elems[5], 10);
    if (!supportedAlgosById[algorithm])
      throw new Error("Unsupported algorithm: " + algorithm);
    var base64key = elems.slice(6, elems.length).join();
    var keyBuffer = Buffer2.from(base64key, "base64");
    if (supportedAlgosById[algorithm].match(/^RSA-/)) {
      var publicExponentLen = keyBuffer.readUInt8(0);
      if (publicExponentLen != 3 && publicExponentLen != 1)
        throw new Error("Cannot parse dnssec key: unsupported exponent length");
      var publicExponent = keyBuffer.slice(1, publicExponentLen + 1);
      publicExponent = utils2.mpNormalize(publicExponent);
      var modulus = keyBuffer.slice(1 + publicExponentLen);
      modulus = utils2.mpNormalize(modulus);
      var rsaKey = {
        type: "rsa",
        parts: []
      };
      rsaKey.parts.push({ name: "e", data: publicExponent });
      rsaKey.parts.push({ name: "n", data: modulus });
      return new Key(rsaKey);
    }
    if (supportedAlgosById[algorithm] === "ECDSA-P384-SHA384" || supportedAlgosById[algorithm] === "ECDSA-P256-SHA256") {
      var curve = "nistp384";
      var size = 384;
      if (supportedAlgosById[algorithm].match(/^ECDSA-P256-SHA256/)) {
        curve = "nistp256";
        size = 256;
      }
      var ecdsaKey = {
        type: "ecdsa",
        curve,
        size,
        parts: [
          { name: "curve", data: Buffer2.from(curve) },
          { name: "Q", data: utils2.ecNormalize(keyBuffer) }
        ]
      };
      return new Key(ecdsaKey);
    }
    throw new Error("Unsupported algorithm: " + supportedAlgosById[algorithm]);
  }
  function elementToBuf(e) {
    return Buffer2.from(e.split(" ")[1], "base64");
  }
  function readDNSSECRSAPrivateKey(elements) {
    var rsaParams = {};
    elements.forEach(function(element) {
      if (element.split(" ")[0] === "Modulus:")
        rsaParams["n"] = elementToBuf(element);
      else if (element.split(" ")[0] === "PublicExponent:")
        rsaParams["e"] = elementToBuf(element);
      else if (element.split(" ")[0] === "PrivateExponent:")
        rsaParams["d"] = elementToBuf(element);
      else if (element.split(" ")[0] === "Prime1:")
        rsaParams["p"] = elementToBuf(element);
      else if (element.split(" ")[0] === "Prime2:")
        rsaParams["q"] = elementToBuf(element);
      else if (element.split(" ")[0] === "Exponent1:")
        rsaParams["dmodp"] = elementToBuf(element);
      else if (element.split(" ")[0] === "Exponent2:")
        rsaParams["dmodq"] = elementToBuf(element);
      else if (element.split(" ")[0] === "Coefficient:")
        rsaParams["iqmp"] = elementToBuf(element);
    });
    var key2 = {
      type: "rsa",
      parts: [
        { name: "e", data: utils2.mpNormalize(rsaParams["e"]) },
        { name: "n", data: utils2.mpNormalize(rsaParams["n"]) },
        { name: "d", data: utils2.mpNormalize(rsaParams["d"]) },
        { name: "p", data: utils2.mpNormalize(rsaParams["p"]) },
        { name: "q", data: utils2.mpNormalize(rsaParams["q"]) },
        {
          name: "dmodp",
          data: utils2.mpNormalize(rsaParams["dmodp"])
        },
        {
          name: "dmodq",
          data: utils2.mpNormalize(rsaParams["dmodq"])
        },
        {
          name: "iqmp",
          data: utils2.mpNormalize(rsaParams["iqmp"])
        }
      ]
    };
    return new PrivateKey(key2);
  }
  function readDNSSECPrivateKey(alg, elements) {
    if (supportedAlgosById[alg].match(/^RSA-/)) {
      return readDNSSECRSAPrivateKey(elements);
    }
    if (supportedAlgosById[alg] === "ECDSA-P384-SHA384" || supportedAlgosById[alg] === "ECDSA-P256-SHA256") {
      var d = Buffer2.from(elements[0].split(" ")[1], "base64");
      var curve = "nistp384";
      var size = 384;
      if (supportedAlgosById[alg] === "ECDSA-P256-SHA256") {
        curve = "nistp256";
        size = 256;
      }
      var publicKey = utils2.publicFromPrivateECDSA(curve, d);
      var Q = publicKey.part["Q"].data;
      var ecdsaKey = {
        type: "ecdsa",
        curve,
        size,
        parts: [
          { name: "curve", data: Buffer2.from(curve) },
          { name: "d", data: d },
          { name: "Q", data: Q }
        ]
      };
      return new PrivateKey(ecdsaKey);
    }
    throw new Error("Unsupported algorithm: " + supportedAlgosById[alg]);
  }
  function dnssecTimestamp(date) {
    var year = date.getFullYear() + "";
    var month = date.getMonth() + 1;
    var timestampStr = year + month + date.getUTCDate();
    timestampStr += "" + date.getUTCHours() + date.getUTCMinutes();
    timestampStr += date.getUTCSeconds();
    return timestampStr;
  }
  function rsaAlgFromOptions(opts) {
    if (!opts || !opts.hashAlgo || opts.hashAlgo === "sha1")
      return "5 (RSASHA1)";
    else if (opts.hashAlgo === "sha256")
      return "8 (RSASHA256)";
    else if (opts.hashAlgo === "sha512")
      return "10 (RSASHA512)";
    else
      throw new Error("Unknown or unsupported hash: " + opts.hashAlgo);
  }
  function writeRSA(key2, options) {
    if (!key2.part.dmodp || !key2.part.dmodq) {
      utils2.addRSAMissing(key2);
    }
    var out = "";
    out += "Private-key-format: v1.3\n";
    out += "Algorithm: " + rsaAlgFromOptions(options) + "\n";
    var n = utils2.mpDenormalize(key2.part["n"].data);
    out += "Modulus: " + n.toString("base64") + "\n";
    var e = utils2.mpDenormalize(key2.part["e"].data);
    out += "PublicExponent: " + e.toString("base64") + "\n";
    var d = utils2.mpDenormalize(key2.part["d"].data);
    out += "PrivateExponent: " + d.toString("base64") + "\n";
    var p = utils2.mpDenormalize(key2.part["p"].data);
    out += "Prime1: " + p.toString("base64") + "\n";
    var q2 = utils2.mpDenormalize(key2.part["q"].data);
    out += "Prime2: " + q2.toString("base64") + "\n";
    var dmodp = utils2.mpDenormalize(key2.part["dmodp"].data);
    out += "Exponent1: " + dmodp.toString("base64") + "\n";
    var dmodq = utils2.mpDenormalize(key2.part["dmodq"].data);
    out += "Exponent2: " + dmodq.toString("base64") + "\n";
    var iqmp = utils2.mpDenormalize(key2.part["iqmp"].data);
    out += "Coefficient: " + iqmp.toString("base64") + "\n";
    var timestamp = /* @__PURE__ */ new Date();
    out += "Created: " + dnssecTimestamp(timestamp) + "\n";
    out += "Publish: " + dnssecTimestamp(timestamp) + "\n";
    out += "Activate: " + dnssecTimestamp(timestamp) + "\n";
    return Buffer2.from(out, "ascii");
  }
  function writeECDSA(key2, options) {
    var out = "";
    out += "Private-key-format: v1.3\n";
    if (key2.curve === "nistp256") {
      out += "Algorithm: 13 (ECDSAP256SHA256)\n";
    } else if (key2.curve === "nistp384") {
      out += "Algorithm: 14 (ECDSAP384SHA384)\n";
    } else {
      throw new Error("Unsupported curve");
    }
    var base64Key = key2.part["d"].data.toString("base64");
    out += "PrivateKey: " + base64Key + "\n";
    var timestamp = /* @__PURE__ */ new Date();
    out += "Created: " + dnssecTimestamp(timestamp) + "\n";
    out += "Publish: " + dnssecTimestamp(timestamp) + "\n";
    out += "Activate: " + dnssecTimestamp(timestamp) + "\n";
    return Buffer2.from(out, "ascii");
  }
  function write(key2, options) {
    if (PrivateKey.isPrivateKey(key2)) {
      if (key2.type === "rsa") {
        return writeRSA(key2, options);
      } else if (key2.type === "ecdsa") {
        return writeECDSA(key2);
      } else {
        throw new Error("Unsupported algorithm: " + key2.type);
      }
    } else if (Key.isKey(key2)) {
      throw new Error('Format "dnssec" only supports writing private keys');
    } else {
      throw new Error("key is not a Key or PrivateKey");
    }
  }
  return dnssec;
}
var putty;
var hasRequiredPutty;
function requirePutty() {
  if (hasRequiredPutty) return putty;
  hasRequiredPutty = 1;
  putty = {
    read,
    write
  };
  var assert = requireAssert();
  var Buffer2 = requireSafer().Buffer;
  var rfc42532 = requireRfc4253();
  var Key = requireKey();
  var SSHBuffer = requireSshBuffer();
  var crypto = require$$0$9;
  var PrivateKey = requirePrivateKey();
  var errors2 = requireErrors$1();
  function read(buf, options) {
    var lines = buf.toString("ascii").split(/[\r\n]+/);
    var found = false;
    var parts;
    var si = 0;
    var formatVersion;
    while (si < lines.length) {
      parts = splitHeader(lines[si++]);
      if (parts) {
        formatVersion = {
          "putty-user-key-file-2": 2,
          "putty-user-key-file-3": 3
        }[parts[0].toLowerCase()];
        if (formatVersion) {
          found = true;
          break;
        }
      }
    }
    if (!found) {
      throw new Error("No PuTTY format first line found");
    }
    var alg = parts[1];
    parts = splitHeader(lines[si++]);
    assert.equal(parts[0].toLowerCase(), "encryption");
    var encryption = parts[1];
    parts = splitHeader(lines[si++]);
    assert.equal(parts[0].toLowerCase(), "comment");
    var comment2 = parts[1];
    parts = splitHeader(lines[si++]);
    assert.equal(parts[0].toLowerCase(), "public-lines");
    var publicLines = parseInt(parts[1], 10);
    if (!isFinite(publicLines) || publicLines < 0 || publicLines > lines.length) {
      throw new Error("Invalid public-lines count");
    }
    var publicBuf = Buffer2.from(
      lines.slice(si, si + publicLines).join(""),
      "base64"
    );
    var keyType = rfc42532.algToKeyType(alg);
    var key2 = rfc42532.read(publicBuf);
    if (key2.type !== keyType) {
      throw new Error("Outer key algorithm mismatch");
    }
    si += publicLines;
    if (lines[si]) {
      parts = splitHeader(lines[si++]);
      assert.equal(parts[0].toLowerCase(), "private-lines");
      var privateLines = parseInt(parts[1], 10);
      if (!isFinite(privateLines) || privateLines < 0 || privateLines > lines.length) {
        throw new Error("Invalid private-lines count");
      }
      var privateBuf = Buffer2.from(
        lines.slice(si, si + privateLines).join(""),
        "base64"
      );
      if (encryption !== "none" && formatVersion === 3) {
        throw new Error("Encrypted keys arenot supported for PuTTY format version 3");
      }
      if (encryption === "aes256-cbc") {
        if (!options.passphrase) {
          throw new errors2.KeyEncryptedError(
            options.filename,
            "PEM"
          );
        }
        var iv = Buffer2.alloc(16, 0);
        var decipher = crypto.createDecipheriv(
          "aes-256-cbc",
          derivePPK2EncryptionKey(options.passphrase),
          iv
        );
        decipher.setAutoPadding(false);
        privateBuf = Buffer2.concat([
          decipher.update(privateBuf),
          decipher.final()
        ]);
      }
      key2 = new PrivateKey(key2);
      if (key2.type !== keyType) {
        throw new Error("Outer key algorithm mismatch");
      }
      var sshbuf = new SSHBuffer({ buffer: privateBuf });
      var privateKeyParts;
      if (alg === "ssh-dss") {
        privateKeyParts = [{
          name: "x",
          data: sshbuf.readBuffer()
        }];
      } else if (alg === "ssh-rsa") {
        privateKeyParts = [
          { name: "d", data: sshbuf.readBuffer() },
          { name: "p", data: sshbuf.readBuffer() },
          { name: "q", data: sshbuf.readBuffer() },
          { name: "iqmp", data: sshbuf.readBuffer() }
        ];
      } else if (alg.match(/^ecdsa-sha2-nistp/)) {
        privateKeyParts = [{
          name: "d",
          data: sshbuf.readBuffer()
        }];
      } else if (alg === "ssh-ed25519") {
        privateKeyParts = [{
          name: "k",
          data: sshbuf.readBuffer()
        }];
      } else {
        throw new Error("Unsupported PPK key type: " + alg);
      }
      key2 = new PrivateKey({
        type: key2.type,
        parts: key2.parts.concat(privateKeyParts)
      });
    }
    key2.comment = comment2;
    return key2;
  }
  function derivePPK2EncryptionKey(passphrase) {
    var hash1 = crypto.createHash("sha1").update(Buffer2.concat([
      Buffer2.from([0, 0, 0, 0]),
      Buffer2.from(passphrase)
    ])).digest();
    var hash2 = crypto.createHash("sha1").update(Buffer2.concat([
      Buffer2.from([0, 0, 0, 1]),
      Buffer2.from(passphrase)
    ])).digest();
    return Buffer2.concat([hash1, hash2]).slice(0, 32);
  }
  function splitHeader(line) {
    var idx = line.indexOf(":");
    if (idx === -1)
      return null;
    var header = line.slice(0, idx);
    ++idx;
    while (line[idx] === " ")
      ++idx;
    var rest = line.slice(idx);
    return [header, rest];
  }
  function write(key2, options) {
    assert.object(key2);
    if (!Key.isKey(key2))
      throw new Error("Must be a public key");
    var alg = rfc42532.keyTypeToAlg(key2);
    var buf = rfc42532.write(key2);
    var comment2 = key2.comment || "";
    var b64 = buf.toString("base64");
    var lines = wrap(b64);
    lines.unshift("Public-Lines: " + lines.length);
    lines.unshift("Comment: " + comment2);
    lines.unshift("Encryption: none");
    lines.unshift("PuTTY-User-Key-File-2: " + alg);
    return Buffer2.from(lines.join("\n") + "\n");
  }
  function wrap(txt, len) {
    var lines = [];
    var pos = 0;
    while (pos < txt.length) {
      lines.push(txt.slice(pos, pos + 64));
      pos += 64;
    }
    return lines;
  }
  return putty;
}
var auto;
var hasRequiredAuto;
function requireAuto() {
  if (hasRequiredAuto) return auto;
  hasRequiredAuto = 1;
  auto = {
    read,
    write
  };
  var assert = requireAssert();
  var Buffer2 = requireSafer().Buffer;
  requireUtils$3();
  requireKey();
  requirePrivateKey();
  var pem2 = requirePem();
  var ssh2 = requireSsh();
  var rfc42532 = requireRfc4253();
  var dnssec2 = requireDnssec();
  var putty2 = requirePutty();
  var DNSSEC_PRIVKEY_HEADER_PREFIX = "Private-key-format: v1";
  function read(buf, options) {
    if (typeof buf === "string") {
      if (buf.trim().match(/^[-]+[ ]*BEGIN/))
        return pem2.read(buf, options);
      if (buf.match(/^\s*ssh-[a-z]/))
        return ssh2.read(buf, options);
      if (buf.match(/^\s*ecdsa-/))
        return ssh2.read(buf, options);
      if (buf.match(/^putty-user-key-file-2:/i))
        return putty2.read(buf, options);
      if (findDNSSECHeader(buf))
        return dnssec2.read(buf, options);
      buf = Buffer2.from(buf, "binary");
    } else {
      assert.buffer(buf);
      if (findPEMHeader(buf))
        return pem2.read(buf, options);
      if (findSSHHeader(buf))
        return ssh2.read(buf, options);
      if (findPuTTYHeader(buf))
        return putty2.read(buf, options);
      if (findDNSSECHeader(buf))
        return dnssec2.read(buf, options);
    }
    if (buf.readUInt32BE(0) < buf.length)
      return rfc42532.read(buf, options);
    throw new Error("Failed to auto-detect format of key");
  }
  function findPuTTYHeader(buf) {
    var offset = 0;
    while (offset < buf.length && (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9))
      ++offset;
    if (offset + 22 <= buf.length && buf.slice(offset, offset + 22).toString("ascii").toLowerCase() === "putty-user-key-file-2:")
      return true;
    return false;
  }
  function findSSHHeader(buf) {
    var offset = 0;
    while (offset < buf.length && (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9))
      ++offset;
    if (offset + 4 <= buf.length && buf.slice(offset, offset + 4).toString("ascii") === "ssh-")
      return true;
    if (offset + 6 <= buf.length && buf.slice(offset, offset + 6).toString("ascii") === "ecdsa-")
      return true;
    return false;
  }
  function findPEMHeader(buf) {
    var offset = 0;
    while (offset < buf.length && (buf[offset] === 32 || buf[offset] === 10))
      ++offset;
    if (buf[offset] !== 45)
      return false;
    while (offset < buf.length && buf[offset] === 45)
      ++offset;
    while (offset < buf.length && buf[offset] === 32)
      ++offset;
    if (offset + 5 > buf.length || buf.slice(offset, offset + 5).toString("ascii") !== "BEGIN")
      return false;
    return true;
  }
  function findDNSSECHeader(buf) {
    if (buf.length <= DNSSEC_PRIVKEY_HEADER_PREFIX.length)
      return false;
    var headerCheck = buf.slice(0, DNSSEC_PRIVKEY_HEADER_PREFIX.length);
    if (headerCheck.toString("ascii") === DNSSEC_PRIVKEY_HEADER_PREFIX)
      return true;
    if (typeof buf !== "string") {
      buf = buf.toString("ascii");
    }
    var lines = buf.split("\n");
    var line = 0;
    while (lines[line].match(/^\;/))
      line++;
    if (lines[line].toString("ascii").match(/\. IN KEY /))
      return true;
    if (lines[line].toString("ascii").match(/\. IN DNSKEY /))
      return true;
    return false;
  }
  function write(key2, options) {
    throw new Error('"auto" format cannot be used for writing');
  }
  return auto;
}
var privateKey;
var hasRequiredPrivateKey;
function requirePrivateKey() {
  if (hasRequiredPrivateKey) return privateKey;
  hasRequiredPrivateKey = 1;
  privateKey = PrivateKey;
  var assert = requireAssert();
  var Buffer2 = requireSafer().Buffer;
  var algs2 = requireAlgs();
  var crypto = require$$0$9;
  requireFingerprint();
  var Signature = requireSignature();
  var errs = requireErrors$1();
  var util2 = require$$0$5;
  var utils2 = requireUtils$3();
  var dhe2 = requireDhe();
  var generateECDSA = dhe2.generateECDSA;
  var generateED25519 = dhe2.generateED25519;
  var edCompat2 = requireEdCompat();
  var nacl = requireNaclFast();
  var Key = requireKey();
  errs.InvalidAlgorithmError;
  var KeyParseError = errs.KeyParseError;
  errs.KeyEncryptedError;
  var formats2 = {};
  formats2["auto"] = requireAuto();
  formats2["pem"] = requirePem();
  formats2["pkcs1"] = requirePkcs1();
  formats2["pkcs8"] = requirePkcs8();
  formats2["rfc4253"] = requireRfc4253();
  formats2["ssh-private"] = requireSshPrivate();
  formats2["openssh"] = formats2["ssh-private"];
  formats2["ssh"] = formats2["ssh-private"];
  formats2["dnssec"] = requireDnssec();
  formats2["putty"] = requirePutty();
  function PrivateKey(opts) {
    assert.object(opts, "options");
    Key.call(this, opts);
    this._pubCache = void 0;
  }
  util2.inherits(PrivateKey, Key);
  PrivateKey.formats = formats2;
  PrivateKey.prototype.toBuffer = function(format2, options) {
    if (format2 === void 0)
      format2 = "pkcs1";
    assert.string(format2, "format");
    assert.object(formats2[format2], "formats[format]");
    assert.optionalObject(options, "options");
    return formats2[format2].write(this, options);
  };
  PrivateKey.prototype.hash = function(algo, type2) {
    return this.toPublic().hash(algo, type2);
  };
  PrivateKey.prototype.fingerprint = function(algo, type2) {
    return this.toPublic().fingerprint(algo, type2);
  };
  PrivateKey.prototype.toPublic = function() {
    if (this._pubCache)
      return this._pubCache;
    var algInfo = algs2.info[this.type];
    var pubParts = [];
    for (var i = 0; i < algInfo.parts.length; ++i) {
      var p = algInfo.parts[i];
      pubParts.push(this.part[p]);
    }
    this._pubCache = new Key({
      type: this.type,
      source: this,
      parts: pubParts
    });
    if (this.comment)
      this._pubCache.comment = this.comment;
    return this._pubCache;
  };
  PrivateKey.prototype.derive = function(newType) {
    assert.string(newType, "type");
    var priv, pub, pair;
    if (this.type === "ed25519" && newType === "curve25519") {
      priv = this.part.k.data;
      if (priv[0] === 0)
        priv = priv.slice(1);
      pair = nacl.box.keyPair.fromSecretKey(new Uint8Array(priv));
      pub = Buffer2.from(pair.publicKey);
      return new PrivateKey({
        type: "curve25519",
        parts: [
          { name: "A", data: utils2.mpNormalize(pub) },
          { name: "k", data: utils2.mpNormalize(priv) }
        ]
      });
    } else if (this.type === "curve25519" && newType === "ed25519") {
      priv = this.part.k.data;
      if (priv[0] === 0)
        priv = priv.slice(1);
      pair = nacl.sign.keyPair.fromSeed(new Uint8Array(priv));
      pub = Buffer2.from(pair.publicKey);
      return new PrivateKey({
        type: "ed25519",
        parts: [
          { name: "A", data: utils2.mpNormalize(pub) },
          { name: "k", data: utils2.mpNormalize(priv) }
        ]
      });
    }
    throw new Error("Key derivation not supported from " + this.type + " to " + newType);
  };
  PrivateKey.prototype.createVerify = function(hashAlgo) {
    return this.toPublic().createVerify(hashAlgo);
  };
  PrivateKey.prototype.createSign = function(hashAlgo) {
    if (hashAlgo === void 0)
      hashAlgo = this.defaultHashAlgorithm();
    assert.string(hashAlgo, "hash algorithm");
    if (this.type === "ed25519" && edCompat2 !== void 0)
      return new edCompat2.Signer(this, hashAlgo);
    if (this.type === "curve25519")
      throw new Error("Curve25519 keys are not suitable for signing or verification");
    var v, nm, err;
    try {
      nm = hashAlgo.toUpperCase();
      v = crypto.createSign(nm);
    } catch (e) {
      err = e;
    }
    if (v === void 0 || err instanceof Error && err.message.match(/Unknown message digest/)) {
      nm = "RSA-";
      nm += hashAlgo.toUpperCase();
      v = crypto.createSign(nm);
    }
    assert.ok(v, "failed to create verifier");
    var oldSign = v.sign.bind(v);
    var key2 = this.toBuffer("pkcs1");
    var type2 = this.type;
    var curve = this.curve;
    v.sign = function() {
      var sig = oldSign(key2);
      if (typeof sig === "string")
        sig = Buffer2.from(sig, "binary");
      sig = Signature.parse(sig, type2, "asn1");
      sig.hashAlgorithm = hashAlgo;
      sig.curve = curve;
      return sig;
    };
    return v;
  };
  PrivateKey.parse = function(data2, format2, options) {
    if (typeof data2 !== "string")
      assert.buffer(data2, "data");
    if (format2 === void 0)
      format2 = "auto";
    assert.string(format2, "format");
    if (typeof options === "string")
      options = { filename: options };
    assert.optionalObject(options, "options");
    if (options === void 0)
      options = {};
    assert.optionalString(options.filename, "options.filename");
    if (options.filename === void 0)
      options.filename = "(unnamed)";
    assert.object(formats2[format2], "formats[format]");
    try {
      var k = formats2[format2].read(data2, options);
      assert.ok(k instanceof PrivateKey, "key is not a private key");
      if (!k.comment)
        k.comment = options.filename;
      return k;
    } catch (e) {
      if (e.name === "KeyEncryptedError")
        throw e;
      throw new KeyParseError(options.filename, format2, e);
    }
  };
  PrivateKey.isPrivateKey = function(obj, ver) {
    return utils2.isCompatible(obj, PrivateKey, ver);
  };
  PrivateKey.generate = function(type2, options) {
    if (options === void 0)
      options = {};
    assert.object(options, "options");
    switch (type2) {
      case "ecdsa":
        if (options.curve === void 0)
          options.curve = "nistp256";
        assert.string(options.curve, "options.curve");
        return generateECDSA(options.curve);
      case "ed25519":
        return generateED25519();
      default:
        throw new Error('Key generation not supported with key type "' + type2 + '"');
    }
  };
  PrivateKey.prototype._sshpkApiVersion = [1, 6];
  PrivateKey._oldVersionDetect = function(obj) {
    assert.func(obj.toPublic);
    assert.func(obj.createSign);
    if (obj.derive)
      return [1, 3];
    if (obj.defaultHashAlgorithm)
      return [1, 2];
    if (obj.formats["auto"])
      return [1, 1];
    return [1, 0];
  };
  return privateKey;
}
var identity;
var hasRequiredIdentity;
function requireIdentity() {
  if (hasRequiredIdentity) return identity;
  hasRequiredIdentity = 1;
  identity = Identity;
  var assert = requireAssert();
  requireAlgs();
  requireFingerprint();
  requireSignature();
  requireErrors$1();
  var utils2 = requireUtils$3();
  var asn1 = requireLib$4();
  var Buffer2 = requireSafer().Buffer;
  var DNS_NAME_RE = /^([*]|[a-z0-9][a-z0-9\-]{0,62})(?:\.([*]|[a-z0-9][a-z0-9\-]{0,62}))*$/i;
  var oids = {};
  oids.cn = "2.5.4.3";
  oids.o = "2.5.4.10";
  oids.ou = "2.5.4.11";
  oids.l = "2.5.4.7";
  oids.s = "2.5.4.8";
  oids.c = "2.5.4.6";
  oids.sn = "2.5.4.4";
  oids.postalCode = "2.5.4.17";
  oids.serialNumber = "2.5.4.5";
  oids.street = "2.5.4.9";
  oids.x500UniqueIdentifier = "2.5.4.45";
  oids.role = "2.5.4.72";
  oids.telephoneNumber = "2.5.4.20";
  oids.description = "2.5.4.13";
  oids.dc = "0.9.2342.19200300.100.1.25";
  oids.uid = "0.9.2342.19200300.100.1.1";
  oids.mail = "0.9.2342.19200300.100.1.3";
  oids.title = "2.5.4.12";
  oids.gn = "2.5.4.42";
  oids.initials = "2.5.4.43";
  oids.pseudonym = "2.5.4.65";
  oids.emailAddress = "1.2.840.113549.1.9.1";
  var unoids = {};
  Object.keys(oids).forEach(function(k) {
    unoids[oids[k]] = k;
  });
  function Identity(opts) {
    var self2 = this;
    assert.object(opts, "options");
    assert.arrayOfObject(opts.components, "options.components");
    this.components = opts.components;
    this.componentLookup = {};
    this.components.forEach(function(c) {
      if (c.name && !c.oid)
        c.oid = oids[c.name];
      if (c.oid && !c.name)
        c.name = unoids[c.oid];
      if (self2.componentLookup[c.name] === void 0)
        self2.componentLookup[c.name] = [];
      self2.componentLookup[c.name].push(c);
    });
    if (this.componentLookup.cn && this.componentLookup.cn.length > 0) {
      this.cn = this.componentLookup.cn[0].value;
    }
    assert.optionalString(opts.type, "options.type");
    if (opts.type === void 0) {
      if (this.components.length === 1 && this.componentLookup.cn && this.componentLookup.cn.length === 1 && this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {
        this.type = "host";
        this.hostname = this.componentLookup.cn[0].value;
      } else if (this.componentLookup.dc && this.components.length === this.componentLookup.dc.length) {
        this.type = "host";
        this.hostname = this.componentLookup.dc.map(
          function(c) {
            return c.value;
          }
        ).join(".");
      } else if (this.componentLookup.uid && this.components.length === this.componentLookup.uid.length) {
        this.type = "user";
        this.uid = this.componentLookup.uid[0].value;
      } else if (this.componentLookup.cn && this.componentLookup.cn.length === 1 && this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {
        this.type = "host";
        this.hostname = this.componentLookup.cn[0].value;
      } else if (this.componentLookup.uid && this.componentLookup.uid.length === 1) {
        this.type = "user";
        this.uid = this.componentLookup.uid[0].value;
      } else if (this.componentLookup.mail && this.componentLookup.mail.length === 1) {
        this.type = "email";
        this.email = this.componentLookup.mail[0].value;
      } else if (this.componentLookup.cn && this.componentLookup.cn.length === 1) {
        this.type = "user";
        this.uid = this.componentLookup.cn[0].value;
      } else {
        this.type = "unknown";
      }
    } else {
      this.type = opts.type;
      if (this.type === "host")
        this.hostname = opts.hostname;
      else if (this.type === "user")
        this.uid = opts.uid;
      else if (this.type === "email")
        this.email = opts.email;
      else
        throw new Error("Unknown type " + this.type);
    }
  }
  Identity.prototype.toString = function() {
    return this.components.map(function(c) {
      var n = c.name.toUpperCase();
      n = n.replace(/=/g, "\\=");
      var v = c.value;
      v = v.replace(/,/g, "\\,");
      return n + "=" + v;
    }).join(", ");
  };
  Identity.prototype.get = function(name, asArray) {
    assert.string(name, "name");
    var arr = this.componentLookup[name];
    if (arr === void 0 || arr.length === 0)
      return void 0;
    if (!asArray && arr.length > 1)
      throw new Error("Multiple values for attribute " + name);
    if (!asArray)
      return arr[0].value;
    return arr.map(function(c) {
      return c.value;
    });
  };
  Identity.prototype.toArray = function(idx) {
    return this.components.map(function(c) {
      return {
        name: c.name,
        value: c.value
      };
    });
  };
  var NOT_PRINTABLE = /[^a-zA-Z0-9 '(),+.\/:=?-]/;
  var NOT_IA5 = /[^\x00-\x7f]/;
  Identity.prototype.toAsn1 = function(der, tag) {
    der.startSequence(tag);
    this.components.forEach(function(c) {
      der.startSequence(asn1.Ber.Constructor | asn1.Ber.Set);
      der.startSequence();
      der.writeOID(c.oid);
      if (c.asn1type === asn1.Ber.Utf8String || c.value.match(NOT_IA5)) {
        var v = Buffer2.from(c.value, "utf8");
        der.writeBuffer(v, asn1.Ber.Utf8String);
      } else if (c.asn1type === asn1.Ber.IA5String || c.value.match(NOT_PRINTABLE)) {
        der.writeString(c.value, asn1.Ber.IA5String);
      } else {
        var type2 = asn1.Ber.PrintableString;
        if (c.asn1type !== void 0)
          type2 = c.asn1type;
        der.writeString(c.value, type2);
      }
      der.endSequence();
      der.endSequence();
    });
    der.endSequence();
  };
  function globMatch(a, b) {
    if (a === "**" || b === "**")
      return true;
    var aParts = a.split(".");
    var bParts = b.split(".");
    if (aParts.length !== bParts.length)
      return false;
    for (var i = 0; i < aParts.length; ++i) {
      if (aParts[i] === "*" || bParts[i] === "*")
        continue;
      if (aParts[i] !== bParts[i])
        return false;
    }
    return true;
  }
  Identity.prototype.equals = function(other) {
    if (!Identity.isIdentity(other, [1, 0]))
      return false;
    if (other.components.length !== this.components.length)
      return false;
    for (var i = 0; i < this.components.length; ++i) {
      if (this.components[i].oid !== other.components[i].oid)
        return false;
      if (!globMatch(
        this.components[i].value,
        other.components[i].value
      )) {
        return false;
      }
    }
    return true;
  };
  Identity.forHost = function(hostname) {
    assert.string(hostname, "hostname");
    return new Identity({
      type: "host",
      hostname,
      components: [{ name: "cn", value: hostname }]
    });
  };
  Identity.forUser = function(uid) {
    assert.string(uid, "uid");
    return new Identity({
      type: "user",
      uid,
      components: [{ name: "uid", value: uid }]
    });
  };
  Identity.forEmail = function(email) {
    assert.string(email, "email");
    return new Identity({
      type: "email",
      email,
      components: [{ name: "mail", value: email }]
    });
  };
  Identity.parseDN = function(dn) {
    assert.string(dn, "dn");
    var parts = [""];
    var idx = 0;
    var rem = dn;
    while (rem.length > 0) {
      var m;
      if ((m = /^,/.exec(rem)) !== null) {
        parts[++idx] = "";
        rem = rem.slice(m[0].length);
      } else if ((m = /^\\,/.exec(rem)) !== null) {
        parts[idx] += ",";
        rem = rem.slice(m[0].length);
      } else if ((m = /^\\./.exec(rem)) !== null) {
        parts[idx] += m[0];
        rem = rem.slice(m[0].length);
      } else if ((m = /^[^\\,]+/.exec(rem)) !== null) {
        parts[idx] += m[0];
        rem = rem.slice(m[0].length);
      } else {
        throw new Error("Failed to parse DN");
      }
    }
    var cmps = parts.map(function(c) {
      c = c.trim();
      var eqPos = c.indexOf("=");
      while (eqPos > 0 && c.charAt(eqPos - 1) === "\\")
        eqPos = c.indexOf("=", eqPos + 1);
      if (eqPos === -1) {
        throw new Error("Failed to parse DN");
      }
      var name = c.slice(0, eqPos).toLowerCase().replace(/\\=/g, "=");
      var value = c.slice(eqPos + 1);
      return { name, value };
    });
    return new Identity({ components: cmps });
  };
  Identity.fromArray = function(components) {
    assert.arrayOfObject(components, "components");
    components.forEach(function(cmp) {
      assert.object(cmp, "component");
      assert.string(cmp.name, "component.name");
      if (!Buffer2.isBuffer(cmp.value) && !(typeof cmp.value === "string")) {
        throw new Error("Invalid component value");
      }
    });
    return new Identity({ components });
  };
  Identity.parseAsn1 = function(der, top) {
    var components = [];
    der.readSequence(top);
    var end = der.offset + der.length;
    while (der.offset < end) {
      der.readSequence(asn1.Ber.Constructor | asn1.Ber.Set);
      var after = der.offset + der.length;
      der.readSequence();
      var oid = der.readOID();
      var type2 = der.peek();
      var value;
      switch (type2) {
        case asn1.Ber.PrintableString:
        case asn1.Ber.IA5String:
        case asn1.Ber.OctetString:
        case asn1.Ber.T61String:
          value = der.readString(type2);
          break;
        case asn1.Ber.Utf8String:
          value = der.readString(type2, true);
          value = value.toString("utf8");
          break;
        case asn1.Ber.CharacterString:
        case asn1.Ber.BMPString:
          value = der.readString(type2, true);
          value = value.toString("utf16le");
          break;
        default:
          throw new Error("Unknown asn1 type " + type2);
      }
      components.push({ oid, asn1type: type2, value });
      der._offset = after;
    }
    der._offset = end;
    return new Identity({
      components
    });
  };
  Identity.isIdentity = function(obj, ver) {
    return utils2.isCompatible(obj, Identity, ver);
  };
  Identity.prototype._sshpkApiVersion = [1, 0];
  Identity._oldVersionDetect = function(obj) {
    return [1, 0];
  };
  return identity;
}
var opensshCert;
var hasRequiredOpensshCert;
function requireOpensshCert() {
  if (hasRequiredOpensshCert) return opensshCert;
  hasRequiredOpensshCert = 1;
  opensshCert = {
    read,
    verify: verify2,
    sign,
    signAsync,
    write,
    /* Internal private API */
    fromBuffer,
    toBuffer
  };
  var assert = requireAssert();
  var SSHBuffer = requireSshBuffer();
  var crypto = require$$0$9;
  var Buffer2 = requireSafer().Buffer;
  var algs2 = requireAlgs();
  var Key = requireKey();
  requirePrivateKey();
  var Identity = requireIdentity();
  var rfc42532 = requireRfc4253();
  var Signature = requireSignature();
  var utils2 = requireUtils$3();
  var Certificate = requireCertificate();
  function verify2(cert, key2) {
    return false;
  }
  var TYPES = {
    "user": 1,
    "host": 2
  };
  Object.keys(TYPES).forEach(function(k) {
    TYPES[TYPES[k]] = k;
  });
  var ECDSA_ALGO = /^ecdsa-sha2-([^@-]+)-cert-v01@openssh.com$/;
  function read(buf, options) {
    if (Buffer2.isBuffer(buf))
      buf = buf.toString("ascii");
    var parts = buf.trim().split(/[ \t\n]+/g);
    if (parts.length < 2 || parts.length > 3)
      throw new Error("Not a valid SSH certificate line");
    var algo = parts[0];
    var data2 = parts[1];
    data2 = Buffer2.from(data2, "base64");
    return fromBuffer(data2, algo);
  }
  function fromBuffer(data2, algo, partial) {
    var sshbuf = new SSHBuffer({ buffer: data2 });
    var innerAlgo = sshbuf.readString();
    if (algo !== void 0 && innerAlgo !== algo)
      throw new Error("SSH certificate algorithm mismatch");
    if (algo === void 0)
      algo = innerAlgo;
    var cert = {};
    cert.signatures = {};
    cert.signatures.openssh = {};
    cert.signatures.openssh.nonce = sshbuf.readBuffer();
    var key2 = {};
    var parts = key2.parts = [];
    key2.type = getAlg(algo);
    var partCount = algs2.info[key2.type].parts.length;
    while (parts.length < partCount)
      parts.push(sshbuf.readPart());
    assert.ok(parts.length >= 1, "key must have at least one part");
    var algInfo = algs2.info[key2.type];
    if (key2.type === "ecdsa") {
      var res = ECDSA_ALGO.exec(algo);
      assert.ok(res !== null);
      assert.strictEqual(res[1], parts[0].data.toString());
    }
    for (var i = 0; i < algInfo.parts.length; ++i) {
      parts[i].name = algInfo.parts[i];
      if (parts[i].name !== "curve" && algInfo.normalize !== false) {
        var p = parts[i];
        p.data = utils2.mpNormalize(p.data);
      }
    }
    cert.subjectKey = new Key(key2);
    cert.serial = sshbuf.readInt64();
    var type2 = TYPES[sshbuf.readInt()];
    assert.string(type2, "valid cert type");
    cert.signatures.openssh.keyId = sshbuf.readString();
    var principals = [];
    var pbuf = sshbuf.readBuffer();
    var psshbuf = new SSHBuffer({ buffer: pbuf });
    while (!psshbuf.atEnd())
      principals.push(psshbuf.readString());
    if (principals.length === 0)
      principals = ["*"];
    cert.subjects = principals.map(function(pr) {
      if (type2 === "user")
        return Identity.forUser(pr);
      else if (type2 === "host")
        return Identity.forHost(pr);
      throw new Error("Unknown identity type " + type2);
    });
    cert.validFrom = int64ToDate(sshbuf.readInt64());
    cert.validUntil = int64ToDate(sshbuf.readInt64());
    var exts = [];
    var extbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });
    var ext;
    while (!extbuf.atEnd()) {
      ext = { critical: true };
      ext.name = extbuf.readString();
      ext.data = extbuf.readBuffer();
      exts.push(ext);
    }
    extbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });
    while (!extbuf.atEnd()) {
      ext = { critical: false };
      ext.name = extbuf.readString();
      ext.data = extbuf.readBuffer();
      exts.push(ext);
    }
    cert.signatures.openssh.exts = exts;
    sshbuf.readBuffer();
    var signingKeyBuf = sshbuf.readBuffer();
    cert.issuerKey = rfc42532.read(signingKeyBuf);
    cert.issuer = Identity.forHost("**");
    var sigBuf = sshbuf.readBuffer();
    cert.signatures.openssh.signature = Signature.parse(sigBuf, cert.issuerKey.type, "ssh");
    if (partial !== void 0) {
      partial.remainder = sshbuf.remainder();
      partial.consumed = sshbuf._offset;
    }
    return new Certificate(cert);
  }
  function int64ToDate(buf) {
    var i = buf.readUInt32BE(0) * 4294967296;
    i += buf.readUInt32BE(4);
    var d = /* @__PURE__ */ new Date();
    d.setTime(i * 1e3);
    d.sourceInt64 = buf;
    return d;
  }
  function dateToInt64(date) {
    if (date.sourceInt64 !== void 0)
      return date.sourceInt64;
    var i = Math.round(date.getTime() / 1e3);
    var upper = Math.floor(i / 4294967296);
    var lower = Math.floor(i % 4294967296);
    var buf = Buffer2.alloc(8);
    buf.writeUInt32BE(upper, 0);
    buf.writeUInt32BE(lower, 4);
    return buf;
  }
  function sign(cert, key2) {
    if (cert.signatures.openssh === void 0)
      cert.signatures.openssh = {};
    try {
      var blob = toBuffer(cert, true);
    } catch (e) {
      delete cert.signatures.openssh;
      return false;
    }
    var sig = cert.signatures.openssh;
    var hashAlgo = void 0;
    if (key2.type === "rsa" || key2.type === "dsa")
      hashAlgo = "sha1";
    var signer2 = key2.createSign(hashAlgo);
    signer2.write(blob);
    sig.signature = signer2.sign();
    return true;
  }
  function signAsync(cert, signer2, done) {
    if (cert.signatures.openssh === void 0)
      cert.signatures.openssh = {};
    try {
      var blob = toBuffer(cert, true);
    } catch (e) {
      delete cert.signatures.openssh;
      done(e);
      return;
    }
    var sig = cert.signatures.openssh;
    signer2(blob, function(err, signature2) {
      if (err) {
        done(err);
        return;
      }
      try {
        signature2.toBuffer("ssh");
      } catch (e) {
        done(e);
        return;
      }
      sig.signature = signature2;
      done();
    });
  }
  function write(cert, options) {
    if (options === void 0)
      options = {};
    var blob = toBuffer(cert);
    var out = getCertType(cert.subjectKey) + " " + blob.toString("base64");
    if (options.comment)
      out = out + " " + options.comment;
    return out;
  }
  function toBuffer(cert, noSig) {
    assert.object(cert.signatures.openssh, "signature for openssh format");
    var sig = cert.signatures.openssh;
    if (sig.nonce === void 0)
      sig.nonce = crypto.randomBytes(16);
    var buf = new SSHBuffer({});
    buf.writeString(getCertType(cert.subjectKey));
    buf.writeBuffer(sig.nonce);
    var key2 = cert.subjectKey;
    var algInfo = algs2.info[key2.type];
    algInfo.parts.forEach(function(part) {
      buf.writePart(key2.part[part]);
    });
    buf.writeInt64(cert.serial);
    var type2 = cert.subjects[0].type;
    assert.notStrictEqual(type2, "unknown");
    cert.subjects.forEach(function(id) {
      assert.strictEqual(id.type, type2);
    });
    type2 = TYPES[type2];
    buf.writeInt(type2);
    if (sig.keyId === void 0) {
      sig.keyId = cert.subjects[0].type + "_" + (cert.subjects[0].uid || cert.subjects[0].hostname);
    }
    buf.writeString(sig.keyId);
    var sub = new SSHBuffer({});
    cert.subjects.forEach(function(id) {
      if (type2 === TYPES.host)
        sub.writeString(id.hostname);
      else if (type2 === TYPES.user)
        sub.writeString(id.uid);
    });
    buf.writeBuffer(sub.toBuffer());
    buf.writeInt64(dateToInt64(cert.validFrom));
    buf.writeInt64(dateToInt64(cert.validUntil));
    var exts = sig.exts;
    if (exts === void 0)
      exts = [];
    var extbuf = new SSHBuffer({});
    exts.forEach(function(ext) {
      if (ext.critical !== true)
        return;
      extbuf.writeString(ext.name);
      extbuf.writeBuffer(ext.data);
    });
    buf.writeBuffer(extbuf.toBuffer());
    extbuf = new SSHBuffer({});
    exts.forEach(function(ext) {
      if (ext.critical === true)
        return;
      extbuf.writeString(ext.name);
      extbuf.writeBuffer(ext.data);
    });
    buf.writeBuffer(extbuf.toBuffer());
    buf.writeBuffer(Buffer2.alloc(0));
    sub = rfc42532.write(cert.issuerKey);
    buf.writeBuffer(sub);
    if (!noSig)
      buf.writeBuffer(sig.signature.toBuffer("ssh"));
    return buf.toBuffer();
  }
  function getAlg(certType) {
    if (certType === "ssh-rsa-cert-v01@openssh.com")
      return "rsa";
    if (certType === "ssh-dss-cert-v01@openssh.com")
      return "dsa";
    if (certType.match(ECDSA_ALGO))
      return "ecdsa";
    if (certType === "ssh-ed25519-cert-v01@openssh.com")
      return "ed25519";
    throw new Error("Unsupported cert type " + certType);
  }
  function getCertType(key2) {
    if (key2.type === "rsa")
      return "ssh-rsa-cert-v01@openssh.com";
    if (key2.type === "dsa")
      return "ssh-dss-cert-v01@openssh.com";
    if (key2.type === "ecdsa")
      return "ecdsa-sha2-" + key2.curve + "-cert-v01@openssh.com";
    if (key2.type === "ed25519")
      return "ssh-ed25519-cert-v01@openssh.com";
    throw new Error("Unsupported key type " + key2.type);
  }
  return opensshCert;
}
var x509;
var hasRequiredX509;
function requireX509() {
  if (hasRequiredX509) return x509;
  hasRequiredX509 = 1;
  x509 = {
    read,
    verify: verify2,
    sign,
    signAsync,
    write
  };
  var assert = requireAssert();
  var asn1 = requireLib$4();
  var Buffer2 = requireSafer().Buffer;
  requireAlgs();
  var utils2 = requireUtils$3();
  requireKey();
  requirePrivateKey();
  requirePem();
  var Identity = requireIdentity();
  var Signature = requireSignature();
  var Certificate = requireCertificate();
  var pkcs82 = requirePkcs8();
  function readMPInt(der, nm) {
    assert.strictEqual(
      der.peek(),
      asn1.Ber.Integer,
      nm + " is not an Integer"
    );
    return utils2.mpNormalize(der.readString(asn1.Ber.Integer, true));
  }
  function verify2(cert, key2) {
    var sig = cert.signatures.x509;
    assert.object(sig, "x509 signature");
    var algParts = sig.algo.split("-");
    if (algParts[0] !== key2.type)
      return false;
    var blob = sig.cache;
    if (blob === void 0) {
      var der = new asn1.BerWriter();
      writeTBSCert(cert, der);
      blob = der.buffer;
    }
    var verifier = key2.createVerify(algParts[1]);
    verifier.write(blob);
    return verifier.verify(sig.signature);
  }
  function Local(i) {
    return asn1.Ber.Context | asn1.Ber.Constructor | i;
  }
  function Context(i) {
    return asn1.Ber.Context | i;
  }
  var SIGN_ALGS = {
    "rsa-md5": "1.2.840.113549.1.1.4",
    "rsa-sha1": "1.2.840.113549.1.1.5",
    "rsa-sha256": "1.2.840.113549.1.1.11",
    "rsa-sha384": "1.2.840.113549.1.1.12",
    "rsa-sha512": "1.2.840.113549.1.1.13",
    "dsa-sha1": "1.2.840.10040.4.3",
    "dsa-sha256": "2.16.840.1.101.3.4.3.2",
    "ecdsa-sha1": "1.2.840.10045.4.1",
    "ecdsa-sha256": "1.2.840.10045.4.3.2",
    "ecdsa-sha384": "1.2.840.10045.4.3.3",
    "ecdsa-sha512": "1.2.840.10045.4.3.4",
    "ed25519-sha512": "1.3.101.112"
  };
  Object.keys(SIGN_ALGS).forEach(function(k) {
    SIGN_ALGS[SIGN_ALGS[k]] = k;
  });
  SIGN_ALGS["1.3.14.3.2.3"] = "rsa-md5";
  SIGN_ALGS["1.3.14.3.2.29"] = "rsa-sha1";
  var EXTS = {
    "altName": "2.5.29.17",
    "basicConstraints": "2.5.29.19",
    "keyUsage": "2.5.29.15",
    "extKeyUsage": "2.5.29.37"
  };
  function read(buf, options) {
    if (typeof buf === "string") {
      buf = Buffer2.from(buf, "binary");
    }
    assert.buffer(buf, "buf");
    var der = new asn1.BerReader(buf);
    der.readSequence();
    if (Math.abs(der.length - der.remain) > 1) {
      throw new Error("DER sequence does not contain whole byte stream");
    }
    var tbsStart = der.offset;
    der.readSequence();
    var sigOffset = der.offset + der.length;
    var tbsEnd = sigOffset;
    if (der.peek() === Local(0)) {
      der.readSequence(Local(0));
      var version2 = der.readInt();
      assert.ok(
        version2 <= 3,
        "only x.509 versions up to v3 supported"
      );
    }
    var cert = {};
    cert.signatures = {};
    var sig = cert.signatures.x509 = {};
    sig.extras = {};
    cert.serial = readMPInt(der, "serial");
    der.readSequence();
    var after = der.offset + der.length;
    var certAlgOid = der.readOID();
    var certAlg = SIGN_ALGS[certAlgOid];
    if (certAlg === void 0)
      throw new Error("unknown signature algorithm " + certAlgOid);
    der._offset = after;
    cert.issuer = Identity.parseAsn1(der);
    der.readSequence();
    cert.validFrom = readDate(der);
    cert.validUntil = readDate(der);
    cert.subjects = [Identity.parseAsn1(der)];
    der.readSequence();
    after = der.offset + der.length;
    cert.subjectKey = pkcs82.readPkcs8(void 0, "public", der);
    der._offset = after;
    if (der.peek() === Local(1)) {
      der.readSequence(Local(1));
      sig.extras.issuerUniqueID = buf.slice(der.offset, der.offset + der.length);
      der._offset += der.length;
    }
    if (der.peek() === Local(2)) {
      der.readSequence(Local(2));
      sig.extras.subjectUniqueID = buf.slice(der.offset, der.offset + der.length);
      der._offset += der.length;
    }
    if (der.peek() === Local(3)) {
      der.readSequence(Local(3));
      var extEnd = der.offset + der.length;
      der.readSequence();
      while (der.offset < extEnd)
        readExtension(cert, buf, der);
      assert.strictEqual(der.offset, extEnd);
    }
    assert.strictEqual(der.offset, sigOffset);
    der.readSequence();
    after = der.offset + der.length;
    var sigAlgOid = der.readOID();
    var sigAlg = SIGN_ALGS[sigAlgOid];
    if (sigAlg === void 0)
      throw new Error("unknown signature algorithm " + sigAlgOid);
    der._offset = after;
    var sigData = der.readString(asn1.Ber.BitString, true);
    if (sigData[0] === 0)
      sigData = sigData.slice(1);
    var algParts = sigAlg.split("-");
    sig.signature = Signature.parse(sigData, algParts[0], "asn1");
    sig.signature.hashAlgorithm = algParts[1];
    sig.algo = sigAlg;
    sig.cache = buf.slice(tbsStart, tbsEnd);
    return new Certificate(cert);
  }
  function readDate(der) {
    if (der.peek() === asn1.Ber.UTCTime) {
      return utcTimeToDate(der.readString(asn1.Ber.UTCTime));
    } else if (der.peek() === asn1.Ber.GeneralizedTime) {
      return gTimeToDate(der.readString(asn1.Ber.GeneralizedTime));
    } else {
      throw new Error("Unsupported date format");
    }
  }
  function writeDate(der, date) {
    if (date.getUTCFullYear() >= 2050 || date.getUTCFullYear() < 1950) {
      der.writeString(dateToGTime(date), asn1.Ber.GeneralizedTime);
    } else {
      der.writeString(dateToUTCTime(date), asn1.Ber.UTCTime);
    }
  }
  var ALTNAME = {
    OtherName: Local(0),
    RFC822Name: Context(1),
    DNSName: Context(2),
    X400Address: Local(3),
    DirectoryName: Local(4),
    EDIPartyName: Local(5),
    URI: Context(6),
    IPAddress: Context(7),
    OID: Context(8)
  };
  var EXTPURPOSE = {
    "serverAuth": "1.3.6.1.5.5.7.3.1",
    "clientAuth": "1.3.6.1.5.5.7.3.2",
    "codeSigning": "1.3.6.1.5.5.7.3.3",
    /* See https://github.com/joyent/oid-docs/blob/master/root.md */
    "joyentDocker": "1.3.6.1.4.1.38678.1.4.1",
    "joyentCmon": "1.3.6.1.4.1.38678.1.4.2"
  };
  var EXTPURPOSE_REV = {};
  Object.keys(EXTPURPOSE).forEach(function(k) {
    EXTPURPOSE_REV[EXTPURPOSE[k]] = k;
  });
  var KEYUSEBITS = [
    "signature",
    "identity",
    "keyEncryption",
    "encryption",
    "keyAgreement",
    "ca",
    "crl"
  ];
  function readExtension(cert, buf, der) {
    der.readSequence();
    var after = der.offset + der.length;
    var extId = der.readOID();
    var id;
    var sig = cert.signatures.x509;
    if (!sig.extras.exts)
      sig.extras.exts = [];
    var critical;
    if (der.peek() === asn1.Ber.Boolean)
      critical = der.readBoolean();
    switch (extId) {
      case EXTS.basicConstraints:
        der.readSequence(asn1.Ber.OctetString);
        der.readSequence();
        var bcEnd = der.offset + der.length;
        var ca = false;
        if (der.peek() === asn1.Ber.Boolean)
          ca = der.readBoolean();
        if (cert.purposes === void 0)
          cert.purposes = [];
        if (ca === true)
          cert.purposes.push("ca");
        var bc = { oid: extId, critical };
        if (der.offset < bcEnd && der.peek() === asn1.Ber.Integer)
          bc.pathLen = der.readInt();
        sig.extras.exts.push(bc);
        break;
      case EXTS.extKeyUsage:
        der.readSequence(asn1.Ber.OctetString);
        der.readSequence();
        if (cert.purposes === void 0)
          cert.purposes = [];
        var ekEnd = der.offset + der.length;
        while (der.offset < ekEnd) {
          var oid = der.readOID();
          cert.purposes.push(EXTPURPOSE_REV[oid] || oid);
        }
        if (cert.purposes.indexOf("serverAuth") !== -1 && cert.purposes.indexOf("clientAuth") === -1) {
          cert.subjects.forEach(function(ide) {
            if (ide.type !== "host") {
              ide.type = "host";
              ide.hostname = ide.uid || ide.email || ide.components[0].value;
            }
          });
        } else if (cert.purposes.indexOf("clientAuth") !== -1 && cert.purposes.indexOf("serverAuth") === -1) {
          cert.subjects.forEach(function(ide) {
            if (ide.type !== "user") {
              ide.type = "user";
              ide.uid = ide.hostname || ide.email || ide.components[0].value;
            }
          });
        }
        sig.extras.exts.push({ oid: extId, critical });
        break;
      case EXTS.keyUsage:
        der.readSequence(asn1.Ber.OctetString);
        var bits = der.readString(asn1.Ber.BitString, true);
        var setBits = readBitField(bits, KEYUSEBITS);
        setBits.forEach(function(bit) {
          if (cert.purposes === void 0)
            cert.purposes = [];
          if (cert.purposes.indexOf(bit) === -1)
            cert.purposes.push(bit);
        });
        sig.extras.exts.push({
          oid: extId,
          critical,
          bits
        });
        break;
      case EXTS.altName:
        der.readSequence(asn1.Ber.OctetString);
        der.readSequence();
        var aeEnd = der.offset + der.length;
        while (der.offset < aeEnd) {
          switch (der.peek()) {
            case ALTNAME.OtherName:
            case ALTNAME.EDIPartyName:
              der.readSequence();
              der._offset += der.length;
              break;
            case ALTNAME.OID:
              der.readOID(ALTNAME.OID);
              break;
            case ALTNAME.RFC822Name:
              var email = der.readString(ALTNAME.RFC822Name);
              id = Identity.forEmail(email);
              if (!cert.subjects[0].equals(id))
                cert.subjects.push(id);
              break;
            case ALTNAME.DirectoryName:
              der.readSequence(ALTNAME.DirectoryName);
              id = Identity.parseAsn1(der);
              if (!cert.subjects[0].equals(id))
                cert.subjects.push(id);
              break;
            case ALTNAME.DNSName:
              var host = der.readString(
                ALTNAME.DNSName
              );
              id = Identity.forHost(host);
              if (!cert.subjects[0].equals(id))
                cert.subjects.push(id);
              break;
            default:
              der.readString(der.peek());
              break;
          }
        }
        sig.extras.exts.push({ oid: extId, critical });
        break;
      default:
        sig.extras.exts.push({
          oid: extId,
          critical,
          data: der.readString(asn1.Ber.OctetString, true)
        });
        break;
    }
    der._offset = after;
  }
  var UTCTIME_RE = /^([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;
  function utcTimeToDate(t) {
    var m = t.match(UTCTIME_RE);
    assert.ok(m, "timestamps must be in UTC");
    var d = /* @__PURE__ */ new Date();
    var thisYear = d.getUTCFullYear();
    var century = Math.floor(thisYear / 100) * 100;
    var year = parseInt(m[1], 10);
    if (thisYear % 100 < 50 && year >= 60)
      year += century - 1;
    else
      year += century;
    d.setUTCFullYear(year, parseInt(m[2], 10) - 1, parseInt(m[3], 10));
    d.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));
    if (m[6] && m[6].length > 0)
      d.setUTCSeconds(parseInt(m[6], 10));
    return d;
  }
  var GTIME_RE = /^([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;
  function gTimeToDate(t) {
    var m = t.match(GTIME_RE);
    assert.ok(m);
    var d = /* @__PURE__ */ new Date();
    d.setUTCFullYear(
      parseInt(m[1], 10),
      parseInt(m[2], 10) - 1,
      parseInt(m[3], 10)
    );
    d.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));
    if (m[6] && m[6].length > 0)
      d.setUTCSeconds(parseInt(m[6], 10));
    return d;
  }
  function zeroPad(n, m) {
    if (m === void 0)
      m = 2;
    var s = "" + n;
    while (s.length < m)
      s = "0" + s;
    return s;
  }
  function dateToUTCTime(d) {
    var s = "";
    s += zeroPad(d.getUTCFullYear() % 100);
    s += zeroPad(d.getUTCMonth() + 1);
    s += zeroPad(d.getUTCDate());
    s += zeroPad(d.getUTCHours());
    s += zeroPad(d.getUTCMinutes());
    s += zeroPad(d.getUTCSeconds());
    s += "Z";
    return s;
  }
  function dateToGTime(d) {
    var s = "";
    s += zeroPad(d.getUTCFullYear(), 4);
    s += zeroPad(d.getUTCMonth() + 1);
    s += zeroPad(d.getUTCDate());
    s += zeroPad(d.getUTCHours());
    s += zeroPad(d.getUTCMinutes());
    s += zeroPad(d.getUTCSeconds());
    s += "Z";
    return s;
  }
  function sign(cert, key2) {
    if (cert.signatures.x509 === void 0)
      cert.signatures.x509 = {};
    var sig = cert.signatures.x509;
    sig.algo = key2.type + "-" + key2.defaultHashAlgorithm();
    if (SIGN_ALGS[sig.algo] === void 0)
      return false;
    var der = new asn1.BerWriter();
    writeTBSCert(cert, der);
    var blob = der.buffer;
    sig.cache = blob;
    var signer2 = key2.createSign();
    signer2.write(blob);
    cert.signatures.x509.signature = signer2.sign();
    return true;
  }
  function signAsync(cert, signer2, done) {
    if (cert.signatures.x509 === void 0)
      cert.signatures.x509 = {};
    var sig = cert.signatures.x509;
    var der = new asn1.BerWriter();
    writeTBSCert(cert, der);
    var blob = der.buffer;
    sig.cache = blob;
    signer2(blob, function(err, signature2) {
      if (err) {
        done(err);
        return;
      }
      sig.algo = signature2.type + "-" + signature2.hashAlgorithm;
      if (SIGN_ALGS[sig.algo] === void 0) {
        done(new Error('Invalid signing algorithm "' + sig.algo + '"'));
        return;
      }
      sig.signature = signature2;
      done();
    });
  }
  function write(cert, options) {
    var sig = cert.signatures.x509;
    assert.object(sig, "x509 signature");
    var der = new asn1.BerWriter();
    der.startSequence();
    if (sig.cache) {
      der._ensure(sig.cache.length);
      sig.cache.copy(der._buf, der._offset);
      der._offset += sig.cache.length;
    } else {
      writeTBSCert(cert, der);
    }
    der.startSequence();
    der.writeOID(SIGN_ALGS[sig.algo]);
    if (sig.algo.match(/^rsa-/))
      der.writeNull();
    der.endSequence();
    var sigData = sig.signature.toBuffer("asn1");
    var data2 = Buffer2.alloc(sigData.length + 1);
    data2[0] = 0;
    sigData.copy(data2, 1);
    der.writeBuffer(data2, asn1.Ber.BitString);
    der.endSequence();
    return der.buffer;
  }
  function writeTBSCert(cert, der) {
    var sig = cert.signatures.x509;
    assert.object(sig, "x509 signature");
    der.startSequence();
    der.startSequence(Local(0));
    der.writeInt(2);
    der.endSequence();
    der.writeBuffer(utils2.mpNormalize(cert.serial), asn1.Ber.Integer);
    der.startSequence();
    der.writeOID(SIGN_ALGS[sig.algo]);
    if (sig.algo.match(/^rsa-/))
      der.writeNull();
    der.endSequence();
    cert.issuer.toAsn1(der);
    der.startSequence();
    writeDate(der, cert.validFrom);
    writeDate(der, cert.validUntil);
    der.endSequence();
    var subject = cert.subjects[0];
    var altNames = cert.subjects.slice(1);
    subject.toAsn1(der);
    pkcs82.writePkcs8(der, cert.subjectKey);
    if (sig.extras && sig.extras.issuerUniqueID) {
      der.writeBuffer(sig.extras.issuerUniqueID, Local(1));
    }
    if (sig.extras && sig.extras.subjectUniqueID) {
      der.writeBuffer(sig.extras.subjectUniqueID, Local(2));
    }
    if (altNames.length > 0 || subject.type === "host" || cert.purposes !== void 0 && cert.purposes.length > 0 || sig.extras && sig.extras.exts) {
      der.startSequence(Local(3));
      der.startSequence();
      var exts = [];
      if (cert.purposes !== void 0 && cert.purposes.length > 0) {
        exts.push({
          oid: EXTS.basicConstraints,
          critical: true
        });
        exts.push({
          oid: EXTS.keyUsage,
          critical: true
        });
        exts.push({
          oid: EXTS.extKeyUsage,
          critical: true
        });
      }
      exts.push({ oid: EXTS.altName });
      if (sig.extras && sig.extras.exts)
        exts = sig.extras.exts;
      for (var i = 0; i < exts.length; ++i) {
        der.startSequence();
        der.writeOID(exts[i].oid);
        if (exts[i].critical !== void 0)
          der.writeBoolean(exts[i].critical);
        if (exts[i].oid === EXTS.altName) {
          der.startSequence(asn1.Ber.OctetString);
          der.startSequence();
          if (subject.type === "host") {
            der.writeString(
              subject.hostname,
              Context(2)
            );
          }
          for (var j = 0; j < altNames.length; ++j) {
            if (altNames[j].type === "host") {
              der.writeString(
                altNames[j].hostname,
                ALTNAME.DNSName
              );
            } else if (altNames[j].type === "email") {
              der.writeString(
                altNames[j].email,
                ALTNAME.RFC822Name
              );
            } else {
              der.startSequence(
                ALTNAME.DirectoryName
              );
              altNames[j].toAsn1(der);
              der.endSequence();
            }
          }
          der.endSequence();
          der.endSequence();
        } else if (exts[i].oid === EXTS.basicConstraints) {
          der.startSequence(asn1.Ber.OctetString);
          der.startSequence();
          var ca = cert.purposes.indexOf("ca") !== -1;
          var pathLen = exts[i].pathLen;
          der.writeBoolean(ca);
          if (pathLen !== void 0)
            der.writeInt(pathLen);
          der.endSequence();
          der.endSequence();
        } else if (exts[i].oid === EXTS.extKeyUsage) {
          der.startSequence(asn1.Ber.OctetString);
          der.startSequence();
          cert.purposes.forEach(function(purpose) {
            if (purpose === "ca")
              return;
            if (KEYUSEBITS.indexOf(purpose) !== -1)
              return;
            var oid = purpose;
            if (EXTPURPOSE[purpose] !== void 0)
              oid = EXTPURPOSE[purpose];
            der.writeOID(oid);
          });
          der.endSequence();
          der.endSequence();
        } else if (exts[i].oid === EXTS.keyUsage) {
          der.startSequence(asn1.Ber.OctetString);
          if (exts[i].bits !== void 0) {
            der.writeBuffer(
              exts[i].bits,
              asn1.Ber.BitString
            );
          } else {
            var bits = writeBitField(
              cert.purposes,
              KEYUSEBITS
            );
            der.writeBuffer(
              bits,
              asn1.Ber.BitString
            );
          }
          der.endSequence();
        } else {
          der.writeBuffer(
            exts[i].data,
            asn1.Ber.OctetString
          );
        }
        der.endSequence();
      }
      der.endSequence();
      der.endSequence();
    }
    der.endSequence();
  }
  function readBitField(bits, bitIndex) {
    var bitLen = 8 * (bits.length - 1) - bits[0];
    var setBits = {};
    for (var i = 0; i < bitLen; ++i) {
      var byteN = 1 + Math.floor(i / 8);
      var bit = 7 - i % 8;
      var mask = 1 << bit;
      var bitVal = (bits[byteN] & mask) !== 0;
      var name = bitIndex[i];
      if (bitVal && typeof name === "string") {
        setBits[name] = true;
      }
    }
    return Object.keys(setBits);
  }
  function writeBitField(setBits, bitIndex) {
    var bitLen = bitIndex.length;
    var blen = Math.ceil(bitLen / 8);
    var unused = blen * 8 - bitLen;
    var bits = Buffer2.alloc(1 + blen);
    bits[0] = unused;
    for (var i = 0; i < bitLen; ++i) {
      var byteN = 1 + Math.floor(i / 8);
      var bit = 7 - i % 8;
      var mask = 1 << bit;
      var name = bitIndex[i];
      if (name === void 0)
        continue;
      var bitVal = setBits.indexOf(name) !== -1;
      if (bitVal) {
        bits[byteN] |= mask;
      }
    }
    return bits;
  }
  return x509;
}
var x509Pem;
var hasRequiredX509Pem;
function requireX509Pem() {
  if (hasRequiredX509Pem) return x509Pem;
  hasRequiredX509Pem = 1;
  var x5092 = requireX509();
  x509Pem = {
    read,
    verify: x5092.verify,
    sign: x5092.sign,
    write
  };
  var assert = requireAssert();
  requireLib$4();
  var Buffer2 = requireSafer().Buffer;
  requireAlgs();
  requireUtils$3();
  requireKey();
  requirePrivateKey();
  requirePem();
  requireIdentity();
  requireSignature();
  requireCertificate();
  function read(buf, options) {
    if (typeof buf !== "string") {
      assert.buffer(buf, "buf");
      buf = buf.toString("ascii");
    }
    var lines = buf.trim().split(/[\r\n]+/g);
    var m;
    var si = -1;
    while (!m && si < lines.length) {
      m = lines[++si].match(
        /*JSSTYLED*/
        /[-]+[ ]*BEGIN CERTIFICATE[ ]*[-]+/
      );
    }
    assert.ok(m, "invalid PEM header");
    var m2;
    var ei = lines.length;
    while (!m2 && ei > 0) {
      m2 = lines[--ei].match(
        /*JSSTYLED*/
        /[-]+[ ]*END CERTIFICATE[ ]*[-]+/
      );
    }
    assert.ok(m2, "invalid PEM footer");
    lines = lines.slice(si, ei + 1);
    var headers = {};
    while (true) {
      lines = lines.slice(1);
      m = lines[0].match(
        /*JSSTYLED*/
        /^([A-Za-z0-9-]+): (.+)$/
      );
      if (!m)
        break;
      headers[m[1].toLowerCase()] = m[2];
    }
    lines = lines.slice(0, -1).join("");
    buf = Buffer2.from(lines, "base64");
    return x5092.read(buf, options);
  }
  function write(cert, options) {
    var dbuf = x5092.write(cert, options);
    var header = "CERTIFICATE";
    var tmp = dbuf.toString("base64");
    var len = tmp.length + tmp.length / 64 + 18 + 16 + header.length * 2 + 10;
    var buf = Buffer2.alloc(len);
    var o = 0;
    o += buf.write("-----BEGIN " + header + "-----\n", o);
    for (var i = 0; i < tmp.length; ) {
      var limit = i + 64;
      if (limit > tmp.length)
        limit = tmp.length;
      o += buf.write(tmp.slice(i, limit), o);
      buf[o++] = 10;
      i = limit;
    }
    o += buf.write("-----END " + header + "-----\n", o);
    return buf.slice(0, o);
  }
  return x509Pem;
}
var certificate;
var hasRequiredCertificate;
function requireCertificate() {
  if (hasRequiredCertificate) return certificate;
  hasRequiredCertificate = 1;
  certificate = Certificate;
  var assert = requireAssert();
  var Buffer2 = requireSafer().Buffer;
  var algs2 = requireAlgs();
  var crypto = require$$0$9;
  var Fingerprint = requireFingerprint();
  requireSignature();
  var errs = requireErrors$1();
  var utils2 = requireUtils$3();
  var Key = requireKey();
  var PrivateKey = requirePrivateKey();
  var Identity = requireIdentity();
  var formats2 = {};
  formats2["openssh"] = requireOpensshCert();
  formats2["x509"] = requireX509();
  formats2["pem"] = requireX509Pem();
  var CertificateParseError = errs.CertificateParseError;
  var InvalidAlgorithmError = errs.InvalidAlgorithmError;
  function Certificate(opts) {
    assert.object(opts, "options");
    assert.arrayOfObject(opts.subjects, "options.subjects");
    utils2.assertCompatible(
      opts.subjects[0],
      Identity,
      [1, 0],
      "options.subjects"
    );
    utils2.assertCompatible(
      opts.subjectKey,
      Key,
      [1, 0],
      "options.subjectKey"
    );
    utils2.assertCompatible(opts.issuer, Identity, [1, 0], "options.issuer");
    if (opts.issuerKey !== void 0) {
      utils2.assertCompatible(
        opts.issuerKey,
        Key,
        [1, 0],
        "options.issuerKey"
      );
    }
    assert.object(opts.signatures, "options.signatures");
    assert.buffer(opts.serial, "options.serial");
    assert.date(opts.validFrom, "options.validFrom");
    assert.date(opts.validUntil, "optons.validUntil");
    assert.optionalArrayOfString(opts.purposes, "options.purposes");
    this._hashCache = {};
    this.subjects = opts.subjects;
    this.issuer = opts.issuer;
    this.subjectKey = opts.subjectKey;
    this.issuerKey = opts.issuerKey;
    this.signatures = opts.signatures;
    this.serial = opts.serial;
    this.validFrom = opts.validFrom;
    this.validUntil = opts.validUntil;
    this.purposes = opts.purposes;
  }
  Certificate.formats = formats2;
  Certificate.prototype.toBuffer = function(format2, options) {
    if (format2 === void 0)
      format2 = "x509";
    assert.string(format2, "format");
    assert.object(formats2[format2], "formats[format]");
    assert.optionalObject(options, "options");
    return formats2[format2].write(this, options);
  };
  Certificate.prototype.toString = function(format2, options) {
    if (format2 === void 0)
      format2 = "pem";
    return this.toBuffer(format2, options).toString();
  };
  Certificate.prototype.fingerprint = function(algo) {
    if (algo === void 0)
      algo = "sha256";
    assert.string(algo, "algorithm");
    var opts = {
      type: "certificate",
      hash: this.hash(algo),
      algorithm: algo
    };
    return new Fingerprint(opts);
  };
  Certificate.prototype.hash = function(algo) {
    assert.string(algo, "algorithm");
    algo = algo.toLowerCase();
    if (algs2.hashAlgs[algo] === void 0)
      throw new InvalidAlgorithmError(algo);
    if (this._hashCache[algo])
      return this._hashCache[algo];
    var hash = crypto.createHash(algo).update(this.toBuffer("x509")).digest();
    this._hashCache[algo] = hash;
    return hash;
  };
  Certificate.prototype.isExpired = function(when) {
    if (when === void 0)
      when = /* @__PURE__ */ new Date();
    return !(when.getTime() >= this.validFrom.getTime() && when.getTime() < this.validUntil.getTime());
  };
  Certificate.prototype.isSignedBy = function(issuerCert) {
    utils2.assertCompatible(issuerCert, Certificate, [1, 0], "issuer");
    if (!this.issuer.equals(issuerCert.subjects[0]))
      return false;
    if (this.issuer.purposes && this.issuer.purposes.length > 0 && this.issuer.purposes.indexOf("ca") === -1) {
      return false;
    }
    return this.isSignedByKey(issuerCert.subjectKey);
  };
  Certificate.prototype.getExtension = function(keyOrOid) {
    assert.string(keyOrOid, "keyOrOid");
    var ext = this.getExtensions().filter(function(maybeExt) {
      if (maybeExt.format === "x509")
        return maybeExt.oid === keyOrOid;
      if (maybeExt.format === "openssh")
        return maybeExt.name === keyOrOid;
      return false;
    })[0];
    return ext;
  };
  Certificate.prototype.getExtensions = function() {
    var exts = [];
    var x5092 = this.signatures.x509;
    if (x5092 && x5092.extras && x5092.extras.exts) {
      x5092.extras.exts.forEach(function(ext) {
        ext.format = "x509";
        exts.push(ext);
      });
    }
    var openssh = this.signatures.openssh;
    if (openssh && openssh.exts) {
      openssh.exts.forEach(function(ext) {
        ext.format = "openssh";
        exts.push(ext);
      });
    }
    return exts;
  };
  Certificate.prototype.isSignedByKey = function(issuerKey) {
    utils2.assertCompatible(issuerKey, Key, [1, 2], "issuerKey");
    if (this.issuerKey !== void 0) {
      return this.issuerKey.fingerprint("sha512").matches(issuerKey);
    }
    var fmt = Object.keys(this.signatures)[0];
    var valid = formats2[fmt].verify(this, issuerKey);
    if (valid)
      this.issuerKey = issuerKey;
    return valid;
  };
  Certificate.prototype.signWith = function(key2) {
    utils2.assertCompatible(key2, PrivateKey, [1, 2], "key");
    var fmts = Object.keys(formats2);
    var didOne = false;
    for (var i = 0; i < fmts.length; ++i) {
      if (fmts[i] !== "pem") {
        var ret = formats2[fmts[i]].sign(this, key2);
        if (ret === true)
          didOne = true;
      }
    }
    if (!didOne) {
      throw new Error("Failed to sign the certificate for any available certificate formats");
    }
  };
  Certificate.createSelfSigned = function(subjectOrSubjects, key2, options) {
    var subjects;
    if (Array.isArray(subjectOrSubjects))
      subjects = subjectOrSubjects;
    else
      subjects = [subjectOrSubjects];
    assert.arrayOfObject(subjects);
    subjects.forEach(function(subject) {
      utils2.assertCompatible(subject, Identity, [1, 0], "subject");
    });
    utils2.assertCompatible(key2, PrivateKey, [1, 2], "private key");
    assert.optionalObject(options, "options");
    if (options === void 0)
      options = {};
    assert.optionalObject(options.validFrom, "options.validFrom");
    assert.optionalObject(options.validUntil, "options.validUntil");
    var validFrom = options.validFrom;
    var validUntil = options.validUntil;
    if (validFrom === void 0)
      validFrom = /* @__PURE__ */ new Date();
    if (validUntil === void 0) {
      assert.optionalNumber(options.lifetime, "options.lifetime");
      var lifetime = options.lifetime;
      if (lifetime === void 0)
        lifetime = 10 * 365 * 24 * 3600;
      validUntil = /* @__PURE__ */ new Date();
      validUntil.setTime(validUntil.getTime() + lifetime * 1e3);
    }
    assert.optionalBuffer(options.serial, "options.serial");
    var serial = options.serial;
    if (serial === void 0)
      serial = Buffer2.from("0000000000000001", "hex");
    var purposes = options.purposes;
    if (purposes === void 0)
      purposes = [];
    if (purposes.indexOf("signature") === -1)
      purposes.push("signature");
    if (purposes.indexOf("ca") === -1)
      purposes.push("ca");
    if (purposes.indexOf("crl") === -1)
      purposes.push("crl");
    if (purposes.length <= 3) {
      var hostSubjects = subjects.filter(function(subject) {
        return subject.type === "host";
      });
      var userSubjects = subjects.filter(function(subject) {
        return subject.type === "user";
      });
      if (hostSubjects.length > 0) {
        if (purposes.indexOf("serverAuth") === -1)
          purposes.push("serverAuth");
      }
      if (userSubjects.length > 0) {
        if (purposes.indexOf("clientAuth") === -1)
          purposes.push("clientAuth");
      }
      if (userSubjects.length > 0 || hostSubjects.length > 0) {
        if (purposes.indexOf("keyAgreement") === -1)
          purposes.push("keyAgreement");
        if (key2.type === "rsa" && purposes.indexOf("encryption") === -1)
          purposes.push("encryption");
      }
    }
    var cert = new Certificate({
      subjects,
      issuer: subjects[0],
      subjectKey: key2.toPublic(),
      issuerKey: key2.toPublic(),
      signatures: {},
      serial,
      validFrom,
      validUntil,
      purposes
    });
    cert.signWith(key2);
    return cert;
  };
  Certificate.create = function(subjectOrSubjects, key2, issuer, issuerKey, options) {
    var subjects;
    if (Array.isArray(subjectOrSubjects))
      subjects = subjectOrSubjects;
    else
      subjects = [subjectOrSubjects];
    assert.arrayOfObject(subjects);
    subjects.forEach(function(subject) {
      utils2.assertCompatible(subject, Identity, [1, 0], "subject");
    });
    utils2.assertCompatible(key2, Key, [1, 0], "key");
    if (PrivateKey.isPrivateKey(key2))
      key2 = key2.toPublic();
    utils2.assertCompatible(issuer, Identity, [1, 0], "issuer");
    utils2.assertCompatible(issuerKey, PrivateKey, [1, 2], "issuer key");
    assert.optionalObject(options, "options");
    if (options === void 0)
      options = {};
    assert.optionalObject(options.validFrom, "options.validFrom");
    assert.optionalObject(options.validUntil, "options.validUntil");
    var validFrom = options.validFrom;
    var validUntil = options.validUntil;
    if (validFrom === void 0)
      validFrom = /* @__PURE__ */ new Date();
    if (validUntil === void 0) {
      assert.optionalNumber(options.lifetime, "options.lifetime");
      var lifetime = options.lifetime;
      if (lifetime === void 0)
        lifetime = 10 * 365 * 24 * 3600;
      validUntil = /* @__PURE__ */ new Date();
      validUntil.setTime(validUntil.getTime() + lifetime * 1e3);
    }
    assert.optionalBuffer(options.serial, "options.serial");
    var serial = options.serial;
    if (serial === void 0)
      serial = Buffer2.from("0000000000000001", "hex");
    var purposes = options.purposes;
    if (purposes === void 0)
      purposes = [];
    if (purposes.indexOf("signature") === -1)
      purposes.push("signature");
    if (options.ca === true) {
      if (purposes.indexOf("ca") === -1)
        purposes.push("ca");
      if (purposes.indexOf("crl") === -1)
        purposes.push("crl");
    }
    var hostSubjects = subjects.filter(function(subject) {
      return subject.type === "host";
    });
    var userSubjects = subjects.filter(function(subject) {
      return subject.type === "user";
    });
    if (hostSubjects.length > 0) {
      if (purposes.indexOf("serverAuth") === -1)
        purposes.push("serverAuth");
    }
    if (userSubjects.length > 0) {
      if (purposes.indexOf("clientAuth") === -1)
        purposes.push("clientAuth");
    }
    if (userSubjects.length > 0 || hostSubjects.length > 0) {
      if (purposes.indexOf("keyAgreement") === -1)
        purposes.push("keyAgreement");
      if (key2.type === "rsa" && purposes.indexOf("encryption") === -1)
        purposes.push("encryption");
    }
    var cert = new Certificate({
      subjects,
      issuer,
      subjectKey: key2,
      issuerKey: issuerKey.toPublic(),
      signatures: {},
      serial,
      validFrom,
      validUntil,
      purposes
    });
    cert.signWith(issuerKey);
    return cert;
  };
  Certificate.parse = function(data2, format2, options) {
    if (typeof data2 !== "string")
      assert.buffer(data2, "data");
    if (format2 === void 0)
      format2 = "auto";
    assert.string(format2, "format");
    if (typeof options === "string")
      options = { filename: options };
    assert.optionalObject(options, "options");
    if (options === void 0)
      options = {};
    assert.optionalString(options.filename, "options.filename");
    if (options.filename === void 0)
      options.filename = "(unnamed)";
    assert.object(formats2[format2], "formats[format]");
    try {
      var k = formats2[format2].read(data2, options);
      return k;
    } catch (e) {
      throw new CertificateParseError(options.filename, format2, e);
    }
  };
  Certificate.isCertificate = function(obj, ver) {
    return utils2.isCompatible(obj, Certificate, ver);
  };
  Certificate.prototype._sshpkApiVersion = [1, 1];
  Certificate._oldVersionDetect = function(obj) {
    return [1, 0];
  };
  return certificate;
}
var fingerprint;
var hasRequiredFingerprint;
function requireFingerprint() {
  if (hasRequiredFingerprint) return fingerprint;
  hasRequiredFingerprint = 1;
  fingerprint = Fingerprint;
  var assert = requireAssert();
  var Buffer2 = requireSafer().Buffer;
  var algs2 = requireAlgs();
  var crypto = require$$0$9;
  var errs = requireErrors$1();
  var Key = requireKey();
  var PrivateKey = requirePrivateKey();
  var Certificate = requireCertificate();
  var utils2 = requireUtils$3();
  var FingerprintFormatError = errs.FingerprintFormatError;
  var InvalidAlgorithmError = errs.InvalidAlgorithmError;
  function Fingerprint(opts) {
    assert.object(opts, "options");
    assert.string(opts.type, "options.type");
    assert.buffer(opts.hash, "options.hash");
    assert.string(opts.algorithm, "options.algorithm");
    this.algorithm = opts.algorithm.toLowerCase();
    if (algs2.hashAlgs[this.algorithm] !== true)
      throw new InvalidAlgorithmError(this.algorithm);
    this.hash = opts.hash;
    this.type = opts.type;
    this.hashType = opts.hashType;
  }
  Fingerprint.prototype.toString = function(format2) {
    if (format2 === void 0) {
      if (this.algorithm === "md5" || this.hashType === "spki")
        format2 = "hex";
      else
        format2 = "base64";
    }
    assert.string(format2);
    switch (format2) {
      case "hex":
        if (this.hashType === "spki")
          return this.hash.toString("hex");
        return addColons(this.hash.toString("hex"));
      case "base64":
        if (this.hashType === "spki")
          return this.hash.toString("base64");
        return sshBase64Format(
          this.algorithm,
          this.hash.toString("base64")
        );
      default:
        throw new FingerprintFormatError(void 0, format2);
    }
  };
  Fingerprint.prototype.matches = function(other) {
    assert.object(other, "key or certificate");
    if (this.type === "key" && this.hashType !== "ssh") {
      utils2.assertCompatible(other, Key, [1, 7], "key with spki");
      if (PrivateKey.isPrivateKey(other)) {
        utils2.assertCompatible(
          other,
          PrivateKey,
          [1, 6],
          "privatekey with spki support"
        );
      }
    } else if (this.type === "key") {
      utils2.assertCompatible(other, Key, [1, 0], "key");
    } else {
      utils2.assertCompatible(
        other,
        Certificate,
        [1, 0],
        "certificate"
      );
    }
    var theirHash = other.hash(this.algorithm, this.hashType);
    var theirHash2 = crypto.createHash(this.algorithm).update(theirHash).digest("base64");
    if (this.hash2 === void 0)
      this.hash2 = crypto.createHash(this.algorithm).update(this.hash).digest("base64");
    return this.hash2 === theirHash2;
  };
  var base64RE = /^[A-Za-z0-9+\/=]+$/;
  var hexRE = /^[a-fA-F0-9]+$/;
  Fingerprint.parse = function(fp, options) {
    assert.string(fp, "fingerprint");
    var alg, hash, enAlgs;
    if (Array.isArray(options)) {
      enAlgs = options;
      options = {};
    }
    assert.optionalObject(options, "options");
    if (options === void 0)
      options = {};
    if (options.enAlgs !== void 0)
      enAlgs = options.enAlgs;
    if (options.algorithms !== void 0)
      enAlgs = options.algorithms;
    assert.optionalArrayOfString(enAlgs, "algorithms");
    var hashType = "ssh";
    if (options.hashType !== void 0)
      hashType = options.hashType;
    assert.string(hashType, "options.hashType");
    var parts = fp.split(":");
    if (parts.length == 2) {
      alg = parts[0].toLowerCase();
      if (!base64RE.test(parts[1]))
        throw new FingerprintFormatError(fp);
      try {
        hash = Buffer2.from(parts[1], "base64");
      } catch (e) {
        throw new FingerprintFormatError(fp);
      }
    } else if (parts.length > 2) {
      alg = "md5";
      if (parts[0].toLowerCase() === "md5")
        parts = parts.slice(1);
      parts = parts.map(function(p) {
        while (p.length < 2)
          p = "0" + p;
        if (p.length > 2)
          throw new FingerprintFormatError(fp);
        return p;
      });
      parts = parts.join("");
      if (!hexRE.test(parts) || parts.length % 2 !== 0)
        throw new FingerprintFormatError(fp);
      try {
        hash = Buffer2.from(parts, "hex");
      } catch (e) {
        throw new FingerprintFormatError(fp);
      }
    } else {
      if (hexRE.test(fp)) {
        hash = Buffer2.from(fp, "hex");
      } else if (base64RE.test(fp)) {
        hash = Buffer2.from(fp, "base64");
      } else {
        throw new FingerprintFormatError(fp);
      }
      switch (hash.length) {
        case 32:
          alg = "sha256";
          break;
        case 16:
          alg = "md5";
          break;
        case 20:
          alg = "sha1";
          break;
        case 64:
          alg = "sha512";
          break;
        default:
          throw new FingerprintFormatError(fp);
      }
      if (options.hashType === void 0)
        hashType = "spki";
    }
    if (alg === void 0)
      throw new FingerprintFormatError(fp);
    if (algs2.hashAlgs[alg] === void 0)
      throw new InvalidAlgorithmError(alg);
    if (enAlgs !== void 0) {
      enAlgs = enAlgs.map(function(a) {
        return a.toLowerCase();
      });
      if (enAlgs.indexOf(alg) === -1)
        throw new InvalidAlgorithmError(alg);
    }
    return new Fingerprint({
      algorithm: alg,
      hash,
      type: options.type || "key",
      hashType
    });
  };
  function addColons(s) {
    return s.replace(/(.{2})(?=.)/g, "$1:");
  }
  function base64Strip(s) {
    return s.replace(/=*$/, "");
  }
  function sshBase64Format(alg, h) {
    return alg.toUpperCase() + ":" + base64Strip(h);
  }
  Fingerprint.isFingerprint = function(obj, ver) {
    return utils2.isCompatible(obj, Fingerprint, ver);
  };
  Fingerprint.prototype._sshpkApiVersion = [1, 2];
  Fingerprint._oldVersionDetect = function(obj) {
    assert.func(obj.toString);
    assert.func(obj.matches);
    return [1, 0];
  };
  return fingerprint;
}
var key;
var hasRequiredKey;
function requireKey() {
  if (hasRequiredKey) return key;
  hasRequiredKey = 1;
  key = Key;
  var assert = requireAssert();
  var algs2 = requireAlgs();
  var crypto = require$$0$9;
  var Fingerprint = requireFingerprint();
  var Signature = requireSignature();
  var DiffieHellman = requireDhe().DiffieHellman;
  var errs = requireErrors$1();
  var utils2 = requireUtils$3();
  var PrivateKey = requirePrivateKey();
  var edCompat2;
  try {
    edCompat2 = requireEdCompat();
  } catch (e) {
  }
  var InvalidAlgorithmError = errs.InvalidAlgorithmError;
  var KeyParseError = errs.KeyParseError;
  var formats2 = {};
  formats2["auto"] = requireAuto();
  formats2["pem"] = requirePem();
  formats2["pkcs1"] = requirePkcs1();
  formats2["pkcs8"] = requirePkcs8();
  formats2["rfc4253"] = requireRfc4253();
  formats2["ssh"] = requireSsh();
  formats2["ssh-private"] = requireSshPrivate();
  formats2["openssh"] = formats2["ssh-private"];
  formats2["dnssec"] = requireDnssec();
  formats2["putty"] = requirePutty();
  formats2["ppk"] = formats2["putty"];
  function Key(opts) {
    assert.object(opts, "options");
    assert.arrayOfObject(opts.parts, "options.parts");
    assert.string(opts.type, "options.type");
    assert.optionalString(opts.comment, "options.comment");
    var algInfo = algs2.info[opts.type];
    if (typeof algInfo !== "object")
      throw new InvalidAlgorithmError(opts.type);
    var partLookup = {};
    for (var i = 0; i < opts.parts.length; ++i) {
      var part = opts.parts[i];
      partLookup[part.name] = part;
    }
    this.type = opts.type;
    this.parts = opts.parts;
    this.part = partLookup;
    this.comment = void 0;
    this.source = opts.source;
    this._rfc4253Cache = opts._rfc4253Cache;
    this._hashCache = {};
    var sz;
    this.curve = void 0;
    if (this.type === "ecdsa") {
      var curve = this.part.curve.data.toString();
      this.curve = curve;
      sz = algs2.curves[curve].size;
    } else if (this.type === "ed25519" || this.type === "curve25519") {
      sz = 256;
      this.curve = "curve25519";
    } else {
      var szPart = this.part[algInfo.sizePart];
      sz = szPart.data.length;
      sz = sz * 8 - utils2.countZeros(szPart.data);
    }
    this.size = sz;
  }
  Key.formats = formats2;
  Key.prototype.toBuffer = function(format2, options) {
    if (format2 === void 0)
      format2 = "ssh";
    assert.string(format2, "format");
    assert.object(formats2[format2], "formats[format]");
    assert.optionalObject(options, "options");
    if (format2 === "rfc4253") {
      if (this._rfc4253Cache === void 0)
        this._rfc4253Cache = formats2["rfc4253"].write(this);
      return this._rfc4253Cache;
    }
    return formats2[format2].write(this, options);
  };
  Key.prototype.toString = function(format2, options) {
    return this.toBuffer(format2, options).toString();
  };
  Key.prototype.hash = function(algo, type2) {
    assert.string(algo, "algorithm");
    assert.optionalString(type2, "type");
    if (type2 === void 0)
      type2 = "ssh";
    algo = algo.toLowerCase();
    if (algs2.hashAlgs[algo] === void 0)
      throw new InvalidAlgorithmError(algo);
    var cacheKey = algo + "||" + type2;
    if (this._hashCache[cacheKey])
      return this._hashCache[cacheKey];
    var buf;
    if (type2 === "ssh") {
      buf = this.toBuffer("rfc4253");
    } else if (type2 === "spki") {
      buf = formats2.pkcs8.pkcs8ToBuffer(this);
    } else {
      throw new Error("Hash type " + type2 + " not supported");
    }
    var hash = crypto.createHash(algo).update(buf).digest();
    this._hashCache[cacheKey] = hash;
    return hash;
  };
  Key.prototype.fingerprint = function(algo, type2) {
    if (algo === void 0)
      algo = "sha256";
    if (type2 === void 0)
      type2 = "ssh";
    assert.string(algo, "algorithm");
    assert.string(type2, "type");
    var opts = {
      type: "key",
      hash: this.hash(algo, type2),
      algorithm: algo,
      hashType: type2
    };
    return new Fingerprint(opts);
  };
  Key.prototype.defaultHashAlgorithm = function() {
    var hashAlgo = "sha1";
    if (this.type === "rsa")
      hashAlgo = "sha256";
    if (this.type === "dsa" && this.size > 1024)
      hashAlgo = "sha256";
    if (this.type === "ed25519")
      hashAlgo = "sha512";
    if (this.type === "ecdsa") {
      if (this.size <= 256)
        hashAlgo = "sha256";
      else if (this.size <= 384)
        hashAlgo = "sha384";
      else
        hashAlgo = "sha512";
    }
    return hashAlgo;
  };
  Key.prototype.createVerify = function(hashAlgo) {
    if (hashAlgo === void 0)
      hashAlgo = this.defaultHashAlgorithm();
    assert.string(hashAlgo, "hash algorithm");
    if (this.type === "ed25519" && edCompat2 !== void 0)
      return new edCompat2.Verifier(this, hashAlgo);
    if (this.type === "curve25519")
      throw new Error("Curve25519 keys are not suitable for signing or verification");
    var v, nm, err;
    try {
      nm = hashAlgo.toUpperCase();
      v = crypto.createVerify(nm);
    } catch (e) {
      err = e;
    }
    if (v === void 0 || err instanceof Error && err.message.match(/Unknown message digest/)) {
      nm = "RSA-";
      nm += hashAlgo.toUpperCase();
      v = crypto.createVerify(nm);
    }
    assert.ok(v, "failed to create verifier");
    var oldVerify = v.verify.bind(v);
    var key2 = this.toBuffer("pkcs8");
    var curve = this.curve;
    var self2 = this;
    v.verify = function(signature2, fmt) {
      if (Signature.isSignature(signature2, [2, 0])) {
        if (signature2.type !== self2.type)
          return false;
        if (signature2.hashAlgorithm && signature2.hashAlgorithm !== hashAlgo)
          return false;
        if (signature2.curve && self2.type === "ecdsa" && signature2.curve !== curve)
          return false;
        return oldVerify(key2, signature2.toBuffer("asn1"));
      } else if (typeof signature2 === "string" || Buffer.isBuffer(signature2)) {
        return oldVerify(key2, signature2, fmt);
      } else if (Signature.isSignature(signature2, [1, 0])) {
        throw new Error("signature was created by too old a version of sshpk and cannot be verified");
      } else {
        throw new TypeError("signature must be a string, Buffer, or Signature object");
      }
    };
    return v;
  };
  Key.prototype.createDiffieHellman = function() {
    if (this.type === "rsa")
      throw new Error("RSA keys do not support Diffie-Hellman");
    return new DiffieHellman(this);
  };
  Key.prototype.createDH = Key.prototype.createDiffieHellman;
  Key.parse = function(data2, format2, options) {
    if (typeof data2 !== "string")
      assert.buffer(data2, "data");
    if (format2 === void 0)
      format2 = "auto";
    assert.string(format2, "format");
    if (typeof options === "string")
      options = { filename: options };
    assert.optionalObject(options, "options");
    if (options === void 0)
      options = {};
    assert.optionalString(options.filename, "options.filename");
    if (options.filename === void 0)
      options.filename = "(unnamed)";
    assert.object(formats2[format2], "formats[format]");
    try {
      var k = formats2[format2].read(data2, options);
      if (k instanceof PrivateKey)
        k = k.toPublic();
      if (!k.comment)
        k.comment = options.filename;
      return k;
    } catch (e) {
      if (e.name === "KeyEncryptedError")
        throw e;
      throw new KeyParseError(options.filename, format2, e);
    }
  };
  Key.isKey = function(obj, ver) {
    return utils2.isCompatible(obj, Key, ver);
  };
  Key.prototype._sshpkApiVersion = [1, 7];
  Key._oldVersionDetect = function(obj) {
    assert.func(obj.toBuffer);
    assert.func(obj.fingerprint);
    if (obj.createDH)
      return [1, 4];
    if (obj.defaultHashAlgorithm)
      return [1, 3];
    if (obj.formats["auto"])
      return [1, 2];
    if (obj.formats["pkcs1"])
      return [1, 1];
    return [1, 0];
  };
  return key;
}
var lib$3;
var hasRequiredLib$3;
function requireLib$3() {
  if (hasRequiredLib$3) return lib$3;
  hasRequiredLib$3 = 1;
  var Key = requireKey();
  var Fingerprint = requireFingerprint();
  var Signature = requireSignature();
  var PrivateKey = requirePrivateKey();
  var Certificate = requireCertificate();
  var Identity = requireIdentity();
  var errs = requireErrors$1();
  lib$3 = {
    /* top-level classes */
    Key,
    parseKey: Key.parse,
    Fingerprint,
    parseFingerprint: Fingerprint.parse,
    Signature,
    parseSignature: Signature.parse,
    PrivateKey,
    parsePrivateKey: PrivateKey.parse,
    generatePrivateKey: PrivateKey.generate,
    Certificate,
    parseCertificate: Certificate.parse,
    createSelfSignedCertificate: Certificate.createSelfSigned,
    createCertificate: Certificate.create,
    Identity,
    identityFromDN: Identity.parseDN,
    identityForHost: Identity.forHost,
    identityForUser: Identity.forUser,
    identityForEmail: Identity.forEmail,
    identityFromArray: Identity.fromArray,
    /* errors */
    FingerprintFormatError: errs.FingerprintFormatError,
    InvalidAlgorithmError: errs.InvalidAlgorithmError,
    KeyParseError: errs.KeyParseError,
    SignatureParseError: errs.SignatureParseError,
    KeyEncryptedError: errs.KeyEncryptedError,
    CertificateParseError: errs.CertificateParseError
  };
  return lib$3;
}
var utils$2;
var hasRequiredUtils$2;
function requireUtils$2() {
  if (hasRequiredUtils$2) return utils$2;
  hasRequiredUtils$2 = 1;
  var assert = requireAssert();
  var sshpk = requireLib$3();
  var util2 = require$$0$5;
  var HASH_ALGOS = {
    "sha1": true,
    "sha256": true,
    "sha512": true
  };
  var PK_ALGOS = {
    "rsa": true,
    "dsa": true,
    "ecdsa": true
  };
  function HttpSignatureError(message, caller) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, caller || HttpSignatureError);
    this.message = message;
    this.name = caller.name;
  }
  util2.inherits(HttpSignatureError, Error);
  function InvalidAlgorithmError(message) {
    HttpSignatureError.call(this, message, InvalidAlgorithmError);
  }
  util2.inherits(InvalidAlgorithmError, HttpSignatureError);
  function validateAlgorithm(algorithm) {
    var alg = algorithm.toLowerCase().split("-");
    if (alg.length !== 2) {
      throw new InvalidAlgorithmError(alg[0].toUpperCase() + " is not a valid algorithm");
    }
    if (alg[0] !== "hmac" && !PK_ALGOS[alg[0]]) {
      throw new InvalidAlgorithmError(alg[0].toUpperCase() + " type keys are not supported");
    }
    if (!HASH_ALGOS[alg[1]]) {
      throw new InvalidAlgorithmError(alg[1].toUpperCase() + " is not a supported hash algorithm");
    }
    return alg;
  }
  utils$2 = {
    HASH_ALGOS,
    PK_ALGOS,
    HttpSignatureError,
    InvalidAlgorithmError,
    validateAlgorithm,
    /**
     * Converts an OpenSSH public key (rsa only) to a PKCS#8 PEM file.
     *
     * The intent of this module is to interoperate with OpenSSL only,
     * specifically the node crypto module's `verify` method.
     *
     * @param {String} key an OpenSSH public key.
     * @return {String} PEM encoded form of the RSA public key.
     * @throws {TypeError} on bad input.
     * @throws {Error} on invalid ssh key formatted data.
     */
    sshKeyToPEM: function sshKeyToPEM(key2) {
      assert.string(key2, "ssh_key");
      var k = sshpk.parseKey(key2, "ssh");
      return k.toString("pem");
    },
    /**
     * Generates an OpenSSH fingerprint from an ssh public key.
     *
     * @param {String} key an OpenSSH public key.
     * @return {String} key fingerprint.
     * @throws {TypeError} on bad input.
     * @throws {Error} if what you passed doesn't look like an ssh public key.
     */
    fingerprint: function fingerprint2(key2) {
      assert.string(key2, "ssh_key");
      var k = sshpk.parseKey(key2, "ssh");
      return k.fingerprint("md5").toString("hex");
    },
    /**
     * Converts a PKGCS#8 PEM file to an OpenSSH public key (rsa)
     *
     * The reverse of the above function.
     */
    pemToRsaSSHKey: function pemToRsaSSHKey(pem2, comment2) {
      assert.equal("string", typeof pem2, "typeof pem");
      var k = sshpk.parseKey(pem2, "pem");
      k.comment = comment2;
      return k.toString("ssh");
    }
  };
  return utils$2;
}
var parser;
var hasRequiredParser;
function requireParser() {
  if (hasRequiredParser) return parser;
  hasRequiredParser = 1;
  var assert = requireAssert();
  var util2 = require$$0$5;
  var utils2 = requireUtils$2();
  utils2.HASH_ALGOS;
  utils2.PK_ALGOS;
  var HttpSignatureError = utils2.HttpSignatureError;
  var InvalidAlgorithmError = utils2.InvalidAlgorithmError;
  var validateAlgorithm = utils2.validateAlgorithm;
  var State = {
    New: 0,
    Params: 1
  };
  var ParamsState = {
    Name: 0,
    Quote: 1,
    Value: 2,
    Comma: 3
  };
  function ExpiredRequestError(message) {
    HttpSignatureError.call(this, message, ExpiredRequestError);
  }
  util2.inherits(ExpiredRequestError, HttpSignatureError);
  function InvalidHeaderError(message) {
    HttpSignatureError.call(this, message, InvalidHeaderError);
  }
  util2.inherits(InvalidHeaderError, HttpSignatureError);
  function InvalidParamsError(message) {
    HttpSignatureError.call(this, message, InvalidParamsError);
  }
  util2.inherits(InvalidParamsError, HttpSignatureError);
  function MissingHeaderError(message) {
    HttpSignatureError.call(this, message, MissingHeaderError);
  }
  util2.inherits(MissingHeaderError, HttpSignatureError);
  function StrictParsingError(message) {
    HttpSignatureError.call(this, message, StrictParsingError);
  }
  util2.inherits(StrictParsingError, HttpSignatureError);
  parser = {
    /**
     * Parses the 'Authorization' header out of an http.ServerRequest object.
     *
     * Note that this API will fully validate the Authorization header, and throw
     * on any error.  It will not however check the signature, or the keyId format
     * as those are specific to your environment.  You can use the options object
     * to pass in extra constraints.
     *
     * As a response object you can expect this:
     *
     *     {
     *       "scheme": "Signature",
     *       "params": {
     *         "keyId": "foo",
     *         "algorithm": "rsa-sha256",
     *         "headers": [
     *           "date" or "x-date",
     *           "digest"
     *         ],
     *         "signature": "base64"
     *       },
     *       "signingString": "ready to be passed to crypto.verify()"
     *     }
     *
     * @param {Object} request an http.ServerRequest.
     * @param {Object} options an optional options object with:
     *                   - clockSkew: allowed clock skew in seconds (default 300).
     *                   - headers: required header names (def: date or x-date)
     *                   - algorithms: algorithms to support (default: all).
     *                   - strict: should enforce latest spec parsing
     *                             (default: false).
     * @return {Object} parsed out object (see above).
     * @throws {TypeError} on invalid input.
     * @throws {InvalidHeaderError} on an invalid Authorization header error.
     * @throws {InvalidParamsError} if the params in the scheme are invalid.
     * @throws {MissingHeaderError} if the params indicate a header not present,
     *                              either in the request headers from the params,
     *                              or not in the params from a required header
     *                              in options.
     * @throws {StrictParsingError} if old attributes are used in strict parsing
     *                              mode.
     * @throws {ExpiredRequestError} if the value of date or x-date exceeds skew.
     */
    parseRequest: function parseRequest(request2, options) {
      assert.object(request2, "request");
      assert.object(request2.headers, "request.headers");
      if (options === void 0) {
        options = {};
      }
      if (options.headers === void 0) {
        options.headers = [request2.headers["x-date"] ? "x-date" : "date"];
      }
      assert.object(options, "options");
      assert.arrayOfString(options.headers, "options.headers");
      assert.optionalFinite(options.clockSkew, "options.clockSkew");
      var authzHeaderName = options.authorizationHeaderName || "authorization";
      if (!request2.headers[authzHeaderName]) {
        throw new MissingHeaderError("no " + authzHeaderName + " header present in the request");
      }
      options.clockSkew = options.clockSkew || 300;
      var i = 0;
      var state = State.New;
      var substate = ParamsState.Name;
      var tmpName = "";
      var tmpValue = "";
      var parsed = {
        scheme: "",
        params: {},
        signingString: ""
      };
      var authz = request2.headers[authzHeaderName];
      for (i = 0; i < authz.length; i++) {
        var c = authz.charAt(i);
        switch (Number(state)) {
          case State.New:
            if (c !== " ") parsed.scheme += c;
            else state = State.Params;
            break;
          case State.Params:
            switch (Number(substate)) {
              case ParamsState.Name:
                var code = c.charCodeAt(0);
                if (code >= 65 && code <= 90 || // A-Z
                code >= 97 && code <= 122) {
                  tmpName += c;
                } else if (c === "=") {
                  if (tmpName.length === 0)
                    throw new InvalidHeaderError("bad param format");
                  substate = ParamsState.Quote;
                } else {
                  throw new InvalidHeaderError("bad param format");
                }
                break;
              case ParamsState.Quote:
                if (c === '"') {
                  tmpValue = "";
                  substate = ParamsState.Value;
                } else {
                  throw new InvalidHeaderError("bad param format");
                }
                break;
              case ParamsState.Value:
                if (c === '"') {
                  parsed.params[tmpName] = tmpValue;
                  substate = ParamsState.Comma;
                } else {
                  tmpValue += c;
                }
                break;
              case ParamsState.Comma:
                if (c === ",") {
                  tmpName = "";
                  substate = ParamsState.Name;
                } else {
                  throw new InvalidHeaderError("bad param format");
                }
                break;
              default:
                throw new Error("Invalid substate");
            }
            break;
          default:
            throw new Error("Invalid substate");
        }
      }
      if (!parsed.params.headers || parsed.params.headers === "") {
        if (request2.headers["x-date"]) {
          parsed.params.headers = ["x-date"];
        } else {
          parsed.params.headers = ["date"];
        }
      } else {
        parsed.params.headers = parsed.params.headers.split(" ");
      }
      if (!parsed.scheme || parsed.scheme !== "Signature")
        throw new InvalidHeaderError('scheme was not "Signature"');
      if (!parsed.params.keyId)
        throw new InvalidHeaderError("keyId was not specified");
      if (!parsed.params.algorithm)
        throw new InvalidHeaderError("algorithm was not specified");
      if (!parsed.params.signature)
        throw new InvalidHeaderError("signature was not specified");
      parsed.params.algorithm = parsed.params.algorithm.toLowerCase();
      try {
        validateAlgorithm(parsed.params.algorithm);
      } catch (e) {
        if (e instanceof InvalidAlgorithmError)
          throw new InvalidParamsError(parsed.params.algorithm + " is not supported");
        else
          throw e;
      }
      for (i = 0; i < parsed.params.headers.length; i++) {
        var h = parsed.params.headers[i].toLowerCase();
        parsed.params.headers[i] = h;
        if (h === "request-line") {
          if (!options.strict) {
            parsed.signingString += request2.method + " " + request2.url + " HTTP/" + request2.httpVersion;
          } else {
            throw new StrictParsingError("request-line is not a valid header with strict parsing enabled.");
          }
        } else if (h === "(request-target)") {
          parsed.signingString += "(request-target): " + request2.method.toLowerCase() + " " + request2.url;
        } else {
          var value = request2.headers[h];
          if (value === void 0)
            throw new MissingHeaderError(h + " was not in the request");
          parsed.signingString += h + ": " + value;
        }
        if (i + 1 < parsed.params.headers.length)
          parsed.signingString += "\n";
      }
      var date;
      if (request2.headers.date || request2.headers["x-date"]) {
        if (request2.headers["x-date"]) {
          date = new Date(request2.headers["x-date"]);
        } else {
          date = new Date(request2.headers.date);
        }
        var now = /* @__PURE__ */ new Date();
        var skew = Math.abs(now.getTime() - date.getTime());
        if (skew > options.clockSkew * 1e3) {
          throw new ExpiredRequestError("clock skew of " + skew / 1e3 + "s was greater than " + options.clockSkew + "s");
        }
      }
      options.headers.forEach(function(hdr) {
        if (parsed.params.headers.indexOf(hdr.toLowerCase()) < 0)
          throw new MissingHeaderError(hdr + " was not a signed header");
      });
      if (options.algorithms) {
        if (options.algorithms.indexOf(parsed.params.algorithm) === -1)
          throw new InvalidParamsError(parsed.params.algorithm + " is not a supported algorithm");
      }
      parsed.algorithm = parsed.params.algorithm.toUpperCase();
      parsed.keyId = parsed.params.keyId;
      return parsed;
    }
  };
  return parser;
}
var jsprim = {};
var extsprintf = {};
var hasRequiredExtsprintf;
function requireExtsprintf() {
  if (hasRequiredExtsprintf) return extsprintf;
  hasRequiredExtsprintf = 1;
  var mod_assert = require$$0$6;
  var mod_util = require$$0$5;
  extsprintf.sprintf = jsSprintf;
  extsprintf.printf = jsPrintf;
  extsprintf.fprintf = jsFprintf;
  function jsSprintf(fmt) {
    var regex = [
      "([^%]*)",
      /* normal text */
      "%",
      /* start of format */
      "(['\\-+ #0]*?)",
      /* flags (optional) */
      "([1-9]\\d*)?",
      /* width (optional) */
      "(\\.([1-9]\\d*))?",
      /* precision (optional) */
      "[lhjztL]*?",
      /* length mods (ignored) */
      "([diouxXfFeEgGaAcCsSp%jr])"
      /* conversion */
    ].join("");
    var re = new RegExp(regex);
    var args = Array.prototype.slice.call(arguments, 1);
    var flags, width, precision, conversion;
    var left, pad, sign, arg, match;
    var ret = "";
    var argn = 1;
    mod_assert.equal("string", typeof fmt);
    while ((match = re.exec(fmt)) !== null) {
      ret += match[1];
      fmt = fmt.substring(match[0].length);
      flags = match[2] || "";
      width = match[3] || 0;
      precision = match[4] || "";
      conversion = match[6];
      left = false;
      sign = false;
      pad = " ";
      if (conversion == "%") {
        ret += "%";
        continue;
      }
      if (args.length === 0)
        throw new Error("too few args to sprintf");
      arg = args.shift();
      argn++;
      if (flags.match(/[\' #]/))
        throw new Error(
          "unsupported flags: " + flags
        );
      if (precision.length > 0)
        throw new Error(
          "non-zero precision not supported"
        );
      if (flags.match(/-/))
        left = true;
      if (flags.match(/0/))
        pad = "0";
      if (flags.match(/\+/))
        sign = true;
      switch (conversion) {
        case "s":
          if (arg === void 0 || arg === null)
            throw new Error("argument " + argn + ": attempted to print undefined or null as a string");
          ret += doPad(pad, width, left, arg.toString());
          break;
        case "d":
          arg = Math.floor(arg);
        /*jsl:fallthru*/
        case "f":
          sign = sign && arg > 0 ? "+" : "";
          ret += sign + doPad(
            pad,
            width,
            left,
            arg.toString()
          );
          break;
        case "x":
          ret += doPad(pad, width, left, arg.toString(16));
          break;
        case "j":
          if (width === 0)
            width = 10;
          ret += mod_util.inspect(arg, false, width);
          break;
        case "r":
          ret += dumpException(arg);
          break;
        default:
          throw new Error("unsupported conversion: " + conversion);
      }
    }
    ret += fmt;
    return ret;
  }
  function jsPrintf() {
    var args = Array.prototype.slice.call(arguments);
    args.unshift(process.stdout);
    jsFprintf.apply(null, args);
  }
  function jsFprintf(stream) {
    var args = Array.prototype.slice.call(arguments, 1);
    return stream.write(jsSprintf.apply(this, args));
  }
  function doPad(chr, width, left, str) {
    var ret = str;
    while (ret.length < width) {
      if (left)
        ret += chr;
      else
        ret = chr + ret;
    }
    return ret;
  }
  function dumpException(ex) {
    var ret;
    if (!(ex instanceof Error))
      throw new Error(jsSprintf("invalid type for %%r: %j", ex));
    ret = "EXCEPTION: " + ex.constructor.name + ": " + ex.stack;
    if (ex.cause && typeof ex.cause === "function") {
      var cex = ex.cause();
      if (cex) {
        ret += "\nCaused by: " + dumpException(cex);
      }
    }
    return ret;
  }
  return extsprintf;
}
var util$1 = {};
var hasRequiredUtil$1;
function requireUtil$1() {
  if (hasRequiredUtil$1) return util$1;
  hasRequiredUtil$1 = 1;
  function isArray(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString(arg) === "[object Array]";
  }
  util$1.isArray = isArray;
  function isBoolean(arg) {
    return typeof arg === "boolean";
  }
  util$1.isBoolean = isBoolean;
  function isNull(arg) {
    return arg === null;
  }
  util$1.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  util$1.isNullOrUndefined = isNullOrUndefined;
  function isNumber(arg) {
    return typeof arg === "number";
  }
  util$1.isNumber = isNumber;
  function isString(arg) {
    return typeof arg === "string";
  }
  util$1.isString = isString;
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  util$1.isSymbol = isSymbol;
  function isUndefined(arg) {
    return arg === void 0;
  }
  util$1.isUndefined = isUndefined;
  function isRegExp(re) {
    return objectToString(re) === "[object RegExp]";
  }
  util$1.isRegExp = isRegExp;
  function isObject(arg) {
    return typeof arg === "object" && arg !== null;
  }
  util$1.isObject = isObject;
  function isDate(d) {
    return objectToString(d) === "[object Date]";
  }
  util$1.isDate = isDate;
  function isError(e) {
    return objectToString(e) === "[object Error]" || e instanceof Error;
  }
  util$1.isError = isError;
  function isFunction(arg) {
    return typeof arg === "function";
  }
  util$1.isFunction = isFunction;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
    typeof arg === "undefined";
  }
  util$1.isPrimitive = isPrimitive;
  util$1.isBuffer = Buffer.isBuffer;
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
  return util$1;
}
var verror;
var hasRequiredVerror;
function requireVerror() {
  if (hasRequiredVerror) return verror;
  hasRequiredVerror = 1;
  var mod_assertplus = requireAssert();
  var mod_util = require$$0$5;
  var mod_extsprintf = requireExtsprintf();
  var mod_isError = requireUtil$1().isError;
  var sprintf = mod_extsprintf.sprintf;
  verror = VError;
  VError.VError = VError;
  VError.SError = SError;
  VError.WError = WError;
  VError.MultiError = MultiError;
  function parseConstructorArguments(args) {
    var argv, options, sprintf_args, shortmessage, k;
    mod_assertplus.object(args, "args");
    mod_assertplus.bool(args.strict, "args.strict");
    mod_assertplus.array(args.argv, "args.argv");
    argv = args.argv;
    if (argv.length === 0) {
      options = {};
      sprintf_args = [];
    } else if (mod_isError(argv[0])) {
      options = { "cause": argv[0] };
      sprintf_args = argv.slice(1);
    } else if (typeof argv[0] === "object") {
      options = {};
      for (k in argv[0]) {
        options[k] = argv[0][k];
      }
      sprintf_args = argv.slice(1);
    } else {
      mod_assertplus.string(
        argv[0],
        "first argument to VError, SError, or WError constructor must be a string, object, or Error"
      );
      options = {};
      sprintf_args = argv;
    }
    mod_assertplus.object(options);
    if (!options.strict && !args.strict) {
      sprintf_args = sprintf_args.map(function(a) {
        return a === null ? "null" : a === void 0 ? "undefined" : a;
      });
    }
    if (sprintf_args.length === 0) {
      shortmessage = "";
    } else {
      shortmessage = sprintf.apply(null, sprintf_args);
    }
    return {
      "options": options,
      "shortmessage": shortmessage
    };
  }
  function VError() {
    var args, obj, parsed, cause, ctor, message, k;
    args = Array.prototype.slice.call(arguments, 0);
    if (!(this instanceof VError)) {
      obj = Object.create(VError.prototype);
      VError.apply(obj, arguments);
      return obj;
    }
    parsed = parseConstructorArguments({
      "argv": args,
      "strict": false
    });
    if (parsed.options.name) {
      mod_assertplus.string(
        parsed.options.name,
        `error's "name" must be a string`
      );
      this.name = parsed.options.name;
    }
    this.jse_shortmsg = parsed.shortmessage;
    message = parsed.shortmessage;
    cause = parsed.options.cause;
    if (cause) {
      mod_assertplus.ok(mod_isError(cause), "cause is not an Error");
      this.jse_cause = cause;
      if (!parsed.options.skipCauseMessage) {
        message += ": " + cause.message;
      }
    }
    this.jse_info = {};
    if (parsed.options.info) {
      for (k in parsed.options.info) {
        this.jse_info[k] = parsed.options.info[k];
      }
    }
    this.message = message;
    Error.call(this, message);
    if (Error.captureStackTrace) {
      ctor = parsed.options.constructorOpt || this.constructor;
      Error.captureStackTrace(this, ctor);
    }
    return this;
  }
  mod_util.inherits(VError, Error);
  VError.prototype.name = "VError";
  VError.prototype.toString = function ve_toString() {
    var str = this.hasOwnProperty("name") && this.name || this.constructor.name || this.constructor.prototype.name;
    if (this.message)
      str += ": " + this.message;
    return str;
  };
  VError.prototype.cause = function ve_cause() {
    var cause = VError.cause(this);
    return cause === null ? void 0 : cause;
  };
  VError.cause = function(err) {
    mod_assertplus.ok(mod_isError(err), "err must be an Error");
    return mod_isError(err.jse_cause) ? err.jse_cause : null;
  };
  VError.info = function(err) {
    var rv, cause, k;
    mod_assertplus.ok(mod_isError(err), "err must be an Error");
    cause = VError.cause(err);
    if (cause !== null) {
      rv = VError.info(cause);
    } else {
      rv = {};
    }
    if (typeof err.jse_info == "object" && err.jse_info !== null) {
      for (k in err.jse_info) {
        rv[k] = err.jse_info[k];
      }
    }
    return rv;
  };
  VError.findCauseByName = function(err, name) {
    var cause;
    mod_assertplus.ok(mod_isError(err), "err must be an Error");
    mod_assertplus.string(name, "name");
    mod_assertplus.ok(name.length > 0, "name cannot be empty");
    for (cause = err; cause !== null; cause = VError.cause(cause)) {
      mod_assertplus.ok(mod_isError(cause));
      if (cause.name == name) {
        return cause;
      }
    }
    return null;
  };
  VError.hasCauseWithName = function(err, name) {
    return VError.findCauseByName(err, name) !== null;
  };
  VError.fullStack = function(err) {
    mod_assertplus.ok(mod_isError(err), "err must be an Error");
    var cause = VError.cause(err);
    if (cause) {
      return err.stack + "\ncaused by: " + VError.fullStack(cause);
    }
    return err.stack;
  };
  VError.errorFromList = function(errors2) {
    mod_assertplus.arrayOfObject(errors2, "errors");
    if (errors2.length === 0) {
      return null;
    }
    errors2.forEach(function(e) {
      mod_assertplus.ok(mod_isError(e));
    });
    if (errors2.length == 1) {
      return errors2[0];
    }
    return new MultiError(errors2);
  };
  VError.errorForEach = function(err, func) {
    mod_assertplus.ok(mod_isError(err), "err must be an Error");
    mod_assertplus.func(func, "func");
    if (err instanceof MultiError) {
      err.errors().forEach(function iterError(e) {
        func(e);
      });
    } else {
      func(err);
    }
  };
  function SError() {
    var args, obj, parsed, options;
    args = Array.prototype.slice.call(arguments, 0);
    if (!(this instanceof SError)) {
      obj = Object.create(SError.prototype);
      SError.apply(obj, arguments);
      return obj;
    }
    parsed = parseConstructorArguments({
      "argv": args,
      "strict": true
    });
    options = parsed.options;
    VError.call(this, options, "%s", parsed.shortmessage);
    return this;
  }
  mod_util.inherits(SError, VError);
  function MultiError(errors2) {
    mod_assertplus.array(errors2, "list of errors");
    mod_assertplus.ok(errors2.length > 0, "must be at least one error");
    this.ase_errors = errors2;
    VError.call(this, {
      "cause": errors2[0]
    }, "first of %d error%s", errors2.length, errors2.length == 1 ? "" : "s");
  }
  mod_util.inherits(MultiError, VError);
  MultiError.prototype.name = "MultiError";
  MultiError.prototype.errors = function me_errors() {
    return this.ase_errors.slice(0);
  };
  function WError() {
    var args, obj, parsed, options;
    args = Array.prototype.slice.call(arguments, 0);
    if (!(this instanceof WError)) {
      obj = Object.create(WError.prototype);
      WError.apply(obj, args);
      return obj;
    }
    parsed = parseConstructorArguments({
      "argv": args,
      "strict": false
    });
    options = parsed.options;
    options["skipCauseMessage"] = true;
    VError.call(this, options, "%s", parsed.shortmessage);
    return this;
  }
  mod_util.inherits(WError, VError);
  WError.prototype.name = "WError";
  WError.prototype.toString = function we_toString() {
    var str = this.hasOwnProperty("name") && this.name || this.constructor.name || this.constructor.prototype.name;
    if (this.message)
      str += ": " + this.message;
    if (this.jse_cause && this.jse_cause.message)
      str += "; caused by " + this.jse_cause.toString();
    return str;
  };
  WError.prototype.cause = function we_cause(c) {
    if (mod_isError(c))
      this.jse_cause = c;
    return this.jse_cause;
  };
  return verror;
}
var validate$2 = { exports: {} };
var validate$1 = validate$2.exports;
var hasRequiredValidate$1;
function requireValidate$1() {
  if (hasRequiredValidate$1) return validate$2.exports;
  hasRequiredValidate$1 = 1;
  (function(module) {
    (function(root, factory) {
      if (module.exports) {
        module.exports = factory();
      } else {
        root.jsonSchema = factory();
      }
    })(validate$1, function() {
      var exports$1 = validate2;
      exports$1.Integer = { type: "integer" };
      var primitiveConstructors = {
        String,
        Boolean,
        Number,
        Object,
        Array,
        Date
      };
      exports$1.validate = validate2;
      function validate2(instance, schema) {
        return validate2(instance, schema, { changing: false });
      }
      exports$1.checkPropertyChange = function(value, schema, property) {
        return validate2(value, schema, { changing: property || "property" });
      };
      var validate2 = exports$1._validate = function(instance, schema, options) {
        if (!options) options = {};
        var _changing = options.changing;
        function getType(schema2) {
          return schema2.type || primitiveConstructors[schema2.name] == schema2 && schema2.name.toLowerCase();
        }
        var errors2 = [];
        function checkProp(value, schema2, path, i) {
          var l;
          path += path ? typeof i == "number" ? "[" + i + "]" : typeof i == "undefined" ? "" : "." + i : i;
          function addError(message) {
            errors2.push({ property: path, message });
          }
          if ((typeof schema2 != "object" || schema2 instanceof Array) && (path || typeof schema2 != "function") && !(schema2 && getType(schema2))) {
            if (typeof schema2 == "function") {
              if (!(value instanceof schema2)) {
                addError("is not an instance of the class/constructor " + schema2.name);
              }
            } else if (schema2) {
              addError("Invalid schema/property definition " + schema2);
            }
            return null;
          }
          if (_changing && schema2.readonly) {
            addError("is a readonly field, it can not be changed");
          }
          if (schema2["extends"]) {
            checkProp(value, schema2["extends"], path, i);
          }
          function checkType(type2, value2) {
            if (type2) {
              if (typeof type2 == "string" && type2 != "any" && (type2 == "null" ? value2 !== null : typeof value2 != type2) && !(value2 instanceof Array && type2 == "array") && !(value2 instanceof Date && type2 == "date") && !(type2 == "integer" && value2 % 1 === 0)) {
                return [{ property: path, message: value2 + " - " + typeof value2 + " value found, but a " + type2 + " is required" }];
              }
              if (type2 instanceof Array) {
                var unionErrors = [];
                for (var j2 = 0; j2 < type2.length; j2++) {
                  if (!(unionErrors = checkType(type2[j2], value2)).length) {
                    break;
                  }
                }
                if (unionErrors.length) {
                  return unionErrors;
                }
              } else if (typeof type2 == "object") {
                var priorErrors = errors2;
                errors2 = [];
                checkProp(value2, type2, path);
                var theseErrors = errors2;
                errors2 = priorErrors;
                return theseErrors;
              }
            }
            return [];
          }
          if (value === void 0) {
            if (schema2.required) {
              addError("is missing and it is required");
            }
          } else {
            errors2 = errors2.concat(checkType(getType(schema2), value));
            if (schema2.disallow && !checkType(schema2.disallow, value).length) {
              addError(" disallowed value was matched");
            }
            if (value !== null) {
              if (value instanceof Array) {
                if (schema2.items) {
                  var itemsIsArray = schema2.items instanceof Array;
                  var propDef = schema2.items;
                  for (i = 0, l = value.length; i < l; i += 1) {
                    if (itemsIsArray)
                      propDef = schema2.items[i];
                    if (options.coerce)
                      value[i] = options.coerce(value[i], propDef);
                    errors2.concat(checkProp(value[i], propDef, path, i));
                  }
                }
                if (schema2.minItems && value.length < schema2.minItems) {
                  addError("There must be a minimum of " + schema2.minItems + " in the array");
                }
                if (schema2.maxItems && value.length > schema2.maxItems) {
                  addError("There must be a maximum of " + schema2.maxItems + " in the array");
                }
              } else if (schema2.properties || schema2.additionalProperties) {
                errors2.concat(checkObj(value, schema2.properties, path, schema2.additionalProperties));
              }
              if (schema2.pattern && typeof value == "string" && !value.match(schema2.pattern)) {
                addError("does not match the regex pattern " + schema2.pattern);
              }
              if (schema2.maxLength && typeof value == "string" && value.length > schema2.maxLength) {
                addError("may only be " + schema2.maxLength + " characters long");
              }
              if (schema2.minLength && typeof value == "string" && value.length < schema2.minLength) {
                addError("must be at least " + schema2.minLength + " characters long");
              }
              if (typeof schema2.minimum !== "undefined" && typeof value == typeof schema2.minimum && schema2.minimum > value) {
                addError("must have a minimum value of " + schema2.minimum);
              }
              if (typeof schema2.maximum !== "undefined" && typeof value == typeof schema2.maximum && schema2.maximum < value) {
                addError("must have a maximum value of " + schema2.maximum);
              }
              if (schema2["enum"]) {
                var enumer = schema2["enum"];
                l = enumer.length;
                var found;
                for (var j = 0; j < l; j++) {
                  if (enumer[j] === value) {
                    found = 1;
                    break;
                  }
                }
                if (!found) {
                  addError("does not have a value in the enumeration " + enumer.join(", "));
                }
              }
              if (typeof schema2.maxDecimal == "number" && value.toString().match(new RegExp("\\.[0-9]{" + (schema2.maxDecimal + 1) + ",}"))) {
                addError("may only have " + schema2.maxDecimal + " digits of decimal places");
              }
            }
          }
          return null;
        }
        function checkObj(instance2, objTypeDef, path, additionalProp) {
          if (typeof objTypeDef == "object") {
            if (typeof instance2 != "object" || instance2 instanceof Array) {
              errors2.push({ property: path, message: "an object is required" });
            }
            for (var i in objTypeDef) {
              if (objTypeDef.hasOwnProperty(i) && i != "__proto__" && i != "constructor") {
                var value = instance2.hasOwnProperty(i) ? instance2[i] : void 0;
                if (value === void 0 && options.existingOnly) continue;
                var propDef = objTypeDef[i];
                if (value === void 0 && propDef["default"]) {
                  value = instance2[i] = propDef["default"];
                }
                if (options.coerce && i in instance2) {
                  value = instance2[i] = options.coerce(value, propDef);
                }
                checkProp(value, propDef, path, i);
              }
            }
          }
          for (i in instance2) {
            if (instance2.hasOwnProperty(i) && !(i.charAt(0) == "_" && i.charAt(1) == "_") && objTypeDef && !objTypeDef[i] && additionalProp === false) {
              if (options.filter) {
                delete instance2[i];
                continue;
              } else {
                errors2.push({ property: path, message: "The property " + i + " is not defined in the schema and the schema does not allow additional properties" });
              }
            }
            var requires = objTypeDef && objTypeDef[i] && objTypeDef[i].requires;
            if (requires && !(requires in instance2)) {
              errors2.push({ property: path, message: "the presence of the property " + i + " requires that " + requires + " also be present" });
            }
            value = instance2[i];
            if (additionalProp && (!(objTypeDef && typeof objTypeDef == "object") || !(i in objTypeDef))) {
              if (options.coerce) {
                value = instance2[i] = options.coerce(value, additionalProp);
              }
              checkProp(value, additionalProp, path, i);
            }
            if (!_changing && value && value.$schema) {
              errors2 = errors2.concat(checkProp(value, value.$schema, path, i));
            }
          }
          return errors2;
        }
        if (schema) {
          checkProp(instance, schema, "", _changing || "");
        }
        if (!_changing && instance && instance.$schema) {
          checkProp(instance, instance.$schema, "", "");
        }
        return { valid: !errors2.length, errors: errors2 };
      };
      exports$1.mustBeValid = function(result) {
        if (!result.valid) {
          throw new TypeError(result.errors.map(function(error2) {
            return "for property " + error2.property + ": " + error2.message;
          }).join(", \n"));
        }
      };
      return exports$1;
    });
  })(validate$2);
  return validate$2.exports;
}
var hasRequiredJsprim;
function requireJsprim() {
  if (hasRequiredJsprim) return jsprim;
  hasRequiredJsprim = 1;
  var mod_assert = requireAssert();
  var mod_extsprintf = requireExtsprintf();
  var mod_verror = requireVerror();
  var mod_jsonschema = requireValidate$1();
  jsprim.deepCopy = deepCopy;
  jsprim.deepEqual = deepEqual;
  jsprim.isEmpty = isEmpty;
  jsprim.hasKey = hasKey;
  jsprim.forEachKey = forEachKey;
  jsprim.pluck = pluck;
  jsprim.flattenObject = flattenObject;
  jsprim.flattenIter = flattenIter;
  jsprim.validateJsonObject = validateJsonObjectJS;
  jsprim.validateJsonObjectJS = validateJsonObjectJS;
  jsprim.randElt = randElt;
  jsprim.extraProperties = extraProperties;
  jsprim.mergeObjects = mergeObjects;
  jsprim.startsWith = startsWith;
  jsprim.endsWith = endsWith;
  jsprim.parseInteger = parseInteger;
  jsprim.iso8601 = iso8601;
  jsprim.rfc1123 = rfc1123;
  jsprim.parseDateTime = parseDateTime;
  jsprim.hrtimediff = hrtimeDiff;
  jsprim.hrtimeDiff = hrtimeDiff;
  jsprim.hrtimeAccum = hrtimeAccum;
  jsprim.hrtimeAdd = hrtimeAdd;
  jsprim.hrtimeNanosec = hrtimeNanosec;
  jsprim.hrtimeMicrosec = hrtimeMicrosec;
  jsprim.hrtimeMillisec = hrtimeMillisec;
  function deepCopy(obj) {
    var ret, key2;
    var marker = "__deepCopy";
    if (obj && obj[marker])
      throw new Error("attempted deep copy of cyclic object");
    if (obj && obj.constructor == Object) {
      ret = {};
      obj[marker] = true;
      for (key2 in obj) {
        if (key2 == marker)
          continue;
        ret[key2] = deepCopy(obj[key2]);
      }
      delete obj[marker];
      return ret;
    }
    if (obj && obj.constructor == Array) {
      ret = [];
      obj[marker] = true;
      for (key2 = 0; key2 < obj.length; key2++)
        ret.push(deepCopy(obj[key2]));
      delete obj[marker];
      return ret;
    }
    return obj;
  }
  function deepEqual(obj1, obj2) {
    if (typeof obj1 != typeof obj2)
      return false;
    if (obj1 === null || obj2 === null || typeof obj1 != "object")
      return obj1 === obj2;
    if (obj1.constructor != obj2.constructor)
      return false;
    var k;
    for (k in obj1) {
      if (!obj2.hasOwnProperty(k))
        return false;
      if (!deepEqual(obj1[k], obj2[k]))
        return false;
    }
    for (k in obj2) {
      if (!obj1.hasOwnProperty(k))
        return false;
    }
    return true;
  }
  function isEmpty(obj) {
    var key2;
    for (key2 in obj)
      return false;
    return true;
  }
  function hasKey(obj, key2) {
    mod_assert.equal(typeof key2, "string");
    return Object.prototype.hasOwnProperty.call(obj, key2);
  }
  function forEachKey(obj, callback) {
    for (var key2 in obj) {
      if (hasKey(obj, key2)) {
        callback(key2, obj[key2]);
      }
    }
  }
  function pluck(obj, key2) {
    mod_assert.equal(typeof key2, "string");
    return pluckv(obj, key2);
  }
  function pluckv(obj, key2) {
    if (obj === null || typeof obj !== "object")
      return void 0;
    if (obj.hasOwnProperty(key2))
      return obj[key2];
    var i = key2.indexOf(".");
    if (i == -1)
      return void 0;
    var key1 = key2.substr(0, i);
    if (!obj.hasOwnProperty(key1))
      return void 0;
    return pluckv(obj[key1], key2.substr(i + 1));
  }
  function flattenIter(data2, depth, callback) {
    doFlattenIter(data2, depth, [], callback);
  }
  function doFlattenIter(data2, depth, accum, callback) {
    var each;
    var key2;
    if (depth === 0) {
      each = accum.slice(0);
      each.push(data2);
      callback(each);
      return;
    }
    mod_assert.ok(data2 !== null);
    mod_assert.equal(typeof data2, "object");
    mod_assert.equal(typeof depth, "number");
    mod_assert.ok(depth >= 0);
    for (key2 in data2) {
      each = accum.slice(0);
      each.push(key2);
      doFlattenIter(data2[key2], depth - 1, each, callback);
    }
  }
  function flattenObject(data2, depth) {
    if (depth === 0)
      return [data2];
    mod_assert.ok(data2 !== null);
    mod_assert.equal(typeof data2, "object");
    mod_assert.equal(typeof depth, "number");
    mod_assert.ok(depth >= 0);
    var rv = [];
    var key2;
    for (key2 in data2) {
      flattenObject(data2[key2], depth - 1).forEach(function(p) {
        rv.push([key2].concat(p));
      });
    }
    return rv;
  }
  function startsWith(str, prefix) {
    return str.substr(0, prefix.length) == prefix;
  }
  function endsWith(str, suffix) {
    return str.substr(
      str.length - suffix.length,
      suffix.length
    ) == suffix;
  }
  function iso8601(d) {
    if (typeof d == "number")
      d = new Date(d);
    mod_assert.ok(d.constructor === Date);
    return mod_extsprintf.sprintf(
      "%4d-%02d-%02dT%02d:%02d:%02d.%03dZ",
      d.getUTCFullYear(),
      d.getUTCMonth() + 1,
      d.getUTCDate(),
      d.getUTCHours(),
      d.getUTCMinutes(),
      d.getUTCSeconds(),
      d.getUTCMilliseconds()
    );
  }
  var RFC1123_MONTHS = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  var RFC1123_DAYS = [
    "Sun",
    "Mon",
    "Tue",
    "Wed",
    "Thu",
    "Fri",
    "Sat"
  ];
  function rfc1123(date) {
    return mod_extsprintf.sprintf(
      "%s, %02d %s %04d %02d:%02d:%02d GMT",
      RFC1123_DAYS[date.getUTCDay()],
      date.getUTCDate(),
      RFC1123_MONTHS[date.getUTCMonth()],
      date.getUTCFullYear(),
      date.getUTCHours(),
      date.getUTCMinutes(),
      date.getUTCSeconds()
    );
  }
  function parseDateTime(str) {
    var numeric = +str;
    if (!isNaN(numeric)) {
      return new Date(numeric);
    } else {
      return new Date(str);
    }
  }
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
  var PI_DEFAULTS = {
    base: 10,
    allowSign: true,
    allowPrefix: false,
    allowTrailing: false,
    allowImprecise: false,
    trimWhitespace: false,
    leadingZeroIsOctal: false
  };
  var CP_0 = 48;
  var CP_9 = 57;
  var CP_A = 65;
  var CP_B = 66;
  var CP_O = 79;
  var CP_T = 84;
  var CP_X = 88;
  var CP_Z = 90;
  var CP_a = 97;
  var CP_b = 98;
  var CP_o = 111;
  var CP_t = 116;
  var CP_x = 120;
  var CP_z = 122;
  var PI_CONV_DEC = 48;
  var PI_CONV_UC = 55;
  var PI_CONV_LC = 87;
  function parseInteger(str, uopts) {
    mod_assert.string(str, "str");
    mod_assert.optionalObject(uopts, "options");
    var baseOverride = false;
    var options = PI_DEFAULTS;
    if (uopts) {
      baseOverride = hasKey(uopts, "base");
      options = mergeObjects(options, uopts);
      mod_assert.number(options.base, "options.base");
      mod_assert.ok(options.base >= 2, "options.base >= 2");
      mod_assert.ok(options.base <= 36, "options.base <= 36");
      mod_assert.bool(options.allowSign, "options.allowSign");
      mod_assert.bool(options.allowPrefix, "options.allowPrefix");
      mod_assert.bool(
        options.allowTrailing,
        "options.allowTrailing"
      );
      mod_assert.bool(
        options.allowImprecise,
        "options.allowImprecise"
      );
      mod_assert.bool(
        options.trimWhitespace,
        "options.trimWhitespace"
      );
      mod_assert.bool(
        options.leadingZeroIsOctal,
        "options.leadingZeroIsOctal"
      );
      if (options.leadingZeroIsOctal) {
        mod_assert.ok(
          !baseOverride,
          '"base" and "leadingZeroIsOctal" are mutually exclusive'
        );
      }
    }
    var c;
    var pbase = -1;
    var base = options.base;
    var start;
    var mult = 1;
    var value = 0;
    var idx = 0;
    var len = str.length;
    if (options.trimWhitespace) {
      while (idx < len && isSpace(str.charCodeAt(idx))) {
        ++idx;
      }
    }
    if (options.allowSign) {
      if (str[idx] === "-") {
        idx += 1;
        mult = -1;
      } else if (str[idx] === "+") {
        idx += 1;
      }
    }
    if (str[idx] === "0") {
      if (options.allowPrefix) {
        pbase = prefixToBase(str.charCodeAt(idx + 1));
        if (pbase !== -1 && (!baseOverride || pbase === base)) {
          base = pbase;
          idx += 2;
        }
      }
      if (pbase === -1 && options.leadingZeroIsOctal) {
        base = 8;
      }
    }
    for (start = idx; idx < len; ++idx) {
      c = translateDigit(str.charCodeAt(idx));
      if (c !== -1 && c < base) {
        value *= base;
        value += c;
      } else {
        break;
      }
    }
    if (start === idx) {
      return new Error("invalid number: " + JSON.stringify(str));
    }
    if (options.trimWhitespace) {
      while (idx < len && isSpace(str.charCodeAt(idx))) {
        ++idx;
      }
    }
    if (idx < len && !options.allowTrailing) {
      return new Error("trailing characters after number: " + JSON.stringify(str.slice(idx)));
    }
    if (value === 0) {
      return 0;
    }
    var result = value * mult;
    if (!options.allowImprecise && (value > MAX_SAFE_INTEGER || result < MIN_SAFE_INTEGER)) {
      return new Error("number is outside of the supported range: " + JSON.stringify(str.slice(start, idx)));
    }
    return result;
  }
  function translateDigit(d) {
    if (d >= CP_0 && d <= CP_9) {
      return d - PI_CONV_DEC;
    } else if (d >= CP_A && d <= CP_Z) {
      return d - PI_CONV_UC;
    } else if (d >= CP_a && d <= CP_z) {
      return d - PI_CONV_LC;
    } else {
      return -1;
    }
  }
  function isSpace(c) {
    return c === 32 || c >= 9 && c <= 13 || c === 160 || c === 5760 || c === 6158 || c >= 8192 && c <= 8202 || c === 8232 || c === 8233 || c === 8239 || c === 8287 || c === 12288 || c === 65279;
  }
  function prefixToBase(c) {
    if (c === CP_b || c === CP_B) {
      return 2;
    } else if (c === CP_o || c === CP_O) {
      return 8;
    } else if (c === CP_t || c === CP_T) {
      return 10;
    } else if (c === CP_x || c === CP_X) {
      return 16;
    } else {
      return -1;
    }
  }
  function validateJsonObjectJS(schema, input) {
    var report = mod_jsonschema.validate(input, schema);
    if (report.errors.length === 0)
      return null;
    var error2 = report.errors[0];
    var propname = error2["property"];
    var reason = error2["message"].toLowerCase();
    var i, j;
    if ((i = reason.indexOf("the property ")) != -1 && (j = reason.indexOf(" is not defined in the schema and the schema does not allow additional properties")) != -1) {
      i += "the property ".length;
      if (propname === "")
        propname = reason.substr(i, j - i);
      else
        propname = propname + "." + reason.substr(i, j - i);
      reason = "unsupported property";
    }
    var rv = new mod_verror.VError('property "%s": %s', propname, reason);
    rv.jsv_details = error2;
    return rv;
  }
  function randElt(arr) {
    mod_assert.ok(
      Array.isArray(arr) && arr.length > 0,
      "randElt argument must be a non-empty array"
    );
    return arr[Math.floor(Math.random() * arr.length)];
  }
  function assertHrtime(a) {
    mod_assert.ok(
      a[0] >= 0 && a[1] >= 0,
      "negative numbers not allowed in hrtimes"
    );
    mod_assert.ok(a[1] < 1e9, "nanoseconds column overflow");
  }
  function hrtimeDiff(a, b) {
    assertHrtime(a);
    assertHrtime(b);
    mod_assert.ok(
      a[0] > b[0] || a[0] == b[0] && a[1] >= b[1],
      "negative differences not allowed"
    );
    var rv = [a[0] - b[0], 0];
    if (a[1] >= b[1]) {
      rv[1] = a[1] - b[1];
    } else {
      rv[0]--;
      rv[1] = 1e9 - (b[1] - a[1]);
    }
    return rv;
  }
  function hrtimeNanosec(a) {
    assertHrtime(a);
    return Math.floor(a[0] * 1e9 + a[1]);
  }
  function hrtimeMicrosec(a) {
    assertHrtime(a);
    return Math.floor(a[0] * 1e6 + a[1] / 1e3);
  }
  function hrtimeMillisec(a) {
    assertHrtime(a);
    return Math.floor(a[0] * 1e3 + a[1] / 1e6);
  }
  function hrtimeAccum(a, b) {
    assertHrtime(a);
    assertHrtime(b);
    a[1] += b[1];
    if (a[1] >= 1e9) {
      a[0]++;
      a[1] -= 1e9;
    }
    a[0] += b[0];
    return a;
  }
  function hrtimeAdd(a, b) {
    assertHrtime(a);
    var rv = [a[0], a[1]];
    return hrtimeAccum(rv, b);
  }
  function extraProperties(obj, allowed) {
    mod_assert.ok(
      typeof obj === "object" && obj !== null,
      "obj argument must be a non-null object"
    );
    mod_assert.ok(
      Array.isArray(allowed),
      "allowed argument must be an array of strings"
    );
    for (var i = 0; i < allowed.length; i++) {
      mod_assert.ok(
        typeof allowed[i] === "string",
        "allowed argument must be an array of strings"
      );
    }
    return Object.keys(obj).filter(function(key2) {
      return allowed.indexOf(key2) === -1;
    });
  }
  function mergeObjects(provided, overrides, defaults) {
    var rv, k;
    rv = {};
    if (defaults) {
      for (k in defaults)
        rv[k] = defaults[k];
    }
    if (provided) {
      for (k in provided)
        rv[k] = provided[k];
    }
    if (overrides) {
      for (k in overrides)
        rv[k] = overrides[k];
    }
    return rv;
  }
  return jsprim;
}
var signer;
var hasRequiredSigner;
function requireSigner() {
  if (hasRequiredSigner) return signer;
  hasRequiredSigner = 1;
  var assert = requireAssert();
  var crypto = require$$0$9;
  var util2 = require$$0$5;
  var sshpk = requireLib$3();
  var jsprim2 = requireJsprim();
  var utils2 = requireUtils$2();
  var sprintf = require$$0$5.format;
  var HASH_ALGOS = utils2.HASH_ALGOS;
  var PK_ALGOS = utils2.PK_ALGOS;
  var InvalidAlgorithmError = utils2.InvalidAlgorithmError;
  var HttpSignatureError = utils2.HttpSignatureError;
  var validateAlgorithm = utils2.validateAlgorithm;
  var AUTHZ_FMT = 'Signature keyId="%s",algorithm="%s",headers="%s",signature="%s"';
  function MissingHeaderError(message) {
    HttpSignatureError.call(this, message, MissingHeaderError);
  }
  util2.inherits(MissingHeaderError, HttpSignatureError);
  function StrictParsingError(message) {
    HttpSignatureError.call(this, message, StrictParsingError);
  }
  util2.inherits(StrictParsingError, HttpSignatureError);
  function RequestSigner(options) {
    assert.object(options, "options");
    var alg = [];
    if (options.algorithm !== void 0) {
      assert.string(options.algorithm, "options.algorithm");
      alg = validateAlgorithm(options.algorithm);
    }
    this.rs_alg = alg;
    if (options.sign !== void 0) {
      assert.func(options.sign, "options.sign");
      this.rs_signFunc = options.sign;
    } else if (alg[0] === "hmac" && options.key !== void 0) {
      assert.string(options.keyId, "options.keyId");
      this.rs_keyId = options.keyId;
      if (typeof options.key !== "string" && !Buffer.isBuffer(options.key))
        throw new TypeError("options.key for HMAC must be a string or Buffer");
      this.rs_signer = crypto.createHmac(alg[1].toUpperCase(), options.key);
      this.rs_signer.sign = function() {
        var digest = this.digest("base64");
        return {
          hashAlgorithm: alg[1],
          toString: function() {
            return digest;
          }
        };
      };
    } else if (options.key !== void 0) {
      var key2 = options.key;
      if (typeof key2 === "string" || Buffer.isBuffer(key2))
        key2 = sshpk.parsePrivateKey(key2);
      assert.ok(
        sshpk.PrivateKey.isPrivateKey(key2, [1, 2]),
        "options.key must be a sshpk.PrivateKey"
      );
      this.rs_key = key2;
      assert.string(options.keyId, "options.keyId");
      this.rs_keyId = options.keyId;
      if (!PK_ALGOS[key2.type]) {
        throw new InvalidAlgorithmError(key2.type.toUpperCase() + " type keys are not supported");
      }
      if (alg[0] !== void 0 && key2.type !== alg[0]) {
        throw new InvalidAlgorithmError("options.key must be a " + alg[0].toUpperCase() + " key, was given a " + key2.type.toUpperCase() + " key instead");
      }
      this.rs_signer = key2.createSign(alg[1]);
    } else {
      throw new TypeError("options.sign (func) or options.key is required");
    }
    this.rs_headers = [];
    this.rs_lines = [];
  }
  RequestSigner.prototype.writeHeader = function(header, value) {
    assert.string(header, "header");
    header = header.toLowerCase();
    assert.string(value, "value");
    this.rs_headers.push(header);
    if (this.rs_signFunc) {
      this.rs_lines.push(header + ": " + value);
    } else {
      var line = header + ": " + value;
      if (this.rs_headers.length > 0)
        line = "\n" + line;
      this.rs_signer.update(line);
    }
    return value;
  };
  RequestSigner.prototype.writeDateHeader = function() {
    return this.writeHeader("date", jsprim2.rfc1123(/* @__PURE__ */ new Date()));
  };
  RequestSigner.prototype.writeTarget = function(method, path) {
    assert.string(method, "method");
    assert.string(path, "path");
    method = method.toLowerCase();
    this.writeHeader("(request-target)", method + " " + path);
  };
  RequestSigner.prototype.sign = function(cb) {
    assert.func(cb, "callback");
    if (this.rs_headers.length < 1)
      throw new Error("At least one header must be signed");
    var alg, authz;
    if (this.rs_signFunc) {
      var data2 = this.rs_lines.join("\n");
      var self2 = this;
      this.rs_signFunc(data2, function(err, sig) {
        if (err) {
          cb(err);
          return;
        }
        try {
          assert.object(sig, "signature");
          assert.string(sig.keyId, "signature.keyId");
          assert.string(sig.algorithm, "signature.algorithm");
          assert.string(sig.signature, "signature.signature");
          alg = validateAlgorithm(sig.algorithm);
          authz = sprintf(
            AUTHZ_FMT,
            sig.keyId,
            sig.algorithm,
            self2.rs_headers.join(" "),
            sig.signature
          );
        } catch (e) {
          cb(e);
          return;
        }
        cb(null, authz);
      });
    } else {
      try {
        var sigObj = this.rs_signer.sign();
      } catch (e) {
        cb(e);
        return;
      }
      alg = (this.rs_alg[0] || this.rs_key.type) + "-" + sigObj.hashAlgorithm;
      var signature2 = sigObj.toString();
      authz = sprintf(
        AUTHZ_FMT,
        this.rs_keyId,
        alg,
        this.rs_headers.join(" "),
        signature2
      );
      cb(null, authz);
    }
  };
  signer = {
    /**
     * Identifies whether a given object is a request signer or not.
     *
     * @param {Object} object, the object to identify
     * @returns {Boolean}
     */
    isSigner: function(obj) {
      if (typeof obj === "object" && obj instanceof RequestSigner)
        return true;
      return false;
    },
    /**
     * Creates a request signer, used to asynchronously build a signature
     * for a request (does not have to be an http.ClientRequest).
     *
     * @param {Object} options, either:
     *                   - {String} keyId
     *                   - {String|Buffer} key
     *                   - {String} algorithm (optional, required for HMAC)
     *                 or:
     *                   - {Func} sign (data, cb)
     * @return {RequestSigner}
     */
    createSigner: function createSigner(options) {
      return new RequestSigner(options);
    },
    /**
     * Adds an 'Authorization' header to an http.ClientRequest object.
     *
     * Note that this API will add a Date header if it's not already set. Any
     * other headers in the options.headers array MUST be present, or this
     * will throw.
     *
     * You shouldn't need to check the return type; it's just there if you want
     * to be pedantic.
     *
     * The optional flag indicates whether parsing should use strict enforcement
     * of the version draft-cavage-http-signatures-04 of the spec or beyond.
     * The default is to be loose and support
     * older versions for compatibility.
     *
     * @param {Object} request an instance of http.ClientRequest.
     * @param {Object} options signing parameters object:
     *                   - {String} keyId required.
     *                   - {String} key required (either a PEM or HMAC key).
     *                   - {Array} headers optional; defaults to ['date'].
     *                   - {String} algorithm optional (unless key is HMAC);
     *                              default is the same as the sshpk default
     *                              signing algorithm for the type of key given
     *                   - {String} httpVersion optional; defaults to '1.1'.
     *                   - {Boolean} strict optional; defaults to 'false'.
     * @return {Boolean} true if Authorization (and optionally Date) were added.
     * @throws {TypeError} on bad parameter types (input).
     * @throws {InvalidAlgorithmError} if algorithm was bad or incompatible with
     *                                 the given key.
     * @throws {sshpk.KeyParseError} if key was bad.
     * @throws {MissingHeaderError} if a header to be signed was specified but
     *                              was not present.
     */
    signRequest: function signRequest(request2, options) {
      assert.object(request2, "request");
      assert.object(options, "options");
      assert.optionalString(options.algorithm, "options.algorithm");
      assert.string(options.keyId, "options.keyId");
      assert.optionalArrayOfString(options.headers, "options.headers");
      assert.optionalString(options.httpVersion, "options.httpVersion");
      if (!request2.getHeader("Date"))
        request2.setHeader("Date", jsprim2.rfc1123(/* @__PURE__ */ new Date()));
      if (!options.headers)
        options.headers = ["date"];
      if (!options.httpVersion)
        options.httpVersion = "1.1";
      var alg = [];
      if (options.algorithm) {
        options.algorithm = options.algorithm.toLowerCase();
        alg = validateAlgorithm(options.algorithm);
      }
      var i;
      var stringToSign = "";
      for (i = 0; i < options.headers.length; i++) {
        if (typeof options.headers[i] !== "string")
          throw new TypeError("options.headers must be an array of Strings");
        var h = options.headers[i].toLowerCase();
        if (h === "request-line") {
          if (!options.strict) {
            stringToSign += request2.method + " " + request2.path + " HTTP/" + options.httpVersion;
          } else {
            throw new StrictParsingError("request-line is not a valid header with strict parsing enabled.");
          }
        } else if (h === "(request-target)") {
          stringToSign += "(request-target): " + request2.method.toLowerCase() + " " + request2.path;
        } else {
          var value = request2.getHeader(h);
          if (value === void 0 || value === "") {
            throw new MissingHeaderError(h + " was not in the request");
          }
          stringToSign += h + ": " + value;
        }
        if (i + 1 < options.headers.length)
          stringToSign += "\n";
      }
      if (request2.hasOwnProperty("_stringToSign")) {
        request2._stringToSign = stringToSign;
      }
      var signature2;
      if (alg[0] === "hmac") {
        if (typeof options.key !== "string" && !Buffer.isBuffer(options.key))
          throw new TypeError("options.key must be a string or Buffer");
        var hmac = crypto.createHmac(alg[1].toUpperCase(), options.key);
        hmac.update(stringToSign);
        signature2 = hmac.digest("base64");
      } else {
        var key2 = options.key;
        if (typeof key2 === "string" || Buffer.isBuffer(key2))
          key2 = sshpk.parsePrivateKey(options.key);
        assert.ok(
          sshpk.PrivateKey.isPrivateKey(key2, [1, 2]),
          "options.key must be a sshpk.PrivateKey"
        );
        if (!PK_ALGOS[key2.type]) {
          throw new InvalidAlgorithmError(key2.type.toUpperCase() + " type keys are not supported");
        }
        if (alg[0] !== void 0 && key2.type !== alg[0]) {
          throw new InvalidAlgorithmError("options.key must be a " + alg[0].toUpperCase() + " key, was given a " + key2.type.toUpperCase() + " key instead");
        }
        var signer2 = key2.createSign(alg[1]);
        signer2.update(stringToSign);
        var sigObj = signer2.sign();
        if (!HASH_ALGOS[sigObj.hashAlgorithm]) {
          throw new InvalidAlgorithmError(sigObj.hashAlgorithm.toUpperCase() + " is not a supported hash algorithm");
        }
        options.algorithm = key2.type + "-" + sigObj.hashAlgorithm;
        signature2 = sigObj.toString();
        assert.notStrictEqual(signature2, "", "empty signature produced");
      }
      var authzHeaderName = options.authorizationHeaderName || "Authorization";
      request2.setHeader(authzHeaderName, sprintf(
        AUTHZ_FMT,
        options.keyId,
        options.algorithm,
        options.headers.join(" "),
        signature2
      ));
      return true;
    }
  };
  return signer;
}
var verify;
var hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify) return verify;
  hasRequiredVerify = 1;
  var assert = requireAssert();
  var crypto = require$$0$9;
  var sshpk = requireLib$3();
  var utils2 = requireUtils$2();
  utils2.HASH_ALGOS;
  utils2.PK_ALGOS;
  utils2.InvalidAlgorithmError;
  utils2.HttpSignatureError;
  var validateAlgorithm = utils2.validateAlgorithm;
  verify = {
    /**
     * Verify RSA/DSA signature against public key.  You are expected to pass in
     * an object that was returned from `parse()`.
     *
     * @param {Object} parsedSignature the object you got from `parse`.
     * @param {String} pubkey RSA/DSA private key PEM.
     * @return {Boolean} true if valid, false otherwise.
     * @throws {TypeError} if you pass in bad arguments.
     * @throws {InvalidAlgorithmError}
     */
    verifySignature: function verifySignature(parsedSignature, pubkey) {
      assert.object(parsedSignature, "parsedSignature");
      if (typeof pubkey === "string" || Buffer.isBuffer(pubkey))
        pubkey = sshpk.parseKey(pubkey);
      assert.ok(sshpk.Key.isKey(pubkey, [1, 1]), "pubkey must be a sshpk.Key");
      var alg = validateAlgorithm(parsedSignature.algorithm);
      if (alg[0] === "hmac" || alg[0] !== pubkey.type)
        return false;
      var v = pubkey.createVerify(alg[1]);
      v.update(parsedSignature.signingString);
      return v.verify(parsedSignature.params.signature, "base64");
    },
    /**
     * Verify HMAC against shared secret.  You are expected to pass in an object
     * that was returned from `parse()`.
     *
     * @param {Object} parsedSignature the object you got from `parse`.
     * @param {String} secret HMAC shared secret.
     * @return {Boolean} true if valid, false otherwise.
     * @throws {TypeError} if you pass in bad arguments.
     * @throws {InvalidAlgorithmError}
     */
    verifyHMAC: function verifyHMAC(parsedSignature, secret) {
      assert.object(parsedSignature, "parsedHMAC");
      assert.string(secret, "secret");
      var alg = validateAlgorithm(parsedSignature.algorithm);
      if (alg[0] !== "hmac")
        return false;
      var hashAlg = alg[1].toUpperCase();
      var hmac = crypto.createHmac(hashAlg, secret);
      hmac.update(parsedSignature.signingString);
      var h1 = crypto.createHmac(hashAlg, secret);
      h1.update(hmac.digest());
      h1 = h1.digest();
      var h2 = crypto.createHmac(hashAlg, secret);
      h2.update(new Buffer(parsedSignature.params.signature, "base64"));
      h2 = h2.digest();
      if (typeof h1 === "string")
        return h1 === h2;
      if (Buffer.isBuffer(h1) && !h1.equals)
        return h1.toString("binary") === h2.toString("binary");
      return h1.equals(h2);
    }
  };
  return verify;
}
var lib$2;
var hasRequiredLib$2;
function requireLib$2() {
  if (hasRequiredLib$2) return lib$2;
  hasRequiredLib$2 = 1;
  var parser2 = requireParser();
  var signer2 = requireSigner();
  var verify2 = requireVerify();
  var utils2 = requireUtils$2();
  lib$2 = {
    parse: parser2.parseRequest,
    parseRequest: parser2.parseRequest,
    sign: signer2.signRequest,
    signRequest: signer2.signRequest,
    createSigner: signer2.createSigner,
    isSigner: signer2.isSigner,
    sshKeyToPEM: utils2.sshKeyToPEM,
    sshKeyFingerprint: utils2.fingerprint,
    pemToRsaSSHKey: utils2.pemToRsaSSHKey,
    verify: verify2.verifySignature,
    verifySignature: verify2.verifySignature,
    verifyHMAC: verify2.verifyHMAC
  };
  return lib$2;
}
var mimeTypes = {};
const require$$0$1 = {
  "application/1d-interleaved-parityfec": { "source": "iana" },
  "application/3gpdash-qoe-report+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/3gpp-ims+xml": { "source": "iana", "compressible": true },
  "application/3gpphal+json": { "source": "iana", "compressible": true },
  "application/3gpphalforms+json": { "source": "iana", "compressible": true },
  "application/a2l": { "source": "iana" },
  "application/ace+cbor": { "source": "iana" },
  "application/activemessage": { "source": "iana" },
  "application/activity+json": { "source": "iana", "compressible": true },
  "application/alto-costmap+json": { "source": "iana", "compressible": true },
  "application/alto-costmapfilter+json": { "source": "iana", "compressible": true },
  "application/alto-directory+json": { "source": "iana", "compressible": true },
  "application/alto-endpointcost+json": { "source": "iana", "compressible": true },
  "application/alto-endpointcostparams+json": { "source": "iana", "compressible": true },
  "application/alto-endpointprop+json": { "source": "iana", "compressible": true },
  "application/alto-endpointpropparams+json": { "source": "iana", "compressible": true },
  "application/alto-error+json": { "source": "iana", "compressible": true },
  "application/alto-networkmap+json": { "source": "iana", "compressible": true },
  "application/alto-networkmapfilter+json": { "source": "iana", "compressible": true },
  "application/alto-updatestreamcontrol+json": { "source": "iana", "compressible": true },
  "application/alto-updatestreamparams+json": { "source": "iana", "compressible": true },
  "application/aml": { "source": "iana" },
  "application/andrew-inset": { "source": "iana", "extensions": ["ez"] },
  "application/applefile": { "source": "iana" },
  "application/applixware": { "source": "apache", "extensions": ["aw"] },
  "application/at+jwt": { "source": "iana" },
  "application/atf": { "source": "iana" },
  "application/atfx": { "source": "iana" },
  "application/atom+xml": { "source": "iana", "compressible": true, "extensions": ["atom"] },
  "application/atomcat+xml": { "source": "iana", "compressible": true, "extensions": ["atomcat"] },
  "application/atomdeleted+xml": { "source": "iana", "compressible": true, "extensions": ["atomdeleted"] },
  "application/atomicmail": { "source": "iana" },
  "application/atomsvc+xml": { "source": "iana", "compressible": true, "extensions": ["atomsvc"] },
  "application/atsc-dwd+xml": { "source": "iana", "compressible": true, "extensions": ["dwd"] },
  "application/atsc-dynamic-event-message": { "source": "iana" },
  "application/atsc-held+xml": { "source": "iana", "compressible": true, "extensions": ["held"] },
  "application/atsc-rdt+json": { "source": "iana", "compressible": true },
  "application/atsc-rsat+xml": { "source": "iana", "compressible": true, "extensions": ["rsat"] },
  "application/atxml": { "source": "iana" },
  "application/auth-policy+xml": { "source": "iana", "compressible": true },
  "application/bacnet-xdd+zip": { "source": "iana", "compressible": false },
  "application/batch-smtp": { "source": "iana" },
  "application/bdoc": { "compressible": false, "extensions": ["bdoc"] },
  "application/beep+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/calendar+json": { "source": "iana", "compressible": true },
  "application/calendar+xml": { "source": "iana", "compressible": true, "extensions": ["xcs"] },
  "application/call-completion": { "source": "iana" },
  "application/cals-1840": { "source": "iana" },
  "application/captive+json": { "source": "iana", "compressible": true },
  "application/cbor": { "source": "iana" },
  "application/cbor-seq": { "source": "iana" },
  "application/cccex": { "source": "iana" },
  "application/ccmp+xml": { "source": "iana", "compressible": true },
  "application/ccxml+xml": { "source": "iana", "compressible": true, "extensions": ["ccxml"] },
  "application/cdfx+xml": { "source": "iana", "compressible": true, "extensions": ["cdfx"] },
  "application/cdmi-capability": { "source": "iana", "extensions": ["cdmia"] },
  "application/cdmi-container": { "source": "iana", "extensions": ["cdmic"] },
  "application/cdmi-domain": { "source": "iana", "extensions": ["cdmid"] },
  "application/cdmi-object": { "source": "iana", "extensions": ["cdmio"] },
  "application/cdmi-queue": { "source": "iana", "extensions": ["cdmiq"] },
  "application/cdni": { "source": "iana" },
  "application/cea": { "source": "iana" },
  "application/cea-2018+xml": { "source": "iana", "compressible": true },
  "application/cellml+xml": { "source": "iana", "compressible": true },
  "application/cfw": { "source": "iana" },
  "application/city+json": { "source": "iana", "compressible": true },
  "application/clr": { "source": "iana" },
  "application/clue+xml": { "source": "iana", "compressible": true },
  "application/clue_info+xml": { "source": "iana", "compressible": true },
  "application/cms": { "source": "iana" },
  "application/cnrp+xml": { "source": "iana", "compressible": true },
  "application/coap-group+json": { "source": "iana", "compressible": true },
  "application/coap-payload": { "source": "iana" },
  "application/commonground": { "source": "iana" },
  "application/conference-info+xml": { "source": "iana", "compressible": true },
  "application/cose": { "source": "iana" },
  "application/cose-key": { "source": "iana" },
  "application/cose-key-set": { "source": "iana" },
  "application/cpl+xml": { "source": "iana", "compressible": true, "extensions": ["cpl"] },
  "application/csrattrs": { "source": "iana" },
  "application/csta+xml": { "source": "iana", "compressible": true },
  "application/cstadata+xml": { "source": "iana", "compressible": true },
  "application/csvm+json": { "source": "iana", "compressible": true },
  "application/cu-seeme": { "source": "apache", "extensions": ["cu"] },
  "application/cwt": { "source": "iana" },
  "application/cybercash": { "source": "iana" },
  "application/dart": { "compressible": true },
  "application/dash+xml": { "source": "iana", "compressible": true, "extensions": ["mpd"] },
  "application/dash-patch+xml": { "source": "iana", "compressible": true, "extensions": ["mpp"] },
  "application/dashdelta": { "source": "iana" },
  "application/davmount+xml": { "source": "iana", "compressible": true, "extensions": ["davmount"] },
  "application/dca-rft": { "source": "iana" },
  "application/dcd": { "source": "iana" },
  "application/dec-dx": { "source": "iana" },
  "application/dialog-info+xml": { "source": "iana", "compressible": true },
  "application/dicom": { "source": "iana" },
  "application/dicom+json": { "source": "iana", "compressible": true },
  "application/dicom+xml": { "source": "iana", "compressible": true },
  "application/dii": { "source": "iana" },
  "application/dit": { "source": "iana" },
  "application/dns": { "source": "iana" },
  "application/dns+json": { "source": "iana", "compressible": true },
  "application/dns-message": { "source": "iana" },
  "application/docbook+xml": { "source": "apache", "compressible": true, "extensions": ["dbk"] },
  "application/dots+cbor": { "source": "iana" },
  "application/dskpp+xml": { "source": "iana", "compressible": true },
  "application/dssc+der": { "source": "iana", "extensions": ["dssc"] },
  "application/dssc+xml": { "source": "iana", "compressible": true, "extensions": ["xdssc"] },
  "application/dvcs": { "source": "iana" },
  "application/ecmascript": { "source": "iana", "compressible": true, "extensions": ["es", "ecma"] },
  "application/edi-consent": { "source": "iana" },
  "application/edi-x12": { "source": "iana", "compressible": false },
  "application/edifact": { "source": "iana", "compressible": false },
  "application/efi": { "source": "iana" },
  "application/elm+json": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/elm+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.cap+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/emergencycalldata.comment+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.control+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.deviceinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.ecall.msd": { "source": "iana" },
  "application/emergencycalldata.providerinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.serviceinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.subscriberinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.veds+xml": { "source": "iana", "compressible": true },
  "application/emma+xml": { "source": "iana", "compressible": true, "extensions": ["emma"] },
  "application/emotionml+xml": { "source": "iana", "compressible": true, "extensions": ["emotionml"] },
  "application/encaprtp": { "source": "iana" },
  "application/epp+xml": { "source": "iana", "compressible": true },
  "application/epub+zip": { "source": "iana", "compressible": false, "extensions": ["epub"] },
  "application/eshop": { "source": "iana" },
  "application/exi": { "source": "iana", "extensions": ["exi"] },
  "application/expect-ct-report+json": { "source": "iana", "compressible": true },
  "application/express": { "source": "iana", "extensions": ["exp"] },
  "application/fastinfoset": { "source": "iana" },
  "application/fastsoap": { "source": "iana" },
  "application/fdt+xml": { "source": "iana", "compressible": true, "extensions": ["fdt"] },
  "application/fhir+json": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/fhir+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/fido.trusted-apps+json": { "compressible": true },
  "application/fits": { "source": "iana" },
  "application/flexfec": { "source": "iana" },
  "application/font-sfnt": { "source": "iana" },
  "application/font-tdpfr": { "source": "iana", "extensions": ["pfr"] },
  "application/font-woff": { "source": "iana", "compressible": false },
  "application/framework-attributes+xml": { "source": "iana", "compressible": true },
  "application/geo+json": { "source": "iana", "compressible": true, "extensions": ["geojson"] },
  "application/geo+json-seq": { "source": "iana" },
  "application/geopackage+sqlite3": { "source": "iana" },
  "application/geoxacml+xml": { "source": "iana", "compressible": true },
  "application/gltf-buffer": { "source": "iana" },
  "application/gml+xml": { "source": "iana", "compressible": true, "extensions": ["gml"] },
  "application/gpx+xml": { "source": "apache", "compressible": true, "extensions": ["gpx"] },
  "application/gxf": { "source": "apache", "extensions": ["gxf"] },
  "application/gzip": { "source": "iana", "compressible": false, "extensions": ["gz"] },
  "application/h224": { "source": "iana" },
  "application/held+xml": { "source": "iana", "compressible": true },
  "application/hjson": { "extensions": ["hjson"] },
  "application/http": { "source": "iana" },
  "application/hyperstudio": { "source": "iana", "extensions": ["stk"] },
  "application/ibe-key-request+xml": { "source": "iana", "compressible": true },
  "application/ibe-pkg-reply+xml": { "source": "iana", "compressible": true },
  "application/ibe-pp-data": { "source": "iana" },
  "application/iges": { "source": "iana" },
  "application/im-iscomposing+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/index": { "source": "iana" },
  "application/index.cmd": { "source": "iana" },
  "application/index.obj": { "source": "iana" },
  "application/index.response": { "source": "iana" },
  "application/index.vnd": { "source": "iana" },
  "application/inkml+xml": { "source": "iana", "compressible": true, "extensions": ["ink", "inkml"] },
  "application/iotp": { "source": "iana" },
  "application/ipfix": { "source": "iana", "extensions": ["ipfix"] },
  "application/ipp": { "source": "iana" },
  "application/isup": { "source": "iana" },
  "application/its+xml": { "source": "iana", "compressible": true, "extensions": ["its"] },
  "application/java-archive": { "source": "apache", "compressible": false, "extensions": ["jar", "war", "ear"] },
  "application/java-serialized-object": { "source": "apache", "compressible": false, "extensions": ["ser"] },
  "application/java-vm": { "source": "apache", "compressible": false, "extensions": ["class"] },
  "application/javascript": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["js", "mjs"] },
  "application/jf2feed+json": { "source": "iana", "compressible": true },
  "application/jose": { "source": "iana" },
  "application/jose+json": { "source": "iana", "compressible": true },
  "application/jrd+json": { "source": "iana", "compressible": true },
  "application/jscalendar+json": { "source": "iana", "compressible": true },
  "application/json": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["json", "map"] },
  "application/json-patch+json": { "source": "iana", "compressible": true },
  "application/json-seq": { "source": "iana" },
  "application/json5": { "extensions": ["json5"] },
  "application/jsonml+json": { "source": "apache", "compressible": true, "extensions": ["jsonml"] },
  "application/jwk+json": { "source": "iana", "compressible": true },
  "application/jwk-set+json": { "source": "iana", "compressible": true },
  "application/jwt": { "source": "iana" },
  "application/kpml-request+xml": { "source": "iana", "compressible": true },
  "application/kpml-response+xml": { "source": "iana", "compressible": true },
  "application/ld+json": { "source": "iana", "compressible": true, "extensions": ["jsonld"] },
  "application/lgr+xml": { "source": "iana", "compressible": true, "extensions": ["lgr"] },
  "application/link-format": { "source": "iana" },
  "application/load-control+xml": { "source": "iana", "compressible": true },
  "application/lost+xml": { "source": "iana", "compressible": true, "extensions": ["lostxml"] },
  "application/lostsync+xml": { "source": "iana", "compressible": true },
  "application/lpf+zip": { "source": "iana", "compressible": false },
  "application/lxf": { "source": "iana" },
  "application/mac-binhex40": { "source": "iana", "extensions": ["hqx"] },
  "application/mac-compactpro": { "source": "apache", "extensions": ["cpt"] },
  "application/macwriteii": { "source": "iana" },
  "application/mads+xml": { "source": "iana", "compressible": true, "extensions": ["mads"] },
  "application/manifest+json": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["webmanifest"] },
  "application/marc": { "source": "iana", "extensions": ["mrc"] },
  "application/marcxml+xml": { "source": "iana", "compressible": true, "extensions": ["mrcx"] },
  "application/mathematica": { "source": "iana", "extensions": ["ma", "nb", "mb"] },
  "application/mathml+xml": { "source": "iana", "compressible": true, "extensions": ["mathml"] },
  "application/mathml-content+xml": { "source": "iana", "compressible": true },
  "application/mathml-presentation+xml": { "source": "iana", "compressible": true },
  "application/mbms-associated-procedure-description+xml": { "source": "iana", "compressible": true },
  "application/mbms-deregister+xml": { "source": "iana", "compressible": true },
  "application/mbms-envelope+xml": { "source": "iana", "compressible": true },
  "application/mbms-msk+xml": { "source": "iana", "compressible": true },
  "application/mbms-msk-response+xml": { "source": "iana", "compressible": true },
  "application/mbms-protection-description+xml": { "source": "iana", "compressible": true },
  "application/mbms-reception-report+xml": { "source": "iana", "compressible": true },
  "application/mbms-register+xml": { "source": "iana", "compressible": true },
  "application/mbms-register-response+xml": { "source": "iana", "compressible": true },
  "application/mbms-schedule+xml": { "source": "iana", "compressible": true },
  "application/mbms-user-service-description+xml": { "source": "iana", "compressible": true },
  "application/mbox": { "source": "iana", "extensions": ["mbox"] },
  "application/media-policy-dataset+xml": { "source": "iana", "compressible": true, "extensions": ["mpf"] },
  "application/media_control+xml": { "source": "iana", "compressible": true },
  "application/mediaservercontrol+xml": { "source": "iana", "compressible": true, "extensions": ["mscml"] },
  "application/merge-patch+json": { "source": "iana", "compressible": true },
  "application/metalink+xml": { "source": "apache", "compressible": true, "extensions": ["metalink"] },
  "application/metalink4+xml": { "source": "iana", "compressible": true, "extensions": ["meta4"] },
  "application/mets+xml": { "source": "iana", "compressible": true, "extensions": ["mets"] },
  "application/mf4": { "source": "iana" },
  "application/mikey": { "source": "iana" },
  "application/mipc": { "source": "iana" },
  "application/missing-blocks+cbor-seq": { "source": "iana" },
  "application/mmt-aei+xml": { "source": "iana", "compressible": true, "extensions": ["maei"] },
  "application/mmt-usd+xml": { "source": "iana", "compressible": true, "extensions": ["musd"] },
  "application/mods+xml": { "source": "iana", "compressible": true, "extensions": ["mods"] },
  "application/moss-keys": { "source": "iana" },
  "application/moss-signature": { "source": "iana" },
  "application/mosskey-data": { "source": "iana" },
  "application/mosskey-request": { "source": "iana" },
  "application/mp21": { "source": "iana", "extensions": ["m21", "mp21"] },
  "application/mp4": { "source": "iana", "extensions": ["mp4s", "m4p"] },
  "application/mpeg4-generic": { "source": "iana" },
  "application/mpeg4-iod": { "source": "iana" },
  "application/mpeg4-iod-xmt": { "source": "iana" },
  "application/mrb-consumer+xml": { "source": "iana", "compressible": true },
  "application/mrb-publish+xml": { "source": "iana", "compressible": true },
  "application/msc-ivr+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/msc-mixer+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/msword": { "source": "iana", "compressible": false, "extensions": ["doc", "dot"] },
  "application/mud+json": { "source": "iana", "compressible": true },
  "application/multipart-core": { "source": "iana" },
  "application/mxf": { "source": "iana", "extensions": ["mxf"] },
  "application/n-quads": { "source": "iana", "extensions": ["nq"] },
  "application/n-triples": { "source": "iana", "extensions": ["nt"] },
  "application/nasdata": { "source": "iana" },
  "application/news-checkgroups": { "source": "iana", "charset": "US-ASCII" },
  "application/news-groupinfo": { "source": "iana", "charset": "US-ASCII" },
  "application/news-transmission": { "source": "iana" },
  "application/nlsml+xml": { "source": "iana", "compressible": true },
  "application/node": { "source": "iana", "extensions": ["cjs"] },
  "application/nss": { "source": "iana" },
  "application/oauth-authz-req+jwt": { "source": "iana" },
  "application/oblivious-dns-message": { "source": "iana" },
  "application/ocsp-request": { "source": "iana" },
  "application/ocsp-response": { "source": "iana" },
  "application/octet-stream": { "source": "iana", "compressible": false, "extensions": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"] },
  "application/oda": { "source": "iana", "extensions": ["oda"] },
  "application/odm+xml": { "source": "iana", "compressible": true },
  "application/odx": { "source": "iana" },
  "application/oebps-package+xml": { "source": "iana", "compressible": true, "extensions": ["opf"] },
  "application/ogg": { "source": "iana", "compressible": false, "extensions": ["ogx"] },
  "application/omdoc+xml": { "source": "apache", "compressible": true, "extensions": ["omdoc"] },
  "application/onenote": { "source": "apache", "extensions": ["onetoc", "onetoc2", "onetmp", "onepkg"] },
  "application/opc-nodeset+xml": { "source": "iana", "compressible": true },
  "application/oscore": { "source": "iana" },
  "application/oxps": { "source": "iana", "extensions": ["oxps"] },
  "application/p21": { "source": "iana" },
  "application/p21+zip": { "source": "iana", "compressible": false },
  "application/p2p-overlay+xml": { "source": "iana", "compressible": true, "extensions": ["relo"] },
  "application/parityfec": { "source": "iana" },
  "application/passport": { "source": "iana" },
  "application/patch-ops-error+xml": { "source": "iana", "compressible": true, "extensions": ["xer"] },
  "application/pdf": { "source": "iana", "compressible": false, "extensions": ["pdf"] },
  "application/pdx": { "source": "iana" },
  "application/pem-certificate-chain": { "source": "iana" },
  "application/pgp-encrypted": { "source": "iana", "compressible": false, "extensions": ["pgp"] },
  "application/pgp-keys": { "source": "iana", "extensions": ["asc"] },
  "application/pgp-signature": { "source": "iana", "extensions": ["asc", "sig"] },
  "application/pics-rules": { "source": "apache", "extensions": ["prf"] },
  "application/pidf+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/pidf-diff+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/pkcs10": { "source": "iana", "extensions": ["p10"] },
  "application/pkcs12": { "source": "iana" },
  "application/pkcs7-mime": { "source": "iana", "extensions": ["p7m", "p7c"] },
  "application/pkcs7-signature": { "source": "iana", "extensions": ["p7s"] },
  "application/pkcs8": { "source": "iana", "extensions": ["p8"] },
  "application/pkcs8-encrypted": { "source": "iana" },
  "application/pkix-attr-cert": { "source": "iana", "extensions": ["ac"] },
  "application/pkix-cert": { "source": "iana", "extensions": ["cer"] },
  "application/pkix-crl": { "source": "iana", "extensions": ["crl"] },
  "application/pkix-pkipath": { "source": "iana", "extensions": ["pkipath"] },
  "application/pkixcmp": { "source": "iana", "extensions": ["pki"] },
  "application/pls+xml": { "source": "iana", "compressible": true, "extensions": ["pls"] },
  "application/poc-settings+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/postscript": { "source": "iana", "compressible": true, "extensions": ["ai", "eps", "ps"] },
  "application/ppsp-tracker+json": { "source": "iana", "compressible": true },
  "application/problem+json": { "source": "iana", "compressible": true },
  "application/problem+xml": { "source": "iana", "compressible": true },
  "application/provenance+xml": { "source": "iana", "compressible": true, "extensions": ["provx"] },
  "application/prs.alvestrand.titrax-sheet": { "source": "iana" },
  "application/prs.cww": { "source": "iana", "extensions": ["cww"] },
  "application/prs.cyn": { "source": "iana", "charset": "7-BIT" },
  "application/prs.hpub+zip": { "source": "iana", "compressible": false },
  "application/prs.nprend": { "source": "iana" },
  "application/prs.plucker": { "source": "iana" },
  "application/prs.rdf-xml-crypt": { "source": "iana" },
  "application/prs.xsf+xml": { "source": "iana", "compressible": true },
  "application/pskc+xml": { "source": "iana", "compressible": true, "extensions": ["pskcxml"] },
  "application/pvd+json": { "source": "iana", "compressible": true },
  "application/qsig": { "source": "iana" },
  "application/raml+yaml": { "compressible": true, "extensions": ["raml"] },
  "application/raptorfec": { "source": "iana" },
  "application/rdap+json": { "source": "iana", "compressible": true },
  "application/rdf+xml": { "source": "iana", "compressible": true, "extensions": ["rdf", "owl"] },
  "application/reginfo+xml": { "source": "iana", "compressible": true, "extensions": ["rif"] },
  "application/relax-ng-compact-syntax": { "source": "iana", "extensions": ["rnc"] },
  "application/remote-printing": { "source": "iana" },
  "application/reputon+json": { "source": "iana", "compressible": true },
  "application/resource-lists+xml": { "source": "iana", "compressible": true, "extensions": ["rl"] },
  "application/resource-lists-diff+xml": { "source": "iana", "compressible": true, "extensions": ["rld"] },
  "application/rfc+xml": { "source": "iana", "compressible": true },
  "application/riscos": { "source": "iana" },
  "application/rlmi+xml": { "source": "iana", "compressible": true },
  "application/rls-services+xml": { "source": "iana", "compressible": true, "extensions": ["rs"] },
  "application/route-apd+xml": { "source": "iana", "compressible": true, "extensions": ["rapd"] },
  "application/route-s-tsid+xml": { "source": "iana", "compressible": true, "extensions": ["sls"] },
  "application/route-usd+xml": { "source": "iana", "compressible": true, "extensions": ["rusd"] },
  "application/rpki-ghostbusters": { "source": "iana", "extensions": ["gbr"] },
  "application/rpki-manifest": { "source": "iana", "extensions": ["mft"] },
  "application/rpki-publication": { "source": "iana" },
  "application/rpki-roa": { "source": "iana", "extensions": ["roa"] },
  "application/rpki-updown": { "source": "iana" },
  "application/rsd+xml": { "source": "apache", "compressible": true, "extensions": ["rsd"] },
  "application/rss+xml": { "source": "apache", "compressible": true, "extensions": ["rss"] },
  "application/rtf": { "source": "iana", "compressible": true, "extensions": ["rtf"] },
  "application/rtploopback": { "source": "iana" },
  "application/rtx": { "source": "iana" },
  "application/samlassertion+xml": { "source": "iana", "compressible": true },
  "application/samlmetadata+xml": { "source": "iana", "compressible": true },
  "application/sarif+json": { "source": "iana", "compressible": true },
  "application/sarif-external-properties+json": { "source": "iana", "compressible": true },
  "application/sbe": { "source": "iana" },
  "application/sbml+xml": { "source": "iana", "compressible": true, "extensions": ["sbml"] },
  "application/scaip+xml": { "source": "iana", "compressible": true },
  "application/scim+json": { "source": "iana", "compressible": true },
  "application/scvp-cv-request": { "source": "iana", "extensions": ["scq"] },
  "application/scvp-cv-response": { "source": "iana", "extensions": ["scs"] },
  "application/scvp-vp-request": { "source": "iana", "extensions": ["spq"] },
  "application/scvp-vp-response": { "source": "iana", "extensions": ["spp"] },
  "application/sdp": { "source": "iana", "extensions": ["sdp"] },
  "application/secevent+jwt": { "source": "iana" },
  "application/senml+cbor": { "source": "iana" },
  "application/senml+json": { "source": "iana", "compressible": true },
  "application/senml+xml": { "source": "iana", "compressible": true, "extensions": ["senmlx"] },
  "application/senml-etch+cbor": { "source": "iana" },
  "application/senml-etch+json": { "source": "iana", "compressible": true },
  "application/senml-exi": { "source": "iana" },
  "application/sensml+cbor": { "source": "iana" },
  "application/sensml+json": { "source": "iana", "compressible": true },
  "application/sensml+xml": { "source": "iana", "compressible": true, "extensions": ["sensmlx"] },
  "application/sensml-exi": { "source": "iana" },
  "application/sep+xml": { "source": "iana", "compressible": true },
  "application/sep-exi": { "source": "iana" },
  "application/session-info": { "source": "iana" },
  "application/set-payment": { "source": "iana" },
  "application/set-payment-initiation": { "source": "iana", "extensions": ["setpay"] },
  "application/set-registration": { "source": "iana" },
  "application/set-registration-initiation": { "source": "iana", "extensions": ["setreg"] },
  "application/sgml": { "source": "iana" },
  "application/sgml-open-catalog": { "source": "iana" },
  "application/shf+xml": { "source": "iana", "compressible": true, "extensions": ["shf"] },
  "application/sieve": { "source": "iana", "extensions": ["siv", "sieve"] },
  "application/simple-filter+xml": { "source": "iana", "compressible": true },
  "application/simple-message-summary": { "source": "iana" },
  "application/simplesymbolcontainer": { "source": "iana" },
  "application/sipc": { "source": "iana" },
  "application/slate": { "source": "iana" },
  "application/smil": { "source": "iana" },
  "application/smil+xml": { "source": "iana", "compressible": true, "extensions": ["smi", "smil"] },
  "application/smpte336m": { "source": "iana" },
  "application/soap+fastinfoset": { "source": "iana" },
  "application/soap+xml": { "source": "iana", "compressible": true },
  "application/sparql-query": { "source": "iana", "extensions": ["rq"] },
  "application/sparql-results+xml": { "source": "iana", "compressible": true, "extensions": ["srx"] },
  "application/spdx+json": { "source": "iana", "compressible": true },
  "application/spirits-event+xml": { "source": "iana", "compressible": true },
  "application/sql": { "source": "iana" },
  "application/srgs": { "source": "iana", "extensions": ["gram"] },
  "application/srgs+xml": { "source": "iana", "compressible": true, "extensions": ["grxml"] },
  "application/sru+xml": { "source": "iana", "compressible": true, "extensions": ["sru"] },
  "application/ssdl+xml": { "source": "apache", "compressible": true, "extensions": ["ssdl"] },
  "application/ssml+xml": { "source": "iana", "compressible": true, "extensions": ["ssml"] },
  "application/stix+json": { "source": "iana", "compressible": true },
  "application/swid+xml": { "source": "iana", "compressible": true, "extensions": ["swidtag"] },
  "application/tamp-apex-update": { "source": "iana" },
  "application/tamp-apex-update-confirm": { "source": "iana" },
  "application/tamp-community-update": { "source": "iana" },
  "application/tamp-community-update-confirm": { "source": "iana" },
  "application/tamp-error": { "source": "iana" },
  "application/tamp-sequence-adjust": { "source": "iana" },
  "application/tamp-sequence-adjust-confirm": { "source": "iana" },
  "application/tamp-status-query": { "source": "iana" },
  "application/tamp-status-response": { "source": "iana" },
  "application/tamp-update": { "source": "iana" },
  "application/tamp-update-confirm": { "source": "iana" },
  "application/tar": { "compressible": true },
  "application/taxii+json": { "source": "iana", "compressible": true },
  "application/td+json": { "source": "iana", "compressible": true },
  "application/tei+xml": { "source": "iana", "compressible": true, "extensions": ["tei", "teicorpus"] },
  "application/tetra_isi": { "source": "iana" },
  "application/thraud+xml": { "source": "iana", "compressible": true, "extensions": ["tfi"] },
  "application/timestamp-query": { "source": "iana" },
  "application/timestamp-reply": { "source": "iana" },
  "application/timestamped-data": { "source": "iana", "extensions": ["tsd"] },
  "application/tlsrpt+gzip": { "source": "iana" },
  "application/tlsrpt+json": { "source": "iana", "compressible": true },
  "application/tnauthlist": { "source": "iana" },
  "application/token-introspection+jwt": { "source": "iana" },
  "application/toml": { "compressible": true, "extensions": ["toml"] },
  "application/trickle-ice-sdpfrag": { "source": "iana" },
  "application/trig": { "source": "iana", "extensions": ["trig"] },
  "application/ttml+xml": { "source": "iana", "compressible": true, "extensions": ["ttml"] },
  "application/tve-trigger": { "source": "iana" },
  "application/tzif": { "source": "iana" },
  "application/tzif-leap": { "source": "iana" },
  "application/ubjson": { "compressible": false, "extensions": ["ubj"] },
  "application/ulpfec": { "source": "iana" },
  "application/urc-grpsheet+xml": { "source": "iana", "compressible": true },
  "application/urc-ressheet+xml": { "source": "iana", "compressible": true, "extensions": ["rsheet"] },
  "application/urc-targetdesc+xml": { "source": "iana", "compressible": true, "extensions": ["td"] },
  "application/urc-uisocketdesc+xml": { "source": "iana", "compressible": true },
  "application/vcard+json": { "source": "iana", "compressible": true },
  "application/vcard+xml": { "source": "iana", "compressible": true },
  "application/vemmi": { "source": "iana" },
  "application/vividence.scriptfile": { "source": "apache" },
  "application/vnd.1000minds.decision-model+xml": { "source": "iana", "compressible": true, "extensions": ["1km"] },
  "application/vnd.3gpp-prose+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-prose-pc3ch+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-v2x-local-service-information": { "source": "iana" },
  "application/vnd.3gpp.5gnas": { "source": "iana" },
  "application/vnd.3gpp.access-transfer-events+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.bsf+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.gmop+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.gtpc": { "source": "iana" },
  "application/vnd.3gpp.interworking-data": { "source": "iana" },
  "application/vnd.3gpp.lpp": { "source": "iana" },
  "application/vnd.3gpp.mc-signalling-ear": { "source": "iana" },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-payload": { "source": "iana" },
  "application/vnd.3gpp.mcdata-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-signalling": { "source": "iana" },
  "application/vnd.3gpp.mcdata-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-floor-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-location-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-signed+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-location-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mid-call+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.ngap": { "source": "iana" },
  "application/vnd.3gpp.pfcp": { "source": "iana" },
  "application/vnd.3gpp.pic-bw-large": { "source": "iana", "extensions": ["plb"] },
  "application/vnd.3gpp.pic-bw-small": { "source": "iana", "extensions": ["psb"] },
  "application/vnd.3gpp.pic-bw-var": { "source": "iana", "extensions": ["pvb"] },
  "application/vnd.3gpp.s1ap": { "source": "iana" },
  "application/vnd.3gpp.sms": { "source": "iana" },
  "application/vnd.3gpp.sms+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.srvcc-ext+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.srvcc-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.state-and-event-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.ussd+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp2.bcmcsinfo+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp2.sms": { "source": "iana" },
  "application/vnd.3gpp2.tcap": { "source": "iana", "extensions": ["tcap"] },
  "application/vnd.3lightssoftware.imagescal": { "source": "iana" },
  "application/vnd.3m.post-it-notes": { "source": "iana", "extensions": ["pwn"] },
  "application/vnd.accpac.simply.aso": { "source": "iana", "extensions": ["aso"] },
  "application/vnd.accpac.simply.imp": { "source": "iana", "extensions": ["imp"] },
  "application/vnd.acucobol": { "source": "iana", "extensions": ["acu"] },
  "application/vnd.acucorp": { "source": "iana", "extensions": ["atc", "acutc"] },
  "application/vnd.adobe.air-application-installer-package+zip": { "source": "apache", "compressible": false, "extensions": ["air"] },
  "application/vnd.adobe.flash.movie": { "source": "iana" },
  "application/vnd.adobe.formscentral.fcdt": { "source": "iana", "extensions": ["fcdt"] },
  "application/vnd.adobe.fxp": { "source": "iana", "extensions": ["fxp", "fxpl"] },
  "application/vnd.adobe.partial-upload": { "source": "iana" },
  "application/vnd.adobe.xdp+xml": { "source": "iana", "compressible": true, "extensions": ["xdp"] },
  "application/vnd.adobe.xfdf": { "source": "iana", "extensions": ["xfdf"] },
  "application/vnd.aether.imp": { "source": "iana" },
  "application/vnd.afpc.afplinedata": { "source": "iana" },
  "application/vnd.afpc.afplinedata-pagedef": { "source": "iana" },
  "application/vnd.afpc.cmoca-cmresource": { "source": "iana" },
  "application/vnd.afpc.foca-charset": { "source": "iana" },
  "application/vnd.afpc.foca-codedfont": { "source": "iana" },
  "application/vnd.afpc.foca-codepage": { "source": "iana" },
  "application/vnd.afpc.modca": { "source": "iana" },
  "application/vnd.afpc.modca-cmtable": { "source": "iana" },
  "application/vnd.afpc.modca-formdef": { "source": "iana" },
  "application/vnd.afpc.modca-mediummap": { "source": "iana" },
  "application/vnd.afpc.modca-objectcontainer": { "source": "iana" },
  "application/vnd.afpc.modca-overlay": { "source": "iana" },
  "application/vnd.afpc.modca-pagesegment": { "source": "iana" },
  "application/vnd.age": { "source": "iana", "extensions": ["age"] },
  "application/vnd.ah-barcode": { "source": "iana" },
  "application/vnd.ahead.space": { "source": "iana", "extensions": ["ahead"] },
  "application/vnd.airzip.filesecure.azf": { "source": "iana", "extensions": ["azf"] },
  "application/vnd.airzip.filesecure.azs": { "source": "iana", "extensions": ["azs"] },
  "application/vnd.amadeus+json": { "source": "iana", "compressible": true },
  "application/vnd.amazon.ebook": { "source": "apache", "extensions": ["azw"] },
  "application/vnd.amazon.mobi8-ebook": { "source": "iana" },
  "application/vnd.americandynamics.acc": { "source": "iana", "extensions": ["acc"] },
  "application/vnd.amiga.ami": { "source": "iana", "extensions": ["ami"] },
  "application/vnd.amundsen.maze+xml": { "source": "iana", "compressible": true },
  "application/vnd.android.ota": { "source": "iana" },
  "application/vnd.android.package-archive": { "source": "apache", "compressible": false, "extensions": ["apk"] },
  "application/vnd.anki": { "source": "iana" },
  "application/vnd.anser-web-certificate-issue-initiation": { "source": "iana", "extensions": ["cii"] },
  "application/vnd.anser-web-funds-transfer-initiation": { "source": "apache", "extensions": ["fti"] },
  "application/vnd.antix.game-component": { "source": "iana", "extensions": ["atx"] },
  "application/vnd.apache.arrow.file": { "source": "iana" },
  "application/vnd.apache.arrow.stream": { "source": "iana" },
  "application/vnd.apache.thrift.binary": { "source": "iana" },
  "application/vnd.apache.thrift.compact": { "source": "iana" },
  "application/vnd.apache.thrift.json": { "source": "iana" },
  "application/vnd.api+json": { "source": "iana", "compressible": true },
  "application/vnd.aplextor.warrp+json": { "source": "iana", "compressible": true },
  "application/vnd.apothekende.reservation+json": { "source": "iana", "compressible": true },
  "application/vnd.apple.installer+xml": { "source": "iana", "compressible": true, "extensions": ["mpkg"] },
  "application/vnd.apple.keynote": { "source": "iana", "extensions": ["key"] },
  "application/vnd.apple.mpegurl": { "source": "iana", "extensions": ["m3u8"] },
  "application/vnd.apple.numbers": { "source": "iana", "extensions": ["numbers"] },
  "application/vnd.apple.pages": { "source": "iana", "extensions": ["pages"] },
  "application/vnd.apple.pkpass": { "compressible": false, "extensions": ["pkpass"] },
  "application/vnd.arastra.swi": { "source": "iana" },
  "application/vnd.aristanetworks.swi": { "source": "iana", "extensions": ["swi"] },
  "application/vnd.artisan+json": { "source": "iana", "compressible": true },
  "application/vnd.artsquare": { "source": "iana" },
  "application/vnd.astraea-software.iota": { "source": "iana", "extensions": ["iota"] },
  "application/vnd.audiograph": { "source": "iana", "extensions": ["aep"] },
  "application/vnd.autopackage": { "source": "iana" },
  "application/vnd.avalon+json": { "source": "iana", "compressible": true },
  "application/vnd.avistar+xml": { "source": "iana", "compressible": true },
  "application/vnd.balsamiq.bmml+xml": { "source": "iana", "compressible": true, "extensions": ["bmml"] },
  "application/vnd.balsamiq.bmpr": { "source": "iana" },
  "application/vnd.banana-accounting": { "source": "iana" },
  "application/vnd.bbf.usp.error": { "source": "iana" },
  "application/vnd.bbf.usp.msg": { "source": "iana" },
  "application/vnd.bbf.usp.msg+json": { "source": "iana", "compressible": true },
  "application/vnd.bekitzur-stech+json": { "source": "iana", "compressible": true },
  "application/vnd.bint.med-content": { "source": "iana" },
  "application/vnd.biopax.rdf+xml": { "source": "iana", "compressible": true },
  "application/vnd.blink-idb-value-wrapper": { "source": "iana" },
  "application/vnd.blueice.multipass": { "source": "iana", "extensions": ["mpm"] },
  "application/vnd.bluetooth.ep.oob": { "source": "iana" },
  "application/vnd.bluetooth.le.oob": { "source": "iana" },
  "application/vnd.bmi": { "source": "iana", "extensions": ["bmi"] },
  "application/vnd.bpf": { "source": "iana" },
  "application/vnd.bpf3": { "source": "iana" },
  "application/vnd.businessobjects": { "source": "iana", "extensions": ["rep"] },
  "application/vnd.byu.uapi+json": { "source": "iana", "compressible": true },
  "application/vnd.cab-jscript": { "source": "iana" },
  "application/vnd.canon-cpdl": { "source": "iana" },
  "application/vnd.canon-lips": { "source": "iana" },
  "application/vnd.capasystems-pg+json": { "source": "iana", "compressible": true },
  "application/vnd.cendio.thinlinc.clientconf": { "source": "iana" },
  "application/vnd.century-systems.tcp_stream": { "source": "iana" },
  "application/vnd.chemdraw+xml": { "source": "iana", "compressible": true, "extensions": ["cdxml"] },
  "application/vnd.chess-pgn": { "source": "iana" },
  "application/vnd.chipnuts.karaoke-mmd": { "source": "iana", "extensions": ["mmd"] },
  "application/vnd.ciedi": { "source": "iana" },
  "application/vnd.cinderella": { "source": "iana", "extensions": ["cdy"] },
  "application/vnd.cirpack.isdn-ext": { "source": "iana" },
  "application/vnd.citationstyles.style+xml": { "source": "iana", "compressible": true, "extensions": ["csl"] },
  "application/vnd.claymore": { "source": "iana", "extensions": ["cla"] },
  "application/vnd.cloanto.rp9": { "source": "iana", "extensions": ["rp9"] },
  "application/vnd.clonk.c4group": { "source": "iana", "extensions": ["c4g", "c4d", "c4f", "c4p", "c4u"] },
  "application/vnd.cluetrust.cartomobile-config": { "source": "iana", "extensions": ["c11amc"] },
  "application/vnd.cluetrust.cartomobile-config-pkg": { "source": "iana", "extensions": ["c11amz"] },
  "application/vnd.coffeescript": { "source": "iana" },
  "application/vnd.collabio.xodocuments.document": { "source": "iana" },
  "application/vnd.collabio.xodocuments.document-template": { "source": "iana" },
  "application/vnd.collabio.xodocuments.presentation": { "source": "iana" },
  "application/vnd.collabio.xodocuments.presentation-template": { "source": "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet": { "source": "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet-template": { "source": "iana" },
  "application/vnd.collection+json": { "source": "iana", "compressible": true },
  "application/vnd.collection.doc+json": { "source": "iana", "compressible": true },
  "application/vnd.collection.next+json": { "source": "iana", "compressible": true },
  "application/vnd.comicbook+zip": { "source": "iana", "compressible": false },
  "application/vnd.comicbook-rar": { "source": "iana" },
  "application/vnd.commerce-battelle": { "source": "iana" },
  "application/vnd.commonspace": { "source": "iana", "extensions": ["csp"] },
  "application/vnd.contact.cmsg": { "source": "iana", "extensions": ["cdbcmsg"] },
  "application/vnd.coreos.ignition+json": { "source": "iana", "compressible": true },
  "application/vnd.cosmocaller": { "source": "iana", "extensions": ["cmc"] },
  "application/vnd.crick.clicker": { "source": "iana", "extensions": ["clkx"] },
  "application/vnd.crick.clicker.keyboard": { "source": "iana", "extensions": ["clkk"] },
  "application/vnd.crick.clicker.palette": { "source": "iana", "extensions": ["clkp"] },
  "application/vnd.crick.clicker.template": { "source": "iana", "extensions": ["clkt"] },
  "application/vnd.crick.clicker.wordbank": { "source": "iana", "extensions": ["clkw"] },
  "application/vnd.criticaltools.wbs+xml": { "source": "iana", "compressible": true, "extensions": ["wbs"] },
  "application/vnd.cryptii.pipe+json": { "source": "iana", "compressible": true },
  "application/vnd.crypto-shade-file": { "source": "iana" },
  "application/vnd.cryptomator.encrypted": { "source": "iana" },
  "application/vnd.cryptomator.vault": { "source": "iana" },
  "application/vnd.ctc-posml": { "source": "iana", "extensions": ["pml"] },
  "application/vnd.ctct.ws+xml": { "source": "iana", "compressible": true },
  "application/vnd.cups-pdf": { "source": "iana" },
  "application/vnd.cups-postscript": { "source": "iana" },
  "application/vnd.cups-ppd": { "source": "iana", "extensions": ["ppd"] },
  "application/vnd.cups-raster": { "source": "iana" },
  "application/vnd.cups-raw": { "source": "iana" },
  "application/vnd.curl": { "source": "iana" },
  "application/vnd.curl.car": { "source": "apache", "extensions": ["car"] },
  "application/vnd.curl.pcurl": { "source": "apache", "extensions": ["pcurl"] },
  "application/vnd.cyan.dean.root+xml": { "source": "iana", "compressible": true },
  "application/vnd.cybank": { "source": "iana" },
  "application/vnd.cyclonedx+json": { "source": "iana", "compressible": true },
  "application/vnd.cyclonedx+xml": { "source": "iana", "compressible": true },
  "application/vnd.d2l.coursepackage1p0+zip": { "source": "iana", "compressible": false },
  "application/vnd.d3m-dataset": { "source": "iana" },
  "application/vnd.d3m-problem": { "source": "iana" },
  "application/vnd.dart": { "source": "iana", "compressible": true, "extensions": ["dart"] },
  "application/vnd.data-vision.rdz": { "source": "iana", "extensions": ["rdz"] },
  "application/vnd.datapackage+json": { "source": "iana", "compressible": true },
  "application/vnd.dataresource+json": { "source": "iana", "compressible": true },
  "application/vnd.dbf": { "source": "iana", "extensions": ["dbf"] },
  "application/vnd.debian.binary-package": { "source": "iana" },
  "application/vnd.dece.data": { "source": "iana", "extensions": ["uvf", "uvvf", "uvd", "uvvd"] },
  "application/vnd.dece.ttml+xml": { "source": "iana", "compressible": true, "extensions": ["uvt", "uvvt"] },
  "application/vnd.dece.unspecified": { "source": "iana", "extensions": ["uvx", "uvvx"] },
  "application/vnd.dece.zip": { "source": "iana", "extensions": ["uvz", "uvvz"] },
  "application/vnd.denovo.fcselayout-link": { "source": "iana", "extensions": ["fe_launch"] },
  "application/vnd.desmume.movie": { "source": "iana" },
  "application/vnd.dir-bi.plate-dl-nosuffix": { "source": "iana" },
  "application/vnd.dm.delegation+xml": { "source": "iana", "compressible": true },
  "application/vnd.dna": { "source": "iana", "extensions": ["dna"] },
  "application/vnd.document+json": { "source": "iana", "compressible": true },
  "application/vnd.dolby.mlp": { "source": "apache", "extensions": ["mlp"] },
  "application/vnd.dolby.mobile.1": { "source": "iana" },
  "application/vnd.dolby.mobile.2": { "source": "iana" },
  "application/vnd.doremir.scorecloud-binary-document": { "source": "iana" },
  "application/vnd.dpgraph": { "source": "iana", "extensions": ["dpg"] },
  "application/vnd.dreamfactory": { "source": "iana", "extensions": ["dfac"] },
  "application/vnd.drive+json": { "source": "iana", "compressible": true },
  "application/vnd.ds-keypoint": { "source": "apache", "extensions": ["kpxx"] },
  "application/vnd.dtg.local": { "source": "iana" },
  "application/vnd.dtg.local.flash": { "source": "iana" },
  "application/vnd.dtg.local.html": { "source": "iana" },
  "application/vnd.dvb.ait": { "source": "iana", "extensions": ["ait"] },
  "application/vnd.dvb.dvbisl+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.dvbj": { "source": "iana" },
  "application/vnd.dvb.esgcontainer": { "source": "iana" },
  "application/vnd.dvb.ipdcdftnotifaccess": { "source": "iana" },
  "application/vnd.dvb.ipdcesgaccess": { "source": "iana" },
  "application/vnd.dvb.ipdcesgaccess2": { "source": "iana" },
  "application/vnd.dvb.ipdcesgpdd": { "source": "iana" },
  "application/vnd.dvb.ipdcroaming": { "source": "iana" },
  "application/vnd.dvb.iptv.alfec-base": { "source": "iana" },
  "application/vnd.dvb.iptv.alfec-enhancement": { "source": "iana" },
  "application/vnd.dvb.notif-aggregate-root+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-container+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-generic+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-msglist+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-registration-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-registration-response+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-init+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.pfr": { "source": "iana" },
  "application/vnd.dvb.service": { "source": "iana", "extensions": ["svc"] },
  "application/vnd.dxr": { "source": "iana" },
  "application/vnd.dynageo": { "source": "iana", "extensions": ["geo"] },
  "application/vnd.dzr": { "source": "iana" },
  "application/vnd.easykaraoke.cdgdownload": { "source": "iana" },
  "application/vnd.ecdis-update": { "source": "iana" },
  "application/vnd.ecip.rlp": { "source": "iana" },
  "application/vnd.eclipse.ditto+json": { "source": "iana", "compressible": true },
  "application/vnd.ecowin.chart": { "source": "iana", "extensions": ["mag"] },
  "application/vnd.ecowin.filerequest": { "source": "iana" },
  "application/vnd.ecowin.fileupdate": { "source": "iana" },
  "application/vnd.ecowin.series": { "source": "iana" },
  "application/vnd.ecowin.seriesrequest": { "source": "iana" },
  "application/vnd.ecowin.seriesupdate": { "source": "iana" },
  "application/vnd.efi.img": { "source": "iana" },
  "application/vnd.efi.iso": { "source": "iana" },
  "application/vnd.emclient.accessrequest+xml": { "source": "iana", "compressible": true },
  "application/vnd.enliven": { "source": "iana", "extensions": ["nml"] },
  "application/vnd.enphase.envoy": { "source": "iana" },
  "application/vnd.eprints.data+xml": { "source": "iana", "compressible": true },
  "application/vnd.epson.esf": { "source": "iana", "extensions": ["esf"] },
  "application/vnd.epson.msf": { "source": "iana", "extensions": ["msf"] },
  "application/vnd.epson.quickanime": { "source": "iana", "extensions": ["qam"] },
  "application/vnd.epson.salt": { "source": "iana", "extensions": ["slt"] },
  "application/vnd.epson.ssf": { "source": "iana", "extensions": ["ssf"] },
  "application/vnd.ericsson.quickcall": { "source": "iana" },
  "application/vnd.espass-espass+zip": { "source": "iana", "compressible": false },
  "application/vnd.eszigno3+xml": { "source": "iana", "compressible": true, "extensions": ["es3", "et3"] },
  "application/vnd.etsi.aoc+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.asic-e+zip": { "source": "iana", "compressible": false },
  "application/vnd.etsi.asic-s+zip": { "source": "iana", "compressible": false },
  "application/vnd.etsi.cug+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvcommand+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvdiscovery+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-bc+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-cod+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-npvr+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvservice+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsync+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvueprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.mcid+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.mheg5": { "source": "iana" },
  "application/vnd.etsi.overload-control-policy-dataset+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.pstn+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.sci+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.simservs+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.timestamp-token": { "source": "iana" },
  "application/vnd.etsi.tsl+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.tsl.der": { "source": "iana" },
  "application/vnd.eu.kasparian.car+json": { "source": "iana", "compressible": true },
  "application/vnd.eudora.data": { "source": "iana" },
  "application/vnd.evolv.ecig.profile": { "source": "iana" },
  "application/vnd.evolv.ecig.settings": { "source": "iana" },
  "application/vnd.evolv.ecig.theme": { "source": "iana" },
  "application/vnd.exstream-empower+zip": { "source": "iana", "compressible": false },
  "application/vnd.exstream-package": { "source": "iana" },
  "application/vnd.ezpix-album": { "source": "iana", "extensions": ["ez2"] },
  "application/vnd.ezpix-package": { "source": "iana", "extensions": ["ez3"] },
  "application/vnd.f-secure.mobile": { "source": "iana" },
  "application/vnd.familysearch.gedcom+zip": { "source": "iana", "compressible": false },
  "application/vnd.fastcopy-disk-image": { "source": "iana" },
  "application/vnd.fdf": { "source": "iana", "extensions": ["fdf"] },
  "application/vnd.fdsn.mseed": { "source": "iana", "extensions": ["mseed"] },
  "application/vnd.fdsn.seed": { "source": "iana", "extensions": ["seed", "dataless"] },
  "application/vnd.ffsns": { "source": "iana" },
  "application/vnd.ficlab.flb+zip": { "source": "iana", "compressible": false },
  "application/vnd.filmit.zfc": { "source": "iana" },
  "application/vnd.fints": { "source": "iana" },
  "application/vnd.firemonkeys.cloudcell": { "source": "iana" },
  "application/vnd.flographit": { "source": "iana", "extensions": ["gph"] },
  "application/vnd.fluxtime.clip": { "source": "iana", "extensions": ["ftc"] },
  "application/vnd.font-fontforge-sfd": { "source": "iana" },
  "application/vnd.framemaker": { "source": "iana", "extensions": ["fm", "frame", "maker", "book"] },
  "application/vnd.frogans.fnc": { "source": "iana", "extensions": ["fnc"] },
  "application/vnd.frogans.ltf": { "source": "iana", "extensions": ["ltf"] },
  "application/vnd.fsc.weblaunch": { "source": "iana", "extensions": ["fsc"] },
  "application/vnd.fujifilm.fb.docuworks": { "source": "iana" },
  "application/vnd.fujifilm.fb.docuworks.binder": { "source": "iana" },
  "application/vnd.fujifilm.fb.docuworks.container": { "source": "iana" },
  "application/vnd.fujifilm.fb.jfi+xml": { "source": "iana", "compressible": true },
  "application/vnd.fujitsu.oasys": { "source": "iana", "extensions": ["oas"] },
  "application/vnd.fujitsu.oasys2": { "source": "iana", "extensions": ["oa2"] },
  "application/vnd.fujitsu.oasys3": { "source": "iana", "extensions": ["oa3"] },
  "application/vnd.fujitsu.oasysgp": { "source": "iana", "extensions": ["fg5"] },
  "application/vnd.fujitsu.oasysprs": { "source": "iana", "extensions": ["bh2"] },
  "application/vnd.fujixerox.art-ex": { "source": "iana" },
  "application/vnd.fujixerox.art4": { "source": "iana" },
  "application/vnd.fujixerox.ddd": { "source": "iana", "extensions": ["ddd"] },
  "application/vnd.fujixerox.docuworks": { "source": "iana", "extensions": ["xdw"] },
  "application/vnd.fujixerox.docuworks.binder": { "source": "iana", "extensions": ["xbd"] },
  "application/vnd.fujixerox.docuworks.container": { "source": "iana" },
  "application/vnd.fujixerox.hbpl": { "source": "iana" },
  "application/vnd.fut-misnet": { "source": "iana" },
  "application/vnd.futoin+cbor": { "source": "iana" },
  "application/vnd.futoin+json": { "source": "iana", "compressible": true },
  "application/vnd.fuzzysheet": { "source": "iana", "extensions": ["fzs"] },
  "application/vnd.genomatix.tuxedo": { "source": "iana", "extensions": ["txd"] },
  "application/vnd.gentics.grd+json": { "source": "iana", "compressible": true },
  "application/vnd.geo+json": { "source": "iana", "compressible": true },
  "application/vnd.geocube+xml": { "source": "iana", "compressible": true },
  "application/vnd.geogebra.file": { "source": "iana", "extensions": ["ggb"] },
  "application/vnd.geogebra.slides": { "source": "iana" },
  "application/vnd.geogebra.tool": { "source": "iana", "extensions": ["ggt"] },
  "application/vnd.geometry-explorer": { "source": "iana", "extensions": ["gex", "gre"] },
  "application/vnd.geonext": { "source": "iana", "extensions": ["gxt"] },
  "application/vnd.geoplan": { "source": "iana", "extensions": ["g2w"] },
  "application/vnd.geospace": { "source": "iana", "extensions": ["g3w"] },
  "application/vnd.gerber": { "source": "iana" },
  "application/vnd.globalplatform.card-content-mgt": { "source": "iana" },
  "application/vnd.globalplatform.card-content-mgt-response": { "source": "iana" },
  "application/vnd.gmx": { "source": "iana", "extensions": ["gmx"] },
  "application/vnd.google-apps.document": { "compressible": false, "extensions": ["gdoc"] },
  "application/vnd.google-apps.presentation": { "compressible": false, "extensions": ["gslides"] },
  "application/vnd.google-apps.spreadsheet": { "compressible": false, "extensions": ["gsheet"] },
  "application/vnd.google-earth.kml+xml": { "source": "iana", "compressible": true, "extensions": ["kml"] },
  "application/vnd.google-earth.kmz": { "source": "iana", "compressible": false, "extensions": ["kmz"] },
  "application/vnd.gov.sk.e-form+xml": { "source": "iana", "compressible": true },
  "application/vnd.gov.sk.e-form+zip": { "source": "iana", "compressible": false },
  "application/vnd.gov.sk.xmldatacontainer+xml": { "source": "iana", "compressible": true },
  "application/vnd.grafeq": { "source": "iana", "extensions": ["gqf", "gqs"] },
  "application/vnd.gridmp": { "source": "iana" },
  "application/vnd.groove-account": { "source": "iana", "extensions": ["gac"] },
  "application/vnd.groove-help": { "source": "iana", "extensions": ["ghf"] },
  "application/vnd.groove-identity-message": { "source": "iana", "extensions": ["gim"] },
  "application/vnd.groove-injector": { "source": "iana", "extensions": ["grv"] },
  "application/vnd.groove-tool-message": { "source": "iana", "extensions": ["gtm"] },
  "application/vnd.groove-tool-template": { "source": "iana", "extensions": ["tpl"] },
  "application/vnd.groove-vcard": { "source": "iana", "extensions": ["vcg"] },
  "application/vnd.hal+json": { "source": "iana", "compressible": true },
  "application/vnd.hal+xml": { "source": "iana", "compressible": true, "extensions": ["hal"] },
  "application/vnd.handheld-entertainment+xml": { "source": "iana", "compressible": true, "extensions": ["zmm"] },
  "application/vnd.hbci": { "source": "iana", "extensions": ["hbci"] },
  "application/vnd.hc+json": { "source": "iana", "compressible": true },
  "application/vnd.hcl-bireports": { "source": "iana" },
  "application/vnd.hdt": { "source": "iana" },
  "application/vnd.heroku+json": { "source": "iana", "compressible": true },
  "application/vnd.hhe.lesson-player": { "source": "iana", "extensions": ["les"] },
  "application/vnd.hl7cda+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.hl7v2+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.hp-hpgl": { "source": "iana", "extensions": ["hpgl"] },
  "application/vnd.hp-hpid": { "source": "iana", "extensions": ["hpid"] },
  "application/vnd.hp-hps": { "source": "iana", "extensions": ["hps"] },
  "application/vnd.hp-jlyt": { "source": "iana", "extensions": ["jlt"] },
  "application/vnd.hp-pcl": { "source": "iana", "extensions": ["pcl"] },
  "application/vnd.hp-pclxl": { "source": "iana", "extensions": ["pclxl"] },
  "application/vnd.httphone": { "source": "iana" },
  "application/vnd.hydrostatix.sof-data": { "source": "iana", "extensions": ["sfd-hdstx"] },
  "application/vnd.hyper+json": { "source": "iana", "compressible": true },
  "application/vnd.hyper-item+json": { "source": "iana", "compressible": true },
  "application/vnd.hyperdrive+json": { "source": "iana", "compressible": true },
  "application/vnd.hzn-3d-crossword": { "source": "iana" },
  "application/vnd.ibm.afplinedata": { "source": "iana" },
  "application/vnd.ibm.electronic-media": { "source": "iana" },
  "application/vnd.ibm.minipay": { "source": "iana", "extensions": ["mpy"] },
  "application/vnd.ibm.modcap": { "source": "iana", "extensions": ["afp", "listafp", "list3820"] },
  "application/vnd.ibm.rights-management": { "source": "iana", "extensions": ["irm"] },
  "application/vnd.ibm.secure-container": { "source": "iana", "extensions": ["sc"] },
  "application/vnd.iccprofile": { "source": "iana", "extensions": ["icc", "icm"] },
  "application/vnd.ieee.1905": { "source": "iana" },
  "application/vnd.igloader": { "source": "iana", "extensions": ["igl"] },
  "application/vnd.imagemeter.folder+zip": { "source": "iana", "compressible": false },
  "application/vnd.imagemeter.image+zip": { "source": "iana", "compressible": false },
  "application/vnd.immervision-ivp": { "source": "iana", "extensions": ["ivp"] },
  "application/vnd.immervision-ivu": { "source": "iana", "extensions": ["ivu"] },
  "application/vnd.ims.imsccv1p1": { "source": "iana" },
  "application/vnd.ims.imsccv1p2": { "source": "iana" },
  "application/vnd.ims.imsccv1p3": { "source": "iana" },
  "application/vnd.ims.lis.v2.result+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolproxy+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolproxy.id+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolsettings+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": { "source": "iana", "compressible": true },
  "application/vnd.informedcontrol.rms+xml": { "source": "iana", "compressible": true },
  "application/vnd.informix-visionary": { "source": "iana" },
  "application/vnd.infotech.project": { "source": "iana" },
  "application/vnd.infotech.project+xml": { "source": "iana", "compressible": true },
  "application/vnd.innopath.wamp.notification": { "source": "iana" },
  "application/vnd.insors.igm": { "source": "iana", "extensions": ["igm"] },
  "application/vnd.intercon.formnet": { "source": "iana", "extensions": ["xpw", "xpx"] },
  "application/vnd.intergeo": { "source": "iana", "extensions": ["i2g"] },
  "application/vnd.intertrust.digibox": { "source": "iana" },
  "application/vnd.intertrust.nncp": { "source": "iana" },
  "application/vnd.intu.qbo": { "source": "iana", "extensions": ["qbo"] },
  "application/vnd.intu.qfx": { "source": "iana", "extensions": ["qfx"] },
  "application/vnd.iptc.g2.catalogitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.conceptitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.knowledgeitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.newsitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.newsmessage+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.packageitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.planningitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.ipunplugged.rcprofile": { "source": "iana", "extensions": ["rcprofile"] },
  "application/vnd.irepository.package+xml": { "source": "iana", "compressible": true, "extensions": ["irp"] },
  "application/vnd.is-xpr": { "source": "iana", "extensions": ["xpr"] },
  "application/vnd.isac.fcs": { "source": "iana", "extensions": ["fcs"] },
  "application/vnd.iso11783-10+zip": { "source": "iana", "compressible": false },
  "application/vnd.jam": { "source": "iana", "extensions": ["jam"] },
  "application/vnd.japannet-directory-service": { "source": "iana" },
  "application/vnd.japannet-jpnstore-wakeup": { "source": "iana" },
  "application/vnd.japannet-payment-wakeup": { "source": "iana" },
  "application/vnd.japannet-registration": { "source": "iana" },
  "application/vnd.japannet-registration-wakeup": { "source": "iana" },
  "application/vnd.japannet-setstore-wakeup": { "source": "iana" },
  "application/vnd.japannet-verification": { "source": "iana" },
  "application/vnd.japannet-verification-wakeup": { "source": "iana" },
  "application/vnd.jcp.javame.midlet-rms": { "source": "iana", "extensions": ["rms"] },
  "application/vnd.jisp": { "source": "iana", "extensions": ["jisp"] },
  "application/vnd.joost.joda-archive": { "source": "iana", "extensions": ["joda"] },
  "application/vnd.jsk.isdn-ngn": { "source": "iana" },
  "application/vnd.kahootz": { "source": "iana", "extensions": ["ktz", "ktr"] },
  "application/vnd.kde.karbon": { "source": "iana", "extensions": ["karbon"] },
  "application/vnd.kde.kchart": { "source": "iana", "extensions": ["chrt"] },
  "application/vnd.kde.kformula": { "source": "iana", "extensions": ["kfo"] },
  "application/vnd.kde.kivio": { "source": "iana", "extensions": ["flw"] },
  "application/vnd.kde.kontour": { "source": "iana", "extensions": ["kon"] },
  "application/vnd.kde.kpresenter": { "source": "iana", "extensions": ["kpr", "kpt"] },
  "application/vnd.kde.kspread": { "source": "iana", "extensions": ["ksp"] },
  "application/vnd.kde.kword": { "source": "iana", "extensions": ["kwd", "kwt"] },
  "application/vnd.kenameaapp": { "source": "iana", "extensions": ["htke"] },
  "application/vnd.kidspiration": { "source": "iana", "extensions": ["kia"] },
  "application/vnd.kinar": { "source": "iana", "extensions": ["kne", "knp"] },
  "application/vnd.koan": { "source": "iana", "extensions": ["skp", "skd", "skt", "skm"] },
  "application/vnd.kodak-descriptor": { "source": "iana", "extensions": ["sse"] },
  "application/vnd.las": { "source": "iana" },
  "application/vnd.las.las+json": { "source": "iana", "compressible": true },
  "application/vnd.las.las+xml": { "source": "iana", "compressible": true, "extensions": ["lasxml"] },
  "application/vnd.laszip": { "source": "iana" },
  "application/vnd.leap+json": { "source": "iana", "compressible": true },
  "application/vnd.liberty-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.llamagraphics.life-balance.desktop": { "source": "iana", "extensions": ["lbd"] },
  "application/vnd.llamagraphics.life-balance.exchange+xml": { "source": "iana", "compressible": true, "extensions": ["lbe"] },
  "application/vnd.logipipe.circuit+zip": { "source": "iana", "compressible": false },
  "application/vnd.loom": { "source": "iana" },
  "application/vnd.lotus-1-2-3": { "source": "iana", "extensions": ["123"] },
  "application/vnd.lotus-approach": { "source": "iana", "extensions": ["apr"] },
  "application/vnd.lotus-freelance": { "source": "iana", "extensions": ["pre"] },
  "application/vnd.lotus-notes": { "source": "iana", "extensions": ["nsf"] },
  "application/vnd.lotus-organizer": { "source": "iana", "extensions": ["org"] },
  "application/vnd.lotus-screencam": { "source": "iana", "extensions": ["scm"] },
  "application/vnd.lotus-wordpro": { "source": "iana", "extensions": ["lwp"] },
  "application/vnd.macports.portpkg": { "source": "iana", "extensions": ["portpkg"] },
  "application/vnd.mapbox-vector-tile": { "source": "iana", "extensions": ["mvt"] },
  "application/vnd.marlin.drm.actiontoken+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.conftoken+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.license+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.mdcf": { "source": "iana" },
  "application/vnd.mason+json": { "source": "iana", "compressible": true },
  "application/vnd.maxar.archive.3tz+zip": { "source": "iana", "compressible": false },
  "application/vnd.maxmind.maxmind-db": { "source": "iana" },
  "application/vnd.mcd": { "source": "iana", "extensions": ["mcd"] },
  "application/vnd.medcalcdata": { "source": "iana", "extensions": ["mc1"] },
  "application/vnd.mediastation.cdkey": { "source": "iana", "extensions": ["cdkey"] },
  "application/vnd.meridian-slingshot": { "source": "iana" },
  "application/vnd.mfer": { "source": "iana", "extensions": ["mwf"] },
  "application/vnd.mfmp": { "source": "iana", "extensions": ["mfm"] },
  "application/vnd.micro+json": { "source": "iana", "compressible": true },
  "application/vnd.micrografx.flo": { "source": "iana", "extensions": ["flo"] },
  "application/vnd.micrografx.igx": { "source": "iana", "extensions": ["igx"] },
  "application/vnd.microsoft.portable-executable": { "source": "iana" },
  "application/vnd.microsoft.windows.thumbnail-cache": { "source": "iana" },
  "application/vnd.miele+json": { "source": "iana", "compressible": true },
  "application/vnd.mif": { "source": "iana", "extensions": ["mif"] },
  "application/vnd.minisoft-hp3000-save": { "source": "iana" },
  "application/vnd.mitsubishi.misty-guard.trustweb": { "source": "iana" },
  "application/vnd.mobius.daf": { "source": "iana", "extensions": ["daf"] },
  "application/vnd.mobius.dis": { "source": "iana", "extensions": ["dis"] },
  "application/vnd.mobius.mbk": { "source": "iana", "extensions": ["mbk"] },
  "application/vnd.mobius.mqy": { "source": "iana", "extensions": ["mqy"] },
  "application/vnd.mobius.msl": { "source": "iana", "extensions": ["msl"] },
  "application/vnd.mobius.plc": { "source": "iana", "extensions": ["plc"] },
  "application/vnd.mobius.txf": { "source": "iana", "extensions": ["txf"] },
  "application/vnd.mophun.application": { "source": "iana", "extensions": ["mpn"] },
  "application/vnd.mophun.certificate": { "source": "iana", "extensions": ["mpc"] },
  "application/vnd.motorola.flexsuite": { "source": "iana" },
  "application/vnd.motorola.flexsuite.adsi": { "source": "iana" },
  "application/vnd.motorola.flexsuite.fis": { "source": "iana" },
  "application/vnd.motorola.flexsuite.gotap": { "source": "iana" },
  "application/vnd.motorola.flexsuite.kmr": { "source": "iana" },
  "application/vnd.motorola.flexsuite.ttc": { "source": "iana" },
  "application/vnd.motorola.flexsuite.wem": { "source": "iana" },
  "application/vnd.motorola.iprm": { "source": "iana" },
  "application/vnd.mozilla.xul+xml": { "source": "iana", "compressible": true, "extensions": ["xul"] },
  "application/vnd.ms-3mfdocument": { "source": "iana" },
  "application/vnd.ms-artgalry": { "source": "iana", "extensions": ["cil"] },
  "application/vnd.ms-asf": { "source": "iana" },
  "application/vnd.ms-cab-compressed": { "source": "iana", "extensions": ["cab"] },
  "application/vnd.ms-color.iccprofile": { "source": "apache" },
  "application/vnd.ms-excel": { "source": "iana", "compressible": false, "extensions": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"] },
  "application/vnd.ms-excel.addin.macroenabled.12": { "source": "iana", "extensions": ["xlam"] },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": { "source": "iana", "extensions": ["xlsb"] },
  "application/vnd.ms-excel.sheet.macroenabled.12": { "source": "iana", "extensions": ["xlsm"] },
  "application/vnd.ms-excel.template.macroenabled.12": { "source": "iana", "extensions": ["xltm"] },
  "application/vnd.ms-fontobject": { "source": "iana", "compressible": true, "extensions": ["eot"] },
  "application/vnd.ms-htmlhelp": { "source": "iana", "extensions": ["chm"] },
  "application/vnd.ms-ims": { "source": "iana", "extensions": ["ims"] },
  "application/vnd.ms-lrm": { "source": "iana", "extensions": ["lrm"] },
  "application/vnd.ms-office.activex+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-officetheme": { "source": "iana", "extensions": ["thmx"] },
  "application/vnd.ms-opentype": { "source": "apache", "compressible": true },
  "application/vnd.ms-outlook": { "compressible": false, "extensions": ["msg"] },
  "application/vnd.ms-package.obfuscated-opentype": { "source": "apache" },
  "application/vnd.ms-pki.seccat": { "source": "apache", "extensions": ["cat"] },
  "application/vnd.ms-pki.stl": { "source": "apache", "extensions": ["stl"] },
  "application/vnd.ms-playready.initiator+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-powerpoint": { "source": "iana", "compressible": false, "extensions": ["ppt", "pps", "pot"] },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": { "source": "iana", "extensions": ["ppam"] },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": { "source": "iana", "extensions": ["pptm"] },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": { "source": "iana", "extensions": ["sldm"] },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": { "source": "iana", "extensions": ["ppsm"] },
  "application/vnd.ms-powerpoint.template.macroenabled.12": { "source": "iana", "extensions": ["potm"] },
  "application/vnd.ms-printdevicecapabilities+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-printing.printticket+xml": { "source": "apache", "compressible": true },
  "application/vnd.ms-printschematicket+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-project": { "source": "iana", "extensions": ["mpp", "mpt"] },
  "application/vnd.ms-tnef": { "source": "iana" },
  "application/vnd.ms-windows.devicepairing": { "source": "iana" },
  "application/vnd.ms-windows.nwprinting.oob": { "source": "iana" },
  "application/vnd.ms-windows.printerpairing": { "source": "iana" },
  "application/vnd.ms-windows.wsd.oob": { "source": "iana" },
  "application/vnd.ms-wmdrm.lic-chlg-req": { "source": "iana" },
  "application/vnd.ms-wmdrm.lic-resp": { "source": "iana" },
  "application/vnd.ms-wmdrm.meter-chlg-req": { "source": "iana" },
  "application/vnd.ms-wmdrm.meter-resp": { "source": "iana" },
  "application/vnd.ms-word.document.macroenabled.12": { "source": "iana", "extensions": ["docm"] },
  "application/vnd.ms-word.template.macroenabled.12": { "source": "iana", "extensions": ["dotm"] },
  "application/vnd.ms-works": { "source": "iana", "extensions": ["wps", "wks", "wcm", "wdb"] },
  "application/vnd.ms-wpl": { "source": "iana", "extensions": ["wpl"] },
  "application/vnd.ms-xpsdocument": { "source": "iana", "compressible": false, "extensions": ["xps"] },
  "application/vnd.msa-disk-image": { "source": "iana" },
  "application/vnd.mseq": { "source": "iana", "extensions": ["mseq"] },
  "application/vnd.msign": { "source": "iana" },
  "application/vnd.multiad.creator": { "source": "iana" },
  "application/vnd.multiad.creator.cif": { "source": "iana" },
  "application/vnd.music-niff": { "source": "iana" },
  "application/vnd.musician": { "source": "iana", "extensions": ["mus"] },
  "application/vnd.muvee.style": { "source": "iana", "extensions": ["msty"] },
  "application/vnd.mynfc": { "source": "iana", "extensions": ["taglet"] },
  "application/vnd.nacamar.ybrid+json": { "source": "iana", "compressible": true },
  "application/vnd.ncd.control": { "source": "iana" },
  "application/vnd.ncd.reference": { "source": "iana" },
  "application/vnd.nearst.inv+json": { "source": "iana", "compressible": true },
  "application/vnd.nebumind.line": { "source": "iana" },
  "application/vnd.nervana": { "source": "iana" },
  "application/vnd.netfpx": { "source": "iana" },
  "application/vnd.neurolanguage.nlu": { "source": "iana", "extensions": ["nlu"] },
  "application/vnd.nimn": { "source": "iana" },
  "application/vnd.nintendo.nitro.rom": { "source": "iana" },
  "application/vnd.nintendo.snes.rom": { "source": "iana" },
  "application/vnd.nitf": { "source": "iana", "extensions": ["ntf", "nitf"] },
  "application/vnd.noblenet-directory": { "source": "iana", "extensions": ["nnd"] },
  "application/vnd.noblenet-sealer": { "source": "iana", "extensions": ["nns"] },
  "application/vnd.noblenet-web": { "source": "iana", "extensions": ["nnw"] },
  "application/vnd.nokia.catalogs": { "source": "iana" },
  "application/vnd.nokia.conml+wbxml": { "source": "iana" },
  "application/vnd.nokia.conml+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.iptv.config+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.isds-radio-presets": { "source": "iana" },
  "application/vnd.nokia.landmark+wbxml": { "source": "iana" },
  "application/vnd.nokia.landmark+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.landmarkcollection+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.n-gage.ac+xml": { "source": "iana", "compressible": true, "extensions": ["ac"] },
  "application/vnd.nokia.n-gage.data": { "source": "iana", "extensions": ["ngdat"] },
  "application/vnd.nokia.n-gage.symbian.install": { "source": "iana", "extensions": ["n-gage"] },
  "application/vnd.nokia.ncd": { "source": "iana" },
  "application/vnd.nokia.pcd+wbxml": { "source": "iana" },
  "application/vnd.nokia.pcd+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.radio-preset": { "source": "iana", "extensions": ["rpst"] },
  "application/vnd.nokia.radio-presets": { "source": "iana", "extensions": ["rpss"] },
  "application/vnd.novadigm.edm": { "source": "iana", "extensions": ["edm"] },
  "application/vnd.novadigm.edx": { "source": "iana", "extensions": ["edx"] },
  "application/vnd.novadigm.ext": { "source": "iana", "extensions": ["ext"] },
  "application/vnd.ntt-local.content-share": { "source": "iana" },
  "application/vnd.ntt-local.file-transfer": { "source": "iana" },
  "application/vnd.ntt-local.ogw_remote-access": { "source": "iana" },
  "application/vnd.ntt-local.sip-ta_remote": { "source": "iana" },
  "application/vnd.ntt-local.sip-ta_tcp_stream": { "source": "iana" },
  "application/vnd.oasis.opendocument.chart": { "source": "iana", "extensions": ["odc"] },
  "application/vnd.oasis.opendocument.chart-template": { "source": "iana", "extensions": ["otc"] },
  "application/vnd.oasis.opendocument.database": { "source": "iana", "extensions": ["odb"] },
  "application/vnd.oasis.opendocument.formula": { "source": "iana", "extensions": ["odf"] },
  "application/vnd.oasis.opendocument.formula-template": { "source": "iana", "extensions": ["odft"] },
  "application/vnd.oasis.opendocument.graphics": { "source": "iana", "compressible": false, "extensions": ["odg"] },
  "application/vnd.oasis.opendocument.graphics-template": { "source": "iana", "extensions": ["otg"] },
  "application/vnd.oasis.opendocument.image": { "source": "iana", "extensions": ["odi"] },
  "application/vnd.oasis.opendocument.image-template": { "source": "iana", "extensions": ["oti"] },
  "application/vnd.oasis.opendocument.presentation": { "source": "iana", "compressible": false, "extensions": ["odp"] },
  "application/vnd.oasis.opendocument.presentation-template": { "source": "iana", "extensions": ["otp"] },
  "application/vnd.oasis.opendocument.spreadsheet": { "source": "iana", "compressible": false, "extensions": ["ods"] },
  "application/vnd.oasis.opendocument.spreadsheet-template": { "source": "iana", "extensions": ["ots"] },
  "application/vnd.oasis.opendocument.text": { "source": "iana", "compressible": false, "extensions": ["odt"] },
  "application/vnd.oasis.opendocument.text-master": { "source": "iana", "extensions": ["odm"] },
  "application/vnd.oasis.opendocument.text-template": { "source": "iana", "extensions": ["ott"] },
  "application/vnd.oasis.opendocument.text-web": { "source": "iana", "extensions": ["oth"] },
  "application/vnd.obn": { "source": "iana" },
  "application/vnd.ocf+cbor": { "source": "iana" },
  "application/vnd.oci.image.manifest.v1+json": { "source": "iana", "compressible": true },
  "application/vnd.oftn.l10n+json": { "source": "iana", "compressible": true },
  "application/vnd.oipf.contentaccessdownload+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.contentaccessstreaming+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.cspg-hexbinary": { "source": "iana" },
  "application/vnd.oipf.dae.svg+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.dae.xhtml+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.mippvcontrolmessage+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.pae.gem": { "source": "iana" },
  "application/vnd.oipf.spdiscovery+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.spdlist+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.ueprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.userprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.olpc-sugar": { "source": "iana", "extensions": ["xo"] },
  "application/vnd.oma-scws-config": { "source": "iana" },
  "application/vnd.oma-scws-http-request": { "source": "iana" },
  "application/vnd.oma-scws-http-response": { "source": "iana" },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.drm-trigger+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.imd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.ltkm": { "source": "iana" },
  "application/vnd.oma.bcast.notification+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.provisioningtrigger": { "source": "iana" },
  "application/vnd.oma.bcast.sgboot": { "source": "iana" },
  "application/vnd.oma.bcast.sgdd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.sgdu": { "source": "iana" },
  "application/vnd.oma.bcast.simple-symbol-container": { "source": "iana" },
  "application/vnd.oma.bcast.smartcard-trigger+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.sprov+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.stkm": { "source": "iana" },
  "application/vnd.oma.cab-address-book+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-feature-handler+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-pcc+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-subs-invite+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-user-prefs+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.dcd": { "source": "iana" },
  "application/vnd.oma.dcdc": { "source": "iana" },
  "application/vnd.oma.dd2+xml": { "source": "iana", "compressible": true, "extensions": ["dd2"] },
  "application/vnd.oma.drm.risd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.group-usage-list+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.lwm2m+cbor": { "source": "iana" },
  "application/vnd.oma.lwm2m+json": { "source": "iana", "compressible": true },
  "application/vnd.oma.lwm2m+tlv": { "source": "iana" },
  "application/vnd.oma.pal+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.detailed-progress-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.final-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.groups+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.invocation-descriptor+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.optimized-progress-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.push": { "source": "iana" },
  "application/vnd.oma.scidm.messages+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.xcap-directory+xml": { "source": "iana", "compressible": true },
  "application/vnd.omads-email+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omads-file+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omads-folder+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omaloc-supl-init": { "source": "iana" },
  "application/vnd.onepager": { "source": "iana" },
  "application/vnd.onepagertamp": { "source": "iana" },
  "application/vnd.onepagertamx": { "source": "iana" },
  "application/vnd.onepagertat": { "source": "iana" },
  "application/vnd.onepagertatp": { "source": "iana" },
  "application/vnd.onepagertatx": { "source": "iana" },
  "application/vnd.openblox.game+xml": { "source": "iana", "compressible": true, "extensions": ["obgx"] },
  "application/vnd.openblox.game-binary": { "source": "iana" },
  "application/vnd.openeye.oeb": { "source": "iana" },
  "application/vnd.openofficeorg.extension": { "source": "apache", "extensions": ["oxt"] },
  "application/vnd.openstreetmap.data+xml": { "source": "iana", "compressible": true, "extensions": ["osm"] },
  "application/vnd.opentimestamps.ots": { "source": "iana" },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawing+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": { "source": "iana", "compressible": false, "extensions": ["pptx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": { "source": "iana", "extensions": ["sldx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": { "source": "iana", "extensions": ["ppsx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.template": { "source": "iana", "extensions": ["potx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": { "source": "iana", "compressible": false, "extensions": ["xlsx"] },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": { "source": "iana", "extensions": ["xltx"] },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.theme+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.vmldrawing": { "source": "iana" },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": { "source": "iana", "compressible": false, "extensions": ["docx"] },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": { "source": "iana", "extensions": ["dotx"] },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.core-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.relationships+xml": { "source": "iana", "compressible": true },
  "application/vnd.oracle.resource+json": { "source": "iana", "compressible": true },
  "application/vnd.orange.indata": { "source": "iana" },
  "application/vnd.osa.netdeploy": { "source": "iana" },
  "application/vnd.osgeo.mapguide.package": { "source": "iana", "extensions": ["mgp"] },
  "application/vnd.osgi.bundle": { "source": "iana" },
  "application/vnd.osgi.dp": { "source": "iana", "extensions": ["dp"] },
  "application/vnd.osgi.subsystem": { "source": "iana", "extensions": ["esa"] },
  "application/vnd.otps.ct-kip+xml": { "source": "iana", "compressible": true },
  "application/vnd.oxli.countgraph": { "source": "iana" },
  "application/vnd.pagerduty+json": { "source": "iana", "compressible": true },
  "application/vnd.palm": { "source": "iana", "extensions": ["pdb", "pqa", "oprc"] },
  "application/vnd.panoply": { "source": "iana" },
  "application/vnd.paos.xml": { "source": "iana" },
  "application/vnd.patentdive": { "source": "iana" },
  "application/vnd.patientecommsdoc": { "source": "iana" },
  "application/vnd.pawaafile": { "source": "iana", "extensions": ["paw"] },
  "application/vnd.pcos": { "source": "iana" },
  "application/vnd.pg.format": { "source": "iana", "extensions": ["str"] },
  "application/vnd.pg.osasli": { "source": "iana", "extensions": ["ei6"] },
  "application/vnd.piaccess.application-licence": { "source": "iana" },
  "application/vnd.picsel": { "source": "iana", "extensions": ["efif"] },
  "application/vnd.pmi.widget": { "source": "iana", "extensions": ["wg"] },
  "application/vnd.poc.group-advertisement+xml": { "source": "iana", "compressible": true },
  "application/vnd.pocketlearn": { "source": "iana", "extensions": ["plf"] },
  "application/vnd.powerbuilder6": { "source": "iana", "extensions": ["pbd"] },
  "application/vnd.powerbuilder6-s": { "source": "iana" },
  "application/vnd.powerbuilder7": { "source": "iana" },
  "application/vnd.powerbuilder7-s": { "source": "iana" },
  "application/vnd.powerbuilder75": { "source": "iana" },
  "application/vnd.powerbuilder75-s": { "source": "iana" },
  "application/vnd.preminet": { "source": "iana" },
  "application/vnd.previewsystems.box": { "source": "iana", "extensions": ["box"] },
  "application/vnd.proteus.magazine": { "source": "iana", "extensions": ["mgz"] },
  "application/vnd.psfs": { "source": "iana" },
  "application/vnd.publishare-delta-tree": { "source": "iana", "extensions": ["qps"] },
  "application/vnd.pvi.ptid1": { "source": "iana", "extensions": ["ptid"] },
  "application/vnd.pwg-multiplexed": { "source": "iana" },
  "application/vnd.pwg-xhtml-print+xml": { "source": "iana", "compressible": true },
  "application/vnd.qualcomm.brew-app-res": { "source": "iana" },
  "application/vnd.quarantainenet": { "source": "iana" },
  "application/vnd.quark.quarkxpress": { "source": "iana", "extensions": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"] },
  "application/vnd.quobject-quoxdocument": { "source": "iana" },
  "application/vnd.radisys.moml+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-conf+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-conn+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-dialog+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-stream+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-conf+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-base+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-group+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-speech+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-transform+xml": { "source": "iana", "compressible": true },
  "application/vnd.rainstor.data": { "source": "iana" },
  "application/vnd.rapid": { "source": "iana" },
  "application/vnd.rar": { "source": "iana", "extensions": ["rar"] },
  "application/vnd.realvnc.bed": { "source": "iana", "extensions": ["bed"] },
  "application/vnd.recordare.musicxml": { "source": "iana", "extensions": ["mxl"] },
  "application/vnd.recordare.musicxml+xml": { "source": "iana", "compressible": true, "extensions": ["musicxml"] },
  "application/vnd.renlearn.rlprint": { "source": "iana" },
  "application/vnd.resilient.logic": { "source": "iana" },
  "application/vnd.restful+json": { "source": "iana", "compressible": true },
  "application/vnd.rig.cryptonote": { "source": "iana", "extensions": ["cryptonote"] },
  "application/vnd.rim.cod": { "source": "apache", "extensions": ["cod"] },
  "application/vnd.rn-realmedia": { "source": "apache", "extensions": ["rm"] },
  "application/vnd.rn-realmedia-vbr": { "source": "apache", "extensions": ["rmvb"] },
  "application/vnd.route66.link66+xml": { "source": "iana", "compressible": true, "extensions": ["link66"] },
  "application/vnd.rs-274x": { "source": "iana" },
  "application/vnd.ruckus.download": { "source": "iana" },
  "application/vnd.s3sms": { "source": "iana" },
  "application/vnd.sailingtracker.track": { "source": "iana", "extensions": ["st"] },
  "application/vnd.sar": { "source": "iana" },
  "application/vnd.sbm.cid": { "source": "iana" },
  "application/vnd.sbm.mid2": { "source": "iana" },
  "application/vnd.scribus": { "source": "iana" },
  "application/vnd.sealed.3df": { "source": "iana" },
  "application/vnd.sealed.csf": { "source": "iana" },
  "application/vnd.sealed.doc": { "source": "iana" },
  "application/vnd.sealed.eml": { "source": "iana" },
  "application/vnd.sealed.mht": { "source": "iana" },
  "application/vnd.sealed.net": { "source": "iana" },
  "application/vnd.sealed.ppt": { "source": "iana" },
  "application/vnd.sealed.tiff": { "source": "iana" },
  "application/vnd.sealed.xls": { "source": "iana" },
  "application/vnd.sealedmedia.softseal.html": { "source": "iana" },
  "application/vnd.sealedmedia.softseal.pdf": { "source": "iana" },
  "application/vnd.seemail": { "source": "iana", "extensions": ["see"] },
  "application/vnd.seis+json": { "source": "iana", "compressible": true },
  "application/vnd.sema": { "source": "iana", "extensions": ["sema"] },
  "application/vnd.semd": { "source": "iana", "extensions": ["semd"] },
  "application/vnd.semf": { "source": "iana", "extensions": ["semf"] },
  "application/vnd.shade-save-file": { "source": "iana" },
  "application/vnd.shana.informed.formdata": { "source": "iana", "extensions": ["ifm"] },
  "application/vnd.shana.informed.formtemplate": { "source": "iana", "extensions": ["itp"] },
  "application/vnd.shana.informed.interchange": { "source": "iana", "extensions": ["iif"] },
  "application/vnd.shana.informed.package": { "source": "iana", "extensions": ["ipk"] },
  "application/vnd.shootproof+json": { "source": "iana", "compressible": true },
  "application/vnd.shopkick+json": { "source": "iana", "compressible": true },
  "application/vnd.shp": { "source": "iana" },
  "application/vnd.shx": { "source": "iana" },
  "application/vnd.sigrok.session": { "source": "iana" },
  "application/vnd.simtech-mindmapper": { "source": "iana", "extensions": ["twd", "twds"] },
  "application/vnd.siren+json": { "source": "iana", "compressible": true },
  "application/vnd.smaf": { "source": "iana", "extensions": ["mmf"] },
  "application/vnd.smart.notebook": { "source": "iana" },
  "application/vnd.smart.teacher": { "source": "iana", "extensions": ["teacher"] },
  "application/vnd.snesdev-page-table": { "source": "iana" },
  "application/vnd.software602.filler.form+xml": { "source": "iana", "compressible": true, "extensions": ["fo"] },
  "application/vnd.software602.filler.form-xml-zip": { "source": "iana" },
  "application/vnd.solent.sdkm+xml": { "source": "iana", "compressible": true, "extensions": ["sdkm", "sdkd"] },
  "application/vnd.spotfire.dxp": { "source": "iana", "extensions": ["dxp"] },
  "application/vnd.spotfire.sfs": { "source": "iana", "extensions": ["sfs"] },
  "application/vnd.sqlite3": { "source": "iana" },
  "application/vnd.sss-cod": { "source": "iana" },
  "application/vnd.sss-dtf": { "source": "iana" },
  "application/vnd.sss-ntf": { "source": "iana" },
  "application/vnd.stardivision.calc": { "source": "apache", "extensions": ["sdc"] },
  "application/vnd.stardivision.draw": { "source": "apache", "extensions": ["sda"] },
  "application/vnd.stardivision.impress": { "source": "apache", "extensions": ["sdd"] },
  "application/vnd.stardivision.math": { "source": "apache", "extensions": ["smf"] },
  "application/vnd.stardivision.writer": { "source": "apache", "extensions": ["sdw", "vor"] },
  "application/vnd.stardivision.writer-global": { "source": "apache", "extensions": ["sgl"] },
  "application/vnd.stepmania.package": { "source": "iana", "extensions": ["smzip"] },
  "application/vnd.stepmania.stepchart": { "source": "iana", "extensions": ["sm"] },
  "application/vnd.street-stream": { "source": "iana" },
  "application/vnd.sun.wadl+xml": { "source": "iana", "compressible": true, "extensions": ["wadl"] },
  "application/vnd.sun.xml.calc": { "source": "apache", "extensions": ["sxc"] },
  "application/vnd.sun.xml.calc.template": { "source": "apache", "extensions": ["stc"] },
  "application/vnd.sun.xml.draw": { "source": "apache", "extensions": ["sxd"] },
  "application/vnd.sun.xml.draw.template": { "source": "apache", "extensions": ["std"] },
  "application/vnd.sun.xml.impress": { "source": "apache", "extensions": ["sxi"] },
  "application/vnd.sun.xml.impress.template": { "source": "apache", "extensions": ["sti"] },
  "application/vnd.sun.xml.math": { "source": "apache", "extensions": ["sxm"] },
  "application/vnd.sun.xml.writer": { "source": "apache", "extensions": ["sxw"] },
  "application/vnd.sun.xml.writer.global": { "source": "apache", "extensions": ["sxg"] },
  "application/vnd.sun.xml.writer.template": { "source": "apache", "extensions": ["stw"] },
  "application/vnd.sus-calendar": { "source": "iana", "extensions": ["sus", "susp"] },
  "application/vnd.svd": { "source": "iana", "extensions": ["svd"] },
  "application/vnd.swiftview-ics": { "source": "iana" },
  "application/vnd.sycle+xml": { "source": "iana", "compressible": true },
  "application/vnd.syft+json": { "source": "iana", "compressible": true },
  "application/vnd.symbian.install": { "source": "apache", "extensions": ["sis", "sisx"] },
  "application/vnd.syncml+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["xsm"] },
  "application/vnd.syncml.dm+wbxml": { "source": "iana", "charset": "UTF-8", "extensions": ["bdm"] },
  "application/vnd.syncml.dm+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["xdm"] },
  "application/vnd.syncml.dm.notification": { "source": "iana" },
  "application/vnd.syncml.dmddf+wbxml": { "source": "iana" },
  "application/vnd.syncml.dmddf+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["ddf"] },
  "application/vnd.syncml.dmtnds+wbxml": { "source": "iana" },
  "application/vnd.syncml.dmtnds+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.syncml.ds.notification": { "source": "iana" },
  "application/vnd.tableschema+json": { "source": "iana", "compressible": true },
  "application/vnd.tao.intent-module-archive": { "source": "iana", "extensions": ["tao"] },
  "application/vnd.tcpdump.pcap": { "source": "iana", "extensions": ["pcap", "cap", "dmp"] },
  "application/vnd.think-cell.ppttc+json": { "source": "iana", "compressible": true },
  "application/vnd.tmd.mediaflex.api+xml": { "source": "iana", "compressible": true },
  "application/vnd.tml": { "source": "iana" },
  "application/vnd.tmobile-livetv": { "source": "iana", "extensions": ["tmo"] },
  "application/vnd.tri.onesource": { "source": "iana" },
  "application/vnd.trid.tpt": { "source": "iana", "extensions": ["tpt"] },
  "application/vnd.triscape.mxs": { "source": "iana", "extensions": ["mxs"] },
  "application/vnd.trueapp": { "source": "iana", "extensions": ["tra"] },
  "application/vnd.truedoc": { "source": "iana" },
  "application/vnd.ubisoft.webplayer": { "source": "iana" },
  "application/vnd.ufdl": { "source": "iana", "extensions": ["ufd", "ufdl"] },
  "application/vnd.uiq.theme": { "source": "iana", "extensions": ["utz"] },
  "application/vnd.umajin": { "source": "iana", "extensions": ["umj"] },
  "application/vnd.unity": { "source": "iana", "extensions": ["unityweb"] },
  "application/vnd.uoml+xml": { "source": "iana", "compressible": true, "extensions": ["uoml"] },
  "application/vnd.uplanet.alert": { "source": "iana" },
  "application/vnd.uplanet.alert-wbxml": { "source": "iana" },
  "application/vnd.uplanet.bearer-choice": { "source": "iana" },
  "application/vnd.uplanet.bearer-choice-wbxml": { "source": "iana" },
  "application/vnd.uplanet.cacheop": { "source": "iana" },
  "application/vnd.uplanet.cacheop-wbxml": { "source": "iana" },
  "application/vnd.uplanet.channel": { "source": "iana" },
  "application/vnd.uplanet.channel-wbxml": { "source": "iana" },
  "application/vnd.uplanet.list": { "source": "iana" },
  "application/vnd.uplanet.list-wbxml": { "source": "iana" },
  "application/vnd.uplanet.listcmd": { "source": "iana" },
  "application/vnd.uplanet.listcmd-wbxml": { "source": "iana" },
  "application/vnd.uplanet.signal": { "source": "iana" },
  "application/vnd.uri-map": { "source": "iana" },
  "application/vnd.valve.source.material": { "source": "iana" },
  "application/vnd.vcx": { "source": "iana", "extensions": ["vcx"] },
  "application/vnd.vd-study": { "source": "iana" },
  "application/vnd.vectorworks": { "source": "iana" },
  "application/vnd.vel+json": { "source": "iana", "compressible": true },
  "application/vnd.verimatrix.vcas": { "source": "iana" },
  "application/vnd.veritone.aion+json": { "source": "iana", "compressible": true },
  "application/vnd.veryant.thin": { "source": "iana" },
  "application/vnd.ves.encrypted": { "source": "iana" },
  "application/vnd.vidsoft.vidconference": { "source": "iana" },
  "application/vnd.visio": { "source": "iana", "extensions": ["vsd", "vst", "vss", "vsw"] },
  "application/vnd.visionary": { "source": "iana", "extensions": ["vis"] },
  "application/vnd.vividence.scriptfile": { "source": "iana" },
  "application/vnd.vsf": { "source": "iana", "extensions": ["vsf"] },
  "application/vnd.wap.sic": { "source": "iana" },
  "application/vnd.wap.slc": { "source": "iana" },
  "application/vnd.wap.wbxml": { "source": "iana", "charset": "UTF-8", "extensions": ["wbxml"] },
  "application/vnd.wap.wmlc": { "source": "iana", "extensions": ["wmlc"] },
  "application/vnd.wap.wmlscriptc": { "source": "iana", "extensions": ["wmlsc"] },
  "application/vnd.webturbo": { "source": "iana", "extensions": ["wtb"] },
  "application/vnd.wfa.dpp": { "source": "iana" },
  "application/vnd.wfa.p2p": { "source": "iana" },
  "application/vnd.wfa.wsc": { "source": "iana" },
  "application/vnd.windows.devicepairing": { "source": "iana" },
  "application/vnd.wmc": { "source": "iana" },
  "application/vnd.wmf.bootstrap": { "source": "iana" },
  "application/vnd.wolfram.mathematica": { "source": "iana" },
  "application/vnd.wolfram.mathematica.package": { "source": "iana" },
  "application/vnd.wolfram.player": { "source": "iana", "extensions": ["nbp"] },
  "application/vnd.wordperfect": { "source": "iana", "extensions": ["wpd"] },
  "application/vnd.wqd": { "source": "iana", "extensions": ["wqd"] },
  "application/vnd.wrq-hp3000-labelled": { "source": "iana" },
  "application/vnd.wt.stf": { "source": "iana", "extensions": ["stf"] },
  "application/vnd.wv.csp+wbxml": { "source": "iana" },
  "application/vnd.wv.csp+xml": { "source": "iana", "compressible": true },
  "application/vnd.wv.ssp+xml": { "source": "iana", "compressible": true },
  "application/vnd.xacml+json": { "source": "iana", "compressible": true },
  "application/vnd.xara": { "source": "iana", "extensions": ["xar"] },
  "application/vnd.xfdl": { "source": "iana", "extensions": ["xfdl"] },
  "application/vnd.xfdl.webform": { "source": "iana" },
  "application/vnd.xmi+xml": { "source": "iana", "compressible": true },
  "application/vnd.xmpie.cpkg": { "source": "iana" },
  "application/vnd.xmpie.dpkg": { "source": "iana" },
  "application/vnd.xmpie.plan": { "source": "iana" },
  "application/vnd.xmpie.ppkg": { "source": "iana" },
  "application/vnd.xmpie.xlim": { "source": "iana" },
  "application/vnd.yamaha.hv-dic": { "source": "iana", "extensions": ["hvd"] },
  "application/vnd.yamaha.hv-script": { "source": "iana", "extensions": ["hvs"] },
  "application/vnd.yamaha.hv-voice": { "source": "iana", "extensions": ["hvp"] },
  "application/vnd.yamaha.openscoreformat": { "source": "iana", "extensions": ["osf"] },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": { "source": "iana", "compressible": true, "extensions": ["osfpvg"] },
  "application/vnd.yamaha.remote-setup": { "source": "iana" },
  "application/vnd.yamaha.smaf-audio": { "source": "iana", "extensions": ["saf"] },
  "application/vnd.yamaha.smaf-phrase": { "source": "iana", "extensions": ["spf"] },
  "application/vnd.yamaha.through-ngn": { "source": "iana" },
  "application/vnd.yamaha.tunnel-udpencap": { "source": "iana" },
  "application/vnd.yaoweme": { "source": "iana" },
  "application/vnd.yellowriver-custom-menu": { "source": "iana", "extensions": ["cmp"] },
  "application/vnd.youtube.yt": { "source": "iana" },
  "application/vnd.zul": { "source": "iana", "extensions": ["zir", "zirz"] },
  "application/vnd.zzazz.deck+xml": { "source": "iana", "compressible": true, "extensions": ["zaz"] },
  "application/voicexml+xml": { "source": "iana", "compressible": true, "extensions": ["vxml"] },
  "application/voucher-cms+json": { "source": "iana", "compressible": true },
  "application/vq-rtcpxr": { "source": "iana" },
  "application/wasm": { "source": "iana", "compressible": true, "extensions": ["wasm"] },
  "application/watcherinfo+xml": { "source": "iana", "compressible": true, "extensions": ["wif"] },
  "application/webpush-options+json": { "source": "iana", "compressible": true },
  "application/whoispp-query": { "source": "iana" },
  "application/whoispp-response": { "source": "iana" },
  "application/widget": { "source": "iana", "extensions": ["wgt"] },
  "application/winhlp": { "source": "apache", "extensions": ["hlp"] },
  "application/wita": { "source": "iana" },
  "application/wordperfect5.1": { "source": "iana" },
  "application/wsdl+xml": { "source": "iana", "compressible": true, "extensions": ["wsdl"] },
  "application/wspolicy+xml": { "source": "iana", "compressible": true, "extensions": ["wspolicy"] },
  "application/x-7z-compressed": { "source": "apache", "compressible": false, "extensions": ["7z"] },
  "application/x-abiword": { "source": "apache", "extensions": ["abw"] },
  "application/x-ace-compressed": { "source": "apache", "extensions": ["ace"] },
  "application/x-amf": { "source": "apache" },
  "application/x-apple-diskimage": { "source": "apache", "extensions": ["dmg"] },
  "application/x-arj": { "compressible": false, "extensions": ["arj"] },
  "application/x-authorware-bin": { "source": "apache", "extensions": ["aab", "x32", "u32", "vox"] },
  "application/x-authorware-map": { "source": "apache", "extensions": ["aam"] },
  "application/x-authorware-seg": { "source": "apache", "extensions": ["aas"] },
  "application/x-bcpio": { "source": "apache", "extensions": ["bcpio"] },
  "application/x-bdoc": { "compressible": false, "extensions": ["bdoc"] },
  "application/x-bittorrent": { "source": "apache", "extensions": ["torrent"] },
  "application/x-blorb": { "source": "apache", "extensions": ["blb", "blorb"] },
  "application/x-bzip": { "source": "apache", "compressible": false, "extensions": ["bz"] },
  "application/x-bzip2": { "source": "apache", "compressible": false, "extensions": ["bz2", "boz"] },
  "application/x-cbr": { "source": "apache", "extensions": ["cbr", "cba", "cbt", "cbz", "cb7"] },
  "application/x-cdlink": { "source": "apache", "extensions": ["vcd"] },
  "application/x-cfs-compressed": { "source": "apache", "extensions": ["cfs"] },
  "application/x-chat": { "source": "apache", "extensions": ["chat"] },
  "application/x-chess-pgn": { "source": "apache", "extensions": ["pgn"] },
  "application/x-chrome-extension": { "extensions": ["crx"] },
  "application/x-cocoa": { "source": "nginx", "extensions": ["cco"] },
  "application/x-compress": { "source": "apache" },
  "application/x-conference": { "source": "apache", "extensions": ["nsc"] },
  "application/x-cpio": { "source": "apache", "extensions": ["cpio"] },
  "application/x-csh": { "source": "apache", "extensions": ["csh"] },
  "application/x-deb": { "compressible": false },
  "application/x-debian-package": { "source": "apache", "extensions": ["deb", "udeb"] },
  "application/x-dgc-compressed": { "source": "apache", "extensions": ["dgc"] },
  "application/x-director": { "source": "apache", "extensions": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"] },
  "application/x-doom": { "source": "apache", "extensions": ["wad"] },
  "application/x-dtbncx+xml": { "source": "apache", "compressible": true, "extensions": ["ncx"] },
  "application/x-dtbook+xml": { "source": "apache", "compressible": true, "extensions": ["dtb"] },
  "application/x-dtbresource+xml": { "source": "apache", "compressible": true, "extensions": ["res"] },
  "application/x-dvi": { "source": "apache", "compressible": false, "extensions": ["dvi"] },
  "application/x-envoy": { "source": "apache", "extensions": ["evy"] },
  "application/x-eva": { "source": "apache", "extensions": ["eva"] },
  "application/x-font-bdf": { "source": "apache", "extensions": ["bdf"] },
  "application/x-font-dos": { "source": "apache" },
  "application/x-font-framemaker": { "source": "apache" },
  "application/x-font-ghostscript": { "source": "apache", "extensions": ["gsf"] },
  "application/x-font-libgrx": { "source": "apache" },
  "application/x-font-linux-psf": { "source": "apache", "extensions": ["psf"] },
  "application/x-font-pcf": { "source": "apache", "extensions": ["pcf"] },
  "application/x-font-snf": { "source": "apache", "extensions": ["snf"] },
  "application/x-font-speedo": { "source": "apache" },
  "application/x-font-sunos-news": { "source": "apache" },
  "application/x-font-type1": { "source": "apache", "extensions": ["pfa", "pfb", "pfm", "afm"] },
  "application/x-font-vfont": { "source": "apache" },
  "application/x-freearc": { "source": "apache", "extensions": ["arc"] },
  "application/x-futuresplash": { "source": "apache", "extensions": ["spl"] },
  "application/x-gca-compressed": { "source": "apache", "extensions": ["gca"] },
  "application/x-glulx": { "source": "apache", "extensions": ["ulx"] },
  "application/x-gnumeric": { "source": "apache", "extensions": ["gnumeric"] },
  "application/x-gramps-xml": { "source": "apache", "extensions": ["gramps"] },
  "application/x-gtar": { "source": "apache", "extensions": ["gtar"] },
  "application/x-gzip": { "source": "apache" },
  "application/x-hdf": { "source": "apache", "extensions": ["hdf"] },
  "application/x-httpd-php": { "compressible": true, "extensions": ["php"] },
  "application/x-install-instructions": { "source": "apache", "extensions": ["install"] },
  "application/x-iso9660-image": { "source": "apache", "extensions": ["iso"] },
  "application/x-iwork-keynote-sffkey": { "extensions": ["key"] },
  "application/x-iwork-numbers-sffnumbers": { "extensions": ["numbers"] },
  "application/x-iwork-pages-sffpages": { "extensions": ["pages"] },
  "application/x-java-archive-diff": { "source": "nginx", "extensions": ["jardiff"] },
  "application/x-java-jnlp-file": { "source": "apache", "compressible": false, "extensions": ["jnlp"] },
  "application/x-javascript": { "compressible": true },
  "application/x-keepass2": { "extensions": ["kdbx"] },
  "application/x-latex": { "source": "apache", "compressible": false, "extensions": ["latex"] },
  "application/x-lua-bytecode": { "extensions": ["luac"] },
  "application/x-lzh-compressed": { "source": "apache", "extensions": ["lzh", "lha"] },
  "application/x-makeself": { "source": "nginx", "extensions": ["run"] },
  "application/x-mie": { "source": "apache", "extensions": ["mie"] },
  "application/x-mobipocket-ebook": { "source": "apache", "extensions": ["prc", "mobi"] },
  "application/x-mpegurl": { "compressible": false },
  "application/x-ms-application": { "source": "apache", "extensions": ["application"] },
  "application/x-ms-shortcut": { "source": "apache", "extensions": ["lnk"] },
  "application/x-ms-wmd": { "source": "apache", "extensions": ["wmd"] },
  "application/x-ms-wmz": { "source": "apache", "extensions": ["wmz"] },
  "application/x-ms-xbap": { "source": "apache", "extensions": ["xbap"] },
  "application/x-msaccess": { "source": "apache", "extensions": ["mdb"] },
  "application/x-msbinder": { "source": "apache", "extensions": ["obd"] },
  "application/x-mscardfile": { "source": "apache", "extensions": ["crd"] },
  "application/x-msclip": { "source": "apache", "extensions": ["clp"] },
  "application/x-msdos-program": { "extensions": ["exe"] },
  "application/x-msdownload": { "source": "apache", "extensions": ["exe", "dll", "com", "bat", "msi"] },
  "application/x-msmediaview": { "source": "apache", "extensions": ["mvb", "m13", "m14"] },
  "application/x-msmetafile": { "source": "apache", "extensions": ["wmf", "wmz", "emf", "emz"] },
  "application/x-msmoney": { "source": "apache", "extensions": ["mny"] },
  "application/x-mspublisher": { "source": "apache", "extensions": ["pub"] },
  "application/x-msschedule": { "source": "apache", "extensions": ["scd"] },
  "application/x-msterminal": { "source": "apache", "extensions": ["trm"] },
  "application/x-mswrite": { "source": "apache", "extensions": ["wri"] },
  "application/x-netcdf": { "source": "apache", "extensions": ["nc", "cdf"] },
  "application/x-ns-proxy-autoconfig": { "compressible": true, "extensions": ["pac"] },
  "application/x-nzb": { "source": "apache", "extensions": ["nzb"] },
  "application/x-perl": { "source": "nginx", "extensions": ["pl", "pm"] },
  "application/x-pilot": { "source": "nginx", "extensions": ["prc", "pdb"] },
  "application/x-pkcs12": { "source": "apache", "compressible": false, "extensions": ["p12", "pfx"] },
  "application/x-pkcs7-certificates": { "source": "apache", "extensions": ["p7b", "spc"] },
  "application/x-pkcs7-certreqresp": { "source": "apache", "extensions": ["p7r"] },
  "application/x-pki-message": { "source": "iana" },
  "application/x-rar-compressed": { "source": "apache", "compressible": false, "extensions": ["rar"] },
  "application/x-redhat-package-manager": { "source": "nginx", "extensions": ["rpm"] },
  "application/x-research-info-systems": { "source": "apache", "extensions": ["ris"] },
  "application/x-sea": { "source": "nginx", "extensions": ["sea"] },
  "application/x-sh": { "source": "apache", "compressible": true, "extensions": ["sh"] },
  "application/x-shar": { "source": "apache", "extensions": ["shar"] },
  "application/x-shockwave-flash": { "source": "apache", "compressible": false, "extensions": ["swf"] },
  "application/x-silverlight-app": { "source": "apache", "extensions": ["xap"] },
  "application/x-sql": { "source": "apache", "extensions": ["sql"] },
  "application/x-stuffit": { "source": "apache", "compressible": false, "extensions": ["sit"] },
  "application/x-stuffitx": { "source": "apache", "extensions": ["sitx"] },
  "application/x-subrip": { "source": "apache", "extensions": ["srt"] },
  "application/x-sv4cpio": { "source": "apache", "extensions": ["sv4cpio"] },
  "application/x-sv4crc": { "source": "apache", "extensions": ["sv4crc"] },
  "application/x-t3vm-image": { "source": "apache", "extensions": ["t3"] },
  "application/x-tads": { "source": "apache", "extensions": ["gam"] },
  "application/x-tar": { "source": "apache", "compressible": true, "extensions": ["tar"] },
  "application/x-tcl": { "source": "apache", "extensions": ["tcl", "tk"] },
  "application/x-tex": { "source": "apache", "extensions": ["tex"] },
  "application/x-tex-tfm": { "source": "apache", "extensions": ["tfm"] },
  "application/x-texinfo": { "source": "apache", "extensions": ["texinfo", "texi"] },
  "application/x-tgif": { "source": "apache", "extensions": ["obj"] },
  "application/x-ustar": { "source": "apache", "extensions": ["ustar"] },
  "application/x-virtualbox-hdd": { "compressible": true, "extensions": ["hdd"] },
  "application/x-virtualbox-ova": { "compressible": true, "extensions": ["ova"] },
  "application/x-virtualbox-ovf": { "compressible": true, "extensions": ["ovf"] },
  "application/x-virtualbox-vbox": { "compressible": true, "extensions": ["vbox"] },
  "application/x-virtualbox-vbox-extpack": { "compressible": false, "extensions": ["vbox-extpack"] },
  "application/x-virtualbox-vdi": { "compressible": true, "extensions": ["vdi"] },
  "application/x-virtualbox-vhd": { "compressible": true, "extensions": ["vhd"] },
  "application/x-virtualbox-vmdk": { "compressible": true, "extensions": ["vmdk"] },
  "application/x-wais-source": { "source": "apache", "extensions": ["src"] },
  "application/x-web-app-manifest+json": { "compressible": true, "extensions": ["webapp"] },
  "application/x-www-form-urlencoded": { "source": "iana", "compressible": true },
  "application/x-x509-ca-cert": { "source": "iana", "extensions": ["der", "crt", "pem"] },
  "application/x-x509-ca-ra-cert": { "source": "iana" },
  "application/x-x509-next-ca-cert": { "source": "iana" },
  "application/x-xfig": { "source": "apache", "extensions": ["fig"] },
  "application/x-xliff+xml": { "source": "apache", "compressible": true, "extensions": ["xlf"] },
  "application/x-xpinstall": { "source": "apache", "compressible": false, "extensions": ["xpi"] },
  "application/x-xz": { "source": "apache", "extensions": ["xz"] },
  "application/x-zmachine": { "source": "apache", "extensions": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"] },
  "application/x400-bp": { "source": "iana" },
  "application/xacml+xml": { "source": "iana", "compressible": true },
  "application/xaml+xml": { "source": "apache", "compressible": true, "extensions": ["xaml"] },
  "application/xcap-att+xml": { "source": "iana", "compressible": true, "extensions": ["xav"] },
  "application/xcap-caps+xml": { "source": "iana", "compressible": true, "extensions": ["xca"] },
  "application/xcap-diff+xml": { "source": "iana", "compressible": true, "extensions": ["xdf"] },
  "application/xcap-el+xml": { "source": "iana", "compressible": true, "extensions": ["xel"] },
  "application/xcap-error+xml": { "source": "iana", "compressible": true },
  "application/xcap-ns+xml": { "source": "iana", "compressible": true, "extensions": ["xns"] },
  "application/xcon-conference-info+xml": { "source": "iana", "compressible": true },
  "application/xcon-conference-info-diff+xml": { "source": "iana", "compressible": true },
  "application/xenc+xml": { "source": "iana", "compressible": true, "extensions": ["xenc"] },
  "application/xhtml+xml": { "source": "iana", "compressible": true, "extensions": ["xhtml", "xht"] },
  "application/xhtml-voice+xml": { "source": "apache", "compressible": true },
  "application/xliff+xml": { "source": "iana", "compressible": true, "extensions": ["xlf"] },
  "application/xml": { "source": "iana", "compressible": true, "extensions": ["xml", "xsl", "xsd", "rng"] },
  "application/xml-dtd": { "source": "iana", "compressible": true, "extensions": ["dtd"] },
  "application/xml-external-parsed-entity": { "source": "iana" },
  "application/xml-patch+xml": { "source": "iana", "compressible": true },
  "application/xmpp+xml": { "source": "iana", "compressible": true },
  "application/xop+xml": { "source": "iana", "compressible": true, "extensions": ["xop"] },
  "application/xproc+xml": { "source": "apache", "compressible": true, "extensions": ["xpl"] },
  "application/xslt+xml": { "source": "iana", "compressible": true, "extensions": ["xsl", "xslt"] },
  "application/xspf+xml": { "source": "apache", "compressible": true, "extensions": ["xspf"] },
  "application/xv+xml": { "source": "iana", "compressible": true, "extensions": ["mxml", "xhvml", "xvml", "xvm"] },
  "application/yang": { "source": "iana", "extensions": ["yang"] },
  "application/yang-data+json": { "source": "iana", "compressible": true },
  "application/yang-data+xml": { "source": "iana", "compressible": true },
  "application/yang-patch+json": { "source": "iana", "compressible": true },
  "application/yang-patch+xml": { "source": "iana", "compressible": true },
  "application/yin+xml": { "source": "iana", "compressible": true, "extensions": ["yin"] },
  "application/zip": { "source": "iana", "compressible": false, "extensions": ["zip"] },
  "application/zlib": { "source": "iana" },
  "application/zstd": { "source": "iana" },
  "audio/1d-interleaved-parityfec": { "source": "iana" },
  "audio/32kadpcm": { "source": "iana" },
  "audio/3gpp": { "source": "iana", "compressible": false, "extensions": ["3gpp"] },
  "audio/3gpp2": { "source": "iana" },
  "audio/aac": { "source": "iana" },
  "audio/ac3": { "source": "iana" },
  "audio/adpcm": { "source": "apache", "extensions": ["adp"] },
  "audio/amr": { "source": "iana", "extensions": ["amr"] },
  "audio/amr-wb": { "source": "iana" },
  "audio/amr-wb+": { "source": "iana" },
  "audio/aptx": { "source": "iana" },
  "audio/asc": { "source": "iana" },
  "audio/atrac-advanced-lossless": { "source": "iana" },
  "audio/atrac-x": { "source": "iana" },
  "audio/atrac3": { "source": "iana" },
  "audio/basic": { "source": "iana", "compressible": false, "extensions": ["au", "snd"] },
  "audio/bv16": { "source": "iana" },
  "audio/bv32": { "source": "iana" },
  "audio/clearmode": { "source": "iana" },
  "audio/cn": { "source": "iana" },
  "audio/dat12": { "source": "iana" },
  "audio/dls": { "source": "iana" },
  "audio/dsr-es201108": { "source": "iana" },
  "audio/dsr-es202050": { "source": "iana" },
  "audio/dsr-es202211": { "source": "iana" },
  "audio/dsr-es202212": { "source": "iana" },
  "audio/dv": { "source": "iana" },
  "audio/dvi4": { "source": "iana" },
  "audio/eac3": { "source": "iana" },
  "audio/encaprtp": { "source": "iana" },
  "audio/evrc": { "source": "iana" },
  "audio/evrc-qcp": { "source": "iana" },
  "audio/evrc0": { "source": "iana" },
  "audio/evrc1": { "source": "iana" },
  "audio/evrcb": { "source": "iana" },
  "audio/evrcb0": { "source": "iana" },
  "audio/evrcb1": { "source": "iana" },
  "audio/evrcnw": { "source": "iana" },
  "audio/evrcnw0": { "source": "iana" },
  "audio/evrcnw1": { "source": "iana" },
  "audio/evrcwb": { "source": "iana" },
  "audio/evrcwb0": { "source": "iana" },
  "audio/evrcwb1": { "source": "iana" },
  "audio/evs": { "source": "iana" },
  "audio/flexfec": { "source": "iana" },
  "audio/fwdred": { "source": "iana" },
  "audio/g711-0": { "source": "iana" },
  "audio/g719": { "source": "iana" },
  "audio/g722": { "source": "iana" },
  "audio/g7221": { "source": "iana" },
  "audio/g723": { "source": "iana" },
  "audio/g726-16": { "source": "iana" },
  "audio/g726-24": { "source": "iana" },
  "audio/g726-32": { "source": "iana" },
  "audio/g726-40": { "source": "iana" },
  "audio/g728": { "source": "iana" },
  "audio/g729": { "source": "iana" },
  "audio/g7291": { "source": "iana" },
  "audio/g729d": { "source": "iana" },
  "audio/g729e": { "source": "iana" },
  "audio/gsm": { "source": "iana" },
  "audio/gsm-efr": { "source": "iana" },
  "audio/gsm-hr-08": { "source": "iana" },
  "audio/ilbc": { "source": "iana" },
  "audio/ip-mr_v2.5": { "source": "iana" },
  "audio/isac": { "source": "apache" },
  "audio/l16": { "source": "iana" },
  "audio/l20": { "source": "iana" },
  "audio/l24": { "source": "iana", "compressible": false },
  "audio/l8": { "source": "iana" },
  "audio/lpc": { "source": "iana" },
  "audio/melp": { "source": "iana" },
  "audio/melp1200": { "source": "iana" },
  "audio/melp2400": { "source": "iana" },
  "audio/melp600": { "source": "iana" },
  "audio/mhas": { "source": "iana" },
  "audio/midi": { "source": "apache", "extensions": ["mid", "midi", "kar", "rmi"] },
  "audio/mobile-xmf": { "source": "iana", "extensions": ["mxmf"] },
  "audio/mp3": { "compressible": false, "extensions": ["mp3"] },
  "audio/mp4": { "source": "iana", "compressible": false, "extensions": ["m4a", "mp4a"] },
  "audio/mp4a-latm": { "source": "iana" },
  "audio/mpa": { "source": "iana" },
  "audio/mpa-robust": { "source": "iana" },
  "audio/mpeg": { "source": "iana", "compressible": false, "extensions": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"] },
  "audio/mpeg4-generic": { "source": "iana" },
  "audio/musepack": { "source": "apache" },
  "audio/ogg": { "source": "iana", "compressible": false, "extensions": ["oga", "ogg", "spx", "opus"] },
  "audio/opus": { "source": "iana" },
  "audio/parityfec": { "source": "iana" },
  "audio/pcma": { "source": "iana" },
  "audio/pcma-wb": { "source": "iana" },
  "audio/pcmu": { "source": "iana" },
  "audio/pcmu-wb": { "source": "iana" },
  "audio/prs.sid": { "source": "iana" },
  "audio/qcelp": { "source": "iana" },
  "audio/raptorfec": { "source": "iana" },
  "audio/red": { "source": "iana" },
  "audio/rtp-enc-aescm128": { "source": "iana" },
  "audio/rtp-midi": { "source": "iana" },
  "audio/rtploopback": { "source": "iana" },
  "audio/rtx": { "source": "iana" },
  "audio/s3m": { "source": "apache", "extensions": ["s3m"] },
  "audio/scip": { "source": "iana" },
  "audio/silk": { "source": "apache", "extensions": ["sil"] },
  "audio/smv": { "source": "iana" },
  "audio/smv-qcp": { "source": "iana" },
  "audio/smv0": { "source": "iana" },
  "audio/sofa": { "source": "iana" },
  "audio/sp-midi": { "source": "iana" },
  "audio/speex": { "source": "iana" },
  "audio/t140c": { "source": "iana" },
  "audio/t38": { "source": "iana" },
  "audio/telephone-event": { "source": "iana" },
  "audio/tetra_acelp": { "source": "iana" },
  "audio/tetra_acelp_bb": { "source": "iana" },
  "audio/tone": { "source": "iana" },
  "audio/tsvcis": { "source": "iana" },
  "audio/uemclip": { "source": "iana" },
  "audio/ulpfec": { "source": "iana" },
  "audio/usac": { "source": "iana" },
  "audio/vdvi": { "source": "iana" },
  "audio/vmr-wb": { "source": "iana" },
  "audio/vnd.3gpp.iufp": { "source": "iana" },
  "audio/vnd.4sb": { "source": "iana" },
  "audio/vnd.audiokoz": { "source": "iana" },
  "audio/vnd.celp": { "source": "iana" },
  "audio/vnd.cisco.nse": { "source": "iana" },
  "audio/vnd.cmles.radio-events": { "source": "iana" },
  "audio/vnd.cns.anp1": { "source": "iana" },
  "audio/vnd.cns.inf1": { "source": "iana" },
  "audio/vnd.dece.audio": { "source": "iana", "extensions": ["uva", "uvva"] },
  "audio/vnd.digital-winds": { "source": "iana", "extensions": ["eol"] },
  "audio/vnd.dlna.adts": { "source": "iana" },
  "audio/vnd.dolby.heaac.1": { "source": "iana" },
  "audio/vnd.dolby.heaac.2": { "source": "iana" },
  "audio/vnd.dolby.mlp": { "source": "iana" },
  "audio/vnd.dolby.mps": { "source": "iana" },
  "audio/vnd.dolby.pl2": { "source": "iana" },
  "audio/vnd.dolby.pl2x": { "source": "iana" },
  "audio/vnd.dolby.pl2z": { "source": "iana" },
  "audio/vnd.dolby.pulse.1": { "source": "iana" },
  "audio/vnd.dra": { "source": "iana", "extensions": ["dra"] },
  "audio/vnd.dts": { "source": "iana", "extensions": ["dts"] },
  "audio/vnd.dts.hd": { "source": "iana", "extensions": ["dtshd"] },
  "audio/vnd.dts.uhd": { "source": "iana" },
  "audio/vnd.dvb.file": { "source": "iana" },
  "audio/vnd.everad.plj": { "source": "iana" },
  "audio/vnd.hns.audio": { "source": "iana" },
  "audio/vnd.lucent.voice": { "source": "iana", "extensions": ["lvp"] },
  "audio/vnd.ms-playready.media.pya": { "source": "iana", "extensions": ["pya"] },
  "audio/vnd.nokia.mobile-xmf": { "source": "iana" },
  "audio/vnd.nortel.vbk": { "source": "iana" },
  "audio/vnd.nuera.ecelp4800": { "source": "iana", "extensions": ["ecelp4800"] },
  "audio/vnd.nuera.ecelp7470": { "source": "iana", "extensions": ["ecelp7470"] },
  "audio/vnd.nuera.ecelp9600": { "source": "iana", "extensions": ["ecelp9600"] },
  "audio/vnd.octel.sbc": { "source": "iana" },
  "audio/vnd.presonus.multitrack": { "source": "iana" },
  "audio/vnd.qcelp": { "source": "iana" },
  "audio/vnd.rhetorex.32kadpcm": { "source": "iana" },
  "audio/vnd.rip": { "source": "iana", "extensions": ["rip"] },
  "audio/vnd.rn-realaudio": { "compressible": false },
  "audio/vnd.sealedmedia.softseal.mpeg": { "source": "iana" },
  "audio/vnd.vmx.cvsd": { "source": "iana" },
  "audio/vnd.wave": { "compressible": false },
  "audio/vorbis": { "source": "iana", "compressible": false },
  "audio/vorbis-config": { "source": "iana" },
  "audio/wav": { "compressible": false, "extensions": ["wav"] },
  "audio/wave": { "compressible": false, "extensions": ["wav"] },
  "audio/webm": { "source": "apache", "compressible": false, "extensions": ["weba"] },
  "audio/x-aac": { "source": "apache", "compressible": false, "extensions": ["aac"] },
  "audio/x-aiff": { "source": "apache", "extensions": ["aif", "aiff", "aifc"] },
  "audio/x-caf": { "source": "apache", "compressible": false, "extensions": ["caf"] },
  "audio/x-flac": { "source": "apache", "extensions": ["flac"] },
  "audio/x-m4a": { "source": "nginx", "extensions": ["m4a"] },
  "audio/x-matroska": { "source": "apache", "extensions": ["mka"] },
  "audio/x-mpegurl": { "source": "apache", "extensions": ["m3u"] },
  "audio/x-ms-wax": { "source": "apache", "extensions": ["wax"] },
  "audio/x-ms-wma": { "source": "apache", "extensions": ["wma"] },
  "audio/x-pn-realaudio": { "source": "apache", "extensions": ["ram", "ra"] },
  "audio/x-pn-realaudio-plugin": { "source": "apache", "extensions": ["rmp"] },
  "audio/x-realaudio": { "source": "nginx", "extensions": ["ra"] },
  "audio/x-tta": { "source": "apache" },
  "audio/x-wav": { "source": "apache", "extensions": ["wav"] },
  "audio/xm": { "source": "apache", "extensions": ["xm"] },
  "chemical/x-cdx": { "source": "apache", "extensions": ["cdx"] },
  "chemical/x-cif": { "source": "apache", "extensions": ["cif"] },
  "chemical/x-cmdf": { "source": "apache", "extensions": ["cmdf"] },
  "chemical/x-cml": { "source": "apache", "extensions": ["cml"] },
  "chemical/x-csml": { "source": "apache", "extensions": ["csml"] },
  "chemical/x-pdb": { "source": "apache" },
  "chemical/x-xyz": { "source": "apache", "extensions": ["xyz"] },
  "font/collection": { "source": "iana", "extensions": ["ttc"] },
  "font/otf": { "source": "iana", "compressible": true, "extensions": ["otf"] },
  "font/sfnt": { "source": "iana" },
  "font/ttf": { "source": "iana", "compressible": true, "extensions": ["ttf"] },
  "font/woff": { "source": "iana", "extensions": ["woff"] },
  "font/woff2": { "source": "iana", "extensions": ["woff2"] },
  "image/aces": { "source": "iana", "extensions": ["exr"] },
  "image/apng": { "compressible": false, "extensions": ["apng"] },
  "image/avci": { "source": "iana", "extensions": ["avci"] },
  "image/avcs": { "source": "iana", "extensions": ["avcs"] },
  "image/avif": { "source": "iana", "compressible": false, "extensions": ["avif"] },
  "image/bmp": { "source": "iana", "compressible": true, "extensions": ["bmp"] },
  "image/cgm": { "source": "iana", "extensions": ["cgm"] },
  "image/dicom-rle": { "source": "iana", "extensions": ["drle"] },
  "image/emf": { "source": "iana", "extensions": ["emf"] },
  "image/fits": { "source": "iana", "extensions": ["fits"] },
  "image/g3fax": { "source": "iana", "extensions": ["g3"] },
  "image/gif": { "source": "iana", "compressible": false, "extensions": ["gif"] },
  "image/heic": { "source": "iana", "extensions": ["heic"] },
  "image/heic-sequence": { "source": "iana", "extensions": ["heics"] },
  "image/heif": { "source": "iana", "extensions": ["heif"] },
  "image/heif-sequence": { "source": "iana", "extensions": ["heifs"] },
  "image/hej2k": { "source": "iana", "extensions": ["hej2"] },
  "image/hsj2": { "source": "iana", "extensions": ["hsj2"] },
  "image/ief": { "source": "iana", "extensions": ["ief"] },
  "image/jls": { "source": "iana", "extensions": ["jls"] },
  "image/jp2": { "source": "iana", "compressible": false, "extensions": ["jp2", "jpg2"] },
  "image/jpeg": { "source": "iana", "compressible": false, "extensions": ["jpeg", "jpg", "jpe"] },
  "image/jph": { "source": "iana", "extensions": ["jph"] },
  "image/jphc": { "source": "iana", "extensions": ["jhc"] },
  "image/jpm": { "source": "iana", "compressible": false, "extensions": ["jpm"] },
  "image/jpx": { "source": "iana", "compressible": false, "extensions": ["jpx", "jpf"] },
  "image/jxr": { "source": "iana", "extensions": ["jxr"] },
  "image/jxra": { "source": "iana", "extensions": ["jxra"] },
  "image/jxrs": { "source": "iana", "extensions": ["jxrs"] },
  "image/jxs": { "source": "iana", "extensions": ["jxs"] },
  "image/jxsc": { "source": "iana", "extensions": ["jxsc"] },
  "image/jxsi": { "source": "iana", "extensions": ["jxsi"] },
  "image/jxss": { "source": "iana", "extensions": ["jxss"] },
  "image/ktx": { "source": "iana", "extensions": ["ktx"] },
  "image/ktx2": { "source": "iana", "extensions": ["ktx2"] },
  "image/naplps": { "source": "iana" },
  "image/pjpeg": { "compressible": false },
  "image/png": { "source": "iana", "compressible": false, "extensions": ["png"] },
  "image/prs.btif": { "source": "iana", "extensions": ["btif"] },
  "image/prs.pti": { "source": "iana", "extensions": ["pti"] },
  "image/pwg-raster": { "source": "iana" },
  "image/sgi": { "source": "apache", "extensions": ["sgi"] },
  "image/svg+xml": { "source": "iana", "compressible": true, "extensions": ["svg", "svgz"] },
  "image/t38": { "source": "iana", "extensions": ["t38"] },
  "image/tiff": { "source": "iana", "compressible": false, "extensions": ["tif", "tiff"] },
  "image/tiff-fx": { "source": "iana", "extensions": ["tfx"] },
  "image/vnd.adobe.photoshop": { "source": "iana", "compressible": true, "extensions": ["psd"] },
  "image/vnd.airzip.accelerator.azv": { "source": "iana", "extensions": ["azv"] },
  "image/vnd.cns.inf2": { "source": "iana" },
  "image/vnd.dece.graphic": { "source": "iana", "extensions": ["uvi", "uvvi", "uvg", "uvvg"] },
  "image/vnd.djvu": { "source": "iana", "extensions": ["djvu", "djv"] },
  "image/vnd.dvb.subtitle": { "source": "iana", "extensions": ["sub"] },
  "image/vnd.dwg": { "source": "iana", "extensions": ["dwg"] },
  "image/vnd.dxf": { "source": "iana", "extensions": ["dxf"] },
  "image/vnd.fastbidsheet": { "source": "iana", "extensions": ["fbs"] },
  "image/vnd.fpx": { "source": "iana", "extensions": ["fpx"] },
  "image/vnd.fst": { "source": "iana", "extensions": ["fst"] },
  "image/vnd.fujixerox.edmics-mmr": { "source": "iana", "extensions": ["mmr"] },
  "image/vnd.fujixerox.edmics-rlc": { "source": "iana", "extensions": ["rlc"] },
  "image/vnd.globalgraphics.pgb": { "source": "iana" },
  "image/vnd.microsoft.icon": { "source": "iana", "compressible": true, "extensions": ["ico"] },
  "image/vnd.mix": { "source": "iana" },
  "image/vnd.mozilla.apng": { "source": "iana" },
  "image/vnd.ms-dds": { "compressible": true, "extensions": ["dds"] },
  "image/vnd.ms-modi": { "source": "iana", "extensions": ["mdi"] },
  "image/vnd.ms-photo": { "source": "apache", "extensions": ["wdp"] },
  "image/vnd.net-fpx": { "source": "iana", "extensions": ["npx"] },
  "image/vnd.pco.b16": { "source": "iana", "extensions": ["b16"] },
  "image/vnd.radiance": { "source": "iana" },
  "image/vnd.sealed.png": { "source": "iana" },
  "image/vnd.sealedmedia.softseal.gif": { "source": "iana" },
  "image/vnd.sealedmedia.softseal.jpg": { "source": "iana" },
  "image/vnd.svf": { "source": "iana" },
  "image/vnd.tencent.tap": { "source": "iana", "extensions": ["tap"] },
  "image/vnd.valve.source.texture": { "source": "iana", "extensions": ["vtf"] },
  "image/vnd.wap.wbmp": { "source": "iana", "extensions": ["wbmp"] },
  "image/vnd.xiff": { "source": "iana", "extensions": ["xif"] },
  "image/vnd.zbrush.pcx": { "source": "iana", "extensions": ["pcx"] },
  "image/webp": { "source": "apache", "extensions": ["webp"] },
  "image/wmf": { "source": "iana", "extensions": ["wmf"] },
  "image/x-3ds": { "source": "apache", "extensions": ["3ds"] },
  "image/x-cmu-raster": { "source": "apache", "extensions": ["ras"] },
  "image/x-cmx": { "source": "apache", "extensions": ["cmx"] },
  "image/x-freehand": { "source": "apache", "extensions": ["fh", "fhc", "fh4", "fh5", "fh7"] },
  "image/x-icon": { "source": "apache", "compressible": true, "extensions": ["ico"] },
  "image/x-jng": { "source": "nginx", "extensions": ["jng"] },
  "image/x-mrsid-image": { "source": "apache", "extensions": ["sid"] },
  "image/x-ms-bmp": { "source": "nginx", "compressible": true, "extensions": ["bmp"] },
  "image/x-pcx": { "source": "apache", "extensions": ["pcx"] },
  "image/x-pict": { "source": "apache", "extensions": ["pic", "pct"] },
  "image/x-portable-anymap": { "source": "apache", "extensions": ["pnm"] },
  "image/x-portable-bitmap": { "source": "apache", "extensions": ["pbm"] },
  "image/x-portable-graymap": { "source": "apache", "extensions": ["pgm"] },
  "image/x-portable-pixmap": { "source": "apache", "extensions": ["ppm"] },
  "image/x-rgb": { "source": "apache", "extensions": ["rgb"] },
  "image/x-tga": { "source": "apache", "extensions": ["tga"] },
  "image/x-xbitmap": { "source": "apache", "extensions": ["xbm"] },
  "image/x-xcf": { "compressible": false },
  "image/x-xpixmap": { "source": "apache", "extensions": ["xpm"] },
  "image/x-xwindowdump": { "source": "apache", "extensions": ["xwd"] },
  "message/cpim": { "source": "iana" },
  "message/delivery-status": { "source": "iana" },
  "message/disposition-notification": { "source": "iana", "extensions": ["disposition-notification"] },
  "message/external-body": { "source": "iana" },
  "message/feedback-report": { "source": "iana" },
  "message/global": { "source": "iana", "extensions": ["u8msg"] },
  "message/global-delivery-status": { "source": "iana", "extensions": ["u8dsn"] },
  "message/global-disposition-notification": { "source": "iana", "extensions": ["u8mdn"] },
  "message/global-headers": { "source": "iana", "extensions": ["u8hdr"] },
  "message/http": { "source": "iana", "compressible": false },
  "message/imdn+xml": { "source": "iana", "compressible": true },
  "message/news": { "source": "iana" },
  "message/partial": { "source": "iana", "compressible": false },
  "message/rfc822": { "source": "iana", "compressible": true, "extensions": ["eml", "mime"] },
  "message/s-http": { "source": "iana" },
  "message/sip": { "source": "iana" },
  "message/sipfrag": { "source": "iana" },
  "message/tracking-status": { "source": "iana" },
  "message/vnd.si.simp": { "source": "iana" },
  "message/vnd.wfa.wsc": { "source": "iana", "extensions": ["wsc"] },
  "model/3mf": { "source": "iana", "extensions": ["3mf"] },
  "model/e57": { "source": "iana" },
  "model/gltf+json": { "source": "iana", "compressible": true, "extensions": ["gltf"] },
  "model/gltf-binary": { "source": "iana", "compressible": true, "extensions": ["glb"] },
  "model/iges": { "source": "iana", "compressible": false, "extensions": ["igs", "iges"] },
  "model/mesh": { "source": "iana", "compressible": false, "extensions": ["msh", "mesh", "silo"] },
  "model/mtl": { "source": "iana", "extensions": ["mtl"] },
  "model/obj": { "source": "iana", "extensions": ["obj"] },
  "model/step": { "source": "iana" },
  "model/step+xml": { "source": "iana", "compressible": true, "extensions": ["stpx"] },
  "model/step+zip": { "source": "iana", "compressible": false, "extensions": ["stpz"] },
  "model/step-xml+zip": { "source": "iana", "compressible": false, "extensions": ["stpxz"] },
  "model/stl": { "source": "iana", "extensions": ["stl"] },
  "model/vnd.collada+xml": { "source": "iana", "compressible": true, "extensions": ["dae"] },
  "model/vnd.dwf": { "source": "iana", "extensions": ["dwf"] },
  "model/vnd.flatland.3dml": { "source": "iana" },
  "model/vnd.gdl": { "source": "iana", "extensions": ["gdl"] },
  "model/vnd.gs-gdl": { "source": "apache" },
  "model/vnd.gs.gdl": { "source": "iana" },
  "model/vnd.gtw": { "source": "iana", "extensions": ["gtw"] },
  "model/vnd.moml+xml": { "source": "iana", "compressible": true },
  "model/vnd.mts": { "source": "iana", "extensions": ["mts"] },
  "model/vnd.opengex": { "source": "iana", "extensions": ["ogex"] },
  "model/vnd.parasolid.transmit.binary": { "source": "iana", "extensions": ["x_b"] },
  "model/vnd.parasolid.transmit.text": { "source": "iana", "extensions": ["x_t"] },
  "model/vnd.pytha.pyox": { "source": "iana" },
  "model/vnd.rosette.annotated-data-model": { "source": "iana" },
  "model/vnd.sap.vds": { "source": "iana", "extensions": ["vds"] },
  "model/vnd.usdz+zip": { "source": "iana", "compressible": false, "extensions": ["usdz"] },
  "model/vnd.valve.source.compiled-map": { "source": "iana", "extensions": ["bsp"] },
  "model/vnd.vtu": { "source": "iana", "extensions": ["vtu"] },
  "model/vrml": { "source": "iana", "compressible": false, "extensions": ["wrl", "vrml"] },
  "model/x3d+binary": { "source": "apache", "compressible": false, "extensions": ["x3db", "x3dbz"] },
  "model/x3d+fastinfoset": { "source": "iana", "extensions": ["x3db"] },
  "model/x3d+vrml": { "source": "apache", "compressible": false, "extensions": ["x3dv", "x3dvz"] },
  "model/x3d+xml": { "source": "iana", "compressible": true, "extensions": ["x3d", "x3dz"] },
  "model/x3d-vrml": { "source": "iana", "extensions": ["x3dv"] },
  "multipart/alternative": { "source": "iana", "compressible": false },
  "multipart/appledouble": { "source": "iana" },
  "multipart/byteranges": { "source": "iana" },
  "multipart/digest": { "source": "iana" },
  "multipart/encrypted": { "source": "iana", "compressible": false },
  "multipart/form-data": { "source": "iana", "compressible": false },
  "multipart/header-set": { "source": "iana" },
  "multipart/mixed": { "source": "iana" },
  "multipart/multilingual": { "source": "iana" },
  "multipart/parallel": { "source": "iana" },
  "multipart/related": { "source": "iana", "compressible": false },
  "multipart/report": { "source": "iana" },
  "multipart/signed": { "source": "iana", "compressible": false },
  "multipart/vnd.bint.med-plus": { "source": "iana" },
  "multipart/voice-message": { "source": "iana" },
  "multipart/x-mixed-replace": { "source": "iana" },
  "text/1d-interleaved-parityfec": { "source": "iana" },
  "text/cache-manifest": { "source": "iana", "compressible": true, "extensions": ["appcache", "manifest"] },
  "text/calendar": { "source": "iana", "extensions": ["ics", "ifb"] },
  "text/calender": { "compressible": true },
  "text/cmd": { "compressible": true },
  "text/coffeescript": { "extensions": ["coffee", "litcoffee"] },
  "text/cql": { "source": "iana" },
  "text/cql-expression": { "source": "iana" },
  "text/cql-identifier": { "source": "iana" },
  "text/css": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["css"] },
  "text/csv": { "source": "iana", "compressible": true, "extensions": ["csv"] },
  "text/csv-schema": { "source": "iana" },
  "text/directory": { "source": "iana" },
  "text/dns": { "source": "iana" },
  "text/ecmascript": { "source": "iana" },
  "text/encaprtp": { "source": "iana" },
  "text/enriched": { "source": "iana" },
  "text/fhirpath": { "source": "iana" },
  "text/flexfec": { "source": "iana" },
  "text/fwdred": { "source": "iana" },
  "text/gff3": { "source": "iana" },
  "text/grammar-ref-list": { "source": "iana" },
  "text/html": { "source": "iana", "compressible": true, "extensions": ["html", "htm", "shtml"] },
  "text/jade": { "extensions": ["jade"] },
  "text/javascript": { "source": "iana", "compressible": true },
  "text/jcr-cnd": { "source": "iana" },
  "text/jsx": { "compressible": true, "extensions": ["jsx"] },
  "text/less": { "compressible": true, "extensions": ["less"] },
  "text/markdown": { "source": "iana", "compressible": true, "extensions": ["markdown", "md"] },
  "text/mathml": { "source": "nginx", "extensions": ["mml"] },
  "text/mdx": { "compressible": true, "extensions": ["mdx"] },
  "text/mizar": { "source": "iana" },
  "text/n3": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["n3"] },
  "text/parameters": { "source": "iana", "charset": "UTF-8" },
  "text/parityfec": { "source": "iana" },
  "text/plain": { "source": "iana", "compressible": true, "extensions": ["txt", "text", "conf", "def", "list", "log", "in", "ini"] },
  "text/provenance-notation": { "source": "iana", "charset": "UTF-8" },
  "text/prs.fallenstein.rst": { "source": "iana" },
  "text/prs.lines.tag": { "source": "iana", "extensions": ["dsc"] },
  "text/prs.prop.logic": { "source": "iana" },
  "text/raptorfec": { "source": "iana" },
  "text/red": { "source": "iana" },
  "text/rfc822-headers": { "source": "iana" },
  "text/richtext": { "source": "iana", "compressible": true, "extensions": ["rtx"] },
  "text/rtf": { "source": "iana", "compressible": true, "extensions": ["rtf"] },
  "text/rtp-enc-aescm128": { "source": "iana" },
  "text/rtploopback": { "source": "iana" },
  "text/rtx": { "source": "iana" },
  "text/sgml": { "source": "iana", "extensions": ["sgml", "sgm"] },
  "text/shaclc": { "source": "iana" },
  "text/shex": { "source": "iana", "extensions": ["shex"] },
  "text/slim": { "extensions": ["slim", "slm"] },
  "text/spdx": { "source": "iana", "extensions": ["spdx"] },
  "text/strings": { "source": "iana" },
  "text/stylus": { "extensions": ["stylus", "styl"] },
  "text/t140": { "source": "iana" },
  "text/tab-separated-values": { "source": "iana", "compressible": true, "extensions": ["tsv"] },
  "text/troff": { "source": "iana", "extensions": ["t", "tr", "roff", "man", "me", "ms"] },
  "text/turtle": { "source": "iana", "charset": "UTF-8", "extensions": ["ttl"] },
  "text/ulpfec": { "source": "iana" },
  "text/uri-list": { "source": "iana", "compressible": true, "extensions": ["uri", "uris", "urls"] },
  "text/vcard": { "source": "iana", "compressible": true, "extensions": ["vcard"] },
  "text/vnd.a": { "source": "iana" },
  "text/vnd.abc": { "source": "iana" },
  "text/vnd.ascii-art": { "source": "iana" },
  "text/vnd.curl": { "source": "iana", "extensions": ["curl"] },
  "text/vnd.curl.dcurl": { "source": "apache", "extensions": ["dcurl"] },
  "text/vnd.curl.mcurl": { "source": "apache", "extensions": ["mcurl"] },
  "text/vnd.curl.scurl": { "source": "apache", "extensions": ["scurl"] },
  "text/vnd.debian.copyright": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.dmclientscript": { "source": "iana" },
  "text/vnd.dvb.subtitle": { "source": "iana", "extensions": ["sub"] },
  "text/vnd.esmertec.theme-descriptor": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.familysearch.gedcom": { "source": "iana", "extensions": ["ged"] },
  "text/vnd.ficlab.flt": { "source": "iana" },
  "text/vnd.fly": { "source": "iana", "extensions": ["fly"] },
  "text/vnd.fmi.flexstor": { "source": "iana", "extensions": ["flx"] },
  "text/vnd.gml": { "source": "iana" },
  "text/vnd.graphviz": { "source": "iana", "extensions": ["gv"] },
  "text/vnd.hans": { "source": "iana" },
  "text/vnd.hgl": { "source": "iana" },
  "text/vnd.in3d.3dml": { "source": "iana", "extensions": ["3dml"] },
  "text/vnd.in3d.spot": { "source": "iana", "extensions": ["spot"] },
  "text/vnd.iptc.newsml": { "source": "iana" },
  "text/vnd.iptc.nitf": { "source": "iana" },
  "text/vnd.latex-z": { "source": "iana" },
  "text/vnd.motorola.reflex": { "source": "iana" },
  "text/vnd.ms-mediapackage": { "source": "iana" },
  "text/vnd.net2phone.commcenter.command": { "source": "iana" },
  "text/vnd.radisys.msml-basic-layout": { "source": "iana" },
  "text/vnd.senx.warpscript": { "source": "iana" },
  "text/vnd.si.uricatalogue": { "source": "iana" },
  "text/vnd.sosi": { "source": "iana" },
  "text/vnd.sun.j2me.app-descriptor": { "source": "iana", "charset": "UTF-8", "extensions": ["jad"] },
  "text/vnd.trolltech.linguist": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.wap.si": { "source": "iana" },
  "text/vnd.wap.sl": { "source": "iana" },
  "text/vnd.wap.wml": { "source": "iana", "extensions": ["wml"] },
  "text/vnd.wap.wmlscript": { "source": "iana", "extensions": ["wmls"] },
  "text/vtt": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["vtt"] },
  "text/x-asm": { "source": "apache", "extensions": ["s", "asm"] },
  "text/x-c": { "source": "apache", "extensions": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"] },
  "text/x-component": { "source": "nginx", "extensions": ["htc"] },
  "text/x-fortran": { "source": "apache", "extensions": ["f", "for", "f77", "f90"] },
  "text/x-gwt-rpc": { "compressible": true },
  "text/x-handlebars-template": { "extensions": ["hbs"] },
  "text/x-java-source": { "source": "apache", "extensions": ["java"] },
  "text/x-jquery-tmpl": { "compressible": true },
  "text/x-lua": { "extensions": ["lua"] },
  "text/x-markdown": { "compressible": true, "extensions": ["mkd"] },
  "text/x-nfo": { "source": "apache", "extensions": ["nfo"] },
  "text/x-opml": { "source": "apache", "extensions": ["opml"] },
  "text/x-org": { "compressible": true, "extensions": ["org"] },
  "text/x-pascal": { "source": "apache", "extensions": ["p", "pas"] },
  "text/x-processing": { "compressible": true, "extensions": ["pde"] },
  "text/x-sass": { "extensions": ["sass"] },
  "text/x-scss": { "extensions": ["scss"] },
  "text/x-setext": { "source": "apache", "extensions": ["etx"] },
  "text/x-sfv": { "source": "apache", "extensions": ["sfv"] },
  "text/x-suse-ymp": { "compressible": true, "extensions": ["ymp"] },
  "text/x-uuencode": { "source": "apache", "extensions": ["uu"] },
  "text/x-vcalendar": { "source": "apache", "extensions": ["vcs"] },
  "text/x-vcard": { "source": "apache", "extensions": ["vcf"] },
  "text/xml": { "source": "iana", "compressible": true, "extensions": ["xml"] },
  "text/xml-external-parsed-entity": { "source": "iana" },
  "text/yaml": { "compressible": true, "extensions": ["yaml", "yml"] },
  "video/1d-interleaved-parityfec": { "source": "iana" },
  "video/3gpp": { "source": "iana", "extensions": ["3gp", "3gpp"] },
  "video/3gpp-tt": { "source": "iana" },
  "video/3gpp2": { "source": "iana", "extensions": ["3g2"] },
  "video/av1": { "source": "iana" },
  "video/bmpeg": { "source": "iana" },
  "video/bt656": { "source": "iana" },
  "video/celb": { "source": "iana" },
  "video/dv": { "source": "iana" },
  "video/encaprtp": { "source": "iana" },
  "video/ffv1": { "source": "iana" },
  "video/flexfec": { "source": "iana" },
  "video/h261": { "source": "iana", "extensions": ["h261"] },
  "video/h263": { "source": "iana", "extensions": ["h263"] },
  "video/h263-1998": { "source": "iana" },
  "video/h263-2000": { "source": "iana" },
  "video/h264": { "source": "iana", "extensions": ["h264"] },
  "video/h264-rcdo": { "source": "iana" },
  "video/h264-svc": { "source": "iana" },
  "video/h265": { "source": "iana" },
  "video/iso.segment": { "source": "iana", "extensions": ["m4s"] },
  "video/jpeg": { "source": "iana", "extensions": ["jpgv"] },
  "video/jpeg2000": { "source": "iana" },
  "video/jpm": { "source": "apache", "extensions": ["jpm", "jpgm"] },
  "video/jxsv": { "source": "iana" },
  "video/mj2": { "source": "iana", "extensions": ["mj2", "mjp2"] },
  "video/mp1s": { "source": "iana" },
  "video/mp2p": { "source": "iana" },
  "video/mp2t": { "source": "iana", "extensions": ["ts"] },
  "video/mp4": { "source": "iana", "compressible": false, "extensions": ["mp4", "mp4v", "mpg4"] },
  "video/mp4v-es": { "source": "iana" },
  "video/mpeg": { "source": "iana", "compressible": false, "extensions": ["mpeg", "mpg", "mpe", "m1v", "m2v"] },
  "video/mpeg4-generic": { "source": "iana" },
  "video/mpv": { "source": "iana" },
  "video/nv": { "source": "iana" },
  "video/ogg": { "source": "iana", "compressible": false, "extensions": ["ogv"] },
  "video/parityfec": { "source": "iana" },
  "video/pointer": { "source": "iana" },
  "video/quicktime": { "source": "iana", "compressible": false, "extensions": ["qt", "mov"] },
  "video/raptorfec": { "source": "iana" },
  "video/raw": { "source": "iana" },
  "video/rtp-enc-aescm128": { "source": "iana" },
  "video/rtploopback": { "source": "iana" },
  "video/rtx": { "source": "iana" },
  "video/scip": { "source": "iana" },
  "video/smpte291": { "source": "iana" },
  "video/smpte292m": { "source": "iana" },
  "video/ulpfec": { "source": "iana" },
  "video/vc1": { "source": "iana" },
  "video/vc2": { "source": "iana" },
  "video/vnd.cctv": { "source": "iana" },
  "video/vnd.dece.hd": { "source": "iana", "extensions": ["uvh", "uvvh"] },
  "video/vnd.dece.mobile": { "source": "iana", "extensions": ["uvm", "uvvm"] },
  "video/vnd.dece.mp4": { "source": "iana" },
  "video/vnd.dece.pd": { "source": "iana", "extensions": ["uvp", "uvvp"] },
  "video/vnd.dece.sd": { "source": "iana", "extensions": ["uvs", "uvvs"] },
  "video/vnd.dece.video": { "source": "iana", "extensions": ["uvv", "uvvv"] },
  "video/vnd.directv.mpeg": { "source": "iana" },
  "video/vnd.directv.mpeg-tts": { "source": "iana" },
  "video/vnd.dlna.mpeg-tts": { "source": "iana" },
  "video/vnd.dvb.file": { "source": "iana", "extensions": ["dvb"] },
  "video/vnd.fvt": { "source": "iana", "extensions": ["fvt"] },
  "video/vnd.hns.video": { "source": "iana" },
  "video/vnd.iptvforum.1dparityfec-1010": { "source": "iana" },
  "video/vnd.iptvforum.1dparityfec-2005": { "source": "iana" },
  "video/vnd.iptvforum.2dparityfec-1010": { "source": "iana" },
  "video/vnd.iptvforum.2dparityfec-2005": { "source": "iana" },
  "video/vnd.iptvforum.ttsavc": { "source": "iana" },
  "video/vnd.iptvforum.ttsmpeg2": { "source": "iana" },
  "video/vnd.motorola.video": { "source": "iana" },
  "video/vnd.motorola.videop": { "source": "iana" },
  "video/vnd.mpegurl": { "source": "iana", "extensions": ["mxu", "m4u"] },
  "video/vnd.ms-playready.media.pyv": { "source": "iana", "extensions": ["pyv"] },
  "video/vnd.nokia.interleaved-multimedia": { "source": "iana" },
  "video/vnd.nokia.mp4vr": { "source": "iana" },
  "video/vnd.nokia.videovoip": { "source": "iana" },
  "video/vnd.objectvideo": { "source": "iana" },
  "video/vnd.radgamettools.bink": { "source": "iana" },
  "video/vnd.radgamettools.smacker": { "source": "iana" },
  "video/vnd.sealed.mpeg1": { "source": "iana" },
  "video/vnd.sealed.mpeg4": { "source": "iana" },
  "video/vnd.sealed.swf": { "source": "iana" },
  "video/vnd.sealedmedia.softseal.mov": { "source": "iana" },
  "video/vnd.uvvu.mp4": { "source": "iana", "extensions": ["uvu", "uvvu"] },
  "video/vnd.vivo": { "source": "iana", "extensions": ["viv"] },
  "video/vnd.youtube.yt": { "source": "iana" },
  "video/vp8": { "source": "iana" },
  "video/vp9": { "source": "iana" },
  "video/webm": { "source": "apache", "compressible": false, "extensions": ["webm"] },
  "video/x-f4v": { "source": "apache", "extensions": ["f4v"] },
  "video/x-fli": { "source": "apache", "extensions": ["fli"] },
  "video/x-flv": { "source": "apache", "compressible": false, "extensions": ["flv"] },
  "video/x-m4v": { "source": "apache", "extensions": ["m4v"] },
  "video/x-matroska": { "source": "apache", "compressible": false, "extensions": ["mkv", "mk3d", "mks"] },
  "video/x-mng": { "source": "apache", "extensions": ["mng"] },
  "video/x-ms-asf": { "source": "apache", "extensions": ["asf", "asx"] },
  "video/x-ms-vob": { "source": "apache", "extensions": ["vob"] },
  "video/x-ms-wm": { "source": "apache", "extensions": ["wm"] },
  "video/x-ms-wmv": { "source": "apache", "compressible": false, "extensions": ["wmv"] },
  "video/x-ms-wmx": { "source": "apache", "extensions": ["wmx"] },
  "video/x-ms-wvx": { "source": "apache", "extensions": ["wvx"] },
  "video/x-msvideo": { "source": "apache", "extensions": ["avi"] },
  "video/x-sgi-movie": { "source": "apache", "extensions": ["movie"] },
  "video/x-smv": { "source": "apache", "extensions": ["smv"] },
  "x-conference/x-cooltalk": { "source": "apache", "extensions": ["ice"] },
  "x-shader/x-fragment": { "compressible": true },
  "x-shader/x-vertex": { "compressible": true }
};
var mimeDb;
var hasRequiredMimeDb;
function requireMimeDb() {
  if (hasRequiredMimeDb) return mimeDb;
  hasRequiredMimeDb = 1;
  mimeDb = require$$0$1;
  return mimeDb;
}
var hasRequiredMimeTypes;
function requireMimeTypes() {
  if (hasRequiredMimeTypes) return mimeTypes;
  hasRequiredMimeTypes = 1;
  (function(exports$1) {
    var db = requireMimeDb();
    var extname = require$$1$5.extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports$1.charset = charset;
    exports$1.charsets = { lookup: charset };
    exports$1.contentType = contentType;
    exports$1.extension = extension;
    exports$1.extensions = /* @__PURE__ */ Object.create(null);
    exports$1.lookup = lookup;
    exports$1.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports$1.extensions, exports$1.types);
    function charset(type2) {
      if (!type2 || typeof type2 !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type2);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports$1.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports$1.charset(mime);
        if (charset2) mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type2) {
      if (!type2 || typeof type2 !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type2);
      var exts = match && exports$1.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path) {
      if (!path || typeof path !== "string") {
        return false;
      }
      var extension2 = extname("x." + path).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports$1.types[extension2] || false;
    }
    function populateMaps(extensions, types2) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type2) {
        var mime = db[type2];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type2] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types2[extension2]) {
            var from = preference.indexOf(db[types2[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types2[extension2] !== "application/octet-stream" && (from > to || from === to && types2[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types2[extension2] = type2;
        }
      });
    }
  })(mimeTypes);
  return mimeTypes;
}
var caseless = { exports: {} };
var hasRequiredCaseless;
function requireCaseless() {
  if (hasRequiredCaseless) return caseless.exports;
  hasRequiredCaseless = 1;
  function Caseless(dict) {
    this.dict = dict || {};
  }
  Caseless.prototype.set = function(name, value, clobber) {
    if (typeof name === "object") {
      for (var i in name) {
        this.set(i, name[i], value);
      }
    } else {
      if (typeof clobber === "undefined") clobber = true;
      var has = this.has(name);
      if (!clobber && has) this.dict[has] = this.dict[has] + "," + value;
      else this.dict[has || name] = value;
      return has;
    }
  };
  Caseless.prototype.has = function(name) {
    var keys = Object.keys(this.dict), name = name.toLowerCase();
    for (var i = 0; i < keys.length; i++) {
      if (keys[i].toLowerCase() === name) return keys[i];
    }
    return false;
  };
  Caseless.prototype.get = function(name) {
    name = name.toLowerCase();
    var result, _key;
    var headers = this.dict;
    Object.keys(headers).forEach(function(key2) {
      _key = key2.toLowerCase();
      if (name === _key) result = headers[key2];
    });
    return result;
  };
  Caseless.prototype.swap = function(name) {
    var has = this.has(name);
    if (has === name) return;
    if (!has) throw new Error('There is no header than matches "' + name + '"');
    this.dict[name] = this.dict[has];
    delete this.dict[has];
  };
  Caseless.prototype.del = function(name) {
    var has = this.has(name);
    return delete this.dict[has || name];
  };
  caseless.exports = function(dict) {
    return new Caseless(dict);
  };
  caseless.exports.httpify = function(resp, headers) {
    var c = new Caseless(headers);
    resp.setHeader = function(key2, value, clobber) {
      if (typeof value === "undefined") return;
      return c.set(key2, value, clobber);
    };
    resp.hasHeader = function(key2) {
      return c.has(key2);
    };
    resp.getHeader = function(key2) {
      return c.get(key2);
    };
    resp.removeHeader = function(key2) {
      return c.del(key2);
    };
    resp.headers = c.dict;
    return c;
  };
  return caseless.exports;
}
var foreverAgent;
var hasRequiredForeverAgent;
function requireForeverAgent() {
  if (hasRequiredForeverAgent) return foreverAgent;
  hasRequiredForeverAgent = 1;
  foreverAgent = ForeverAgent;
  ForeverAgent.SSL = ForeverAgentSSL;
  var util2 = require$$0$5, Agent = require$$2$2.Agent, net = require$$0$8, tls = require$$3$3, AgentSSL = require$$4$2.Agent;
  function getConnectionName(host, port) {
    var name = "";
    if (typeof host === "string") {
      name = host + ":" + port;
    } else {
      name = host.host + ":" + host.port + ":" + (host.localAddress ? host.localAddress + ":" : ":");
    }
    return name;
  }
  function ForeverAgent(options) {
    var self2 = this;
    self2.options = options || {};
    self2.requests = {};
    self2.sockets = {};
    self2.freeSockets = {};
    self2.maxSockets = self2.options.maxSockets || Agent.defaultMaxSockets;
    self2.minSockets = self2.options.minSockets || ForeverAgent.defaultMinSockets;
    self2.on("free", function(socket, host, port) {
      var name = getConnectionName(host, port);
      if (self2.requests[name] && self2.requests[name].length) {
        self2.requests[name].shift().onSocket(socket);
      } else if (self2.sockets[name].length < self2.minSockets) {
        if (!self2.freeSockets[name]) self2.freeSockets[name] = [];
        self2.freeSockets[name].push(socket);
        var onIdleError = function() {
          socket.destroy();
        };
        socket._onIdleError = onIdleError;
        socket.on("error", onIdleError);
      } else {
        socket.destroy();
      }
    });
  }
  util2.inherits(ForeverAgent, Agent);
  ForeverAgent.defaultMinSockets = 5;
  ForeverAgent.prototype.createConnection = net.createConnection;
  ForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest;
  ForeverAgent.prototype.addRequest = function(req, host, port) {
    var name = getConnectionName(host, port);
    if (typeof host !== "string") {
      var options = host;
      port = options.port;
      host = options.host;
    }
    if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {
      var idleSocket = this.freeSockets[name].pop();
      idleSocket.removeListener("error", idleSocket._onIdleError);
      delete idleSocket._onIdleError;
      req._reusedSocket = true;
      req.onSocket(idleSocket);
    } else {
      this.addRequestNoreuse(req, host, port);
    }
  };
  ForeverAgent.prototype.removeSocket = function(s, name, host, port) {
    if (this.sockets[name]) {
      var index = this.sockets[name].indexOf(s);
      if (index !== -1) {
        this.sockets[name].splice(index, 1);
      }
    } else if (this.sockets[name] && this.sockets[name].length === 0) {
      delete this.sockets[name];
      delete this.requests[name];
    }
    if (this.freeSockets[name]) {
      var index = this.freeSockets[name].indexOf(s);
      if (index !== -1) {
        this.freeSockets[name].splice(index, 1);
        if (this.freeSockets[name].length === 0) {
          delete this.freeSockets[name];
        }
      }
    }
    if (this.requests[name] && this.requests[name].length) {
      this.createSocket(name, host, port).emit("free");
    }
  };
  function ForeverAgentSSL(options) {
    ForeverAgent.call(this, options);
  }
  util2.inherits(ForeverAgentSSL, ForeverAgent);
  ForeverAgentSSL.prototype.createConnection = createConnectionSSL;
  ForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest;
  function createConnectionSSL(port, host, options) {
    if (typeof port === "object") {
      options = port;
    } else if (typeof host === "object") {
      options = host;
    } else if (typeof options === "object") {
      options = options;
    } else {
      options = {};
    }
    if (typeof port === "number") {
      options.port = port;
    }
    if (typeof host === "string") {
      options.host = host;
    }
    return tls.connect(options);
  }
  return foreverAgent;
}
var delayed_stream;
var hasRequiredDelayed_stream;
function requireDelayed_stream() {
  if (hasRequiredDelayed_stream) return delayed_stream;
  hasRequiredDelayed_stream = 1;
  var Stream = require$$1$2.Stream;
  var util2 = require$$0$5;
  delayed_stream = DelayedStream;
  function DelayedStream() {
    this.source = null;
    this.dataSize = 0;
    this.maxDataSize = 1024 * 1024;
    this.pauseStream = true;
    this._maxDataSizeExceeded = false;
    this._released = false;
    this._bufferedEvents = [];
  }
  util2.inherits(DelayedStream, Stream);
  DelayedStream.create = function(source, options) {
    var delayedStream = new this();
    options = options || {};
    for (var option in options) {
      delayedStream[option] = options[option];
    }
    delayedStream.source = source;
    var realEmit = source.emit;
    source.emit = function() {
      delayedStream._handleEmit(arguments);
      return realEmit.apply(source, arguments);
    };
    source.on("error", function() {
    });
    if (delayedStream.pauseStream) {
      source.pause();
    }
    return delayedStream;
  };
  Object.defineProperty(DelayedStream.prototype, "readable", {
    configurable: true,
    enumerable: true,
    get: function() {
      return this.source.readable;
    }
  });
  DelayedStream.prototype.setEncoding = function() {
    return this.source.setEncoding.apply(this.source, arguments);
  };
  DelayedStream.prototype.resume = function() {
    if (!this._released) {
      this.release();
    }
    this.source.resume();
  };
  DelayedStream.prototype.pause = function() {
    this.source.pause();
  };
  DelayedStream.prototype.release = function() {
    this._released = true;
    this._bufferedEvents.forEach((function(args) {
      this.emit.apply(this, args);
    }).bind(this));
    this._bufferedEvents = [];
  };
  DelayedStream.prototype.pipe = function() {
    var r = Stream.prototype.pipe.apply(this, arguments);
    this.resume();
    return r;
  };
  DelayedStream.prototype._handleEmit = function(args) {
    if (this._released) {
      this.emit.apply(this, args);
      return;
    }
    if (args[0] === "data") {
      this.dataSize += args[1].length;
      this._checkIfMaxDataSizeExceeded();
    }
    this._bufferedEvents.push(args);
  };
  DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
    if (this._maxDataSizeExceeded) {
      return;
    }
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    this._maxDataSizeExceeded = true;
    var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this.emit("error", new Error(message));
  };
  return delayed_stream;
}
var combined_stream;
var hasRequiredCombined_stream;
function requireCombined_stream() {
  if (hasRequiredCombined_stream) return combined_stream;
  hasRequiredCombined_stream = 1;
  var util2 = require$$0$5;
  var Stream = require$$1$2.Stream;
  var DelayedStream = requireDelayed_stream();
  combined_stream = CombinedStream;
  function CombinedStream() {
    this.writable = false;
    this.readable = true;
    this.dataSize = 0;
    this.maxDataSize = 2 * 1024 * 1024;
    this.pauseStreams = true;
    this._released = false;
    this._streams = [];
    this._currentStream = null;
    this._insideLoop = false;
    this._pendingNext = false;
  }
  util2.inherits(CombinedStream, Stream);
  CombinedStream.create = function(options) {
    var combinedStream = new this();
    options = options || {};
    for (var option in options) {
      combinedStream[option] = options[option];
    }
    return combinedStream;
  };
  CombinedStream.isStreamLike = function(stream) {
    return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
  };
  CombinedStream.prototype.append = function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      if (!(stream instanceof DelayedStream)) {
        var newStream = DelayedStream.create(stream, {
          maxDataSize: Infinity,
          pauseStream: this.pauseStreams
        });
        stream.on("data", this._checkDataSize.bind(this));
        stream = newStream;
      }
      this._handleErrors(stream);
      if (this.pauseStreams) {
        stream.pause();
      }
    }
    this._streams.push(stream);
    return this;
  };
  CombinedStream.prototype.pipe = function(dest, options) {
    Stream.prototype.pipe.call(this, dest, options);
    this.resume();
    return dest;
  };
  CombinedStream.prototype._getNext = function() {
    this._currentStream = null;
    if (this._insideLoop) {
      this._pendingNext = true;
      return;
    }
    this._insideLoop = true;
    try {
      do {
        this._pendingNext = false;
        this._realGetNext();
      } while (this._pendingNext);
    } finally {
      this._insideLoop = false;
    }
  };
  CombinedStream.prototype._realGetNext = function() {
    var stream = this._streams.shift();
    if (typeof stream == "undefined") {
      this.end();
      return;
    }
    if (typeof stream !== "function") {
      this._pipeNext(stream);
      return;
    }
    var getStream = stream;
    getStream((function(stream2) {
      var isStreamLike = CombinedStream.isStreamLike(stream2);
      if (isStreamLike) {
        stream2.on("data", this._checkDataSize.bind(this));
        this._handleErrors(stream2);
      }
      this._pipeNext(stream2);
    }).bind(this));
  };
  CombinedStream.prototype._pipeNext = function(stream) {
    this._currentStream = stream;
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on("end", this._getNext.bind(this));
      stream.pipe(this, { end: false });
      return;
    }
    var value = stream;
    this.write(value);
    this._getNext();
  };
  CombinedStream.prototype._handleErrors = function(stream) {
    var self2 = this;
    stream.on("error", function(err) {
      self2._emitError(err);
    });
  };
  CombinedStream.prototype.write = function(data2) {
    this.emit("data", data2);
  };
  CombinedStream.prototype.pause = function() {
    if (!this.pauseStreams) {
      return;
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function") this._currentStream.pause();
    this.emit("pause");
  };
  CombinedStream.prototype.resume = function() {
    if (!this._released) {
      this._released = true;
      this.writable = true;
      this._getNext();
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function") this._currentStream.resume();
    this.emit("resume");
  };
  CombinedStream.prototype.end = function() {
    this._reset();
    this.emit("end");
  };
  CombinedStream.prototype.destroy = function() {
    this._reset();
    this.emit("close");
  };
  CombinedStream.prototype._reset = function() {
    this.writable = false;
    this._streams = [];
    this._currentStream = null;
  };
  CombinedStream.prototype._checkDataSize = function() {
    this._updateDataSize();
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this._emitError(new Error(message));
  };
  CombinedStream.prototype._updateDataSize = function() {
    this.dataSize = 0;
    var self2 = this;
    this._streams.forEach(function(stream) {
      if (!stream.dataSize) {
        return;
      }
      self2.dataSize += stream.dataSize;
    });
    if (this._currentStream && this._currentStream.dataSize) {
      this.dataSize += this._currentStream.dataSize;
    }
  };
  CombinedStream.prototype._emitError = function(err) {
    this._reset();
    this.emit("error", err);
  };
  return combined_stream;
}
var defer_1;
var hasRequiredDefer;
function requireDefer() {
  if (hasRequiredDefer) return defer_1;
  hasRequiredDefer = 1;
  defer_1 = defer;
  function defer(fn) {
    var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
    if (nextTick) {
      nextTick(fn);
    } else {
      setTimeout(fn, 0);
    }
  }
  return defer_1;
}
var async_1;
var hasRequiredAsync$1;
function requireAsync$1() {
  if (hasRequiredAsync$1) return async_1;
  hasRequiredAsync$1 = 1;
  var defer = requireDefer();
  async_1 = async2;
  function async2(callback) {
    var isAsync = false;
    defer(function() {
      isAsync = true;
    });
    return function async_callback(err, result) {
      if (isAsync) {
        callback(err, result);
      } else {
        defer(function nextTick_callback() {
          callback(err, result);
        });
      }
    };
  }
  return async_1;
}
var abort_1;
var hasRequiredAbort;
function requireAbort() {
  if (hasRequiredAbort) return abort_1;
  hasRequiredAbort = 1;
  abort_1 = abort;
  function abort(state) {
    Object.keys(state.jobs).forEach(clean.bind(state));
    state.jobs = {};
  }
  function clean(key2) {
    if (typeof this.jobs[key2] == "function") {
      this.jobs[key2]();
    }
  }
  return abort_1;
}
var iterate_1;
var hasRequiredIterate;
function requireIterate() {
  if (hasRequiredIterate) return iterate_1;
  hasRequiredIterate = 1;
  var async2 = requireAsync$1(), abort = requireAbort();
  iterate_1 = iterate;
  function iterate(list, iterator, state, callback) {
    var key2 = state["keyedList"] ? state["keyedList"][state.index] : state.index;
    state.jobs[key2] = runJob(iterator, key2, list[key2], function(error2, output) {
      if (!(key2 in state.jobs)) {
        return;
      }
      delete state.jobs[key2];
      if (error2) {
        abort(state);
      } else {
        state.results[key2] = output;
      }
      callback(error2, state.results);
    });
  }
  function runJob(iterator, key2, item, callback) {
    var aborter;
    if (iterator.length == 2) {
      aborter = iterator(item, async2(callback));
    } else {
      aborter = iterator(item, key2, async2(callback));
    }
    return aborter;
  }
  return iterate_1;
}
var state_1;
var hasRequiredState;
function requireState() {
  if (hasRequiredState) return state_1;
  hasRequiredState = 1;
  state_1 = state;
  function state(list, sortMethod) {
    var isNamedList = !Array.isArray(list), initState = {
      index: 0,
      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
      jobs: {},
      results: isNamedList ? {} : [],
      size: isNamedList ? Object.keys(list).length : list.length
    };
    if (sortMethod) {
      initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
        return sortMethod(list[a], list[b]);
      });
    }
    return initState;
  }
  return state_1;
}
var terminator_1;
var hasRequiredTerminator;
function requireTerminator() {
  if (hasRequiredTerminator) return terminator_1;
  hasRequiredTerminator = 1;
  var abort = requireAbort(), async2 = requireAsync$1();
  terminator_1 = terminator;
  function terminator(callback) {
    if (!Object.keys(this.jobs).length) {
      return;
    }
    this.index = this.size;
    abort(this);
    async2(callback)(null, this.results);
  }
  return terminator_1;
}
var parallel_1;
var hasRequiredParallel;
function requireParallel() {
  if (hasRequiredParallel) return parallel_1;
  hasRequiredParallel = 1;
  var iterate = requireIterate(), initState = requireState(), terminator = requireTerminator();
  parallel_1 = parallel;
  function parallel(list, iterator, callback) {
    var state = initState(list);
    while (state.index < (state["keyedList"] || list).length) {
      iterate(list, iterator, state, function(error2, result) {
        if (error2) {
          callback(error2, result);
          return;
        }
        if (Object.keys(state.jobs).length === 0) {
          callback(null, state.results);
          return;
        }
      });
      state.index++;
    }
    return terminator.bind(state, callback);
  }
  return parallel_1;
}
var serialOrdered = { exports: {} };
var hasRequiredSerialOrdered;
function requireSerialOrdered() {
  if (hasRequiredSerialOrdered) return serialOrdered.exports;
  hasRequiredSerialOrdered = 1;
  var iterate = requireIterate(), initState = requireState(), terminator = requireTerminator();
  serialOrdered.exports = serialOrdered$1;
  serialOrdered.exports.ascending = ascending;
  serialOrdered.exports.descending = descending;
  function serialOrdered$1(list, iterator, sortMethod, callback) {
    var state = initState(list, sortMethod);
    iterate(list, iterator, state, function iteratorHandler(error2, result) {
      if (error2) {
        callback(error2, result);
        return;
      }
      state.index++;
      if (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, iteratorHandler);
        return;
      }
      callback(null, state.results);
    });
    return terminator.bind(state, callback);
  }
  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }
  function descending(a, b) {
    return -1 * ascending(a, b);
  }
  return serialOrdered.exports;
}
var serial_1;
var hasRequiredSerial;
function requireSerial() {
  if (hasRequiredSerial) return serial_1;
  hasRequiredSerial = 1;
  var serialOrdered2 = requireSerialOrdered();
  serial_1 = serial;
  function serial(list, iterator, callback) {
    return serialOrdered2(list, iterator, null, callback);
  }
  return serial_1;
}
var asynckit;
var hasRequiredAsynckit;
function requireAsynckit() {
  if (hasRequiredAsynckit) return asynckit;
  hasRequiredAsynckit = 1;
  asynckit = {
    parallel: requireParallel(),
    serial: requireSerial(),
    serialOrdered: requireSerialOrdered()
  };
  return asynckit;
}
var populate;
var hasRequiredPopulate;
function requirePopulate() {
  if (hasRequiredPopulate) return populate;
  hasRequiredPopulate = 1;
  populate = function(dst, src) {
    Object.keys(src).forEach(function(prop) {
      dst[prop] = dst[prop] || src[prop];
    });
    return dst;
  };
  return populate;
}
var form_data;
var hasRequiredForm_data;
function requireForm_data() {
  if (hasRequiredForm_data) return form_data;
  hasRequiredForm_data = 1;
  var CombinedStream = requireCombined_stream();
  var util2 = require$$0$5;
  var path = require$$1$5;
  var http = require$$2$2;
  var https = require$$4$2;
  var parseUrl = require$$0$7.parse;
  var fs = require$$0$a;
  var mime = requireMimeTypes();
  var asynckit2 = requireAsynckit();
  var populate2 = requirePopulate();
  form_data = FormData;
  util2.inherits(FormData, CombinedStream);
  function FormData(options) {
    if (!(this instanceof FormData)) {
      return new FormData();
    }
    this._overheadLength = 0;
    this._valueLength = 0;
    this._valuesToMeasure = [];
    CombinedStream.call(this);
    options = options || {};
    for (var option in options) {
      this[option] = options[option];
    }
  }
  FormData.LINE_BREAK = "\r\n";
  FormData.DEFAULT_CONTENT_TYPE = "application/octet-stream";
  FormData.prototype.append = function(field, value, options) {
    options = options || {};
    if (typeof options == "string") {
      options = { filename: options };
    }
    var append = CombinedStream.prototype.append.bind(this);
    if (typeof value == "number") {
      value = "" + value;
    }
    if (util2.isArray(value)) {
      this._error(new Error("Arrays are not supported."));
      return;
    }
    var header = this._multiPartHeader(field, value, options);
    var footer = this._multiPartFooter();
    append(header);
    append(value);
    append(footer);
    this._trackLength(header, value, options);
  };
  FormData.prototype._trackLength = function(header, value, options) {
    var valueLength = 0;
    if (options.knownLength != null) {
      valueLength += +options.knownLength;
    } else if (Buffer.isBuffer(value)) {
      valueLength = value.length;
    } else if (typeof value === "string") {
      valueLength = Buffer.byteLength(value);
    }
    this._valueLength += valueLength;
    this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length;
    if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion"))) {
      return;
    }
    if (!options.knownLength) {
      this._valuesToMeasure.push(value);
    }
  };
  FormData.prototype._lengthRetriever = function(value, callback) {
    if (value.hasOwnProperty("fd")) {
      if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
        callback(null, value.end + 1 - (value.start ? value.start : 0));
      } else {
        fs.stat(value.path, function(err, stat) {
          var fileSize;
          if (err) {
            callback(err);
            return;
          }
          fileSize = stat.size - (value.start ? value.start : 0);
          callback(null, fileSize);
        });
      }
    } else if (value.hasOwnProperty("httpVersion")) {
      callback(null, +value.headers["content-length"]);
    } else if (value.hasOwnProperty("httpModule")) {
      value.on("response", function(response) {
        value.pause();
        callback(null, +response.headers["content-length"]);
      });
      value.resume();
    } else {
      callback("Unknown stream");
    }
  };
  FormData.prototype._multiPartHeader = function(field, value, options) {
    if (typeof options.header == "string") {
      return options.header;
    }
    var contentDisposition = this._getContentDisposition(value, options);
    var contentType = this._getContentType(value, options);
    var contents = "";
    var headers = {
      // add custom disposition as third element or keep it two elements if not
      "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
      // if no content type. allow it to be empty array
      "Content-Type": [].concat(contentType || [])
    };
    if (typeof options.header == "object") {
      populate2(headers, options.header);
    }
    var header;
    for (var prop in headers) {
      if (!headers.hasOwnProperty(prop)) continue;
      header = headers[prop];
      if (header == null) {
        continue;
      }
      if (!Array.isArray(header)) {
        header = [header];
      }
      if (header.length) {
        contents += prop + ": " + header.join("; ") + FormData.LINE_BREAK;
      }
    }
    return "--" + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
  };
  FormData.prototype._getContentDisposition = function(value, options) {
    var filename, contentDisposition;
    if (typeof options.filepath === "string") {
      filename = path.normalize(options.filepath).replace(/\\/g, "/");
    } else if (options.filename || value.name || value.path) {
      filename = path.basename(options.filename || value.name || value.path);
    } else if (value.readable && value.hasOwnProperty("httpVersion")) {
      filename = path.basename(value.client._httpMessage.path);
    }
    if (filename) {
      contentDisposition = 'filename="' + filename + '"';
    }
    return contentDisposition;
  };
  FormData.prototype._getContentType = function(value, options) {
    var contentType = options.contentType;
    if (!contentType && value.name) {
      contentType = mime.lookup(value.name);
    }
    if (!contentType && value.path) {
      contentType = mime.lookup(value.path);
    }
    if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
      contentType = value.headers["content-type"];
    }
    if (!contentType && (options.filepath || options.filename)) {
      contentType = mime.lookup(options.filepath || options.filename);
    }
    if (!contentType && typeof value == "object") {
      contentType = FormData.DEFAULT_CONTENT_TYPE;
    }
    return contentType;
  };
  FormData.prototype._multiPartFooter = function() {
    return (function(next) {
      var footer = FormData.LINE_BREAK;
      var lastPart = this._streams.length === 0;
      if (lastPart) {
        footer += this._lastBoundary();
      }
      next(footer);
    }).bind(this);
  };
  FormData.prototype._lastBoundary = function() {
    return "--" + this.getBoundary() + "--" + FormData.LINE_BREAK;
  };
  FormData.prototype.getHeaders = function(userHeaders) {
    var header;
    var formHeaders = {
      "content-type": "multipart/form-data; boundary=" + this.getBoundary()
    };
    for (header in userHeaders) {
      if (userHeaders.hasOwnProperty(header)) {
        formHeaders[header.toLowerCase()] = userHeaders[header];
      }
    }
    return formHeaders;
  };
  FormData.prototype.getBoundary = function() {
    if (!this._boundary) {
      this._generateBoundary();
    }
    return this._boundary;
  };
  FormData.prototype._generateBoundary = function() {
    var boundary = "--------------------------";
    for (var i = 0; i < 24; i++) {
      boundary += Math.floor(Math.random() * 10).toString(16);
    }
    this._boundary = boundary;
  };
  FormData.prototype.getLengthSync = function() {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this.hasKnownLength()) {
      this._error(new Error("Cannot calculate proper length in synchronous way."));
    }
    return knownLength;
  };
  FormData.prototype.hasKnownLength = function() {
    var hasKnownLength = true;
    if (this._valuesToMeasure.length) {
      hasKnownLength = false;
    }
    return hasKnownLength;
  };
  FormData.prototype.getLength = function(cb) {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this._valuesToMeasure.length) {
      process.nextTick(cb.bind(this, null, knownLength));
      return;
    }
    asynckit2.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
      if (err) {
        cb(err);
        return;
      }
      values.forEach(function(length) {
        knownLength += length;
      });
      cb(null, knownLength);
    });
  };
  FormData.prototype.submit = function(params, cb) {
    var request2, options, defaults = { method: "post" };
    if (typeof params == "string") {
      params = parseUrl(params);
      options = populate2({
        port: params.port,
        path: params.pathname,
        host: params.hostname,
        protocol: params.protocol
      }, defaults);
    } else {
      options = populate2(params, defaults);
      if (!options.port) {
        options.port = options.protocol == "https:" ? 443 : 80;
      }
    }
    options.headers = this.getHeaders(params.headers);
    if (options.protocol == "https:") {
      request2 = https.request(options);
    } else {
      request2 = http.request(options);
    }
    this.getLength((function(err, length) {
      if (err) {
        this._error(err);
        return;
      }
      request2.setHeader("Content-Length", length);
      this.pipe(request2);
      if (cb) {
        request2.on("error", cb);
        request2.on("response", cb.bind(this, null));
      }
    }).bind(this));
    return request2;
  };
  FormData.prototype._error = function(err) {
    if (!this.error) {
      this.error = err;
      this.pause();
      this.emit("error", err);
    }
  };
  FormData.prototype.toString = function() {
    return "[object FormData]";
  };
  return form_data;
}
var isstream = { exports: {} };
var hasRequiredIsstream;
function requireIsstream() {
  if (hasRequiredIsstream) return isstream.exports;
  hasRequiredIsstream = 1;
  var stream = require$$1$2;
  function isStream(obj) {
    return obj instanceof stream.Stream;
  }
  function isReadable(obj) {
    return isStream(obj) && typeof obj._read == "function" && typeof obj._readableState == "object";
  }
  function isWritable(obj) {
    return isStream(obj) && typeof obj._write == "function" && typeof obj._writableState == "object";
  }
  function isDuplex(obj) {
    return isReadable(obj) && isWritable(obj);
  }
  isstream.exports = isStream;
  isstream.exports.isReadable = isReadable;
  isstream.exports.isWritable = isWritable;
  isstream.exports.isDuplex = isDuplex;
  return isstream.exports;
}
var isTypedarray;
var hasRequiredIsTypedarray;
function requireIsTypedarray() {
  if (hasRequiredIsTypedarray) return isTypedarray;
  hasRequiredIsTypedarray = 1;
  isTypedarray = isTypedArray;
  isTypedArray.strict = isStrictTypedArray;
  isTypedArray.loose = isLooseTypedArray;
  var toString = Object.prototype.toString;
  var names = {
    "[object Int8Array]": true,
    "[object Int16Array]": true,
    "[object Int32Array]": true,
    "[object Uint8Array]": true,
    "[object Uint8ClampedArray]": true,
    "[object Uint16Array]": true,
    "[object Uint32Array]": true,
    "[object Float32Array]": true,
    "[object Float64Array]": true
  };
  function isTypedArray(arr) {
    return isStrictTypedArray(arr) || isLooseTypedArray(arr);
  }
  function isStrictTypedArray(arr) {
    return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
  }
  function isLooseTypedArray(arr) {
    return names[toString.call(arr)];
  }
  return isTypedarray;
}
var getProxyFromURI_1;
var hasRequiredGetProxyFromURI;
function requireGetProxyFromURI() {
  if (hasRequiredGetProxyFromURI) return getProxyFromURI_1;
  hasRequiredGetProxyFromURI = 1;
  function formatHostname(hostname) {
    return hostname.replace(/^\.*/, ".").toLowerCase();
  }
  function parseNoProxyZone(zone) {
    zone = zone.trim().toLowerCase();
    var zoneParts = zone.split(":", 2);
    var zoneHost = formatHostname(zoneParts[0]);
    var zonePort = zoneParts[1];
    var hasPort = zone.indexOf(":") > -1;
    return { hostname: zoneHost, port: zonePort, hasPort };
  }
  function uriInNoProxy(uri, noProxy) {
    var port = uri.port || (uri.protocol === "https:" ? "443" : "80");
    var hostname = formatHostname(uri.hostname);
    var noProxyList = noProxy.split(",");
    return noProxyList.map(parseNoProxyZone).some(function(noProxyZone) {
      var isMatchedAt = hostname.indexOf(noProxyZone.hostname);
      var hostnameMatched = isMatchedAt > -1 && isMatchedAt === hostname.length - noProxyZone.hostname.length;
      if (noProxyZone.hasPort) {
        return port === noProxyZone.port && hostnameMatched;
      }
      return hostnameMatched;
    });
  }
  function getProxyFromURI(uri) {
    var noProxy = process.env.NO_PROXY || process.env.no_proxy || "";
    if (noProxy === "*") {
      return null;
    }
    if (noProxy !== "" && uriInNoProxy(uri, noProxy)) {
      return null;
    }
    if (uri.protocol === "http:") {
      return process.env.HTTP_PROXY || process.env.http_proxy || null;
    }
    if (uri.protocol === "https:") {
      return process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy || null;
    }
    return null;
  }
  getProxyFromURI_1 = getProxyFromURI;
  return getProxyFromURI_1;
}
var querystring = {};
var utils$1;
var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$1;
  hasRequiredUtils$1 = 1;
  var has = Object.prototype.hasOwnProperty;
  var hexTable = (function() {
    var array = [];
    for (var i = 0; i < 256; ++i) {
      array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
    }
    return array;
  })();
  var compactQueue = function compactQueue2(queue) {
    var obj;
    while (queue.length) {
      var item = queue.pop();
      obj = item.obj[item.prop];
      if (Array.isArray(obj)) {
        var compacted = [];
        for (var j = 0; j < obj.length; ++j) {
          if (typeof obj[j] !== "undefined") {
            compacted.push(obj[j]);
          }
        }
        item.obj[item.prop] = compacted;
      }
    }
    return obj;
  };
  var arrayToObject = function arrayToObject2(source, options) {
    var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
      if (typeof source[i] !== "undefined") {
        obj[i] = source[i];
      }
    }
    return obj;
  };
  var merge = function merge2(target, source, options) {
    if (!source) {
      return target;
    }
    if (typeof source !== "object") {
      if (Array.isArray(target)) {
        target.push(source);
      } else if (target && typeof target === "object") {
        if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
          target[source] = true;
        }
      } else {
        return [target, source];
      }
      return target;
    }
    if (!target || typeof target !== "object") {
      return [target].concat(source);
    }
    var mergeTarget = target;
    if (Array.isArray(target) && !Array.isArray(source)) {
      mergeTarget = arrayToObject(target, options);
    }
    if (Array.isArray(target) && Array.isArray(source)) {
      source.forEach(function(item, i) {
        if (has.call(target, i)) {
          var targetItem = target[i];
          if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
            target[i] = merge2(targetItem, item, options);
          } else {
            target.push(item);
          }
        } else {
          target[i] = item;
        }
      });
      return target;
    }
    return Object.keys(source).reduce(function(acc, key2) {
      var value = source[key2];
      if (has.call(acc, key2)) {
        acc[key2] = merge2(acc[key2], value, options);
      } else {
        acc[key2] = value;
      }
      return acc;
    }, mergeTarget);
  };
  var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function(acc, key2) {
      acc[key2] = source[key2];
      return acc;
    }, target);
  };
  var decode = function(str) {
    try {
      return decodeURIComponent(str.replace(/\+/g, " "));
    } catch (e) {
      return str;
    }
  };
  var encode = function encode2(str) {
    if (str.length === 0) {
      return str;
    }
    var string = typeof str === "string" ? str : String(str);
    var out = "";
    for (var i = 0; i < string.length; ++i) {
      var c = string.charCodeAt(i);
      if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122) {
        out += string.charAt(i);
        continue;
      }
      if (c < 128) {
        out = out + hexTable[c];
        continue;
      }
      if (c < 2048) {
        out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
        continue;
      }
      if (c < 55296 || c >= 57344) {
        out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
        continue;
      }
      i += 1;
      c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i) & 1023);
      out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
    }
    return out;
  };
  var compact = function compact2(value) {
    var queue = [{ obj: { o: value }, prop: "o" }];
    var refs = [];
    for (var i = 0; i < queue.length; ++i) {
      var item = queue[i];
      var obj = item.obj[item.prop];
      var keys = Object.keys(obj);
      for (var j = 0; j < keys.length; ++j) {
        var key2 = keys[j];
        var val = obj[key2];
        if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
          queue.push({ obj, prop: key2 });
          refs.push(val);
        }
      }
    }
    return compactQueue(queue);
  };
  var isRegExp = function isRegExp2(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
  };
  var isBuffer = function isBuffer2(obj) {
    if (obj === null || typeof obj === "undefined") {
      return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
  };
  utils$1 = {
    arrayToObject,
    assign,
    compact,
    decode,
    encode,
    isBuffer,
    isRegExp,
    merge
  };
  return utils$1;
}
var formats;
var hasRequiredFormats$1;
function requireFormats$1() {
  if (hasRequiredFormats$1) return formats;
  hasRequiredFormats$1 = 1;
  var replace = String.prototype.replace;
  var percentTwenties = /%20/g;
  formats = {
    "default": "RFC3986",
    formatters: {
      RFC1738: function(value) {
        return replace.call(value, percentTwenties, "+");
      },
      RFC3986: function(value) {
        return String(value);
      }
    },
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
  };
  return formats;
}
var stringify_1;
var hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify) return stringify_1;
  hasRequiredStringify = 1;
  var utils2 = requireUtils$1();
  var formats2 = requireFormats$1();
  var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
      return prefix + "[]";
    },
    indices: function indices(prefix, key2) {
      return prefix + "[" + key2 + "]";
    },
    repeat: function repeat(prefix) {
      return prefix;
    }
  };
  var isArray = Array.isArray;
  var push = Array.prototype.push;
  var pushToArray = function(arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
  };
  var toISO = Date.prototype.toISOString;
  var defaults = {
    delimiter: "&",
    encode: true,
    encoder: utils2.encode,
    encodeValuesOnly: false,
    serializeDate: function serializeDate(date) {
      return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
  };
  var stringify2 = function stringify3(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder2, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly) {
    var obj = object;
    if (typeof filter === "function") {
      obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
      obj = serializeDate(obj);
    }
    if (obj === null) {
      if (strictNullHandling) {
        return encoder2 && !encodeValuesOnly ? encoder2(prefix, defaults.encoder) : prefix;
      }
      obj = "";
    }
    if (typeof obj === "string" || typeof obj === "number" || typeof obj === "boolean" || utils2.isBuffer(obj)) {
      if (encoder2) {
        var keyValue = encodeValuesOnly ? prefix : encoder2(prefix, defaults.encoder);
        return [formatter(keyValue) + "=" + formatter(encoder2(obj, defaults.encoder))];
      }
      return [formatter(prefix) + "=" + formatter(String(obj))];
    }
    var values = [];
    if (typeof obj === "undefined") {
      return values;
    }
    var objKeys;
    if (isArray(filter)) {
      objKeys = filter;
    } else {
      var keys = Object.keys(obj);
      objKeys = sort ? keys.sort(sort) : keys;
    }
    for (var i = 0; i < objKeys.length; ++i) {
      var key2 = objKeys[i];
      if (skipNulls && obj[key2] === null) {
        continue;
      }
      if (isArray(obj)) {
        pushToArray(values, stringify3(
          obj[key2],
          generateArrayPrefix(prefix, key2),
          generateArrayPrefix,
          strictNullHandling,
          skipNulls,
          encoder2,
          filter,
          sort,
          allowDots,
          serializeDate,
          formatter,
          encodeValuesOnly
        ));
      } else {
        pushToArray(values, stringify3(
          obj[key2],
          prefix + (allowDots ? "." + key2 : "[" + key2 + "]"),
          generateArrayPrefix,
          strictNullHandling,
          skipNulls,
          encoder2,
          filter,
          sort,
          allowDots,
          serializeDate,
          formatter,
          encodeValuesOnly
        ));
      }
    }
    return values;
  };
  stringify_1 = function(object, opts) {
    var obj = object;
    var options = opts ? utils2.assign({}, opts) : {};
    if (options.encoder !== null && typeof options.encoder !== "undefined" && typeof options.encoder !== "function") {
      throw new TypeError("Encoder has to be a function.");
    }
    var delimiter = typeof options.delimiter === "undefined" ? defaults.delimiter : options.delimiter;
    var strictNullHandling = typeof options.strictNullHandling === "boolean" ? options.strictNullHandling : defaults.strictNullHandling;
    var skipNulls = typeof options.skipNulls === "boolean" ? options.skipNulls : defaults.skipNulls;
    var encode = typeof options.encode === "boolean" ? options.encode : defaults.encode;
    var encoder2 = typeof options.encoder === "function" ? options.encoder : defaults.encoder;
    var sort = typeof options.sort === "function" ? options.sort : null;
    var allowDots = typeof options.allowDots === "undefined" ? false : options.allowDots;
    var serializeDate = typeof options.serializeDate === "function" ? options.serializeDate : defaults.serializeDate;
    var encodeValuesOnly = typeof options.encodeValuesOnly === "boolean" ? options.encodeValuesOnly : defaults.encodeValuesOnly;
    if (typeof options.format === "undefined") {
      options.format = formats2["default"];
    } else if (!Object.prototype.hasOwnProperty.call(formats2.formatters, options.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    var formatter = formats2.formatters[options.format];
    var objKeys;
    var filter;
    if (typeof options.filter === "function") {
      filter = options.filter;
      obj = filter("", obj);
    } else if (isArray(options.filter)) {
      filter = options.filter;
      objKeys = filter;
    }
    var keys = [];
    if (typeof obj !== "object" || obj === null) {
      return "";
    }
    var arrayFormat;
    if (options.arrayFormat in arrayPrefixGenerators) {
      arrayFormat = options.arrayFormat;
    } else if ("indices" in options) {
      arrayFormat = options.indices ? "indices" : "repeat";
    } else {
      arrayFormat = "indices";
    }
    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
    if (!objKeys) {
      objKeys = Object.keys(obj);
    }
    if (sort) {
      objKeys.sort(sort);
    }
    for (var i = 0; i < objKeys.length; ++i) {
      var key2 = objKeys[i];
      if (skipNulls && obj[key2] === null) {
        continue;
      }
      pushToArray(keys, stringify2(
        obj[key2],
        key2,
        generateArrayPrefix,
        strictNullHandling,
        skipNulls,
        encode ? encoder2 : null,
        filter,
        sort,
        allowDots,
        serializeDate,
        formatter,
        encodeValuesOnly
      ));
    }
    var joined = keys.join(delimiter);
    var prefix = options.addQueryPrefix === true ? "?" : "";
    return joined.length > 0 ? prefix + joined : "";
  };
  return stringify_1;
}
var parse;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse;
  hasRequiredParse = 1;
  var utils2 = requireUtils$1();
  var has = Object.prototype.hasOwnProperty;
  var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    decoder: utils2.decode,
    delimiter: "&",
    depth: 5,
    parameterLimit: 1e3,
    plainObjects: false,
    strictNullHandling: false
  };
  var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
    var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    for (var i = 0; i < parts.length; ++i) {
      var part = parts[i];
      var bracketEqualsPos = part.indexOf("]=");
      var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
      var key2, val;
      if (pos === -1) {
        key2 = options.decoder(part, defaults.decoder);
        val = options.strictNullHandling ? null : "";
      } else {
        key2 = options.decoder(part.slice(0, pos), defaults.decoder);
        val = options.decoder(part.slice(pos + 1), defaults.decoder);
      }
      if (has.call(obj, key2)) {
        obj[key2] = [].concat(obj[key2]).concat(val);
      } else {
        obj[key2] = val;
      }
    }
    return obj;
  };
  var parseObject = function(chain, val, options) {
    var leaf = val;
    for (var i = chain.length - 1; i >= 0; --i) {
      var obj;
      var root = chain[i];
      if (root === "[]" && options.parseArrays) {
        obj = [].concat(leaf);
      } else {
        obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
        var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
        var index = parseInt(cleanRoot, 10);
        if (!options.parseArrays && cleanRoot === "") {
          obj = { 0: leaf };
        } else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
          obj = [];
          obj[index] = leaf;
        } else if (cleanRoot !== "__proto__") {
          obj[cleanRoot] = leaf;
        }
      }
      leaf = obj;
    }
    return leaf;
  };
  var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
    if (!givenKey) {
      return;
    }
    var key2 = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;
    var segment = brackets.exec(key2);
    var parent = segment ? key2.slice(0, segment.index) : key2;
    var keys = [];
    if (parent) {
      if (!options.plainObjects && has.call(Object.prototype, parent)) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(parent);
    }
    var i = 0;
    while ((segment = child.exec(key2)) !== null && i < options.depth) {
      i += 1;
      if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(segment[1]);
    }
    if (segment) {
      keys.push("[" + key2.slice(segment.index) + "]");
    }
    return parseObject(keys, val, options);
  };
  parse = function(str, opts) {
    var options = opts ? utils2.assign({}, opts) : {};
    if (options.decoder !== null && options.decoder !== void 0 && typeof options.decoder !== "function") {
      throw new TypeError("Decoder has to be a function.");
    }
    options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;
    options.delimiter = typeof options.delimiter === "string" || utils2.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
    options.depth = typeof options.depth === "number" ? options.depth : defaults.depth;
    options.arrayLimit = typeof options.arrayLimit === "number" ? options.arrayLimit : defaults.arrayLimit;
    options.parseArrays = options.parseArrays !== false;
    options.decoder = typeof options.decoder === "function" ? options.decoder : defaults.decoder;
    options.allowDots = typeof options.allowDots === "boolean" ? options.allowDots : defaults.allowDots;
    options.plainObjects = typeof options.plainObjects === "boolean" ? options.plainObjects : defaults.plainObjects;
    options.allowPrototypes = typeof options.allowPrototypes === "boolean" ? options.allowPrototypes : defaults.allowPrototypes;
    options.parameterLimit = typeof options.parameterLimit === "number" ? options.parameterLimit : defaults.parameterLimit;
    options.strictNullHandling = typeof options.strictNullHandling === "boolean" ? options.strictNullHandling : defaults.strictNullHandling;
    if (str === "" || str === null || typeof str === "undefined") {
      return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
    }
    var tempObj = typeof str === "string" ? parseValues(str, options) : str;
    var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
      var key2 = keys[i];
      var newObj = parseKeys(key2, tempObj[key2], options);
      obj = utils2.merge(obj, newObj, options);
    }
    return utils2.compact(obj);
  };
  return parse;
}
var lib$1;
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib$1;
  hasRequiredLib$1 = 1;
  var stringify2 = requireStringify();
  var parse2 = requireParse();
  var formats2 = requireFormats$1();
  lib$1 = {
    formats: formats2,
    parse: parse2,
    stringify: stringify2
  };
  return lib$1;
}
var hasRequiredQuerystring;
function requireQuerystring() {
  if (hasRequiredQuerystring) return querystring;
  hasRequiredQuerystring = 1;
  var qs = requireLib$1();
  var querystring$1 = require$$1$4;
  function Querystring(request2) {
    this.request = request2;
    this.lib = null;
    this.useQuerystring = null;
    this.parseOptions = null;
    this.stringifyOptions = null;
  }
  Querystring.prototype.init = function(options) {
    if (this.lib) {
      return;
    }
    this.useQuerystring = options.useQuerystring;
    this.lib = this.useQuerystring ? querystring$1 : qs;
    this.parseOptions = options.qsParseOptions || {};
    this.stringifyOptions = options.qsStringifyOptions || {};
  };
  Querystring.prototype.stringify = function(obj) {
    return this.useQuerystring ? this.rfc3986(this.lib.stringify(
      obj,
      this.stringifyOptions.sep || null,
      this.stringifyOptions.eq || null,
      this.stringifyOptions
    )) : this.lib.stringify(obj, this.stringifyOptions);
  };
  Querystring.prototype.parse = function(str) {
    return this.useQuerystring ? this.lib.parse(
      str,
      this.parseOptions.sep || null,
      this.parseOptions.eq || null,
      this.parseOptions
    ) : this.lib.parse(str, this.parseOptions);
  };
  Querystring.prototype.rfc3986 = function(str) {
    return str.replace(/[!'()*]/g, function(c) {
      return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
  };
  Querystring.prototype.unescape = querystring$1.unescape;
  querystring.Querystring = Querystring;
  return querystring;
}
var har = {};
var promise = {};
var uri_all$1 = { exports: {} };
var uri_all = uri_all$1.exports;
var hasRequiredUri_all;
function requireUri_all() {
  if (hasRequiredUri_all) return uri_all$1.exports;
  hasRequiredUri_all = 1;
  (function(module, exports$1) {
    (function(global2, factory) {
      factory(exports$1);
    })(uri_all, (function(exports$12) {
      function merge() {
        for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
          sets[_key] = arguments[_key];
        }
        if (sets.length > 1) {
          sets[0] = sets[0].slice(0, -1);
          var xl = sets.length - 1;
          for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
          }
          sets[xl] = sets[xl].slice(1);
          return sets.join("");
        } else {
          return sets[0];
        }
      }
      function subexp(str) {
        return "(?:" + str + ")";
      }
      function typeOf(o) {
        return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
      }
      function toUpperCase(str) {
        return str.toUpperCase();
      }
      function toArray(obj) {
        return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
      }
      function assign(target, source) {
        var obj = target;
        if (source) {
          for (var key2 in source) {
            obj[key2] = source[key2];
          }
        }
        return obj;
      }
      function buildExps(isIRI) {
        var ALPHA$$ = "[A-Za-z]", DIGIT$$ = "[0-9]", HEXDIG$$2 = merge(DIGIT$$, "[A-Fa-f]"), PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$);
        subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*");
        subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*");
        var DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+");
        subexp("[vV]" + HEXDIG$$2 + "+\\." + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+");
        subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$)) + "*");
        var PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]"));
        subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+");
        subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*");
        return {
          NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
          NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
          NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
          ESCAPE: new RegExp(merge("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
          OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
          PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
          IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
          IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
          //RFC 6874, with relaxed parsing rules
        };
      }
      var URI_PROTOCOL = buildExps(false);
      var IRI_PROTOCOL = buildExps(true);
      var slicedToArray = /* @__PURE__ */ (function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }
          return _arr;
        }
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      })();
      var toConsumableArray = function(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
          return arr2;
        } else {
          return Array.from(arr);
        }
      };
      var maxInt = 2147483647;
      var base = 36;
      var tMin = 1;
      var tMax = 26;
      var skew = 38;
      var damp = 700;
      var initialBias = 72;
      var initialN = 128;
      var delimiter = "-";
      var regexPunycode = /^xn--/;
      var regexNonASCII = /[^\0-\x7E]/;
      var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
      var errors2 = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      };
      var baseMinusTMin = base - tMin;
      var floor = Math.floor;
      var stringFromCharCode = String.fromCharCode;
      function error$1(type2) {
        throw new RangeError(errors2[type2]);
      }
      function map(array, fn) {
        var result = [];
        var length = array.length;
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        while (counter < length) {
          var value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            var extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      var ucs2encode = function ucs2encode2(array) {
        return String.fromCodePoint.apply(String, toConsumableArray(array));
      };
      var basicToDigit = function basicToDigit2(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      };
      var digitToBasic = function digitToBasic2(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      };
      var adapt = function adapt2(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (
          ;
          /* no initialization */
          delta > baseMinusTMin * tMax >> 1;
          k += base
        ) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      };
      var decode = function decode2(input) {
        var output = [];
        var inputLength = input.length;
        var i = 0;
        var n = initialN;
        var bias = initialBias;
        var basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (var j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error$1("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          var oldi = i;
          for (
            var w = 1, k = base;
            ;
            /* no condition */
            k += base
          ) {
            if (index >= inputLength) {
              error$1("invalid-input");
            }
            var digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error$1("overflow");
            }
            i += digit * w;
            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            var baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error$1("overflow");
            }
            w *= baseMinusT;
          }
          var out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error$1("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return String.fromCodePoint.apply(String, output);
      };
      var encode = function encode2(input) {
        var output = [];
        input = ucs2decode(input);
        var inputLength = input.length;
        var n = initialN;
        var delta = 0;
        var bias = initialBias;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _currentValue2 = _step.value;
            if (_currentValue2 < 128) {
              output.push(stringFromCharCode(_currentValue2));
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        var basicLength = output.length;
        var handledCPCount = basicLength;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          var m = maxInt;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var currentValue = _step2.value;
              if (currentValue >= n && currentValue < m) {
                m = currentValue;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          var handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error$1("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _currentValue = _step3.value;
              if (_currentValue < n && ++delta > maxInt) {
                error$1("overflow");
              }
              if (_currentValue == n) {
                var q2 = delta;
                for (
                  var k = base;
                  ;
                  /* no condition */
                  k += base
                ) {
                  var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q2 < t) {
                    break;
                  }
                  var qMinusT = q2 - t;
                  var baseMinusT = base - t;
                  output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                  q2 = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q2, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      };
      var toUnicode = function toUnicode2(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      };
      var toASCII = function toASCII2(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      };
      var punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "2.1.0",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      var SCHEMES = {};
      function pctEncChar(chr) {
        var c = chr.charCodeAt(0);
        var e = void 0;
        if (c < 16) e = "%0" + c.toString(16).toUpperCase();
        else if (c < 128) e = "%" + c.toString(16).toUpperCase();
        else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        return e;
      }
      function pctDecChars(str) {
        var newStr = "";
        var i = 0;
        var il = str.length;
        while (i < il) {
          var c = parseInt(str.substr(i + 1, 2), 16);
          if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
          } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
              var c2 = parseInt(str.substr(i + 4, 2), 16);
              newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
              newStr += str.substr(i, 6);
            }
            i += 6;
          } else if (c >= 224) {
            if (il - i >= 9) {
              var _c = parseInt(str.substr(i + 4, 2), 16);
              var c3 = parseInt(str.substr(i + 7, 2), 16);
              newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
              newStr += str.substr(i, 9);
            }
            i += 9;
          } else {
            newStr += str.substr(i, 3);
            i += 3;
          }
        }
        return newStr;
      }
      function _normalizeComponentEncoding(components, protocol) {
        function decodeUnreserved2(str) {
          var decStr = pctDecChars(str);
          return !decStr.match(protocol.UNRESERVED) ? str : decStr;
        }
        if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
        if (components.userinfo !== void 0) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.host !== void 0) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.path !== void 0) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.query !== void 0) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.fragment !== void 0) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        return components;
      }
      function _stripLeadingZeros(str) {
        return str.replace(/^0*(.*)/, "$1") || "0";
      }
      function _normalizeIPv4(host, protocol) {
        var matches = host.match(protocol.IPV4ADDRESS) || [];
        var _matches = slicedToArray(matches, 2), address = _matches[1];
        if (address) {
          return address.split(".").map(_stripLeadingZeros).join(".");
        } else {
          return host;
        }
      }
      function _normalizeIPv6(host, protocol) {
        var matches = host.match(protocol.IPV6ADDRESS) || [];
        var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
        if (address) {
          var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
          var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
          var lastFields = last.split(":").map(_stripLeadingZeros);
          var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
          var fieldCount = isLastFieldIPv4Address ? 7 : 8;
          var lastFieldsStart = lastFields.length - fieldCount;
          var fields = Array(fieldCount);
          for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
          }
          if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
          }
          var allZeroFields = fields.reduce(function(acc, field, index) {
            if (!field || field === "0") {
              var lastLongest = acc[acc.length - 1];
              if (lastLongest && lastLongest.index + lastLongest.length === index) {
                lastLongest.length++;
              } else {
                acc.push({ index, length: 1 });
              }
            }
            return acc;
          }, []);
          var longestZeroFields = allZeroFields.sort(function(a, b) {
            return b.length - a.length;
          })[0];
          var newHost = void 0;
          if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
          } else {
            newHost = fields.join(":");
          }
          if (zone) {
            newHost += "%" + zone;
          }
          return newHost;
        } else {
          return host;
        }
      }
      var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
      var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
      function parse2(uriString) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var components = {};
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
        var matches = uriString.match(URI_PARSE);
        if (matches) {
          if (NO_MATCH_IS_UNDEFINED) {
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            if (isNaN(components.port)) {
              components.port = matches[5];
            }
          } else {
            components.scheme = matches[1] || void 0;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
            if (isNaN(components.port)) {
              components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
            }
          }
          if (components.host) {
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
          }
          if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
            components.reference = "same-document";
          } else if (components.scheme === void 0) {
            components.reference = "relative";
          } else if (components.fragment === void 0) {
            components.reference = "absolute";
          } else {
            components.reference = "uri";
          }
          if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
          }
          var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
          if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
              try {
                components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
              } catch (e) {
                components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
              }
            }
            _normalizeComponentEncoding(components, URI_PROTOCOL);
          } else {
            _normalizeComponentEncoding(components, protocol);
          }
          if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
          }
        } else {
          components.error = components.error || "URI can not be parsed.";
        }
        return components;
      }
      function _recomposeAuthority(components, options) {
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        if (components.userinfo !== void 0) {
          uriTokens.push(components.userinfo);
          uriTokens.push("@");
        }
        if (components.host !== void 0) {
          uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
          }));
        }
        if (typeof components.port === "number" || typeof components.port === "string") {
          uriTokens.push(":");
          uriTokens.push(String(components.port));
        }
        return uriTokens.length ? uriTokens.join("") : void 0;
      }
      var RDS1 = /^\.\.?\//;
      var RDS2 = /^\/\.(\/|$)/;
      var RDS3 = /^\/\.\.(\/|$)/;
      var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
      function removeDotSegments(input) {
        var output = [];
        while (input.length) {
          if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
          } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
          } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
          } else if (input === "." || input === "..") {
            input = "";
          } else {
            var im = input.match(RDS5);
            if (im) {
              var s = im[0];
              input = input.slice(s.length);
              output.push(s);
            } else {
              throw new Error("Unexpected dot segment condition");
            }
          }
        }
        return output.join("");
      }
      function serialize(components) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
        if (components.host) {
          if (protocol.IPV6ADDRESS.test(components.host)) ;
          else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
            try {
              components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
          }
        }
        _normalizeComponentEncoding(components, protocol);
        if (options.reference !== "suffix" && components.scheme) {
          uriTokens.push(components.scheme);
          uriTokens.push(":");
        }
        var authority = _recomposeAuthority(components, options);
        if (authority !== void 0) {
          if (options.reference !== "suffix") {
            uriTokens.push("//");
          }
          uriTokens.push(authority);
          if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
          }
        }
        if (components.path !== void 0) {
          var s = components.path;
          if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
          }
          if (authority === void 0) {
            s = s.replace(/^\/\//, "/%2F");
          }
          uriTokens.push(s);
        }
        if (components.query !== void 0) {
          uriTokens.push("?");
          uriTokens.push(components.query);
        }
        if (components.fragment !== void 0) {
          uriTokens.push("#");
          uriTokens.push(components.fragment);
        }
        return uriTokens.join("");
      }
      function resolveComponents(base2, relative) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var skipNormalization = arguments[3];
        var target = {};
        if (!skipNormalization) {
          base2 = parse2(serialize(base2, options), options);
          relative = parse2(serialize(relative, options), options);
        }
        options = options || {};
        if (!options.tolerant && relative.scheme) {
          target.scheme = relative.scheme;
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
          } else {
            if (!relative.path) {
              target.path = base2.path;
              if (relative.query !== void 0) {
                target.query = relative.query;
              } else {
                target.query = base2.query;
              }
            } else {
              if (relative.path.charAt(0) === "/") {
                target.path = removeDotSegments(relative.path);
              } else {
                if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                  target.path = "/" + relative.path;
                } else if (!base2.path) {
                  target.path = relative.path;
                } else {
                  target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
                }
                target.path = removeDotSegments(target.path);
              }
              target.query = relative.query;
            }
            target.userinfo = base2.userinfo;
            target.host = base2.host;
            target.port = base2.port;
          }
          target.scheme = base2.scheme;
        }
        target.fragment = relative.fragment;
        return target;
      }
      function resolve(baseURI, relativeURI, options) {
        var schemelessOptions = assign({ scheme: "null" }, options);
        return serialize(resolveComponents(parse2(baseURI, schemelessOptions), parse2(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
      }
      function normalize(uri, options) {
        if (typeof uri === "string") {
          uri = serialize(parse2(uri, options), options);
        } else if (typeOf(uri) === "object") {
          uri = parse2(serialize(uri, options), options);
        }
        return uri;
      }
      function equal(uriA, uriB, options) {
        if (typeof uriA === "string") {
          uriA = serialize(parse2(uriA, options), options);
        } else if (typeOf(uriA) === "object") {
          uriA = serialize(uriA, options);
        }
        if (typeof uriB === "string") {
          uriB = serialize(parse2(uriB, options), options);
        } else if (typeOf(uriB) === "object") {
          uriB = serialize(uriB, options);
        }
        return uriA === uriB;
      }
      function escapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
      }
      function unescapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
      }
      var handler = {
        scheme: "http",
        domainHost: true,
        parse: function parse3(components, options) {
          if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
          }
          return components;
        },
        serialize: function serialize2(components, options) {
          var secure = String(components.scheme).toLowerCase() === "https";
          if (components.port === (secure ? 443 : 80) || components.port === "") {
            components.port = void 0;
          }
          if (!components.path) {
            components.path = "/";
          }
          return components;
        }
      };
      var handler$1 = {
        scheme: "https",
        domainHost: handler.domainHost,
        parse: handler.parse,
        serialize: handler.serialize
      };
      function isSecure(wsComponents) {
        return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
      }
      var handler$2 = {
        scheme: "ws",
        domainHost: true,
        parse: function parse3(components, options) {
          var wsComponents = components;
          wsComponents.secure = isSecure(wsComponents);
          wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
          wsComponents.path = void 0;
          wsComponents.query = void 0;
          return wsComponents;
        },
        serialize: function serialize2(wsComponents, options) {
          if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
            wsComponents.port = void 0;
          }
          if (typeof wsComponents.secure === "boolean") {
            wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
            wsComponents.secure = void 0;
          }
          if (wsComponents.resourceName) {
            var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
            wsComponents.path = path && path !== "/" ? path : void 0;
            wsComponents.query = query;
            wsComponents.resourceName = void 0;
          }
          wsComponents.fragment = void 0;
          return wsComponents;
        }
      };
      var handler$3 = {
        scheme: "wss",
        domainHost: handler$2.domainHost,
        parse: handler$2.parse,
        serialize: handler$2.serialize
      };
      var O = {};
      var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]";
      var HEXDIG$$ = "[0-9A-Fa-f]";
      var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
      var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
      var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
      var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
      var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
      var UNRESERVED = new RegExp(UNRESERVED$$, "g");
      var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
      var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
      var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
      var NOT_HFVALUE = NOT_HFNAME;
      function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(UNRESERVED) ? str : decStr;
      }
      var handler$4 = {
        scheme: "mailto",
        parse: function parse$$1(components, options) {
          var mailtoComponents = components;
          var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
          mailtoComponents.path = void 0;
          if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
              var hfield = hfields[x].split("=");
              switch (hfield[0]) {
                case "to":
                  var toAddrs = hfield[1].split(",");
                  for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                    to.push(toAddrs[_x]);
                  }
                  break;
                case "subject":
                  mailtoComponents.subject = unescapeComponent(hfield[1], options);
                  break;
                case "body":
                  mailtoComponents.body = unescapeComponent(hfield[1], options);
                  break;
                default:
                  unknownHeaders = true;
                  headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                  break;
              }
            }
            if (unknownHeaders) mailtoComponents.headers = headers;
          }
          mailtoComponents.query = void 0;
          for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
              try {
                addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
              } catch (e) {
                mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
              }
            } else {
              addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
          }
          return mailtoComponents;
        },
        serialize: function serialize$$1(mailtoComponents, options) {
          var components = mailtoComponents;
          var to = toArray(mailtoComponents.to);
          if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
              var toAddr = String(to[x]);
              var atIdx = toAddr.lastIndexOf("@");
              var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
              var domain = toAddr.slice(atIdx + 1);
              try {
                domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
              } catch (e) {
                components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
              }
              to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
          }
          var headers = mailtoComponents.headers = mailtoComponents.headers || {};
          if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
          if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
          var fields = [];
          for (var name in headers) {
            if (headers[name] !== O[name]) {
              fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
          }
          if (fields.length) {
            components.query = fields.join("&");
          }
          return components;
        }
      };
      var URN_PARSE = /^([^\:]+)\:(.*)/;
      var handler$5 = {
        scheme: "urn",
        parse: function parse$$1(components, options) {
          var matches = components.path && components.path.match(URN_PARSE);
          var urnComponents = components;
          if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = void 0;
            if (schemeHandler) {
              urnComponents = schemeHandler.parse(urnComponents, options);
            }
          } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
          }
          return urnComponents;
        },
        serialize: function serialize$$1(urnComponents, options) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = urnComponents.nid;
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
          }
          var uriComponents = urnComponents;
          var nss = urnComponents.nss;
          uriComponents.path = (nid || options.nid) + ":" + nss;
          return uriComponents;
        }
      };
      var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
      var handler$6 = {
        scheme: "urn:uuid",
        parse: function parse3(urnComponents, options) {
          var uuidComponents = urnComponents;
          uuidComponents.uuid = uuidComponents.nss;
          uuidComponents.nss = void 0;
          if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
          }
          return uuidComponents;
        },
        serialize: function serialize2(uuidComponents, options) {
          var urnComponents = uuidComponents;
          urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
          return urnComponents;
        }
      };
      SCHEMES[handler.scheme] = handler;
      SCHEMES[handler$1.scheme] = handler$1;
      SCHEMES[handler$2.scheme] = handler$2;
      SCHEMES[handler$3.scheme] = handler$3;
      SCHEMES[handler$4.scheme] = handler$4;
      SCHEMES[handler$5.scheme] = handler$5;
      SCHEMES[handler$6.scheme] = handler$6;
      exports$12.SCHEMES = SCHEMES;
      exports$12.pctEncChar = pctEncChar;
      exports$12.pctDecChars = pctDecChars;
      exports$12.parse = parse2;
      exports$12.removeDotSegments = removeDotSegments;
      exports$12.serialize = serialize;
      exports$12.resolveComponents = resolveComponents;
      exports$12.resolve = resolve;
      exports$12.normalize = normalize;
      exports$12.equal = equal;
      exports$12.escapeComponent = escapeComponent;
      exports$12.unescapeComponent = unescapeComponent;
      Object.defineProperty(exports$12, "__esModule", { value: true });
    }));
  })(uri_all$1, uri_all$1.exports);
  return uri_all$1.exports;
}
var fastDeepEqual;
var hasRequiredFastDeepEqual;
function requireFastDeepEqual() {
  if (hasRequiredFastDeepEqual) return fastDeepEqual;
  hasRequiredFastDeepEqual = 1;
  fastDeepEqual = function equal(a, b) {
    if (a === b) return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor) return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length) return false;
        for (i = length; i-- !== 0; )
          if (!equal(a[i], b[i])) return false;
        return true;
      }
      if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length) return false;
      for (i = length; i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
      for (i = length; i-- !== 0; ) {
        var key2 = keys[i];
        if (!equal(a[key2], b[key2])) return false;
      }
      return true;
    }
    return a !== a && b !== b;
  };
  return fastDeepEqual;
}
var ucs2length;
var hasRequiredUcs2length;
function requireUcs2length() {
  if (hasRequiredUcs2length) return ucs2length;
  hasRequiredUcs2length = 1;
  ucs2length = function ucs2length2(str) {
    var length = 0, len = str.length, pos = 0, value;
    while (pos < len) {
      length++;
      value = str.charCodeAt(pos++);
      if (value >= 55296 && value <= 56319 && pos < len) {
        value = str.charCodeAt(pos);
        if ((value & 64512) == 56320) pos++;
      }
    }
    return length;
  };
  return ucs2length;
}
var util;
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  util = {
    copy,
    checkDataType,
    checkDataTypes,
    coerceToTypes,
    toHash,
    getProperty,
    escapeQuotes,
    equal: requireFastDeepEqual(),
    ucs2length: requireUcs2length(),
    varOccurences,
    varReplace,
    schemaHasRules,
    schemaHasRulesExcept,
    schemaUnknownRules,
    toQuotedString,
    getPathExpr,
    getPath,
    getData,
    unescapeFragment,
    unescapeJsonPointer,
    escapeFragment,
    escapeJsonPointer
  };
  function copy(o, to) {
    to = to || {};
    for (var key2 in o) to[key2] = o[key2];
    return to;
  }
  function checkDataType(dataType, data2, strictNumbers, negate) {
    var EQUAL = negate ? " !== " : " === ", AND = negate ? " || " : " && ", OK = negate ? "!" : "", NOT = negate ? "" : "!";
    switch (dataType) {
      case "null":
        return data2 + EQUAL + "null";
      case "array":
        return OK + "Array.isArray(" + data2 + ")";
      case "object":
        return "(" + OK + data2 + AND + "typeof " + data2 + EQUAL + '"object"' + AND + NOT + "Array.isArray(" + data2 + "))";
      case "integer":
        return "(typeof " + data2 + EQUAL + '"number"' + AND + NOT + "(" + data2 + " % 1)" + AND + data2 + EQUAL + data2 + (strictNumbers ? AND + OK + "isFinite(" + data2 + ")" : "") + ")";
      case "number":
        return "(typeof " + data2 + EQUAL + '"' + dataType + '"' + (strictNumbers ? AND + OK + "isFinite(" + data2 + ")" : "") + ")";
      default:
        return "typeof " + data2 + EQUAL + '"' + dataType + '"';
    }
  }
  function checkDataTypes(dataTypes, data2, strictNumbers) {
    switch (dataTypes.length) {
      case 1:
        return checkDataType(dataTypes[0], data2, strictNumbers, true);
      default:
        var code = "";
        var types2 = toHash(dataTypes);
        if (types2.array && types2.object) {
          code = types2.null ? "(" : "(!" + data2 + " || ";
          code += "typeof " + data2 + ' !== "object")';
          delete types2.null;
          delete types2.array;
          delete types2.object;
        }
        if (types2.number) delete types2.integer;
        for (var t in types2)
          code += (code ? " && " : "") + checkDataType(t, data2, strictNumbers, true);
        return code;
    }
  }
  var COERCE_TO_TYPES = toHash(["string", "number", "integer", "boolean", "null"]);
  function coerceToTypes(optionCoerceTypes, dataTypes) {
    if (Array.isArray(dataTypes)) {
      var types2 = [];
      for (var i = 0; i < dataTypes.length; i++) {
        var t = dataTypes[i];
        if (COERCE_TO_TYPES[t]) types2[types2.length] = t;
        else if (optionCoerceTypes === "array" && t === "array") types2[types2.length] = t;
      }
      if (types2.length) return types2;
    } else if (COERCE_TO_TYPES[dataTypes]) {
      return [dataTypes];
    } else if (optionCoerceTypes === "array" && dataTypes === "array") {
      return ["array"];
    }
  }
  function toHash(arr) {
    var hash = {};
    for (var i = 0; i < arr.length; i++) hash[arr[i]] = true;
    return hash;
  }
  var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  var SINGLE_QUOTE = /'|\\/g;
  function getProperty(key2) {
    return typeof key2 == "number" ? "[" + key2 + "]" : IDENTIFIER.test(key2) ? "." + key2 : "['" + escapeQuotes(key2) + "']";
  }
  function escapeQuotes(str) {
    return str.replace(SINGLE_QUOTE, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
  }
  function varOccurences(str, dataVar) {
    dataVar += "[^0-9]";
    var matches = str.match(new RegExp(dataVar, "g"));
    return matches ? matches.length : 0;
  }
  function varReplace(str, dataVar, expr) {
    dataVar += "([^0-9])";
    expr = expr.replace(/\$/g, "$$$$");
    return str.replace(new RegExp(dataVar, "g"), expr + "$1");
  }
  function schemaHasRules(schema, rules2) {
    if (typeof schema == "boolean") return !schema;
    for (var key2 in schema) if (rules2[key2]) return true;
  }
  function schemaHasRulesExcept(schema, rules2, exceptKeyword) {
    if (typeof schema == "boolean") return !schema && exceptKeyword != "not";
    for (var key2 in schema) if (key2 != exceptKeyword && rules2[key2]) return true;
  }
  function schemaUnknownRules(schema, rules2) {
    if (typeof schema == "boolean") return;
    for (var key2 in schema) if (!rules2[key2]) return key2;
  }
  function toQuotedString(str) {
    return "'" + escapeQuotes(str) + "'";
  }
  function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
    var path = jsonPointers ? "'/' + " + expr + (isNumber ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : isNumber ? "'[' + " + expr + " + ']'" : "'[\\'' + " + expr + " + '\\']'";
    return joinPaths(currentPath, path);
  }
  function getPath(currentPath, prop, jsonPointers) {
    var path = jsonPointers ? toQuotedString("/" + escapeJsonPointer(prop)) : toQuotedString(getProperty(prop));
    return joinPaths(currentPath, path);
  }
  var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
  var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function getData($data, lvl, paths) {
    var up, jsonPointer, data2, matches;
    if ($data === "") return "rootData";
    if ($data[0] == "/") {
      if (!JSON_POINTER.test($data)) throw new Error("Invalid JSON-pointer: " + $data);
      jsonPointer = $data;
      data2 = "rootData";
    } else {
      matches = $data.match(RELATIVE_JSON_POINTER);
      if (!matches) throw new Error("Invalid JSON-pointer: " + $data);
      up = +matches[1];
      jsonPointer = matches[2];
      if (jsonPointer == "#") {
        if (up >= lvl) throw new Error("Cannot access property/index " + up + " levels up, current level is " + lvl);
        return paths[lvl - up];
      }
      if (up > lvl) throw new Error("Cannot access data " + up + " levels up, current level is " + lvl);
      data2 = "data" + (lvl - up || "");
      if (!jsonPointer) return data2;
    }
    var expr = data2;
    var segments = jsonPointer.split("/");
    for (var i = 0; i < segments.length; i++) {
      var segment = segments[i];
      if (segment) {
        data2 += getProperty(unescapeJsonPointer(segment));
        expr += " && " + data2;
      }
    }
    return expr;
  }
  function joinPaths(a, b) {
    if (a == '""') return b;
    return (a + " + " + b).replace(/([^\\])' \+ '/g, "$1");
  }
  function unescapeFragment(str) {
    return unescapeJsonPointer(decodeURIComponent(str));
  }
  function escapeFragment(str) {
    return encodeURIComponent(escapeJsonPointer(str));
  }
  function escapeJsonPointer(str) {
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  function unescapeJsonPointer(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  return util;
}
var schema_obj;
var hasRequiredSchema_obj;
function requireSchema_obj() {
  if (hasRequiredSchema_obj) return schema_obj;
  hasRequiredSchema_obj = 1;
  var util2 = requireUtil();
  schema_obj = SchemaObject;
  function SchemaObject(obj) {
    util2.copy(obj, this);
  }
  return schema_obj;
}
var jsonSchemaTraverse = { exports: {} };
var hasRequiredJsonSchemaTraverse;
function requireJsonSchemaTraverse() {
  if (hasRequiredJsonSchemaTraverse) return jsonSchemaTraverse.exports;
  hasRequiredJsonSchemaTraverse = 1;
  var traverse = jsonSchemaTraverse.exports = function(schema, opts, cb) {
    if (typeof opts == "function") {
      cb = opts;
      opts = {};
    }
    cb = opts.cb || cb;
    var pre = typeof cb == "function" ? cb : cb.pre || function() {
    };
    var post = cb.post || function() {
    };
    _traverse(opts, pre, post, schema, "", schema);
  };
  traverse.keywords = {
    additionalItems: true,
    items: true,
    contains: true,
    additionalProperties: true,
    propertyNames: true,
    not: true
  };
  traverse.arrayKeywords = {
    items: true,
    allOf: true,
    anyOf: true,
    oneOf: true
  };
  traverse.propsKeywords = {
    definitions: true,
    properties: true,
    patternProperties: true,
    dependencies: true
  };
  traverse.skipKeywords = {
    default: true,
    enum: true,
    const: true,
    required: true,
    maximum: true,
    minimum: true,
    exclusiveMaximum: true,
    exclusiveMinimum: true,
    multipleOf: true,
    maxLength: true,
    minLength: true,
    pattern: true,
    format: true,
    maxItems: true,
    minItems: true,
    uniqueItems: true,
    maxProperties: true,
    minProperties: true
  };
  function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (schema && typeof schema == "object" && !Array.isArray(schema)) {
      pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      for (var key2 in schema) {
        var sch = schema[key2];
        if (Array.isArray(sch)) {
          if (key2 in traverse.arrayKeywords) {
            for (var i = 0; i < sch.length; i++)
              _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key2 + "/" + i, rootSchema, jsonPtr, key2, schema, i);
          }
        } else if (key2 in traverse.propsKeywords) {
          if (sch && typeof sch == "object") {
            for (var prop in sch)
              _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key2 + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key2, schema, prop);
          }
        } else if (key2 in traverse.keywords || opts.allKeys && !(key2 in traverse.skipKeywords)) {
          _traverse(opts, pre, post, sch, jsonPtr + "/" + key2, rootSchema, jsonPtr, key2, schema);
        }
      }
      post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    }
  }
  function escapeJsonPtr(str) {
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  return jsonSchemaTraverse.exports;
}
var resolve_1;
var hasRequiredResolve;
function requireResolve() {
  if (hasRequiredResolve) return resolve_1;
  hasRequiredResolve = 1;
  var URI = requireUri_all(), equal = requireFastDeepEqual(), util2 = requireUtil(), SchemaObject = requireSchema_obj(), traverse = requireJsonSchemaTraverse();
  resolve_1 = resolve;
  resolve.normalizeId = normalizeId;
  resolve.fullPath = getFullPath;
  resolve.url = resolveUrl;
  resolve.ids = resolveIds;
  resolve.inlineRef = inlineRef;
  resolve.schema = resolveSchema;
  function resolve(compile2, root, ref2) {
    var refVal = this._refs[ref2];
    if (typeof refVal == "string") {
      if (this._refs[refVal]) refVal = this._refs[refVal];
      else return resolve.call(this, compile2, root, refVal);
    }
    refVal = refVal || this._schemas[ref2];
    if (refVal instanceof SchemaObject) {
      return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
    }
    var res = resolveSchema.call(this, root, ref2);
    var schema, v, baseId;
    if (res) {
      schema = res.schema;
      root = res.root;
      baseId = res.baseId;
    }
    if (schema instanceof SchemaObject) {
      v = schema.validate || compile2.call(this, schema.schema, root, void 0, baseId);
    } else if (schema !== void 0) {
      v = inlineRef(schema, this._opts.inlineRefs) ? schema : compile2.call(this, schema, root, void 0, baseId);
    }
    return v;
  }
  function resolveSchema(root, ref2) {
    var p = URI.parse(ref2), refPath = _getFullPath(p), baseId = getFullPath(this._getId(root.schema));
    if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
      var id = normalizeId(refPath);
      var refVal = this._refs[id];
      if (typeof refVal == "string") {
        return resolveRecursive.call(this, root, refVal, p);
      } else if (refVal instanceof SchemaObject) {
        if (!refVal.validate) this._compile(refVal);
        root = refVal;
      } else {
        refVal = this._schemas[id];
        if (refVal instanceof SchemaObject) {
          if (!refVal.validate) this._compile(refVal);
          if (id == normalizeId(ref2))
            return { schema: refVal, root, baseId };
          root = refVal;
        } else {
          return;
        }
      }
      if (!root.schema) return;
      baseId = getFullPath(this._getId(root.schema));
    }
    return getJsonPointer.call(this, p, baseId, root.schema, root);
  }
  function resolveRecursive(root, ref2, parsedRef) {
    var res = resolveSchema.call(this, root, ref2);
    if (res) {
      var schema = res.schema;
      var baseId = res.baseId;
      root = res.root;
      var id = this._getId(schema);
      if (id) baseId = resolveUrl(baseId, id);
      return getJsonPointer.call(this, parsedRef, baseId, schema, root);
    }
  }
  var PREVENT_SCOPE_CHANGE = util2.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
  function getJsonPointer(parsedRef, baseId, schema, root) {
    parsedRef.fragment = parsedRef.fragment || "";
    if (parsedRef.fragment.slice(0, 1) != "/") return;
    var parts = parsedRef.fragment.split("/");
    for (var i = 1; i < parts.length; i++) {
      var part = parts[i];
      if (part) {
        part = util2.unescapeFragment(part);
        schema = schema[part];
        if (schema === void 0) break;
        var id;
        if (!PREVENT_SCOPE_CHANGE[part]) {
          id = this._getId(schema);
          if (id) baseId = resolveUrl(baseId, id);
          if (schema.$ref) {
            var $ref = resolveUrl(baseId, schema.$ref);
            var res = resolveSchema.call(this, root, $ref);
            if (res) {
              schema = res.schema;
              root = res.root;
              baseId = res.baseId;
            }
          }
        }
      }
    }
    if (schema !== void 0 && schema !== root.schema)
      return { schema, root, baseId };
  }
  var SIMPLE_INLINED = util2.toHash([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum"
  ]);
  function inlineRef(schema, limit) {
    if (limit === false) return false;
    if (limit === void 0 || limit === true) return checkNoRef(schema);
    else if (limit) return countKeys(schema) <= limit;
  }
  function checkNoRef(schema) {
    var item;
    if (Array.isArray(schema)) {
      for (var i = 0; i < schema.length; i++) {
        item = schema[i];
        if (typeof item == "object" && !checkNoRef(item)) return false;
      }
    } else {
      for (var key2 in schema) {
        if (key2 == "$ref") return false;
        item = schema[key2];
        if (typeof item == "object" && !checkNoRef(item)) return false;
      }
    }
    return true;
  }
  function countKeys(schema) {
    var count = 0, item;
    if (Array.isArray(schema)) {
      for (var i = 0; i < schema.length; i++) {
        item = schema[i];
        if (typeof item == "object") count += countKeys(item);
        if (count == Infinity) return Infinity;
      }
    } else {
      for (var key2 in schema) {
        if (key2 == "$ref") return Infinity;
        if (SIMPLE_INLINED[key2]) {
          count++;
        } else {
          item = schema[key2];
          if (typeof item == "object") count += countKeys(item) + 1;
          if (count == Infinity) return Infinity;
        }
      }
    }
    return count;
  }
  function getFullPath(id, normalize) {
    if (normalize !== false) id = normalizeId(id);
    var p = URI.parse(id);
    return _getFullPath(p);
  }
  function _getFullPath(p) {
    return URI.serialize(p).split("#")[0] + "#";
  }
  var TRAILING_SLASH_HASH = /#\/?$/;
  function normalizeId(id) {
    return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
  }
  function resolveUrl(baseId, id) {
    id = normalizeId(id);
    return URI.resolve(baseId, id);
  }
  function resolveIds(schema) {
    var schemaId = normalizeId(this._getId(schema));
    var baseIds = { "": schemaId };
    var fullPaths = { "": getFullPath(schemaId, false) };
    var localRefs = {};
    var self2 = this;
    traverse(schema, { allKeys: true }, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (jsonPtr === "") return;
      var id = self2._getId(sch);
      var baseId = baseIds[parentJsonPtr];
      var fullPath = fullPaths[parentJsonPtr] + "/" + parentKeyword;
      if (keyIndex !== void 0)
        fullPath += "/" + (typeof keyIndex == "number" ? keyIndex : util2.escapeFragment(keyIndex));
      if (typeof id == "string") {
        id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);
        var refVal = self2._refs[id];
        if (typeof refVal == "string") refVal = self2._refs[refVal];
        if (refVal && refVal.schema) {
          if (!equal(sch, refVal.schema))
            throw new Error('id "' + id + '" resolves to more than one schema');
        } else if (id != normalizeId(fullPath)) {
          if (id[0] == "#") {
            if (localRefs[id] && !equal(sch, localRefs[id]))
              throw new Error('id "' + id + '" resolves to more than one schema');
            localRefs[id] = sch;
          } else {
            self2._refs[id] = fullPath;
          }
        }
      }
      baseIds[jsonPtr] = baseId;
      fullPaths[jsonPtr] = fullPath;
    });
    return localRefs;
  }
  return resolve_1;
}
var error_classes;
var hasRequiredError_classes;
function requireError_classes() {
  if (hasRequiredError_classes) return error_classes;
  hasRequiredError_classes = 1;
  var resolve = requireResolve();
  error_classes = {
    Validation: errorSubclass(ValidationError),
    MissingRef: errorSubclass(MissingRefError)
  };
  function ValidationError(errors2) {
    this.message = "validation failed";
    this.errors = errors2;
    this.ajv = this.validation = true;
  }
  MissingRefError.message = function(baseId, ref2) {
    return "can't resolve reference " + ref2 + " from id " + baseId;
  };
  function MissingRefError(baseId, ref2, message) {
    this.message = message || MissingRefError.message(baseId, ref2);
    this.missingRef = resolve.url(baseId, ref2);
    this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
  }
  function errorSubclass(Subclass) {
    Subclass.prototype = Object.create(Error.prototype);
    Subclass.prototype.constructor = Subclass;
    return Subclass;
  }
  return error_classes;
}
var fastJsonStableStringify;
var hasRequiredFastJsonStableStringify;
function requireFastJsonStableStringify() {
  if (hasRequiredFastJsonStableStringify) return fastJsonStableStringify;
  hasRequiredFastJsonStableStringify = 1;
  fastJsonStableStringify = function(data2, opts) {
    if (!opts) opts = {};
    if (typeof opts === "function") opts = { cmp: opts };
    var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
    var cmp = opts.cmp && /* @__PURE__ */ (function(f) {
      return function(node) {
        return function(a, b) {
          var aobj = { key: a, value: node[a] };
          var bobj = { key: b, value: node[b] };
          return f(aobj, bobj);
        };
      };
    })(opts.cmp);
    var seen = [];
    return (function stringify2(node) {
      if (node && node.toJSON && typeof node.toJSON === "function") {
        node = node.toJSON();
      }
      if (node === void 0) return;
      if (typeof node == "number") return isFinite(node) ? "" + node : "null";
      if (typeof node !== "object") return JSON.stringify(node);
      var i, out;
      if (Array.isArray(node)) {
        out = "[";
        for (i = 0; i < node.length; i++) {
          if (i) out += ",";
          out += stringify2(node[i]) || "null";
        }
        return out + "]";
      }
      if (node === null) return "null";
      if (seen.indexOf(node) !== -1) {
        if (cycles) return JSON.stringify("__cycle__");
        throw new TypeError("Converting circular structure to JSON");
      }
      var seenIndex = seen.push(node) - 1;
      var keys = Object.keys(node).sort(cmp && cmp(node));
      out = "";
      for (i = 0; i < keys.length; i++) {
        var key2 = keys[i];
        var value = stringify2(node[key2]);
        if (!value) continue;
        if (out) out += ",";
        out += JSON.stringify(key2) + ":" + value;
      }
      seen.splice(seenIndex, 1);
      return "{" + out + "}";
    })(data2);
  };
  return fastJsonStableStringify;
}
var validate;
var hasRequiredValidate;
function requireValidate() {
  if (hasRequiredValidate) return validate;
  hasRequiredValidate = 1;
  validate = function generate_validate(it, $keyword, $ruleType) {
    var out = "";
    var $async = it.schema.$async === true, $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, "$ref"), $id2 = it.self._getId(it.schema);
    if (it.opts.strictKeywords) {
      var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
      if ($unknownKwd) {
        var $keywordsMsg = "unknown keyword: " + $unknownKwd;
        if (it.opts.strictKeywords === "log") it.logger.warn($keywordsMsg);
        else throw new Error($keywordsMsg);
      }
    }
    if (it.isTop) {
      out += " var validate = ";
      if ($async) {
        it.async = true;
        out += "async ";
      }
      out += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ";
      if ($id2 && (it.opts.sourceCode || it.opts.processCode)) {
        out += " " + ("/*# sourceURL=" + $id2 + " */") + " ";
      }
    }
    if (typeof it.schema == "boolean" || !($refKeywords || it.schema.$ref)) {
      var $keyword = "false schema";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema2 = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      if (it.schema === false) {
        if (it.isTop) {
          $breakOnError = true;
        } else {
          out += " var " + $valid + " = false; ";
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "false schema") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'boolean schema is false' ";
          }
          if (it.opts.verbose) {
            out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
      } else {
        if (it.isTop) {
          if ($async) {
            out += " return data; ";
          } else {
            out += " validate.errors = null; return true; ";
          }
        } else {
          out += " var " + $valid + " = true; ";
        }
      }
      if (it.isTop) {
        out += " }; return validate; ";
      }
      return out;
    }
    if (it.isTop) {
      var $top = it.isTop, $lvl = it.level = 0, $dataLvl = it.dataLevel = 0, $data = "data";
      it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
      it.baseId = it.baseId || it.rootId;
      delete it.isTop;
      it.dataPathArr = [""];
      if (it.schema.default !== void 0 && it.opts.useDefaults && it.opts.strictDefaults) {
        var $defaultMsg = "default is ignored in the schema root";
        if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
        else throw new Error($defaultMsg);
      }
      out += " var vErrors = null; ";
      out += " var errors = 0;     ";
      out += " if (rootData === undefined) rootData = data; ";
    } else {
      var $lvl = it.level, $dataLvl = it.dataLevel, $data = "data" + ($dataLvl || "");
      if ($id2) it.baseId = it.resolve.url(it.baseId, $id2);
      if ($async && !it.async) throw new Error("async schema in sync schema");
      out += " var errs_" + $lvl + " = errors;";
    }
    var $valid = "valid" + $lvl, $breakOnError = !it.opts.allErrors, $closingBraces1 = "", $closingBraces2 = "";
    var $errorKeyword;
    var $typeSchema = it.schema.type, $typeIsArray = Array.isArray($typeSchema);
    if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
      if ($typeIsArray) {
        if ($typeSchema.indexOf("null") == -1) $typeSchema = $typeSchema.concat("null");
      } else if ($typeSchema != "null") {
        $typeSchema = [$typeSchema, "null"];
        $typeIsArray = true;
      }
    }
    if ($typeIsArray && $typeSchema.length == 1) {
      $typeSchema = $typeSchema[0];
      $typeIsArray = false;
    }
    if (it.schema.$ref && $refKeywords) {
      if (it.opts.extendRefs == "fail") {
        throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
      } else if (it.opts.extendRefs !== true) {
        $refKeywords = false;
        it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
      }
    }
    if (it.schema.$comment && it.opts.$comment) {
      out += " " + it.RULES.all.$comment.code(it, "$comment");
    }
    if ($typeSchema) {
      if (it.opts.coerceTypes) {
        var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
      }
      var $rulesGroup = it.RULES.types[$typeSchema];
      if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
        var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
        var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type", $method = $typeIsArray ? "checkDataTypes" : "checkDataType";
        out += " if (" + it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true) + ") { ";
        if ($coerceToTypes) {
          var $dataType = "dataType" + $lvl, $coerced = "coerced" + $lvl;
          out += " var " + $dataType + " = typeof " + $data + "; var " + $coerced + " = undefined; ";
          if (it.opts.coerceTypes == "array") {
            out += " if (" + $dataType + " == 'object' && Array.isArray(" + $data + ") && " + $data + ".length == 1) { " + $data + " = " + $data + "[0]; " + $dataType + " = typeof " + $data + "; if (" + it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers) + ") " + $coerced + " = " + $data + "; } ";
          }
          out += " if (" + $coerced + " !== undefined) ; ";
          var arr1 = $coerceToTypes;
          if (arr1) {
            var $type2, $i = -1, l1 = arr1.length - 1;
            while ($i < l1) {
              $type2 = arr1[$i += 1];
              if ($type2 == "string") {
                out += " else if (" + $dataType + " == 'number' || " + $dataType + " == 'boolean') " + $coerced + " = '' + " + $data + "; else if (" + $data + " === null) " + $coerced + " = ''; ";
              } else if ($type2 == "number" || $type2 == "integer") {
                out += " else if (" + $dataType + " == 'boolean' || " + $data + " === null || (" + $dataType + " == 'string' && " + $data + " && " + $data + " == +" + $data + " ";
                if ($type2 == "integer") {
                  out += " && !(" + $data + " % 1)";
                }
                out += ")) " + $coerced + " = +" + $data + "; ";
              } else if ($type2 == "boolean") {
                out += " else if (" + $data + " === 'false' || " + $data + " === 0 || " + $data + " === null) " + $coerced + " = false; else if (" + $data + " === 'true' || " + $data + " === 1) " + $coerced + " = true; ";
              } else if ($type2 == "null") {
                out += " else if (" + $data + " === '' || " + $data + " === 0 || " + $data + " === false) " + $coerced + " = null; ";
              } else if (it.opts.coerceTypes == "array" && $type2 == "array") {
                out += " else if (" + $dataType + " == 'string' || " + $dataType + " == 'number' || " + $dataType + " == 'boolean' || " + $data + " == null) " + $coerced + " = [" + $data + "]; ";
              }
            }
          }
          out += " else {   ";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
            if ($typeIsArray) {
              out += "" + $typeSchema.join(",");
            } else {
              out += "" + $typeSchema;
            }
            out += "' } ";
            if (it.opts.messages !== false) {
              out += " , message: 'should be ";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } if (" + $coerced + " !== undefined) {  ";
          var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
          out += " " + $data + " = " + $coerced + "; ";
          if (!$dataLvl) {
            out += "if (" + $parentData + " !== undefined)";
          }
          out += " " + $parentData + "[" + $parentDataProperty + "] = " + $coerced + "; } ";
        } else {
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
            if ($typeIsArray) {
              out += "" + $typeSchema.join(",");
            } else {
              out += "" + $typeSchema;
            }
            out += "' } ";
            if (it.opts.messages !== false) {
              out += " , message: 'should be ";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
        }
        out += " } ";
      }
    }
    if (it.schema.$ref && !$refKeywords) {
      out += " " + it.RULES.all.$ref.code(it, "$ref") + " ";
      if ($breakOnError) {
        out += " } if (errors === ";
        if ($top) {
          out += "0";
        } else {
          out += "errs_" + $lvl;
        }
        out += ") { ";
        $closingBraces2 += "}";
      }
    } else {
      var arr2 = it.RULES;
      if (arr2) {
        var $rulesGroup, i2 = -1, l2 = arr2.length - 1;
        while (i2 < l2) {
          $rulesGroup = arr2[i2 += 1];
          if ($shouldUseGroup($rulesGroup)) {
            if ($rulesGroup.type) {
              out += " if (" + it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers) + ") { ";
            }
            if (it.opts.useDefaults) {
              if ($rulesGroup.type == "object" && it.schema.properties) {
                var $schema2 = it.schema.properties, $schemaKeys = Object.keys($schema2);
                var arr3 = $schemaKeys;
                if (arr3) {
                  var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                  while (i3 < l3) {
                    $propertyKey = arr3[i3 += 1];
                    var $sch = $schema2[$propertyKey];
                    if ($sch.default !== void 0) {
                      var $passData = $data + it.util.getProperty($propertyKey);
                      if (it.compositeRule) {
                        if (it.opts.strictDefaults) {
                          var $defaultMsg = "default is ignored for: " + $passData;
                          if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
                          else throw new Error($defaultMsg);
                        }
                      } else {
                        out += " if (" + $passData + " === undefined ";
                        if (it.opts.useDefaults == "empty") {
                          out += " || " + $passData + " === null || " + $passData + " === '' ";
                        }
                        out += " ) " + $passData + " = ";
                        if (it.opts.useDefaults == "shared") {
                          out += " " + it.useDefault($sch.default) + " ";
                        } else {
                          out += " " + JSON.stringify($sch.default) + " ";
                        }
                        out += "; ";
                      }
                    }
                  }
                }
              } else if ($rulesGroup.type == "array" && Array.isArray(it.schema.items)) {
                var arr4 = it.schema.items;
                if (arr4) {
                  var $sch, $i = -1, l4 = arr4.length - 1;
                  while ($i < l4) {
                    $sch = arr4[$i += 1];
                    if ($sch.default !== void 0) {
                      var $passData = $data + "[" + $i + "]";
                      if (it.compositeRule) {
                        if (it.opts.strictDefaults) {
                          var $defaultMsg = "default is ignored for: " + $passData;
                          if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
                          else throw new Error($defaultMsg);
                        }
                      } else {
                        out += " if (" + $passData + " === undefined ";
                        if (it.opts.useDefaults == "empty") {
                          out += " || " + $passData + " === null || " + $passData + " === '' ";
                        }
                        out += " ) " + $passData + " = ";
                        if (it.opts.useDefaults == "shared") {
                          out += " " + it.useDefault($sch.default) + " ";
                        } else {
                          out += " " + JSON.stringify($sch.default) + " ";
                        }
                        out += "; ";
                      }
                    }
                  }
                }
              }
            }
            var arr5 = $rulesGroup.rules;
            if (arr5) {
              var $rule, i5 = -1, l5 = arr5.length - 1;
              while (i5 < l5) {
                $rule = arr5[i5 += 1];
                if ($shouldUseRule($rule)) {
                  var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                  if ($code) {
                    out += " " + $code + " ";
                    if ($breakOnError) {
                      $closingBraces1 += "}";
                    }
                  }
                }
              }
            }
            if ($breakOnError) {
              out += " " + $closingBraces1 + " ";
              $closingBraces1 = "";
            }
            if ($rulesGroup.type) {
              out += " } ";
              if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
                out += " else { ";
                var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = "";
                if (it.createErrors !== false) {
                  out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                  if ($typeIsArray) {
                    out += "" + $typeSchema.join(",");
                  } else {
                    out += "" + $typeSchema;
                  }
                  out += "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: 'should be ";
                    if ($typeIsArray) {
                      out += "" + $typeSchema.join(",");
                    } else {
                      out += "" + $typeSchema;
                    }
                    out += "' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                  if (it.async) {
                    out += " throw new ValidationError([" + __err + "]); ";
                  } else {
                    out += " validate.errors = [" + __err + "]; return false; ";
                  }
                } else {
                  out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                }
                out += " } ";
              }
            }
            if ($breakOnError) {
              out += " if (errors === ";
              if ($top) {
                out += "0";
              } else {
                out += "errs_" + $lvl;
              }
              out += ") { ";
              $closingBraces2 += "}";
            }
          }
        }
      }
    }
    if ($breakOnError) {
      out += " " + $closingBraces2 + " ";
    }
    if ($top) {
      if ($async) {
        out += " if (errors === 0) return data;           ";
        out += " else throw new ValidationError(vErrors); ";
      } else {
        out += " validate.errors = vErrors; ";
        out += " return errors === 0;       ";
      }
      out += " }; return validate;";
    } else {
      out += " var " + $valid + " = errors === errs_" + $lvl + ";";
    }
    function $shouldUseGroup($rulesGroup2) {
      var rules2 = $rulesGroup2.rules;
      for (var i = 0; i < rules2.length; i++)
        if ($shouldUseRule(rules2[i])) return true;
    }
    function $shouldUseRule($rule2) {
      return it.schema[$rule2.keyword] !== void 0 || $rule2.implements && $ruleImplementsSomeKeyword($rule2);
    }
    function $ruleImplementsSomeKeyword($rule2) {
      var impl = $rule2.implements;
      for (var i = 0; i < impl.length; i++)
        if (it.schema[impl[i]] !== void 0) return true;
    }
    return out;
  };
  return validate;
}
var compile_1;
var hasRequiredCompile;
function requireCompile() {
  if (hasRequiredCompile) return compile_1;
  hasRequiredCompile = 1;
  var resolve = requireResolve(), util2 = requireUtil(), errorClasses = requireError_classes(), stableStringify = requireFastJsonStableStringify();
  var validateGenerator = requireValidate();
  var ucs2length2 = util2.ucs2length;
  var equal = requireFastDeepEqual();
  var ValidationError = errorClasses.Validation;
  compile_1 = compile2;
  function compile2(schema, root, localRefs, baseId) {
    var self2 = this, opts = this._opts, refVal = [void 0], refs = {}, patterns = [], patternsHash = {}, defaults = [], defaultsHash = {}, customRules = [];
    root = root || { schema, refVal, refs };
    var c = checkCompiling.call(this, schema, root, baseId);
    var compilation = this._compilations[c.index];
    if (c.compiling) return compilation.callValidate = callValidate;
    var formats2 = this._formats;
    var RULES = this.RULES;
    try {
      var v = localCompile(schema, root, localRefs, baseId);
      compilation.validate = v;
      var cv = compilation.callValidate;
      if (cv) {
        cv.schema = v.schema;
        cv.errors = null;
        cv.refs = v.refs;
        cv.refVal = v.refVal;
        cv.root = v.root;
        cv.$async = v.$async;
        if (opts.sourceCode) cv.source = v.source;
      }
      return v;
    } finally {
      endCompiling.call(this, schema, root, baseId);
    }
    function callValidate() {
      var validate2 = compilation.validate;
      var result = validate2.apply(this, arguments);
      callValidate.errors = validate2.errors;
      return result;
    }
    function localCompile(_schema, _root, localRefs2, baseId2) {
      var isRoot = !_root || _root && _root.schema == _schema;
      if (_root.schema != root.schema)
        return compile2.call(self2, _schema, _root, localRefs2, baseId2);
      var $async = _schema.$async === true;
      var sourceCode = validateGenerator({
        isTop: true,
        schema: _schema,
        isRoot,
        baseId: baseId2,
        root: _root,
        schemaPath: "",
        errSchemaPath: "#",
        errorPath: '""',
        MissingRefError: errorClasses.MissingRef,
        RULES,
        validate: validateGenerator,
        util: util2,
        resolve,
        resolveRef,
        usePattern,
        useDefault,
        useCustomRule,
        opts,
        formats: formats2,
        logger: self2.logger,
        self: self2
      });
      sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode) + sourceCode;
      if (opts.processCode) sourceCode = opts.processCode(sourceCode, _schema);
      var validate2;
      try {
        var makeValidate = new Function(
          "self",
          "RULES",
          "formats",
          "root",
          "refVal",
          "defaults",
          "customRules",
          "equal",
          "ucs2length",
          "ValidationError",
          sourceCode
        );
        validate2 = makeValidate(
          self2,
          RULES,
          formats2,
          root,
          refVal,
          defaults,
          customRules,
          equal,
          ucs2length2,
          ValidationError
        );
        refVal[0] = validate2;
      } catch (e) {
        self2.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      }
      validate2.schema = _schema;
      validate2.errors = null;
      validate2.refs = refs;
      validate2.refVal = refVal;
      validate2.root = isRoot ? validate2 : _root;
      if ($async) validate2.$async = true;
      if (opts.sourceCode === true) {
        validate2.source = {
          code: sourceCode,
          patterns,
          defaults
        };
      }
      return validate2;
    }
    function resolveRef(baseId2, ref2, isRoot) {
      ref2 = resolve.url(baseId2, ref2);
      var refIndex = refs[ref2];
      var _refVal, refCode;
      if (refIndex !== void 0) {
        _refVal = refVal[refIndex];
        refCode = "refVal[" + refIndex + "]";
        return resolvedRef(_refVal, refCode);
      }
      if (!isRoot && root.refs) {
        var rootRefId = root.refs[ref2];
        if (rootRefId !== void 0) {
          _refVal = root.refVal[rootRefId];
          refCode = addLocalRef(ref2, _refVal);
          return resolvedRef(_refVal, refCode);
        }
      }
      refCode = addLocalRef(ref2);
      var v2 = resolve.call(self2, localCompile, root, ref2);
      if (v2 === void 0) {
        var localSchema = localRefs && localRefs[ref2];
        if (localSchema) {
          v2 = resolve.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile2.call(self2, localSchema, root, localRefs, baseId2);
        }
      }
      if (v2 === void 0) {
        removeLocalRef(ref2);
      } else {
        replaceLocalRef(ref2, v2);
        return resolvedRef(v2, refCode);
      }
    }
    function addLocalRef(ref2, v2) {
      var refId = refVal.length;
      refVal[refId] = v2;
      refs[ref2] = refId;
      return "refVal" + refId;
    }
    function removeLocalRef(ref2) {
      delete refs[ref2];
    }
    function replaceLocalRef(ref2, v2) {
      var refId = refs[ref2];
      refVal[refId] = v2;
    }
    function resolvedRef(refVal2, code) {
      return typeof refVal2 == "object" || typeof refVal2 == "boolean" ? { code, schema: refVal2, inline: true } : { code, $async: refVal2 && !!refVal2.$async };
    }
    function usePattern(regexStr) {
      var index = patternsHash[regexStr];
      if (index === void 0) {
        index = patternsHash[regexStr] = patterns.length;
        patterns[index] = regexStr;
      }
      return "pattern" + index;
    }
    function useDefault(value) {
      switch (typeof value) {
        case "boolean":
        case "number":
          return "" + value;
        case "string":
          return util2.toQuotedString(value);
        case "object":
          if (value === null) return "null";
          var valueStr = stableStringify(value);
          var index = defaultsHash[valueStr];
          if (index === void 0) {
            index = defaultsHash[valueStr] = defaults.length;
            defaults[index] = value;
          }
          return "default" + index;
      }
    }
    function useCustomRule(rule, schema2, parentSchema, it) {
      if (self2._opts.validateSchema !== false) {
        var deps = rule.definition.dependencies;
        if (deps && !deps.every(function(keyword2) {
          return Object.prototype.hasOwnProperty.call(parentSchema, keyword2);
        }))
          throw new Error("parent schema must have all required keywords: " + deps.join(","));
        var validateSchema = rule.definition.validateSchema;
        if (validateSchema) {
          var valid = validateSchema(schema2);
          if (!valid) {
            var message = "keyword schema is invalid: " + self2.errorsText(validateSchema.errors);
            if (self2._opts.validateSchema == "log") self2.logger.error(message);
            else throw new Error(message);
          }
        }
      }
      var compile3 = rule.definition.compile, inline = rule.definition.inline, macro = rule.definition.macro;
      var validate2;
      if (compile3) {
        validate2 = compile3.call(self2, schema2, parentSchema, it);
      } else if (macro) {
        validate2 = macro.call(self2, schema2, parentSchema, it);
        if (opts.validateSchema !== false) self2.validateSchema(validate2, true);
      } else if (inline) {
        validate2 = inline.call(self2, it, rule.keyword, schema2, parentSchema);
      } else {
        validate2 = rule.definition.validate;
        if (!validate2) return;
      }
      if (validate2 === void 0)
        throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
      var index = customRules.length;
      customRules[index] = validate2;
      return {
        code: "customRule" + index,
        validate: validate2
      };
    }
  }
  function checkCompiling(schema, root, baseId) {
    var index = compIndex.call(this, schema, root, baseId);
    if (index >= 0) return { index, compiling: true };
    index = this._compilations.length;
    this._compilations[index] = {
      schema,
      root,
      baseId
    };
    return { index, compiling: false };
  }
  function endCompiling(schema, root, baseId) {
    var i = compIndex.call(this, schema, root, baseId);
    if (i >= 0) this._compilations.splice(i, 1);
  }
  function compIndex(schema, root, baseId) {
    for (var i = 0; i < this._compilations.length; i++) {
      var c = this._compilations[i];
      if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
    }
    return -1;
  }
  function patternCode(i, patterns) {
    return "var pattern" + i + " = new RegExp(" + util2.toQuotedString(patterns[i]) + ");";
  }
  function defaultCode(i) {
    return "var default" + i + " = defaults[" + i + "];";
  }
  function refValCode(i, refVal) {
    return refVal[i] === void 0 ? "" : "var refVal" + i + " = refVal[" + i + "];";
  }
  function customRuleCode(i) {
    return "var customRule" + i + " = customRules[" + i + "];";
  }
  function vars(arr, statement) {
    if (!arr.length) return "";
    var code = "";
    for (var i = 0; i < arr.length; i++)
      code += statement(i, arr);
    return code;
  }
  return compile_1;
}
var cache = { exports: {} };
var hasRequiredCache;
function requireCache() {
  if (hasRequiredCache) return cache.exports;
  hasRequiredCache = 1;
  var Cache = cache.exports = function Cache2() {
    this._cache = {};
  };
  Cache.prototype.put = function Cache_put(key2, value) {
    this._cache[key2] = value;
  };
  Cache.prototype.get = function Cache_get(key2) {
    return this._cache[key2];
  };
  Cache.prototype.del = function Cache_del(key2) {
    delete this._cache[key2];
  };
  Cache.prototype.clear = function Cache_clear() {
    this._cache = {};
  };
  return cache.exports;
}
var formats_1;
var hasRequiredFormats;
function requireFormats() {
  if (hasRequiredFormats) return formats_1;
  hasRequiredFormats = 1;
  var util2 = requireUtil();
  var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
  var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
  var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
  var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
  var URL = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
  var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
  var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
  var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
  var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
  formats_1 = formats2;
  function formats2(mode) {
    mode = mode == "full" ? "full" : "fast";
    return util2.copy(formats2[mode]);
  }
  formats2.fast = {
    // date: http://tools.ietf.org/html/rfc3339#section-5.6
    date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
    time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
    "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    "uri-template": URITEMPLATE,
    url: URL,
    // email (sources from jsen validator):
    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
    hostname: HOSTNAME,
    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
    ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
    regex,
    // uuid: http://tools.ietf.org/html/rfc4122
    uuid: UUID,
    // JSON-pointer: https://tools.ietf.org/html/rfc6901
    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
    "json-pointer": JSON_POINTER,
    "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
    "relative-json-pointer": RELATIVE_JSON_POINTER
  };
  formats2.full = {
    date,
    time,
    "date-time": date_time,
    uri,
    "uri-reference": URIREF,
    "uri-template": URITEMPLATE,
    url: URL,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: HOSTNAME,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
    regex,
    uuid: UUID,
    "json-pointer": JSON_POINTER,
    "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
    "relative-json-pointer": RELATIVE_JSON_POINTER
  };
  function isLeapYear(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }
  function date(str) {
    var matches = str.match(DATE);
    if (!matches) return false;
    var year = +matches[1];
    var month = +matches[2];
    var day = +matches[3];
    return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
  }
  function time(str, full) {
    var matches = str.match(TIME);
    if (!matches) return false;
    var hour = matches[1];
    var minute = matches[2];
    var second = matches[3];
    var timeZone = matches[5];
    return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
  }
  var DATE_TIME_SEPARATOR = /t|\s/i;
  function date_time(str) {
    var dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
  }
  var NOT_URI_FRAGMENT = /\/|:/;
  function uri(str) {
    return NOT_URI_FRAGMENT.test(str) && URI.test(str);
  }
  var Z_ANCHOR = /[^\\]\\Z/;
  function regex(str) {
    if (Z_ANCHOR.test(str)) return false;
    try {
      new RegExp(str);
      return true;
    } catch (e) {
      return false;
    }
  }
  return formats_1;
}
var ref;
var hasRequiredRef;
function requireRef() {
  if (hasRequiredRef) return ref;
  hasRequiredRef = 1;
  ref = function generate_ref(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $async, $refCode;
    if ($schema2 == "#" || $schema2 == "#/") {
      if (it.isRoot) {
        $async = it.async;
        $refCode = "validate";
      } else {
        $async = it.root.schema.$async === true;
        $refCode = "root.refVal[0]";
      }
    } else {
      var $refVal = it.resolveRef(it.baseId, $schema2, it.isRoot);
      if ($refVal === void 0) {
        var $message = it.MissingRefError.message(it.baseId, $schema2);
        if (it.opts.missingRefs == "fail") {
          it.logger.error($message);
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: '$ref' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { ref: '" + it.util.escapeQuotes($schema2) + "' } ";
            if (it.opts.messages !== false) {
              out += " , message: 'can\\'t resolve reference " + it.util.escapeQuotes($schema2) + "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: " + it.util.toQuotedString($schema2) + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          if ($breakOnError) {
            out += " if (false) { ";
          }
        } else if (it.opts.missingRefs == "ignore") {
          it.logger.warn($message);
          if ($breakOnError) {
            out += " if (true) { ";
          }
        } else {
          throw new it.MissingRefError(it.baseId, $schema2, $message);
        }
      } else if ($refVal.inline) {
        var $it = it.util.copy(it);
        $it.level++;
        var $nextValid = "valid" + $it.level;
        $it.schema = $refVal.schema;
        $it.schemaPath = "";
        $it.errSchemaPath = $schema2;
        var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
        out += " " + $code + " ";
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
        }
      } else {
        $async = $refVal.$async === true || it.async && $refVal.$async !== false;
        $refCode = $refVal.code;
      }
    }
    if ($refCode) {
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.opts.passContext) {
        out += " " + $refCode + ".call(this, ";
      } else {
        out += " " + $refCode + "( ";
      }
      out += " " + $data + ", (dataPath || '')";
      if (it.errorPath != '""') {
        out += " + " + it.errorPath;
      }
      var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
      out += " , " + $parentData + " , " + $parentDataProperty + ", rootData)  ";
      var __callValidate = out;
      out = $$outStack.pop();
      if ($async) {
        if (!it.async) throw new Error("async schema referenced by sync schema");
        if ($breakOnError) {
          out += " var " + $valid + "; ";
        }
        out += " try { await " + __callValidate + "; ";
        if ($breakOnError) {
          out += " " + $valid + " = true; ";
        }
        out += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ";
        if ($breakOnError) {
          out += " " + $valid + " = false; ";
        }
        out += " } ";
        if ($breakOnError) {
          out += " if (" + $valid + ") { ";
        }
      } else {
        out += " if (!" + __callValidate + ") { if (vErrors === null) vErrors = " + $refCode + ".errors; else vErrors = vErrors.concat(" + $refCode + ".errors); errors = vErrors.length; } ";
        if ($breakOnError) {
          out += " else { ";
        }
      }
    }
    return out;
  };
  return ref;
}
var allOf;
var hasRequiredAllOf;
function requireAllOf() {
  if (hasRequiredAllOf) return allOf;
  hasRequiredAllOf = 1;
  allOf = function generate_allOf(it, $keyword, $ruleType) {
    var out = " ";
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $currentBaseId = $it.baseId, $allSchemasEmpty = true;
    var arr1 = $schema2;
    if (arr1) {
      var $sch, $i = -1, l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
          $allSchemasEmpty = false;
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + "[" + $i + "]";
          $it.errSchemaPath = $errSchemaPath + "/" + $i;
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      }
    }
    if ($breakOnError) {
      if ($allSchemasEmpty) {
        out += " if (true) { ";
      } else {
        out += " " + $closingBraces.slice(0, -1) + " ";
      }
    }
    return out;
  };
  return allOf;
}
var anyOf;
var hasRequiredAnyOf;
function requireAnyOf() {
  if (hasRequiredAnyOf) return anyOf;
  hasRequiredAnyOf = 1;
  anyOf = function generate_anyOf(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $noEmptySchema = $schema2.every(function($sch2) {
      return it.opts.strictKeywords ? typeof $sch2 == "object" && Object.keys($sch2).length > 0 || $sch2 === false : it.util.schemaHasRules($sch2, it.RULES.all);
    });
    if ($noEmptySchema) {
      var $currentBaseId = $it.baseId;
      out += " var " + $errs + " = errors; var " + $valid + " = false;  ";
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      var arr1 = $schema2;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + "[" + $i + "]";
          $it.errSchemaPath = $errSchemaPath + "/" + $i;
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " " + $valid + " = " + $valid + " || " + $nextValid + "; if (!" + $valid + ") { ";
          $closingBraces += "}";
        }
      }
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += " " + $closingBraces + " if (!" + $valid + ") {   var err =   ";
      if (it.createErrors !== false) {
        out += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: 'should match some schema in anyOf' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
      out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
      if (it.opts.allErrors) {
        out += " } ";
      }
    } else {
      if ($breakOnError) {
        out += " if (true) { ";
      }
    }
    return out;
  };
  return anyOf;
}
var comment;
var hasRequiredComment;
function requireComment() {
  if (hasRequiredComment) return comment;
  hasRequiredComment = 1;
  comment = function generate_comment(it, $keyword, $ruleType) {
    var out = " ";
    var $schema2 = it.schema[$keyword];
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    !it.opts.allErrors;
    var $comment = it.util.toQuotedString($schema2);
    if (it.opts.$comment === true) {
      out += " console.log(" + $comment + ");";
    } else if (typeof it.opts.$comment == "function") {
      out += " self._opts.$comment(" + $comment + ", " + it.util.toQuotedString($errSchemaPath) + ", validate.root.schema);";
    }
    return out;
  };
  return comment;
}
var _const;
var hasRequired_const;
function require_const() {
  if (hasRequired_const) return _const;
  hasRequired_const = 1;
  _const = function generate_const(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it.opts.$data && $schema2 && $schema2.$data;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    }
    if (!$isData) {
      out += " var schema" + $lvl + " = validate.schema" + $schemaPath + ";";
    }
    out += "var " + $valid + " = equal(" + $data + ", schema" + $lvl + "); if (!" + $valid + ") {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: 'const' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValue: schema" + $lvl + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should be equal to constant' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " }";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
  return _const;
}
var contains;
var hasRequiredContains;
function requireContains() {
  if (hasRequiredContains) return contains;
  hasRequiredContains = 1;
  contains = function generate_contains(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId, $nonEmptySchema = it.opts.strictKeywords ? typeof $schema2 == "object" && Object.keys($schema2).length > 0 || $schema2 === false : it.util.schemaHasRules($schema2, it.RULES.all);
    out += "var " + $errs + " = errors;var " + $valid + ";";
    if ($nonEmptySchema) {
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      $it.schema = $schema2;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      out += " var " + $nextValid + " = false; for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
      var $passData = $data + "[" + $idx + "]";
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
      } else {
        out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
      }
      out += " if (" + $nextValid + ") break; }  ";
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += " " + $closingBraces + " if (!" + $nextValid + ") {";
    } else {
      out += " if (" + $data + ".length == 0) {";
    }
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: 'contains' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
      if (it.opts.messages !== false) {
        out += " , message: 'should contain a valid item' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " } else { ";
    if ($nonEmptySchema) {
      out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
    }
    if (it.opts.allErrors) {
      out += " } ";
    }
    return out;
  };
  return contains;
}
var dependencies;
var hasRequiredDependencies;
function requireDependencies() {
  if (hasRequiredDependencies) return dependencies;
  hasRequiredDependencies = 1;
  dependencies = function generate_dependencies(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $schemaDeps = {}, $propertyDeps = {}, $ownProperties = it.opts.ownProperties;
    for ($property in $schema2) {
      if ($property == "__proto__") continue;
      var $sch = $schema2[$property];
      var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
      $deps[$property] = $sch;
    }
    out += "var " + $errs + " = errors;";
    var $currentErrorPath = it.errorPath;
    out += "var missing" + $lvl + ";";
    for (var $property in $propertyDeps) {
      $deps = $propertyDeps[$property];
      if ($deps.length) {
        out += " if ( " + $data + it.util.getProperty($property) + " !== undefined ";
        if ($ownProperties) {
          out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
        }
        if ($breakOnError) {
          out += " && ( ";
          var arr1 = $deps;
          if (arr1) {
            var $propertyKey, $i = -1, l1 = arr1.length - 1;
            while ($i < l1) {
              $propertyKey = arr1[$i += 1];
              if ($i) {
                out += " || ";
              }
              var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
              out += " ( ( " + $useData + " === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
              }
              out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
            }
          }
          out += ")) {  ";
          var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
          }
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
            if (it.opts.messages !== false) {
              out += " , message: 'should have ";
              if ($deps.length == 1) {
                out += "property " + it.util.escapeQuotes($deps[0]);
              } else {
                out += "properties " + it.util.escapeQuotes($deps.join(", "));
              }
              out += " when property " + it.util.escapeQuotes($property) + " is present' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
        } else {
          out += " ) { ";
          var arr2 = $deps;
          if (arr2) {
            var $propertyKey, i2 = -1, l2 = arr2.length - 1;
            while (i2 < l2) {
              $propertyKey = arr2[i2 += 1];
              var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
              }
              out += " if ( " + $useData + " === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
              }
              out += ") {  var err =   ";
              if (it.createErrors !== false) {
                out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: 'should have ";
                  if ($deps.length == 1) {
                    out += "property " + it.util.escapeQuotes($deps[0]);
                  } else {
                    out += "properties " + it.util.escapeQuotes($deps.join(", "));
                  }
                  out += " when property " + it.util.escapeQuotes($property) + " is present' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
            }
          }
        }
        out += " }   ";
        if ($breakOnError) {
          $closingBraces += "}";
          out += " else { ";
        }
      }
    }
    it.errorPath = $currentErrorPath;
    var $currentBaseId = $it.baseId;
    for (var $property in $schemaDeps) {
      var $sch = $schemaDeps[$property];
      if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
        out += " " + $nextValid + " = true; if ( " + $data + it.util.getProperty($property) + " !== undefined ";
        if ($ownProperties) {
          out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
        }
        out += ") { ";
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + it.util.getProperty($property);
        $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($property);
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
        out += " }  ";
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
          $closingBraces += "}";
        }
      }
    }
    if ($breakOnError) {
      out += "   " + $closingBraces + " if (" + $errs + " == errors) {";
    }
    return out;
  };
  return dependencies;
}
var _enum;
var hasRequired_enum;
function require_enum() {
  if (hasRequired_enum) return _enum;
  hasRequired_enum = 1;
  _enum = function generate_enum(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it.opts.$data && $schema2 && $schema2.$data;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    }
    var $i = "i" + $lvl, $vSchema = "schema" + $lvl;
    if (!$isData) {
      out += " var " + $vSchema + " = validate.schema" + $schemaPath + ";";
    }
    out += "var " + $valid + ";";
    if ($isData) {
      out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
    }
    out += "" + $valid + " = false;for (var " + $i + "=0; " + $i + "<" + $vSchema + ".length; " + $i + "++) if (equal(" + $data + ", " + $vSchema + "[" + $i + "])) { " + $valid + " = true; break; }";
    if ($isData) {
      out += "  }  ";
    }
    out += " if (!" + $valid + ") {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: 'enum' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValues: schema" + $lvl + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should be equal to one of the allowed values' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " }";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
  return _enum;
}
var format;
var hasRequiredFormat;
function requireFormat() {
  if (hasRequiredFormat) return format;
  hasRequiredFormat = 1;
  format = function generate_format(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    if (it.opts.format === false) {
      if ($breakOnError) {
        out += " if (true) { ";
      }
      return out;
    }
    var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema2;
    }
    var $unknownFormats = it.opts.unknownFormats, $allowUnknown = Array.isArray($unknownFormats);
    if ($isData) {
      var $format = "format" + $lvl, $isObject = "isObject" + $lvl, $formatType = "formatType" + $lvl;
      out += " var " + $format + " = formats[" + $schemaValue + "]; var " + $isObject + " = typeof " + $format + " == 'object' && !(" + $format + " instanceof RegExp) && " + $format + ".validate; var " + $formatType + " = " + $isObject + " && " + $format + ".type || 'string'; if (" + $isObject + ") { ";
      if (it.async) {
        out += " var async" + $lvl + " = " + $format + ".async; ";
      }
      out += " " + $format + " = " + $format + ".validate; } if (  ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
      }
      out += " (";
      if ($unknownFormats != "ignore") {
        out += " (" + $schemaValue + " && !" + $format + " ";
        if ($allowUnknown) {
          out += " && self._opts.unknownFormats.indexOf(" + $schemaValue + ") == -1 ";
        }
        out += ") || ";
      }
      out += " (" + $format + " && " + $formatType + " == '" + $ruleType + "' && !(typeof " + $format + " == 'function' ? ";
      if (it.async) {
        out += " (async" + $lvl + " ? await " + $format + "(" + $data + ") : " + $format + "(" + $data + ")) ";
      } else {
        out += " " + $format + "(" + $data + ") ";
      }
      out += " : " + $format + ".test(" + $data + "))))) {";
    } else {
      var $format = it.formats[$schema2];
      if (!$format) {
        if ($unknownFormats == "ignore") {
          it.logger.warn('unknown format "' + $schema2 + '" ignored in schema at path "' + it.errSchemaPath + '"');
          if ($breakOnError) {
            out += " if (true) { ";
          }
          return out;
        } else if ($allowUnknown && $unknownFormats.indexOf($schema2) >= 0) {
          if ($breakOnError) {
            out += " if (true) { ";
          }
          return out;
        } else {
          throw new Error('unknown format "' + $schema2 + '" is used in schema at path "' + it.errSchemaPath + '"');
        }
      }
      var $isObject = typeof $format == "object" && !($format instanceof RegExp) && $format.validate;
      var $formatType = $isObject && $format.type || "string";
      if ($isObject) {
        var $async = $format.async === true;
        $format = $format.validate;
      }
      if ($formatType != $ruleType) {
        if ($breakOnError) {
          out += " if (true) { ";
        }
        return out;
      }
      if ($async) {
        if (!it.async) throw new Error("async format in sync schema");
        var $formatRef = "formats" + it.util.getProperty($schema2) + ".validate";
        out += " if (!(await " + $formatRef + "(" + $data + "))) { ";
      } else {
        out += " if (! ";
        var $formatRef = "formats" + it.util.getProperty($schema2);
        if ($isObject) $formatRef += ".validate";
        if (typeof $format == "function") {
          out += " " + $formatRef + "(" + $data + ") ";
        } else {
          out += " " + $formatRef + ".test(" + $data + ") ";
        }
        out += ") { ";
      }
    }
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: 'format' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { format:  ";
      if ($isData) {
        out += "" + $schemaValue;
      } else {
        out += "" + it.util.toQuotedString($schema2);
      }
      out += "  } ";
      if (it.opts.messages !== false) {
        out += ` , message: 'should match format "`;
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + it.util.escapeQuotes($schema2);
        }
        out += `"' `;
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + it.util.toQuotedString($schema2);
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " } ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
  return format;
}
var _if;
var hasRequired_if;
function require_if() {
  if (hasRequired_if) return _if;
  hasRequired_if = 1;
  _if = function generate_if(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $thenSch = it.schema["then"], $elseSch = it.schema["else"], $thenPresent = $thenSch !== void 0 && (it.opts.strictKeywords ? typeof $thenSch == "object" && Object.keys($thenSch).length > 0 || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)), $elsePresent = $elseSch !== void 0 && (it.opts.strictKeywords ? typeof $elseSch == "object" && Object.keys($elseSch).length > 0 || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)), $currentBaseId = $it.baseId;
    if ($thenPresent || $elsePresent) {
      var $ifClause;
      $it.createErrors = false;
      $it.schema = $schema2;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      out += " var " + $errs + " = errors; var " + $valid + " = true;  ";
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      out += "  " + it.validate($it) + " ";
      $it.baseId = $currentBaseId;
      $it.createErrors = true;
      out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }  ";
      it.compositeRule = $it.compositeRule = $wasComposite;
      if ($thenPresent) {
        out += " if (" + $nextValid + ") {  ";
        $it.schema = it.schema["then"];
        $it.schemaPath = it.schemaPath + ".then";
        $it.errSchemaPath = it.errSchemaPath + "/then";
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
        out += " " + $valid + " = " + $nextValid + "; ";
        if ($thenPresent && $elsePresent) {
          $ifClause = "ifClause" + $lvl;
          out += " var " + $ifClause + " = 'then'; ";
        } else {
          $ifClause = "'then'";
        }
        out += " } ";
        if ($elsePresent) {
          out += " else { ";
        }
      } else {
        out += " if (!" + $nextValid + ") { ";
      }
      if ($elsePresent) {
        $it.schema = it.schema["else"];
        $it.schemaPath = it.schemaPath + ".else";
        $it.errSchemaPath = it.errSchemaPath + "/else";
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
        out += " " + $valid + " = " + $nextValid + "; ";
        if ($thenPresent && $elsePresent) {
          $ifClause = "ifClause" + $lvl;
          out += " var " + $ifClause + " = 'else'; ";
        } else {
          $ifClause = "'else'";
        }
        out += " } ";
      }
      out += " if (!" + $valid + ") {   var err =   ";
      if (it.createErrors !== false) {
        out += " { keyword: 'if' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { failingKeyword: " + $ifClause + " } ";
        if (it.opts.messages !== false) {
          out += ` , message: 'should match "' + ` + $ifClause + ` + '" schema' `;
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
      out += " }   ";
      if ($breakOnError) {
        out += " else { ";
      }
    } else {
      if ($breakOnError) {
        out += " if (true) { ";
      }
    }
    return out;
  };
  return _if;
}
var items;
var hasRequiredItems;
function requireItems() {
  if (hasRequiredItems) return items;
  hasRequiredItems = 1;
  items = function generate_items(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId;
    out += "var " + $errs + " = errors;var " + $valid + ";";
    if (Array.isArray($schema2)) {
      var $additionalItems = it.schema.additionalItems;
      if ($additionalItems === false) {
        out += " " + $valid + " = " + $data + ".length <= " + $schema2.length + "; ";
        var $currErrSchemaPath = $errSchemaPath;
        $errSchemaPath = it.errSchemaPath + "/additionalItems";
        out += "  if (!" + $valid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schema2.length + " } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT have more than " + $schema2.length + " items' ";
          }
          if (it.opts.verbose) {
            out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } ";
        $errSchemaPath = $currErrSchemaPath;
        if ($breakOnError) {
          $closingBraces += "}";
          out += " else { ";
        }
      }
      var arr1 = $schema2;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
            out += " " + $nextValid + " = true; if (" + $data + ".length > " + $i + ") { ";
            var $passData = $data + "[" + $i + "]";
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
            $it.dataPathArr[$dataNxt] = $i;
            var $code = it.validate($it);
            $it.baseId = $currentBaseId;
            if (it.util.varOccurences($code, $nextData) < 2) {
              out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
            } else {
              out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
            }
            out += " }  ";
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
      if (typeof $additionalItems == "object" && (it.opts.strictKeywords ? typeof $additionalItems == "object" && Object.keys($additionalItems).length > 0 || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
        $it.schema = $additionalItems;
        $it.schemaPath = it.schemaPath + ".additionalItems";
        $it.errSchemaPath = it.errSchemaPath + "/additionalItems";
        out += " " + $nextValid + " = true; if (" + $data + ".length > " + $schema2.length + ") {  for (var " + $idx + " = " + $schema2.length + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        if ($breakOnError) {
          out += " if (!" + $nextValid + ") break; ";
        }
        out += " } }  ";
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
          $closingBraces += "}";
        }
      }
    } else if (it.opts.strictKeywords ? typeof $schema2 == "object" && Object.keys($schema2).length > 0 || $schema2 === false : it.util.schemaHasRules($schema2, it.RULES.all)) {
      $it.schema = $schema2;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      out += "  for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
      var $passData = $data + "[" + $idx + "]";
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
      } else {
        out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
      }
      if ($breakOnError) {
        out += " if (!" + $nextValid + ") break; ";
      }
      out += " }";
    }
    if ($breakOnError) {
      out += " " + $closingBraces + " if (" + $errs + " == errors) {";
    }
    return out;
  };
  return items;
}
var _limit;
var hasRequired_limit;
function require_limit() {
  if (hasRequired_limit) return _limit;
  hasRequired_limit = 1;
  _limit = function generate__limit(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema2;
    }
    var $isMax = $keyword == "maximum", $exclusiveKeyword = $isMax ? "exclusiveMaximum" : "exclusiveMinimum", $schemaExcl = it.schema[$exclusiveKeyword], $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? "<" : ">", $notOp = $isMax ? ">" : "<", $errorKeyword = void 0;
    if (!($isData || typeof $schema2 == "number" || $schema2 === void 0)) {
      throw new Error($keyword + " must be number");
    }
    if (!($isDataExcl || $schemaExcl === void 0 || typeof $schemaExcl == "number" || typeof $schemaExcl == "boolean")) {
      throw new Error($exclusiveKeyword + " must be number or boolean");
    }
    if ($isDataExcl) {
      var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr), $exclusive = "exclusive" + $lvl, $exclType = "exclType" + $lvl, $exclIsNumber = "exclIsNumber" + $lvl, $opExpr = "op" + $lvl, $opStr = "' + " + $opExpr + " + '";
      out += " var schemaExcl" + $lvl + " = " + $schemaValueExcl + "; ";
      $schemaValueExcl = "schemaExcl" + $lvl;
      out += " var " + $exclusive + "; var " + $exclType + " = typeof " + $schemaValueExcl + "; if (" + $exclType + " != 'boolean' && " + $exclType + " != 'undefined' && " + $exclType + " != 'number') { ";
      var $errorKeyword = $exclusiveKeyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: '" + $exclusiveKeyword + " should be boolean' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } else if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " " + $exclType + " == 'number' ? ( (" + $exclusive + " = " + $schemaValue + " === undefined || " + $schemaValueExcl + " " + $op + "= " + $schemaValue + ") ? " + $data + " " + $notOp + "= " + $schemaValueExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) : ( (" + $exclusive + " = " + $schemaValueExcl + " === true) ? " + $data + " " + $notOp + "= " + $schemaValue + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { var op" + $lvl + " = " + $exclusive + " ? '" + $op + "' : '" + $op + "='; ";
      if ($schema2 === void 0) {
        $errorKeyword = $exclusiveKeyword;
        $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
        $schemaValue = $schemaValueExcl;
        $isData = $isDataExcl;
      }
    } else {
      var $exclIsNumber = typeof $schemaExcl == "number", $opStr = $op;
      if ($exclIsNumber && $isData) {
        var $opExpr = "'" + $opStr + "'";
        out += " if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        out += " ( " + $schemaValue + " === undefined || " + $schemaExcl + " " + $op + "= " + $schemaValue + " ? " + $data + " " + $notOp + "= " + $schemaExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { ";
      } else {
        if ($exclIsNumber && $schema2 === void 0) {
          $exclusive = true;
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
          $schemaValue = $schemaExcl;
          $notOp += "=";
        } else {
          if ($exclIsNumber) $schemaValue = Math[$isMax ? "min" : "max"]($schemaExcl, $schema2);
          if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
            $exclusive = true;
            $errorKeyword = $exclusiveKeyword;
            $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
            $notOp += "=";
          } else {
            $exclusive = false;
            $opStr += "=";
          }
        }
        var $opExpr = "'" + $opStr + "'";
        out += " if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        out += " " + $data + " " + $notOp + " " + $schemaValue + " || " + $data + " !== " + $data + ") { ";
      }
    }
    $errorKeyword = $errorKeyword || $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "_limit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { comparison: " + $opExpr + ", limit: " + $schemaValue + ", exclusive: " + $exclusive + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should be " + $opStr + " ";
        if ($isData) {
          out += "' + " + $schemaValue;
        } else {
          out += "" + $schemaValue + "'";
        }
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema2;
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " } ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
  return _limit;
}
var _limitItems;
var hasRequired_limitItems;
function require_limitItems() {
  if (hasRequired_limitItems) return _limitItems;
  hasRequired_limitItems = 1;
  _limitItems = function generate__limitItems(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema2;
    }
    if (!($isData || typeof $schema2 == "number")) {
      throw new Error($keyword + " must be number");
    }
    var $op = $keyword == "maxItems" ? ">" : "<";
    out += "if ( ";
    if ($isData) {
      out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
    }
    out += " " + $data + ".length " + $op + " " + $schemaValue + ") { ";
    var $errorKeyword = $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "_limitItems") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should NOT have ";
        if ($keyword == "maxItems") {
          out += "more";
        } else {
          out += "fewer";
        }
        out += " than ";
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + $schema2;
        }
        out += " items' ";
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema2;
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
  return _limitItems;
}
var _limitLength;
var hasRequired_limitLength;
function require_limitLength() {
  if (hasRequired_limitLength) return _limitLength;
  hasRequired_limitLength = 1;
  _limitLength = function generate__limitLength(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema2;
    }
    if (!($isData || typeof $schema2 == "number")) {
      throw new Error($keyword + " must be number");
    }
    var $op = $keyword == "maxLength" ? ">" : "<";
    out += "if ( ";
    if ($isData) {
      out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
    }
    if (it.opts.unicode === false) {
      out += " " + $data + ".length ";
    } else {
      out += " ucs2length(" + $data + ") ";
    }
    out += " " + $op + " " + $schemaValue + ") { ";
    var $errorKeyword = $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "_limitLength") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should NOT be ";
        if ($keyword == "maxLength") {
          out += "longer";
        } else {
          out += "shorter";
        }
        out += " than ";
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + $schema2;
        }
        out += " characters' ";
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema2;
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
  return _limitLength;
}
var _limitProperties;
var hasRequired_limitProperties;
function require_limitProperties() {
  if (hasRequired_limitProperties) return _limitProperties;
  hasRequired_limitProperties = 1;
  _limitProperties = function generate__limitProperties(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema2;
    }
    if (!($isData || typeof $schema2 == "number")) {
      throw new Error($keyword + " must be number");
    }
    var $op = $keyword == "maxProperties" ? ">" : "<";
    out += "if ( ";
    if ($isData) {
      out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
    }
    out += " Object.keys(" + $data + ").length " + $op + " " + $schemaValue + ") { ";
    var $errorKeyword = $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "_limitProperties") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should NOT have ";
        if ($keyword == "maxProperties") {
          out += "more";
        } else {
          out += "fewer";
        }
        out += " than ";
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + $schema2;
        }
        out += " properties' ";
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema2;
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
  return _limitProperties;
}
var multipleOf;
var hasRequiredMultipleOf;
function requireMultipleOf() {
  if (hasRequiredMultipleOf) return multipleOf;
  hasRequiredMultipleOf = 1;
  multipleOf = function generate_multipleOf(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema2;
    }
    if (!($isData || typeof $schema2 == "number")) {
      throw new Error($keyword + " must be number");
    }
    out += "var division" + $lvl + ";if (";
    if ($isData) {
      out += " " + $schemaValue + " !== undefined && ( typeof " + $schemaValue + " != 'number' || ";
    }
    out += " (division" + $lvl + " = " + $data + " / " + $schemaValue + ", ";
    if (it.opts.multipleOfPrecision) {
      out += " Math.abs(Math.round(division" + $lvl + ") - division" + $lvl + ") > 1e-" + it.opts.multipleOfPrecision + " ";
    } else {
      out += " division" + $lvl + " !== parseInt(division" + $lvl + ") ";
    }
    out += " ) ";
    if ($isData) {
      out += "  )  ";
    }
    out += " ) {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { multipleOf: " + $schemaValue + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should be multiple of ";
        if ($isData) {
          out += "' + " + $schemaValue;
        } else {
          out += "" + $schemaValue + "'";
        }
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema2;
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
  return multipleOf;
}
var not;
var hasRequiredNot;
function requireNot() {
  if (hasRequiredNot) return not;
  hasRequiredNot = 1;
  not = function generate_not(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    $it.level++;
    var $nextValid = "valid" + $it.level;
    if (it.opts.strictKeywords ? typeof $schema2 == "object" && Object.keys($schema2).length > 0 || $schema2 === false : it.util.schemaHasRules($schema2, it.RULES.all)) {
      $it.schema = $schema2;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      out += " var " + $errs + " = errors;  ";
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      $it.createErrors = false;
      var $allErrorsOption;
      if ($it.opts.allErrors) {
        $allErrorsOption = $it.opts.allErrors;
        $it.opts.allErrors = false;
      }
      out += " " + it.validate($it) + " ";
      $it.createErrors = true;
      if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += " if (" + $nextValid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT be valid' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
      if (it.opts.allErrors) {
        out += " } ";
      }
    } else {
      out += "  var err =   ";
      if (it.createErrors !== false) {
        out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT be valid' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if ($breakOnError) {
        out += " if (false) { ";
      }
    }
    return out;
  };
  return not;
}
var oneOf;
var hasRequiredOneOf;
function requireOneOf() {
  if (hasRequiredOneOf) return oneOf;
  hasRequiredOneOf = 1;
  oneOf = function generate_oneOf(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $currentBaseId = $it.baseId, $prevValid = "prevValid" + $lvl, $passingSchemas = "passingSchemas" + $lvl;
    out += "var " + $errs + " = errors , " + $prevValid + " = false , " + $valid + " = false , " + $passingSchemas + " = null; ";
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var arr1 = $schema2;
    if (arr1) {
      var $sch, $i = -1, l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + "[" + $i + "]";
          $it.errSchemaPath = $errSchemaPath + "/" + $i;
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
        } else {
          out += " var " + $nextValid + " = true; ";
        }
        if ($i) {
          out += " if (" + $nextValid + " && " + $prevValid + ") { " + $valid + " = false; " + $passingSchemas + " = [" + $passingSchemas + ", " + $i + "]; } else { ";
          $closingBraces += "}";
        }
        out += " if (" + $nextValid + ") { " + $valid + " = " + $prevValid + " = true; " + $passingSchemas + " = " + $i + "; }";
      }
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += "" + $closingBraces + "if (!" + $valid + ") {   var err =   ";
    if (it.createErrors !== false) {
      out += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { passingSchemas: " + $passingSchemas + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should match exactly one schema in oneOf' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError(vErrors); ";
      } else {
        out += " validate.errors = vErrors; return false; ";
      }
    }
    out += "} else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }";
    if (it.opts.allErrors) {
      out += " } ";
    }
    return out;
  };
  return oneOf;
}
var pattern;
var hasRequiredPattern;
function requirePattern() {
  if (hasRequiredPattern) return pattern;
  hasRequiredPattern = 1;
  pattern = function generate_pattern(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema2;
    }
    var $regexp = $isData ? "(new RegExp(" + $schemaValue + "))" : it.usePattern($schema2);
    out += "if ( ";
    if ($isData) {
      out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
    }
    out += " !" + $regexp + ".test(" + $data + ") ) {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { pattern:  ";
      if ($isData) {
        out += "" + $schemaValue;
      } else {
        out += "" + it.util.toQuotedString($schema2);
      }
      out += "  } ";
      if (it.opts.messages !== false) {
        out += ` , message: 'should match pattern "`;
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + it.util.escapeQuotes($schema2);
        }
        out += `"' `;
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + it.util.toQuotedString($schema2);
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
  return pattern;
}
var properties$l;
var hasRequiredProperties;
function requireProperties() {
  if (hasRequiredProperties) return properties$l;
  hasRequiredProperties = 1;
  properties$l = function generate_properties(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $key = "key" + $lvl, $idx = "idx" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl;
    var $schemaKeys = Object.keys($schema2 || {}).filter(notProto), $pProperties = it.schema.patternProperties || {}, $pPropertyKeys = Object.keys($pProperties).filter(notProto), $aProperties = it.schema.additionalProperties, $someProperties = $schemaKeys.length || $pPropertyKeys.length, $noAdditional = $aProperties === false, $additionalIsSchema = typeof $aProperties == "object" && Object.keys($aProperties).length, $removeAdditional = it.opts.removeAdditional, $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
    var $required = it.schema.required;
    if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) {
      var $requiredHash = it.util.toHash($required);
    }
    function notProto(p) {
      return p !== "__proto__";
    }
    out += "var " + $errs + " = errors;var " + $nextValid + " = true;";
    if ($ownProperties) {
      out += " var " + $dataProperties + " = undefined;";
    }
    if ($checkAdditional) {
      if ($ownProperties) {
        out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
      } else {
        out += " for (var " + $key + " in " + $data + ") { ";
      }
      if ($someProperties) {
        out += " var isAdditional" + $lvl + " = !(false ";
        if ($schemaKeys.length) {
          if ($schemaKeys.length > 8) {
            out += " || validate.schema" + $schemaPath + ".hasOwnProperty(" + $key + ") ";
          } else {
            var arr1 = $schemaKeys;
            if (arr1) {
              var $propertyKey, i1 = -1, l1 = arr1.length - 1;
              while (i1 < l1) {
                $propertyKey = arr1[i1 += 1];
                out += " || " + $key + " == " + it.util.toQuotedString($propertyKey) + " ";
              }
            }
          }
        }
        if ($pPropertyKeys.length) {
          var arr2 = $pPropertyKeys;
          if (arr2) {
            var $pProperty, $i = -1, l2 = arr2.length - 1;
            while ($i < l2) {
              $pProperty = arr2[$i += 1];
              out += " || " + it.usePattern($pProperty) + ".test(" + $key + ") ";
            }
          }
        }
        out += " ); if (isAdditional" + $lvl + ") { ";
      }
      if ($removeAdditional == "all") {
        out += " delete " + $data + "[" + $key + "]; ";
      } else {
        var $currentErrorPath = it.errorPath;
        var $additionalProperty = "' + " + $key + " + '";
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
        }
        if ($noAdditional) {
          if ($removeAdditional) {
            out += " delete " + $data + "[" + $key + "]; ";
          } else {
            out += " " + $nextValid + " = false; ";
            var $currErrSchemaPath = $errSchemaPath;
            $errSchemaPath = it.errSchemaPath + "/additionalProperties";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { additionalProperty: '" + $additionalProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is an invalid additional property";
                } else {
                  out += "should NOT have additional properties";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            $errSchemaPath = $currErrSchemaPath;
            if ($breakOnError) {
              out += " break; ";
            }
          }
        } else if ($additionalIsSchema) {
          if ($removeAdditional == "failing") {
            out += " var " + $errs + " = errors;  ";
            var $wasComposite = it.compositeRule;
            it.compositeRule = $it.compositeRule = true;
            $it.schema = $aProperties;
            $it.schemaPath = it.schemaPath + ".additionalProperties";
            $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
            $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
            var $passData = $data + "[" + $key + "]";
            $it.dataPathArr[$dataNxt] = $key;
            var $code = it.validate($it);
            $it.baseId = $currentBaseId;
            if (it.util.varOccurences($code, $nextData) < 2) {
              out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
            } else {
              out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
            }
            out += " if (!" + $nextValid + ") { errors = " + $errs + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + $data + "[" + $key + "]; }  ";
            it.compositeRule = $it.compositeRule = $wasComposite;
          } else {
            $it.schema = $aProperties;
            $it.schemaPath = it.schemaPath + ".additionalProperties";
            $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
            $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
            var $passData = $data + "[" + $key + "]";
            $it.dataPathArr[$dataNxt] = $key;
            var $code = it.validate($it);
            $it.baseId = $currentBaseId;
            if (it.util.varOccurences($code, $nextData) < 2) {
              out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
            } else {
              out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
            }
            if ($breakOnError) {
              out += " if (!" + $nextValid + ") break; ";
            }
          }
        }
        it.errorPath = $currentErrorPath;
      }
      if ($someProperties) {
        out += " } ";
      }
      out += " }  ";
      if ($breakOnError) {
        out += " if (" + $nextValid + ") { ";
        $closingBraces += "}";
      }
    }
    var $useDefaults = it.opts.useDefaults && !it.compositeRule;
    if ($schemaKeys.length) {
      var arr3 = $schemaKeys;
      if (arr3) {
        var $propertyKey, i3 = -1, l3 = arr3.length - 1;
        while (i3 < l3) {
          $propertyKey = arr3[i3 += 1];
          var $sch = $schema2[$propertyKey];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
            var $prop = it.util.getProperty($propertyKey), $passData = $data + $prop, $hasDefault = $useDefaults && $sch.default !== void 0;
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + $prop;
            $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($propertyKey);
            $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
            $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
            var $code = it.validate($it);
            $it.baseId = $currentBaseId;
            if (it.util.varOccurences($code, $nextData) < 2) {
              $code = it.util.varReplace($code, $nextData, $passData);
              var $useData = $passData;
            } else {
              var $useData = $nextData;
              out += " var " + $nextData + " = " + $passData + "; ";
            }
            if ($hasDefault) {
              out += " " + $code + " ";
            } else {
              if ($requiredHash && $requiredHash[$propertyKey]) {
                out += " if ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") { " + $nextValid + " = false; ";
                var $currentErrorPath = it.errorPath, $currErrSchemaPath = $errSchemaPath, $missingProperty = it.util.escapeQuotes($propertyKey);
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                }
                $errSchemaPath = it.errSchemaPath + "/required";
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = "";
                if (it.createErrors !== false) {
                  out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: '";
                    if (it.opts._errorDataPathProperty) {
                      out += "is a required property";
                    } else {
                      out += "should have required property \\'" + $missingProperty + "\\'";
                    }
                    out += "' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                  if (it.async) {
                    out += " throw new ValidationError([" + __err + "]); ";
                  } else {
                    out += " validate.errors = [" + __err + "]; return false; ";
                  }
                } else {
                  out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                }
                $errSchemaPath = $currErrSchemaPath;
                it.errorPath = $currentErrorPath;
                out += " } else { ";
              } else {
                if ($breakOnError) {
                  out += " if ( " + $useData + " === undefined ";
                  if ($ownProperties) {
                    out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += ") { " + $nextValid + " = true; } else { ";
                } else {
                  out += " if (" + $useData + " !== undefined ";
                  if ($ownProperties) {
                    out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += " ) { ";
                }
              }
              out += " " + $code + " } ";
            }
          }
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      }
    }
    if ($pPropertyKeys.length) {
      var arr4 = $pPropertyKeys;
      if (arr4) {
        var $pProperty, i4 = -1, l4 = arr4.length - 1;
        while (i4 < l4) {
          $pProperty = arr4[i4 += 1];
          var $sch = $pProperties[$pProperty];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
            $it.schema = $sch;
            $it.schemaPath = it.schemaPath + ".patternProperties" + it.util.getProperty($pProperty);
            $it.errSchemaPath = it.errSchemaPath + "/patternProperties/" + it.util.escapeFragment($pProperty);
            if ($ownProperties) {
              out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
            } else {
              out += " for (var " + $key + " in " + $data + ") { ";
            }
            out += " if (" + it.usePattern($pProperty) + ".test(" + $key + ")) { ";
            $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
            var $passData = $data + "[" + $key + "]";
            $it.dataPathArr[$dataNxt] = $key;
            var $code = it.validate($it);
            $it.baseId = $currentBaseId;
            if (it.util.varOccurences($code, $nextData) < 2) {
              out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
            } else {
              out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
            }
            if ($breakOnError) {
              out += " if (!" + $nextValid + ") break; ";
            }
            out += " } ";
            if ($breakOnError) {
              out += " else " + $nextValid + " = true; ";
            }
            out += " }  ";
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
    }
    if ($breakOnError) {
      out += " " + $closingBraces + " if (" + $errs + " == errors) {";
    }
    return out;
  };
  return properties$l;
}
var propertyNames;
var hasRequiredPropertyNames;
function requirePropertyNames() {
  if (hasRequiredPropertyNames) return propertyNames;
  hasRequiredPropertyNames = 1;
  propertyNames = function generate_propertyNames(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    out += "var " + $errs + " = errors;";
    if (it.opts.strictKeywords ? typeof $schema2 == "object" && Object.keys($schema2).length > 0 || $schema2 === false : it.util.schemaHasRules($schema2, it.RULES.all)) {
      $it.schema = $schema2;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      var $key = "key" + $lvl, $idx = "idx" + $lvl, $i = "i" + $lvl, $invalidName = "' + " + $key + " + '", $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
      if ($ownProperties) {
        out += " var " + $dataProperties + " = undefined; ";
      }
      if ($ownProperties) {
        out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
      } else {
        out += " for (var " + $key + " in " + $data + ") { ";
      }
      out += " var startErrs" + $lvl + " = errors; ";
      var $passData = $key;
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
      } else {
        out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
      }
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += " if (!" + $nextValid + ") { for (var " + $i + "=startErrs" + $lvl + "; " + $i + "<errors; " + $i + "++) { vErrors[" + $i + "].propertyName = " + $key + "; }   var err =   ";
      if (it.createErrors !== false) {
        out += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { propertyName: '" + $invalidName + "' } ";
        if (it.opts.messages !== false) {
          out += " , message: 'property name \\'" + $invalidName + "\\' is invalid' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
      if ($breakOnError) {
        out += " break; ";
      }
      out += " } }";
    }
    if ($breakOnError) {
      out += " " + $closingBraces + " if (" + $errs + " == errors) {";
    }
    return out;
  };
  return propertyNames;
}
var required$h;
var hasRequiredRequired;
function requireRequired() {
  if (hasRequiredRequired) return required$h;
  hasRequiredRequired = 1;
  required$h = function generate_required(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it.opts.$data && $schema2 && $schema2.$data;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    }
    var $vSchema = "schema" + $lvl;
    if (!$isData) {
      if ($schema2.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
        var $required = [];
        var arr1 = $schema2;
        if (arr1) {
          var $property, i1 = -1, l1 = arr1.length - 1;
          while (i1 < l1) {
            $property = arr1[i1 += 1];
            var $propertySch = it.schema.properties[$property];
            if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == "object" && Object.keys($propertySch).length > 0 || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
              $required[$required.length] = $property;
            }
          }
        }
      } else {
        var $required = $schema2;
      }
    }
    if ($isData || $required.length) {
      var $currentErrorPath = it.errorPath, $loopRequired = $isData || $required.length >= it.opts.loopRequired, $ownProperties = it.opts.ownProperties;
      if ($breakOnError) {
        out += " var missing" + $lvl + "; ";
        if ($loopRequired) {
          if (!$isData) {
            out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
          }
          var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
          }
          out += " var " + $valid + " = true; ";
          if ($isData) {
            out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
          }
          out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { " + $valid + " = " + $data + "[" + $vSchema + "[" + $i + "]] !== undefined ";
          if ($ownProperties) {
            out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
          }
          out += "; if (!" + $valid + ") break; } ";
          if ($isData) {
            out += "  }  ";
          }
          out += "  if (!" + $valid + ") {   ";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
            if (it.opts.messages !== false) {
              out += " , message: '";
              if (it.opts._errorDataPathProperty) {
                out += "is a required property";
              } else {
                out += "should have required property \\'" + $missingProperty + "\\'";
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } else { ";
        } else {
          out += " if ( ";
          var arr2 = $required;
          if (arr2) {
            var $propertyKey, $i = -1, l2 = arr2.length - 1;
            while ($i < l2) {
              $propertyKey = arr2[$i += 1];
              if ($i) {
                out += " || ";
              }
              var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
              out += " ( ( " + $useData + " === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
              }
              out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
            }
          }
          out += ") {  ";
          var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
          }
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
            if (it.opts.messages !== false) {
              out += " , message: '";
              if (it.opts._errorDataPathProperty) {
                out += "is a required property";
              } else {
                out += "should have required property \\'" + $missingProperty + "\\'";
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } else { ";
        }
      } else {
        if ($loopRequired) {
          if (!$isData) {
            out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
          }
          var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
          }
          if ($isData) {
            out += " if (" + $vSchema + " && !Array.isArray(" + $vSchema + ")) {  var err =   ";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + $vSchema + " !== undefined) { ";
          }
          out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { if (" + $data + "[" + $vSchema + "[" + $i + "]] === undefined ";
          if ($ownProperties) {
            out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
          }
          out += ") {  var err =   ";
          if (it.createErrors !== false) {
            out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
            if (it.opts.messages !== false) {
              out += " , message: '";
              if (it.opts._errorDataPathProperty) {
                out += "is a required property";
              } else {
                out += "should have required property \\'" + $missingProperty + "\\'";
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ";
          if ($isData) {
            out += "  }  ";
          }
        } else {
          var arr3 = $required;
          if (arr3) {
            var $propertyKey, i3 = -1, l3 = arr3.length - 1;
            while (i3 < l3) {
              $propertyKey = arr3[i3 += 1];
              var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
              }
              out += " if ( " + $useData + " === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
              }
              out += ") {  var err =   ";
              if (it.createErrors !== false) {
                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is a required property";
                  } else {
                    out += "should have required property \\'" + $missingProperty + "\\'";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
            }
          }
        }
      }
      it.errorPath = $currentErrorPath;
    } else if ($breakOnError) {
      out += " if (true) {";
    }
    return out;
  };
  return required$h;
}
var uniqueItems;
var hasRequiredUniqueItems;
function requireUniqueItems() {
  if (hasRequiredUniqueItems) return uniqueItems;
  hasRequiredUniqueItems = 1;
  uniqueItems = function generate_uniqueItems(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema2;
    }
    if (($schema2 || $isData) && it.opts.uniqueItems !== false) {
      if ($isData) {
        out += " var " + $valid + "; if (" + $schemaValue + " === false || " + $schemaValue + " === undefined) " + $valid + " = true; else if (typeof " + $schemaValue + " != 'boolean') " + $valid + " = false; else { ";
      }
      out += " var i = " + $data + ".length , " + $valid + " = true , j; if (i > 1) { ";
      var $itemType = it.schema.items && it.schema.items.type, $typeIsArray = Array.isArray($itemType);
      if (!$itemType || $itemType == "object" || $itemType == "array" || $typeIsArray && ($itemType.indexOf("object") >= 0 || $itemType.indexOf("array") >= 0)) {
        out += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + $data + "[i], " + $data + "[j])) { " + $valid + " = false; break outer; } } } ";
      } else {
        out += " var itemIndices = {}, item; for (;i--;) { var item = " + $data + "[i]; ";
        var $method = "checkDataType" + ($typeIsArray ? "s" : "");
        out += " if (" + it.util[$method]($itemType, "item", it.opts.strictNumbers, true) + ") continue; ";
        if ($typeIsArray) {
          out += ` if (typeof item == 'string') item = '"' + item; `;
        }
        out += " if (typeof itemIndices[item] == 'number') { " + $valid + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
      }
      out += " } ";
      if ($isData) {
        out += "  }  ";
      }
      out += " if (!" + $valid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { i: i, j: j } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema2;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
    } else {
      if ($breakOnError) {
        out += " if (true) { ";
      }
    }
    return out;
  };
  return uniqueItems;
}
var dotjs;
var hasRequiredDotjs;
function requireDotjs() {
  if (hasRequiredDotjs) return dotjs;
  hasRequiredDotjs = 1;
  dotjs = {
    "$ref": requireRef(),
    allOf: requireAllOf(),
    anyOf: requireAnyOf(),
    "$comment": requireComment(),
    const: require_const(),
    contains: requireContains(),
    dependencies: requireDependencies(),
    "enum": require_enum(),
    format: requireFormat(),
    "if": require_if(),
    items: requireItems(),
    maximum: require_limit(),
    minimum: require_limit(),
    maxItems: require_limitItems(),
    minItems: require_limitItems(),
    maxLength: require_limitLength(),
    minLength: require_limitLength(),
    maxProperties: require_limitProperties(),
    minProperties: require_limitProperties(),
    multipleOf: requireMultipleOf(),
    not: requireNot(),
    oneOf: requireOneOf(),
    pattern: requirePattern(),
    properties: requireProperties(),
    propertyNames: requirePropertyNames(),
    required: requireRequired(),
    uniqueItems: requireUniqueItems(),
    validate: requireValidate()
  };
  return dotjs;
}
var rules;
var hasRequiredRules;
function requireRules() {
  if (hasRequiredRules) return rules;
  hasRequiredRules = 1;
  var ruleModules = requireDotjs(), toHash = requireUtil().toHash;
  rules = function rules2() {
    var RULES = [
      {
        type: "number",
        rules: [
          { "maximum": ["exclusiveMaximum"] },
          { "minimum": ["exclusiveMinimum"] },
          "multipleOf",
          "format"
        ]
      },
      {
        type: "string",
        rules: ["maxLength", "minLength", "pattern", "format"]
      },
      {
        type: "array",
        rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"]
      },
      {
        type: "object",
        rules: [
          "maxProperties",
          "minProperties",
          "required",
          "dependencies",
          "propertyNames",
          { "properties": ["additionalProperties", "patternProperties"] }
        ]
      },
      { rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"] }
    ];
    var ALL = ["type", "$comment"];
    var KEYWORDS = [
      "$schema",
      "$id",
      "id",
      "$data",
      "$async",
      "title",
      "description",
      "default",
      "definitions",
      "examples",
      "readOnly",
      "writeOnly",
      "contentMediaType",
      "contentEncoding",
      "additionalItems",
      "then",
      "else"
    ];
    var TYPES = ["number", "integer", "string", "array", "object", "boolean", "null"];
    RULES.all = toHash(ALL);
    RULES.types = toHash(TYPES);
    RULES.forEach(function(group) {
      group.rules = group.rules.map(function(keyword2) {
        var implKeywords;
        if (typeof keyword2 == "object") {
          var key2 = Object.keys(keyword2)[0];
          implKeywords = keyword2[key2];
          keyword2 = key2;
          implKeywords.forEach(function(k) {
            ALL.push(k);
            RULES.all[k] = true;
          });
        }
        ALL.push(keyword2);
        var rule = RULES.all[keyword2] = {
          keyword: keyword2,
          code: ruleModules[keyword2],
          implements: implKeywords
        };
        return rule;
      });
      RULES.all.$comment = {
        keyword: "$comment",
        code: ruleModules.$comment
      };
      if (group.type) RULES.types[group.type] = group;
    });
    RULES.keywords = toHash(ALL.concat(KEYWORDS));
    RULES.custom = {};
    return RULES;
  };
  return rules;
}
var data;
var hasRequiredData;
function requireData() {
  if (hasRequiredData) return data;
  hasRequiredData = 1;
  var KEYWORDS = [
    "multipleOf",
    "maximum",
    "exclusiveMaximum",
    "minimum",
    "exclusiveMinimum",
    "maxLength",
    "minLength",
    "pattern",
    "additionalItems",
    "maxItems",
    "minItems",
    "uniqueItems",
    "maxProperties",
    "minProperties",
    "required",
    "additionalProperties",
    "enum",
    "format",
    "const"
  ];
  data = function(metaSchema, keywordsJsonPointers) {
    for (var i = 0; i < keywordsJsonPointers.length; i++) {
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      var segments = keywordsJsonPointers[i].split("/");
      var keywords = metaSchema;
      var j;
      for (j = 1; j < segments.length; j++)
        keywords = keywords[segments[j]];
      for (j = 0; j < KEYWORDS.length; j++) {
        var key2 = KEYWORDS[j];
        var schema = keywords[key2];
        if (schema) {
          keywords[key2] = {
            anyOf: [
              schema,
              { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
            ]
          };
        }
      }
    }
    return metaSchema;
  };
  return data;
}
var async;
var hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async;
  hasRequiredAsync = 1;
  var MissingRefError = requireError_classes().MissingRef;
  async = compileAsync;
  function compileAsync(schema, meta, callback) {
    var self2 = this;
    if (typeof this._opts.loadSchema != "function")
      throw new Error("options.loadSchema should be a function");
    if (typeof meta == "function") {
      callback = meta;
      meta = void 0;
    }
    var p = loadMetaSchemaOf(schema).then(function() {
      var schemaObj = self2._addSchema(schema, void 0, meta);
      return schemaObj.validate || _compileAsync(schemaObj);
    });
    if (callback) {
      p.then(
        function(v) {
          callback(null, v);
        },
        callback
      );
    }
    return p;
    function loadMetaSchemaOf(sch) {
      var $schema2 = sch.$schema;
      return $schema2 && !self2.getSchema($schema2) ? compileAsync.call(self2, { $ref: $schema2 }, true) : Promise.resolve();
    }
    function _compileAsync(schemaObj) {
      try {
        return self2._compile(schemaObj);
      } catch (e) {
        if (e instanceof MissingRefError) return loadMissingSchema(e);
        throw e;
      }
      function loadMissingSchema(e) {
        var ref2 = e.missingSchema;
        if (added(ref2)) throw new Error("Schema " + ref2 + " is loaded but " + e.missingRef + " cannot be resolved");
        var schemaPromise = self2._loadingSchemas[ref2];
        if (!schemaPromise) {
          schemaPromise = self2._loadingSchemas[ref2] = self2._opts.loadSchema(ref2);
          schemaPromise.then(removePromise, removePromise);
        }
        return schemaPromise.then(function(sch) {
          if (!added(ref2)) {
            return loadMetaSchemaOf(sch).then(function() {
              if (!added(ref2)) self2.addSchema(sch, ref2, void 0, meta);
            });
          }
        }).then(function() {
          return _compileAsync(schemaObj);
        });
        function removePromise() {
          delete self2._loadingSchemas[ref2];
        }
        function added(ref3) {
          return self2._refs[ref3] || self2._schemas[ref3];
        }
      }
    }
  }
  return async;
}
var custom;
var hasRequiredCustom;
function requireCustom() {
  if (hasRequiredCustom) return custom;
  hasRequiredCustom = 1;
  custom = function generate_custom(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema2;
    }
    var $rule = this, $definition = "definition" + $lvl, $rDef = $rule.definition, $closingBraces = "";
    var $compile, $inline, $macro, $ruleValidate, $validateCode;
    if ($isData && $rDef.$data) {
      $validateCode = "keywordValidate" + $lvl;
      var $validateSchema = $rDef.validateSchema;
      out += " var " + $definition + " = RULES.custom['" + $keyword + "'].definition; var " + $validateCode + " = " + $definition + ".validate;";
    } else {
      $ruleValidate = it.useCustomRule($rule, $schema2, it.schema, it);
      if (!$ruleValidate) return;
      $schemaValue = "validate.schema" + $schemaPath;
      $validateCode = $ruleValidate.code;
      $compile = $rDef.compile;
      $inline = $rDef.inline;
      $macro = $rDef.macro;
    }
    var $ruleErrs = $validateCode + ".errors", $i = "i" + $lvl, $ruleErr = "ruleErr" + $lvl, $asyncKeyword = $rDef.async;
    if ($asyncKeyword && !it.async) throw new Error("async keyword in sync schema");
    if (!($inline || $macro)) {
      out += "" + $ruleErrs + " = null;";
    }
    out += "var " + $errs + " = errors;var " + $valid + ";";
    if ($isData && $rDef.$data) {
      $closingBraces += "}";
      out += " if (" + $schemaValue + " === undefined) { " + $valid + " = true; } else { ";
      if ($validateSchema) {
        $closingBraces += "}";
        out += " " + $valid + " = " + $definition + ".validateSchema(" + $schemaValue + "); if (" + $valid + ") { ";
      }
    }
    if ($inline) {
      if ($rDef.statements) {
        out += " " + $ruleValidate.validate + " ";
      } else {
        out += " " + $valid + " = " + $ruleValidate.validate + "; ";
      }
    } else if ($macro) {
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      $it.schema = $ruleValidate.validate;
      $it.schemaPath = "";
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += " " + $code;
    } else {
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      out += "  " + $validateCode + ".call( ";
      if (it.opts.passContext) {
        out += "this";
      } else {
        out += "self";
      }
      if ($compile || $rDef.schema === false) {
        out += " , " + $data + " ";
      } else {
        out += " , " + $schemaValue + " , " + $data + " , validate.schema" + it.schemaPath + " ";
      }
      out += " , (dataPath || '')";
      if (it.errorPath != '""') {
        out += " + " + it.errorPath;
      }
      var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
      out += " , " + $parentData + " , " + $parentDataProperty + " , rootData )  ";
      var def_callRuleValidate = out;
      out = $$outStack.pop();
      if ($rDef.errors === false) {
        out += " " + $valid + " = ";
        if ($asyncKeyword) {
          out += "await ";
        }
        out += "" + def_callRuleValidate + "; ";
      } else {
        if ($asyncKeyword) {
          $ruleErrs = "customErrors" + $lvl;
          out += " var " + $ruleErrs + " = null; try { " + $valid + " = await " + def_callRuleValidate + "; } catch (e) { " + $valid + " = false; if (e instanceof ValidationError) " + $ruleErrs + " = e.errors; else throw e; } ";
        } else {
          out += " " + $ruleErrs + " = null; " + $valid + " = " + def_callRuleValidate + "; ";
        }
      }
    }
    if ($rDef.modifying) {
      out += " if (" + $parentData + ") " + $data + " = " + $parentData + "[" + $parentDataProperty + "];";
    }
    out += "" + $closingBraces;
    if ($rDef.valid) {
      if ($breakOnError) {
        out += " if (true) { ";
      }
    } else {
      out += " if ( ";
      if ($rDef.valid === void 0) {
        out += " !";
        if ($macro) {
          out += "" + $nextValid;
        } else {
          out += "" + $valid;
        }
      } else {
        out += " " + !$rDef.valid + " ";
      }
      out += ") { ";
      $errorKeyword = $rule.keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
        if (it.opts.messages !== false) {
          out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      var def_customError = out;
      out = $$outStack.pop();
      if ($inline) {
        if ($rDef.errors) {
          if ($rDef.errors != "full") {
            out += "  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
            if (it.opts.verbose) {
              out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
            }
            out += " } ";
          }
        } else {
          if ($rDef.errors === false) {
            out += " " + def_customError + " ";
          } else {
            out += " if (" + $errs + " == errors) { " + def_customError + " } else {  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
            if (it.opts.verbose) {
              out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
            }
            out += " } } ";
          }
        }
      } else if ($macro) {
        out += "   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
          if (it.opts.messages !== false) {
            out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
      } else {
        if ($rDef.errors === false) {
          out += " " + def_customError + " ";
        } else {
          out += " if (Array.isArray(" + $ruleErrs + ")) { if (vErrors === null) vErrors = " + $ruleErrs + "; else vErrors = vErrors.concat(" + $ruleErrs + "); errors = vErrors.length;  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + ";  " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '";  ';
          if (it.opts.verbose) {
            out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
          }
          out += " } } else { " + def_customError + " } ";
        }
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
    }
    return out;
  };
  return custom;
}
const $schema$k = "http://json-schema.org/draft-07/schema#";
const $id$k = "http://json-schema.org/draft-07/schema#";
const title$1 = "Core schema meta-schema";
const definitions$1 = { "schemaArray": { "type": "array", "minItems": 1, "items": { "$ref": "#" } }, "nonNegativeInteger": { "type": "integer", "minimum": 0 }, "nonNegativeIntegerDefault0": { "allOf": [{ "$ref": "#/definitions/nonNegativeInteger" }, { "default": 0 }] }, "simpleTypes": { "enum": ["array", "boolean", "integer", "null", "number", "object", "string"] }, "stringArray": { "type": "array", "items": { "type": "string" }, "uniqueItems": true, "default": [] } };
const type$i = ["object", "boolean"];
const properties$k = { "$id": { "type": "string", "format": "uri-reference" }, "$schema": { "type": "string", "format": "uri" }, "$ref": { "type": "string", "format": "uri-reference" }, "$comment": { "type": "string" }, "title": { "type": "string" }, "description": { "type": "string" }, "default": true, "readOnly": { "type": "boolean", "default": false }, "examples": { "type": "array", "items": true }, "multipleOf": { "type": "number", "exclusiveMinimum": 0 }, "maximum": { "type": "number" }, "exclusiveMaximum": { "type": "number" }, "minimum": { "type": "number" }, "exclusiveMinimum": { "type": "number" }, "maxLength": { "$ref": "#/definitions/nonNegativeInteger" }, "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "pattern": { "type": "string", "format": "regex" }, "additionalItems": { "$ref": "#" }, "items": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/schemaArray" }], "default": true }, "maxItems": { "$ref": "#/definitions/nonNegativeInteger" }, "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "uniqueItems": { "type": "boolean", "default": false }, "contains": { "$ref": "#" }, "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" }, "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "required": { "$ref": "#/definitions/stringArray" }, "additionalProperties": { "$ref": "#" }, "definitions": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "properties": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "patternProperties": { "type": "object", "additionalProperties": { "$ref": "#" }, "propertyNames": { "format": "regex" }, "default": {} }, "dependencies": { "type": "object", "additionalProperties": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/stringArray" }] } }, "propertyNames": { "$ref": "#" }, "const": true, "enum": { "type": "array", "items": true, "minItems": 1, "uniqueItems": true }, "type": { "anyOf": [{ "$ref": "#/definitions/simpleTypes" }, { "type": "array", "items": { "$ref": "#/definitions/simpleTypes" }, "minItems": 1, "uniqueItems": true }] }, "format": { "type": "string" }, "contentMediaType": { "type": "string" }, "contentEncoding": { "type": "string" }, "if": { "$ref": "#" }, "then": { "$ref": "#" }, "else": { "$ref": "#" }, "allOf": { "$ref": "#/definitions/schemaArray" }, "anyOf": { "$ref": "#/definitions/schemaArray" }, "oneOf": { "$ref": "#/definitions/schemaArray" }, "not": { "$ref": "#" } };
const require$$13$1 = {
  $schema: $schema$k,
  $id: $id$k,
  title: title$1,
  definitions: definitions$1,
  type: type$i,
  properties: properties$k,
  "default": true
};
var definition_schema;
var hasRequiredDefinition_schema;
function requireDefinition_schema() {
  if (hasRequiredDefinition_schema) return definition_schema;
  hasRequiredDefinition_schema = 1;
  var metaSchema = require$$13$1;
  definition_schema = {
    $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
    definitions: {
      simpleTypes: metaSchema.definitions.simpleTypes
    },
    type: "object",
    dependencies: {
      schema: ["validate"],
      $data: ["validate"],
      statements: ["inline"],
      valid: { not: { required: ["macro"] } }
    },
    properties: {
      type: metaSchema.properties.type,
      schema: { type: "boolean" },
      statements: { type: "boolean" },
      dependencies: {
        type: "array",
        items: { type: "string" }
      },
      metaSchema: { type: "object" },
      modifying: { type: "boolean" },
      valid: { type: "boolean" },
      $data: { type: "boolean" },
      async: { type: "boolean" },
      errors: {
        anyOf: [
          { type: "boolean" },
          { const: "full" }
        ]
      }
    }
  };
  return definition_schema;
}
var keyword;
var hasRequiredKeyword;
function requireKeyword() {
  if (hasRequiredKeyword) return keyword;
  hasRequiredKeyword = 1;
  var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
  var customRuleCode = requireCustom();
  var definitionSchema = requireDefinition_schema();
  keyword = {
    add: addKeyword,
    get: getKeyword,
    remove: removeKeyword,
    validate: validateKeyword
  };
  function addKeyword(keyword2, definition) {
    var RULES = this.RULES;
    if (RULES.keywords[keyword2])
      throw new Error("Keyword " + keyword2 + " is already defined");
    if (!IDENTIFIER.test(keyword2))
      throw new Error("Keyword " + keyword2 + " is not a valid identifier");
    if (definition) {
      this.validateKeyword(definition, true);
      var dataType = definition.type;
      if (Array.isArray(dataType)) {
        for (var i = 0; i < dataType.length; i++)
          _addRule(keyword2, dataType[i], definition);
      } else {
        _addRule(keyword2, dataType, definition);
      }
      var metaSchema = definition.metaSchema;
      if (metaSchema) {
        if (definition.$data && this._opts.$data) {
          metaSchema = {
            anyOf: [
              metaSchema,
              { "$ref": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
            ]
          };
        }
        definition.validateSchema = this.compile(metaSchema, true);
      }
    }
    RULES.keywords[keyword2] = RULES.all[keyword2] = true;
    function _addRule(keyword3, dataType2, definition2) {
      var ruleGroup;
      for (var i2 = 0; i2 < RULES.length; i2++) {
        var rg = RULES[i2];
        if (rg.type == dataType2) {
          ruleGroup = rg;
          break;
        }
      }
      if (!ruleGroup) {
        ruleGroup = { type: dataType2, rules: [] };
        RULES.push(ruleGroup);
      }
      var rule = {
        keyword: keyword3,
        definition: definition2,
        custom: true,
        code: customRuleCode,
        implements: definition2.implements
      };
      ruleGroup.rules.push(rule);
      RULES.custom[keyword3] = rule;
    }
    return this;
  }
  function getKeyword(keyword2) {
    var rule = this.RULES.custom[keyword2];
    return rule ? rule.definition : this.RULES.keywords[keyword2] || false;
  }
  function removeKeyword(keyword2) {
    var RULES = this.RULES;
    delete RULES.keywords[keyword2];
    delete RULES.all[keyword2];
    delete RULES.custom[keyword2];
    for (var i = 0; i < RULES.length; i++) {
      var rules2 = RULES[i].rules;
      for (var j = 0; j < rules2.length; j++) {
        if (rules2[j].keyword == keyword2) {
          rules2.splice(j, 1);
          break;
        }
      }
    }
    return this;
  }
  function validateKeyword(definition, throwError) {
    validateKeyword.errors = null;
    var v = this._validateKeyword = this._validateKeyword || this.compile(definitionSchema, true);
    if (v(definition)) return true;
    validateKeyword.errors = v.errors;
    if (throwError)
      throw new Error("custom keyword definition is invalid: " + this.errorsText(v.errors));
    else
      return false;
  }
  return keyword;
}
const $schema$j = "http://json-schema.org/draft-07/schema#";
const $id$j = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
const description = "Meta-schema for $data reference (JSON Schema extension proposal)";
const type$h = "object";
const required$g = ["$data"];
const properties$j = { "$data": { "type": "string", "anyOf": [{ "format": "relative-json-pointer" }, { "format": "json-pointer" }] } };
const additionalProperties = false;
const require$$12$1 = {
  $schema: $schema$j,
  $id: $id$j,
  description,
  type: type$h,
  required: required$g,
  properties: properties$j,
  additionalProperties
};
var ajv;
var hasRequiredAjv;
function requireAjv() {
  if (hasRequiredAjv) return ajv;
  hasRequiredAjv = 1;
  var compileSchema = requireCompile(), resolve = requireResolve(), Cache = requireCache(), SchemaObject = requireSchema_obj(), stableStringify = requireFastJsonStableStringify(), formats2 = requireFormats(), rules2 = requireRules(), $dataMetaSchema = requireData(), util2 = requireUtil();
  ajv = Ajv;
  Ajv.prototype.validate = validate2;
  Ajv.prototype.compile = compile2;
  Ajv.prototype.addSchema = addSchema;
  Ajv.prototype.addMetaSchema = addMetaSchema;
  Ajv.prototype.validateSchema = validateSchema;
  Ajv.prototype.getSchema = getSchema;
  Ajv.prototype.removeSchema = removeSchema;
  Ajv.prototype.addFormat = addFormat;
  Ajv.prototype.errorsText = errorsText;
  Ajv.prototype._addSchema = _addSchema;
  Ajv.prototype._compile = _compile;
  Ajv.prototype.compileAsync = requireAsync();
  var customKeyword = requireKeyword();
  Ajv.prototype.addKeyword = customKeyword.add;
  Ajv.prototype.getKeyword = customKeyword.get;
  Ajv.prototype.removeKeyword = customKeyword.remove;
  Ajv.prototype.validateKeyword = customKeyword.validate;
  var errorClasses = requireError_classes();
  Ajv.ValidationError = errorClasses.Validation;
  Ajv.MissingRefError = errorClasses.MissingRef;
  Ajv.$dataMetaSchema = $dataMetaSchema;
  var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
  var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"];
  var META_SUPPORT_DATA = ["/properties"];
  function Ajv(opts) {
    if (!(this instanceof Ajv)) return new Ajv(opts);
    opts = this._opts = util2.copy(opts) || {};
    setLogger(this);
    this._schemas = {};
    this._refs = {};
    this._fragments = {};
    this._formats = formats2(opts.format);
    this._cache = opts.cache || new Cache();
    this._loadingSchemas = {};
    this._compilations = [];
    this.RULES = rules2();
    this._getId = chooseGetId(opts);
    opts.loopRequired = opts.loopRequired || Infinity;
    if (opts.errorDataPath == "property") opts._errorDataPathProperty = true;
    if (opts.serialize === void 0) opts.serialize = stableStringify;
    this._metaOpts = getMetaSchemaOptions(this);
    if (opts.formats) addInitialFormats(this);
    if (opts.keywords) addInitialKeywords(this);
    addDefaultMetaSchema(this);
    if (typeof opts.meta == "object") this.addMetaSchema(opts.meta);
    if (opts.nullable) this.addKeyword("nullable", { metaSchema: { type: "boolean" } });
    addInitialSchemas(this);
  }
  function validate2(schemaKeyRef, data2) {
    var v;
    if (typeof schemaKeyRef == "string") {
      v = this.getSchema(schemaKeyRef);
      if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
    } else {
      var schemaObj = this._addSchema(schemaKeyRef);
      v = schemaObj.validate || this._compile(schemaObj);
    }
    var valid = v(data2);
    if (v.$async !== true) this.errors = v.errors;
    return valid;
  }
  function compile2(schema, _meta) {
    var schemaObj = this._addSchema(schema, void 0, _meta);
    return schemaObj.validate || this._compile(schemaObj);
  }
  function addSchema(schema, key2, _skipValidation, _meta) {
    if (Array.isArray(schema)) {
      for (var i = 0; i < schema.length; i++) this.addSchema(schema[i], void 0, _skipValidation, _meta);
      return this;
    }
    var id = this._getId(schema);
    if (id !== void 0 && typeof id != "string")
      throw new Error("schema id must be string");
    key2 = resolve.normalizeId(key2 || id);
    checkUnique(this, key2);
    this._schemas[key2] = this._addSchema(schema, _skipValidation, _meta, true);
    return this;
  }
  function addMetaSchema(schema, key2, skipValidation) {
    this.addSchema(schema, key2, skipValidation, true);
    return this;
  }
  function validateSchema(schema, throwOrLogError) {
    var $schema2 = schema.$schema;
    if ($schema2 !== void 0 && typeof $schema2 != "string")
      throw new Error("$schema must be a string");
    $schema2 = $schema2 || this._opts.defaultMeta || defaultMeta(this);
    if (!$schema2) {
      this.logger.warn("meta-schema not available");
      this.errors = null;
      return true;
    }
    var valid = this.validate($schema2, schema);
    if (!valid && throwOrLogError) {
      var message = "schema is invalid: " + this.errorsText();
      if (this._opts.validateSchema == "log") this.logger.error(message);
      else throw new Error(message);
    }
    return valid;
  }
  function defaultMeta(self2) {
    var meta = self2._opts.meta;
    self2._opts.defaultMeta = typeof meta == "object" ? self2._getId(meta) || meta : self2.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0;
    return self2._opts.defaultMeta;
  }
  function getSchema(keyRef) {
    var schemaObj = _getSchemaObj(this, keyRef);
    switch (typeof schemaObj) {
      case "object":
        return schemaObj.validate || this._compile(schemaObj);
      case "string":
        return this.getSchema(schemaObj);
      case "undefined":
        return _getSchemaFragment(this, keyRef);
    }
  }
  function _getSchemaFragment(self2, ref2) {
    var res = resolve.schema.call(self2, { schema: {} }, ref2);
    if (res) {
      var schema = res.schema, root = res.root, baseId = res.baseId;
      var v = compileSchema.call(self2, schema, root, void 0, baseId);
      self2._fragments[ref2] = new SchemaObject({
        ref: ref2,
        fragment: true,
        schema,
        root,
        baseId,
        validate: v
      });
      return v;
    }
  }
  function _getSchemaObj(self2, keyRef) {
    keyRef = resolve.normalizeId(keyRef);
    return self2._schemas[keyRef] || self2._refs[keyRef] || self2._fragments[keyRef];
  }
  function removeSchema(schemaKeyRef) {
    if (schemaKeyRef instanceof RegExp) {
      _removeAllSchemas(this, this._schemas, schemaKeyRef);
      _removeAllSchemas(this, this._refs, schemaKeyRef);
      return this;
    }
    switch (typeof schemaKeyRef) {
      case "undefined":
        _removeAllSchemas(this, this._schemas);
        _removeAllSchemas(this, this._refs);
        this._cache.clear();
        return this;
      case "string":
        var schemaObj = _getSchemaObj(this, schemaKeyRef);
        if (schemaObj) this._cache.del(schemaObj.cacheKey);
        delete this._schemas[schemaKeyRef];
        delete this._refs[schemaKeyRef];
        return this;
      case "object":
        var serialize = this._opts.serialize;
        var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
        this._cache.del(cacheKey);
        var id = this._getId(schemaKeyRef);
        if (id) {
          id = resolve.normalizeId(id);
          delete this._schemas[id];
          delete this._refs[id];
        }
    }
    return this;
  }
  function _removeAllSchemas(self2, schemas, regex) {
    for (var keyRef in schemas) {
      var schemaObj = schemas[keyRef];
      if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
        self2._cache.del(schemaObj.cacheKey);
        delete schemas[keyRef];
      }
    }
  }
  function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
    if (typeof schema != "object" && typeof schema != "boolean")
      throw new Error("schema should be object or boolean");
    var serialize = this._opts.serialize;
    var cacheKey = serialize ? serialize(schema) : schema;
    var cached = this._cache.get(cacheKey);
    if (cached) return cached;
    shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
    var id = resolve.normalizeId(this._getId(schema));
    if (id && shouldAddSchema) checkUnique(this, id);
    var willValidate = this._opts.validateSchema !== false && !skipValidation;
    var recursiveMeta;
    if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
      this.validateSchema(schema, true);
    var localRefs = resolve.ids.call(this, schema);
    var schemaObj = new SchemaObject({
      id,
      schema,
      localRefs,
      cacheKey,
      meta
    });
    if (id[0] != "#" && shouldAddSchema) this._refs[id] = schemaObj;
    this._cache.put(cacheKey, schemaObj);
    if (willValidate && recursiveMeta) this.validateSchema(schema, true);
    return schemaObj;
  }
  function _compile(schemaObj, root) {
    if (schemaObj.compiling) {
      schemaObj.validate = callValidate;
      callValidate.schema = schemaObj.schema;
      callValidate.errors = null;
      callValidate.root = root ? root : callValidate;
      if (schemaObj.schema.$async === true)
        callValidate.$async = true;
      return callValidate;
    }
    schemaObj.compiling = true;
    var currentOpts;
    if (schemaObj.meta) {
      currentOpts = this._opts;
      this._opts = this._metaOpts;
    }
    var v;
    try {
      v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
    } catch (e) {
      delete schemaObj.validate;
      throw e;
    } finally {
      schemaObj.compiling = false;
      if (schemaObj.meta) this._opts = currentOpts;
    }
    schemaObj.validate = v;
    schemaObj.refs = v.refs;
    schemaObj.refVal = v.refVal;
    schemaObj.root = v.root;
    return v;
    function callValidate() {
      var _validate = schemaObj.validate;
      var result = _validate.apply(this, arguments);
      callValidate.errors = _validate.errors;
      return result;
    }
  }
  function chooseGetId(opts) {
    switch (opts.schemaId) {
      case "auto":
        return _get$IdOrId;
      case "id":
        return _getId;
      default:
        return _get$Id;
    }
  }
  function _getId(schema) {
    if (schema.$id) this.logger.warn("schema $id ignored", schema.$id);
    return schema.id;
  }
  function _get$Id(schema) {
    if (schema.id) this.logger.warn("schema id ignored", schema.id);
    return schema.$id;
  }
  function _get$IdOrId(schema) {
    if (schema.$id && schema.id && schema.$id != schema.id)
      throw new Error("schema $id is different from id");
    return schema.$id || schema.id;
  }
  function errorsText(errors2, options) {
    errors2 = errors2 || this.errors;
    if (!errors2) return "No errors";
    options = options || {};
    var separator = options.separator === void 0 ? ", " : options.separator;
    var dataVar = options.dataVar === void 0 ? "data" : options.dataVar;
    var text = "";
    for (var i = 0; i < errors2.length; i++) {
      var e = errors2[i];
      if (e) text += dataVar + e.dataPath + " " + e.message + separator;
    }
    return text.slice(0, -separator.length);
  }
  function addFormat(name, format2) {
    if (typeof format2 == "string") format2 = new RegExp(format2);
    this._formats[name] = format2;
    return this;
  }
  function addDefaultMetaSchema(self2) {
    var $dataSchema;
    if (self2._opts.$data) {
      $dataSchema = require$$12$1;
      self2.addMetaSchema($dataSchema, $dataSchema.$id, true);
    }
    if (self2._opts.meta === false) return;
    var metaSchema = require$$13$1;
    if (self2._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
    self2.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
    self2._refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
  }
  function addInitialSchemas(self2) {
    var optsSchemas = self2._opts.schemas;
    if (!optsSchemas) return;
    if (Array.isArray(optsSchemas)) self2.addSchema(optsSchemas);
    else for (var key2 in optsSchemas) self2.addSchema(optsSchemas[key2], key2);
  }
  function addInitialFormats(self2) {
    for (var name in self2._opts.formats) {
      var format2 = self2._opts.formats[name];
      self2.addFormat(name, format2);
    }
  }
  function addInitialKeywords(self2) {
    for (var name in self2._opts.keywords) {
      var keyword2 = self2._opts.keywords[name];
      self2.addKeyword(name, keyword2);
    }
  }
  function checkUnique(self2, id) {
    if (self2._schemas[id] || self2._refs[id])
      throw new Error('schema with key or id "' + id + '" already exists');
  }
  function getMetaSchemaOptions(self2) {
    var metaOpts = util2.copy(self2._opts);
    for (var i = 0; i < META_IGNORE_OPTIONS.length; i++)
      delete metaOpts[META_IGNORE_OPTIONS[i]];
    return metaOpts;
  }
  function setLogger(self2) {
    var logger = self2._opts.logger;
    if (logger === false) {
      self2.logger = { log: noop, warn: noop, error: noop };
    } else {
      if (logger === void 0) logger = console;
      if (!(typeof logger == "object" && logger.log && logger.warn && logger.error))
        throw new Error("logger must implement log, warn and error methods");
      self2.logger = logger;
    }
  }
  function noop() {
  }
  return ajv;
}
var error;
var hasRequiredError;
function requireError() {
  if (hasRequiredError) return error;
  hasRequiredError = 1;
  function HARError(errors2) {
    var message = "validation failed";
    this.name = "HARError";
    this.message = message;
    this.errors = errors2;
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error(message).stack;
    }
  }
  HARError.prototype = Error.prototype;
  error = HARError;
  return error;
}
const $id$i = "afterRequest.json#";
const $schema$i = "http://json-schema.org/draft-06/schema#";
const type$g = "object";
const optional$4 = true;
const required$f = ["lastAccess", "eTag", "hitCount"];
const properties$i = { "expires": { "type": "string", "pattern": "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?" }, "lastAccess": { "type": "string", "pattern": "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?" }, "eTag": { "type": "string" }, "hitCount": { "type": "integer" }, "comment": { "type": "string" } };
const require$$0 = {
  $id: $id$i,
  $schema: $schema$i,
  type: type$g,
  optional: optional$4,
  required: required$f,
  properties: properties$i
};
const $id$h = "beforeRequest.json#";
const $schema$h = "http://json-schema.org/draft-06/schema#";
const type$f = "object";
const optional$3 = true;
const required$e = ["lastAccess", "eTag", "hitCount"];
const properties$h = { "expires": { "type": "string", "pattern": "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?" }, "lastAccess": { "type": "string", "pattern": "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?" }, "eTag": { "type": "string" }, "hitCount": { "type": "integer" }, "comment": { "type": "string" } };
const require$$1 = {
  $id: $id$h,
  $schema: $schema$h,
  type: type$f,
  optional: optional$3,
  required: required$e,
  properties: properties$h
};
const $id$g = "browser.json#";
const $schema$g = "http://json-schema.org/draft-06/schema#";
const type$e = "object";
const required$d = ["name", "version"];
const properties$g = { "name": { "type": "string" }, "version": { "type": "string" }, "comment": { "type": "string" } };
const require$$2 = {
  $id: $id$g,
  $schema: $schema$g,
  type: type$e,
  required: required$d,
  properties: properties$g
};
const $id$f = "cache.json#";
const $schema$f = "http://json-schema.org/draft-06/schema#";
const properties$f = { "beforeRequest": { "oneOf": [{ "type": "null" }, { "$ref": "beforeRequest.json#" }] }, "afterRequest": { "oneOf": [{ "type": "null" }, { "$ref": "afterRequest.json#" }] }, "comment": { "type": "string" } };
const require$$3$1 = {
  $id: $id$f,
  $schema: $schema$f,
  properties: properties$f
};
const $id$e = "content.json#";
const $schema$e = "http://json-schema.org/draft-06/schema#";
const type$d = "object";
const required$c = ["size", "mimeType"];
const properties$e = { "size": { "type": "integer" }, "compression": { "type": "integer" }, "mimeType": { "type": "string" }, "text": { "type": "string" }, "encoding": { "type": "string" }, "comment": { "type": "string" } };
const require$$4 = {
  $id: $id$e,
  $schema: $schema$e,
  type: type$d,
  required: required$c,
  properties: properties$e
};
const $id$d = "cookie.json#";
const $schema$d = "http://json-schema.org/draft-06/schema#";
const type$c = "object";
const required$b = ["name", "value"];
const properties$d = { "name": { "type": "string" }, "value": { "type": "string" }, "path": { "type": "string" }, "domain": { "type": "string" }, "expires": { "type": ["string", "null"], "format": "date-time" }, "httpOnly": { "type": "boolean" }, "secure": { "type": "boolean" }, "comment": { "type": "string" } };
const require$$5 = {
  $id: $id$d,
  $schema: $schema$d,
  type: type$c,
  required: required$b,
  properties: properties$d
};
const $id$c = "creator.json#";
const $schema$c = "http://json-schema.org/draft-06/schema#";
const type$b = "object";
const required$a = ["name", "version"];
const properties$c = { "name": { "type": "string" }, "version": { "type": "string" }, "comment": { "type": "string" } };
const require$$6 = {
  $id: $id$c,
  $schema: $schema$c,
  type: type$b,
  required: required$a,
  properties: properties$c
};
const $id$b = "entry.json#";
const $schema$b = "http://json-schema.org/draft-06/schema#";
const type$a = "object";
const optional$2 = true;
const required$9 = ["startedDateTime", "time", "request", "response", "cache", "timings"];
const properties$b = { "pageref": { "type": "string" }, "startedDateTime": { "type": "string", "format": "date-time", "pattern": "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))" }, "time": { "type": "number", "min": 0 }, "request": { "$ref": "request.json#" }, "response": { "$ref": "response.json#" }, "cache": { "$ref": "cache.json#" }, "timings": { "$ref": "timings.json#" }, "serverIPAddress": { "type": "string", "oneOf": [{ "format": "ipv4" }, { "format": "ipv6" }] }, "connection": { "type": "string" }, "comment": { "type": "string" } };
const require$$7 = {
  $id: $id$b,
  $schema: $schema$b,
  type: type$a,
  optional: optional$2,
  required: required$9,
  properties: properties$b
};
const $id$a = "har.json#";
const $schema$a = "http://json-schema.org/draft-06/schema#";
const type$9 = "object";
const required$8 = ["log"];
const properties$a = { "log": { "$ref": "log.json#" } };
const require$$8 = {
  $id: $id$a,
  $schema: $schema$a,
  type: type$9,
  required: required$8,
  properties: properties$a
};
const $id$9 = "header.json#";
const $schema$9 = "http://json-schema.org/draft-06/schema#";
const type$8 = "object";
const required$7 = ["name", "value"];
const properties$9 = { "name": { "type": "string" }, "value": { "type": "string" }, "comment": { "type": "string" } };
const require$$9 = {
  $id: $id$9,
  $schema: $schema$9,
  type: type$8,
  required: required$7,
  properties: properties$9
};
const $id$8 = "log.json#";
const $schema$8 = "http://json-schema.org/draft-06/schema#";
const type$7 = "object";
const required$6 = ["version", "creator", "entries"];
const properties$8 = { "version": { "type": "string" }, "creator": { "$ref": "creator.json#" }, "browser": { "$ref": "browser.json#" }, "pages": { "type": "array", "items": { "$ref": "page.json#" } }, "entries": { "type": "array", "items": { "$ref": "entry.json#" } }, "comment": { "type": "string" } };
const require$$10 = {
  $id: $id$8,
  $schema: $schema$8,
  type: type$7,
  required: required$6,
  properties: properties$8
};
const $id$7 = "page.json#";
const $schema$7 = "http://json-schema.org/draft-06/schema#";
const type$6 = "object";
const optional$1 = true;
const required$5 = ["startedDateTime", "id", "title", "pageTimings"];
const properties$7 = { "startedDateTime": { "type": "string", "format": "date-time", "pattern": "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))" }, "id": { "type": "string", "unique": true }, "title": { "type": "string" }, "pageTimings": { "$ref": "pageTimings.json#" }, "comment": { "type": "string" } };
const require$$11 = {
  $id: $id$7,
  $schema: $schema$7,
  type: type$6,
  optional: optional$1,
  required: required$5,
  properties: properties$7
};
const $id$6 = "pageTimings.json#";
const $schema$6 = "http://json-schema.org/draft-06/schema#";
const type$5 = "object";
const properties$6 = { "onContentLoad": { "type": "number", "min": -1 }, "onLoad": { "type": "number", "min": -1 }, "comment": { "type": "string" } };
const require$$12 = {
  $id: $id$6,
  $schema: $schema$6,
  type: type$5,
  properties: properties$6
};
const $id$5 = "postData.json#";
const $schema$5 = "http://json-schema.org/draft-06/schema#";
const type$4 = "object";
const optional = true;
const required$4 = ["mimeType"];
const properties$5 = { "mimeType": { "type": "string" }, "text": { "type": "string" }, "params": { "type": "array", "required": ["name"], "properties": { "name": { "type": "string" }, "value": { "type": "string" }, "fileName": { "type": "string" }, "contentType": { "type": "string" }, "comment": { "type": "string" } } }, "comment": { "type": "string" } };
const require$$13 = {
  $id: $id$5,
  $schema: $schema$5,
  type: type$4,
  optional,
  required: required$4,
  properties: properties$5
};
const $id$4 = "query.json#";
const $schema$4 = "http://json-schema.org/draft-06/schema#";
const type$3 = "object";
const required$3 = ["name", "value"];
const properties$4 = { "name": { "type": "string" }, "value": { "type": "string" }, "comment": { "type": "string" } };
const require$$14 = {
  $id: $id$4,
  $schema: $schema$4,
  type: type$3,
  required: required$3,
  properties: properties$4
};
const $id$3 = "request.json#";
const $schema$3 = "http://json-schema.org/draft-06/schema#";
const type$2 = "object";
const required$2 = ["method", "url", "httpVersion", "cookies", "headers", "queryString", "headersSize", "bodySize"];
const properties$3 = { "method": { "type": "string" }, "url": { "type": "string", "format": "uri" }, "httpVersion": { "type": "string" }, "cookies": { "type": "array", "items": { "$ref": "cookie.json#" } }, "headers": { "type": "array", "items": { "$ref": "header.json#" } }, "queryString": { "type": "array", "items": { "$ref": "query.json#" } }, "postData": { "$ref": "postData.json#" }, "headersSize": { "type": "integer" }, "bodySize": { "type": "integer" }, "comment": { "type": "string" } };
const require$$15 = {
  $id: $id$3,
  $schema: $schema$3,
  type: type$2,
  required: required$2,
  properties: properties$3
};
const $id$2 = "response.json#";
const $schema$2 = "http://json-schema.org/draft-06/schema#";
const type$1 = "object";
const required$1 = ["status", "statusText", "httpVersion", "cookies", "headers", "content", "redirectURL", "headersSize", "bodySize"];
const properties$2 = { "status": { "type": "integer" }, "statusText": { "type": "string" }, "httpVersion": { "type": "string" }, "cookies": { "type": "array", "items": { "$ref": "cookie.json#" } }, "headers": { "type": "array", "items": { "$ref": "header.json#" } }, "content": { "$ref": "content.json#" }, "redirectURL": { "type": "string" }, "headersSize": { "type": "integer" }, "bodySize": { "type": "integer" }, "comment": { "type": "string" } };
const require$$16 = {
  $id: $id$2,
  $schema: $schema$2,
  type: type$1,
  required: required$1,
  properties: properties$2
};
const $id$1 = "timings.json#";
const $schema$1 = "http://json-schema.org/draft-06/schema#";
const required = ["send", "wait", "receive"];
const properties$1 = { "dns": { "type": "number", "min": -1 }, "connect": { "type": "number", "min": -1 }, "blocked": { "type": "number", "min": -1 }, "send": { "type": "number", "min": -1 }, "wait": { "type": "number", "min": -1 }, "receive": { "type": "number", "min": -1 }, "ssl": { "type": "number", "min": -1 }, "comment": { "type": "string" } };
const require$$17 = {
  $id: $id$1,
  $schema: $schema$1,
  required,
  properties: properties$1
};
var lib;
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  lib = {
    afterRequest: require$$0,
    beforeRequest: require$$1,
    browser: require$$2,
    cache: require$$3$1,
    content: require$$4,
    cookie: require$$5,
    creator: require$$6,
    entry: require$$7,
    har: require$$8,
    header: require$$9,
    log: require$$10,
    page: require$$11,
    pageTimings: require$$12,
    postData: require$$13,
    query: require$$14,
    request: require$$15,
    response: require$$16,
    timings: require$$17
  };
  return lib;
}
const $schema = "http://json-schema.org/draft-06/schema#";
const $id = "http://json-schema.org/draft-06/schema#";
const title = "Core schema meta-schema";
const definitions = { "schemaArray": { "type": "array", "minItems": 1, "items": { "$ref": "#" } }, "nonNegativeInteger": { "type": "integer", "minimum": 0 }, "nonNegativeIntegerDefault0": { "allOf": [{ "$ref": "#/definitions/nonNegativeInteger" }, { "default": 0 }] }, "simpleTypes": { "enum": ["array", "boolean", "integer", "null", "number", "object", "string"] }, "stringArray": { "type": "array", "items": { "type": "string" }, "uniqueItems": true, "default": [] } };
const type = ["object", "boolean"];
const properties = { "$id": { "type": "string", "format": "uri-reference" }, "$schema": { "type": "string", "format": "uri" }, "$ref": { "type": "string", "format": "uri-reference" }, "title": { "type": "string" }, "description": { "type": "string" }, "default": {}, "examples": { "type": "array", "items": {} }, "multipleOf": { "type": "number", "exclusiveMinimum": 0 }, "maximum": { "type": "number" }, "exclusiveMaximum": { "type": "number" }, "minimum": { "type": "number" }, "exclusiveMinimum": { "type": "number" }, "maxLength": { "$ref": "#/definitions/nonNegativeInteger" }, "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "pattern": { "type": "string", "format": "regex" }, "additionalItems": { "$ref": "#" }, "items": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/schemaArray" }], "default": {} }, "maxItems": { "$ref": "#/definitions/nonNegativeInteger" }, "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "uniqueItems": { "type": "boolean", "default": false }, "contains": { "$ref": "#" }, "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" }, "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "required": { "$ref": "#/definitions/stringArray" }, "additionalProperties": { "$ref": "#" }, "definitions": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "properties": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "patternProperties": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "dependencies": { "type": "object", "additionalProperties": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/stringArray" }] } }, "propertyNames": { "$ref": "#" }, "const": {}, "enum": { "type": "array", "minItems": 1, "uniqueItems": true }, "type": { "anyOf": [{ "$ref": "#/definitions/simpleTypes" }, { "type": "array", "items": { "$ref": "#/definitions/simpleTypes" }, "minItems": 1, "uniqueItems": true }] }, "format": { "type": "string" }, "allOf": { "$ref": "#/definitions/schemaArray" }, "anyOf": { "$ref": "#/definitions/schemaArray" }, "oneOf": { "$ref": "#/definitions/schemaArray" }, "not": { "$ref": "#" } };
const require$$3 = {
  $schema,
  $id,
  title,
  definitions,
  type,
  properties,
  "default": {}
};
var hasRequiredPromise;
function requirePromise() {
  if (hasRequiredPromise) return promise;
  hasRequiredPromise = 1;
  var Ajv = requireAjv();
  var HARError = requireError();
  var schemas = requireLib();
  var ajv2;
  function createAjvInstance() {
    var ajv3 = new Ajv({
      allErrors: true
    });
    ajv3.addMetaSchema(require$$3);
    ajv3.addSchema(schemas);
    return ajv3;
  }
  function validate2(name, data2) {
    data2 = data2 || {};
    ajv2 = ajv2 || createAjvInstance();
    var validate3 = ajv2.getSchema(name + ".json");
    return new Promise(function(resolve, reject) {
      var valid = validate3(data2);
      !valid ? reject(new HARError(validate3.errors)) : resolve(data2);
    });
  }
  promise.afterRequest = function(data2) {
    return validate2("afterRequest", data2);
  };
  promise.beforeRequest = function(data2) {
    return validate2("beforeRequest", data2);
  };
  promise.browser = function(data2) {
    return validate2("browser", data2);
  };
  promise.cache = function(data2) {
    return validate2("cache", data2);
  };
  promise.content = function(data2) {
    return validate2("content", data2);
  };
  promise.cookie = function(data2) {
    return validate2("cookie", data2);
  };
  promise.creator = function(data2) {
    return validate2("creator", data2);
  };
  promise.entry = function(data2) {
    return validate2("entry", data2);
  };
  promise.har = function(data2) {
    return validate2("har", data2);
  };
  promise.header = function(data2) {
    return validate2("header", data2);
  };
  promise.log = function(data2) {
    return validate2("log", data2);
  };
  promise.page = function(data2) {
    return validate2("page", data2);
  };
  promise.pageTimings = function(data2) {
    return validate2("pageTimings", data2);
  };
  promise.postData = function(data2) {
    return validate2("postData", data2);
  };
  promise.query = function(data2) {
    return validate2("query", data2);
  };
  promise.request = function(data2) {
    return validate2("request", data2);
  };
  promise.response = function(data2) {
    return validate2("response", data2);
  };
  promise.timings = function(data2) {
    return validate2("timings", data2);
  };
  return promise;
}
var hasRequiredHar;
function requireHar() {
  if (hasRequiredHar) return har;
  hasRequiredHar = 1;
  var fs = require$$0$a;
  var qs = require$$1$4;
  var validate2 = requirePromise();
  var extend2 = requireExtend();
  function Har(request2) {
    this.request = request2;
  }
  Har.prototype.reducer = function(obj, pair) {
    if (obj[pair.name] === void 0) {
      obj[pair.name] = pair.value;
      return obj;
    }
    var arr = [
      obj[pair.name],
      pair.value
    ];
    obj[pair.name] = arr;
    return obj;
  };
  Har.prototype.prep = function(data2) {
    data2.queryObj = {};
    data2.headersObj = {};
    data2.postData.jsonObj = false;
    data2.postData.paramsObj = false;
    if (data2.queryString && data2.queryString.length) {
      data2.queryObj = data2.queryString.reduce(this.reducer, {});
    }
    if (data2.headers && data2.headers.length) {
      data2.headersObj = data2.headers.reduceRight(function(headers, header) {
        headers[header.name] = header.value;
        return headers;
      }, {});
    }
    if (data2.cookies && data2.cookies.length) {
      var cookies2 = data2.cookies.map(function(cookie2) {
        return cookie2.name + "=" + cookie2.value;
      });
      if (cookies2.length) {
        data2.headersObj.cookie = cookies2.join("; ");
      }
    }
    function some(arr) {
      return arr.some(function(type2) {
        return data2.postData.mimeType.indexOf(type2) === 0;
      });
    }
    if (some([
      "multipart/mixed",
      "multipart/related",
      "multipart/form-data",
      "multipart/alternative"
    ])) {
      data2.postData.mimeType = "multipart/form-data";
    } else if (some([
      "application/x-www-form-urlencoded"
    ])) {
      if (!data2.postData.params) {
        data2.postData.text = "";
      } else {
        data2.postData.paramsObj = data2.postData.params.reduce(this.reducer, {});
        data2.postData.text = qs.stringify(data2.postData.paramsObj);
      }
    } else if (some([
      "text/json",
      "text/x-json",
      "application/json",
      "application/x-json"
    ])) {
      data2.postData.mimeType = "application/json";
      if (data2.postData.text) {
        try {
          data2.postData.jsonObj = JSON.parse(data2.postData.text);
        } catch (e) {
          this.request.debug(e);
          data2.postData.mimeType = "text/plain";
        }
      }
    }
    return data2;
  };
  Har.prototype.options = function(options) {
    if (!options.har) {
      return options;
    }
    var har2 = {};
    extend2(har2, options.har);
    if (har2.log && har2.log.entries) {
      har2 = har2.log.entries[0];
    }
    har2.url = har2.url || options.url || options.uri || options.baseUrl || "/";
    har2.httpVersion = har2.httpVersion || "HTTP/1.1";
    har2.queryString = har2.queryString || [];
    har2.headers = har2.headers || [];
    har2.cookies = har2.cookies || [];
    har2.postData = har2.postData || {};
    har2.postData.mimeType = har2.postData.mimeType || "application/octet-stream";
    har2.bodySize = 0;
    har2.headersSize = 0;
    har2.postData.size = 0;
    if (!validate2.request(har2)) {
      return options;
    }
    var req = this.prep(har2);
    if (req.url) {
      options.url = req.url;
    }
    if (req.method) {
      options.method = req.method;
    }
    if (Object.keys(req.queryObj).length) {
      options.qs = req.queryObj;
    }
    if (Object.keys(req.headersObj).length) {
      options.headers = req.headersObj;
    }
    function test(type2) {
      return req.postData.mimeType.indexOf(type2) === 0;
    }
    if (test("application/x-www-form-urlencoded")) {
      options.form = req.postData.paramsObj;
    } else if (test("application/json")) {
      if (req.postData.jsonObj) {
        options.body = req.postData.jsonObj;
        options.json = true;
      }
    } else if (test("multipart/form-data")) {
      options.formData = {};
      req.postData.params.forEach(function(param) {
        var attachment = {};
        if (!param.fileName && !param.contentType) {
          options.formData[param.name] = param.value;
          return;
        }
        if (param.fileName && !param.value) {
          attachment.value = fs.createReadStream(param.fileName);
        } else if (param.value) {
          attachment.value = param.value;
        }
        if (param.fileName) {
          attachment.options = {
            filename: param.fileName,
            contentType: param.contentType ? param.contentType : null
          };
        }
        options.formData[param.name] = attachment;
      });
    } else {
      if (req.postData.text) {
        options.body = req.postData.text;
      }
    }
    return options;
  };
  har.Har = Har;
  return har;
}
var auth = {};
var rng;
var hasRequiredRng;
function requireRng() {
  if (hasRequiredRng) return rng;
  hasRequiredRng = 1;
  var crypto = require$$0$9;
  rng = function nodeRNG() {
    return crypto.randomBytes(16);
  };
  return rng;
}
var bytesToUuid_1;
var hasRequiredBytesToUuid;
function requireBytesToUuid() {
  if (hasRequiredBytesToUuid) return bytesToUuid_1;
  hasRequiredBytesToUuid = 1;
  var byteToHex = [];
  for (var i = 0; i < 256; ++i) {
    byteToHex[i] = (i + 256).toString(16).substr(1);
  }
  function bytesToUuid(buf, offset) {
    var i2 = offset || 0;
    var bth = byteToHex;
    return [
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]]
    ].join("");
  }
  bytesToUuid_1 = bytesToUuid;
  return bytesToUuid_1;
}
var v4_1;
var hasRequiredV4;
function requireV4() {
  if (hasRequiredV4) return v4_1;
  hasRequiredV4 = 1;
  var rng2 = requireRng();
  var bytesToUuid = requireBytesToUuid();
  function v4(options, buf, offset) {
    var i = buf && offset || 0;
    if (typeof options == "string") {
      buf = options === "binary" ? new Array(16) : null;
      options = null;
    }
    options = options || {};
    var rnds = options.random || (options.rng || rng2)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      for (var ii = 0; ii < 16; ++ii) {
        buf[i + ii] = rnds[ii];
      }
    }
    return buf || bytesToUuid(rnds);
  }
  v4_1 = v4;
  return v4_1;
}
var hasRequiredAuth;
function requireAuth() {
  if (hasRequiredAuth) return auth;
  hasRequiredAuth = 1;
  var caseless2 = requireCaseless();
  var uuid = requireV4();
  var helpers2 = requireHelpers();
  var md5 = helpers2.md5;
  var toBase64 = helpers2.toBase64;
  function Auth(request2) {
    this.request = request2;
    this.hasAuth = false;
    this.sentAuth = false;
    this.bearerToken = null;
    this.user = null;
    this.pass = null;
  }
  Auth.prototype.basic = function(user, pass, sendImmediately) {
    var self2 = this;
    if (typeof user !== "string" || pass !== void 0 && typeof pass !== "string") {
      self2.request.emit("error", new Error("auth() received invalid user or password"));
    }
    self2.user = user;
    self2.pass = pass;
    self2.hasAuth = true;
    var header = user + ":" + (pass || "");
    if (sendImmediately || typeof sendImmediately === "undefined") {
      var authHeader = "Basic " + toBase64(header);
      self2.sentAuth = true;
      return authHeader;
    }
  };
  Auth.prototype.bearer = function(bearer, sendImmediately) {
    var self2 = this;
    self2.bearerToken = bearer;
    self2.hasAuth = true;
    if (sendImmediately || typeof sendImmediately === "undefined") {
      if (typeof bearer === "function") {
        bearer = bearer();
      }
      var authHeader = "Bearer " + (bearer || "");
      self2.sentAuth = true;
      return authHeader;
    }
  };
  Auth.prototype.digest = function(method, path, authHeader) {
    var self2 = this;
    var challenge = {};
    var re = /([a-z0-9_-]+)=(?:"([^"]+)"|([a-z0-9_-]+))/gi;
    while (true) {
      var match = re.exec(authHeader);
      if (!match) {
        break;
      }
      challenge[match[1]] = match[2] || match[3];
    }
    var ha1Compute = function(algorithm, user, realm, pass, nonce, cnonce2) {
      var ha12 = md5(user + ":" + realm + ":" + pass);
      if (algorithm && algorithm.toLowerCase() === "md5-sess") {
        return md5(ha12 + ":" + nonce + ":" + cnonce2);
      } else {
        return ha12;
      }
    };
    var qop = /(^|,)\s*auth\s*($|,)/.test(challenge.qop) && "auth";
    var nc = qop && "00000001";
    var cnonce = qop && uuid().replace(/-/g, "");
    var ha1 = ha1Compute(challenge.algorithm, self2.user, challenge.realm, self2.pass, challenge.nonce, cnonce);
    var ha2 = md5(method + ":" + path);
    var digestResponse = qop ? md5(ha1 + ":" + challenge.nonce + ":" + nc + ":" + cnonce + ":" + qop + ":" + ha2) : md5(ha1 + ":" + challenge.nonce + ":" + ha2);
    var authValues = {
      username: self2.user,
      realm: challenge.realm,
      nonce: challenge.nonce,
      uri: path,
      qop,
      response: digestResponse,
      nc,
      cnonce,
      algorithm: challenge.algorithm,
      opaque: challenge.opaque
    };
    authHeader = [];
    for (var k in authValues) {
      if (authValues[k]) {
        if (k === "qop" || k === "nc" || k === "algorithm") {
          authHeader.push(k + "=" + authValues[k]);
        } else {
          authHeader.push(k + '="' + authValues[k] + '"');
        }
      }
    }
    authHeader = "Digest " + authHeader.join(", ");
    self2.sentAuth = true;
    return authHeader;
  };
  Auth.prototype.onRequest = function(user, pass, sendImmediately, bearer) {
    var self2 = this;
    var request2 = self2.request;
    var authHeader;
    if (bearer === void 0 && user === void 0) {
      self2.request.emit("error", new Error("no auth mechanism defined"));
    } else if (bearer !== void 0) {
      authHeader = self2.bearer(bearer, sendImmediately);
    } else {
      authHeader = self2.basic(user, pass, sendImmediately);
    }
    if (authHeader) {
      request2.setHeader("authorization", authHeader);
    }
  };
  Auth.prototype.onResponse = function(response) {
    var self2 = this;
    var request2 = self2.request;
    if (!self2.hasAuth || self2.sentAuth) {
      return null;
    }
    var c = caseless2(response.headers);
    var authHeader = c.get("www-authenticate");
    var authVerb = authHeader && authHeader.split(" ")[0].toLowerCase();
    request2.debug("reauth", authVerb);
    switch (authVerb) {
      case "basic":
        return self2.basic(self2.user, self2.pass, true);
      case "bearer":
        return self2.bearer(self2.bearerToken, true);
      case "digest":
        return self2.digest(request2.method, request2.path, authHeader);
    }
  };
  auth.Auth = Auth;
  return auth;
}
var oauth = {};
var oauthSign = {};
var hasRequiredOauthSign;
function requireOauthSign() {
  if (hasRequiredOauthSign) return oauthSign;
  hasRequiredOauthSign = 1;
  var crypto = require$$0$9;
  function sha(key2, body, algorithm) {
    return crypto.createHmac(algorithm, key2).update(body).digest("base64");
  }
  function rsa(key2, body) {
    return crypto.createSign("RSA-SHA1").update(body).sign(key2, "base64");
  }
  function rfc3986(str) {
    return encodeURIComponent(str).replace(/!/g, "%21").replace(/\*/g, "%2A").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/'/g, "%27");
  }
  function map(obj) {
    var key2, val, arr = [];
    for (key2 in obj) {
      val = obj[key2];
      if (Array.isArray(val))
        for (var i = 0; i < val.length; i++)
          arr.push([key2, val[i]]);
      else if (typeof val === "object")
        for (var prop in val)
          arr.push([key2 + "[" + prop + "]", val[prop]]);
      else
        arr.push([key2, val]);
    }
    return arr;
  }
  function compare(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
  }
  function generateBase(httpMethod, base_uri, params) {
    var normalized = map(params).map(function(p) {
      return [rfc3986(p[0]), rfc3986(p[1] || "")];
    }).sort(function(a, b) {
      return compare(a[0], b[0]) || compare(a[1], b[1]);
    }).map(function(p) {
      return p.join("=");
    }).join("&");
    var base = [
      rfc3986(httpMethod ? httpMethod.toUpperCase() : "GET"),
      rfc3986(base_uri),
      rfc3986(normalized)
    ].join("&");
    return base;
  }
  function hmacsign(httpMethod, base_uri, params, consumer_secret, token_secret) {
    var base = generateBase(httpMethod, base_uri, params);
    var key2 = [
      consumer_secret || "",
      token_secret || ""
    ].map(rfc3986).join("&");
    return sha(key2, base, "sha1");
  }
  function hmacsign256(httpMethod, base_uri, params, consumer_secret, token_secret) {
    var base = generateBase(httpMethod, base_uri, params);
    var key2 = [
      consumer_secret || "",
      token_secret || ""
    ].map(rfc3986).join("&");
    return sha(key2, base, "sha256");
  }
  function rsasign(httpMethod, base_uri, params, private_key, token_secret) {
    var base = generateBase(httpMethod, base_uri, params);
    var key2 = private_key || "";
    return rsa(key2, base);
  }
  function plaintext(consumer_secret, token_secret) {
    var key2 = [
      consumer_secret || "",
      token_secret || ""
    ].map(rfc3986).join("&");
    return key2;
  }
  function sign(signMethod, httpMethod, base_uri, params, consumer_secret, token_secret) {
    var method;
    var skipArgs = 1;
    switch (signMethod) {
      case "RSA-SHA1":
        method = rsasign;
        break;
      case "HMAC-SHA1":
        method = hmacsign;
        break;
      case "HMAC-SHA256":
        method = hmacsign256;
        break;
      case "PLAINTEXT":
        method = plaintext;
        skipArgs = 4;
        break;
      default:
        throw new Error("Signature method not supported: " + signMethod);
    }
    return method.apply(null, [].slice.call(arguments, skipArgs));
  }
  oauthSign.hmacsign = hmacsign;
  oauthSign.hmacsign256 = hmacsign256;
  oauthSign.rsasign = rsasign;
  oauthSign.plaintext = plaintext;
  oauthSign.sign = sign;
  oauthSign.rfc3986 = rfc3986;
  oauthSign.generateBase = generateBase;
  return oauthSign;
}
var hasRequiredOauth;
function requireOauth() {
  if (hasRequiredOauth) return oauth;
  hasRequiredOauth = 1;
  var url = require$$0$7;
  var qs = requireLib$1();
  var caseless2 = requireCaseless();
  var uuid = requireV4();
  var oauth$1 = requireOauthSign();
  var crypto = require$$0$9;
  var Buffer2 = requireSafeBuffer().Buffer;
  function OAuth(request2) {
    this.request = request2;
    this.params = null;
  }
  OAuth.prototype.buildParams = function(_oauth, uri, method, query, form, qsLib) {
    var oa = {};
    for (var i in _oauth) {
      oa["oauth_" + i] = _oauth[i];
    }
    if (!oa.oauth_version) {
      oa.oauth_version = "1.0";
    }
    if (!oa.oauth_timestamp) {
      oa.oauth_timestamp = Math.floor(Date.now() / 1e3).toString();
    }
    if (!oa.oauth_nonce) {
      oa.oauth_nonce = uuid().replace(/-/g, "");
    }
    if (!oa.oauth_signature_method) {
      oa.oauth_signature_method = "HMAC-SHA1";
    }
    var consumer_secret_or_private_key = oa.oauth_consumer_secret || oa.oauth_private_key;
    delete oa.oauth_consumer_secret;
    delete oa.oauth_private_key;
    var token_secret = oa.oauth_token_secret;
    delete oa.oauth_token_secret;
    var realm = oa.oauth_realm;
    delete oa.oauth_realm;
    delete oa.oauth_transport_method;
    var baseurl = uri.protocol + "//" + uri.host + uri.pathname;
    var params = qsLib.parse([].concat(query, form, qsLib.stringify(oa)).join("&"));
    oa.oauth_signature = oauth$1.sign(
      oa.oauth_signature_method,
      method,
      baseurl,
      params,
      consumer_secret_or_private_key,
      // eslint-disable-line camelcase
      token_secret
      // eslint-disable-line camelcase
    );
    if (realm) {
      oa.realm = realm;
    }
    return oa;
  };
  OAuth.prototype.buildBodyHash = function(_oauth, body) {
    if (["HMAC-SHA1", "RSA-SHA1"].indexOf(_oauth.signature_method || "HMAC-SHA1") < 0) {
      this.request.emit("error", new Error("oauth: " + _oauth.signature_method + " signature_method not supported with body_hash signing."));
    }
    var shasum = crypto.createHash("sha1");
    shasum.update(body || "");
    var sha1 = shasum.digest("hex");
    return Buffer2.from(sha1, "hex").toString("base64");
  };
  OAuth.prototype.concatParams = function(oa, sep, wrap) {
    wrap = wrap || "";
    var params = Object.keys(oa).filter(function(i) {
      return i !== "realm" && i !== "oauth_signature";
    }).sort();
    if (oa.realm) {
      params.splice(0, 0, "realm");
    }
    params.push("oauth_signature");
    return params.map(function(i) {
      return i + "=" + wrap + oauth$1.rfc3986(oa[i]) + wrap;
    }).join(sep);
  };
  OAuth.prototype.onRequest = function(_oauth) {
    var self2 = this;
    self2.params = _oauth;
    var uri = self2.request.uri || {};
    var method = self2.request.method || "";
    var headers = caseless2(self2.request.headers);
    var body = self2.request.body || "";
    var qsLib = self2.request.qsLib || qs;
    var form;
    var query;
    var contentType = headers.get("content-type") || "";
    var formContentType = "application/x-www-form-urlencoded";
    var transport = _oauth.transport_method || "header";
    if (contentType.slice(0, formContentType.length) === formContentType) {
      contentType = formContentType;
      form = body;
    }
    if (uri.query) {
      query = uri.query;
    }
    if (transport === "body" && (method !== "POST" || contentType !== formContentType)) {
      self2.request.emit("error", new Error("oauth: transport_method of body requires POST and content-type " + formContentType));
    }
    if (!form && typeof _oauth.body_hash === "boolean") {
      _oauth.body_hash = self2.buildBodyHash(_oauth, self2.request.body.toString());
    }
    var oa = self2.buildParams(_oauth, uri, method, query, form, qsLib);
    switch (transport) {
      case "header":
        self2.request.setHeader("Authorization", "OAuth " + self2.concatParams(oa, ",", '"'));
        break;
      case "query":
        var href = self2.request.uri.href += (query ? "&" : "?") + self2.concatParams(oa, "&");
        self2.request.uri = url.parse(href);
        self2.request.path = self2.request.uri.path;
        break;
      case "body":
        self2.request.body = (form ? form + "&" : "") + self2.concatParams(oa, "&");
        break;
      default:
        self2.request.emit("error", new Error("oauth: transport_method invalid"));
    }
  };
  oauth.OAuth = OAuth;
  return oauth;
}
var hawk = {};
var hasRequiredHawk;
function requireHawk() {
  if (hasRequiredHawk) return hawk;
  hasRequiredHawk = 1;
  (function(exports$1) {
    var crypto = require$$0$9;
    function randomString(size) {
      var bits = (size + 1) * 6;
      var buffer = crypto.randomBytes(Math.ceil(bits / 8));
      var string = buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
      return string.slice(0, size);
    }
    function calculatePayloadHash(payload, algorithm, contentType) {
      var hash = crypto.createHash(algorithm);
      hash.update("hawk.1.payload\n");
      hash.update((contentType ? contentType.split(";")[0].trim().toLowerCase() : "") + "\n");
      hash.update(payload || "");
      hash.update("\n");
      return hash.digest("base64");
    }
    exports$1.calculateMac = function(credentials, opts) {
      var normalized = "hawk.1.header\n" + opts.ts + "\n" + opts.nonce + "\n" + (opts.method || "").toUpperCase() + "\n" + opts.resource + "\n" + opts.host.toLowerCase() + "\n" + opts.port + "\n" + (opts.hash || "") + "\n";
      if (opts.ext) {
        normalized = normalized + opts.ext.replace("\\", "\\\\").replace("\n", "\\n");
      }
      normalized = normalized + "\n";
      if (opts.app) {
        normalized = normalized + opts.app + "\n" + (opts.dlg || "") + "\n";
      }
      var hmac = crypto.createHmac(credentials.algorithm, credentials.key).update(normalized);
      var digest = hmac.digest("base64");
      return digest;
    };
    exports$1.header = function(uri, method, opts) {
      var timestamp = opts.timestamp || Math.floor((Date.now() + (opts.localtimeOffsetMsec || 0)) / 1e3);
      var credentials = opts.credentials;
      if (!credentials || !credentials.id || !credentials.key || !credentials.algorithm) {
        return "";
      }
      if (["sha1", "sha256"].indexOf(credentials.algorithm) === -1) {
        return "";
      }
      var artifacts = {
        ts: timestamp,
        nonce: opts.nonce || randomString(6),
        method,
        resource: uri.pathname + (uri.search || ""),
        host: uri.hostname,
        port: uri.port || (uri.protocol === "http:" ? 80 : 443),
        hash: opts.hash,
        ext: opts.ext,
        app: opts.app,
        dlg: opts.dlg
      };
      if (!artifacts.hash && (opts.payload || opts.payload === "")) {
        artifacts.hash = calculatePayloadHash(opts.payload, credentials.algorithm, opts.contentType);
      }
      var mac = exports$1.calculateMac(credentials, artifacts);
      var hasExt = artifacts.ext !== null && artifacts.ext !== void 0 && artifacts.ext !== "";
      var header = 'Hawk id="' + credentials.id + '", ts="' + artifacts.ts + '", nonce="' + artifacts.nonce + (artifacts.hash ? '", hash="' + artifacts.hash : "") + (hasExt ? '", ext="' + artifacts.ext.replace(/\\/g, "\\\\").replace(/"/g, '\\"') : "") + '", mac="' + mac + '"';
      if (artifacts.app) {
        header = header + ', app="' + artifacts.app + (artifacts.dlg ? '", dlg="' + artifacts.dlg : "") + '"';
      }
      return header;
    };
  })(hawk);
  return hawk;
}
var multipart = {};
var hasRequiredMultipart;
function requireMultipart() {
  if (hasRequiredMultipart) return multipart;
  hasRequiredMultipart = 1;
  var uuid = requireV4();
  var CombinedStream = requireCombined_stream();
  var isstream2 = requireIsstream();
  var Buffer2 = requireSafeBuffer().Buffer;
  function Multipart(request2) {
    this.request = request2;
    this.boundary = uuid();
    this.chunked = false;
    this.body = null;
  }
  Multipart.prototype.isChunked = function(options) {
    var self2 = this;
    var chunked = false;
    var parts = options.data || options;
    if (!parts.forEach) {
      self2.request.emit("error", new Error("Argument error, options.multipart."));
    }
    if (options.chunked !== void 0) {
      chunked = options.chunked;
    }
    if (self2.request.getHeader("transfer-encoding") === "chunked") {
      chunked = true;
    }
    if (!chunked) {
      parts.forEach(function(part) {
        if (typeof part.body === "undefined") {
          self2.request.emit("error", new Error("Body attribute missing in multipart."));
        }
        if (isstream2(part.body)) {
          chunked = true;
        }
      });
    }
    return chunked;
  };
  Multipart.prototype.setHeaders = function(chunked) {
    var self2 = this;
    if (chunked && !self2.request.hasHeader("transfer-encoding")) {
      self2.request.setHeader("transfer-encoding", "chunked");
    }
    var header = self2.request.getHeader("content-type");
    if (!header || header.indexOf("multipart") === -1) {
      self2.request.setHeader("content-type", "multipart/related; boundary=" + self2.boundary);
    } else {
      if (header.indexOf("boundary") !== -1) {
        self2.boundary = header.replace(/.*boundary=([^\s;]+).*/, "$1");
      } else {
        self2.request.setHeader("content-type", header + "; boundary=" + self2.boundary);
      }
    }
  };
  Multipart.prototype.build = function(parts, chunked) {
    var self2 = this;
    var body = chunked ? new CombinedStream() : [];
    function add(part) {
      if (typeof part === "number") {
        part = part.toString();
      }
      return chunked ? body.append(part) : body.push(Buffer2.from(part));
    }
    if (self2.request.preambleCRLF) {
      add("\r\n");
    }
    parts.forEach(function(part) {
      var preamble = "--" + self2.boundary + "\r\n";
      Object.keys(part).forEach(function(key2) {
        if (key2 === "body") {
          return;
        }
        preamble += key2 + ": " + part[key2] + "\r\n";
      });
      preamble += "\r\n";
      add(preamble);
      add(part.body);
      add("\r\n");
    });
    add("--" + self2.boundary + "--");
    if (self2.request.postambleCRLF) {
      add("\r\n");
    }
    return body;
  };
  Multipart.prototype.onRequest = function(options) {
    var self2 = this;
    var chunked = self2.isChunked(options);
    var parts = options.data || options;
    self2.setHeaders(chunked);
    self2.chunked = chunked;
    self2.body = self2.build(parts, chunked);
  };
  multipart.Multipart = Multipart;
  return multipart;
}
var redirect = {};
var hasRequiredRedirect;
function requireRedirect() {
  if (hasRequiredRedirect) return redirect;
  hasRequiredRedirect = 1;
  var url = require$$0$7;
  var isUrl = /^https?:/;
  function Redirect(request2) {
    this.request = request2;
    this.followRedirect = true;
    this.followRedirects = true;
    this.followAllRedirects = false;
    this.followOriginalHttpMethod = false;
    this.allowRedirect = function() {
      return true;
    };
    this.maxRedirects = 10;
    this.redirects = [];
    this.redirectsFollowed = 0;
    this.removeRefererHeader = false;
  }
  Redirect.prototype.onRequest = function(options) {
    var self2 = this;
    if (options.maxRedirects !== void 0) {
      self2.maxRedirects = options.maxRedirects;
    }
    if (typeof options.followRedirect === "function") {
      self2.allowRedirect = options.followRedirect;
    }
    if (options.followRedirect !== void 0) {
      self2.followRedirects = !!options.followRedirect;
    }
    if (options.followAllRedirects !== void 0) {
      self2.followAllRedirects = options.followAllRedirects;
    }
    if (self2.followRedirects || self2.followAllRedirects) {
      self2.redirects = self2.redirects || [];
    }
    if (options.removeRefererHeader !== void 0) {
      self2.removeRefererHeader = options.removeRefererHeader;
    }
    if (options.followOriginalHttpMethod !== void 0) {
      self2.followOriginalHttpMethod = options.followOriginalHttpMethod;
    }
  };
  Redirect.prototype.redirectTo = function(response) {
    var self2 = this;
    var request2 = self2.request;
    var redirectTo = null;
    if (response.statusCode >= 300 && response.statusCode < 400 && response.caseless.has("location")) {
      var location = response.caseless.get("location");
      request2.debug("redirect", location);
      if (self2.followAllRedirects) {
        redirectTo = location;
      } else if (self2.followRedirects) {
        switch (request2.method) {
          case "PATCH":
          case "PUT":
          case "POST":
          case "DELETE":
            break;
          default:
            redirectTo = location;
            break;
        }
      }
    } else if (response.statusCode === 401) {
      var authHeader = request2._auth.onResponse(response);
      if (authHeader) {
        request2.setHeader("authorization", authHeader);
        redirectTo = request2.uri;
      }
    }
    return redirectTo;
  };
  Redirect.prototype.onResponse = function(response) {
    var self2 = this;
    var request2 = self2.request;
    var redirectTo = self2.redirectTo(response);
    if (!redirectTo || !self2.allowRedirect.call(request2, response)) {
      return false;
    }
    request2.debug("redirect to", redirectTo);
    if (response.resume) {
      response.resume();
    }
    if (self2.redirectsFollowed >= self2.maxRedirects) {
      request2.emit("error", new Error("Exceeded maxRedirects. Probably stuck in a redirect loop " + request2.uri.href));
      return false;
    }
    self2.redirectsFollowed += 1;
    if (!isUrl.test(redirectTo)) {
      redirectTo = url.resolve(request2.uri.href, redirectTo);
    }
    var uriPrev = request2.uri;
    request2.uri = url.parse(redirectTo);
    if (request2.uri.protocol !== uriPrev.protocol) {
      delete request2.agent;
    }
    self2.redirects.push({ statusCode: response.statusCode, redirectUri: redirectTo });
    if (self2.followAllRedirects && request2.method !== "HEAD" && response.statusCode !== 401 && response.statusCode !== 307) {
      request2.method = self2.followOriginalHttpMethod ? request2.method : "GET";
    }
    delete request2.src;
    delete request2.req;
    delete request2._started;
    if (response.statusCode !== 401 && response.statusCode !== 307) {
      delete request2.body;
      delete request2._form;
      if (request2.headers) {
        request2.removeHeader("host");
        request2.removeHeader("content-type");
        request2.removeHeader("content-length");
        if (request2.uri.hostname !== request2.originalHost.split(":")[0]) {
          request2.removeHeader("authorization");
        }
      }
    }
    if (!self2.removeRefererHeader) {
      request2.setHeader("referer", uriPrev.href);
    }
    request2.emit("redirect");
    request2.init();
    return true;
  };
  redirect.Redirect = Redirect;
  return redirect;
}
var tunnel = {};
var tunnelAgent = {};
var hasRequiredTunnelAgent;
function requireTunnelAgent() {
  if (hasRequiredTunnelAgent) return tunnelAgent;
  hasRequiredTunnelAgent = 1;
  var tls = require$$3$3, http = require$$2$2, https = require$$4$2, events = require$$0$b, assert = require$$0$6, util2 = require$$0$5, Buffer2 = requireSafeBuffer().Buffer;
  tunnelAgent.httpOverHttp = httpOverHttp;
  tunnelAgent.httpsOverHttp = httpsOverHttp;
  tunnelAgent.httpOverHttps = httpOverHttps;
  tunnelAgent.httpsOverHttps = httpsOverHttps;
  function httpOverHttp(options) {
    var agent = new TunnelingAgent(options);
    agent.request = http.request;
    return agent;
  }
  function httpsOverHttp(options) {
    var agent = new TunnelingAgent(options);
    agent.request = http.request;
    agent.createSocket = createSecureSocket;
    agent.defaultPort = 443;
    return agent;
  }
  function httpOverHttps(options) {
    var agent = new TunnelingAgent(options);
    agent.request = https.request;
    return agent;
  }
  function httpsOverHttps(options) {
    var agent = new TunnelingAgent(options);
    agent.request = https.request;
    agent.createSocket = createSecureSocket;
    agent.defaultPort = 443;
    return agent;
  }
  function TunnelingAgent(options) {
    var self2 = this;
    self2.options = options || {};
    self2.proxyOptions = self2.options.proxy || {};
    self2.maxSockets = self2.options.maxSockets || http.Agent.defaultMaxSockets;
    self2.requests = [];
    self2.sockets = [];
    self2.on("free", function onFree(socket, host, port) {
      for (var i = 0, len = self2.requests.length; i < len; ++i) {
        var pending = self2.requests[i];
        if (pending.host === host && pending.port === port) {
          self2.requests.splice(i, 1);
          pending.request.onSocket(socket);
          return;
        }
      }
      socket.destroy();
      self2.removeSocket(socket);
    });
  }
  util2.inherits(TunnelingAgent, events.EventEmitter);
  TunnelingAgent.prototype.addRequest = function addRequest(req, options) {
    var self2 = this;
    if (typeof options === "string") {
      options = {
        host: options,
        port: arguments[2],
        path: arguments[3]
      };
    }
    if (self2.sockets.length >= this.maxSockets) {
      self2.requests.push({ host: options.host, port: options.port, request: req });
      return;
    }
    self2.createConnection({ host: options.host, port: options.port, request: req });
  };
  TunnelingAgent.prototype.createConnection = function createConnection(pending) {
    var self2 = this;
    self2.createSocket(pending, function(socket) {
      socket.on("free", onFree);
      socket.on("close", onCloseOrRemove);
      socket.on("agentRemove", onCloseOrRemove);
      pending.request.onSocket(socket);
      function onFree() {
        self2.emit("free", socket, pending.host, pending.port);
      }
      function onCloseOrRemove(err) {
        self2.removeSocket(socket);
        socket.removeListener("free", onFree);
        socket.removeListener("close", onCloseOrRemove);
        socket.removeListener("agentRemove", onCloseOrRemove);
      }
    });
  };
  TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
    var self2 = this;
    var placeholder = {};
    self2.sockets.push(placeholder);
    var connectOptions = mergeOptions(
      {},
      self2.proxyOptions,
      {
        method: "CONNECT",
        path: options.host + ":" + options.port,
        agent: false
      }
    );
    if (connectOptions.proxyAuth) {
      connectOptions.headers = connectOptions.headers || {};
      connectOptions.headers["Proxy-Authorization"] = "Basic " + Buffer2.from(connectOptions.proxyAuth).toString("base64");
    }
    debug("making CONNECT request");
    var connectReq = self2.request(connectOptions);
    connectReq.useChunkedEncodingByDefault = false;
    connectReq.once("response", onResponse);
    connectReq.once("upgrade", onUpgrade);
    connectReq.once("connect", onConnect);
    connectReq.once("error", onError);
    connectReq.end();
    function onResponse(res) {
      res.upgrade = true;
    }
    function onUpgrade(res, socket, head) {
      process.nextTick(function() {
        onConnect(res, socket, head);
      });
    }
    function onConnect(res, socket, head) {
      connectReq.removeAllListeners();
      socket.removeAllListeners();
      if (res.statusCode === 200) {
        assert.equal(head.length, 0);
        debug("tunneling connection has established");
        self2.sockets[self2.sockets.indexOf(placeholder)] = socket;
        cb(socket);
      } else {
        debug("tunneling socket could not be established, statusCode=%d", res.statusCode);
        var error2 = new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
        error2.code = "ECONNRESET";
        options.request.emit("error", error2);
        self2.removeSocket(placeholder);
      }
    }
    function onError(cause) {
      connectReq.removeAllListeners();
      debug("tunneling socket could not be established, cause=%s\n", cause.message, cause.stack);
      var error2 = new Error("tunneling socket could not be established, cause=" + cause.message);
      error2.code = "ECONNRESET";
      options.request.emit("error", error2);
      self2.removeSocket(placeholder);
    }
  };
  TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
    var pos = this.sockets.indexOf(socket);
    if (pos === -1) return;
    this.sockets.splice(pos, 1);
    var pending = this.requests.shift();
    if (pending) {
      this.createConnection(pending);
    }
  };
  function createSecureSocket(options, cb) {
    var self2 = this;
    TunnelingAgent.prototype.createSocket.call(self2, options, function(socket) {
      var secureSocket = tls.connect(0, mergeOptions(
        {},
        self2.options,
        {
          servername: options.host,
          socket
        }
      ));
      self2.sockets[self2.sockets.indexOf(socket)] = secureSocket;
      cb(secureSocket);
    });
  }
  function mergeOptions(target) {
    for (var i = 1, len = arguments.length; i < len; ++i) {
      var overrides = arguments[i];
      if (typeof overrides === "object") {
        var keys = Object.keys(overrides);
        for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
          var k = keys[j];
          if (overrides[k] !== void 0) {
            target[k] = overrides[k];
          }
        }
      }
    }
    return target;
  }
  var debug;
  if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
    debug = function() {
      var args = Array.prototype.slice.call(arguments);
      if (typeof args[0] === "string") {
        args[0] = "TUNNEL: " + args[0];
      } else {
        args.unshift("TUNNEL:");
      }
      console.error.apply(console, args);
    };
  } else {
    debug = function() {
    };
  }
  tunnelAgent.debug = debug;
  return tunnelAgent;
}
var hasRequiredTunnel;
function requireTunnel() {
  if (hasRequiredTunnel) return tunnel;
  hasRequiredTunnel = 1;
  var url = require$$0$7;
  var tunnel$1 = requireTunnelAgent();
  var defaultProxyHeaderWhiteList = [
    "accept",
    "accept-charset",
    "accept-encoding",
    "accept-language",
    "accept-ranges",
    "cache-control",
    "content-encoding",
    "content-language",
    "content-location",
    "content-md5",
    "content-range",
    "content-type",
    "connection",
    "date",
    "expect",
    "max-forwards",
    "pragma",
    "referer",
    "te",
    "user-agent",
    "via"
  ];
  var defaultProxyHeaderExclusiveList = [
    "proxy-authorization"
  ];
  function constructProxyHost(uriObject) {
    var port = uriObject.port;
    var protocol = uriObject.protocol;
    var proxyHost = uriObject.hostname + ":";
    if (port) {
      proxyHost += port;
    } else if (protocol === "https:") {
      proxyHost += "443";
    } else {
      proxyHost += "80";
    }
    return proxyHost;
  }
  function constructProxyHeaderWhiteList(headers, proxyHeaderWhiteList) {
    var whiteList = proxyHeaderWhiteList.reduce(function(set, header) {
      set[header.toLowerCase()] = true;
      return set;
    }, {});
    return Object.keys(headers).filter(function(header) {
      return whiteList[header.toLowerCase()];
    }).reduce(function(set, header) {
      set[header] = headers[header];
      return set;
    }, {});
  }
  function constructTunnelOptions(request2, proxyHeaders) {
    var proxy = request2.proxy;
    var tunnelOptions = {
      proxy: {
        host: proxy.hostname,
        port: +proxy.port,
        proxyAuth: proxy.auth,
        headers: proxyHeaders
      },
      headers: request2.headers,
      ca: request2.ca,
      cert: request2.cert,
      key: request2.key,
      passphrase: request2.passphrase,
      pfx: request2.pfx,
      ciphers: request2.ciphers,
      rejectUnauthorized: request2.rejectUnauthorized,
      secureOptions: request2.secureOptions,
      secureProtocol: request2.secureProtocol
    };
    return tunnelOptions;
  }
  function constructTunnelFnName(uri, proxy) {
    var uriProtocol = uri.protocol === "https:" ? "https" : "http";
    var proxyProtocol = proxy.protocol === "https:" ? "Https" : "Http";
    return [uriProtocol, proxyProtocol].join("Over");
  }
  function getTunnelFn(request2) {
    var uri = request2.uri;
    var proxy = request2.proxy;
    var tunnelFnName = constructTunnelFnName(uri, proxy);
    return tunnel$1[tunnelFnName];
  }
  function Tunnel(request2) {
    this.request = request2;
    this.proxyHeaderWhiteList = defaultProxyHeaderWhiteList;
    this.proxyHeaderExclusiveList = [];
    if (typeof request2.tunnel !== "undefined") {
      this.tunnelOverride = request2.tunnel;
    }
  }
  Tunnel.prototype.isEnabled = function() {
    var self2 = this;
    var request2 = self2.request;
    if (typeof self2.tunnelOverride !== "undefined") {
      return self2.tunnelOverride;
    }
    if (request2.uri.protocol === "https:") {
      return true;
    }
    return false;
  };
  Tunnel.prototype.setup = function(options) {
    var self2 = this;
    var request2 = self2.request;
    options = options || {};
    if (typeof request2.proxy === "string") {
      request2.proxy = url.parse(request2.proxy);
    }
    if (!request2.proxy || !request2.tunnel) {
      return false;
    }
    if (options.proxyHeaderWhiteList) {
      self2.proxyHeaderWhiteList = options.proxyHeaderWhiteList;
    }
    if (options.proxyHeaderExclusiveList) {
      self2.proxyHeaderExclusiveList = options.proxyHeaderExclusiveList;
    }
    var proxyHeaderExclusiveList = self2.proxyHeaderExclusiveList.concat(defaultProxyHeaderExclusiveList);
    var proxyHeaderWhiteList = self2.proxyHeaderWhiteList.concat(proxyHeaderExclusiveList);
    var proxyHeaders = constructProxyHeaderWhiteList(request2.headers, proxyHeaderWhiteList);
    proxyHeaders.host = constructProxyHost(request2.uri);
    proxyHeaderExclusiveList.forEach(request2.removeHeader, request2);
    var tunnelFn = getTunnelFn(request2);
    var tunnelOptions = constructTunnelOptions(request2, proxyHeaders);
    request2.agent = tunnelFn(tunnelOptions);
    return true;
  };
  Tunnel.defaultProxyHeaderWhiteList = defaultProxyHeaderWhiteList;
  Tunnel.defaultProxyHeaderExclusiveList = defaultProxyHeaderExclusiveList;
  tunnel.Tunnel = Tunnel;
  return tunnel;
}
var performanceNow$1 = { exports: {} };
var performanceNow = performanceNow$1.exports;
var hasRequiredPerformanceNow;
function requirePerformanceNow() {
  if (hasRequiredPerformanceNow) return performanceNow$1.exports;
  hasRequiredPerformanceNow = 1;
  (function() {
    var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
    if (typeof performance !== "undefined" && performance !== null && performance.now) {
      performanceNow$1.exports = function() {
        return performance.now();
      };
    } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
      performanceNow$1.exports = function() {
        return (getNanoSeconds() - nodeLoadTime) / 1e6;
      };
      hrtime = process.hrtime;
      getNanoSeconds = function() {
        var hr;
        hr = hrtime();
        return hr[0] * 1e9 + hr[1];
      };
      moduleLoadTime = getNanoSeconds();
      upTime = process.uptime() * 1e9;
      nodeLoadTime = moduleLoadTime - upTime;
    } else if (Date.now) {
      performanceNow$1.exports = function() {
        return Date.now() - loadTime;
      };
      loadTime = Date.now();
    } else {
      performanceNow$1.exports = function() {
        return (/* @__PURE__ */ new Date()).getTime() - loadTime;
      };
      loadTime = (/* @__PURE__ */ new Date()).getTime();
    }
  }).call(performanceNow);
  return performanceNow$1.exports;
}
var request;
var hasRequiredRequest$1;
function requireRequest$1() {
  if (hasRequiredRequest$1) return request;
  hasRequiredRequest$1 = 1;
  var http = require$$2$2;
  var https = require$$4$2;
  var url = require$$0$7;
  var util2 = require$$0$5;
  var stream = require$$1$2;
  var zlib = require$$0$3;
  var aws2 = requireAwsSign2();
  var aws42 = requireAws4();
  var httpSignature = requireLib$2();
  var mime = requireMimeTypes();
  var caseless2 = requireCaseless();
  var ForeverAgent = requireForeverAgent();
  var FormData = requireForm_data();
  var extend2 = requireExtend();
  var isstream2 = requireIsstream();
  var isTypedArray = requireIsTypedarray().strict;
  var helpers2 = requireHelpers();
  var cookies2 = requireCookies();
  var getProxyFromURI = requireGetProxyFromURI();
  var Querystring = requireQuerystring().Querystring;
  var Har = requireHar().Har;
  var Auth = requireAuth().Auth;
  var OAuth = requireOauth().OAuth;
  var hawk2 = requireHawk();
  var Multipart = requireMultipart().Multipart;
  var Redirect = requireRedirect().Redirect;
  var Tunnel = requireTunnel().Tunnel;
  var now = requirePerformanceNow();
  var Buffer2 = requireSafeBuffer().Buffer;
  var safeStringify = helpers2.safeStringify;
  var isReadStream = helpers2.isReadStream;
  var toBase64 = helpers2.toBase64;
  var defer = helpers2.defer;
  var copy = helpers2.copy;
  var version2 = helpers2.version;
  var globalCookieJar = cookies2.jar();
  var globalPool = {};
  function filterForNonReserved(reserved, options) {
    var object = {};
    for (var i in options) {
      var notReserved = reserved.indexOf(i) === -1;
      if (notReserved) {
        object[i] = options[i];
      }
    }
    return object;
  }
  function filterOutReservedFunctions(reserved, options) {
    var object = {};
    for (var i in options) {
      var isReserved = !(reserved.indexOf(i) === -1);
      var isFunction = typeof options[i] === "function";
      if (!(isReserved && isFunction)) {
        object[i] = options[i];
      }
    }
    return object;
  }
  function requestToJSON() {
    var self2 = this;
    return {
      uri: self2.uri,
      method: self2.method,
      headers: self2.headers
    };
  }
  function responseToJSON() {
    var self2 = this;
    return {
      statusCode: self2.statusCode,
      body: self2.body,
      headers: self2.headers,
      request: requestToJSON.call(self2.request)
    };
  }
  function Request2(options) {
    var self2 = this;
    if (options.har) {
      self2._har = new Har(self2);
      options = self2._har.options(options);
    }
    stream.Stream.call(self2);
    var reserved = Object.keys(Request2.prototype);
    var nonReserved = filterForNonReserved(reserved, options);
    extend2(self2, nonReserved);
    options = filterOutReservedFunctions(reserved, options);
    self2.readable = true;
    self2.writable = true;
    if (options.method) {
      self2.explicitMethod = true;
    }
    self2._qs = new Querystring(self2);
    self2._auth = new Auth(self2);
    self2._oauth = new OAuth(self2);
    self2._multipart = new Multipart(self2);
    self2._redirect = new Redirect(self2);
    self2._tunnel = new Tunnel(self2);
    self2.init(options);
  }
  util2.inherits(Request2, stream.Stream);
  Request2.debug = process.env.NODE_DEBUG && /\brequest\b/.test(process.env.NODE_DEBUG);
  function debug() {
    if (Request2.debug) {
      console.error("REQUEST %s", util2.format.apply(util2, arguments));
    }
  }
  Request2.prototype.debug = debug;
  Request2.prototype.init = function(options) {
    var self2 = this;
    if (!options) {
      options = {};
    }
    self2.headers = self2.headers ? copy(self2.headers) : {};
    for (var headerName in self2.headers) {
      if (typeof self2.headers[headerName] === "undefined") {
        delete self2.headers[headerName];
      }
    }
    caseless2.httpify(self2, self2.headers);
    if (!self2.method) {
      self2.method = options.method || "GET";
    }
    if (!self2.localAddress) {
      self2.localAddress = options.localAddress;
    }
    self2._qs.init(options);
    debug(options);
    if (!self2.pool && self2.pool !== false) {
      self2.pool = globalPool;
    }
    self2.dests = self2.dests || [];
    self2.__isRequestRequest = true;
    if (!self2._callback && self2.callback) {
      self2._callback = self2.callback;
      self2.callback = function() {
        if (self2._callbackCalled) {
          return;
        }
        self2._callbackCalled = true;
        self2._callback.apply(self2, arguments);
      };
      self2.on("error", self2.callback.bind());
      self2.on("complete", self2.callback.bind(self2, null));
    }
    if (!self2.uri && self2.url) {
      self2.uri = self2.url;
      delete self2.url;
    }
    if (self2.baseUrl) {
      if (typeof self2.baseUrl !== "string") {
        return self2.emit("error", new Error("options.baseUrl must be a string"));
      }
      if (typeof self2.uri !== "string") {
        return self2.emit("error", new Error("options.uri must be a string when using options.baseUrl"));
      }
      if (self2.uri.indexOf("//") === 0 || self2.uri.indexOf("://") !== -1) {
        return self2.emit("error", new Error("options.uri must be a path when using options.baseUrl"));
      }
      var baseUrlEndsWithSlash = self2.baseUrl.lastIndexOf("/") === self2.baseUrl.length - 1;
      var uriStartsWithSlash = self2.uri.indexOf("/") === 0;
      if (baseUrlEndsWithSlash && uriStartsWithSlash) {
        self2.uri = self2.baseUrl + self2.uri.slice(1);
      } else if (baseUrlEndsWithSlash || uriStartsWithSlash) {
        self2.uri = self2.baseUrl + self2.uri;
      } else if (self2.uri === "") {
        self2.uri = self2.baseUrl;
      } else {
        self2.uri = self2.baseUrl + "/" + self2.uri;
      }
      delete self2.baseUrl;
    }
    if (!self2.uri) {
      return self2.emit("error", new Error("options.uri is a required argument"));
    }
    if (typeof self2.uri === "string") {
      self2.uri = url.parse(self2.uri);
    }
    if (!self2.uri.href) {
      self2.uri.href = url.format(self2.uri);
    }
    if (self2.uri.protocol === "unix:") {
      return self2.emit("error", new Error("`unix://` URL scheme is no longer supported. Please use the format `http://unix:SOCKET:PATH`"));
    }
    if (self2.uri.host === "unix") {
      self2.enableUnixSocket();
    }
    if (self2.strictSSL === false) {
      self2.rejectUnauthorized = false;
    }
    if (!self2.uri.pathname) {
      self2.uri.pathname = "/";
    }
    if (!(self2.uri.host || self2.uri.hostname && self2.uri.port) && !self2.uri.isUnix) {
      var faultyUri = url.format(self2.uri);
      var message = 'Invalid URI "' + faultyUri + '"';
      if (Object.keys(options).length === 0) {
        message += ". This can be caused by a crappy redirection.";
      }
      self2.abort();
      return self2.emit("error", new Error(message));
    }
    if (!self2.hasOwnProperty("proxy")) {
      self2.proxy = getProxyFromURI(self2.uri);
    }
    self2.tunnel = self2._tunnel.isEnabled();
    if (self2.proxy) {
      self2._tunnel.setup(options);
    }
    self2._redirect.onRequest(options);
    self2.setHost = false;
    if (!self2.hasHeader("host")) {
      var hostHeaderName = self2.originalHostHeaderName || "host";
      self2.setHeader(hostHeaderName, self2.uri.host);
      if (self2.uri.port) {
        if (self2.uri.port === "80" && self2.uri.protocol === "http:" || self2.uri.port === "443" && self2.uri.protocol === "https:") {
          self2.setHeader(hostHeaderName, self2.uri.hostname);
        }
      }
      self2.setHost = true;
    }
    self2.jar(self2._jar || options.jar);
    if (!self2.uri.port) {
      if (self2.uri.protocol === "http:") {
        self2.uri.port = 80;
      } else if (self2.uri.protocol === "https:") {
        self2.uri.port = 443;
      }
    }
    if (self2.proxy && !self2.tunnel) {
      self2.port = self2.proxy.port;
      self2.host = self2.proxy.hostname;
    } else {
      self2.port = self2.uri.port;
      self2.host = self2.uri.hostname;
    }
    if (options.form) {
      self2.form(options.form);
    }
    if (options.formData) {
      var formData = options.formData;
      var requestForm = self2.form();
      var appendFormValue = function(key2, value) {
        if (value && value.hasOwnProperty("value") && value.hasOwnProperty("options")) {
          requestForm.append(key2, value.value, value.options);
        } else {
          requestForm.append(key2, value);
        }
      };
      for (var formKey in formData) {
        if (formData.hasOwnProperty(formKey)) {
          var formValue = formData[formKey];
          if (formValue instanceof Array) {
            for (var j = 0; j < formValue.length; j++) {
              appendFormValue(formKey, formValue[j]);
            }
          } else {
            appendFormValue(formKey, formValue);
          }
        }
      }
    }
    if (options.qs) {
      self2.qs(options.qs);
    }
    if (self2.uri.path) {
      self2.path = self2.uri.path;
    } else {
      self2.path = self2.uri.pathname + (self2.uri.search || "");
    }
    if (self2.path.length === 0) {
      self2.path = "/";
    }
    if (options.aws) {
      self2.aws(options.aws);
    }
    if (options.hawk) {
      self2.hawk(options.hawk);
    }
    if (options.httpSignature) {
      self2.httpSignature(options.httpSignature);
    }
    if (options.auth) {
      if (Object.prototype.hasOwnProperty.call(options.auth, "username")) {
        options.auth.user = options.auth.username;
      }
      if (Object.prototype.hasOwnProperty.call(options.auth, "password")) {
        options.auth.pass = options.auth.password;
      }
      self2.auth(
        options.auth.user,
        options.auth.pass,
        options.auth.sendImmediately,
        options.auth.bearer
      );
    }
    if (self2.gzip && !self2.hasHeader("accept-encoding")) {
      self2.setHeader("accept-encoding", "gzip, deflate");
    }
    if (self2.uri.auth && !self2.hasHeader("authorization")) {
      var uriAuthPieces = self2.uri.auth.split(":").map(function(item) {
        return self2._qs.unescape(item);
      });
      self2.auth(uriAuthPieces[0], uriAuthPieces.slice(1).join(":"), true);
    }
    if (!self2.tunnel && self2.proxy && self2.proxy.auth && !self2.hasHeader("proxy-authorization")) {
      var proxyAuthPieces = self2.proxy.auth.split(":").map(function(item) {
        return self2._qs.unescape(item);
      });
      var authHeader = "Basic " + toBase64(proxyAuthPieces.join(":"));
      self2.setHeader("proxy-authorization", authHeader);
    }
    if (self2.proxy && !self2.tunnel) {
      self2.path = self2.uri.protocol + "//" + self2.uri.host + self2.path;
    }
    if (options.json) {
      self2.json(options.json);
    }
    if (options.multipart) {
      self2.multipart(options.multipart);
    }
    if (options.time) {
      self2.timing = true;
      self2.elapsedTime = self2.elapsedTime || 0;
    }
    function setContentLength() {
      if (isTypedArray(self2.body)) {
        self2.body = Buffer2.from(self2.body);
      }
      if (!self2.hasHeader("content-length")) {
        var length;
        if (typeof self2.body === "string") {
          length = Buffer2.byteLength(self2.body);
        } else if (Array.isArray(self2.body)) {
          length = self2.body.reduce(function(a, b) {
            return a + b.length;
          }, 0);
        } else {
          length = self2.body.length;
        }
        if (length) {
          self2.setHeader("content-length", length);
        } else {
          self2.emit("error", new Error("Argument error, options.body."));
        }
      }
    }
    if (self2.body && !isstream2(self2.body)) {
      setContentLength();
    }
    if (options.oauth) {
      self2.oauth(options.oauth);
    } else if (self2._oauth.params && self2.hasHeader("authorization")) {
      self2.oauth(self2._oauth.params);
    }
    var protocol = self2.proxy && !self2.tunnel ? self2.proxy.protocol : self2.uri.protocol;
    var defaultModules = { "http:": http, "https:": https };
    var httpModules = self2.httpModules || {};
    self2.httpModule = httpModules[protocol] || defaultModules[protocol];
    if (!self2.httpModule) {
      return self2.emit("error", new Error("Invalid protocol: " + protocol));
    }
    if (options.ca) {
      self2.ca = options.ca;
    }
    if (!self2.agent) {
      if (options.agentOptions) {
        self2.agentOptions = options.agentOptions;
      }
      if (options.agentClass) {
        self2.agentClass = options.agentClass;
      } else if (options.forever) {
        var v = version2();
        if (v.major === 0 && v.minor <= 10) {
          self2.agentClass = protocol === "http:" ? ForeverAgent : ForeverAgent.SSL;
        } else {
          self2.agentClass = self2.httpModule.Agent;
          self2.agentOptions = self2.agentOptions || {};
          self2.agentOptions.keepAlive = true;
        }
      } else {
        self2.agentClass = self2.httpModule.Agent;
      }
    }
    if (self2.pool === false) {
      self2.agent = false;
    } else {
      self2.agent = self2.agent || self2.getNewAgent();
    }
    self2.on("pipe", function(src) {
      if (self2.ntick && self2._started) {
        self2.emit("error", new Error("You cannot pipe to this stream after the outbound request has started."));
      }
      self2.src = src;
      if (isReadStream(src)) {
        if (!self2.hasHeader("content-type")) {
          self2.setHeader("content-type", mime.lookup(src.path));
        }
      } else {
        if (src.headers) {
          for (var i in src.headers) {
            if (!self2.hasHeader(i)) {
              self2.setHeader(i, src.headers[i]);
            }
          }
        }
        if (self2._json && !self2.hasHeader("content-type")) {
          self2.setHeader("content-type", "application/json");
        }
        if (src.method && !self2.explicitMethod) {
          self2.method = src.method;
        }
      }
    });
    defer(function() {
      if (self2._aborted) {
        return;
      }
      var end = function() {
        if (self2._form) {
          if (!self2._auth.hasAuth) {
            self2._form.pipe(self2);
          } else if (self2._auth.hasAuth && self2._auth.sentAuth) {
            self2._form.pipe(self2);
          }
        }
        if (self2._multipart && self2._multipart.chunked) {
          self2._multipart.body.pipe(self2);
        }
        if (self2.body) {
          if (isstream2(self2.body)) {
            self2.body.pipe(self2);
          } else {
            setContentLength();
            if (Array.isArray(self2.body)) {
              self2.body.forEach(function(part) {
                self2.write(part);
              });
            } else {
              self2.write(self2.body);
            }
            self2.end();
          }
        } else if (self2.requestBodyStream) {
          console.warn("options.requestBodyStream is deprecated, please pass the request object to stream.pipe.");
          self2.requestBodyStream.pipe(self2);
        } else if (!self2.src) {
          if (self2._auth.hasAuth && !self2._auth.sentAuth) {
            self2.end();
            return;
          }
          if (self2.method !== "GET" && typeof self2.method !== "undefined") {
            self2.setHeader("content-length", 0);
          }
          self2.end();
        }
      };
      if (self2._form && !self2.hasHeader("content-length")) {
        self2.setHeader(self2._form.getHeaders(), true);
        self2._form.getLength(function(err, length) {
          if (!err && !isNaN(length)) {
            self2.setHeader("content-length", length);
          }
          end();
        });
      } else {
        end();
      }
      self2.ntick = true;
    });
  };
  Request2.prototype.getNewAgent = function() {
    var self2 = this;
    var Agent = self2.agentClass;
    var options = {};
    if (self2.agentOptions) {
      for (var i in self2.agentOptions) {
        options[i] = self2.agentOptions[i];
      }
    }
    if (self2.ca) {
      options.ca = self2.ca;
    }
    if (self2.ciphers) {
      options.ciphers = self2.ciphers;
    }
    if (self2.secureProtocol) {
      options.secureProtocol = self2.secureProtocol;
    }
    if (self2.secureOptions) {
      options.secureOptions = self2.secureOptions;
    }
    if (typeof self2.rejectUnauthorized !== "undefined") {
      options.rejectUnauthorized = self2.rejectUnauthorized;
    }
    if (self2.cert && self2.key) {
      options.key = self2.key;
      options.cert = self2.cert;
    }
    if (self2.pfx) {
      options.pfx = self2.pfx;
    }
    if (self2.passphrase) {
      options.passphrase = self2.passphrase;
    }
    var poolKey = "";
    if (Agent !== self2.httpModule.Agent) {
      poolKey += Agent.name;
    }
    var proxy = self2.proxy;
    if (typeof proxy === "string") {
      proxy = url.parse(proxy);
    }
    var isHttps = proxy && proxy.protocol === "https:" || this.uri.protocol === "https:";
    if (isHttps) {
      if (options.ca) {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.ca;
      }
      if (typeof options.rejectUnauthorized !== "undefined") {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.rejectUnauthorized;
      }
      if (options.cert) {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.cert.toString("ascii") + options.key.toString("ascii");
      }
      if (options.pfx) {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.pfx.toString("ascii");
      }
      if (options.ciphers) {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.ciphers;
      }
      if (options.secureProtocol) {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.secureProtocol;
      }
      if (options.secureOptions) {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.secureOptions;
      }
    }
    if (self2.pool === globalPool && !poolKey && Object.keys(options).length === 0 && self2.httpModule.globalAgent) {
      return self2.httpModule.globalAgent;
    }
    poolKey = self2.uri.protocol + poolKey;
    if (!self2.pool[poolKey]) {
      self2.pool[poolKey] = new Agent(options);
      if (self2.pool.maxSockets) {
        self2.pool[poolKey].maxSockets = self2.pool.maxSockets;
      }
    }
    return self2.pool[poolKey];
  };
  Request2.prototype.start = function() {
    var self2 = this;
    if (self2.timing) {
      var startTime = (/* @__PURE__ */ new Date()).getTime();
      var startTimeNow = now();
    }
    if (self2._aborted) {
      return;
    }
    self2._started = true;
    self2.method = self2.method || "GET";
    self2.href = self2.uri.href;
    if (self2.src && self2.src.stat && self2.src.stat.size && !self2.hasHeader("content-length")) {
      self2.setHeader("content-length", self2.src.stat.size);
    }
    if (self2._aws) {
      self2.aws(self2._aws, true);
    }
    var reqOptions = copy(self2);
    delete reqOptions.auth;
    debug("make request", self2.uri.href);
    delete reqOptions.timeout;
    try {
      self2.req = self2.httpModule.request(reqOptions);
    } catch (err) {
      self2.emit("error", err);
      return;
    }
    if (self2.timing) {
      self2.startTime = startTime;
      self2.startTimeNow = startTimeNow;
      self2.timings = {};
    }
    var timeout;
    if (self2.timeout && !self2.timeoutTimer) {
      if (self2.timeout < 0) {
        timeout = 0;
      } else if (typeof self2.timeout === "number" && isFinite(self2.timeout)) {
        timeout = self2.timeout;
      }
    }
    self2.req.on("response", self2.onRequestResponse.bind(self2));
    self2.req.on("error", self2.onRequestError.bind(self2));
    self2.req.on("drain", function() {
      self2.emit("drain");
    });
    self2.req.on("socket", function(socket) {
      var isConnecting = socket._connecting || socket.connecting;
      if (self2.timing) {
        self2.timings.socket = now() - self2.startTimeNow;
        if (isConnecting) {
          var onLookupTiming = function() {
            self2.timings.lookup = now() - self2.startTimeNow;
          };
          var onConnectTiming = function() {
            self2.timings.connect = now() - self2.startTimeNow;
          };
          socket.once("lookup", onLookupTiming);
          socket.once("connect", onConnectTiming);
          self2.req.once("error", function() {
            socket.removeListener("lookup", onLookupTiming);
            socket.removeListener("connect", onConnectTiming);
          });
        }
      }
      var setReqTimeout = function() {
        self2.req.setTimeout(timeout, function() {
          if (self2.req) {
            self2.abort();
            var e = new Error("ESOCKETTIMEDOUT");
            e.code = "ESOCKETTIMEDOUT";
            e.connect = false;
            self2.emit("error", e);
          }
        });
      };
      if (timeout !== void 0) {
        if (isConnecting) {
          var onReqSockConnect = function() {
            socket.removeListener("connect", onReqSockConnect);
            self2.clearTimeout();
            setReqTimeout();
          };
          socket.on("connect", onReqSockConnect);
          self2.req.on("error", function(err) {
            socket.removeListener("connect", onReqSockConnect);
          });
          self2.timeoutTimer = setTimeout(function() {
            socket.removeListener("connect", onReqSockConnect);
            self2.abort();
            var e = new Error("ETIMEDOUT");
            e.code = "ETIMEDOUT";
            e.connect = true;
            self2.emit("error", e);
          }, timeout);
        } else {
          setReqTimeout();
        }
      }
      self2.emit("socket", socket);
    });
    self2.emit("request", self2.req);
  };
  Request2.prototype.onRequestError = function(error2) {
    var self2 = this;
    if (self2._aborted) {
      return;
    }
    if (self2.req && self2.req._reusedSocket && error2.code === "ECONNRESET" && self2.agent.addRequestNoreuse) {
      self2.agent = { addRequest: self2.agent.addRequestNoreuse.bind(self2.agent) };
      self2.start();
      self2.req.end();
      return;
    }
    self2.clearTimeout();
    self2.emit("error", error2);
  };
  Request2.prototype.onRequestResponse = function(response) {
    var self2 = this;
    if (self2.timing) {
      self2.timings.response = now() - self2.startTimeNow;
    }
    debug("onRequestResponse", self2.uri.href, response.statusCode, response.headers);
    response.on("end", function() {
      if (self2.timing) {
        self2.timings.end = now() - self2.startTimeNow;
        response.timingStart = self2.startTime;
        if (!self2.timings.socket) {
          self2.timings.socket = 0;
        }
        if (!self2.timings.lookup) {
          self2.timings.lookup = self2.timings.socket;
        }
        if (!self2.timings.connect) {
          self2.timings.connect = self2.timings.lookup;
        }
        if (!self2.timings.response) {
          self2.timings.response = self2.timings.connect;
        }
        debug("elapsed time", self2.timings.end);
        self2.elapsedTime += Math.round(self2.timings.end);
        response.elapsedTime = self2.elapsedTime;
        response.timings = self2.timings;
        response.timingPhases = {
          wait: self2.timings.socket,
          dns: self2.timings.lookup - self2.timings.socket,
          tcp: self2.timings.connect - self2.timings.lookup,
          firstByte: self2.timings.response - self2.timings.connect,
          download: self2.timings.end - self2.timings.response,
          total: self2.timings.end
        };
      }
      debug("response end", self2.uri.href, response.statusCode, response.headers);
    });
    if (self2._aborted) {
      debug("aborted", self2.uri.href);
      response.resume();
      return;
    }
    self2.response = response;
    response.request = self2;
    response.toJSON = responseToJSON;
    if (self2.httpModule === https && self2.strictSSL && (!response.hasOwnProperty("socket") || !response.socket.authorized)) {
      debug("strict ssl error", self2.uri.href);
      var sslErr = response.hasOwnProperty("socket") ? response.socket.authorizationError : self2.uri.href + " does not support SSL";
      self2.emit("error", new Error("SSL Error: " + sslErr));
      return;
    }
    self2.originalHost = self2.getHeader("host");
    if (!self2.originalHostHeaderName) {
      self2.originalHostHeaderName = self2.hasHeader("host");
    }
    if (self2.setHost) {
      self2.removeHeader("host");
    }
    self2.clearTimeout();
    var targetCookieJar = self2._jar && self2._jar.setCookie ? self2._jar : globalCookieJar;
    var addCookie = function(cookie2) {
      try {
        targetCookieJar.setCookie(cookie2, self2.uri.href, { ignoreError: true });
      } catch (e) {
        self2.emit("error", e);
      }
    };
    response.caseless = caseless2(response.headers);
    if (response.caseless.has("set-cookie") && !self2._disableCookies) {
      var headerName = response.caseless.has("set-cookie");
      if (Array.isArray(response.headers[headerName])) {
        response.headers[headerName].forEach(addCookie);
      } else {
        addCookie(response.headers[headerName]);
      }
    }
    if (self2._redirect.onResponse(response)) {
      return;
    } else {
      response.on("close", function() {
        if (!self2._ended) {
          self2.response.emit("end");
        }
      });
      response.once("end", function() {
        self2._ended = true;
      });
      var noBody = function(code) {
        return self2.method === "HEAD" || // Informational
        code >= 100 && code < 200 || // No Content
        code === 204 || // Not Modified
        code === 304;
      };
      var responseContent;
      if (self2.gzip && !noBody(response.statusCode)) {
        var contentEncoding = response.headers["content-encoding"] || "identity";
        contentEncoding = contentEncoding.trim().toLowerCase();
        var zlibOptions = {
          flush: zlib.Z_SYNC_FLUSH,
          finishFlush: zlib.Z_SYNC_FLUSH
        };
        if (contentEncoding === "gzip") {
          responseContent = zlib.createGunzip(zlibOptions);
          response.pipe(responseContent);
        } else if (contentEncoding === "deflate") {
          responseContent = zlib.createInflate(zlibOptions);
          response.pipe(responseContent);
        } else {
          if (contentEncoding !== "identity") {
            debug("ignoring unrecognized Content-Encoding " + contentEncoding);
          }
          responseContent = response;
        }
      } else {
        responseContent = response;
      }
      if (self2.encoding) {
        if (self2.dests.length !== 0) {
          console.error("Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.");
        } else {
          responseContent.setEncoding(self2.encoding);
        }
      }
      if (self2._paused) {
        responseContent.pause();
      }
      self2.responseContent = responseContent;
      self2.emit("response", response);
      self2.dests.forEach(function(dest) {
        self2.pipeDest(dest);
      });
      responseContent.on("data", function(chunk) {
        if (self2.timing && !self2.responseStarted) {
          self2.responseStartTime = (/* @__PURE__ */ new Date()).getTime();
          response.responseStartTime = self2.responseStartTime;
        }
        self2._destdata = true;
        self2.emit("data", chunk);
      });
      responseContent.once("end", function(chunk) {
        self2.emit("end", chunk);
      });
      responseContent.on("error", function(error2) {
        self2.emit("error", error2);
      });
      responseContent.on("close", function() {
        self2.emit("close");
      });
      if (self2.callback) {
        self2.readResponseBody(response);
      } else {
        self2.on("end", function() {
          if (self2._aborted) {
            debug("aborted", self2.uri.href);
            return;
          }
          self2.emit("complete", response);
        });
      }
    }
    debug("finish init function", self2.uri.href);
  };
  Request2.prototype.readResponseBody = function(response) {
    var self2 = this;
    debug("reading response's body");
    var buffers = [];
    var bufferLength = 0;
    var strings = [];
    self2.on("data", function(chunk) {
      if (!Buffer2.isBuffer(chunk)) {
        strings.push(chunk);
      } else if (chunk.length) {
        bufferLength += chunk.length;
        buffers.push(chunk);
      }
    });
    self2.on("end", function() {
      debug("end event", self2.uri.href);
      if (self2._aborted) {
        debug("aborted", self2.uri.href);
        buffers = [];
        bufferLength = 0;
        return;
      }
      if (bufferLength) {
        debug("has body", self2.uri.href, bufferLength);
        response.body = Buffer2.concat(buffers, bufferLength);
        if (self2.encoding !== null) {
          response.body = response.body.toString(self2.encoding);
        }
        buffers = [];
        bufferLength = 0;
      } else if (strings.length) {
        if (self2.encoding === "utf8" && strings[0].length > 0 && strings[0][0] === "\uFEFF") {
          strings[0] = strings[0].substring(1);
        }
        response.body = strings.join("");
      }
      if (self2._json) {
        try {
          response.body = JSON.parse(response.body, self2._jsonReviver);
        } catch (e) {
          debug("invalid JSON received", self2.uri.href);
        }
      }
      debug("emitting complete", self2.uri.href);
      if (typeof response.body === "undefined" && !self2._json) {
        response.body = self2.encoding === null ? Buffer2.alloc(0) : "";
      }
      self2.emit("complete", response, response.body);
    });
  };
  Request2.prototype.abort = function() {
    var self2 = this;
    self2._aborted = true;
    if (self2.req) {
      self2.req.abort();
    } else if (self2.response) {
      self2.response.destroy();
    }
    self2.clearTimeout();
    self2.emit("abort");
  };
  Request2.prototype.pipeDest = function(dest) {
    var self2 = this;
    var response = self2.response;
    if (dest.headers && !dest.headersSent) {
      if (response.caseless.has("content-type")) {
        var ctname = response.caseless.has("content-type");
        if (dest.setHeader) {
          dest.setHeader(ctname, response.headers[ctname]);
        } else {
          dest.headers[ctname] = response.headers[ctname];
        }
      }
      if (response.caseless.has("content-length")) {
        var clname = response.caseless.has("content-length");
        if (dest.setHeader) {
          dest.setHeader(clname, response.headers[clname]);
        } else {
          dest.headers[clname] = response.headers[clname];
        }
      }
    }
    if (dest.setHeader && !dest.headersSent) {
      for (var i in response.headers) {
        if (!self2.gzip || i !== "content-encoding") {
          dest.setHeader(i, response.headers[i]);
        }
      }
      dest.statusCode = response.statusCode;
    }
    if (self2.pipefilter) {
      self2.pipefilter(response, dest);
    }
  };
  Request2.prototype.qs = function(q2, clobber) {
    var self2 = this;
    var base;
    if (!clobber && self2.uri.query) {
      base = self2._qs.parse(self2.uri.query);
    } else {
      base = {};
    }
    for (var i in q2) {
      base[i] = q2[i];
    }
    var qs = self2._qs.stringify(base);
    if (qs === "") {
      return self2;
    }
    self2.uri = url.parse(self2.uri.href.split("?")[0] + "?" + qs);
    self2.url = self2.uri;
    self2.path = self2.uri.path;
    if (self2.uri.host === "unix") {
      self2.enableUnixSocket();
    }
    return self2;
  };
  Request2.prototype.form = function(form) {
    var self2 = this;
    if (form) {
      if (!/^application\/x-www-form-urlencoded\b/.test(self2.getHeader("content-type"))) {
        self2.setHeader("content-type", "application/x-www-form-urlencoded");
      }
      self2.body = typeof form === "string" ? self2._qs.rfc3986(form.toString("utf8")) : self2._qs.stringify(form).toString("utf8");
      return self2;
    }
    self2._form = new FormData();
    self2._form.on("error", function(err) {
      err.message = "form-data: " + err.message;
      self2.emit("error", err);
      self2.abort();
    });
    return self2._form;
  };
  Request2.prototype.multipart = function(multipart2) {
    var self2 = this;
    self2._multipart.onRequest(multipart2);
    if (!self2._multipart.chunked) {
      self2.body = self2._multipart.body;
    }
    return self2;
  };
  Request2.prototype.json = function(val) {
    var self2 = this;
    if (!self2.hasHeader("accept")) {
      self2.setHeader("accept", "application/json");
    }
    if (typeof self2.jsonReplacer === "function") {
      self2._jsonReplacer = self2.jsonReplacer;
    }
    self2._json = true;
    if (typeof val === "boolean") {
      if (self2.body !== void 0) {
        if (!/^application\/x-www-form-urlencoded\b/.test(self2.getHeader("content-type"))) {
          self2.body = safeStringify(self2.body, self2._jsonReplacer);
        } else {
          self2.body = self2._qs.rfc3986(self2.body);
        }
        if (!self2.hasHeader("content-type")) {
          self2.setHeader("content-type", "application/json");
        }
      }
    } else {
      self2.body = safeStringify(val, self2._jsonReplacer);
      if (!self2.hasHeader("content-type")) {
        self2.setHeader("content-type", "application/json");
      }
    }
    if (typeof self2.jsonReviver === "function") {
      self2._jsonReviver = self2.jsonReviver;
    }
    return self2;
  };
  Request2.prototype.getHeader = function(name, headers) {
    var self2 = this;
    var result, re, match;
    if (!headers) {
      headers = self2.headers;
    }
    Object.keys(headers).forEach(function(key2) {
      if (key2.length !== name.length) {
        return;
      }
      re = new RegExp(name, "i");
      match = key2.match(re);
      if (match) {
        result = headers[key2];
      }
    });
    return result;
  };
  Request2.prototype.enableUnixSocket = function() {
    var unixParts = this.uri.path.split(":");
    var host = unixParts[0];
    var path = unixParts[1];
    this.socketPath = host;
    this.uri.pathname = path;
    this.uri.path = path;
    this.uri.host = host;
    this.uri.hostname = host;
    this.uri.isUnix = true;
  };
  Request2.prototype.auth = function(user, pass, sendImmediately, bearer) {
    var self2 = this;
    self2._auth.onRequest(user, pass, sendImmediately, bearer);
    return self2;
  };
  Request2.prototype.aws = function(opts, now2) {
    var self2 = this;
    if (!now2) {
      self2._aws = opts;
      return self2;
    }
    if (opts.sign_version === 4 || opts.sign_version === "4") {
      var options = {
        host: self2.uri.host,
        path: self2.uri.path,
        method: self2.method,
        headers: self2.headers,
        body: self2.body
      };
      if (opts.service) {
        options.service = opts.service;
      }
      var signRes = aws42.sign(options, {
        accessKeyId: opts.key,
        secretAccessKey: opts.secret,
        sessionToken: opts.session
      });
      self2.setHeader("authorization", signRes.headers.Authorization);
      self2.setHeader("x-amz-date", signRes.headers["X-Amz-Date"]);
      if (signRes.headers["X-Amz-Security-Token"]) {
        self2.setHeader("x-amz-security-token", signRes.headers["X-Amz-Security-Token"]);
      }
    } else {
      var date = /* @__PURE__ */ new Date();
      self2.setHeader("date", date.toUTCString());
      var auth2 = {
        key: opts.key,
        secret: opts.secret,
        verb: self2.method.toUpperCase(),
        date,
        contentType: self2.getHeader("content-type") || "",
        md5: self2.getHeader("content-md5") || "",
        amazonHeaders: aws2.canonicalizeHeaders(self2.headers)
      };
      var path = self2.uri.path;
      if (opts.bucket && path) {
        auth2.resource = "/" + opts.bucket + path;
      } else if (opts.bucket && !path) {
        auth2.resource = "/" + opts.bucket;
      } else if (!opts.bucket && path) {
        auth2.resource = path;
      } else if (!opts.bucket && !path) {
        auth2.resource = "/";
      }
      auth2.resource = aws2.canonicalizeResource(auth2.resource);
      self2.setHeader("authorization", aws2.authorization(auth2));
    }
    return self2;
  };
  Request2.prototype.httpSignature = function(opts) {
    var self2 = this;
    httpSignature.signRequest({
      getHeader: function(header) {
        return self2.getHeader(header, self2.headers);
      },
      setHeader: function(header, value) {
        self2.setHeader(header, value);
      },
      method: self2.method,
      path: self2.path
    }, opts);
    debug("httpSignature authorization", self2.getHeader("authorization"));
    return self2;
  };
  Request2.prototype.hawk = function(opts) {
    var self2 = this;
    self2.setHeader("Authorization", hawk2.header(self2.uri, self2.method, opts));
  };
  Request2.prototype.oauth = function(_oauth) {
    var self2 = this;
    self2._oauth.onRequest(_oauth);
    return self2;
  };
  Request2.prototype.jar = function(jar) {
    var self2 = this;
    var cookies22;
    if (self2._redirect.redirectsFollowed === 0) {
      self2.originalCookieHeader = self2.getHeader("cookie");
    }
    if (!jar) {
      cookies22 = false;
      self2._disableCookies = true;
    } else {
      var targetCookieJar = jar.getCookieString ? jar : globalCookieJar;
      var urihref = self2.uri.href;
      if (targetCookieJar) {
        cookies22 = targetCookieJar.getCookieString(urihref);
      }
    }
    if (cookies22 && cookies22.length) {
      if (self2.originalCookieHeader) {
        self2.setHeader("cookie", self2.originalCookieHeader + "; " + cookies22);
      } else {
        self2.setHeader("cookie", cookies22);
      }
    }
    self2._jar = jar;
    return self2;
  };
  Request2.prototype.pipe = function(dest, opts) {
    var self2 = this;
    if (self2.response) {
      if (self2._destdata) {
        self2.emit("error", new Error("You cannot pipe after data has been emitted from the response."));
      } else if (self2._ended) {
        self2.emit("error", new Error("You cannot pipe after the response has been ended."));
      } else {
        stream.Stream.prototype.pipe.call(self2, dest, opts);
        self2.pipeDest(dest);
        return dest;
      }
    } else {
      self2.dests.push(dest);
      stream.Stream.prototype.pipe.call(self2, dest, opts);
      return dest;
    }
  };
  Request2.prototype.write = function() {
    var self2 = this;
    if (self2._aborted) {
      return;
    }
    if (!self2._started) {
      self2.start();
    }
    if (self2.req) {
      return self2.req.write.apply(self2.req, arguments);
    }
  };
  Request2.prototype.end = function(chunk) {
    var self2 = this;
    if (self2._aborted) {
      return;
    }
    if (chunk) {
      self2.write(chunk);
    }
    if (!self2._started) {
      self2.start();
    }
    if (self2.req) {
      self2.req.end();
    }
  };
  Request2.prototype.pause = function() {
    var self2 = this;
    if (!self2.responseContent) {
      self2._paused = true;
    } else {
      self2.responseContent.pause.apply(self2.responseContent, arguments);
    }
  };
  Request2.prototype.resume = function() {
    var self2 = this;
    if (!self2.responseContent) {
      self2._paused = false;
    } else {
      self2.responseContent.resume.apply(self2.responseContent, arguments);
    }
  };
  Request2.prototype.destroy = function() {
    var self2 = this;
    this.clearTimeout();
    if (!self2._ended) {
      self2.end();
    } else if (self2.response) {
      self2.response.destroy();
    }
  };
  Request2.prototype.clearTimeout = function() {
    if (this.timeoutTimer) {
      clearTimeout(this.timeoutTimer);
      this.timeoutTimer = null;
    }
  };
  Request2.defaultProxyHeaderWhiteList = Tunnel.defaultProxyHeaderWhiteList.slice();
  Request2.defaultProxyHeaderExclusiveList = Tunnel.defaultProxyHeaderExclusiveList.slice();
  Request2.prototype.toJSON = requestToJSON;
  request = Request2;
  return request;
}
var request_1;
var hasRequiredRequest;
function requireRequest() {
  if (hasRequiredRequest) return request_1;
  hasRequiredRequest = 1;
  var extend2 = requireExtend();
  var cookies2 = requireCookies();
  var helpers2 = requireHelpers();
  var paramsHaveRequestBody = helpers2.paramsHaveRequestBody;
  function initParams(uri, options, callback) {
    if (typeof options === "function") {
      callback = options;
    }
    var params = {};
    if (options !== null && typeof options === "object") {
      extend2(params, options, { uri });
    } else if (typeof uri === "string") {
      extend2(params, { uri });
    } else {
      extend2(params, uri);
    }
    params.callback = callback || params.callback;
    return params;
  }
  function request2(uri, options, callback) {
    if (typeof uri === "undefined") {
      throw new Error("undefined is not a valid uri or options object.");
    }
    var params = initParams(uri, options, callback);
    if (params.method === "HEAD" && paramsHaveRequestBody(params)) {
      throw new Error("HTTP HEAD requests MUST NOT include a request body.");
    }
    return new request2.Request(params);
  }
  function verbFunc(verb) {
    var method = verb.toUpperCase();
    return function(uri, options, callback) {
      var params = initParams(uri, options, callback);
      params.method = method;
      return request2(params, params.callback);
    };
  }
  request2.get = verbFunc("get");
  request2.head = verbFunc("head");
  request2.options = verbFunc("options");
  request2.post = verbFunc("post");
  request2.put = verbFunc("put");
  request2.patch = verbFunc("patch");
  request2.del = verbFunc("delete");
  request2["delete"] = verbFunc("delete");
  request2.jar = function(store2) {
    return cookies2.jar(store2);
  };
  request2.cookie = function(str) {
    return cookies2.parse(str);
  };
  function wrapRequestMethod(method, options, requester, verb) {
    return function(uri, opts, callback) {
      var params = initParams(uri, opts, callback);
      var target = {};
      extend2(true, target, options, params);
      target.pool = params.pool || options.pool;
      if (verb) {
        target.method = verb.toUpperCase();
      }
      if (typeof requester === "function") {
        method = requester;
      }
      return method(target, target.callback);
    };
  }
  request2.defaults = function(options, requester) {
    var self2 = this;
    options = options || {};
    if (typeof options === "function") {
      requester = options;
      options = {};
    }
    var defaults = wrapRequestMethod(self2, options, requester);
    var verbs = ["get", "head", "post", "put", "patch", "del", "delete"];
    verbs.forEach(function(verb) {
      defaults[verb] = wrapRequestMethod(self2[verb], options, requester, verb);
    });
    defaults.cookie = wrapRequestMethod(self2.cookie, options, requester);
    defaults.jar = self2.jar;
    defaults.defaults = self2.defaults;
    return defaults;
  };
  request2.forever = function(agentOptions, optionsArg) {
    var options = {};
    if (optionsArg) {
      extend2(options, optionsArg);
    }
    if (agentOptions) {
      options.agentOptions = agentOptions;
    }
    options.forever = true;
    return request2.defaults(options);
  };
  request_1 = request2;
  request2.Request = requireRequest$1();
  request2.initParams = initParams;
  Object.defineProperty(request2, "debug", {
    enumerable: true,
    get: function() {
      return request2.Request.debug;
    },
    set: function(debug) {
      request2.Request.debug = debug;
    }
  });
  return request_1;
}
var dataUriToBuffer_1;
var hasRequiredDataUriToBuffer;
function requireDataUriToBuffer() {
  if (hasRequiredDataUriToBuffer) return dataUriToBuffer_1;
  hasRequiredDataUriToBuffer = 1;
  dataUriToBuffer_1 = dataUriToBuffer;
  function dataUriToBuffer(uri) {
    if (!/^data\:/i.test(uri)) {
      throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
    }
    uri = uri.replace(/\r?\n/g, "");
    var firstComma = uri.indexOf(",");
    if (-1 === firstComma || firstComma <= 4) throw new TypeError("malformed data: URI");
    var meta = uri.substring(5, firstComma).split(";");
    var base64 = false;
    var charset = "US-ASCII";
    for (var i = 0; i < meta.length; i++) {
      if ("base64" == meta[i]) {
        base64 = true;
      } else if (0 == meta[i].indexOf("charset=")) {
        charset = meta[i].substring(8);
      }
    }
    var data2 = unescape(uri.substring(firstComma + 1));
    var encoding = base64 ? "base64" : "ascii";
    var buffer = new Buffer(data2, encoding);
    buffer.type = meta[0] || "text/plain";
    buffer.charset = charset;
    return buffer;
  }
  return dataUriToBuffer_1;
}
var parseDataUri_1;
var hasRequiredParseDataUri;
function requireParseDataUri() {
  if (hasRequiredParseDataUri) return parseDataUri_1;
  hasRequiredParseDataUri = 1;
  var toBuffer = requireDataUriToBuffer();
  function parseDataUri(dataUri) {
    return {
      mimeType: normalizeMimeType(parseMimeType(dataUri)),
      data: toBuffer(dataUri)
    };
  }
  function parseMimeType(uri) {
    return uri.substring(5, uri.indexOf(";"));
  }
  var prefix = /^(\w+\/)+/;
  function normalizeMimeType(mime) {
    mime = mime.toLowerCase();
    var once = mime.match(prefix);
    if (!once || !(once = once[1])) {
      return mime;
    }
    return mime.replace(prefix, once);
  }
  parseDataUri_1 = parseDataUri;
  return parseDataUri_1;
}
var nodePixels;
var hasRequiredNodePixels;
function requireNodePixels() {
  if (hasRequiredNodePixels) return nodePixels;
  hasRequiredNodePixels = 1;
  var ndarray2 = requireNdarray();
  var PNG = requirePng().PNG;
  var jpeg = requireJpegJs();
  var pack = requireConvert();
  var GifReader = requireOmggif().GifReader;
  var Bitmap = requireNodeBitmap();
  var fs = require$$0$a;
  var request2 = requireRequest();
  var mime = requireMimeTypes();
  var parseDataURI = requireParseDataUri();
  function handlePNG(data2, cb) {
    var png2 = new PNG();
    png2.parse(data2, function(err, img_data) {
      if (err) {
        cb(err);
        return;
      }
      cb(null, ndarray2(
        new Uint8Array(img_data.data),
        [img_data.width | 0, img_data.height | 0, 4],
        [4, 4 * img_data.width | 0, 1],
        0
      ));
    });
  }
  function handleJPEG(data2, cb) {
    var jpegData;
    try {
      jpegData = jpeg.decode(data2);
    } catch (e) {
      cb(e);
      return;
    }
    if (!jpegData) {
      cb(new Error("Error decoding jpeg"));
      return;
    }
    var nshape = [jpegData.height, jpegData.width, 4];
    var result = ndarray2(jpegData.data, nshape);
    cb(null, result.transpose(1, 0));
  }
  function handleGIF(data2, cb) {
    var reader2;
    try {
      reader2 = new GifReader(data2);
    } catch (err) {
      cb(err);
      return;
    }
    if (reader2.numFrames() > 0) {
      var nshape = [reader2.numFrames(), reader2.height, reader2.width, 4];
      try {
        var ndata = new Uint8Array(nshape[0] * nshape[1] * nshape[2] * nshape[3]);
      } catch (err) {
        cb(err);
        return;
      }
      var result = ndarray2(ndata, nshape);
      try {
        for (var i = 0; i < reader2.numFrames(); ++i) {
          reader2.decodeAndBlitFrameRGBA(i, ndata.subarray(
            result.index(i, 0, 0, 0),
            result.index(i + 1, 0, 0, 0)
          ));
        }
      } catch (err) {
        cb(err);
        return;
      }
      cb(null, result.transpose(0, 2, 1));
    } else {
      var nshape = [reader2.height, reader2.width, 4];
      var ndata = new Uint8Array(nshape[0] * nshape[1] * nshape[2]);
      var result = ndarray2(ndata, nshape);
      try {
        reader2.decodeAndBlitFrameRGBA(0, ndata);
      } catch (err) {
        cb(err);
        return;
      }
      cb(null, result.transpose(1, 0));
    }
  }
  function handleBMP(data2, cb) {
    var bmp = new Bitmap(data2);
    try {
      bmp.init();
    } catch (e) {
      cb(e);
      return;
    }
    var bmpData = bmp.getData();
    var nshape = [bmpData.getHeight(), bmpData.getWidth(), 4];
    var ndata = new Uint8Array(nshape[0] * nshape[1] * nshape[2]);
    var result = ndarray2(ndata, nshape);
    pack(bmpData, result);
    cb(null, result.transpose(1, 0));
  }
  function doParse(mimeType, data2, cb) {
    switch (mimeType) {
      case "image/png":
        handlePNG(data2, cb);
        break;
      case "image/jpg":
      case "image/jpeg":
        handleJPEG(data2, cb);
        break;
      case "image/gif":
        handleGIF(data2, cb);
        break;
      case "image/bmp":
        handleBMP(data2, cb);
        break;
      default:
        cb(new Error("Unsupported file type: " + mimeType));
    }
  }
  nodePixels = function getPixels(url, type2, cb) {
    if (!cb) {
      cb = type2;
      type2 = "";
    }
    if (Buffer.isBuffer(url)) {
      if (!type2) {
        cb(new Error("Invalid file type"));
        return;
      }
      doParse(type2, url, cb);
    } else if (url.indexOf("data:") === 0) {
      try {
        var buffer = parseDataURI(url);
        if (buffer) {
          process.nextTick(function() {
            doParse(type2 || buffer.mimeType, buffer.data, cb);
          });
        } else {
          process.nextTick(function() {
            cb(new Error("Error parsing data URI"));
          });
        }
      } catch (err) {
        process.nextTick(function() {
          cb(err);
        });
      }
    } else if (url.indexOf("http://") === 0 || url.indexOf("https://") === 0) {
      request2({ url, encoding: null }, function(err, response, body) {
        if (err) {
          cb(err);
          return;
        }
        type2 = type2;
        if (!type2) {
          if (response.getHeader !== void 0) {
            type2 = response.getHeader("content-type");
          } else if (response.headers !== void 0) {
            type2 = response.headers["content-type"];
          }
        }
        if (!type2) {
          cb(new Error("Invalid content-type"));
          return;
        }
        doParse(type2, body, cb);
      });
    } else {
      fs.readFile(url, function(err, data2) {
        if (err) {
          cb(err);
          return;
        }
        type2 = type2 || mime.lookup(url);
        if (!type2) {
          cb(new Error("Invalid file type"));
          return;
        }
        doParse(type2, data2, cb);
      });
    }
  };
  return nodePixels;
}
var dist$1 = {};
var tslib = { exports: {} };
var hasRequiredTslib;
function requireTslib() {
  if (hasRequiredTslib) return tslib.exports;
  hasRequiredTslib = 1;
  (function(module) {
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __esDecorate;
    var __runInitializers;
    var __propKey;
    var __setFunctionName;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __spreadArray;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __classPrivateFieldIn;
    var __createBinding;
    var __addDisposableResource;
    var __disposeResources;
    var __rewriteRelativeImportExtension;
    (function(factory) {
      var root = typeof commonjsGlobal === "object" ? commonjsGlobal : typeof self === "object" ? self : typeof this === "object" ? this : {};
      {
        factory(createExporter(root, createExporter(module.exports)));
      }
      function createExporter(exports$1, previous) {
        if (exports$1 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports$1, "__esModule", { value: true });
          } else {
            exports$1.__esModule = true;
          }
        }
        return function(id, v) {
          return exports$1[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      };
      __extends = function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
      __rest = function(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      __decorate = function(decorators, target, key2, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key2, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key2, r) : d(target, key2)) || r;
        return c > 3 && r && Object.defineProperty(target, key2, r), r;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key2) {
          decorator(target, key2, paramIndex);
        };
      };
      __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
        function accept(f) {
          if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
          return f;
        }
        var kind = contextIn.kind, key2 = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
        var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
        var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
        var _, done = false;
        for (var i = decorators.length - 1; i >= 0; i--) {
          var context = {};
          for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
          for (var p in contextIn.access) context.access[p] = contextIn.access[p];
          context.addInitializer = function(f) {
            if (done) throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f || null));
          };
          var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key2], context);
          if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
          } else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key2] = _;
          }
        }
        if (target) Object.defineProperty(target, contextIn.name, descriptor);
        done = true;
      };
      __runInitializers = function(thisArg, initializers, value) {
        var useValue = arguments.length > 2;
        for (var i = 0; i < initializers.length; i++) {
          value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
        }
        return useValue ? value : void 0;
      };
      __propKey = function(x) {
        return typeof x === "symbol" ? x : "".concat(x);
      };
      __setFunctionName = function(f, name, prefix) {
        if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
        return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1) throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
        return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2]) _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
          if (op[0] & 5) throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar = function(m, o) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
      };
      __createBinding = Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      __values = function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
          next: function() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        } catch (error2) {
          e = { error: error2 };
        } finally {
          try {
            if (r && !r.done && (m = i["return"])) m.call(i);
          } finally {
            if (e) throw e.error;
          }
        }
        return ar;
      };
      __spread = function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read(arguments[i]));
        return ar;
      };
      __spreadArrays = function() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
        return r;
      };
      __spreadArray = function(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      __await = function(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q2 = [];
        return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function awaitReturn(f) {
          return function(v) {
            return Promise.resolve(v).then(f, reject);
          };
        }
        function verb(n, f) {
          if (g[n]) {
            i[n] = function(v) {
              return new Promise(function(a, b) {
                q2.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
            if (f) i[n] = f(i[n]);
          }
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q2[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q2[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q2.shift(), q2.length) resume(q2[0][0], q2[0][1]);
        }
      };
      __asyncDelegator = function(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues = function(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({ value: v2, done: d });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      };
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      __classPrivateFieldIn = function(state, receiver) {
        if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
      };
      __addDisposableResource = function(env, value, async2) {
        if (value !== null && value !== void 0) {
          if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
          var dispose, inner;
          if (async2) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
          }
          if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async2) inner = dispose;
          }
          if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
          if (inner) dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
          env.stack.push({ value, dispose, async: async2 });
        } else if (async2) {
          env.stack.push({ async: true });
        }
        return value;
      };
      var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error2, e.suppressed = suppressed, e;
      };
      __disposeResources = function(env) {
        function fail(e) {
          env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
          env.hasError = true;
        }
        var r, s = 0;
        function next() {
          while (r = env.stack.pop()) {
            try {
              if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
              if (r.dispose) {
                var result = r.dispose.call(r.value);
                if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                  fail(e);
                  return next();
                });
              } else s |= 1;
            } catch (e) {
              fail(e);
            }
          }
          if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
          if (env.hasError) throw env.error;
        }
        return next();
      };
      __rewriteRelativeImportExtension = function(path, preserveJsx) {
        if (typeof path === "string" && /^\.\.?\//.test(path)) {
          return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
            return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
          });
        }
        return path;
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__esDecorate", __esDecorate);
      exporter("__runInitializers", __runInitializers);
      exporter("__propKey", __propKey);
      exporter("__setFunctionName", __setFunctionName);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__spreadArray", __spreadArray);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
      exporter("__classPrivateFieldIn", __classPrivateFieldIn);
      exporter("__addDisposableResource", __addDisposableResource);
      exporter("__disposeResources", __disposeResources);
      exporter("__rewriteRelativeImportExtension", __rewriteRelativeImportExtension);
    });
  })(tslib);
  return tslib.exports;
}
var mutableBuffer = {};
var hasRequiredMutableBuffer;
function requireMutableBuffer() {
  if (hasRequiredMutableBuffer) return mutableBuffer;
  hasRequiredMutableBuffer = 1;
  Object.defineProperty(mutableBuffer, "__esModule", { value: true });
  mutableBuffer.MutableBuffer = void 0;
  const DEFAULT_INITIAL_SIZE = 1024;
  const DEFAULT_BLOCK_SIZE = 1024;
  class MutableBuffer {
    constructor(size, blockSize) {
      this._initialSize = size !== null && size !== void 0 ? size : DEFAULT_INITIAL_SIZE;
      this._blockSize = blockSize !== null && blockSize !== void 0 ? blockSize : DEFAULT_BLOCK_SIZE;
      this._buffer = Buffer.alloc(this._initialSize);
      this._size = 0;
    }
    get size() {
      return this._size;
    }
    get buffer() {
      return this._buffer;
    }
    get nativeBuffer() {
      return this._buffer;
    }
    //resize internal buffer if not enough size left
    _ensure(size) {
      const remaining = this._buffer.length - this._size;
      if (remaining < size) {
        const factor = Math.ceil((size - remaining) / this._blockSize);
        const oldBuffer = this._buffer;
        this._buffer = Buffer.alloc(oldBuffer.length + this._blockSize * factor);
        oldBuffer.copy(this._buffer);
      }
    }
    capacity() {
      return this._buffer.length;
    }
    clear() {
      this._size = 0;
    }
    join() {
      return this._buffer.slice(0, this._size);
    }
    flush() {
      const result = this.join();
      this.clear();
      return result;
    }
    write(data2, encoding) {
      if (Buffer.isBuffer(data2)) {
        this._ensure(data2.length);
        data2.copy(this._buffer, this._size);
        this._size += data2.length;
      } else if (Array.isArray(data2)) {
        this._ensure(data2.length);
        for (let i = 0; i < data2.length; i++) {
          this._buffer[this._size + i] = data2[i];
        }
        this._size += data2.length;
      } else if ((data2 === null || data2 === void 0 ? void 0 : data2.buffer) && data2.size) {
        this._ensure(data2.size);
        data2.buffer.copy(this._buffer, this._size);
        this._size += data2.size;
      } else {
        data2 = data2 + "";
        const len = Buffer.byteLength(data2, encoding);
        this._ensure(len);
        this._buffer.write(data2, this._size, len, encoding);
        this._size += len;
      }
      return this;
    }
    writeCString(data2, encoding) {
      if (!data2) {
        this._ensure(1);
      } else if (Buffer.isBuffer(data2)) {
        this._ensure(data2.length);
        data2.copy(this._buffer, this._size);
        this._size += data2.length;
      } else {
        const len = Buffer.byteLength(data2, encoding);
        this._ensure(len + 1);
        this._buffer.write(data2, this._size, len, encoding);
        this._size += len;
      }
      this._buffer[this._size++] = 0;
      return this;
    }
    writeChar(c) {
      this._ensure(1);
      this._buffer.write(c, this._size, 1);
      this._size++;
      return this;
    }
    writeUIntLE(value, byteLength) {
      this._ensure(byteLength >>> 0);
      this._size = this._buffer.writeUIntLE(value, this._size, byteLength);
      return this;
    }
    writeUIntBE(value, byteLength) {
      this._ensure(byteLength >>> 0);
      this._size = this._buffer.writeUIntBE(value, this._size, byteLength);
      return this;
    }
    writeUInt8(value) {
      this._ensure(1);
      this._size = this._buffer.writeUInt8(value, this._size);
      return this;
    }
    writeUInt16LE(value) {
      this._ensure(2);
      this._size = this._buffer.writeUInt16LE(value, this._size);
      return this;
    }
    writeUInt16BE(value) {
      this._ensure(2);
      this._size = this._buffer.writeUInt16BE(value, this._size);
      return this;
    }
    writeUInt32LE(value) {
      this._ensure(4);
      this._size = this._buffer.writeUInt32LE(value, this._size);
      return this;
    }
    writeUInt32BE(value) {
      this._ensure(4);
      this._size = this._buffer.writeUInt32BE(value, this._size);
      return this;
    }
    writeIntLE(value, byteLength) {
      this._ensure(byteLength >>> 0);
      this._size = this._buffer.writeIntLE(value, this._size, byteLength);
      return this;
    }
    writeIntBE(value, byteLength) {
      this._ensure(byteLength >>> 0);
      this._size = this._buffer.writeIntBE(value, this._size, byteLength);
      return this;
    }
    writeInt8(value) {
      this._ensure(1);
      this._size = this._buffer.writeInt8(value, this._size);
      return this;
    }
    writeInt16LE(value) {
      this._ensure(2);
      this._size = this._buffer.writeInt16LE(value, this._size);
      return this;
    }
    writeInt16BE(value) {
      this._ensure(2);
      this._size = this._buffer.writeInt16BE(value, this._size);
      return this;
    }
    writeInt32LE(value) {
      this._ensure(4);
      this._size = this._buffer.writeInt32LE(value, this._size);
      return this;
    }
    writeInt32BE(value) {
      this._ensure(4);
      this._size = this._buffer.writeInt32BE(value, this._size);
      return this;
    }
    writeFloatLE(value) {
      this._ensure(4);
      this._size = this._buffer.writeFloatLE(value, this._size);
      return this;
    }
    writeFloatBE(value) {
      this._ensure(4);
      this._size = this._buffer.writeFloatBE(value, this._size);
      return this;
    }
    writeDoubleLE(value) {
      this._ensure(8);
      this._size = this._buffer.writeDoubleLE(value, this._size);
      return this;
    }
    writeDoubleBE(value) {
      this._ensure(8);
      this._size = this._buffer.writeDoubleBE(value, this._size);
      return this;
    }
    trim() {
      if (this.size <= 0) {
        return this;
      }
      let begin = 0;
      let end = 0;
      for (let i = 0; i < this.size; i++) {
        if (this._buffer[i]) {
          begin = i;
          break;
        }
      }
      for (let i = this.size; i > 0; i--) {
        if (this._buffer[i - 1]) {
          end = i;
          break;
        }
      }
      if (begin === 0 && end === this.size) {
        return this;
      }
      this._buffer = this._buffer.slice(begin, end);
      this._size = end - begin;
      return this;
    }
    trimLeft() {
      if (this.size <= 0 || this._buffer[0]) {
        return this;
      }
      for (let i = 0; i < this.size; i++) {
        if (this._buffer[i]) {
          this._buffer = this._buffer.slice(i);
          this._size = this.size - i;
          return this;
        }
      }
      if (this.size > 0) {
        this._size = 0;
      }
      return this;
    }
    trimRight() {
      if (this.size <= 0 || this._buffer[this.size - 1]) {
        return this;
      }
      for (let i = this.size; i > 0; i--) {
        if (this._buffer[i - 1]) {
          this._buffer = this._buffer.slice(0, i);
          this._size = i;
          return this;
        }
      }
      if (this.size > 0) {
        this._size = 0;
      }
      return this;
    }
  }
  mutableBuffer.MutableBuffer = MutableBuffer;
  return mutableBuffer;
}
var hasRequiredDist$1;
function requireDist$1() {
  if (hasRequiredDist$1) return dist$1;
  hasRequiredDist$1 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    const tslib_1 = /* @__PURE__ */ requireTslib();
    tslib_1.__exportStar(requireMutableBuffer(), exports$1);
    const mutable_buffer_1 = requireMutableBuffer();
    function default_1(size, blockSize) {
      return new mutable_buffer_1.MutableBuffer(size, blockSize);
    }
    exports$1.default = default_1;
  })(dist$1);
  return dist$1;
}
var image;
var hasRequiredImage;
function requireImage() {
  if (hasRequiredImage) return image;
  hasRequiredImage = 1;
  const getPixels = requireNodePixels();
  function Image(pixels) {
    if (!(this instanceof Image))
      return new Image(pixels);
    this.pixels = pixels;
    this.data = [];
    function rgb(pixel) {
      return {
        r: pixel[0],
        g: pixel[1],
        b: pixel[2],
        a: pixel[3]
      };
    }
    var self2 = this;
    for (var i = 0; i < this.pixels.data.length; i += this.size.colors) {
      this.data.push(rgb(new Array(this.size.colors).fill(0).map(function(_, b) {
        return self2.pixels.data[i + b];
      })));
    }
    this.data = this.data.map(function(pixel) {
      if (pixel.a == 0) return 0;
      var shouldBeWhite = pixel.r > 200 && pixel.g > 200 && pixel.b > 200;
      return shouldBeWhite ? 0 : 1;
    });
  }
  Image.load = function(url, type2, callback) {
    if (typeof type2 == "function") {
      callback = type2;
      type2 = null;
    }
    getPixels(url, type2, function(err, pixels) {
      if (err) return callback(err);
      callback(new Image(pixels));
    });
  };
  Image.prototype.__defineGetter__("size", function() {
    return {
      width: this.pixels.shape[0],
      height: this.pixels.shape[1],
      colors: this.pixels.shape[2]
    };
  });
  Image.prototype.toBitmap = function(density) {
    density = density || 24;
    var ld, result = [];
    var x, y, b, l, i;
    var c = density / 8;
    var n = Math.ceil(this.size.height / density);
    for (y = 0; y < n; y++) {
      ld = result[y] = [];
      for (x = 0; x < this.size.width; x++) {
        for (b = 0; b < density; b++) {
          i = x * c + (b >> 3);
          if (ld[i] === void 0) {
            ld[i] = 0;
          }
          l = y * density + b;
          if (l < this.size.height) {
            if (this.data[l * this.size.width + x]) {
              ld[i] += 128 >> (b & 7);
            }
          }
        }
      }
    }
    return {
      data: result,
      density
    };
  };
  Image.prototype.toRaster = function() {
    var result = [];
    var width = this.size.width;
    var height = this.size.height;
    var data2 = this.data;
    var n = Math.ceil(width / 8);
    var x, y, b, c, i;
    for (y = 0; y < height; y++) {
      for (x = 0; x < n; x++) {
        for (b = 0; b < 8; b++) {
          i = x * 8 + b;
          if (result[y * n + x] === void 0) {
            result[y * n + x] = 0;
          }
          c = x * 8 + b;
          if (c < width) {
            if (data2[y * width + i]) {
              result[y * n + x] += 128 >> (b & 7);
            }
          }
        }
      }
    }
    return {
      data: result,
      width: n,
      height
    };
  };
  image = Image;
  return image;
}
var utils = {};
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  utils.getParityBit = function(str) {
    var parity = 0, reversedCode = str.split("").reverse().join("");
    for (var counter = 0; counter < reversedCode.length; counter += 1) {
      parity += parseInt(reversedCode.charAt(counter), 10) * Math.pow(3, (counter + 1) % 2);
    }
    return String((10 - parity % 10) % 10);
  };
  utils.codeLength = function(str) {
    let buff = Buffer.from(str.length.toString(16), "hex");
    return buff.toString();
  };
  return utils;
}
var commands;
var hasRequiredCommands;
function requireCommands() {
  if (hasRequiredCommands) return commands;
  hasRequiredCommands = 1;
  var numToHexString = function(value) {
    value = +value;
    if (!isNaN(value)) {
      value = value.toString(16);
      while (value.length % 2 !== 0) {
        value = "0" + value;
      }
    }
    return value;
  };
  var _ = {
    LF: "\n",
    FS: "",
    FF: "\f",
    GS: "",
    DLE: "",
    EOT: "",
    NUL: "\0",
    ESC: "\x1B",
    TAB: "t",
    EOL: "\n"
  };
  _.FEED_CONTROL_SEQUENCES = {
    CTL_LF: "\n",
    // Print and line feed
    CTL_GLF: "J\0",
    // Print and feed paper (without spaces between lines)
    CTL_FF: "\f",
    // Form feed
    CTL_CR: "\r",
    // Carriage return
    CTL_HT: "	",
    // Horizontal tab
    CTL_VT: "\v"
    // Vertical tab
  };
  _.CHARACTER_SPACING = {
    CS_DEFAULT: "\x1B \0",
    CS_SET: "\x1B "
  };
  _.LINE_SPACING = {
    LS_DEFAULT: "\x1B2",
    LS_SET: "\x1B3"
  };
  _.HARDWARE = {
    HW_INIT: "\x1B@",
    // Clear data in buffer and reset modes
    HW_SELECT: "\x1B=",
    // Printer select
    HW_RESET: "\x1B?\n\0"
    // Reset printer hardware
  };
  _.CASH_DRAWER = {
    CD_KICK_2: "\x1Bp\0Ãº",
    // Sends a pulse to pin 2 []
    CD_KICK_5: "\x1BpÃº"
    // Sends a pulse to pin 5 []
  };
  _.MARGINS = {
    BOTTOM: "\x1BO",
    // Fix bottom size
    LEFT: "\x1Bl",
    // Fix left size
    RIGHT: "\x1BQ"
    // Fix right size
  };
  _.PAPER = {
    PAPER_FULL_CUT: "V\0",
    // Full cut paper
    PAPER_PART_CUT: "V",
    // Partial cut paper
    PAPER_CUT_A: "VA",
    // Partial cut paper
    PAPER_CUT_B: "VB"
    // Partial cut paper
  };
  _.TEXT_FORMAT = {
    TXT_NORMAL: "\x1B!\0",
    // Normal text
    TXT_2HEIGHT: "\x1B!",
    // Double height text
    TXT_2WIDTH: "\x1B! ",
    // Double width text
    TXT_4SQUARE: "\x1B!0",
    // Double width & height text
    TXT_CUSTOM_SIZE: function(width, height) {
      width = width > 7 ? 7 : width;
      width = width < 0 ? 0 : width;
      height = height > 7 ? 7 : height;
      height = height < 0 ? 0 : height;
      var widthDec = width * 16;
      var heightDec = height;
      var sizeDec = widthDec + heightDec;
      return "!" + String.fromCharCode(sizeDec);
    },
    TXT_HEIGHT: {
      1: "\0",
      2: "",
      3: "",
      4: "",
      5: "",
      6: "",
      7: "",
      8: "\x07"
    },
    TXT_WIDTH: {
      1: "\0",
      2: "",
      3: " ",
      4: "0",
      5: "@",
      6: "P",
      7: "`",
      8: "p"
    },
    TXT_UNDERL_OFF: "\x1B-\0",
    // Underline font OFF
    TXT_UNDERL_ON: "\x1B-",
    // Underline font 1-dot ON
    TXT_UNDERL2_ON: "\x1B-",
    // Underline font 2-dot ON
    TXT_BOLD_OFF: "\x1BE\0",
    // Bold font OFF
    TXT_BOLD_ON: "\x1BE",
    // Bold font ON
    TXT_ITALIC_OFF: "\x1B5",
    // Italic font ON
    TXT_ITALIC_ON: "\x1B4",
    // Italic font ON
    TXT_FONT_A: "\x1BM\0",
    // Font type A
    TXT_FONT_B: "\x1BM",
    // Font type B
    TXT_FONT_C: "\x1BM",
    // Font type C
    TXT_ALIGN_LT: "\x1Ba\0",
    // Left justification
    TXT_ALIGN_CT: "\x1Ba",
    // Centering
    TXT_ALIGN_RT: "\x1Ba"
    // Right justification
  };
  _.MODEL = {
    QSPRINTER: {
      BARCODE_MODE: {
        ON: "EC",
        // Barcode mode on
        OFF: "EC\0"
        // Barcode mode off
      },
      BARCODE_HEIGHT_DEFAULT: "hÂ¢",
      // Barcode height default:162
      CODE2D_FORMAT: {
        PIXEL_SIZE: {
          CMD: "\x1B##QPIX",
          MIN: 1,
          MAX: 24,
          DEFAULT: 12
        },
        VERSION: {
          CMD: "(k\x001C",
          MIN: 1,
          MAX: 16,
          DEFAULT: 3
        },
        LEVEL: {
          CMD: "(k\x001E",
          OPTIONS: {
            L: 48,
            M: 49,
            Q: 50,
            H: 51
          }
        },
        LEN_OFFSET: 3,
        SAVEBUF: {
          // Format: CMD_P1{LEN_2BYTE}CMD_P2{DATA}
          // DATA Max Length: 256*256 - 3 (65533)
          CMD_P1: "(k",
          CMD_P2: "1P0"
        },
        PRINTBUF: {
          // Format: CMD_P1{LEN_2BYTE}CMD_P2
          CMD_P1: "(k",
          CMD_P2: "1Q0"
        }
      }
    }
  };
  _.BARCODE_FORMAT = {
    BARCODE_TXT_OFF: "H\0",
    // HRI barcode chars OFF
    BARCODE_TXT_ABV: "H",
    // HRI barcode chars above
    BARCODE_TXT_BLW: "H",
    // HRI barcode chars below
    BARCODE_TXT_BTH: "H",
    // HRI barcode chars both above and below
    BARCODE_FONT_A: "f\0",
    // Font type A for HRI barcode chars
    BARCODE_FONT_B: "f",
    // Font type B for HRI barcode chars
    BARCODE_HEIGHT: function(height) {
      return Buffer.from("1d68" + numToHexString(height), "hex");
    },
    // Barcode Width  [2-6]
    BARCODE_WIDTH: {
      1: "w",
      2: "w",
      3: "w",
      4: "w",
      5: "w"
    },
    BARCODE_HEIGHT_DEFAULT: "hd",
    // Barcode height default:100
    BARCODE_WIDTH_DEFAULT: "w",
    // Barcode width default:1
    BARCODE_UPC_A: "k\0",
    // Barcode type UPC-A
    BARCODE_UPC_E: "k",
    // Barcode type UPC-E
    BARCODE_EAN13: "k",
    // Barcode type EAN13
    BARCODE_EAN8: "k",
    // Barcode type EAN8
    BARCODE_CODE39: "k",
    // Barcode type CODE39
    BARCODE_ITF: "k",
    // Barcode type ITF
    BARCODE_NW7: "k",
    // Barcode type NW7
    BARCODE_CODE93: "kH",
    // Barcode type CODE93
    BARCODE_CODE128: "kI"
    // Barcode type CODE128
  };
  _.CODE2D_FORMAT = {
    TYPE_PDF417: _.GS + "Z\0",
    TYPE_DATAMATRIX: _.GS + "Z",
    TYPE_QR: _.GS + "Z",
    CODE2D: _.ESC + "Z",
    QR_LEVEL_L: "L",
    // correct level 7%
    QR_LEVEL_M: "M",
    // correct level 15%
    QR_LEVEL_Q: "Q",
    // correct level 25%
    QR_LEVEL_H: "H"
    // correct level 30%
  };
  _.IMAGE_FORMAT = {
    S_RASTER_N: "v0\0",
    // Set raster image normal size
    S_RASTER_2W: "v0",
    // Set raster image double width
    S_RASTER_2H: "v0",
    // Set raster image double height
    S_RASTER_Q: "v0"
    // Set raster image quadruple
  };
  _.BITMAP_FORMAT = {
    BITMAP_S8: "\x1B*\0",
    BITMAP_D8: "\x1B*",
    BITMAP_S24: "\x1B* ",
    BITMAP_D24: "\x1B*!"
  };
  _.GSV0_FORMAT = {
    GSV0_NORMAL: "v0\0",
    GSV0_DW: "v0",
    GSV0_DH: "v0",
    GSV0_DWDH: "v0"
  };
  _.BEEP = "\x1BB", // Printer Buzzer pre hex
  /**
   * [COLOR description]
   * @type {Object}
   */
  _.COLOR = {
    0: "\x1Br\0",
    // black
    1: "\x1Br",
    // red
    REVERSE: "B1",
    // Reverses the colors - white text on black background
    UNREVERSE: "B0"
    // Default: undo the reverse - black text on white background
  };
  commands = _;
  return commands;
}
var promisify;
var hasRequiredPromisify;
function requirePromisify() {
  if (hasRequiredPromisify) return promisify;
  hasRequiredPromisify = 1;
  promisify = (printer) => {
    const Printer = printer.constructor;
    const names = Object.getOwnPropertyNames(Printer.prototype);
    names.filter((name) => ~["constructor", "flush", "close"].indexOf(name)).forEach((name) => {
      const fn = printer[name];
      printer[name] = function() {
        return Promise.resolve(fn.apply(printer, arguments));
      };
    });
    ["flush", "close"].forEach((name) => {
      const fn = printer[name];
      printer[name] = (...args) => {
        return new Promise((resolve, reject) => {
          fn(...args, (err, ...others) => {
            if (err) return reject(err);
            resolve(others);
          });
        });
      };
    });
    return printer;
  };
  return promisify;
}
var statuses;
var hasRequiredStatuses;
function requireStatuses() {
  if (hasRequiredStatuses) return statuses;
  hasRequiredStatuses = 1;
  const _ = requireCommands();
  class NotImplementedException extends Error {
  }
  class DeviceStatus {
    byte = "";
    bits = [];
    bitsAsc = [];
    constructor(byte) {
      this.byte = byte;
      for (let j = 7; j >= 0; j--) {
        let bit = byte & 1 << j ? 1 : 0;
        this.bits.push(bit);
      }
      this.bitsAsc = this.bits.slice();
      this.bitsAsc.reverse();
    }
    getBits() {
      return this.bits.join("");
    }
    static commands() {
      throw new NotImplementedException();
    }
    static getClassName() {
      throw new NotImplementedException();
    }
    toJSON() {
      return {
        className: this.constructor.getClassName(),
        byte: this.byte,
        bits: this.getBits(),
        statuses: []
      };
    }
  }
  class PrinterStatus extends DeviceStatus {
    static commands() {
      return [_.DLE, _.EOT, String.fromCharCode(1)];
    }
    static getClassName() {
      return "PrinterStatus";
    }
    toJSON() {
      let result = super.toJSON();
      for (let i = 0; i < 8; i++) {
        let label = "";
        let status = "ok";
        switch (i) {
          case 2:
            if (this.bitsAsc[i] === 1) {
              label = "Drawer kick-out connector pin 3 is HIGH";
            } else {
              label = "Drawer kick-out connector pin 3 is LOW";
            }
            break;
          case 3:
            if (this.bitsAsc[i] === 1) {
              status = "error";
              label = "Offline";
            } else {
              label = "Online";
            }
            break;
          case 5:
            if (this.bitsAsc[i] === 1) {
              status = "error";
              label = "Waiting for online recovery";
            } else {
              label = "Not waiting for online recovery";
            }
            break;
          case 6:
            if (this.bitsAsc[i] === 1) {
              label = "Paper feed button is being pressed";
            } else {
              label = "Paper feed button is not being pressed";
            }
            break;
          default:
            label = "Fixed";
            break;
        }
        result.statuses.push({
          bit: i,
          value: this.bitsAsc[i],
          label,
          status
        });
      }
      return result;
    }
  }
  class OfflineCauseStatus extends DeviceStatus {
    static commands() {
      return [_.DLE, _.EOT, String.fromCharCode(2)];
    }
    static getClassName() {
      return "OfflineCauseStatus";
    }
    toJSON() {
      let result = super.toJSON();
      for (let i = 0; i < 8; i++) {
        let label = "";
        let status = "ok";
        switch (i) {
          case 2:
            if (this.bitsAsc[i] === 1) {
              status = "error";
              label = "Cover is open";
            } else {
              label = "Cover is closed";
            }
            break;
          case 3:
            if (this.bitsAsc[i] === 1) {
              status = "error";
              label = "Paper is being fed by the paper feed button";
            } else {
              label = "Paper is not being fed by the paper feed button";
            }
            break;
          case 5:
            if (this.bitsAsc[i] === 1) {
              status = "error";
              label = "Printing stops due to a paper-end";
            } else {
              label = "No paper-end stop";
            }
            break;
          case 6:
            if (this.bitsAsc[i] === 1) {
              status = "error";
              label = "Error occurred";
            } else {
              label = "No error";
            }
            break;
          default:
            label = "Fixed";
            break;
        }
        result.statuses.push({
          bit: i,
          value: this.bitsAsc[i],
          label,
          status
        });
      }
      return result;
    }
  }
  class ErrorCauseStatus extends DeviceStatus {
    static commands() {
      return [_.DLE, _.EOT, String.fromCharCode(3)];
    }
    static getClassName() {
      return "ErrorCauseStatus";
    }
    toJSON() {
      let result = super.toJSON();
      for (let i = 0; i < 8; i++) {
        let label = "";
        let status = "ok";
        switch (i) {
          case 2:
            if (this.bitsAsc[i] === 1) {
              status = "error";
              label = "Recoverable error occurred";
            } else {
              label = "No recoverable error";
            }
            break;
          case 3:
            if (this.bitsAsc[i] === 1) {
              status = "error";
              label = "Autocutter error occurred";
            } else {
              label = "No autocutter error";
            }
            break;
          case 5:
            if (this.bitsAsc[i] === 1) {
              status = "error";
              label = "Unrecoverable error occurred";
            } else {
              label = "No unrecoverable error";
            }
            break;
          case 6:
            if (this.bitsAsc[i] === 1) {
              status = "error";
              label = "Auto-recoverable error occurred";
            } else {
              label = "No auto-recoverable error";
            }
            break;
          default:
            label = "Fixed";
            break;
        }
        result.statuses.push({
          bit: i,
          value: this.bitsAsc[i],
          label,
          status
        });
      }
      return result;
    }
  }
  class RollPaperSensorStatus extends DeviceStatus {
    static commands() {
      return [_.DLE, _.EOT, String.fromCharCode(4)];
    }
    static getClassName() {
      return "RollPaperSensorStatus";
    }
    toJSON() {
      let result = super.toJSON();
      for (let i = 0; i <= 1; i++) {
        result.statuses.push({
          bit: i,
          value: this.bitsAsc[i],
          label: "Fixed",
          status: "ok"
        });
      }
      let label = "";
      let status = "ok";
      if (this.bitsAsc[2] === 1 && this.bitsAsc[3] === 1) {
        status = "warning";
        label = "Roll paper near-end sensor: paper near-end";
      } else if (this.bitsAsc[2] === 0 && this.bitsAsc[3] === 0) {
        label = "Roll paper near-end sensor: paper adequate";
      }
      result.statuses.push({
        bit: "2,3",
        value: "" + this.bitsAsc[2] + this.bitsAsc[3],
        label,
        status
      });
      result.statuses.push({
        bit: 4,
        value: this.bitsAsc[4],
        label: "Fixed",
        status: "ok"
      });
      label = "";
      status = "ok";
      if (this.bitsAsc[5] === 1 && this.bitsAsc[6] === 1) {
        status = "error";
        label = "Roll paper end sensor: paper not present";
      } else if (this.bitsAsc[5] === 0 && this.bitsAsc[6] === 0) {
        label = "Roll paper end sensor: paper present";
      }
      result.statuses.push({
        bit: "5,6",
        value: "" + this.bitsAsc[5] + this.bitsAsc[6],
        label,
        status
      });
      for (let i = 7; i <= 8; i++) {
        result.statuses.push({
          bit: i,
          value: this.bitsAsc[i],
          label: "Fixed",
          status: "ok"
        });
      }
      return result;
    }
  }
  statuses = {
    PrinterStatus,
    OfflineCauseStatus,
    ErrorCauseStatus,
    RollPaperSensorStatus
  };
  return statuses;
}
var escpos$1;
var hasRequiredEscpos;
function requireEscpos() {
  if (hasRequiredEscpos) return escpos$1;
  hasRequiredEscpos = 1;
  const util2 = require$$0$5;
  const qr2 = requireQr();
  const iconv = requireLib$5();
  const getPixels = requireNodePixels();
  const { MutableBuffer } = requireDist$1();
  const EventEmitter = require$$0$b;
  const Image = requireImage();
  const utils2 = requireUtils();
  const _ = requireCommands();
  const Promiseify = requirePromisify();
  const statuses2 = requireStatuses();
  const { PrinterStatus, OfflineCauseStatus, ErrorCauseStatus, RollPaperSensorStatus } = statuses2;
  function Printer(adapter, options) {
    if (!(this instanceof Printer)) {
      return new Printer(adapter);
    }
    EventEmitter.call(this);
    this.adapter = adapter;
    this.options = options;
    this.buffer = new MutableBuffer();
    this.encoding = options && options.encoding || "GB18030";
    this.width = options && options.width || 48;
    this._model = null;
  }
  Printer.create = function(device2) {
    const printer = new Printer(device2);
    return Promise.resolve(Promiseify(printer));
  };
  util2.inherits(Printer, EventEmitter);
  Printer.prototype.model = function(_model) {
    this._model = _model;
    return this;
  };
  Printer.prototype.setCharacterCodeTable = function(codeTable) {
    this.buffer.write(_.ESC);
    this.buffer.write(_.TAB);
    this.buffer.writeUInt8(codeTable);
    return this;
  };
  Printer.prototype.marginBottom = function(size) {
    this.buffer.write(_.MARGINS.BOTTOM);
    this.buffer.writeUInt8(size);
    return this;
  };
  Printer.prototype.marginLeft = function(size) {
    this.buffer.write(_.MARGINS.LEFT);
    this.buffer.writeUInt8(size);
    return this;
  };
  Printer.prototype.marginRight = function(size) {
    this.buffer.write(_.MARGINS.RIGHT);
    this.buffer.writeUInt8(size);
    return this;
  };
  Printer.prototype.print = function(content) {
    this.buffer.write(content);
    return this;
  };
  Printer.prototype.println = function(content) {
    return this.print(content + _.EOL);
  };
  Printer.prototype.newLine = function() {
    return this.print(_.EOL);
  };
  Printer.prototype.text = function(content, encoding) {
    return this.print(iconv.encode(content + _.EOL, encoding || this.encoding));
  };
  Printer.prototype.drawLine = function() {
    for (var i = 0; i < this.width; i++) {
      this.buffer.write(Buffer.from("-"));
    }
    this.newLine();
    return this;
  };
  Printer.prototype.table = function(data2, encoding) {
    var cellWidth = this.width / data2.length;
    var lineTxt = "";
    for (var i = 0; i < data2.length; i++) {
      lineTxt += data2[i].toString();
      var spaces = cellWidth - data2[i].toString().length;
      for (var j = 0; j < spaces; j++) {
        lineTxt += " ";
      }
    }
    this.buffer.write(iconv.encode(lineTxt + _.EOL, encoding || this.encoding));
    return this;
  };
  Printer.prototype.tableCustom = function(data2, options = {}) {
    options = options || { size: [], encoding: this.encoding };
    let [width = 1, height = 1] = options.size || [];
    let baseWidth = Math.floor(this.width / width);
    let cellWidth = Math.floor(baseWidth / data2.length);
    let leftoverSpace = baseWidth - cellWidth * data2.length;
    let lineStr = "";
    let secondLineEnabled = false;
    let secondLine = [];
    for (let i = 0; i < data2.length; i++) {
      let obj = data2[i];
      let align = (obj.align || "").toUpperCase();
      let tooLong = false;
      obj.text = obj.text.toString();
      let textLength = obj.text.length;
      if (obj.width) {
        cellWidth = baseWidth * obj.width;
      } else if (obj.cols) {
        cellWidth = obj.cols;
      }
      if (cellWidth < textLength) {
        tooLong = true;
        obj.originalText = obj.text;
        obj.text = obj.text.substring(0, cellWidth);
      }
      if (align === "CENTER") {
        let spaces = (cellWidth - textLength) / 2;
        for (let s = 0; s < spaces; s++) {
          lineStr += " ";
        }
        if (obj.text !== "") {
          if (obj.style) {
            lineStr += this._getStyle(obj.style) + obj.text + this._getStyle("NORMAL");
          } else {
            lineStr += obj.text;
          }
        }
        for (let s = 0; s < spaces - 1; s++) {
          lineStr += " ";
        }
      } else if (align === "RIGHT") {
        let spaces = cellWidth - textLength;
        if (leftoverSpace > 0) {
          spaces += leftoverSpace;
          leftoverSpace = 0;
        }
        for (let s = 0; s < spaces; s++) {
          lineStr += " ";
        }
        if (obj.text !== "") {
          if (obj.style) {
            lineStr += this._getStyle(obj.style) + obj.text + this._getStyle("NORMAL");
          } else {
            lineStr += obj.text;
          }
        }
      } else {
        if (obj.text !== "") {
          if (obj.style) {
            lineStr += this._getStyle(obj.style) + obj.text + this._getStyle("NORMAL");
          } else {
            lineStr += obj.text;
          }
        }
        let spaces = Math.floor(cellWidth - textLength);
        if (leftoverSpace > 0) {
          spaces += leftoverSpace;
          leftoverSpace = 0;
        }
        for (let s = 0; s < spaces; s++) {
          lineStr += " ";
        }
      }
      if (tooLong) {
        secondLineEnabled = true;
        obj.text = obj.originalText.substring(cellWidth);
        secondLine.push(obj);
      } else {
        obj.text = "";
        secondLine.push(obj);
      }
    }
    if (width > 1 || height > 1) {
      lineStr = _.TEXT_FORMAT.TXT_CUSTOM_SIZE(width, height) + lineStr + _.TEXT_FORMAT.TXT_NORMAL;
    }
    this.buffer.write(
      iconv.encode(lineStr + _.EOL, options.encoding || this.encoding)
    );
    if (secondLineEnabled) {
      return this.tableCustom(secondLine, options);
    } else {
      return this;
    }
  };
  Printer.prototype.pureText = function(content, encoding) {
    return this.print(iconv.encode(content, encoding || this.encoding));
  };
  Printer.prototype.encode = function(encoding) {
    this.encoding = encoding;
    return this;
  };
  Printer.prototype.feed = function(n) {
    this.buffer.write(new Array(n || 1).fill(_.EOL).join(""));
    return this;
  };
  Printer.prototype.control = function(ctrl) {
    this.buffer.write(_.FEED_CONTROL_SEQUENCES["CTL_" + ctrl.toUpperCase()]);
    return this;
  };
  Printer.prototype.align = function(align) {
    this.buffer.write(_.TEXT_FORMAT["TXT_ALIGN_" + align.toUpperCase()]);
    return this;
  };
  Printer.prototype.font = function(family) {
    this.buffer.write(_.TEXT_FORMAT["TXT_FONT_" + family.toUpperCase()]);
    if (family.toUpperCase() === "A")
      this.width = this.options && this.options.width || 42;
    else
      this.width = this.options && this.options.width || 56;
    return this;
  };
  Printer.prototype._getStyle = function(type2) {
    let styled = "";
    switch (type2.toUpperCase()) {
      case "B":
        styled += _.TEXT_FORMAT.TXT_BOLD_ON;
        styled += _.TEXT_FORMAT.TXT_ITALIC_OFF;
        styled += _.TEXT_FORMAT.TXT_UNDERL_OFF;
        break;
      case "I":
        styled += _.TEXT_FORMAT.TXT_BOLD_OFF;
        styled += _.TEXT_FORMAT.TXT_ITALIC_ON;
        styled += _.TEXT_FORMAT.TXT_UNDERL_OFF;
        break;
      case "U":
        styled += _.TEXT_FORMAT.TXT_BOLD_OFF;
        styled += _.TEXT_FORMAT.TXT_ITALIC_OFF;
        styled += _.TEXT_FORMAT.TXT_UNDERL_ON;
        break;
      case "U2":
        styled += _.TEXT_FORMAT.TXT_BOLD_OFF;
        styled += _.TEXT_FORMAT.TXT_ITALIC_OFF;
        styled += _.TEXT_FORMAT.TXT_UNDERL2_ON;
        break;
      case "BI":
        styled += _.TEXT_FORMAT.TXT_BOLD_ON;
        styled += _.TEXT_FORMAT.TXT_ITALIC_ON;
        styled += _.TEXT_FORMAT.TXT_UNDERL_OFF;
        break;
      case "BIU":
        styled += _.TEXT_FORMAT.TXT_BOLD_ON;
        styled += _.TEXT_FORMAT.TXT_ITALIC_ON;
        styled += _.TEXT_FORMAT.TXT_UNDERL_ON;
        break;
      case "BIU2":
        styled += _.TEXT_FORMAT.TXT_BOLD_ON;
        styled += _.TEXT_FORMAT.TXT_ITALIC_ON;
        styled += _.TEXT_FORMAT.TXT_UNDERL2_ON;
        break;
      case "BU":
        styled += _.TEXT_FORMAT.TXT_BOLD_ON;
        styled += _.TEXT_FORMAT.TXT_ITALIC_OFF;
        styled += _.TEXT_FORMAT.TXT_UNDERL_ON;
        break;
      case "BU2":
        styled += _.TEXT_FORMAT.TXT_BOLD_ON;
        styled += _.TEXT_FORMAT.TXT_ITALIC_OFF;
        styled += _.TEXT_FORMAT.TXT_UNDERL2_ON;
        break;
      case "IU":
        styled += _.TEXT_FORMAT.TXT_BOLD_OFF;
        styled += _.TEXT_FORMAT.TXT_ITALIC_ON;
        styled += _.TEXT_FORMAT.TXT_UNDERL_ON;
        break;
      case "IU2":
        styled += _.TEXT_FORMAT.TXT_BOLD_OFF;
        styled += _.TEXT_FORMAT.TXT_ITALIC_ON;
        styled += _.TEXT_FORMAT.TXT_UNDERL2_ON;
        break;
      case "NORMAL":
      default:
        styled += _.TEXT_FORMAT.TXT_BOLD_OFF;
        styled += _.TEXT_FORMAT.TXT_ITALIC_OFF;
        styled += _.TEXT_FORMAT.TXT_UNDERL_OFF;
        break;
    }
    return styled;
  };
  Printer.prototype.style = function(type2) {
    this.buffer.write(this._getStyle(type2));
    return this;
  };
  Printer.prototype.size = function(width, height) {
    this.buffer.write(_.TEXT_FORMAT.TXT_CUSTOM_SIZE(width, height));
    return this;
  };
  Printer.prototype.spacing = function(n) {
    if (n === void 0 || n === null) {
      this.buffer.write(_.CHARACTER_SPACING.CS_DEFAULT);
    } else {
      this.buffer.write(_.CHARACTER_SPACING.CS_SET);
      this.buffer.writeUInt8(n);
    }
    return this;
  };
  Printer.prototype.lineSpace = function(n) {
    if (n === void 0 || n === null) {
      this.buffer.write(_.LINE_SPACING.LS_DEFAULT);
    } else {
      this.buffer.write(_.LINE_SPACING.LS_SET);
      this.buffer.writeUInt8(n);
    }
    return this;
  };
  Printer.prototype.hardware = function(hw) {
    this.buffer.write(_.HARDWARE["HW_" + hw.toUpperCase()]);
    return this;
  };
  Printer.prototype.barcode = function(code, type2, options) {
    options = options || {};
    var width, height, position, font, includeParity;
    width = arguments[2];
    if (typeof width === "string" || typeof width === "number") {
      width = arguments[2];
      height = arguments[3];
      position = arguments[4];
      font = arguments[5];
    } else {
      width = options.width;
      height = options.height;
      position = options.position;
      font = options.font;
      includeParity = options.includeParity !== false;
    }
    type2 = type2 || "EAN13";
    var convertCode = String(code), parityBit = "", codeLength = "";
    if (typeof type2 === "undefined" || type2 === null) {
      throw new TypeError("barcode type is required");
    }
    if (type2 === "EAN13" && convertCode.length !== 12) {
      throw new Error("EAN13 Barcode type requires code length 12");
    }
    if (type2 === "EAN8" && convertCode.length !== 7) {
      throw new Error("EAN8 Barcode type requires code length 7");
    }
    if (this._model === "qsprinter") {
      this.buffer.write(_.MODEL.QSPRINTER.BARCODE_MODE.ON);
    }
    if (this._model === "qsprinter") ;
    else if (width >= 1 && width <= 5) {
      this.buffer.write(_.BARCODE_FORMAT.BARCODE_WIDTH[width]);
    } else {
      this.buffer.write(_.BARCODE_FORMAT.BARCODE_WIDTH_DEFAULT);
    }
    if (height >= 1 && height <= 255) {
      this.buffer.write(_.BARCODE_FORMAT.BARCODE_HEIGHT(height));
    } else {
      if (this._model === "qsprinter") {
        this.buffer.write(_.MODEL.QSPRINTER.BARCODE_HEIGHT_DEFAULT);
      } else {
        this.buffer.write(_.BARCODE_FORMAT.BARCODE_HEIGHT_DEFAULT);
      }
    }
    if (this._model === "qsprinter") ;
    else {
      this.buffer.write(_.BARCODE_FORMAT["BARCODE_FONT_" + (font || "A").toUpperCase()]);
    }
    this.buffer.write(_.BARCODE_FORMAT["BARCODE_TXT_" + (position || "BLW").toUpperCase()]);
    this.buffer.write(_.BARCODE_FORMAT["BARCODE_" + (type2 || "EAN13").replace("-", "_").toUpperCase()]);
    if (includeParity) {
      if (type2 === "EAN13" || type2 === "EAN8") {
        parityBit = utils2.getParityBit(code);
      }
    }
    if (type2 == "CODE128" || type2 == "CODE93") {
      codeLength = utils2.codeLength(code);
    }
    this.buffer.write(codeLength + code + (includeParity ? parityBit : "") + "\0");
    if (this._model === "qsprinter") {
      this.buffer.write(_.MODEL.QSPRINTER.BARCODE_MODE.OFF);
    }
    return this;
  };
  Printer.prototype.qrcode = function(code, version2, level, size) {
    if (this._model !== "qsprinter") {
      this.buffer.write(_.CODE2D_FORMAT.TYPE_QR);
      this.buffer.write(_.CODE2D_FORMAT.CODE2D);
      this.buffer.writeUInt8(version2 || 3);
      this.buffer.write(_.CODE2D_FORMAT["QR_LEVEL_" + (level || "L").toUpperCase()]);
      this.buffer.writeUInt8(size || 6);
      this.buffer.writeUInt16LE(code.length);
      this.buffer.write(code);
    } else {
      const dataRaw = iconv.encode(code, "utf8");
      if (dataRaw.length < 1 && dataRaw.length > 2710) {
        throw new Error("Invalid code length in byte. Must be between 1 and 2710");
      }
      if (!size || size && typeof size !== "number")
        size = _.MODEL.QSPRINTER.CODE2D_FORMAT.PIXEL_SIZE.DEFAULT;
      else if (size && size < _.MODEL.QSPRINTER.CODE2D_FORMAT.PIXEL_SIZE.MIN)
        size = _.MODEL.QSPRINTER.CODE2D_FORMAT.PIXEL_SIZE.MIN;
      else if (size && size > _.MODEL.QSPRINTER.CODE2D_FORMAT.PIXEL_SIZE.MAX)
        size = _.MODEL.QSPRINTER.CODE2D_FORMAT.PIXEL_SIZE.MAX;
      this.buffer.write(_.MODEL.QSPRINTER.CODE2D_FORMAT.PIXEL_SIZE.CMD);
      this.buffer.writeUInt8(size);
      if (!version2 || version2 && typeof version2 !== "number")
        version2 = _.MODEL.QSPRINTER.CODE2D_FORMAT.VERSION.DEFAULT;
      else if (version2 && version2 < _.MODEL.QSPRINTER.CODE2D_FORMAT.VERSION.MIN)
        version2 = _.MODEL.QSPRINTER.CODE2D_FORMAT.VERSION.MIN;
      else if (version2 && version2 > _.MODEL.QSPRINTER.CODE2D_FORMAT.VERSION.MAX)
        version2 = _.MODEL.QSPRINTER.CODE2D_FORMAT.VERSION.MAX;
      this.buffer.write(_.MODEL.QSPRINTER.CODE2D_FORMAT.VERSION.CMD);
      this.buffer.writeUInt8(version2);
      if (!level || level && typeof level !== "string")
        level = _.CODE2D_FORMAT.QR_LEVEL_L;
      this.buffer.write(_.MODEL.QSPRINTER.CODE2D_FORMAT.LEVEL.CMD);
      this.buffer.write(_.MODEL.QSPRINTER.CODE2D_FORMAT.LEVEL.OPTIONS[level.toUpperCase()]);
      this.buffer.write(_.MODEL.QSPRINTER.CODE2D_FORMAT.SAVEBUF.CMD_P1);
      this.buffer.writeUInt16LE(dataRaw.length + _.MODEL.QSPRINTER.CODE2D_FORMAT.LEN_OFFSET);
      this.buffer.write(_.MODEL.QSPRINTER.CODE2D_FORMAT.SAVEBUF.CMD_P2);
      this.buffer.write(dataRaw);
      this.buffer.write(_.MODEL.QSPRINTER.CODE2D_FORMAT.PRINTBUF.CMD_P1);
      this.buffer.writeUInt16LE(dataRaw.length + _.MODEL.QSPRINTER.CODE2D_FORMAT.LEN_OFFSET);
      this.buffer.write(_.MODEL.QSPRINTER.CODE2D_FORMAT.PRINTBUF.CMD_P2);
    }
    return this;
  };
  Printer.prototype.qrimage = function(content, options, callback) {
    var self2 = this;
    if (typeof options == "function") {
      callback = options;
      options = null;
    }
    options = options || { type: "png", mode: "dhdw" };
    var buffer = qr2.imageSync(content, options);
    var type2 = ["image", options.type].join("/");
    getPixels(buffer, type2, function(err, pixels) {
      if (err) return callback && callback(err);
      self2.raster(new Image(pixels), options.mode);
      callback && callback.call(self2, null, self2);
    });
    return this;
  };
  Printer.prototype.image = async function(image2, density) {
    if (!(image2 instanceof Image))
      throw new TypeError("Only escpos.Image supported");
    density = density || "d24";
    var n = !!~["d8", "s8"].indexOf(density) ? 1 : 3;
    var header = _.BITMAP_FORMAT["BITMAP_" + density.toUpperCase()];
    var bitmap2 = image2.toBitmap(n * 8);
    var self2 = this;
    this.lineSpace(0);
    bitmap2.data.forEach(async (line) => {
      self2.buffer.write(header);
      self2.buffer.writeUInt16LE(line.length / n);
      self2.buffer.write(line);
      self2.buffer.write(_.EOL);
      await new Promise((resolve, reject) => {
        setTimeout(() => {
          resolve(true);
        }, 200);
      });
    });
    return this.lineSpace();
  };
  Printer.prototype.raster = function(image2, mode) {
    if (!(image2 instanceof Image))
      throw new TypeError("Only escpos.Image supported");
    mode = mode || "normal";
    if (mode === "dhdw" || mode === "dwh" || mode === "dhw") mode = "dwdh";
    var raster = image2.toRaster();
    var header = _.GSV0_FORMAT["GSV0_" + mode.toUpperCase()];
    this.buffer.write(header);
    this.buffer.writeUInt16LE(raster.width);
    this.buffer.writeUInt16LE(raster.height);
    this.buffer.write(raster.data);
    return this;
  };
  Printer.prototype.cashdraw = function(pin) {
    this.buffer.write(_.CASH_DRAWER["CD_KICK_" + (pin || 2)]);
    return this;
  };
  Printer.prototype.beep = function(n, t) {
    this.buffer.write(_.BEEP);
    this.buffer.writeUInt8(n);
    this.buffer.writeUInt8(t);
    return this;
  };
  Printer.prototype.flush = function(callback) {
    var buf = this.buffer.flush();
    this.adapter.write(buf, callback);
    return this;
  };
  Printer.prototype.cut = function(part, feed) {
    this.feed(feed || 3);
    this.buffer.write(_.PAPER[part ? "PAPER_PART_CUT" : "PAPER_FULL_CUT"]);
    return this;
  };
  Printer.prototype.close = function(callback, options) {
    var self2 = this;
    return this.flush(function() {
      self2.adapter.close(callback, options);
    });
  };
  Printer.prototype.color = function(color) {
    this.buffer.write(_.COLOR[color === 0 || color === 1 ? color : 0]);
    return this;
  };
  Printer.prototype.setReverseColors = function(bool) {
    this.buffer.write(bool ? _.COLOR.REVERSE : _.COLOR.UNREVERSE);
    return this;
  };
  Printer.prototype.raw = function raw(data2) {
    if (Buffer.isBuffer(data2)) {
      this.buffer.write(data2);
    } else if (typeof data2 === "string") {
      data2 = data2.toLowerCase();
      this.buffer.write(Buffer.from(data2.replace(/(\s|:)/g, ""), "hex"));
    }
    return this;
  };
  Printer.prototype.getStatus = function(statusClassName, callback) {
    this.adapter.read((data2) => {
      const byte = data2.readInt8(0);
      const status = new statuses2[statusClassName](byte);
      callback(status);
    });
    statuses2[statusClassName].commands().forEach((c) => {
      this.buffer.write(c);
    });
    return this;
  };
  Printer.prototype.getStatuses = function(callback) {
    let buffer = [];
    this.adapter.read((data2) => {
      for (let i = 0; i < data2.byteLength; i++) {
        buffer.push(data2.readInt8(i));
      }
      if (buffer.length < 4) {
        return;
      }
      let statuses3 = [];
      for (let i = 0; i < buffer.length; i++) {
        let byte = buffer[i];
        switch (i) {
          case 0:
            statuses3.push(new PrinterStatus(byte));
            break;
          case 1:
            statuses3.push(new RollPaperSensorStatus(byte));
            break;
          case 2:
            statuses3.push(new OfflineCauseStatus(byte));
            break;
          case 3:
            statuses3.push(new ErrorCauseStatus(byte));
            break;
        }
      }
      buffer = [];
      callback(statuses3);
    });
    PrinterStatus.commands().forEach((c) => {
      this.adapter.write(c);
    });
    RollPaperSensorStatus.commands().forEach((c) => {
      this.adapter.write(c);
    });
    OfflineCauseStatus.commands().forEach((c) => {
      this.adapter.write(c);
    });
    ErrorCauseStatus.commands().forEach((c) => {
      this.adapter.write(c);
    });
    return this;
  };
  Printer.Printer = Printer;
  Printer.Image = requireImage();
  Printer.command = requireCommands();
  Printer.Printer2 = requirePromisify();
  escpos$1 = Printer;
  return escpos$1;
}
var escposExports = requireEscpos();
const escpos = /* @__PURE__ */ getDefaultExportFromCjs(escposExports);
var dist = {};
var webusb = {};
var device = {};
var bindings$1 = { exports: {} };
var nodeGypBuild$1 = { exports: {} };
var nodeGypBuild;
var hasRequiredNodeGypBuild$1;
function requireNodeGypBuild$1() {
  if (hasRequiredNodeGypBuild$1) return nodeGypBuild;
  hasRequiredNodeGypBuild$1 = 1;
  var fs = require$$0$a;
  var path = require$$1$5;
  var os = require$$2$3;
  var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : commonjsRequire;
  var vars = process.config && process.config.variables || {};
  var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
  var abi = process.versions.modules;
  var runtime = isElectron() ? "electron" : isNwjs() ? "node-webkit" : "node";
  var arch = process.env.npm_config_arch || os.arch();
  var platform = process.env.npm_config_platform || os.platform();
  var libc = process.env.LIBC || (isAlpine(platform) ? "musl" : "glibc");
  var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : vars.arm_version) || "";
  var uv = (process.versions.uv || "").split(".")[0];
  nodeGypBuild = load;
  function load(dir) {
    return runtimeRequire(load.resolve(dir));
  }
  load.resolve = load.path = function(dir) {
    dir = path.resolve(dir || ".");
    try {
      var name = runtimeRequire(path.join(dir, "package.json")).name.toUpperCase().replace(/-/g, "_");
      if (process.env[name + "_PREBUILD"]) dir = process.env[name + "_PREBUILD"];
    } catch (err) {
    }
    if (!prebuildsOnly) {
      var release = getFirst(path.join(dir, "build/Release"), matchBuild);
      if (release) return release;
      var debug = getFirst(path.join(dir, "build/Debug"), matchBuild);
      if (debug) return debug;
    }
    var prebuild = resolve(dir);
    if (prebuild) return prebuild;
    var nearby = resolve(path.dirname(process.execPath));
    if (nearby) return nearby;
    var target = [
      "platform=" + platform,
      "arch=" + arch,
      "runtime=" + runtime,
      "abi=" + abi,
      "uv=" + uv,
      armv ? "armv=" + armv : "",
      "libc=" + libc,
      "node=" + process.versions.node,
      process.versions.electron ? "electron=" + process.versions.electron : "",
      typeof __webpack_require__ === "function" ? "webpack=true" : ""
      // eslint-disable-line
    ].filter(Boolean).join(" ");
    throw new Error("No native build was found for " + target + "\n    loaded from: " + dir + "\n");
    function resolve(dir2) {
      var tuples = readdirSync(path.join(dir2, "prebuilds")).map(parseTuple);
      var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
      if (!tuple) return;
      var prebuilds = path.join(dir2, "prebuilds", tuple.name);
      var parsed = readdirSync(prebuilds).map(parseTags);
      var candidates = parsed.filter(matchTags(runtime, abi));
      var winner = candidates.sort(compareTags(runtime))[0];
      if (winner) return path.join(prebuilds, winner.file);
    }
  };
  function readdirSync(dir) {
    try {
      return fs.readdirSync(dir);
    } catch (err) {
      return [];
    }
  }
  function getFirst(dir, filter) {
    var files = readdirSync(dir).filter(filter);
    return files[0] && path.join(dir, files[0]);
  }
  function matchBuild(name) {
    return /\.node$/.test(name);
  }
  function parseTuple(name) {
    var arr = name.split("-");
    if (arr.length !== 2) return;
    var platform2 = arr[0];
    var architectures = arr[1].split("+");
    if (!platform2) return;
    if (!architectures.length) return;
    if (!architectures.every(Boolean)) return;
    return { name, platform: platform2, architectures };
  }
  function matchTuple(platform2, arch2) {
    return function(tuple) {
      if (tuple == null) return false;
      if (tuple.platform !== platform2) return false;
      return tuple.architectures.includes(arch2);
    };
  }
  function compareTuples(a, b) {
    return a.architectures.length - b.architectures.length;
  }
  function parseTags(file) {
    var arr = file.split(".");
    var extension = arr.pop();
    var tags = { file, specificity: 0 };
    if (extension !== "node") return;
    for (var i = 0; i < arr.length; i++) {
      var tag = arr[i];
      if (tag === "node" || tag === "electron" || tag === "node-webkit") {
        tags.runtime = tag;
      } else if (tag === "napi") {
        tags.napi = true;
      } else if (tag.slice(0, 3) === "abi") {
        tags.abi = tag.slice(3);
      } else if (tag.slice(0, 2) === "uv") {
        tags.uv = tag.slice(2);
      } else if (tag.slice(0, 4) === "armv") {
        tags.armv = tag.slice(4);
      } else if (tag === "glibc" || tag === "musl") {
        tags.libc = tag;
      } else {
        continue;
      }
      tags.specificity++;
    }
    return tags;
  }
  function matchTags(runtime2, abi2) {
    return function(tags) {
      if (tags == null) return false;
      if (tags.runtime && tags.runtime !== runtime2 && !runtimeAgnostic(tags)) return false;
      if (tags.abi && tags.abi !== abi2 && !tags.napi) return false;
      if (tags.uv && tags.uv !== uv) return false;
      if (tags.armv && tags.armv !== armv) return false;
      if (tags.libc && tags.libc !== libc) return false;
      return true;
    };
  }
  function runtimeAgnostic(tags) {
    return tags.runtime === "node" && tags.napi;
  }
  function compareTags(runtime2) {
    return function(a, b) {
      if (a.runtime !== b.runtime) {
        return a.runtime === runtime2 ? -1 : 1;
      } else if (a.abi !== b.abi) {
        return a.abi ? -1 : 1;
      } else if (a.specificity !== b.specificity) {
        return a.specificity > b.specificity ? -1 : 1;
      } else {
        return 0;
      }
    };
  }
  function isNwjs() {
    return !!(process.versions && process.versions.nw);
  }
  function isElectron() {
    if (process.versions && process.versions.electron) return true;
    if (process.env.ELECTRON_RUN_AS_NODE) return true;
    return typeof window !== "undefined" && window.process && window.process.type === "renderer";
  }
  function isAlpine(platform2) {
    return platform2 === "linux" && fs.existsSync("/etc/alpine-release");
  }
  load.parseTags = parseTags;
  load.matchTags = matchTags;
  load.compareTags = compareTags;
  load.parseTuple = parseTuple;
  load.matchTuple = matchTuple;
  load.compareTuples = compareTuples;
  return nodeGypBuild;
}
var hasRequiredNodeGypBuild;
function requireNodeGypBuild() {
  if (hasRequiredNodeGypBuild) return nodeGypBuild$1.exports;
  hasRequiredNodeGypBuild = 1;
  const runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : commonjsRequire;
  if (typeof runtimeRequire.addon === "function") {
    nodeGypBuild$1.exports = runtimeRequire.addon.bind(runtimeRequire);
  } else {
    nodeGypBuild$1.exports = requireNodeGypBuild$1();
  }
  return nodeGypBuild$1.exports;
}
var bindings = bindings$1.exports;
var hasRequiredBindings;
function requireBindings() {
  if (hasRequiredBindings) return bindings$1.exports;
  hasRequiredBindings = 1;
  Object.defineProperty(bindings, "__esModule", { value: true });
  const path_1 = require$$1$5;
  const usb = requireNodeGypBuild()(process.env.NODE_USB_PATH || (0, path_1.join)(__dirname, "..", ".."));
  bindings$1.exports = usb;
  return bindings$1.exports;
}
var _interface = {};
var endpoint = {};
var hasRequiredEndpoint;
function requireEndpoint() {
  if (hasRequiredEndpoint) return endpoint;
  hasRequiredEndpoint = 1;
  Object.defineProperty(endpoint, "__esModule", { value: true });
  endpoint.OutEndpoint = endpoint.InEndpoint = endpoint.Endpoint = void 0;
  const events_1 = require$$0$b;
  const bindings_1 = requireBindings();
  const util_1 = require$$0$5;
  const isBuffer = (obj) => obj && obj instanceof Buffer;
  class Endpoint extends events_1.EventEmitter {
    constructor(device2, descriptor) {
      super();
      this.device = device2;
      this.timeout = 0;
      this.descriptor = descriptor;
      this.address = descriptor.bEndpointAddress;
      this.transferType = descriptor.bmAttributes & 3;
    }
    /** Clear the halt/stall condition for this endpoint. */
    clearHalt(callback) {
      return this.device.__clearHalt(this.address, callback);
    }
    /**
     * Create a new `Transfer` object for this endpoint.
     *
     * The passed callback will be called when the transfer is submitted and finishes. Its arguments are the error (if any), the submitted buffer, and the amount of data actually written (for
     * OUT transfers) or read (for IN transfers).
     *
     * @param timeout Timeout for the transfer (0 means unlimited).
     * @param callback Transfer completion callback.
     */
    makeTransfer(timeout, callback) {
      return new bindings_1.Transfer(this.device, this.address, this.transferType, timeout, callback);
    }
  }
  endpoint.Endpoint = Endpoint;
  class InEndpoint extends Endpoint {
    constructor(device2, descriptor) {
      super(device2, descriptor);
      this.direction = "in";
      this.pollTransfers = [];
      this.pollTransferSize = 0;
      this.pollPending = 0;
      this.pollActive = false;
      this.transferAsync = (0, util_1.promisify)(this.transfer).bind(this);
    }
    /**
     * Perform a transfer to read data from the endpoint.
     *
     * If length is greater than maxPacketSize, libusb will automatically split the transfer in multiple packets, and you will receive one callback with all data once all packets are complete.
     *
     * `this` in the callback is the InEndpoint object.
     *
     * The device must be open to use this method.
     * @param length
     * @param callback
     */
    transfer(length, callback) {
      const buffer = Buffer.alloc(length);
      const cb = (error2, _buffer, actualLength) => {
        callback.call(this, error2, buffer.slice(0, actualLength));
      };
      try {
        this.makeTransfer(this.timeout, cb).submit(buffer);
      } catch (e) {
        process.nextTick(() => callback.call(this, e));
      }
      return this;
    }
    /**
     * Start polling the endpoint.
     *
     * The library will keep `nTransfers` transfers of size `transferSize` pending in the kernel at all times to ensure continuous data flow.
     * This is handled by the libusb event thread, so it continues even if the Node v8 thread is busy. The `data` and `error` events are emitted as transfers complete.
     *
     * The device must be open to use this method.
     * @param nTransfers
     * @param transferSize
     * @param callback
     */
    startPoll(nTransfers, transferSize, callback) {
      const transferDone = (error2, transfer, buffer, actualLength) => {
        if (!error2) {
          this.emit("data", buffer.slice(0, actualLength));
        } else if (error2.errno !== bindings_1.LIBUSB_TRANSFER_CANCELLED) {
          if (this.pollActive) {
            this.emit("error", error2);
            this.stopPoll();
          }
        }
        if (this.pollActive) {
          startTransfer(transfer);
        } else {
          this.pollPending--;
          if (this.pollPending === 0) {
            this.pollTransfers = [];
            this.pollActive = false;
            this.emit("end");
            if (callback) {
              const cancelled = (error2 === null || error2 === void 0 ? void 0 : error2.errno) === bindings_1.LIBUSB_TRANSFER_CANCELLED;
              callback(cancelled ? void 0 : error2, buffer, actualLength, cancelled);
            }
          }
        }
      };
      const startTransfer = (transfer) => {
        try {
          transfer.submit(Buffer.alloc(this.pollTransferSize), (error2, buffer, actualLength) => {
            transferDone(error2, transfer, buffer, actualLength);
          });
        } catch (e) {
          this.emit("error", e);
          this.stopPoll();
        }
      };
      this.pollTransfers = this.startPollTransfers(nTransfers, transferSize, function(error2, buffer, actualLength) {
        transferDone(error2, this, buffer, actualLength);
      });
      this.pollTransfers.forEach(startTransfer);
      this.pollPending = this.pollTransfers.length;
      return this.pollTransfers;
    }
    startPollTransfers(nTransfers = 3, transferSize = this.descriptor.wMaxPacketSize, callback) {
      if (this.pollActive) {
        throw new Error("Polling already active");
      }
      this.pollTransferSize = transferSize;
      this.pollActive = true;
      this.pollPending = 0;
      const transfers = [];
      for (let i = 0; i < nTransfers; i++) {
        const transfer = this.makeTransfer(0, callback);
        transfers[i] = transfer;
      }
      return transfers;
    }
    /**
     * Stop polling.
     *
     * Further data may still be received. The `end` event is emitted and the callback is called once all transfers have completed or canceled.
     *
     * The device must be open to use this method.
     * @param callback
     */
    stopPoll(callback) {
      if (!this.pollActive) {
        throw new Error("Polling is not active.");
      }
      for (let i = 0; i < this.pollTransfers.length; i++) {
        try {
          this.pollTransfers[i].cancel();
        } catch (error2) {
          this.emit("error", error2);
        }
      }
      this.pollActive = false;
      if (callback)
        this.once("end", callback);
    }
  }
  endpoint.InEndpoint = InEndpoint;
  class OutEndpoint extends Endpoint {
    constructor(device2, descriptor) {
      super(device2, descriptor);
      this.direction = "out";
      this.transferAsync = (0, util_1.promisify)(this.transfer).bind(this);
    }
    /**
     * Perform a transfer to write `data` to the endpoint.
     *
     * If length is greater than maxPacketSize, libusb will automatically split the transfer in multiple packets, and you will receive one callback once all packets are complete.
     *
     * `this` in the callback is the OutEndpoint object.
     *
     * The device must be open to use this method.
     * @param buffer
     * @param callback
     */
    transfer(buffer, callback) {
      if (!buffer) {
        buffer = Buffer.alloc(0);
      } else if (!isBuffer(buffer)) {
        buffer = Buffer.from(buffer);
      }
      const cb = (error2, _buffer, actual) => {
        if (callback) {
          callback.call(this, error2, actual || 0);
        }
      };
      try {
        this.makeTransfer(this.timeout, cb).submit(buffer);
      } catch (e) {
        process.nextTick(() => cb(e));
      }
      return this;
    }
    transferWithZLP(buffer, callback) {
      if (buffer.length % this.descriptor.wMaxPacketSize === 0) {
        this.transfer(buffer);
        this.transfer(Buffer.alloc(0), callback);
      } else {
        this.transfer(buffer, callback);
      }
    }
  }
  endpoint.OutEndpoint = OutEndpoint;
  return endpoint;
}
var hasRequired_interface;
function require_interface() {
  if (hasRequired_interface) return _interface;
  hasRequired_interface = 1;
  Object.defineProperty(_interface, "__esModule", { value: true });
  _interface.Interface = void 0;
  const bindings_1 = requireBindings();
  const endpoint_1 = requireEndpoint();
  const util_1 = require$$0$5;
  class Interface {
    constructor(device2, id) {
      this.device = device2;
      this.id = id;
      this.altSetting = 0;
      this.refresh();
      this.releaseAsync = (0, util_1.promisify)(this.release).bind(this);
      this.setAltSettingAsync = (0, util_1.promisify)(this.setAltSetting).bind(this);
    }
    refresh() {
      if (!this.device.configDescriptor) {
        return;
      }
      this.descriptor = this.device.configDescriptor.interfaces[this.id][this.altSetting];
      this.interfaceNumber = this.descriptor.bInterfaceNumber;
      this.endpoints = [];
      const len = this.descriptor.endpoints.length;
      for (let i = 0; i < len; i++) {
        const desc = this.descriptor.endpoints[i];
        const c = desc.bEndpointAddress & bindings_1.LIBUSB_ENDPOINT_IN ? endpoint_1.InEndpoint : endpoint_1.OutEndpoint;
        this.endpoints[i] = new c(this.device, desc);
      }
    }
    /**
     * Claims the interface. This method must be called before using any endpoints of this interface.
     *
     * The device must be open to use this method.
     */
    claim() {
      this.device.__claimInterface(this.id);
    }
    release(closeEndpointsOrCallback, callback) {
      let closeEndpoints = false;
      if (typeof closeEndpointsOrCallback === "boolean") {
        closeEndpoints = closeEndpointsOrCallback;
      } else {
        callback = closeEndpointsOrCallback;
      }
      const next = () => {
        this.device.__releaseInterface(this.id, (error2) => {
          if (!error2) {
            this.altSetting = 0;
            this.refresh();
          }
          if (callback) {
            callback.call(this, error2);
          }
        });
      };
      if (!closeEndpoints || this.endpoints.length === 0) {
        next();
      } else {
        let n = this.endpoints.length;
        this.endpoints.forEach((ep) => {
          if (ep.direction === "in" && ep.pollActive) {
            ep.once("end", () => {
              if (--n === 0) {
                next();
              }
            });
            ep.stopPoll();
          } else {
            if (--n === 0) {
              next();
            }
          }
        });
      }
    }
    /**
     * Returns `false` if a kernel driver is not active; `true` if active.
     *
     * The device must be open to use this method.
     */
    isKernelDriverActive() {
      return this.device.__isKernelDriverActive(this.id);
    }
    /**
     * Detaches the kernel driver from the interface.
     *
     * The device must be open to use this method.
     */
    detachKernelDriver() {
      return this.device.__detachKernelDriver(this.id);
    }
    /**
     * Re-attaches the kernel driver for the interface.
     *
     * The device must be open to use this method.
     */
    attachKernelDriver() {
      return this.device.__attachKernelDriver(this.id);
    }
    /**
     * Sets the alternate setting. It updates the `interface.endpoints` array to reflect the endpoints found in the alternate setting.
     *
     * The device must be open to use this method.
     * @param altSetting
     * @param callback
     */
    setAltSetting(altSetting, callback) {
      this.device.__setInterface(this.id, altSetting, (error2) => {
        if (!error2) {
          this.altSetting = altSetting;
          this.refresh();
        }
        if (callback) {
          callback.call(this, error2);
        }
      });
    }
    /**
     * Return the InEndpoint or OutEndpoint with the specified address.
     *
     * The device must be open to use this method.
     * @param addr
     */
    endpoint(addr) {
      return this.endpoints.find((item) => item.address === addr);
    }
  }
  _interface.Interface = Interface;
  return _interface;
}
var capability = {};
var hasRequiredCapability;
function requireCapability() {
  if (hasRequiredCapability) return capability;
  hasRequiredCapability = 1;
  Object.defineProperty(capability, "__esModule", { value: true });
  capability.Capability = void 0;
  class Capability {
    constructor(device2, id) {
      this.device = device2;
      this.id = id;
      if (!device2._bosDescriptor) {
        throw new Error("bosDescriptor not found");
      }
      this.descriptor = device2._bosDescriptor.capabilities[this.id];
      this.type = this.descriptor.bDevCapabilityType;
      this.data = this.descriptor.dev_capability_data;
    }
  }
  capability.Capability = Capability;
  return capability;
}
var hasRequiredDevice;
function requireDevice() {
  if (hasRequiredDevice) return device;
  hasRequiredDevice = 1;
  Object.defineProperty(device, "__esModule", { value: true });
  device.ExtendedDevice = void 0;
  const usb = requireBindings();
  const interface_1 = require_interface();
  const capability_1 = requireCapability();
  const isBuffer = (obj) => !!obj && obj instanceof Uint8Array;
  const DEFAULT_TIMEOUT = 1e3;
  class ExtendedDevice {
    constructor() {
      this._timeout = DEFAULT_TIMEOUT;
    }
    /**
     * Timeout in milliseconds to use for control transfers.
     */
    get timeout() {
      return this._timeout || DEFAULT_TIMEOUT;
    }
    set timeout(value) {
      this._timeout = value;
    }
    /**
     * Object with properties for the fields of the active configuration descriptor.
     */
    get configDescriptor() {
      try {
        return this.__getConfigDescriptor();
      } catch (e) {
        const errno = e.errno;
        if (errno === usb.LIBUSB_ERROR_NOT_FOUND || errno === usb.LIBUSB_ERROR_NO_DEVICE) {
          return void 0;
        }
        throw e;
      }
    }
    /**
     * Contains all config descriptors of the device (same structure as .configDescriptor above)
     */
    get allConfigDescriptors() {
      try {
        return this.__getAllConfigDescriptors();
      } catch (e) {
        const errno = e.errno;
        if (errno === usb.LIBUSB_ERROR_NOT_FOUND || errno === usb.LIBUSB_ERROR_NO_DEVICE) {
          return [];
        }
        throw e;
      }
    }
    /**
     * Contains the parent of the device, such as a hub. If there is no parent this property is set to `null`.
     */
    get parent() {
      return this.__getParent();
    }
    /**
     * Open the device.
     * @param defaultConfig
     */
    open(defaultConfig = true) {
      this.__open();
      this.interfaces = [];
      if (defaultConfig === false) {
        return;
      }
      const len = this.configDescriptor ? this.configDescriptor.interfaces.length : 0;
      for (let i = 0; i < len; i++) {
        this.interfaces[i] = new interface_1.Interface(this, i);
      }
    }
    /**
     * Close the device.
     *
     * The device must be open to use this method.
     */
    close() {
      this.__close();
      this.interfaces = void 0;
    }
    /**
     * Set the device configuration to something other than the default (0). To use this, first call `.open(false)` (which tells it not to auto configure),
     * then before claiming an interface, call this method.
     *
     * The device must be open to use this method.
     * @param desired
     * @param callback
     */
    setConfiguration(desired, callback) {
      this.__setConfiguration(desired, (error2) => {
        if (!error2) {
          this.interfaces = [];
          const len = this.configDescriptor ? this.configDescriptor.interfaces.length : 0;
          for (let i = 0; i < len; i++) {
            this.interfaces[i] = new interface_1.Interface(this, i);
          }
        }
        if (callback) {
          callback.call(this, error2);
        }
      });
    }
    /**
     * Enable/disable libusb's automatic kernel driver detachment
     * When this is enabled libusb will automatically detach the kernel driver on an interface when claiming the interface, and attach it when releasing the interface
     *
     * The device must be open to use this method.
     */
    setAutoDetachKernelDriver(enable) {
      return this.__setAutoDetachKernelDriver(enable ? 1 : 0);
    }
    /**
     * Perform a control transfer with `libusb_control_transfer`.
     *
     * Parameter `data_or_length` can be an integer length for an IN transfer, or a `Buffer` for an OUT transfer. The type must match the direction specified in the MSB of bmRequestType.
     *
     * The `data` parameter of the callback is actual transferred for OUT transfers, or will be passed a Buffer for IN transfers.
     *
     * The device must be open to use this method.
     * @param bmRequestType
     * @param bRequest
     * @param wValue
     * @param wIndex
     * @param data_or_length
     * @param callback
     */
    controlTransfer(bmRequestType, bRequest, wValue, wIndex, data_or_length, callback) {
      const isIn = !!(bmRequestType & usb.LIBUSB_ENDPOINT_IN);
      const wLength = isIn ? data_or_length : data_or_length.length;
      if (isIn) {
        if (wLength < 0) {
          throw new TypeError("Expected size number for IN transfer (based on bmRequestType)");
        }
      } else {
        if (!isBuffer(data_or_length)) {
          throw new TypeError("Expected buffer for OUT transfer (based on bmRequestType)");
        }
      }
      const buf = Buffer.alloc(wLength + usb.LIBUSB_CONTROL_SETUP_SIZE);
      buf.writeUInt8(bmRequestType, 0);
      buf.writeUInt8(bRequest, 1);
      buf.writeUInt16LE(wValue, 2);
      buf.writeUInt16LE(wIndex, 4);
      buf.writeUInt16LE(wLength, 6);
      if (!isIn) {
        buf.set(data_or_length, usb.LIBUSB_CONTROL_SETUP_SIZE);
      }
      const transfer = new usb.Transfer(this, 0, usb.LIBUSB_TRANSFER_TYPE_CONTROL, this.timeout, (error2, buf2, actual) => {
        if (callback) {
          if (isIn) {
            callback.call(this, error2, buf2.slice(usb.LIBUSB_CONTROL_SETUP_SIZE, usb.LIBUSB_CONTROL_SETUP_SIZE + actual));
          } else {
            callback.call(this, error2, actual);
          }
        }
      });
      try {
        transfer.submit(buf);
      } catch (e) {
        if (callback) {
          process.nextTick(() => callback.call(this, e, void 0));
        }
      }
      return this;
    }
    /**
     * Return the interface with the specified interface number.
     *
     * The device must be open to use this method.
     * @param addr
     */
    interface(addr) {
      if (!this.interfaces) {
        throw new Error("Device must be open before searching for interfaces");
      }
      addr = addr || 0;
      for (let i = 0; i < this.interfaces.length; i++) {
        if (this.interfaces[i].interfaceNumber === addr) {
          return this.interfaces[i];
        }
      }
      throw new Error(`Interface not found for address: ${addr}`);
    }
    /**
     * Perform a control transfer to retrieve a string descriptor
     *
     * The device must be open to use this method.
     * @param desc_index
     * @param callback
     */
    getStringDescriptor(desc_index, callback) {
      if (desc_index === 0) {
        callback();
        return;
      }
      const langid = 1033;
      const length = 255;
      this.controlTransfer(usb.LIBUSB_ENDPOINT_IN, usb.LIBUSB_REQUEST_GET_DESCRIPTOR, usb.LIBUSB_DT_STRING << 8 | desc_index, langid, length, (error2, buffer) => {
        if (error2) {
          return callback(error2);
        }
        callback(void 0, isBuffer(buffer) ? buffer.toString("utf16le", 2) : void 0);
      });
    }
    /**
     * Perform a control transfer to retrieve an object with properties for the fields of the Binary Object Store descriptor.
     *
     * The device must be open to use this method.
     * @param callback
     */
    getBosDescriptor(callback) {
      if (this._bosDescriptor) {
        return callback(void 0, this._bosDescriptor);
      }
      if (this.deviceDescriptor.bcdUSB < 513) {
        return callback(void 0, void 0);
      }
      this.controlTransfer(usb.LIBUSB_ENDPOINT_IN, usb.LIBUSB_REQUEST_GET_DESCRIPTOR, usb.LIBUSB_DT_BOS << 8, 0, usb.LIBUSB_DT_BOS_SIZE, (error2, buffer) => {
        if (error2) {
          if (error2.errno === usb.LIBUSB_TRANSFER_STALL)
            return callback(void 0, void 0);
          return callback(error2, void 0);
        }
        if (!isBuffer(buffer)) {
          return callback(void 0, void 0);
        }
        const totalLength = buffer.readUInt16LE(2);
        this.controlTransfer(usb.LIBUSB_ENDPOINT_IN, usb.LIBUSB_REQUEST_GET_DESCRIPTOR, usb.LIBUSB_DT_BOS << 8, 0, totalLength, (error3, buffer2) => {
          if (error3) {
            if (error3.errno === usb.LIBUSB_TRANSFER_STALL)
              return callback(void 0, void 0);
            return callback(error3, void 0);
          }
          if (!isBuffer(buffer2)) {
            return callback(void 0, void 0);
          }
          const descriptor = {
            bLength: buffer2.readUInt8(0),
            bDescriptorType: buffer2.readUInt8(1),
            wTotalLength: buffer2.readUInt16LE(2),
            bNumDeviceCaps: buffer2.readUInt8(4),
            capabilities: []
          };
          let i = usb.LIBUSB_DT_BOS_SIZE;
          while (i < descriptor.wTotalLength) {
            const capability2 = {
              bLength: buffer2.readUInt8(i + 0),
              bDescriptorType: buffer2.readUInt8(i + 1),
              bDevCapabilityType: buffer2.readUInt8(i + 2),
              dev_capability_data: buffer2.slice(i + 3, i + buffer2.readUInt8(i + 0))
            };
            descriptor.capabilities.push(capability2);
            i += capability2.bLength;
          }
          this._bosDescriptor = descriptor;
          callback(void 0, this._bosDescriptor);
        });
      });
    }
    /**
     * Retrieve a list of Capability objects for the Binary Object Store capabilities of the device.
     *
     * The device must be open to use this method.
     * @param callback
     */
    getCapabilities(callback) {
      const capabilities = [];
      this.getBosDescriptor((error2, descriptor) => {
        if (error2)
          return callback(error2, void 0);
        const len = descriptor ? descriptor.capabilities.length : 0;
        for (let i = 0; i < len; i++) {
          capabilities.push(new capability_1.Capability(this, i));
        }
        callback(void 0, capabilities);
      });
    }
  }
  device.ExtendedDevice = ExtendedDevice;
  return device;
}
var usb_1;
var hasRequiredUsb;
function requireUsb() {
  if (hasRequiredUsb) return usb_1;
  hasRequiredUsb = 1;
  const events_1 = require$$0$b;
  const device_1 = requireDevice();
  const usb = requireBindings();
  if (usb.INIT_ERROR) {
    console.warn("Failed to initialize libusb.");
  }
  Object.setPrototypeOf(usb, events_1.EventEmitter.prototype);
  Object.defineProperty(usb, "pollHotplug", {
    value: false,
    writable: true
  });
  Object.defineProperty(usb, "pollHotplugDelay", {
    value: 500,
    writable: true
  });
  if (usb.Device) {
    Object.getOwnPropertyNames(device_1.ExtendedDevice.prototype).forEach((name) => {
      Object.defineProperty(usb.Device.prototype, name, Object.getOwnPropertyDescriptor(device_1.ExtendedDevice.prototype, name) || /* @__PURE__ */ Object.create(null));
    });
  }
  let hotPlugDevices = /* @__PURE__ */ new Set();
  const emitHotplugEvents = () => {
    const devices = new Set(usb.getDeviceList());
    for (const device2 of devices) {
      if (!hotPlugDevices.has(device2)) {
        usb.emit("attach", device2);
      }
    }
    for (const device2 of hotPlugDevices) {
      if (!devices.has(device2)) {
        usb.emit("detach", device2);
      }
    }
    hotPlugDevices = devices;
  };
  let pollingHotplug = false;
  const pollHotplug = (start = false) => {
    if (start) {
      pollingHotplug = true;
    } else if (!pollingHotplug) {
      return;
    } else {
      emitHotplugEvents();
    }
    setTimeout(() => pollHotplug(), usb.pollHotplugDelay);
  };
  const devicesChanged = () => setTimeout(() => emitHotplugEvents(), usb.pollHotplugDelay);
  let hotplugSupported = 0;
  const startHotplug = () => {
    hotplugSupported = usb.pollHotplug ? 0 : usb._supportedHotplugEvents();
    if (hotplugSupported !== 1) {
      hotPlugDevices = new Set(usb.getDeviceList());
    }
    if (hotplugSupported) {
      usb._enableHotplugEvents();
      if (hotplugSupported === 2) {
        usb.on("attachIds", devicesChanged);
        usb.on("detachIds", devicesChanged);
      }
    } else {
      pollHotplug(true);
    }
  };
  const stopHotplug = () => {
    if (hotplugSupported) {
      usb._disableHotplugEvents();
      if (hotplugSupported === 2) {
        usb.off("attachIds", devicesChanged);
        usb.off("detachIds", devicesChanged);
      }
    } else {
      pollingHotplug = false;
    }
  };
  usb.on("newListener", (event) => {
    if (event !== "attach" && event !== "detach") {
      return;
    }
    const listenerCount = usb.listenerCount("attach") + usb.listenerCount("detach");
    if (listenerCount === 0) {
      startHotplug();
    }
  });
  usb.on("removeListener", (event) => {
    if (event !== "attach" && event !== "detach") {
      return;
    }
    const listenerCount = usb.listenerCount("attach") + usb.listenerCount("detach");
    if (listenerCount === 0) {
      stopHotplug();
    }
  });
  usb_1 = usb;
  return usb_1;
}
var webusbDevice = {};
var hasRequiredWebusbDevice;
function requireWebusbDevice() {
  if (hasRequiredWebusbDevice) return webusbDevice;
  hasRequiredWebusbDevice = 1;
  Object.defineProperty(webusbDevice, "__esModule", { value: true });
  webusbDevice.WebUSBDevice = void 0;
  const usb = requireUsb();
  const util_1 = require$$0$5;
  const os_1 = require$$2$3;
  const LIBUSB_TRANSFER_TYPE_MASK = 3;
  const ENDPOINT_NUMBER_MASK = 127;
  const CLEAR_FEATURE = 1;
  const ENDPOINT_HALT = 0;
  class WebUSBDevice {
    static async createInstance(device2, autoDetachKernelDriver = true) {
      const instance = new WebUSBDevice(device2, autoDetachKernelDriver);
      await instance.initialize();
      return instance;
    }
    constructor(device2, autoDetachKernelDriver) {
      this.device = device2;
      this.autoDetachKernelDriver = autoDetachKernelDriver;
      this.manufacturerName = null;
      this.productName = null;
      this.serialNumber = null;
      this.configurations = [];
      const usbVersion = this.decodeVersion(device2.deviceDescriptor.bcdUSB);
      this.usbVersionMajor = usbVersion.major;
      this.usbVersionMinor = usbVersion.minor;
      this.usbVersionSubminor = usbVersion.sub;
      this.deviceClass = device2.deviceDescriptor.bDeviceClass;
      this.deviceSubclass = device2.deviceDescriptor.bDeviceSubClass;
      this.deviceProtocol = device2.deviceDescriptor.bDeviceProtocol;
      this.vendorId = device2.deviceDescriptor.idVendor;
      this.productId = device2.deviceDescriptor.idProduct;
      const deviceVersion = this.decodeVersion(device2.deviceDescriptor.bcdDevice);
      this.deviceVersionMajor = deviceVersion.major;
      this.deviceVersionMinor = deviceVersion.minor;
      this.deviceVersionSubminor = deviceVersion.sub;
      this.controlTransferAsync = (0, util_1.promisify)(this.device.controlTransfer).bind(this.device);
      this.setConfigurationAsync = (0, util_1.promisify)(this.device.setConfiguration).bind(this.device);
      this.resetAsync = (0, util_1.promisify)(this.device.reset).bind(this.device);
      this.getStringDescriptorAsync = (0, util_1.promisify)(this.device.getStringDescriptor).bind(this.device);
    }
    get configuration() {
      if (!this.device.configDescriptor) {
        return null;
      }
      const currentConfiguration = this.device.configDescriptor.bConfigurationValue;
      return this.configurations.find((configuration) => configuration.configurationValue === currentConfiguration) || null;
    }
    get opened() {
      return !!this.device.interfaces;
    }
    async open() {
      try {
        if (this.opened) {
          return;
        }
        this.device.open();
        if ((0, os_1.platform)() !== "win32") {
          this.device.setAutoDetachKernelDriver(this.autoDetachKernelDriver);
        }
      } catch (error2) {
        throw new Error(`open error: ${error2}`);
      }
    }
    async close() {
      try {
        if (!this.opened) {
          return;
        }
        try {
          if (this.configuration) {
            for (const iface of this.configuration.interfaces) {
              await this._releaseInterface(iface.interfaceNumber);
              this.configuration.interfaces[this.configuration.interfaces.indexOf(iface)] = {
                interfaceNumber: iface.interfaceNumber,
                alternate: iface.alternate,
                alternates: iface.alternates,
                claimed: false
              };
            }
          }
        } catch (_error) {
        }
        this.device.close();
      } catch (error2) {
        throw new Error(`close error: ${error2}`);
      }
    }
    async selectConfiguration(configurationValue) {
      if (!this.opened || !this.device.configDescriptor) {
        throw new Error("selectConfiguration error: invalid state");
      }
      if (this.device.configDescriptor.bConfigurationValue === configurationValue) {
        return;
      }
      const config = this.configurations.find((configuration) => configuration.configurationValue === configurationValue);
      if (!config) {
        throw new Error("selectConfiguration error: configuration not found");
      }
      try {
        await this.setConfigurationAsync(configurationValue);
      } catch (error2) {
        throw new Error(`selectConfiguration error: ${error2}`);
      }
    }
    async claimInterface(interfaceNumber) {
      if (!this.opened) {
        throw new Error("claimInterface error: invalid state");
      }
      if (!this.configuration) {
        throw new Error("claimInterface error: interface not found");
      }
      const iface = this.configuration.interfaces.find((usbInterface) => usbInterface.interfaceNumber === interfaceNumber);
      if (!iface) {
        throw new Error("claimInterface error: interface not found");
      }
      if (iface.claimed) {
        return;
      }
      try {
        this.device.interface(interfaceNumber).claim();
        this.configuration.interfaces[this.configuration.interfaces.indexOf(iface)] = {
          interfaceNumber,
          alternate: iface.alternate,
          alternates: iface.alternates,
          claimed: true
        };
      } catch (error2) {
        throw new Error(`claimInterface error: ${error2}`);
      }
    }
    async releaseInterface(interfaceNumber) {
      await this._releaseInterface(interfaceNumber);
      if (this.configuration) {
        const iface = this.configuration.interfaces.find((usbInterface) => usbInterface.interfaceNumber === interfaceNumber);
        if (iface) {
          this.configuration.interfaces[this.configuration.interfaces.indexOf(iface)] = {
            interfaceNumber,
            alternate: iface.alternate,
            alternates: iface.alternates,
            claimed: false
          };
        }
      }
    }
    async selectAlternateInterface(interfaceNumber, alternateSetting) {
      if (!this.opened) {
        throw new Error("selectAlternateInterface error: invalid state");
      }
      if (!this.configuration) {
        throw new Error("selectAlternateInterface error: interface not found");
      }
      const iface = this.configuration.interfaces.find((usbInterface) => usbInterface.interfaceNumber === interfaceNumber);
      if (!iface) {
        throw new Error("selectAlternateInterface error: interface not found");
      }
      if (!iface.claimed) {
        throw new Error("selectAlternateInterface error: invalid state");
      }
      try {
        const iface2 = this.device.interface(interfaceNumber);
        await iface2.setAltSettingAsync(alternateSetting);
      } catch (error2) {
        throw new Error(`selectAlternateInterface error: ${error2}`);
      }
    }
    async controlTransferIn(setup, length) {
      try {
        this.checkDeviceOpen();
        const type2 = this.controlTransferParamsToType(setup, usb.LIBUSB_ENDPOINT_IN);
        const result = await this.controlTransferAsync(type2, setup.request, setup.value, setup.index, length);
        return {
          data: result ? new DataView(new Uint8Array(result).buffer) : void 0,
          status: "ok"
        };
      } catch (error2) {
        if (error2.errno === usb.LIBUSB_TRANSFER_STALL) {
          return {
            status: "stall"
          };
        }
        if (error2.errno === usb.LIBUSB_TRANSFER_OVERFLOW) {
          return {
            status: "babble"
          };
        }
        throw new Error(`controlTransferIn error: ${error2}`);
      }
    }
    async controlTransferOut(setup, data2) {
      try {
        this.checkDeviceOpen();
        const type2 = this.controlTransferParamsToType(setup, usb.LIBUSB_ENDPOINT_OUT);
        const buffer = data2 ? Buffer.from(data2) : Buffer.alloc(0);
        const bytesWritten = await this.controlTransferAsync(type2, setup.request, setup.value, setup.index, buffer);
        return {
          bytesWritten,
          status: "ok"
        };
      } catch (error2) {
        if (error2.errno === usb.LIBUSB_TRANSFER_STALL) {
          return {
            bytesWritten: 0,
            status: "stall"
          };
        }
        throw new Error(`controlTransferOut error: ${error2}`);
      }
    }
    async clearHalt(direction, endpointNumber) {
      try {
        const wIndex = endpointNumber | (direction === "in" ? usb.LIBUSB_ENDPOINT_IN : usb.LIBUSB_ENDPOINT_OUT);
        await this.controlTransferAsync(usb.LIBUSB_RECIPIENT_ENDPOINT, CLEAR_FEATURE, ENDPOINT_HALT, wIndex, Buffer.from(new Uint8Array()));
      } catch (error2) {
        throw new Error(`clearHalt error: ${error2}`);
      }
    }
    async transferIn(endpointNumber, length) {
      try {
        this.checkDeviceOpen();
        const endpoint2 = this.getEndpoint(endpointNumber | usb.LIBUSB_ENDPOINT_IN);
        const result = await endpoint2.transferAsync(length);
        return {
          data: result ? new DataView(new Uint8Array(result).buffer) : void 0,
          status: "ok"
        };
      } catch (error2) {
        if (error2.errno === usb.LIBUSB_TRANSFER_STALL) {
          return {
            status: "stall"
          };
        }
        if (error2.errno === usb.LIBUSB_TRANSFER_OVERFLOW) {
          return {
            status: "babble"
          };
        }
        throw new Error(`transferIn error: ${error2}`);
      }
    }
    async transferOut(endpointNumber, data2) {
      try {
        this.checkDeviceOpen();
        const endpoint2 = this.getEndpoint(endpointNumber | usb.LIBUSB_ENDPOINT_OUT);
        const buffer = Buffer.from(data2);
        const bytesWritten = await endpoint2.transferAsync(buffer);
        return {
          bytesWritten,
          status: "ok"
        };
      } catch (error2) {
        if (error2.errno === usb.LIBUSB_TRANSFER_STALL) {
          return {
            bytesWritten: 0,
            status: "stall"
          };
        }
        throw new Error(`transferOut error: ${error2}`);
      }
    }
    async reset() {
      try {
        await this.resetAsync();
      } catch (error2) {
        throw new Error(`reset error: ${error2}`);
      }
    }
    async isochronousTransferIn(_endpointNumber, _packetLengths) {
      throw new Error("isochronousTransferIn error: method not implemented");
    }
    async isochronousTransferOut(_endpointNumber, _data, _packetLengths) {
      throw new Error("isochronousTransferOut error: method not implemented");
    }
    async forget() {
      throw new Error("forget error: method not implemented");
    }
    async initialize() {
      try {
        if (!this.opened) {
          this.device.open();
          if (this.deviceClass === 255 && (0, os_1.platform)() === "darwin") {
            await this.setConfigurationAsync(1);
          }
        }
        this.manufacturerName = await this.getStringDescriptor(this.device.deviceDescriptor.iManufacturer);
        this.productName = await this.getStringDescriptor(this.device.deviceDescriptor.iProduct);
        this.serialNumber = await this.getStringDescriptor(this.device.deviceDescriptor.iSerialNumber);
        this.configurations = await this.getConfigurations();
      } catch (error2) {
        throw new Error(`initialize error: ${error2}`);
      } finally {
        if (this.opened) {
          this.device.close();
        }
      }
    }
    decodeVersion(version2) {
      const hex = `0000${version2.toString(16)}`.slice(-4);
      return {
        major: parseInt(hex.substr(0, 2), void 0),
        minor: parseInt(hex.substr(2, 1), void 0),
        sub: parseInt(hex.substr(3, 1), void 0)
      };
    }
    async getStringDescriptor(index) {
      try {
        const buffer = await this.getStringDescriptorAsync(index);
        return buffer ? buffer.toString() : "";
      } catch (error2) {
        return "";
      }
    }
    async getConfigurations() {
      const configs = [];
      for (const config of this.device.allConfigDescriptors) {
        const interfaces = [];
        for (const iface of config.interfaces) {
          const alternates = [];
          for (const alternate2 of iface) {
            const endpoints = [];
            for (const endpoint2 of alternate2.endpoints) {
              endpoints.push({
                endpointNumber: endpoint2.bEndpointAddress & ENDPOINT_NUMBER_MASK,
                direction: endpoint2.bEndpointAddress & usb.LIBUSB_ENDPOINT_IN ? "in" : "out",
                type: (endpoint2.bmAttributes & LIBUSB_TRANSFER_TYPE_MASK) === usb.LIBUSB_TRANSFER_TYPE_BULK ? "bulk" : (endpoint2.bmAttributes & LIBUSB_TRANSFER_TYPE_MASK) === usb.LIBUSB_TRANSFER_TYPE_INTERRUPT ? "interrupt" : "isochronous",
                packetSize: endpoint2.wMaxPacketSize
              });
            }
            alternates.push({
              alternateSetting: alternate2.bAlternateSetting,
              interfaceClass: alternate2.bInterfaceClass,
              interfaceSubclass: alternate2.bInterfaceSubClass,
              interfaceProtocol: alternate2.bInterfaceProtocol,
              interfaceName: await this.getStringDescriptor(alternate2.iInterface),
              endpoints
            });
          }
          const interfaceNumber = iface[0].bInterfaceNumber;
          const alternate = alternates.find((alt) => alt.alternateSetting === this.device.interface(interfaceNumber).altSetting);
          if (alternate) {
            interfaces.push({
              interfaceNumber,
              alternate,
              alternates,
              claimed: false
            });
          }
        }
        configs.push({
          configurationValue: config.bConfigurationValue,
          configurationName: await this.getStringDescriptor(config.iConfiguration),
          interfaces
        });
      }
      return configs;
    }
    getEndpoint(address) {
      if (!this.device.interfaces) {
        return void 0;
      }
      for (const iface of this.device.interfaces) {
        const endpoint2 = iface.endpoint(address);
        if (endpoint2) {
          return endpoint2;
        }
      }
      return void 0;
    }
    controlTransferParamsToType(setup, direction) {
      const recipient = setup.recipient === "device" ? usb.LIBUSB_RECIPIENT_DEVICE : setup.recipient === "interface" ? usb.LIBUSB_RECIPIENT_INTERFACE : setup.recipient === "endpoint" ? usb.LIBUSB_RECIPIENT_ENDPOINT : usb.LIBUSB_RECIPIENT_OTHER;
      const requestType = setup.requestType === "standard" ? usb.LIBUSB_REQUEST_TYPE_STANDARD : setup.requestType === "class" ? usb.LIBUSB_REQUEST_TYPE_CLASS : usb.LIBUSB_REQUEST_TYPE_VENDOR;
      return recipient | requestType | direction;
    }
    async _releaseInterface(interfaceNumber) {
      if (!this.opened) {
        throw new Error("releaseInterface error: invalid state");
      }
      if (!this.configuration) {
        throw new Error("releaseInterface error: interface not found");
      }
      const iface = this.configuration.interfaces.find((usbInterface) => usbInterface.interfaceNumber === interfaceNumber);
      if (!iface) {
        throw new Error("releaseInterface error: interface not found");
      }
      if (!iface.claimed) {
        return;
      }
      try {
        const iface2 = this.device.interface(interfaceNumber);
        await iface2.releaseAsync();
      } catch (error2) {
        throw new Error(`releaseInterface error: ${error2}`);
      }
    }
    checkDeviceOpen() {
      if (!this.opened) {
        throw new Error("The device must be opened first");
      }
    }
  }
  webusbDevice.WebUSBDevice = WebUSBDevice;
  return webusbDevice;
}
var hasRequiredWebusb;
function requireWebusb() {
  if (hasRequiredWebusb) return webusb;
  hasRequiredWebusb = 1;
  Object.defineProperty(webusb, "__esModule", { value: true });
  webusb.WebUSB = webusb.getWebUsb = void 0;
  const usb = requireUsb();
  const events_1 = require$$0$b;
  const webusb_device_1 = requireWebusbDevice();
  const getWebUsb = () => {
    if (navigator && navigator.usb) {
      return navigator.usb;
    }
    return new WebUSB();
  };
  webusb.getWebUsb = getWebUsb;
  class NamedError extends Error {
    constructor(message, name) {
      super(message);
      this.name = name;
    }
  }
  class WebUSB {
    constructor(options = {}) {
      this.options = options;
      this.emitter = new events_1.EventEmitter();
      this.knownDevices = /* @__PURE__ */ new Map();
      this.authorisedDevices = /* @__PURE__ */ new Set();
      const deviceConnectCallback = async (device2) => {
        const webDevice = await this.getWebDevice(device2);
        if (webDevice && this.isAuthorisedDevice(webDevice)) {
          const event = {
            type: "connect",
            device: webDevice
          };
          this.emitter.emit("connect", event);
        }
      };
      const deviceDisconnectCallback = async (device2) => {
        if (this.knownDevices.has(device2)) {
          const webDevice = this.knownDevices.get(device2);
          if (webDevice && this.isAuthorisedDevice(webDevice)) {
            const event = {
              type: "disconnect",
              device: webDevice
            };
            this.emitter.emit("disconnect", event);
          }
        }
      };
      this.emitter.on("newListener", (event) => {
        const listenerCount = this.emitter.listenerCount(event);
        if (listenerCount !== 0) {
          return;
        }
        if (event === "connect") {
          usb.addListener("attach", deviceConnectCallback);
        } else if (event === "disconnect") {
          usb.addListener("detach", deviceDisconnectCallback);
        }
      });
      this.emitter.on("removeListener", (event) => {
        const listenerCount = this.emitter.listenerCount(event);
        if (listenerCount !== 0) {
          return;
        }
        if (event === "connect") {
          usb.removeListener("attach", deviceConnectCallback);
        } else if (event === "disconnect") {
          usb.removeListener("detach", deviceDisconnectCallback);
        }
      });
    }
    set onconnect(fn) {
      if (this._onconnect) {
        this.removeEventListener("connect", this._onconnect);
        this._onconnect = void 0;
      }
      if (fn) {
        this._onconnect = fn;
        this.addEventListener("connect", this._onconnect);
      }
    }
    set ondisconnect(fn) {
      if (this._ondisconnect) {
        this.removeEventListener("disconnect", this._ondisconnect);
        this._ondisconnect = void 0;
      }
      if (fn) {
        this._ondisconnect = fn;
        this.addEventListener("disconnect", this._ondisconnect);
      }
    }
    addEventListener(type2, listener) {
      this.emitter.addListener(type2, listener);
    }
    removeEventListener(type2, callback) {
      this.emitter.removeListener(type2, callback);
    }
    dispatchEvent(_event) {
      return false;
    }
    /**
     * Requests a single Web USB device
     * @param options The options to use when scanning
     * @returns Promise containing the selected device
     */
    async requestDevice(options) {
      if (!options) {
        throw new TypeError("requestDevice error: 1 argument required, but only 0 present");
      }
      if (options.constructor !== {}.constructor) {
        throw new TypeError("requestDevice error: parameter 1 (options) is not an object");
      }
      if (!options.filters) {
        throw new TypeError("requestDevice error: required member filters is undefined");
      }
      if (options.filters.constructor !== [].constructor) {
        throw new TypeError("requestDevice error: the provided value cannot be converted to a sequence");
      }
      options.filters.forEach((filter) => {
        if (filter.protocolCode && !filter.subclassCode) {
          throw new TypeError("requestDevice error: subclass code is required");
        }
        if (filter.subclassCode && !filter.classCode) {
          throw new TypeError("requestDevice error: class code is required");
        }
      });
      let devices = await this.loadDevices(options.filters);
      devices = devices.filter((device2) => this.filterDevice(device2, options.filters));
      if (devices.length === 0) {
        throw new NamedError("Failed to execute 'requestDevice' on 'USB': No device selected.", "NotFoundError");
      }
      try {
        const device2 = this.options.devicesFound ? await this.options.devicesFound(devices) : devices[0];
        if (!device2) {
          throw new NamedError("Failed to execute 'requestDevice' on 'USB': No device selected.", "NotFoundError");
        }
        this.authorisedDevices.add({
          vendorId: device2.vendorId,
          productId: device2.productId,
          classCode: device2.deviceClass,
          subclassCode: device2.deviceSubclass,
          protocolCode: device2.deviceProtocol,
          serialNumber: device2.serialNumber || void 0
        });
        return device2;
      } catch (error2) {
        throw new NamedError("Failed to execute 'requestDevice' on 'USB': No device selected.", "NotFoundError");
      }
    }
    /**
     * Gets all allowed Web USB devices which are connected
     * @returns Promise containing an array of devices
     */
    async getDevices() {
      const preFilters = this.options.allowAllDevices ? void 0 : this.options.allowedDevices;
      const devices = await this.loadDevices(preFilters);
      return devices.filter((device2) => this.isAuthorisedDevice(device2));
    }
    async loadDevices(preFilters) {
      let devices = usb.getDeviceList();
      devices = this.quickFilter(devices, preFilters);
      const refreshedKnownDevices = /* @__PURE__ */ new Map();
      for (const device2 of devices) {
        const webDevice = await this.getWebDevice(device2);
        if (webDevice) {
          refreshedKnownDevices.set(device2, webDevice);
        }
      }
      this.knownDevices = refreshedKnownDevices;
      return [...this.knownDevices.values()];
    }
    // Get a WebUSBDevice corresponding to underlying device.
    // Returns undefined the device was not found and could not be created.
    async getWebDevice(device2) {
      if (!this.knownDevices.has(device2)) {
        if (this.options.deviceTimeout) {
          device2.timeout = this.options.deviceTimeout;
        }
        try {
          const webDevice = await webusb_device_1.WebUSBDevice.createInstance(device2, this.options.autoDetachKernelDriver);
          this.knownDevices.set(device2, webDevice);
        } catch {
        }
      }
      return this.knownDevices.get(device2);
    }
    // Undertake quick filter on devices before creating WebUSB devices if possible
    quickFilter(devices, preFilters) {
      if (!preFilters || !preFilters.length) {
        return devices;
      }
      return devices.filter((device2) => preFilters.some((filter) => {
        if (filter.vendorId && filter.vendorId !== device2.deviceDescriptor.idVendor)
          return false;
        if (filter.productId && filter.productId !== device2.deviceDescriptor.idProduct)
          return false;
        return true;
      }));
    }
    // Filter WebUSB devices
    filterDevice(device2, filters) {
      if (!filters || !filters.length) {
        return true;
      }
      return filters.some((filter) => {
        if (filter.vendorId && filter.vendorId !== device2.vendorId)
          return false;
        if (filter.productId && filter.productId !== device2.productId)
          return false;
        if (filter.classCode) {
          if (!device2.configuration) {
            return false;
          }
          const match = device2.configuration.interfaces.some((iface) => {
            if (filter.classCode && filter.classCode !== iface.alternate.interfaceClass)
              return false;
            if (filter.subclassCode && filter.subclassCode !== iface.alternate.interfaceSubclass)
              return false;
            if (filter.protocolCode && filter.protocolCode !== iface.alternate.interfaceProtocol)
              return false;
            return true;
          });
          if (match) {
            return true;
          }
        }
        if (filter.classCode && filter.classCode !== device2.deviceClass)
          return false;
        if (filter.subclassCode && filter.subclassCode !== device2.deviceSubclass)
          return false;
        if (filter.protocolCode && filter.protocolCode !== device2.deviceProtocol)
          return false;
        if (filter.serialNumber && filter.serialNumber !== device2.serialNumber)
          return false;
        return true;
      });
    }
    // Check whether a device is authorised
    isAuthorisedDevice(device2) {
      if (this.options.allowAllDevices) {
        return true;
      }
      if (this.options.allowedDevices && this.filterDevice(device2, this.options.allowedDevices)) {
        return true;
      }
      return [...this.authorisedDevices.values()].some((authorised) => authorised.vendorId === device2.vendorId && authorised.productId === device2.productId && authorised.classCode === device2.deviceClass && authorised.subclassCode === device2.deviceSubclass && authorised.protocolCode === device2.deviceProtocol && authorised.serialNumber === device2.serialNumber);
    }
  }
  webusb.WebUSB = WebUSB;
  return webusb;
}
var descriptors = {};
var hasRequiredDescriptors;
function requireDescriptors() {
  if (hasRequiredDescriptors) return descriptors;
  hasRequiredDescriptors = 1;
  Object.defineProperty(descriptors, "__esModule", { value: true });
  return descriptors;
}
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;
  (function(exports$1) {
    var __createBinding = dist && dist.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = dist && dist.__exportStar || function(m, exports$12) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$12, p)) __createBinding(exports$12, m, p);
    };
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.LibUSBException = exports$1.useUsbDkBackend = exports$1.getDeviceList = exports$1.Transfer = exports$1.Device = exports$1.webusb = exports$1.findBySerialNumber = exports$1.findByIds = exports$1.usb = void 0;
    const util_1 = require$$0$5;
    const webusb_1 = requireWebusb();
    const usb = requireUsb();
    exports$1.usb = usb;
    const findByIds = (vid, pid) => {
      const devices = usb.getDeviceList();
      return devices.find((item) => item.deviceDescriptor.idVendor === vid && item.deviceDescriptor.idProduct === pid);
    };
    exports$1.findByIds = findByIds;
    const findBySerialNumber = async (serialNumber) => {
      const devices = usb.getDeviceList();
      const opened = (device2) => !!device2.interfaces;
      for (const device2 of devices) {
        try {
          if (!opened(device2)) {
            device2.open();
          }
          const getStringDescriptor = (0, util_1.promisify)(device2.getStringDescriptor).bind(device2);
          const buffer = await getStringDescriptor(device2.deviceDescriptor.iSerialNumber);
          if (buffer && buffer.toString() === serialNumber) {
            return device2;
          }
        } catch {
        } finally {
          try {
            if (opened(device2)) {
              device2.close();
            }
          } catch {
          }
        }
      }
      return void 0;
    };
    exports$1.findBySerialNumber = findBySerialNumber;
    const webusb2 = new webusb_1.WebUSB();
    exports$1.webusb = webusb2;
    var usb_12 = requireUsb();
    Object.defineProperty(exports$1, "Device", { enumerable: true, get: function() {
      return usb_12.Device;
    } });
    Object.defineProperty(exports$1, "Transfer", { enumerable: true, get: function() {
      return usb_12.Transfer;
    } });
    Object.defineProperty(exports$1, "getDeviceList", { enumerable: true, get: function() {
      return usb_12.getDeviceList;
    } });
    Object.defineProperty(exports$1, "useUsbDkBackend", { enumerable: true, get: function() {
      return usb_12.useUsbDkBackend;
    } });
    Object.defineProperty(exports$1, "LibUSBException", { enumerable: true, get: function() {
      return usb_12.LibUSBException;
    } });
    __exportStar(requireCapability(), exports$1);
    __exportStar(requireDescriptors(), exports$1);
    __exportStar(requireEndpoint(), exports$1);
    __exportStar(require_interface(), exports$1);
    __exportStar(requireWebusb(), exports$1);
    __exportStar(requireWebusbDevice(), exports$1);
  })(dist);
  return dist;
}
var escposUsb;
var hasRequiredEscposUsb;
function requireEscposUsb() {
  if (hasRequiredEscposUsb) return escposUsb;
  hasRequiredEscposUsb = 1;
  const os = require$$2$3;
  const util2 = require$$0$5;
  const EventEmitter = require$$0$b;
  let usb = null;
  const IFACE_CLASS = {
    AUDIO: 1,
    HID: 3,
    PRINTER: 7,
    HUB: 9
  };
  function USB2(vid, pid) {
    if (!usb) {
      usb = requireDist();
    }
    EventEmitter.call(this);
    var self2 = this;
    this.device = null;
    if (vid && pid) {
      this.device = usb.findByIds(vid, pid);
    } else if (vid) {
      this.device = vid;
    } else {
      var devices = USB2.findPrinter();
      if (devices && devices.length)
        this.device = devices[0];
    }
    if (!this.device)
      throw new Error("Can not find printer");
    usb.on("detach", function(device2) {
      if (device2 == self2.device) {
        self2.emit("detach", device2);
        self2.emit("disconnect", device2);
        self2.device = null;
      }
    });
    return this;
  }
  USB2.findPrinter = function() {
    if (!usb) {
      usb = requireDist();
    }
    return usb.getDeviceList().filter(function(device2) {
      try {
        return device2.configDescriptor.interfaces.filter(function(iface) {
          return iface.filter(function(conf) {
            return conf.bInterfaceClass === IFACE_CLASS.PRINTER;
          }).length;
        }).length;
      } catch (e) {
        return false;
      }
    });
  };
  USB2.getDevice = function(vid, pid) {
    return new Promise((resolve, reject) => {
      const device2 = new USB2(vid, pid);
      device2.open((err) => {
        if (err) return reject(err);
        resolve(device2);
      });
    });
  };
  util2.inherits(USB2, EventEmitter);
  USB2.prototype.open = function(callback) {
    let self2 = this, counter = 0;
    this.device.open();
    this.device.interfaces.forEach(function(iface) {
      (function(iface2) {
        iface2.setAltSetting(iface2.altSetting, function() {
          try {
            if ("win32" !== os.platform()) {
              if (iface2.isKernelDriverActive()) {
                try {
                  iface2.detachKernelDriver();
                } catch (e) {
                  console.error("[ERROR] Could not detatch kernel driver: %s", e);
                }
              }
            }
            iface2.claim();
            iface2.endpoints.filter(function(endpoint2) {
              if (endpoint2.direction == "out" && !self2.endpoint) {
                self2.endpoint = endpoint2;
              }
            });
            if (self2.endpoint) {
              self2.emit("connect", self2.device);
              callback && callback(null, self2);
            } else if (++counter === this.device.interfaces.length && !self2.endpoint) {
              callback && callback(new Error("Can not find endpoint from printer"));
            }
          } catch (e) {
            callback && callback(e);
          }
        });
      })(iface);
    });
    return this;
  };
  USB2.prototype.write = function(data2, callback) {
    this.emit("data", data2);
    this.endpoint.transfer(data2, callback);
    return this;
  };
  USB2.prototype.close = function(callback) {
    if (this.device) {
      try {
        this.device.close();
        usb.removeAllListeners("detach");
        callback && callback(null);
        this.emit("close", this.device);
      } catch (e) {
        callback && callback(e);
      }
    } else {
      callback && callback(null);
    }
    return this;
  };
  escposUsb = USB2;
  return escposUsb;
}
var escposUsbExports = requireEscposUsb();
const USB = /* @__PURE__ */ getDefaultExportFromCjs(escposUsbExports);
var $$ = null;
var $j = 0;
var $k = [];
var $_ = {};
const $abs = Math.abs;
const $ceil = Math.ceil;
const $floor = Math.floor;
const $log = Math.log;
const $pow = Math.pow;
const $round = Math.round;
const $sqrt = Math.sqrt;
function $a(a) {
  if (!arguments.length) {
    for (var i = $j - 1; i >= 0 && $k[i] !== Infinity; i--) ;
    if (i < 0) {
      throw new Error("array-marker-not-found");
    }
    a = $k.splice(i + 1, $j - 1 - i);
    $j = i;
  } else if (!(a instanceof Array)) {
    a = new Array(+arguments[0]);
    for (var i = 0, l = a.length; i < l; i++) {
      a[i] = null;
    }
  }
  a.b = a;
  a.o = 0;
  return a;
}
function $d() {
  for (var mark = $j - 1; mark >= 0 && $k[mark] !== Infinity; mark -= 2) {
    if ($k[mark - 1] === Infinity) {
      throw new Error("dict-malformed-stack");
    }
  }
  if (mark < 0) {
    throw new Error("dict-marker-not-found");
  }
  var d = /* @__PURE__ */ new Map();
  for (var i = mark + 1; i < $j; i += 2) {
    var k = $k[i];
    var t = typeof k;
    if (t == "number" || t == "string") {
      d.set(k, $k[i + 1]);
    } else if (k instanceof Uint8Array) {
      d.set($z(k), $k[i + 1]);
    } else {
      throw new Error("dict-not-a-valid-key(" + k + ")");
    }
  }
  $j = mark;
  return d;
}
function $s(v) {
  var t = typeof v;
  if (t === "number") {
    return new Uint8Array(v);
  }
  if (t !== "string") {
    v = "" + v;
  }
  var s = new Uint8Array(v.length);
  for (var i = 0, l = v.length; i < l; i++) {
    s[i] = v.charCodeAt(i);
  }
  return s;
}
function $r(n, c) {
  if ($j < n) {
    throw new Error("roll: --stack-underflow--");
  }
  if (!c) {
    return;
  }
  if (c < 0) {
    var t = $k.splice($j - n, -c);
  } else {
    var t = $k.splice($j - n, n - c);
  }
  $k.splice.apply($k, [$j - t.length, 0].concat(t));
}
function $z(s) {
  if (s instanceof Uint8Array) {
    return String.fromCharCode.apply(null, s);
  }
  return "" + s;
}
function $strcpy(dst, src) {
  if (typeof dst === "string") {
    dst = $s(dst);
  }
  if (src instanceof Uint8Array) {
    for (var i = 0, l = src.length; i < l; i++) {
      dst[i] = src[i];
    }
  } else {
    for (var i = 0, l = src.length; i < l; i++) {
      dst[i] = src.charCodeAt(i);
    }
  }
  return src.length < dst.length ? dst.subarray(0, src.length) : dst;
}
function $arrcpy(dst, src) {
  for (var i = 0, l = src.length; i < l; i++) {
    dst[i] = src[i];
  }
  dst.length = src.length;
  return dst;
}
function $cvi(s) {
  if (s instanceof Uint8Array) {
    return $floor(String.fromCharCode.apply(null, s).replace(/\0+$/, ""));
  }
  return $floor("" + s);
}
function $cvrs(s, n, r) {
  return $strcpy(s, (~~n).toString(r).toUpperCase());
}
function $get(s, k) {
  if (s instanceof Uint8Array) {
    return s[k];
  }
  if (typeof s === "string") {
    return s.charCodeAt(k);
  }
  if (s instanceof Array) {
    return s.b[s.o + k];
  }
  if (k instanceof Uint8Array) {
    k = $z(k);
  }
  if (s instanceof Map) {
    return s.get(k);
  }
  return s[k];
}
function $put(d, k, v) {
  if (d instanceof Uint8Array) {
    d[k] = v;
  } else if (d instanceof Array) {
    d.b[d.o + k] = v;
  } else if (typeof d == "object") {
    if (k instanceof Uint8Array) {
      d.set($z(k), v);
    } else {
      d.set(k, v);
    }
  } else {
    throw new Error("put-not-writable-" + typeof d);
  }
}
function $geti(s, o, l) {
  if (s instanceof Uint8Array) {
    return s.subarray(o, o + l);
  }
  if (s instanceof Array) {
    var a = new Array(l);
    a.b = s.b;
    a.o = s.o + o;
    return a;
  }
  return s.substr(o, l);
}
function $puti(d, o, s) {
  if (d instanceof Uint8Array) {
    if (typeof s == "string") {
      for (var i = 0, l = s.length; i < l; i++) {
        d[o + i] = s.charCodeAt(i);
      }
    } else {
      for (var i = s.length - 1; i >= 0; i--) {
        d[o + i] = s[i];
      }
    }
  } else if (d instanceof Array) {
    var darr = d.b;
    var doff = o + d.o;
    var sarr = s.b;
    var soff = s.o;
    for (var i = 0, l = s.length; i < l; i++) {
      darr[doff + i] = sarr[soff + i];
    }
  } else {
    throw new Error("putinterval-not-writable-" + typeof d);
  }
}
function $type(v) {
  if (v == null) {
    return "nulltype";
  }
  var t = typeof v;
  if (t == "number") {
    return v % 1 ? "realtype" : "integertype";
  }
  if (t == "boolean") {
    return "booleantype";
  }
  if (t == "string" || v instanceof Uint8Array) {
    return "stringtype";
  }
  if (t == "function") {
    return "operatortype";
  }
  if (v instanceof Array) {
    return "arraytype";
  }
  return "dicttype";
}
function $anchorsearch(str, seek) {
  if (!(str instanceof Uint8Array)) {
    str = $s(str);
  }
  var i = 0, ls = str.length, lk = seek.length;
  if (lk == 1) {
    var cd = seek instanceof Uint8Array ? seek[0] : seek.charCodeAt(0);
    i = str[0] == cd ? 1 : ls;
  } else if (seek.length <= ls) {
    if (!(seek instanceof Uint8Array)) {
      seek = $s(seek);
    }
    for (; i < lk && str[i] == seek[i]; i++) ;
  }
  if (i == lk) {
    $k[$j++] = str.subarray(lk);
    $k[$j++] = str.subarray(0, lk);
    $k[$j++] = true;
  } else {
    $k[$j++] = str;
    $k[$j++] = false;
  }
}
function $search(str, seek) {
  if (!(str instanceof Uint8Array)) {
    str = $s(str);
  }
  var ls = str.length;
  if (seek.length == 1) {
    var lk = 1;
    var cd = seek instanceof Uint8Array ? seek[0] : seek.charCodeAt(0);
    for (var i = 0; i < ls && str[i] != cd; i++) ;
  } else {
    if (!(seek instanceof Uint8Array)) {
      seek = $s(seek);
    }
    var lk = seek.length;
    var cd = seek[0];
    for (var i = 0; i < ls && str[i] != cd; i++) ;
    while (i < ls) {
      for (var j = 1; j < lk && str[i + j] === seek[j]; j++) ;
      if (j === lk) {
        break;
      }
      for (i++; i < ls && str[i] != cd; i++) ;
    }
  }
  if (i < ls) {
    $k[$j++] = str.subarray(i + lk);
    $k[$j++] = str.subarray(i, i + lk);
    $k[$j++] = str.subarray(0, i);
    $k[$j++] = true;
  } else {
    $k[$j++] = str;
    $k[$j++] = false;
  }
}
function $forall(o, cb) {
  if (o instanceof Uint8Array) {
    for (var i = 0, l = o.length; i < l; i++) {
      $k[$j++] = o[i];
      if (cb && cb()) break;
    }
  } else if (o instanceof Array) {
    for (var a = o.b, i = o.o, l = o.o + o.length; i < l; i++) {
      $k[$j++] = a[i];
      if (cb && cb()) break;
    }
  } else if (typeof o === "string") {
    for (var i = 0, l = o.length; i < l; i++) {
      $k[$j++] = o.charCodeAt(i);
      if (cb && cb()) break;
    }
  } else if (o instanceof Map) {
    for (var keys = o.keys(), i = 0, l = o.size; i < l; i++) {
      var id = keys.next().value;
      $k[$j++] = id;
      $k[$j++] = o.get(id);
      if (cb && cb()) break;
    }
  } else {
    for (var id in o) {
      $k[$j++] = id;
      $k[$j++] = o[id];
      if (cb && cb()) break;
    }
  }
}
function $cleartomark() {
  while ($j > 0 && $k[--$j] !== Infinity) ;
}
function $counttomark() {
  for (var i = $j - 1; i >= 0 && $k[i] !== Infinity; i--) ;
  return $j - i - 1;
}
function $aload(a) {
  for (var i = 0, l = a.length, b = a.b, o = a.o; i < l; i++) {
    $k[$j++] = b[o + i];
  }
}
function $astore(a) {
  for (var i = 0, l = a.length, b = a.b, o = a.o + l - 1; i < l; i++) {
    b[o - i] = $k[--$j];
  }
  $k[$j++] = a;
}
function $eq(a, b) {
  if (typeof a === "string" && typeof b === "string") {
    return a == b;
  }
  if (a instanceof Uint8Array && b instanceof Uint8Array) {
    if (a.length != b.length) {
      return false;
    }
    for (var i = 0, l = a.length; i < l; i++) {
      if (a[i] != b[i]) {
        return false;
      }
    }
    return true;
  }
  if (a instanceof Uint8Array && typeof b === "string" || b instanceof Uint8Array && typeof a === "string") {
    if (a instanceof Uint8Array) {
      a = $z(a);
    } else {
      b = $z(b);
    }
    return a == b;
  }
  return a == b;
}
function $ne(a, b) {
  return !$eq(a, b);
}
function $lt(a, b) {
  if (a instanceof Uint8Array) {
    a = $z(a);
  }
  if (b instanceof Uint8Array) {
    b = $z(b);
  }
  return a < b;
}
function $le(a, b) {
  if (a instanceof Uint8Array) {
    a = $z(a);
  }
  if (b instanceof Uint8Array) {
    b = $z(b);
  }
  return a <= b;
}
function $gt(a, b) {
  if (a instanceof Uint8Array) {
    a = $z(a);
  }
  if (b instanceof Uint8Array) {
    b = $z(b);
  }
  return a > b;
}
function $ge(a, b) {
  if (a instanceof Uint8Array) {
    a = $z(a);
  }
  if (b instanceof Uint8Array) {
    b = $z(b);
  }
  return a >= b;
}
function $an(a, b) {
  return typeof a === "boolean" ? a && b : a & b;
}
function $or(a, b) {
  return typeof a === "boolean" ? a || b : a | b;
}
function $xo(a, b) {
  return typeof a === "boolean" ? a != b : a ^ b;
}
var $f = /* @__PURE__ */ (function(fa) {
  return (v) => {
    return (v | 0) == v ? v : (fa[0] = v, fa[0]);
  };
})(new Float32Array(1));
function bwipp_raiseerror() {
  var info = $k[--$j];
  var name = $k[--$j];
  if (typeof info == "string" || info instanceof Uint8Array) {
    throw new Error($z(name) + ": " + $z(info));
  } else {
    $k[$j++] = info;
    throw $z(name) + "\nAdditional information: " + tostring(info);
  }
  function tostring(v) {
    if (v instanceof Array) {
      let s = "";
      for (let i = v.o, l = v.o + v.length; i < l; i++) {
        s += " " + tostring(v.b[i]);
      }
      return "[" + s.substr(1) + "]";
    } else if (v instanceof Uint8Array) {
      return String.fromCharCode.apply(String, v);
    } else if (v instanceof Map) {
      let s = "";
      for (const [key2, val] of v) {
        s += " " + tostring(key2) + " " + tostring(val);
      }
      return "<<" + s.substr(1) + ">>";
    } else if (v && typeof v == "object") {
      let s = "";
      for (let id in v) {
        s += " " + tostring(id) + " " + tostring(v[id]);
      }
      return "<<" + s.substr(1) + ">>";
    } else {
      return "" + v;
    }
  }
}
function bwipp_processoptions() {
  var dict = $k[--$j];
  var opts = $k[$j - 1];
  if (opts instanceof Uint8Array) {
    opts = $z(opts);
  }
  if (typeof opts == "string") {
    let vals = opts.trim().split(/ +/g);
    $k[$j - 1] = opts = /* @__PURE__ */ new Map();
    for (let i = 0; i < vals.length; i++) {
      let pair = vals[i].split("=");
      if (pair.length == 1) {
        opts.set(pair[0], true);
      } else {
        opts.set(pair[0], pair[1]);
      }
    }
  }
  for (var id in dict) {
    var val;
    if (!opts.has(id)) {
      continue;
    }
    val = opts.get(id);
    var def = dict[id];
    var typ = typeof def;
    if (def == null || typ == "number") {
      if (!isFinite(+val)) {
        throw new Error("bwipp.invalidOptionType: " + id + ": not a realtype: " + val);
      }
      if (typeof val == "string") {
        val = +val;
        opts.set(id, val);
      }
    } else if (typ == "boolean") {
      if (val !== true && val !== false) {
        if (val == null || (val | 0) === val) {
          val = !!val;
        } else if (val == "true") {
          val = true;
        } else if (val == "false") {
          val = false;
        } else {
          throw new Error("bwipp.invalidOptionType: " + id + ": not a booleantype: " + val);
        }
        opts.set(id, val);
      }
    } else if (typ == "string" || def instanceof Uint8Array) {
      if (typeof val == "number") {
        val = "" + val;
        opts.set(id, val);
      } else if ((id === "extratext" || id === "alttext") && typeof val === "string") {
        val = $s(val);
        opts.set(id, val);
      } else if (typeof val != "string" && !(val instanceof Uint8Array)) {
        throw new Error("bwipp.invalidOptionType: " + id + ": not a stringtype: " + val);
      }
    }
    dict[id] = val;
  }
}
function bwipp_parseinput() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.fncvals = $k[--$j];
  $_.barcode = $k[--$j];
  var _2 = "parse";
  $_[_2] = $get($_.fncvals, _2);
  delete $_.fncvals[_2];
  var _6 = "parsefnc";
  $_[_6] = $get($_.fncvals, _6);
  delete $_.fncvals[_6];
  var _A = "parseonly";
  var _C = $get($_.fncvals, _A) !== void 0;
  $_[_A] = _C;
  delete $_.fncvals[_A];
  var _E = "eci";
  var _G = $get($_.fncvals, _E) !== void 0;
  $_[_E] = _G;
  delete $_.fncvals[_E];
  $k[$j++] = Infinity;
  var _I = $a(["NUL", "SOH", "STX", "ETX", "EOT", "ENQ", "ACK", "BEL", "BS", "TAB", "LF", "VT", "FF", "CR", "", "", "DLE", "DC1", "DC2", "DC3", "DC4", "NAK", "SYN", "ETB", "CAN", "EM", "SUB", "ESC", "FS", "GS", "RS", "US"]);
  $k[$j++] = 0;
  for (var _J = 0, _K = _I.length; _J < _K; _J++) {
    var _M = $k[--$j];
    $k[$j++] = $get(_I, _J);
    $k[$j++] = _M;
    $k[$j++] = _M + 1;
  }
  $j--;
  $_.ctrl = $d();
  $_.msg = $a($_.barcode.length);
  $_.j = 0;
  $k[$j++] = $_.barcode;
  for (; ; ) {
    $search($k[--$j], "^");
    var _T = $k[--$j];
    var _U = $k[--$j];
    $k[$j++] = _T;
    $k[$j++] = _U.length;
    $k[$j++] = $_.msg;
    $k[$j++] = $_.j;
    var _X = Infinity;
    var _Y = _U;
    $k[$j++] = _X;
    $forall(_Y);
    var _Z = $a();
    var _a = $k[--$j];
    $puti($k[--$j], _a, _Z);
    $_.j = $f($k[--$j] + $_.j);
    if ($k[--$j]) {
      $j--;
      for (var _f = 0; _f < 1; _f++) {
        if (!$_.parse && !$_.parsefnc) {
          $put($_.msg, $_.j, 94);
          $_.j = $_.j + 1;
          break;
        }
        $put($_.msg, $_.j, 94);
        $_.j = $_.j + 1;
        if ($_.parse) {
          var _p = $k[$j - 1];
          if (_p.length >= 3) {
            var _q = $k[$j - 1];
            var _r = $geti(_q, 0, 3);
            var _s = $_.ctrl;
            var _t = $get(_s, _r) !== void 0;
            $k[$j++] = _s;
            $k[$j++] = _r;
            if (_t) {
              $_.j = $_.j - 1;
              var _v = $k[--$j];
              $put($_.msg, $_.j, $get($k[--$j], _v));
              $_.j = $_.j + 1;
              var _11 = $k[--$j];
              $k[$j++] = $geti(_11, 3, _11.length - 3);
              break;
            } else {
              $j -= 2;
            }
          }
          var _13 = $k[$j - 1];
          if (_13.length >= 2) {
            var _14 = $k[$j - 1];
            var _15 = $geti(_14, 0, 2);
            var _16 = $_.ctrl;
            var _17 = $get(_16, _15) !== void 0;
            $k[$j++] = _16;
            $k[$j++] = _15;
            if (_17) {
              $_.j = $_.j - 1;
              var _19 = $k[--$j];
              $put($_.msg, $_.j, $get($k[--$j], _19));
              $_.j = $_.j + 1;
              var _1F = $k[--$j];
              $k[$j++] = $geti(_1F, 2, _1F.length - 2);
              break;
            } else {
              $j -= 2;
            }
          }
          var _1H = $k[$j - 1];
          if (_1H.length >= 3) {
            var _1I = $k[$j - 1];
            var _1J = $geti(_1I, 0, 3);
            $k[$j++] = true;
            for (var _1K = 0, _1L = _1J.length; _1K < _1L; _1K++) {
              var _1M = $get(_1J, _1K);
              if (_1M < 48 || _1M > 57) {
                $k[$j - 1] = false;
              }
            }
            if ($k[--$j]) {
              var _1O = $k[$j - 1];
              var _1Q = $cvi($geti(_1O, 0, 3));
              $k[$j++] = _1Q;
              if (_1Q > 255) {
                $j -= 2;
                $k[$j++] = "bwipp.invalidOrdinal#282";
                $k[$j++] = "Ordinal must be 000 to 255";
                bwipp_raiseerror();
              }
              $_.j = $_.j - 1;
              $put($_.msg, $_.j, $k[--$j]);
              $_.j = $_.j + 1;
              var _1W = $k[--$j];
              $k[$j++] = $geti(_1W, 3, _1W.length - 3);
            }
          }
        }
        if ($_.parseonly || !$_.parsefnc || $get($_.msg, $_.j - 1) != 94) {
          break;
        }
        $_.j = $_.j - 1;
        var _1e = $k[$j - 1];
        if (_1e.length < 1) {
          $j--;
          $k[$j++] = "bwipp.truncatedCaret#301";
          $k[$j++] = "Caret character truncated";
          bwipp_raiseerror();
        }
        var _1f = $k[$j - 1];
        if ($get(_1f, 0) == 94) {
          $put($_.msg, $_.j, 94);
          $_.j = $_.j + 1;
          var _1k = $k[--$j];
          $k[$j++] = $geti(_1k, 1, _1k.length - 1);
          break;
        }
        var _1m = $k[$j - 1];
        if (_1m.length < 3) {
          $j--;
          $k[$j++] = "bwipp.truncatedFNC#311";
          $k[$j++] = "Function character truncated";
          bwipp_raiseerror();
        }
        var _1n = $k[$j - 1];
        if ($eq($geti(_1n, 0, 3), "ECI") && $_.eci) {
          var _1q = $k[$j - 1];
          if (_1q.length < 9) {
            $j--;
            $k[$j++] = "bwipp.truncatedECI#316";
            $k[$j++] = "ECI truncated";
            bwipp_raiseerror();
          }
          var _1r = $k[$j - 1];
          var _1s = $geti(_1r, 3, 6);
          $k[$j++] = _1s;
          for (var _1t = 0, _1u = _1s.length; _1t < _1u; _1t++) {
            var _1v = $get(_1s, _1t);
            if (_1v < 48 || _1v > 57) {
              $j -= 2;
              $k[$j++] = "bwipp.invalidECI#322";
              $k[$j++] = "ECI must be 000000 to 999999";
              bwipp_raiseerror();
            }
          }
          var _1w = $k[--$j];
          $k[$j++] = 0;
          $forall(_1w, function() {
            var _1x = $k[--$j];
            var _1y = $k[--$j];
            $k[$j++] = $f(_1y - (_1x - 48)) * 10;
          });
          $put($_.msg, $_.j, ~~($k[--$j] / 10) - 1e6);
          $_.j = $_.j + 1;
          var _23 = $k[--$j];
          $k[$j++] = $geti(_23, 9, _23.length - 9);
          break;
        }
        var _25 = $k[$j - 1];
        if (_25.length < 4) {
          $j--;
          $k[$j++] = "bwipp.truncatedFNC#333";
          $k[$j++] = "Function character truncated";
          bwipp_raiseerror();
        }
        var _26 = $k[$j - 1];
        var _27 = $geti(_26, 0, 4);
        var _29 = $get($_.fncvals, _27) !== void 0;
        $k[$j++] = _27;
        if (!_29) {
          var _2A = $k[--$j];
          var _2B = $s(_2A.length + 28);
          $puti(_2B, 28, _2A);
          $puti(_2B, 0, "Unknown function character: ");
          $k[$j - 1] = _2B;
          var _2D = $k[--$j];
          $k[$j++] = "bwipp.unknownFNC#339";
          $k[$j++] = _2D;
          bwipp_raiseerror();
        }
        $put($_.msg, $_.j, $get($_.fncvals, $k[--$j]));
        $_.j = $_.j + 1;
        var _2K = $k[--$j];
        $k[$j++] = $geti(_2K, 4, _2K.length - 4);
        break;
      }
    } else {
      break;
    }
  }
  if (!$_.parseonly) {
    $k[$j++] = $geti($_.msg, 0, $_.j);
  } else {
    $k[$j++] = $s($_.j);
    for (var _2U = 0, _2T = $_.j - 1; _2U <= _2T; _2U += 1) {
      var _2V = $k[$j - 1];
      $put(_2V, _2U, $get($_.msg, _2U));
    }
  }
  $_ = $__;
}
function bwipp_gs1process() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  var _1 = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 18],
    ["max", 18],
    ["opt", false],
    ["linters", $a(["lintcsum", "lintgcppos2"])]
  ]);
  var _2 = $a([_1]);
  var _3 = $a([]);
  var _4 = /* @__PURE__ */ new Map([
    ["parts", _2],
    ["dlpkey", _3]
  ]);
  var _5 = $a(["lintcsum", "lintgcppos2"]);
  var _6 = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 14],
    ["max", 14],
    ["opt", false],
    ["linters", _5]
  ]);
  var _7 = $a([_6]);
  var _8 = $a(["255", "37"]);
  var _9 = $a(["22", "10", "21"]);
  var _A = $a(["235"]);
  var _B = $a([_9, _A]);
  var _C = /* @__PURE__ */ new Map([
    ["parts", _7],
    ["ex", _8],
    ["dlpkey", _B]
  ]);
  var _D = $a(["lintcsum", "lintgcppos2"]);
  var _E = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 14],
    ["max", 14],
    ["opt", false],
    ["linters", _D]
  ]);
  var _F = $a([_E]);
  var _G = $a(["01", "03"]);
  var _H = $a(["37"]);
  var _I = $a([_H]);
  var _J = $a([_I]);
  var _K = /* @__PURE__ */ new Map([
    ["parts", _F],
    ["ex", _G],
    ["req", _J]
  ]);
  var _L = $a(["lintcsum", "lintgcppos2"]);
  var _M = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 14],
    ["max", 14],
    ["opt", false],
    ["linters", _L]
  ]);
  var _N = $a([_M]);
  var _O = $a(["01", "02", "37"]);
  var _P = /* @__PURE__ */ new Map([
    ["parts", _N],
    ["ex", _O],
    ["dlattr", false]
  ]);
  var _R = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 20],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _a = /* @__PURE__ */ new Map([
    ["parts", $a([_R])],
    ["req", $a([$a([$a(["01"]), $a(["02"]), $a(["03"]), $a(["8006"]), $a(["8026"])])])]
  ]);
  var _c = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a(["lintyymmd0"])]
  ]);
  var _l = /* @__PURE__ */ new Map([
    ["parts", $a([_c])],
    ["req", $a([$a([$a(["01"]), $a(["02"]), $a(["03"]), $a(["8006"]), $a(["8026"])])])]
  ]);
  var _n = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a(["lintyymmd0"])]
  ]);
  var _r = $a([$a([$a(["8020"])])]);
  var _s = /* @__PURE__ */ new Map([
    ["parts", $a([_n])],
    ["req", _r]
  ]);
  var _u = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a(["lintyymmd0"])]
  ]);
  var _13 = /* @__PURE__ */ new Map([
    ["parts", $a([_u])],
    ["req", $a([$a([$a(["01"]), $a(["02"]), $a(["03"]), $a(["8006"]), $a(["8026"])])])]
  ]);
  var _15 = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a(["lintyymmd0"])]
  ]);
  var _1F = /* @__PURE__ */ new Map([
    ["parts", $a([_15])],
    ["req", $a([$a([$a(["01"]), $a(["02"]), $a(["03"]), $a(["255"]), $a(["8006"]), $a(["8026"])])])]
  ]);
  var _1H = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 2],
    ["max", 2],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _1P = /* @__PURE__ */ new Map([
    ["parts", $a([_1H])],
    ["req", $a([$a([$a(["01"]), $a(["02"]), $a(["8006"]), $a(["8026"])])])]
  ]);
  var _1R = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 20],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _1Z = /* @__PURE__ */ new Map([
    ["parts", $a([_1R])],
    ["ex", $a(["235"])],
    ["req", $a([$a([$a(["01"]), $a(["03"]), $a(["8006"])])])],
    ["dlattr", false]
  ]);
  var _1b = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 20],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _1g = /* @__PURE__ */ new Map([
    ["parts", $a([_1b])],
    ["req", $a([$a([$a(["01"])])])],
    ["dlattr", false]
  ]);
  var _1i = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 28],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _1n = /* @__PURE__ */ new Map([
    ["parts", $a([_1i])],
    ["req", $a([$a([$a(["01"])])])],
    ["dlattr", false]
  ]);
  var _1p = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 30],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _1x = /* @__PURE__ */ new Map([
    ["parts", $a([_1p])],
    ["req", $a([$a([$a(["01"]), $a(["02"]), $a(["8006"]), $a(["8026"])])])]
  ]);
  var _1z = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 1],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _27 = /* @__PURE__ */ new Map([
    ["parts", $a([_1z])],
    ["req", $a([$a([$a(["01"]), $a(["02"]), $a(["8006"]), $a(["8026"])])])]
  ]);
  var _29 = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 20],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _2E = /* @__PURE__ */ new Map([
    ["parts", $a([_29])],
    ["req", $a([$a([$a(["01"])])])]
  ]);
  var _2G = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 30],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _2O = /* @__PURE__ */ new Map([
    ["parts", $a([_2G])],
    ["req", $a([$a([$a(["01"]), $a(["8006"])]), $a([$a(["21"])])])]
  ]);
  var _2Q = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 30],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _2W = /* @__PURE__ */ new Map([
    ["parts", $a([_2Q])],
    ["req", $a([$a([$a(["01"]), $a(["8006"])])])]
  ]);
  var _2Y = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 13],
    ["max", 13],
    ["opt", false],
    ["linters", $a(["lintcsum", "lintgcppos1"])]
  ]);
  var _2a = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 17],
    ["opt", true],
    ["linters", $a([])]
  ]);
  var _2d = /* @__PURE__ */ new Map([
    ["parts", $a([_2Y, _2a])],
    ["dlpkey", $a([])]
  ]);
  var _2f = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 20],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _2k = /* @__PURE__ */ new Map([
    ["parts", $a([_2f])],
    ["req", $a([$a([$a(["414"])])])],
    ["dlattr", false]
  ]);
  var _2m = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 13],
    ["max", 13],
    ["opt", false],
    ["linters", $a(["lintcsum", "lintgcppos1"])]
  ]);
  var _2o = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 1],
    ["max", 12],
    ["opt", true],
    ["linters", $a([])]
  ]);
  var _2s = /* @__PURE__ */ new Map([
    ["parts", $a([_2m, _2o])],
    ["ex", $a(["01", "02", "415", "8006", "8020", "8026"])],
    ["dlpkey", $a([])]
  ]);
  var _2u = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 1],
    ["max", 8],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _30 = /* @__PURE__ */ new Map([
    ["parts", $a([_2u])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _32 = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _39 = /* @__PURE__ */ new Map([
    ["parts", $a([_32])],
    ["ex", $a(["310n"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _3B = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _3I = /* @__PURE__ */ new Map([
    ["parts", $a([_3B])],
    ["ex", $a(["311n"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _3K = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _3R = /* @__PURE__ */ new Map([
    ["parts", $a([_3K])],
    ["ex", $a(["312n"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _3T = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _3a = /* @__PURE__ */ new Map([
    ["parts", $a([_3T])],
    ["ex", $a(["313n"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _3c = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _3j = /* @__PURE__ */ new Map([
    ["parts", $a([_3c])],
    ["ex", $a(["314n"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _3l = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _3s = /* @__PURE__ */ new Map([
    ["parts", $a([_3l])],
    ["ex", $a(["315n"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _3u = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _41 = /* @__PURE__ */ new Map([
    ["parts", $a([_3u])],
    ["ex", $a(["316n"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _43 = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _4A = /* @__PURE__ */ new Map([
    ["parts", $a([_43])],
    ["ex", $a(["320n"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _4C = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _4J = /* @__PURE__ */ new Map([
    ["parts", $a([_4C])],
    ["ex", $a(["321n"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _4L = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _4S = /* @__PURE__ */ new Map([
    ["parts", $a([_4L])],
    ["ex", $a(["322n"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _4U = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _4b = /* @__PURE__ */ new Map([
    ["parts", $a([_4U])],
    ["ex", $a(["323n"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _4d = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _4k = /* @__PURE__ */ new Map([
    ["parts", $a([_4d])],
    ["ex", $a(["324n"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _4m = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _4t = /* @__PURE__ */ new Map([
    ["parts", $a([_4m])],
    ["ex", $a(["325n"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _4v = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _52 = /* @__PURE__ */ new Map([
    ["parts", $a([_4v])],
    ["ex", $a(["326n"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _54 = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _5B = /* @__PURE__ */ new Map([
    ["parts", $a([_54])],
    ["ex", $a(["327n"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _5D = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _5K = /* @__PURE__ */ new Map([
    ["parts", $a([_5D])],
    ["ex", $a(["328n"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _5M = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _5T = /* @__PURE__ */ new Map([
    ["parts", $a([_5M])],
    ["ex", $a(["329n"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _5V = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _5c = /* @__PURE__ */ new Map([
    ["parts", $a([_5V])],
    ["ex", $a(["330n"])],
    ["req", $a([$a([$a(["00"]), $a(["01"])])])]
  ]);
  var _5e = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _5l = /* @__PURE__ */ new Map([
    ["parts", $a([_5e])],
    ["ex", $a(["331n"])],
    ["req", $a([$a([$a(["00"]), $a(["01"])])])]
  ]);
  var _5n = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _5u = /* @__PURE__ */ new Map([
    ["parts", $a([_5n])],
    ["ex", $a(["332n"])],
    ["req", $a([$a([$a(["00"]), $a(["01"])])])]
  ]);
  var _5w = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _63 = /* @__PURE__ */ new Map([
    ["parts", $a([_5w])],
    ["ex", $a(["333n"])],
    ["req", $a([$a([$a(["00"]), $a(["01"])])])]
  ]);
  var _65 = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _6C = /* @__PURE__ */ new Map([
    ["parts", $a([_65])],
    ["ex", $a(["334n"])],
    ["req", $a([$a([$a(["00"]), $a(["01"])])])]
  ]);
  var _6E = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _6L = /* @__PURE__ */ new Map([
    ["parts", $a([_6E])],
    ["ex", $a(["335n"])],
    ["req", $a([$a([$a(["00"]), $a(["01"])])])]
  ]);
  var _6N = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _6U = /* @__PURE__ */ new Map([
    ["parts", $a([_6N])],
    ["ex", $a(["336n"])],
    ["req", $a([$a([$a(["00"]), $a(["01"])])])]
  ]);
  var _6W = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _6c = /* @__PURE__ */ new Map([
    ["parts", $a([_6W])],
    ["ex", $a(["337n"])],
    ["req", $a([$a([$a(["01"])])])]
  ]);
  var _6e = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _6l = /* @__PURE__ */ new Map([
    ["parts", $a([_6e])],
    ["ex", $a(["340n"])],
    ["req", $a([$a([$a(["00"]), $a(["01"])])])]
  ]);
  var _6n = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _6u = /* @__PURE__ */ new Map([
    ["parts", $a([_6n])],
    ["ex", $a(["341n"])],
    ["req", $a([$a([$a(["00"]), $a(["01"])])])]
  ]);
  var _6w = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _73 = /* @__PURE__ */ new Map([
    ["parts", $a([_6w])],
    ["ex", $a(["342n"])],
    ["req", $a([$a([$a(["00"]), $a(["01"])])])]
  ]);
  var _75 = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _7C = /* @__PURE__ */ new Map([
    ["parts", $a([_75])],
    ["ex", $a(["343n"])],
    ["req", $a([$a([$a(["00"]), $a(["01"])])])]
  ]);
  var _7E = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _7L = /* @__PURE__ */ new Map([
    ["parts", $a([_7E])],
    ["ex", $a(["344n"])],
    ["req", $a([$a([$a(["00"]), $a(["01"])])])]
  ]);
  var _7N = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _7U = /* @__PURE__ */ new Map([
    ["parts", $a([_7N])],
    ["ex", $a(["345n"])],
    ["req", $a([$a([$a(["00"]), $a(["01"])])])]
  ]);
  var _7W = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _7d = /* @__PURE__ */ new Map([
    ["parts", $a([_7W])],
    ["ex", $a(["346n"])],
    ["req", $a([$a([$a(["00"]), $a(["01"])])])]
  ]);
  var _7f = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _7m = /* @__PURE__ */ new Map([
    ["parts", $a([_7f])],
    ["ex", $a(["347n"])],
    ["req", $a([$a([$a(["00"]), $a(["01"])])])]
  ]);
  var _7o = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _7v = /* @__PURE__ */ new Map([
    ["parts", $a([_7o])],
    ["ex", $a(["348n"])],
    ["req", $a([$a([$a(["00"]), $a(["01"])])])]
  ]);
  var _7x = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _84 = /* @__PURE__ */ new Map([
    ["parts", $a([_7x])],
    ["ex", $a(["349n"])],
    ["req", $a([$a([$a(["00"]), $a(["01"])])])]
  ]);
  var _86 = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _8D = /* @__PURE__ */ new Map([
    ["parts", $a([_86])],
    ["ex", $a(["350n"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _8F = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _8M = /* @__PURE__ */ new Map([
    ["parts", $a([_8F])],
    ["ex", $a(["351n"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _8O = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _8V = /* @__PURE__ */ new Map([
    ["parts", $a([_8O])],
    ["ex", $a(["352n"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _8X = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _8e = /* @__PURE__ */ new Map([
    ["parts", $a([_8X])],
    ["ex", $a(["353n"])],
    ["req", $a([$a([$a(["00"]), $a(["01"])])])]
  ]);
  var _8g = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _8n = /* @__PURE__ */ new Map([
    ["parts", $a([_8g])],
    ["ex", $a(["354n"])],
    ["req", $a([$a([$a(["00"]), $a(["01"])])])]
  ]);
  var _8p = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _8w = /* @__PURE__ */ new Map([
    ["parts", $a([_8p])],
    ["ex", $a(["355n"])],
    ["req", $a([$a([$a(["00"]), $a(["01"])])])]
  ]);
  var _8y = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _95 = /* @__PURE__ */ new Map([
    ["parts", $a([_8y])],
    ["ex", $a(["356n"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _97 = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _9E = /* @__PURE__ */ new Map([
    ["parts", $a([_97])],
    ["ex", $a(["357n"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _9G = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _9N = /* @__PURE__ */ new Map([
    ["parts", $a([_9G])],
    ["ex", $a(["360n"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _9P = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _9W = /* @__PURE__ */ new Map([
    ["parts", $a([_9P])],
    ["ex", $a(["361n"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _9Y = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _9f = /* @__PURE__ */ new Map([
    ["parts", $a([_9Y])],
    ["ex", $a(["362n"])],
    ["req", $a([$a([$a(["00"]), $a(["01"])])])]
  ]);
  var _9h = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _9o = /* @__PURE__ */ new Map([
    ["parts", $a([_9h])],
    ["ex", $a(["363n"])],
    ["req", $a([$a([$a(["00"]), $a(["01"])])])]
  ]);
  var _9q = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _9x = /* @__PURE__ */ new Map([
    ["parts", $a([_9q])],
    ["ex", $a(["364n"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _9z = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _A6 = /* @__PURE__ */ new Map([
    ["parts", $a([_9z])],
    ["ex", $a(["365n"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _A8 = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _AF = /* @__PURE__ */ new Map([
    ["parts", $a([_A8])],
    ["ex", $a(["366n"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _AH = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _AO = /* @__PURE__ */ new Map([
    ["parts", $a([_AH])],
    ["ex", $a(["367n"])],
    ["req", $a([$a([$a(["00"]), $a(["01"])])])]
  ]);
  var _AQ = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _AX = /* @__PURE__ */ new Map([
    ["parts", $a([_AQ])],
    ["ex", $a(["368n"])],
    ["req", $a([$a([$a(["00"]), $a(["01"])])])]
  ]);
  var _AZ = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _Ag = /* @__PURE__ */ new Map([
    ["parts", $a([_AZ])],
    ["ex", $a(["369n"])],
    ["req", $a([$a([$a(["00"]), $a(["01"])])])]
  ]);
  var _Ai = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 1],
    ["max", 8],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _Aq = /* @__PURE__ */ new Map([
    ["parts", $a([_Ai])],
    ["req", $a([$a([$a(["00"])]), $a([$a(["02"]), $a(["8026"])])])]
  ]);
  var _As = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 1],
    ["max", 15],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _Az = /* @__PURE__ */ new Map([
    ["parts", $a([_As])],
    ["ex", $a(["390n", "391n", "394n", "8111"])],
    ["req", $a([$a([$a(["255"]), $a(["8020"])])])]
  ]);
  var _B1 = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 3],
    ["max", 3],
    ["opt", false],
    ["linters", $a(["lintiso4217"])]
  ]);
  var _B3 = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 1],
    ["max", 15],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _B9 = /* @__PURE__ */ new Map([
    ["parts", $a([_B1, _B3])],
    ["ex", $a(["391n"])],
    ["req", $a([$a([$a(["8020"])])])]
  ]);
  var _BB = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 1],
    ["max", 15],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _BN = /* @__PURE__ */ new Map([
    ["parts", $a([_BB])],
    ["ex", $a(["392n", "393n"])],
    ["req", $a([$a([$a(["01"])]), $a([$a(["30"]), $a(["31nn"]), $a(["32nn"]), $a(["35nn"]), $a(["36nn"])])])]
  ]);
  var _BP = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 3],
    ["max", 3],
    ["opt", false],
    ["linters", $a(["lintiso4217"])]
  ]);
  var _BR = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 1],
    ["max", 15],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _Bb = /* @__PURE__ */ new Map([
    ["parts", $a([_BP, _BR])],
    ["ex", $a(["393n"])],
    ["req", $a([$a([$a(["30"]), $a(["31nn"]), $a(["32nn"]), $a(["35nn"]), $a(["36nn"])])])]
  ]);
  var _Bd = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 4],
    ["max", 4],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _Bj = /* @__PURE__ */ new Map([
    ["parts", $a([_Bd])],
    ["ex", $a(["394n", "8111"])],
    ["req", $a([$a([$a(["255"])])])]
  ]);
  var _Bl = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _Bv = /* @__PURE__ */ new Map([
    ["parts", $a([_Bl])],
    ["ex", $a(["392n", "393n", "395n", "8005"])],
    ["req", $a([$a([$a(["30"]), $a(["31nn"]), $a(["32nn"]), $a(["35nn"]), $a(["36nn"])])])]
  ]);
  var _Bx = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 30],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _Bz = /* @__PURE__ */ new Map([
    ["parts", $a([_Bx])]
  ]);
  var _C1 = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 30],
    ["opt", false],
    ["linters", $a(["lintgcppos1"])]
  ]);
  var _C4 = /* @__PURE__ */ new Map([
    ["parts", $a([_C1])],
    ["dlpkey", $a([])]
  ]);
  var _C6 = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 17],
    ["max", 17],
    ["opt", false],
    ["linters", $a(["lintcsum", "lintgcppos1"])]
  ]);
  var _C9 = /* @__PURE__ */ new Map([
    ["parts", $a([_C6])],
    ["dlpkey", $a([])]
  ]);
  var _CB = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 30],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _CG = /* @__PURE__ */ new Map([
    ["parts", $a([_CB])],
    ["req", $a([$a([$a(["00"])])])]
  ]);
  var _CI = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 13],
    ["max", 13],
    ["opt", false],
    ["linters", $a(["lintcsum", "lintgcppos1"])]
  ]);
  var _CK = /* @__PURE__ */ new Map([
    ["parts", $a([_CI])]
  ]);
  var _CM = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 13],
    ["max", 13],
    ["opt", false],
    ["linters", $a(["lintcsum", "lintgcppos1"])]
  ]);
  var _CR = /* @__PURE__ */ new Map([
    ["parts", $a([_CM])],
    ["dlpkey", $a([$a(["254"]), $a(["7040"])])]
  ]);
  var _CT = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 13],
    ["max", 13],
    ["opt", false],
    ["linters", $a(["lintcsum", "lintgcppos1"])]
  ]);
  var _Ca = /* @__PURE__ */ new Map([
    ["parts", $a([_CT])],
    ["req", $a([$a([$a(["8020"])])])],
    ["dlpkey", $a([$a(["8020"])])]
  ]);
  var _Cc = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 13],
    ["max", 13],
    ["opt", false],
    ["linters", $a(["lintcsum", "lintgcppos1"])]
  ]);
  var _Ce = /* @__PURE__ */ new Map([
    ["parts", $a([_Cc])]
  ]);
  var _Cg = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 13],
    ["max", 13],
    ["opt", false],
    ["linters", $a(["lintcsum", "lintgcppos1"])]
  ]);
  var _Ck = /* @__PURE__ */ new Map([
    ["parts", $a([_Cg])],
    ["dlpkey", $a([$a(["7040"])])]
  ]);
  var _Cm = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 20],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _Cp = /* @__PURE__ */ new Map([
    ["parts", $a([_Cm])],
    ["ex", $a(["421"])]
  ]);
  var _Cr = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 3],
    ["max", 3],
    ["opt", false],
    ["linters", $a(["lintiso3166"])]
  ]);
  var _Ct = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 9],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _Cw = /* @__PURE__ */ new Map([
    ["parts", $a([_Cr, _Ct])],
    ["ex", $a(["4307"])]
  ]);
  var _Cy = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 3],
    ["max", 3],
    ["opt", false],
    ["linters", $a(["lintiso3166"])]
  ]);
  var _D7 = /* @__PURE__ */ new Map([
    ["parts", $a([_Cy])],
    ["ex", $a(["426"])],
    ["req", $a([$a([$a(["01"]), $a(["02"]), $a(["8006"]), $a(["8026"])])])]
  ]);
  var _D9 = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 3],
    ["max", 3],
    ["opt", false],
    ["linters", $a(["lintiso3166"])]
  ]);
  var _DB = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 3],
    ["max", 3],
    ["opt", true],
    ["linters", $a(["lintiso3166"])]
  ]);
  var _DD = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 3],
    ["max", 3],
    ["opt", true],
    ["linters", $a(["lintiso3166"])]
  ]);
  var _DF = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 3],
    ["max", 3],
    ["opt", true],
    ["linters", $a(["lintiso3166"])]
  ]);
  var _DH = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 3],
    ["max", 3],
    ["opt", true],
    ["linters", $a(["lintiso3166"])]
  ]);
  var _DO = /* @__PURE__ */ new Map([
    ["parts", $a([_D9, _DB, _DD, _DF, _DH])],
    ["ex", $a(["426"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _DQ = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 3],
    ["max", 3],
    ["opt", false],
    ["linters", $a(["lintiso3166"])]
  ]);
  var _DX = /* @__PURE__ */ new Map([
    ["parts", $a([_DQ])],
    ["ex", $a(["426"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _DZ = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 3],
    ["max", 3],
    ["opt", false],
    ["linters", $a(["lintiso3166"])]
  ]);
  var _Db = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 3],
    ["max", 3],
    ["opt", true],
    ["linters", $a(["lintiso3166"])]
  ]);
  var _Dd = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 3],
    ["max", 3],
    ["opt", true],
    ["linters", $a(["lintiso3166"])]
  ]);
  var _Df = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 3],
    ["max", 3],
    ["opt", true],
    ["linters", $a(["lintiso3166"])]
  ]);
  var _Dh = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 3],
    ["max", 3],
    ["opt", true],
    ["linters", $a(["lintiso3166"])]
  ]);
  var _Do = /* @__PURE__ */ new Map([
    ["parts", $a([_DZ, _Db, _Dd, _Df, _Dh])],
    ["ex", $a(["426"])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _Dq = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 3],
    ["max", 3],
    ["opt", false],
    ["linters", $a(["lintiso3166"])]
  ]);
  var _Dw = /* @__PURE__ */ new Map([
    ["parts", $a([_Dq])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _Dy = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 3],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _E6 = /* @__PURE__ */ new Map([
    ["parts", $a([_Dy])],
    ["req", $a([$a([$a(["01"]), $a(["02"])]), $a([$a(["422"])])])]
  ]);
  var _E8 = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 35],
    ["opt", false],
    ["linters", $a(["lintpcenc"])]
  ]);
  var _ED = /* @__PURE__ */ new Map([
    ["parts", $a([_E8])],
    ["req", $a([$a([$a(["00"])])])]
  ]);
  var _EF = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 70],
    ["opt", false],
    ["linters", $a(["lintpcenc"])]
  ]);
  var _EK = /* @__PURE__ */ new Map([
    ["parts", $a([_EF])],
    ["req", $a([$a([$a(["00"])])])]
  ]);
  var _EM = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 70],
    ["opt", false],
    ["linters", $a(["lintpcenc"])]
  ]);
  var _ER = /* @__PURE__ */ new Map([
    ["parts", $a([_EM])],
    ["req", $a([$a([$a(["4302"])])])]
  ]);
  var _ET = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 70],
    ["opt", false],
    ["linters", $a(["lintpcenc"])]
  ]);
  var _EY = /* @__PURE__ */ new Map([
    ["parts", $a([_ET])],
    ["req", $a([$a([$a(["00"])])])]
  ]);
  var _Ea = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 2],
    ["max", 2],
    ["opt", false],
    ["linters", $a(["lintiso3166alpha2"])]
  ]);
  var _Ef = /* @__PURE__ */ new Map([
    ["parts", $a([_Ea])],
    ["req", $a([$a([$a(["00"])])])]
  ]);
  var _Eh = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 30],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _Em = /* @__PURE__ */ new Map([
    ["parts", $a([_Eh])],
    ["req", $a([$a([$a(["00"])])])]
  ]);
  var _Eo = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 10],
    ["max", 10],
    ["opt", false],
    ["linters", $a(["lintlatitude"])]
  ]);
  var _Eq = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 10],
    ["max", 10],
    ["opt", false],
    ["linters", $a(["lintlongitude"])]
  ]);
  var _Ev = /* @__PURE__ */ new Map([
    ["parts", $a([_Eo, _Eq])],
    ["req", $a([$a([$a(["00"])])])]
  ]);
  var _Ex = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 35],
    ["opt", false],
    ["linters", $a(["lintpcenc"])]
  ]);
  var _F2 = /* @__PURE__ */ new Map([
    ["parts", $a([_Ex])],
    ["req", $a([$a([$a(["00"])])])]
  ]);
  var _F4 = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 70],
    ["opt", false],
    ["linters", $a(["lintpcenc"])]
  ]);
  var _F9 = /* @__PURE__ */ new Map([
    ["parts", $a([_F4])],
    ["req", $a([$a([$a(["00"])])])]
  ]);
  var _FB = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 70],
    ["opt", false],
    ["linters", $a(["lintpcenc"])]
  ]);
  var _FG = /* @__PURE__ */ new Map([
    ["parts", $a([_FB])],
    ["req", $a([$a([$a(["4312"])])])]
  ]);
  var _FI = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 70],
    ["opt", false],
    ["linters", $a(["lintpcenc"])]
  ]);
  var _FN = /* @__PURE__ */ new Map([
    ["parts", $a([_FI])],
    ["req", $a([$a([$a(["00"])])])]
  ]);
  var _FP = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 2],
    ["max", 2],
    ["opt", false],
    ["linters", $a(["lintiso3166alpha2"])]
  ]);
  var _FU = /* @__PURE__ */ new Map([
    ["parts", $a([_FP])],
    ["req", $a([$a([$a(["00"])])])]
  ]);
  var _FW = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 20],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _Fb = /* @__PURE__ */ new Map([
    ["parts", $a([_FW])],
    ["req", $a([$a([$a(["00"])])])]
  ]);
  var _Fd = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 30],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _Fi = /* @__PURE__ */ new Map([
    ["parts", $a([_Fd])],
    ["req", $a([$a([$a(["00"])])])]
  ]);
  var _Fk = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 35],
    ["opt", false],
    ["linters", $a(["lintpcenc"])]
  ]);
  var _Fp = /* @__PURE__ */ new Map([
    ["parts", $a([_Fk])],
    ["req", $a([$a([$a(["00"])])])]
  ]);
  var _Fr = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 1],
    ["max", 1],
    ["opt", false],
    ["linters", $a(["lintyesno"])]
  ]);
  var _Fw = /* @__PURE__ */ new Map([
    ["parts", $a([_Fr])],
    ["req", $a([$a([$a(["00"])])])]
  ]);
  var _Fy = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a(["lintyymmd0"])]
  ]);
  var _G0 = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 4],
    ["max", 4],
    ["opt", false],
    ["linters", $a(["linthhmi"])]
  ]);
  var _G5 = /* @__PURE__ */ new Map([
    ["parts", $a([_Fy, _G0])],
    ["req", $a([$a([$a(["00"])])])]
  ]);
  var _G7 = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a(["lintyymmdd"])]
  ]);
  var _GC = /* @__PURE__ */ new Map([
    ["parts", $a([_G7])],
    ["req", $a([$a([$a(["00"])])])]
  ]);
  var _GE = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _GG = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 1],
    ["opt", true],
    ["linters", $a(["linthyphen"])]
  ]);
  var _GM = /* @__PURE__ */ new Map([
    ["parts", $a([_GE, _GG])],
    ["ex", $a(["4331"])],
    ["req", $a([$a([$a(["00"])])])]
  ]);
  var _GO = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _GQ = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 1],
    ["opt", true],
    ["linters", $a(["linthyphen"])]
  ]);
  var _GW = /* @__PURE__ */ new Map([
    ["parts", $a([_GO, _GQ])],
    ["ex", $a(["4330"])],
    ["req", $a([$a([$a(["00"])])])]
  ]);
  var _GY = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _Ga = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 1],
    ["opt", true],
    ["linters", $a(["linthyphen"])]
  ]);
  var _Gg = /* @__PURE__ */ new Map([
    ["parts", $a([_GY, _Ga])],
    ["ex", $a(["4333"])],
    ["req", $a([$a([$a(["00"])])])]
  ]);
  var _Gi = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _Gk = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 1],
    ["opt", true],
    ["linters", $a(["linthyphen"])]
  ]);
  var _Gq = /* @__PURE__ */ new Map([
    ["parts", $a([_Gi, _Gk])],
    ["ex", $a(["4332"])],
    ["req", $a([$a([$a(["00"])])])]
  ]);
  var _Gs = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 13],
    ["max", 13],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _H0 = /* @__PURE__ */ new Map([
    ["parts", $a([_Gs])],
    ["req", $a([$a([$a(["01"]), $a(["02"]), $a(["8006"]), $a(["8026"])])])]
  ]);
  var _H2 = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 30],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _H8 = /* @__PURE__ */ new Map([
    ["parts", $a([_H2])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _HA = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a(["lintyymmdd"])]
  ]);
  var _HC = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 4],
    ["max", 4],
    ["opt", false],
    ["linters", $a(["linthhmi"])]
  ]);
  var _HI = /* @__PURE__ */ new Map([
    ["parts", $a([_HA, _HC])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _HK = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 1],
    ["max", 4],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _HR = /* @__PURE__ */ new Map([
    ["parts", $a([_HK])],
    ["req", $a([$a([$a(["01"])]), $a([$a(["10"])])])]
  ]);
  var _HT = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 12],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _HZ = /* @__PURE__ */ new Map([
    ["parts", $a([_HT])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _Hb = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a(["lintyymmdd"])]
  ]);
  var _Hh = /* @__PURE__ */ new Map([
    ["parts", $a([_Hb])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _Hj = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a(["lintyymmdd"])]
  ]);
  var _Hl = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", true],
    ["linters", $a(["lintyymmdd"])]
  ]);
  var _Hr = /* @__PURE__ */ new Map([
    ["parts", $a([_Hj, _Hl])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _Ht = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 3],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _Hz = /* @__PURE__ */ new Map([
    ["parts", $a([_Ht])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _I1 = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 10],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _I7 = /* @__PURE__ */ new Map([
    ["parts", $a([_I1])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _I9 = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 2],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _IF = /* @__PURE__ */ new Map([
    ["parts", $a([_I9])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _IH = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a(["lintyymmdd"])]
  ]);
  var _IJ = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 4],
    ["max", 4],
    ["opt", true],
    ["linters", $a(["linthhmi"])]
  ]);
  var _IP = /* @__PURE__ */ new Map([
    ["parts", $a([_IH, _IJ])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _IR = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 20],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _IZ = /* @__PURE__ */ new Map([
    ["parts", $a([_IR])],
    ["req", $a([$a([$a(["01"]), $a(["8006"])]), $a([$a(["416"])])])]
  ]);
  var _Ib = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 20],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _Ih = /* @__PURE__ */ new Map([
    ["parts", $a([_Ib])],
    ["req", $a([$a([$a(["01"]), $a(["8006"])])])]
  ]);
  var _Ij = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 20],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _Io = /* @__PURE__ */ new Map([
    ["parts", $a([_Ij])],
    ["req", $a([$a([$a(["7021"])])])]
  ]);
  var _Iq = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 30],
    ["opt", false],
    ["linters", $a(["lintgcppos1"])]
  ]);
  var _Is = /* @__PURE__ */ new Map([
    ["parts", $a([_Iq])]
  ]);
  var _Iu = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 3],
    ["max", 3],
    ["opt", false],
    ["linters", $a(["lintiso3166999"])]
  ]);
  var _Iw = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 27],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _J2 = /* @__PURE__ */ new Map([
    ["parts", $a([_Iu, _Iw])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _J4 = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 1],
    ["max", 1],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _J6 = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 1],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _J8 = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 1],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _JA = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 1],
    ["opt", false],
    ["linters", $a(["lintimporteridx"])]
  ]);
  var _JC = /* @__PURE__ */ new Map([
    ["parts", $a([_J4, _J6, _J8, _JA])],
    ["dlattr", false]
  ]);
  var _JE = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 4],
    ["opt", false],
    ["linters", $a(["lintpackagetype"])]
  ]);
  var _JJ = /* @__PURE__ */ new Map([
    ["parts", $a([_JE])],
    ["req", $a([$a([$a(["00"])])])],
    ["dlattr", false]
  ]);
  var _JL = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 20],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _JQ = /* @__PURE__ */ new Map([
    ["parts", $a([_JL])],
    ["req", $a([$a([$a(["01"])])])]
  ]);
  var _JS = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 2],
    ["max", 2],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _JU = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 28],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _Ja = /* @__PURE__ */ new Map([
    ["parts", $a([_JS, _JU])],
    ["req", $a([$a([$a(["01"]), $a(["8004"])])])]
  ]);
  var _Jc = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 20],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _Ji = /* @__PURE__ */ new Map([
    ["parts", $a([_Jc])],
    ["req", $a([$a([$a(["01"]), $a(["8006"])])])]
  ]);
  var _Jk = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 2],
    ["max", 2],
    ["opt", false],
    ["linters", $a(["lintmediatype"])]
  ]);
  var _Jq = /* @__PURE__ */ new Map([
    ["parts", $a([_Jk])],
    ["req", $a([$a([$a(["8017"]), $a(["8018"])])])]
  ]);
  var _Js = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 25],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _Jy = /* @__PURE__ */ new Map([
    ["parts", $a([_Js])],
    ["req", $a([$a([$a(["8017"]), $a(["8018"])])])]
  ]);
  var _K0 = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 8],
    ["max", 8],
    ["opt", false],
    ["linters", $a(["lintyyyymmdd"])]
  ]);
  var _K6 = /* @__PURE__ */ new Map([
    ["parts", $a([_K0])],
    ["ex", $a(["7251"])],
    ["req", $a([$a([$a(["8018"])])])]
  ]);
  var _K8 = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 8],
    ["max", 8],
    ["opt", false],
    ["linters", $a(["lintyyyymmdd"])]
  ]);
  var _KA = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 4],
    ["max", 4],
    ["opt", false],
    ["linters", $a(["linthhmi"])]
  ]);
  var _KG = /* @__PURE__ */ new Map([
    ["parts", $a([_K8, _KA])],
    ["ex", $a(["7250"])],
    ["req", $a([$a([$a(["8018"])])])]
  ]);
  var _KI = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 1],
    ["max", 1],
    ["opt", false],
    ["linters", $a(["lintiso5218"])]
  ]);
  var _KN = /* @__PURE__ */ new Map([
    ["parts", $a([_KI])],
    ["req", $a([$a([$a(["8018"])])])]
  ]);
  var _KP = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 40],
    ["opt", false],
    ["linters", $a(["lintpcenc"])]
  ]);
  var _KW = /* @__PURE__ */ new Map([
    ["parts", $a([_KP])],
    ["ex", $a(["7256", "7259"])],
    ["req", $a([$a([$a(["8017"]), $a(["8018"])])])]
  ]);
  var _KY = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 10],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _Kf = /* @__PURE__ */ new Map([
    ["parts", $a([_KY])],
    ["ex", $a(["7256", "7259"])],
    ["req", $a([$a([$a(["8017"]), $a(["8018"])])])]
  ]);
  var _Kh = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 90],
    ["opt", false],
    ["linters", $a(["lintpcenc"])]
  ]);
  var _Kn = /* @__PURE__ */ new Map([
    ["parts", $a([_Kh])],
    ["req", $a([$a([$a(["8017"]), $a(["8018"])])])]
  ]);
  var _Kp = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 70],
    ["opt", false],
    ["linters", $a(["lintpcenc"])]
  ]);
  var _Ku = /* @__PURE__ */ new Map([
    ["parts", $a([_Kp])],
    ["req", $a([$a([$a(["8018"])])])]
  ]);
  var _Kw = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 3],
    ["max", 3],
    ["opt", false],
    ["linters", $a(["lintposinseqslash"])]
  ]);
  var _L1 = /* @__PURE__ */ new Map([
    ["parts", $a([_Kw])],
    ["req", $a([$a([$a(["8018", "7259"])])])]
  ]);
  var _L3 = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 40],
    ["opt", false],
    ["linters", $a(["lintpcenc"])]
  ]);
  var _L9 = /* @__PURE__ */ new Map([
    ["parts", $a([_L3])],
    ["ex", $a(["7256"])],
    ["req", $a([$a([$a(["8018"])])])]
  ]);
  var _LB = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 4],
    ["max", 4],
    ["opt", false],
    ["linters", $a(["lintnonzero"])]
  ]);
  var _LD = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 5],
    ["max", 5],
    ["opt", false],
    ["linters", $a(["lintnonzero"])]
  ]);
  var _LF = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 3],
    ["max", 3],
    ["opt", false],
    ["linters", $a(["lintnonzero"])]
  ]);
  var _LH = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 1],
    ["max", 1],
    ["opt", false],
    ["linters", $a(["lintwinding"])]
  ]);
  var _LJ = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 1],
    ["max", 1],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _LO = /* @__PURE__ */ new Map([
    ["parts", $a([_LB, _LD, _LF, _LH, _LJ])],
    ["req", $a([$a([$a(["01"])])])]
  ]);
  var _LQ = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 20],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _LS = /* @__PURE__ */ new Map([
    ["parts", $a([_LQ])]
  ]);
  var _LU = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 1],
    ["max", 1],
    ["opt", false],
    ["linters", $a(["lintzero"])]
  ]);
  var _LW = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 13],
    ["max", 13],
    ["opt", false],
    ["linters", $a(["lintcsum", "lintgcppos1"])]
  ]);
  var _LY = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 16],
    ["opt", true],
    ["linters", $a([])]
  ]);
  var _Lb = /* @__PURE__ */ new Map([
    ["parts", $a([_LU, _LW, _LY])],
    ["dlpkey", $a([])]
  ]);
  var _Ld = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 30],
    ["opt", false],
    ["linters", $a(["lintgcppos1"])]
  ]);
  var _Lh = /* @__PURE__ */ new Map([
    ["parts", $a([_Ld])],
    ["dlpkey", $a([$a(["7040"])])]
  ]);
  var _Lj = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _Lp = /* @__PURE__ */ new Map([
    ["parts", $a([_Lj])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _Lr = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 14],
    ["max", 14],
    ["opt", false],
    ["linters", $a(["lintcsum", "lintgcppos2"])]
  ]);
  var _Lt = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 4],
    ["max", 4],
    ["opt", false],
    ["linters", $a(["lintpieceoftotal"])]
  ]);
  var _Ly = /* @__PURE__ */ new Map([
    ["parts", $a([_Lr, _Lt])],
    ["ex", $a(["01", "37"])],
    ["dlpkey", $a([$a(["22", "10", "21"])])]
  ]);
  var _M0 = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 34],
    ["opt", false],
    ["linters", $a(["lintiban"])]
  ]);
  var _M5 = /* @__PURE__ */ new Map([
    ["parts", $a([_M0])],
    ["req", $a([$a([$a(["415"])])])]
  ]);
  var _M7 = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 6],
    ["max", 6],
    ["opt", false],
    ["linters", $a(["lintyymmdd"])]
  ]);
  var _M9 = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 2],
    ["max", 2],
    ["opt", false],
    ["linters", $a(["linthh"])]
  ]);
  var _MB = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 2],
    ["max", 2],
    ["opt", true],
    ["linters", $a(["lintmi"])]
  ]);
  var _MD = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 2],
    ["max", 2],
    ["opt", true],
    ["linters", $a(["lintss"])]
  ]);
  var _MJ = /* @__PURE__ */ new Map([
    ["parts", $a([_M7, _M9, _MB, _MD])],
    ["req", $a([$a([$a(["01"]), $a(["02"])])])]
  ]);
  var _ML = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 50],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _MR = /* @__PURE__ */ new Map([
    ["parts", $a([_ML])],
    ["req", $a([$a([$a(["00"]), $a(["01"])])])]
  ]);
  var _MT = /* @__PURE__ */ new Map([
    ["cset", "Y"],
    ["min", 1],
    ["max", 30],
    ["opt", false],
    ["linters", $a(["lintgcppos1"])]
  ]);
  var _MX = /* @__PURE__ */ new Map([
    ["parts", $a([_MT])],
    ["dlpkey", $a([$a(["8011"])])]
  ]);
  var _MZ = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 1],
    ["max", 12],
    ["opt", false],
    ["linters", $a(["lintnozeroprefix"])]
  ]);
  var _Me = /* @__PURE__ */ new Map([
    ["parts", $a([_MZ])],
    ["req", $a([$a([$a(["8010"])])])],
    ["dlattr", false]
  ]);
  var _Mg = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 20],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _Mm = /* @__PURE__ */ new Map([
    ["parts", $a([_Mg])],
    ["req", $a([$a([$a(["01"]), $a(["8006"])])])]
  ]);
  var _Mo = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 25],
    ["opt", false],
    ["linters", $a(["lintcsumalpha", "lintgcppos1"])]
  ]);
  var _Mr = /* @__PURE__ */ new Map([
    ["parts", $a([_Mo])],
    ["dlpkey", $a([])]
  ]);
  var _Mt = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 25],
    ["opt", false],
    ["linters", $a(["lintcsumalpha", "lintgcppos1", "linthasnondigit"])]
  ]);
  var _My = /* @__PURE__ */ new Map([
    ["parts", $a([_Mt])],
    ["req", $a([$a([$a(["01"])])])],
    ["dlattr", false]
  ]);
  var _N0 = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 18],
    ["max", 18],
    ["opt", false],
    ["linters", $a(["lintcsum", "lintgcppos1"])]
  ]);
  var _N5 = /* @__PURE__ */ new Map([
    ["parts", $a([_N0])],
    ["ex", $a(["8018"])],
    ["dlpkey", $a([$a(["8019"])])]
  ]);
  var _N7 = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 18],
    ["max", 18],
    ["opt", false],
    ["linters", $a(["lintcsum", "lintgcppos1"])]
  ]);
  var _NC = /* @__PURE__ */ new Map([
    ["parts", $a([_N7])],
    ["ex", $a(["8017"])],
    ["dlpkey", $a([$a(["8019"])])]
  ]);
  var _NE = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 1],
    ["max", 10],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _NK = /* @__PURE__ */ new Map([
    ["parts", $a([_NE])],
    ["req", $a([$a([$a(["8017"]), $a(["8018"])])])],
    ["dlattr", false]
  ]);
  var _NM = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 25],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _NR = /* @__PURE__ */ new Map([
    ["parts", $a([_NM])],
    ["req", $a([$a([$a(["415"])])])],
    ["dlattr", false]
  ]);
  var _NT = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 14],
    ["max", 14],
    ["opt", false],
    ["linters", $a(["lintcsum", "lintgcppos2"])]
  ]);
  var _NV = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 4],
    ["max", 4],
    ["opt", false],
    ["linters", $a(["lintpieceoftotal"])]
  ]);
  var _Nb = /* @__PURE__ */ new Map([
    ["parts", $a([_NT, _NV])],
    ["ex", $a(["02", "8006"])],
    ["req", $a([$a([$a(["37"])])])]
  ]);
  var _Nd = /* @__PURE__ */ new Map([
    ["cset", "Z"],
    ["min", 1],
    ["max", 90],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _Nr = /* @__PURE__ */ new Map([
    ["parts", $a([_Nd])],
    ["req", $a([$a([$a(["00"]), $a(["01", "21"]), $a(["253"]), $a(["255"]), $a(["8003"]), $a(["8004"]), $a(["8006", "21"]), $a(["8010", "8011"]), $a(["8017"]), $a(["8018"])])])]
  ]);
  var _Nt = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 70],
    ["opt", false],
    ["linters", $a(["lintcouponcode"])]
  ]);
  var _Nv = /* @__PURE__ */ new Map([
    ["parts", $a([_Nt])]
  ]);
  var _Nx = /* @__PURE__ */ new Map([
    ["cset", "N"],
    ["min", 4],
    ["max", 4],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _O2 = /* @__PURE__ */ new Map([
    ["parts", $a([_Nx])],
    ["req", $a([$a([$a(["255"])])])]
  ]);
  var _O4 = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 70],
    ["opt", false],
    ["linters", $a(["lintcouponposoffer"])]
  ]);
  var _O6 = /* @__PURE__ */ new Map([
    ["parts", $a([_O4])]
  ]);
  var _O8 = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 70],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _OD = /* @__PURE__ */ new Map([
    ["parts", $a([_O8])],
    ["req", $a([$a([$a(["01"])])])],
    ["dlattr", false]
  ]);
  var _OF = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 30],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _OH = /* @__PURE__ */ new Map([
    ["parts", $a([_OF])]
  ]);
  var _OJ = /* @__PURE__ */ new Map([
    ["cset", "X"],
    ["min", 1],
    ["max", 90],
    ["opt", false],
    ["linters", $a([])]
  ]);
  var _OL = /* @__PURE__ */ new Map([
    ["parts", $a([_OJ])]
  ]);
  var _OM = /* @__PURE__ */ new Map([
    ["00", _4],
    ["01", _C],
    ["02", _K],
    ["03", _P],
    ["10", _a],
    ["11", _l],
    ["12", _s],
    ["13", _13],
    ["15", _13],
    ["16", _13],
    ["17", _1F],
    ["20", _1P],
    ["21", _1Z],
    ["22", _1g],
    ["235", _1n],
    ["240", _1x],
    ["241", _1x],
    ["242", _27],
    ["243", _2E],
    ["250", _2O],
    ["251", _2W],
    ["253", _2d],
    ["254", _2k],
    ["255", _2s],
    ["30", _30],
    ["3100", _39],
    ["3101", _39],
    ["3102", _39],
    ["3103", _39],
    ["3104", _39],
    ["3105", _39],
    ["3110", _3I],
    ["3111", _3I],
    ["3112", _3I],
    ["3113", _3I],
    ["3114", _3I],
    ["3115", _3I],
    ["3120", _3R],
    ["3121", _3R],
    ["3122", _3R],
    ["3123", _3R],
    ["3124", _3R],
    ["3125", _3R],
    ["3130", _3a],
    ["3131", _3a],
    ["3132", _3a],
    ["3133", _3a],
    ["3134", _3a],
    ["3135", _3a],
    ["3140", _3j],
    ["3141", _3j],
    ["3142", _3j],
    ["3143", _3j],
    ["3144", _3j],
    ["3145", _3j],
    ["3150", _3s],
    ["3151", _3s],
    ["3152", _3s],
    ["3153", _3s],
    ["3154", _3s],
    ["3155", _3s],
    ["3160", _41],
    ["3161", _41],
    ["3162", _41],
    ["3163", _41],
    ["3164", _41],
    ["3165", _41],
    ["3200", _4A],
    ["3201", _4A],
    ["3202", _4A],
    ["3203", _4A],
    ["3204", _4A],
    ["3205", _4A],
    ["3210", _4J],
    ["3211", _4J],
    ["3212", _4J],
    ["3213", _4J],
    ["3214", _4J],
    ["3215", _4J],
    ["3220", _4S],
    ["3221", _4S],
    ["3222", _4S],
    ["3223", _4S],
    ["3224", _4S],
    ["3225", _4S],
    ["3230", _4b],
    ["3231", _4b],
    ["3232", _4b],
    ["3233", _4b],
    ["3234", _4b],
    ["3235", _4b],
    ["3240", _4k],
    ["3241", _4k],
    ["3242", _4k],
    ["3243", _4k],
    ["3244", _4k],
    ["3245", _4k],
    ["3250", _4t],
    ["3251", _4t],
    ["3252", _4t],
    ["3253", _4t],
    ["3254", _4t],
    ["3255", _4t],
    ["3260", _52],
    ["3261", _52],
    ["3262", _52],
    ["3263", _52],
    ["3264", _52],
    ["3265", _52],
    ["3270", _5B],
    ["3271", _5B],
    ["3272", _5B],
    ["3273", _5B],
    ["3274", _5B],
    ["3275", _5B],
    ["3280", _5K],
    ["3281", _5K],
    ["3282", _5K],
    ["3283", _5K],
    ["3284", _5K],
    ["3285", _5K],
    ["3290", _5T],
    ["3291", _5T],
    ["3292", _5T],
    ["3293", _5T],
    ["3294", _5T],
    ["3295", _5T],
    ["3300", _5c],
    ["3301", _5c],
    ["3302", _5c],
    ["3303", _5c],
    ["3304", _5c],
    ["3305", _5c],
    ["3310", _5l],
    ["3311", _5l],
    ["3312", _5l],
    ["3313", _5l],
    ["3314", _5l],
    ["3315", _5l],
    ["3320", _5u],
    ["3321", _5u],
    ["3322", _5u],
    ["3323", _5u],
    ["3324", _5u],
    ["3325", _5u],
    ["3330", _63],
    ["3331", _63],
    ["3332", _63],
    ["3333", _63],
    ["3334", _63],
    ["3335", _63],
    ["3340", _6C],
    ["3341", _6C],
    ["3342", _6C],
    ["3343", _6C],
    ["3344", _6C],
    ["3345", _6C],
    ["3350", _6L],
    ["3351", _6L],
    ["3352", _6L],
    ["3353", _6L],
    ["3354", _6L],
    ["3355", _6L],
    ["3360", _6U],
    ["3361", _6U],
    ["3362", _6U],
    ["3363", _6U],
    ["3364", _6U],
    ["3365", _6U],
    ["3370", _6c],
    ["3371", _6c],
    ["3372", _6c],
    ["3373", _6c],
    ["3374", _6c],
    ["3375", _6c],
    ["3400", _6l],
    ["3401", _6l],
    ["3402", _6l],
    ["3403", _6l],
    ["3404", _6l],
    ["3405", _6l],
    ["3410", _6u],
    ["3411", _6u],
    ["3412", _6u],
    ["3413", _6u],
    ["3414", _6u],
    ["3415", _6u],
    ["3420", _73],
    ["3421", _73],
    ["3422", _73],
    ["3423", _73],
    ["3424", _73],
    ["3425", _73],
    ["3430", _7C],
    ["3431", _7C],
    ["3432", _7C],
    ["3433", _7C],
    ["3434", _7C],
    ["3435", _7C],
    ["3440", _7L],
    ["3441", _7L],
    ["3442", _7L],
    ["3443", _7L],
    ["3444", _7L],
    ["3445", _7L],
    ["3450", _7U],
    ["3451", _7U],
    ["3452", _7U],
    ["3453", _7U],
    ["3454", _7U],
    ["3455", _7U],
    ["3460", _7d],
    ["3461", _7d],
    ["3462", _7d],
    ["3463", _7d],
    ["3464", _7d],
    ["3465", _7d],
    ["3470", _7m],
    ["3471", _7m],
    ["3472", _7m],
    ["3473", _7m],
    ["3474", _7m],
    ["3475", _7m],
    ["3480", _7v],
    ["3481", _7v],
    ["3482", _7v],
    ["3483", _7v],
    ["3484", _7v],
    ["3485", _7v],
    ["3490", _84],
    ["3491", _84],
    ["3492", _84],
    ["3493", _84],
    ["3494", _84],
    ["3495", _84],
    ["3500", _8D],
    ["3501", _8D],
    ["3502", _8D],
    ["3503", _8D],
    ["3504", _8D],
    ["3505", _8D],
    ["3510", _8M],
    ["3511", _8M],
    ["3512", _8M],
    ["3513", _8M],
    ["3514", _8M],
    ["3515", _8M],
    ["3520", _8V],
    ["3521", _8V],
    ["3522", _8V],
    ["3523", _8V],
    ["3524", _8V],
    ["3525", _8V],
    ["3530", _8e],
    ["3531", _8e],
    ["3532", _8e],
    ["3533", _8e],
    ["3534", _8e],
    ["3535", _8e],
    ["3540", _8n],
    ["3541", _8n],
    ["3542", _8n],
    ["3543", _8n],
    ["3544", _8n],
    ["3545", _8n],
    ["3550", _8w],
    ["3551", _8w],
    ["3552", _8w],
    ["3553", _8w],
    ["3554", _8w],
    ["3555", _8w],
    ["3560", _95],
    ["3561", _95],
    ["3562", _95],
    ["3563", _95],
    ["3564", _95],
    ["3565", _95],
    ["3570", _9E],
    ["3571", _9E],
    ["3572", _9E],
    ["3573", _9E],
    ["3574", _9E],
    ["3575", _9E],
    ["3600", _9N],
    ["3601", _9N],
    ["3602", _9N],
    ["3603", _9N],
    ["3604", _9N],
    ["3605", _9N],
    ["3610", _9W],
    ["3611", _9W],
    ["3612", _9W],
    ["3613", _9W],
    ["3614", _9W],
    ["3615", _9W],
    ["3620", _9f],
    ["3621", _9f],
    ["3622", _9f],
    ["3623", _9f],
    ["3624", _9f],
    ["3625", _9f],
    ["3630", _9o],
    ["3631", _9o],
    ["3632", _9o],
    ["3633", _9o],
    ["3634", _9o],
    ["3635", _9o],
    ["3640", _9x],
    ["3641", _9x],
    ["3642", _9x],
    ["3643", _9x],
    ["3644", _9x],
    ["3645", _9x],
    ["3650", _A6],
    ["3651", _A6],
    ["3652", _A6],
    ["3653", _A6],
    ["3654", _A6],
    ["3655", _A6],
    ["3660", _AF],
    ["3661", _AF],
    ["3662", _AF],
    ["3663", _AF],
    ["3664", _AF],
    ["3665", _AF],
    ["3670", _AO],
    ["3671", _AO],
    ["3672", _AO],
    ["3673", _AO],
    ["3674", _AO],
    ["3675", _AO],
    ["3680", _AX],
    ["3681", _AX],
    ["3682", _AX],
    ["3683", _AX],
    ["3684", _AX],
    ["3685", _AX],
    ["3690", _Ag],
    ["3691", _Ag],
    ["3692", _Ag],
    ["3693", _Ag],
    ["3694", _Ag],
    ["3695", _Ag],
    ["37", _Aq],
    ["3900", _Az],
    ["3901", _Az],
    ["3902", _Az],
    ["3903", _Az],
    ["3904", _Az],
    ["3905", _Az],
    ["3906", _Az],
    ["3907", _Az],
    ["3908", _Az],
    ["3909", _Az],
    ["3910", _B9],
    ["3911", _B9],
    ["3912", _B9],
    ["3913", _B9],
    ["3914", _B9],
    ["3915", _B9],
    ["3916", _B9],
    ["3917", _B9],
    ["3918", _B9],
    ["3919", _B9],
    ["3920", _BN],
    ["3921", _BN],
    ["3922", _BN],
    ["3923", _BN],
    ["3924", _BN],
    ["3925", _BN],
    ["3926", _BN],
    ["3927", _BN],
    ["3928", _BN],
    ["3929", _BN],
    ["3930", _Bb],
    ["3931", _Bb],
    ["3932", _Bb],
    ["3933", _Bb],
    ["3934", _Bb],
    ["3935", _Bb],
    ["3936", _Bb],
    ["3937", _Bb],
    ["3938", _Bb],
    ["3939", _Bb],
    ["3940", _Bj],
    ["3941", _Bj],
    ["3942", _Bj],
    ["3943", _Bj],
    ["3950", _Bv],
    ["3951", _Bv],
    ["3952", _Bv],
    ["3953", _Bv],
    ["3954", _Bv],
    ["3955", _Bv],
    ["400", _Bz],
    ["401", _C4],
    ["402", _C9],
    ["403", _CG],
    ["410", _CK],
    ["411", _CK],
    ["412", _CK],
    ["413", _CK],
    ["414", _CR],
    ["415", _Ca],
    ["416", _Ce],
    ["417", _Ck],
    ["420", _Cp],
    ["421", _Cw],
    ["422", _D7],
    ["423", _DO],
    ["424", _DX],
    ["425", _Do],
    ["426", _Dw],
    ["427", _E6],
    ["4300", _ED],
    ["4301", _ED],
    ["4302", _EK],
    ["4303", _ER],
    ["4304", _EY],
    ["4305", _EY],
    ["4306", _EY],
    ["4307", _Ef],
    ["4308", _Em],
    ["4309", _Ev],
    ["4310", _F2],
    ["4311", _F2],
    ["4312", _F9],
    ["4313", _FG],
    ["4314", _FN],
    ["4315", _FN],
    ["4316", _FN],
    ["4317", _FU],
    ["4318", _Fb],
    ["4319", _Fi],
    ["4320", _Fp],
    ["4321", _Fw],
    ["4322", _Fw],
    ["4323", _Fw],
    ["4324", _G5],
    ["4325", _G5],
    ["4326", _GC],
    ["4330", _GM],
    ["4331", _GW],
    ["4332", _Gg],
    ["4333", _Gq],
    ["7001", _H0],
    ["7002", _H8],
    ["7003", _HI],
    ["7004", _HR],
    ["7005", _HZ],
    ["7006", _Hh],
    ["7007", _Hr],
    ["7008", _Hz],
    ["7009", _I7],
    ["7010", _IF],
    ["7011", _IP],
    ["7020", _IZ],
    ["7021", _Ih],
    ["7022", _Io],
    ["7023", _Is],
    ["7030", _J2],
    ["7031", _J2],
    ["7032", _J2],
    ["7033", _J2],
    ["7034", _J2],
    ["7035", _J2],
    ["7036", _J2],
    ["7037", _J2],
    ["7038", _J2],
    ["7039", _J2],
    ["7040", _JC],
    ["7041", _JJ],
    ["710", _JQ],
    ["711", _JQ],
    ["712", _JQ],
    ["713", _JQ],
    ["714", _JQ],
    ["715", _JQ],
    ["716", _JQ],
    ["7230", _Ja],
    ["7231", _Ja],
    ["7232", _Ja],
    ["7233", _Ja],
    ["7234", _Ja],
    ["7235", _Ja],
    ["7236", _Ja],
    ["7237", _Ja],
    ["7238", _Ja],
    ["7239", _Ja],
    ["7240", _Ji],
    ["7241", _Jq],
    ["7242", _Jy],
    ["7250", _K6],
    ["7251", _KG],
    ["7252", _KN],
    ["7253", _KW],
    ["7254", _KW],
    ["7255", _Kf],
    ["7256", _Kn],
    ["7257", _Ku],
    ["7258", _L1],
    ["7259", _L9],
    ["8001", _LO],
    ["8002", _LS],
    ["8003", _Lb],
    ["8004", _Lh],
    ["8005", _Lp],
    ["8006", _Ly],
    ["8007", _M5],
    ["8008", _MJ],
    ["8009", _MR],
    ["8010", _MX],
    ["8011", _Me],
    ["8012", _Mm],
    ["8013", _Mr],
    ["8014", _My],
    ["8017", _N5],
    ["8018", _NC],
    ["8019", _NK],
    ["8020", _NR],
    ["8026", _Nb],
    ["8030", _Nr],
    ["8110", _Nv],
    ["8111", _O2],
    ["8112", _O6],
    ["8200", _OD],
    ["90", _OH],
    ["91", _OL],
    ["92", _OL],
    ["93", _OL],
    ["94", _OL],
    ["95", _OL],
    ["96", _OL],
    ["97", _OL],
    ["98", _OL],
    ["99", _OL]
  ]);
  $_.gs1syntax = _OM;
  if ($eq($k[--$j], "ai")) {
    $anchorsearch($k[--$j], "(");
    if (!$k[--$j]) {
      $j--;
      $k[$j++] = "bwipp.GS1aiMissingOpenParen#2494";
      $k[$j++] = "AIs must start with '('";
      bwipp_raiseerror();
    }
    $k[$j - 1] = Infinity;
    var _OR = $k[--$j];
    var _OS = $k[--$j];
    $k[$j++] = _OR;
    $k[$j++] = _OS;
    for (; ; ) {
      var _OT = $k[$j - 1];
      if (_OT.length == 0) {
        $j--;
        break;
      }
      $search($k[--$j], ")");
      if (!$k[--$j]) {
        $cleartomark();
        $k[$j++] = "bwipp.GS1aiMissingCloseParen#2500";
        $k[$j++] = "AIs must end with ')'";
        bwipp_raiseerror();
      }
      var _OW = $k[--$j];
      $k[$j - 1] = _OW;
      var _OY = $k[--$j];
      var _OZ = $k[--$j];
      $k[$j++] = _OY;
      $search(_OZ, "(");
      if ($k[--$j]) {
        var _Ob = $k[--$j];
        $k[$j - 1] = _Ob;
        var _Od = $k[--$j];
        var _Oe = $k[--$j];
        $k[$j++] = _Od;
        $k[$j++] = _Oe;
      } else {
        $k[$j++] = "";
      }
    }
    var _Of = $counttomark();
    $k[$j++] = _Of;
    if (_Of > 0) {
      var _Og = $k[--$j];
      for (var _Oi = _Og, _Oh = ~~(_Og / 2) + 1; _Oi >= _Oh; _Oi -= 1) {
        $r(_Oi, -1);
      }
    } else {
      $j--;
    }
    $astore($a(~~($counttomark() / 2)));
    $_.ais = $k[--$j];
    $astore($a($counttomark()));
    $k[$j++] = Infinity;
    var _Oo = $k[--$j];
    var _Op = $k[--$j];
    $k[$j++] = _Oo;
    $forall(_Op, function() {
      var _Or = /* @__PURE__ */ new Map([
        ["parse", $_.parse],
        ["parseonly", true],
        ["parsefnc", false]
      ]);
      $k[$j++] = _Or;
      bwipp_parseinput();
    });
    $_.vals = $a();
    $j--;
  } else {
    $anchorsearch($k[--$j], "http://");
    if (!$k[--$j]) {
      $anchorsearch($k[--$j], "HTTP://");
      if (!$k[--$j]) {
        $anchorsearch($k[--$j], "https://");
        if (!$k[--$j]) {
          $anchorsearch($k[--$j], "HTTPS://");
          if (!$k[--$j]) {
            $j--;
            $k[$j++] = "bwipp.GS1dlURIbadScheme#2519";
            $k[$j++] = "Scheme must be http:// HTTP:// https:// or HTTPS://";
            bwipp_raiseerror();
          }
        }
      }
    }
    $j--;
    $search($k[--$j], "/");
    if (!$k[--$j]) {
      $j--;
      $k[$j++] = "bwipp.GS1dlMissingDomainOrPathInfo#2525";
      $k[$j++] = "URI must contain a domain and path info";
      bwipp_raiseerror();
    }
    $j -= 2;
    $search($k[--$j], "#");
    if ($k[--$j]) {
      var _P5 = $k[--$j];
      $k[$j - 1] = _P5;
      var _P7 = $k[--$j];
      $k[$j - 1] = _P7;
    }
    $search($k[--$j], "?");
    if (!$k[--$j]) {
      var _PB = $k[--$j];
      $k[$j++] = "";
      $k[$j++] = null;
      $k[$j++] = _PB;
    }
    $_.pp = $k[--$j];
    $j--;
    $_.qp = $k[--$j];
    $k[$j++] = Infinity;
    $k[$j++] = 0;
    $k[$j++] = 0;
    $k[$j++] = $_.pp;
    for (; ; ) {
      $search($k[--$j], "/");
      if (!$k[--$j]) {
        $j--;
        break;
      }
      var _PH = $k[--$j];
      $k[$j - 1] = _PH.length + 1;
      var _PJ = $k[--$j];
      var _PK = $k[--$j];
      var _PL = $k[$j - 1];
      $k[$j++] = $f(_PJ + _PL);
      $k[$j++] = _PK;
    }
    $astore($a($counttomark() - 1));
    $_.pipos = $k[--$j];
    $j -= 2;
    if ($_.pipos.length <= 1) {
      $k[$j++] = "bwipp.GS1dlNoAIinfo#2550";
      $k[$j++] = "The path was too short to contain AI info";
      bwipp_raiseerror();
    }
    $k[$j++] = false;
    for (var _PR = $_.pipos.length - 2; _PR >= 0; _PR -= 2) {
      var _PT = $get($_.pipos, _PR);
      var _PX = $geti($_.pp, _PT, $f($get($_.pipos, _PR + 1) - _PT) - 1);
      var _PZ = $get($_.gs1syntax, _PX) !== void 0;
      $k[$j++] = _PR;
      $k[$j++] = _PX;
      if (_PZ) {
        var _Pd = $get($get($_.gs1syntax, $k[--$j]), "dlpkey") !== void 0;
        if (_Pd) {
          var _Pe = $k[--$j];
          $k[$j - 1] = _Pe;
          $k[$j++] = true;
          break;
        }
      } else {
        $j--;
      }
      $j--;
    }
    if (!$k[--$j]) {
      $k[$j++] = "bwipp.GS1dlNoAIinfo#2569";
      $k[$j++] = "The path does not contain a valid primary key";
      bwipp_raiseerror();
    }
    var _Pj = $get($_.pipos, $k[--$j]);
    $_.pp = $geti($_.pp, _Pj, $f($_.pp.length - _Pj));
    $_.uriunescape = function() {
      $_.qq = $k[--$j];
      $_.in = $k[--$j];
      $_.out = $s($_.in.length);
      $k[$j++] = 0;
      $k[$j++] = 0;
      for (; ; ) {
        var _Ps = $k[$j - 2];
        if (_Ps >= $_.in.length) {
          break;
        }
        var _Pw = $k[$j - 2];
        var _Px = $get($_.in, _Pw);
        $k[$j++] = _Px;
        if (_Px == 43 && $_.qq) {
          $j--;
          var _Q0 = $k[--$j];
          $put($_.out, _Q0, 32);
          var _Q1 = $k[--$j];
          $k[$j++] = _Q1 + 1;
          $k[$j++] = _Q0 + 1;
        } else {
          var _Q2 = $k[$j - 1];
          var _Q4 = $k[$j - 3];
          if (_Q2 == 37 && _Q4 < $_.in.length - 2) {
            $j--;
            var _Q8 = $k[$j - 2];
            var _Q9 = $geti($_.in, _Q8 + 1, 2);
            $k[$j++] = 0;
            for (var _QA = 0, _QB = _Q9.length; _QA < _QB; _QA++) {
              var _QC = $get(_Q9, _QA);
              $k[$j++] = _QC;
              if (_QC >= 48 && _QC <= 57) {
                var _QD = $k[--$j];
                $k[$j++] = _QD - 48;
              } else {
                var _QE = $k[$j - 1];
                if (_QE >= 65 && _QE <= 70) {
                  var _QF = $k[--$j];
                  $k[$j++] = _QF - 55;
                } else {
                  var _QG = $k[$j - 1];
                  if (_QG >= 97 && _QG <= 102) {
                    var _QH = $k[--$j];
                    $k[$j++] = _QH - 87;
                  } else {
                    $j -= 2;
                    $k[$j++] = "bwipp.GS1dlBadHexCharacter#2590";
                    $k[$j++] = "Invalid hex character";
                    bwipp_raiseerror();
                  }
                }
              }
              var _QI = $k[--$j];
              var _QJ = $k[--$j];
              $k[$j++] = $f(_QI + _QJ * 16);
            }
            var _QL = $k[--$j];
            var _QM = $k[--$j];
            $put($_.out, _QM, _QL);
            var _QN = $k[--$j];
            $k[$j++] = _QN + 3;
            $k[$j++] = _QM + 1;
          } else {
            var _QP = $k[--$j];
            var _QQ = $k[--$j];
            $put($_.out, _QQ, _QP);
            var _QR = $k[--$j];
            $k[$j++] = _QR + 1;
            $k[$j++] = _QQ + 1;
          }
        }
      }
      $_.out = $geti($_.out, 0, $k[--$j]);
      $k[$j - 1] = $_.out;
    };
    $_.isvaliddlpkeyseq = function() {
      $_.in = $k[--$j];
      $k[$j++] = false;
      $forall($get($get($_.gs1syntax, $get($_.in, 0)), "dlpkey"), function() {
        $_.seq = $k[--$j];
        $_.i = 1;
        $_.j = 0;
        for (; ; ) {
          if ($_.i >= $_.in.length) {
            break;
          }
          if ($_.j >= $_.seq.length) {
            break;
          }
          if ($eq($get($_.in, $_.i), $get($_.seq, $_.j))) {
            $_.i = $_.i + 1;
          }
          $_.j = $_.j + 1;
        }
        if ($_.i == $_.in.length) {
          $k[$j - 1] = true;
          return true;
        }
      });
    };
    $_.ais = $a(99);
    $_.vals = $a(99);
    $k[$j++] = 0;
    $k[$j++] = $_.pp;
    for (; ; ) {
      $search($k[--$j], "/");
      if ($k[--$j]) {
        var _Qx = $k[--$j];
        $j--;
        var _Qz = $k[--$j];
        var _R0 = $k[$j - 1];
        $put($_.ais, _R0, _Qx);
        $search(_Qz, "/");
        if ($k[--$j]) {
          var _R2 = $k[--$j];
          $k[$j - 1] = _R2;
        } else {
          var _R4 = $k[--$j];
          $k[$j++] = "";
          $k[$j++] = _R4;
        }
        var _R6 = $k[--$j];
        var _R8 = $k[$j - 2];
        $k[$j++] = $_.vals;
        $k[$j++] = _R8;
        $k[$j++] = _R6;
        $k[$j++] = false;
        $_.uriunescape();
        var _R9 = $k[--$j];
        var _RA = $k[--$j];
        $put($k[--$j], _RA, _R9);
      } else {
        $j--;
        break;
      }
      var _RC = $k[--$j];
      var _RD = $k[--$j];
      $k[$j++] = _RD + 1;
      $k[$j++] = _RC;
    }
    var _RE = $k[--$j];
    $_.plen = _RE;
    $k[$j++] = _RE;
    if (_RE > 1) {
      $k[$j++] = $geti($_.ais, 0, $_.plen);
      $_.isvaliddlpkeyseq();
      if (!$k[--$j]) {
        $j--;
        $k[$j++] = "bwipp.GS1dlBadPathInfo#2645";
        $k[$j++] = "The AIs in the path are not a valid key-qualifier sequence for the key";
        bwipp_raiseerror();
      }
    }
    $k[$j++] = $_.qp;
    for (; ; ) {
      var _RK = $k[$j - 1];
      if (_RK.length == 0) {
        $j--;
        break;
      }
      $search($k[--$j], "&");
      if ($k[--$j]) {
        var _RN = $k[--$j];
        $k[$j - 1] = _RN;
      } else {
        var _RP = $k[--$j];
        $k[$j++] = "";
        $k[$j++] = _RP;
      }
      $search($k[--$j], "=");
      if ($k[--$j]) {
        var _RS = $k[$j - 1];
        $k[$j++] = true;
        $forall(_RS, function() {
          var _RT = $k[--$j];
          var _RU = $k[--$j];
          $k[$j++] = _RU && (_RT >= 48 && _RT <= 57);
        });
        if ($k[--$j]) {
          var _RX = $k[--$j];
          $j--;
          var _RZ = $k[--$j];
          var _Rb = $k[$j - 2];
          $put($_.ais, _Rb, _RX);
          $k[$j++] = $_.vals;
          $k[$j++] = _Rb;
          $k[$j++] = _RZ;
          $k[$j++] = true;
          $_.uriunescape();
          var _Rd = $k[--$j];
          var _Re = $k[--$j];
          $put($k[--$j], _Re, _Rd);
          var _Rg = $k[--$j];
          var _Rh = $k[--$j];
          $k[$j++] = _Rh + 1;
          $k[$j++] = _Rg;
        } else {
          $j -= 3;
        }
      } else {
        $j--;
      }
    }
    var _Rk = $k[$j - 1];
    var _Rm = $geti($_.ais, $_.plen, $f(_Rk - $_.plen));
    for (var _Rn = 0, _Ro = _Rm.length; _Rn < _Ro; _Rn++) {
      var _Rp = $get(_Rm, _Rn);
      var _Rr = $get($_.gs1syntax, _Rp) !== void 0;
      $k[$j++] = _Rp;
      if (_Rr) {
        var _Rt = $k[$j - 1];
        var _Ru = $get($_.gs1syntax, _Rt);
        var _Rv = $get(_Ru, "dlattr") !== void 0;
        $k[$j++] = _Ru;
        $k[$j++] = "dlattr";
        if (_Rv) {
          var _Rw = $k[--$j];
          var _Ry = $get($k[--$j], _Rw);
          $k[$j++] = _Ry;
        } else {
          $j -= 2;
          $k[$j++] = true;
        }
      } else {
        $k[$j++] = $_.dontlint;
      }
      if (!$k[--$j]) {
        var _S1 = $k[$j - 1];
        var _S2 = _S1.length;
        var _S3 = $s(_S2 + 46);
        $puti(_S3, 0, "AI (");
        $puti(_S3, 4, _S1);
        $puti(_S3, _S2 + 4, ") is not a valid GS1 DL URI data attribute");
        $k[$j++] = _S3;
        var _S4 = $k[--$j];
        $k[$j - 1] = _S4;
        var _S6 = $k[--$j];
        $k[$j++] = "bwipp.GS1dlInvalidDataAttribute#2679";
        $k[$j++] = _S6;
        bwipp_raiseerror();
      }
      $j--;
    }
    var _S9 = $k[$j - 1];
    var _SB = $geti($_.ais, $_.plen, $f(_S9 - $_.plen));
    for (var _SC = 0, _SD = _SB.length; _SC < _SD; _SC++) {
      $k[$j++] = $get(_SB, _SC);
      for (var _SG = $_.plen; _SG >= 1; _SG -= 1) {
        var _SH = $k[$j - 1];
        $k[$j++] = _SG;
        $k[$j++] = _SH;
        $k[$j++] = Infinity;
        $aload($geti($_.ais, 0, $_.plen));
        $r($counttomark() + 3, -2);
        var _SM = $k[--$j];
        var _SN = $k[--$j];
        $k[$j++] = _SM;
        $r(_SN, 1);
        var _SO = $a();
        $k[$j++] = _SO;
        $_.isvaliddlpkeyseq();
        if ($k[--$j]) {
          var _SQ = $k[--$j];
          $k[$j - 1] = _SQ;
          var _SS = $k[$j - 1];
          var _ST = _SS.length;
          var _SU = $s(_ST + 50);
          $puti(_SU, 0, "AI (");
          $puti(_SU, 4, _SS);
          $puti(_SU, _ST + 4, ") from query params should be in the path info");
          $k[$j++] = _SU;
          var _SV = $k[--$j];
          $k[$j - 1] = _SV;
          var _SX = $k[--$j];
          $k[$j++] = "bwipp.GS1dlAttributeMustBeQualifier#2696";
          $k[$j++] = _SX;
          bwipp_raiseerror();
        }
      }
      $j--;
    }
    var _SZ = $k[--$j];
    $_.ais = $geti($_.ais, 0, _SZ);
    $_.vals = $geti($_.vals, 0, _SZ);
    for (var _Sf = 0, _Se = $_.ais.length - 1; _Sf <= _Se; _Sf += 1) {
      $k[$j++] = _Sf;
      if ($eq($get($_.ais, _Sf), "01")) {
        var _Si = $k[$j - 1];
        var _Sk = $get($_.vals, _Si);
        var _Sl = _Sk.length;
        $k[$j++] = _Sk;
        if (_Sl == 8 || (_Sl == 12 || _Sl == 13)) {
          var _Sn = $strcpy($s(14), "00000000000000");
          $k[$j++] = _Sn;
          $k[$j++] = _Sn;
          var _So = $k[$j - 3];
          $puti($k[$j - 1], 14 - _So.length, _So);
          var _Sr = $k[$j - 2];
          $j -= 3;
          var _Ss = $k[$j - 1];
          $put($_.vals, _Ss, _Sr);
        } else {
          $j--;
        }
      }
      $j--;
    }
  }
  $k[$j++] = Infinity;
  var _St = $a(["00", "01", "02", "03", "04", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "31", "32", "33", "34", "35", "36", "41"]);
  for (var _Su = 0, _Sv = _St.length; _Su < _Sv; _Su++) {
    var _Sw = $get(_St, _Su);
    $k[$j++] = _Sw;
    $k[$j++] = _Sw;
  }
  $_.aifixed = $d();
  $k[$j++] = Infinity;
  var _Sz = $_.ais;
  for (var _T0 = 0, _T1 = _Sz.length; _T0 < _T1; _T0++) {
    var _T2 = $get(_Sz, _T0);
    $k[$j++] = true;
    $k[$j++] = _T2;
    if (_T2.length >= 2) {
      var _T6 = $get($_.aifixed, $geti($k[--$j], 0, 2)) !== void 0;
      if (_T6) {
        $k[$j - 1] = false;
      }
    } else {
      $j--;
    }
  }
  $_.fncs = $a();
  $k[$j++] = Infinity;
  $k[$j++] = 0;
  for (var _T8 = 0, _T9 = `!"%&'()*+,-./0123456789:;<=>?ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz`.length; _T8 < _T9; _T8++) {
    var _TB = $k[--$j];
    $k[$j++] = $get(`!"%&'()*+,-./0123456789:;<=>?ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz`, _T8);
    $k[$j++] = _TB;
    $k[$j++] = _TB + 1;
  }
  $j--;
  $_.cset82 = $d();
  $k[$j++] = Infinity;
  $k[$j++] = 0;
  for (var _TD = 0, _TE = "#-/0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ".length; _TD < _TE; _TD++) {
    var _TG = $k[--$j];
    $k[$j++] = $get("#-/0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ", _TD);
    $k[$j++] = _TG;
    $k[$j++] = _TG + 1;
  }
  $j--;
  $_.cset39 = $d();
  $k[$j++] = Infinity;
  $k[$j++] = 0;
  for (var _TI = 0, _TJ = "23456789ABCDEFGHJKLMNPQRSTUVWXYZ".length; _TI < _TJ; _TI++) {
    var _TL = $k[--$j];
    $k[$j++] = $get("23456789ABCDEFGHJKLMNPQRSTUVWXYZ", _TI);
    $k[$j++] = _TL;
    $k[$j++] = _TL + 1;
  }
  $j--;
  $_.cset32 = $d();
  $k[$j++] = Infinity;
  $k[$j++] = 0;
  for (var _TN = 0, _TO = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".length; _TN < _TO; _TN++) {
    var _TQ = $k[--$j];
    $k[$j++] = $get("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", _TN);
    $k[$j++] = _TQ;
    $k[$j++] = _TQ + 1;
  }
  $j--;
  $_.cset64 = $d();
  $_.lintnumeric = function() {
    var _TT = $k[--$j];
    $k[$j++] = true;
    $forall(_TT, function() {
      var _TU = $k[--$j];
      if (_TU < 48 || _TU > 57) {
        $k[$j - 1] = false;
        return true;
      }
    });
    if (!$k[--$j]) {
      $j--;
      $k[$j++] = "bwipp.GS1notNumeric#2770";
      $k[$j++] = "Not numeric";
      $k[$j++] = false;
      return true;
    }
  };
  $_.lintcset82 = function() {
    var _TW = $k[--$j];
    $k[$j++] = true;
    $forall(_TW, function() {
      var _TZ = $get($_.cset82, $k[--$j]) !== void 0;
      if (!_TZ) {
        $k[$j - 1] = false;
        return true;
      }
    });
    if (!$k[--$j]) {
      $j--;
      $k[$j++] = "bwipp.GS1badCSET82character#2775";
      $k[$j++] = "Invalid CSET 82 character";
      $k[$j++] = false;
      return true;
    }
  };
  $_.lintcset39 = function() {
    var _Tb = $k[--$j];
    $k[$j++] = true;
    $forall(_Tb, function() {
      var _Te = $get($_.cset39, $k[--$j]) !== void 0;
      if (!_Te) {
        $k[$j - 1] = false;
        return true;
      }
    });
    if (!$k[--$j]) {
      $j--;
      $k[$j++] = "bwipp.GS1badCSET39character#2780";
      $k[$j++] = "Invalid CSET 39 character";
      $k[$j++] = false;
      return true;
    }
  };
  $_.lintcset64 = function() {
    var _Tg = $k[$j - 1];
    $search(_Tg, "=");
    if ($k[--$j]) {
      var _Ti = $k[--$j];
      $k[$j - 1] = _Ti;
      var _Tk = $k[--$j];
      $k[$j++] = _Tk.length % 3;
      $k[$j++] = _Tk;
      var _Tl = $k[$j - 2];
      var _Tm = $k[$j - 3];
      $k[$j - 3] = $k[$j - 1];
      $j -= 2;
      $k[$j++] = _Tm;
      $k[$j++] = _Tl;
      $k[$j++] = false;
      if (_Tl == 1 && $eq(_Tm, "=")) {
        $k[$j - 1] = true;
      }
      var _To = $k[$j - 2];
      var _Tp = $k[$j - 3];
      if (_To == 2 && _Tp.length == 0) {
        $k[$j - 1] = true;
      }
      if (!$k[--$j]) {
        $j -= 5;
        $k[$j++] = "bwipp.GS1badCSET64padding#2789";
        $k[$j++] = "Invalid CSET 64 padding";
        $k[$j++] = false;
        return true;
      }
      $j -= 2;
      var _Tr = $k[--$j];
      var _Ts = $k[--$j];
      $k[$j++] = _Tr;
      $k[$j++] = _Ts;
    }
    $j--;
    var _Tt = $k[--$j];
    $k[$j++] = true;
    $forall(_Tt, function() {
      var _Tw = $get($_.cset64, $k[--$j]) !== void 0;
      if (!_Tw) {
        $k[$j - 1] = false;
        return true;
      }
    });
    if (!$k[--$j]) {
      $j--;
      $k[$j++] = "bwipp.GS1badCSET64character#2795";
      $k[$j++] = "Invalid CSET 64 character";
      $k[$j++] = false;
      return true;
    }
  };
  $_.lintgcppos1 = function() {
    var _Ty = $k[$j - 1];
    if (_Ty.length < 2) {
      $j -= 2;
      $k[$j++] = "bwipp.GS1gcpTooShort#2799";
      $k[$j++] = "Value is too short to contain a GS1 Company Prefix";
      $k[$j++] = false;
      return true;
    }
    var _Tz = $k[--$j];
    var _U0 = $get(_Tz, 0);
    var _U1 = $get(_Tz, 1);
    if (_U0 < 48 || _U0 > 57 || (_U1 < 48 || _U1 > 57)) {
      $j--;
      $k[$j++] = "bwipp.GS1badGCP#2802";
      $k[$j++] = "Non-numeric GS1 Company Prefix";
      $k[$j++] = false;
      return true;
    }
  };
  $_.lintgcppos2 = function() {
    var _U2 = $k[$j - 1];
    if (_U2.length < 1) {
      $j -= 2;
      $k[$j++] = "bwipp.GS1valueTooShortForOffsetGCP#2807";
      $k[$j++] = "Value is too short to contain an offset GS1 Company Prefix";
      $k[$j++] = false;
      return true;
    }
    var _U3 = $k[--$j];
    $k[$j++] = $geti(_U3, 1, _U3.length - 1);
    $_.lintgcppos1();
  };
  $_.lintimporteridx = function() {
    $search("-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz", $k[--$j]);
    if (!$k[--$j]) {
      $j -= 2;
      $k[$j++] = "bwipp.GS1badImporterIndex#2813";
      $k[$j++] = "Invalid importer index";
      $k[$j++] = false;
      return true;
    }
    $j -= 3;
  };
  $_.lintcsum = function() {
    $k[$j++] = Infinity;
    var _U7 = $k[--$j];
    var _U8 = $k[--$j];
    var _U9 = _U8.length % 2 == 0 ? 3 : 1;
    $k[$j++] = _U7;
    $k[$j++] = _U9;
    $forall(_U8, function() {
      var _UA = $k[--$j];
      var _UB = $k[--$j];
      $k[$j++] = (_UA - 48) * _UB;
      $k[$j++] = 4 - _UB;
    });
    $j--;
    var _UC = $counttomark() + 1;
    $k[$j++] = 0;
    for (var _UD = 0, _UE = _UC - 1; _UD < _UE; _UD++) {
      var _UF = $k[--$j];
      var _UG = $k[--$j];
      $k[$j++] = $f(_UG + _UF);
    }
    var _UH = $k[--$j];
    $k[$j - 1] = _UH;
    if ($k[--$j] % 10 != 0) {
      $j--;
      $k[$j++] = "bwipp.GS1badChecksum#2822";
      $k[$j++] = "Bad checksum";
      $k[$j++] = false;
      return true;
    }
  };
  $_.lintcsumalpha = function() {
    var _UK = $k[$j - 1];
    if (_UK.length < 2) {
      $j -= 2;
      $k[$j++] = "bwipp.GS1alphaTooShort#2826";
      $k[$j++] = "Alphanumeric string is too short to check";
      $k[$j++] = false;
      return true;
    }
    var _UL = $k[$j - 1];
    $k[$j++] = _UL.length - 2;
    var _UN = Infinity;
    var _UO = $geti(_UL, 0, _UL.length - 2);
    $k[$j++] = _UN;
    $forall(_UO, function() {
      var _UP = $k[$j - 1];
      var _UR = $get($_.cset82, _UP) !== void 0;
      if (_UR) {
        var _UU = $get($_.cset82, $k[--$j]);
        $k[$j++] = _UU;
      } else {
        $k[$j++] = -1;
        return true;
      }
    });
    var _UV = $k[$j - 1];
    if (_UV == -1) {
      $cleartomark();
      $j -= 3;
      $k[$j++] = "bwipp.GS1UnknownCSET82Character#2832";
      $k[$j++] = "Unknown CSET 82 character";
      $k[$j++] = false;
      return true;
    }
    $astore($a($counttomark()));
    var _UY = $k[--$j];
    $k[$j - 1] = _UY;
    var _Ua = $k[$j - 2];
    var _Uc = $geti($k[$j - 3], _Ua, 2);
    $k[$j - 3] = $k[$j - 1];
    $j -= 2;
    var _Ud = Infinity;
    var _Ue = _Uc;
    $k[$j++] = _Ud;
    $forall(_Ue, function() {
      var _Uf = $k[$j - 1];
      var _Uh = $get($_.cset32, _Uf) !== void 0;
      if (_Uh) {
        var _Uk = $get($_.cset32, $k[--$j]);
        $k[$j++] = _Uk;
      } else {
        $k[$j++] = -1;
        return true;
      }
    });
    var _Ul = $k[$j - 1];
    if (_Ul == -1) {
      $cleartomark();
      $j -= 2;
      $k[$j++] = "bwipp.GS1UnknownCSET32Character#2838";
      $k[$j++] = "Unknown CSET 32 character";
      $k[$j++] = false;
      return true;
    }
    $astore($a($counttomark()));
    var _Uo = $k[--$j];
    $k[$j - 1] = _Uo;
    var _Uq = $k[--$j];
    var _Ut = $k[--$j];
    var _Uu = $a([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83]);
    var _Uv = _Ut.length;
    $k[$j++] = $f(($get(_Uq, 0) << 5) + $get(_Uq, 1));
    $k[$j++] = _Ut;
    $k[$j++] = _Uu;
    $k[$j++] = _Uv;
    if (_Uv > _Uu.length) {
      $j -= 5;
      $k[$j++] = "bwipp.GS1alphaTooLong#2843";
      $k[$j++] = "Alphanumeric string is too long to check";
      $k[$j++] = false;
      return true;
    }
    var _Uw = $k[--$j];
    var _Uy = $geti($k[--$j], 0, _Uw);
    for (var _Uz = 0, _V0 = _Uy.length; _Uz < _V0; _Uz++) {
      var _V2 = $k[--$j];
      $k[$j++] = $get(_Uy, _Uz);
      $k[$j++] = _V2;
    }
    var _V3 = $k[--$j];
    $k[$j++] = 0;
    $forall(_V3, function() {
      var _V4 = $k[$j - 3];
      var _V5 = $k[$j - 1];
      var _V6 = $k[$j - 2];
      $j -= 3;
      $k[$j++] = $f(_V6 + _V4 * _V5);
    });
    var _V7 = $k[--$j];
    if ($k[--$j] != _V7 % 1021) {
      $j--;
      $k[$j++] = "bwipp.GS1badAlphaCheckCharacters#2846";
      $k[$j++] = "Bad alphanumeric check characters";
      $k[$j++] = false;
      return true;
    }
  };
  $k[$j++] = Infinity;
  var _V9 = $a(["004", "008", "010", "012", "016", "020", "024", "028", "031", "032", "036", "040", "044", "048", "050", "051", "052", "056", "060", "064", "068", "070", "072", "074", "076", "084", "086", "090", "092", "096", "100", "104", "108", "112", "116", "120", "124", "132", "136", "140", "144", "148", "152", "156", "158", "162", "166", "170", "174", "175", "178", "180", "184", "188", "191", "192", "196", "203", "204", "208", "212", "214", "218", "222", "226", "231", "232", "233", "234", "238", "239", "242", "246", "248", "250", "254", "258", "260", "262", "266", "268", "270", "275", "276", "288", "292", "296", "300", "304", "308", "312", "316", "320", "324", "328", "332", "334", "336", "340", "344", "348", "352", "356", "360", "364", "368", "372", "376", "380", "384", "388", "392", "398", "400", "404", "408", "410", "414", "417", "418", "422", "426", "428", "430", "434", "438", "440", "442", "446", "450", "454", "458", "462", "466", "470", "474", "478", "480", "484", "492", "496", "498", "499", "500", "504", "508", "512", "516", "520", "524", "528", "531", "533", "534", "535", "540", "548", "554", "558", "562", "566", "570", "574", "578", "580", "581", "583", "584", "585", "586", "591", "598", "600", "604", "608", "612", "616", "620", "624", "626", "630", "634", "638", "642", "643", "646", "652", "654", "659", "660", "662", "663", "666", "670", "674", "678", "682", "686", "688", "690", "694", "702", "703", "704", "705", "706", "710", "716", "724", "728", "729", "732", "740", "744", "748", "752", "756", "760", "762", "764", "768", "772", "776", "780", "784", "788", "792", "795", "796", "798", "800", "804", "807", "818", "826", "831", "832", "833", "834", "840", "850", "854", "858", "860", "862", "876", "882", "887", "894"]);
  for (var _VA = 0, _VB = _V9.length; _VA < _VB; _VA++) {
    var _VC = $get(_V9, _VA);
    $k[$j++] = _VC;
    $k[$j++] = _VC;
  }
  $_.iso3166 = $d();
  $_.lintiso3166 = function() {
    var _VH = $get($_.iso3166, $k[--$j]) !== void 0;
    if (!_VH) {
      $j--;
      $k[$j++] = "bwipp.GS1UnknownCountry#2873";
      $k[$j++] = "Unknown country code";
      $k[$j++] = false;
      return true;
    }
  };
  $_.lintiso3166999 = function() {
    var _VI = $k[$j - 1];
    if ($ne(_VI, "999")) {
      var _VL = $get($_.iso3166, $k[--$j]) !== void 0;
      if (!_VL) {
        $j--;
        $k[$j++] = "bwipp.GS1UnknownCountryOr999#2878";
        $k[$j++] = "Unknown country code or not 999";
        $k[$j++] = false;
        return true;
      }
    } else {
      $j--;
    }
  };
  $k[$j++] = Infinity;
  var _VM = $a(["AD", "AE", "AF", "AG", "AI", "AL", "AM", "AO", "AQ", "AR", "AS", "AT", "AU", "AW", "AX", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BL", "BM", "BN", "BO", "BQ", "BR", "BS", "BT", "BV", "BW", "BY", "BZ", "CA", "CC", "CD", "CF", "CG", "CH", "CI", "CK", "CL", "CM", "CN", "CO", "CR", "CU", "CV", "CW", "CX", "CY", "CZ", "DE", "DJ", "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER", "ES", "ET", "FI", "FJ", "FK", "FM", "FO", "FR", "GA", "GB", "GD", "GE", "GF", "GG", "GH", "GI", "GL", "GM", "GN", "GP", "GQ", "GR", "GS", "GT", "GU", "GW", "GY", "HK", "HM", "HN", "HR", "HT", "HU", "ID", "IE", "IL", "IM", "IN", "IO", "IQ", "IR", "IS", "IT", "JE", "JM", "JO", "JP", "KE", "KG", "KH", "KI", "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS", "LT", "LU", "LV", "LY", "MA", "MC", "MD", "ME", "MF", "MG", "MH", "MK", "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA", "NC", "NE", "NF", "NG", "NI", "NL", "NO", "NP", "NR", "NU", "NZ", "OM", "PA", "PE", "PF", "PG", "PH", "PK", "PL", "PM", "PN", "PR", "PS", "PT", "PW", "PY", "QA", "RE", "RO", "RS", "RU", "RW", "SA", "SB", "SC", "SD", "SE", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SR", "SS", "ST", "SV", "SX", "SY", "SZ", "TC", "TD", "TF", "TG", "TH", "TJ", "TK", "TL", "TM", "TN", "TO", "TR", "TT", "TV", "TW", "TZ", "UA", "UG", "UM", "US", "UY", "UZ", "VA", "VC", "VE", "VG", "VI", "VN", "VU", "WF", "WS", "YE", "YT", "ZA", "ZM", "ZW"]);
  for (var _VN = 0, _VO = _VM.length; _VN < _VO; _VN++) {
    var _VP = $get(_VM, _VN);
    $k[$j++] = _VP;
    $k[$j++] = _VP;
  }
  $_.iso3166alpha2 = $d();
  $_.lintiso3166alpha2 = function() {
    var _VU = $get($_.iso3166alpha2, $k[--$j]) !== void 0;
    if (!_VU) {
      $j--;
      $k[$j++] = "bwipp.GS1UnknownCountryAlpha#2914";
      $k[$j++] = "Unknown country alpha code";
      $k[$j++] = false;
      return true;
    }
  };
  $k[$j++] = Infinity;
  var _VV = $a(["008", "012", "032", "036", "044", "048", "050", "051", "052", "060", "064", "068", "072", "084", "090", "096", "104", "108", "116", "124", "132", "136", "144", "152", "156", "170", "174", "188", "191", "192", "203", "208", "214", "222", "230", "232", "238", "242", "262", "270", "292", "320", "324", "328", "332", "340", "344", "348", "352", "356", "360", "364", "368", "376", "388", "392", "396", "398", "400", "404", "408", "410", "414", "417", "418", "422", "426", "430", "434", "446", "454", "458", "462", "480", "484", "496", "498", "504", "512", "516", "524", "532", "533", "548", "554", "558", "566", "578", "586", "590", "598", "600", "604", "608", "634", "643", "646", "654", "682", "690", "694", "702", "704", "706", "710", "728", "748", "752", "756", "760", "764", "776", "780", "784", "788", "800", "807", "818", "826", "834", "840", "858", "860", "882", "886", "901", "925", "927", "928", "929", "930", "931", "932", "933", "934", "936", "938", "940", "941", "943", "944", "946", "947", "948", "949", "950", "951", "952", "953", "955", "956", "957", "958", "959", "960", "961", "962", "963", "964", "965", "967", "968", "969", "970", "971", "972", "973", "975", "976", "977", "978", "979", "980", "981", "984", "985", "986", "990", "994", "997", "999"]);
  for (var _VW = 0, _VX = _VV.length; _VW < _VX; _VW++) {
    var _VY = $get(_VV, _VW);
    $k[$j++] = _VY;
    $k[$j++] = _VY;
  }
  $_.iso4217 = $d();
  $_.lintiso4217 = function() {
    var _Vd = $get($_.iso4217, $k[--$j]) !== void 0;
    if (!_Vd) {
      $j--;
      $k[$j++] = "bwipp.GS1UnknownCurrency#2945";
      $k[$j++] = "Unknown currency code";
      $k[$j++] = false;
      return true;
    }
  };
  $_.lintiso5218 = function() {
    var _Ve = $k[--$j];
    if ($ne(_Ve, "0") && ($ne(_Ve, "1") && ($ne(_Ve, "2") && $ne(_Ve, "9")))) {
      $j--;
      $k[$j++] = "bwipp.GS1biologicalSexCode#2950";
      $k[$j++] = "Invalid biological sex code";
      $k[$j++] = false;
      return true;
    }
  };
  $_.lintiban = function() {
    var _Vf = $k[$j - 1];
    if (_Vf.length <= 4) {
      $j -= 2;
      $k[$j++] = "bwipp.GS1tooShort#2955";
      $k[$j++] = "IBAN too short";
      $k[$j++] = false;
      return true;
    }
    var _Vg = $k[$j - 1];
    $k[$j++] = true;
    $forall(_Vg, function() {
      var _Vh = $s(1);
      $k[$j++] = _Vh;
      $k[$j++] = _Vh;
      $k[$j++] = 0;
      $r(4, -1);
      var _Vi = $k[--$j];
      var _Vj = $k[--$j];
      $put($k[--$j], _Vj, _Vi);
      $search("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ", $k[--$j]);
      if (!$k[--$j]) {
        $j -= 2;
        $k[$j++] = false;
        return true;
      }
      $j -= 3;
    });
    if (!$k[--$j]) {
      $j--;
      $k[$j++] = "bwipp.GS1badIBANcharacter#2962";
      $k[$j++] = "Invalid IBAN character";
      $k[$j++] = false;
      return true;
    }
    var _Vo = $k[$j - 1];
    var _Vp = Infinity;
    var _Vq = _Vo;
    $k[$j++] = _Vp;
    var _Vr = Infinity;
    var _Vs = _Vq;
    $k[$j++] = _Vr;
    $forall(_Vs);
    $r($counttomark(), -4);
    $astore($a($counttomark()));
    var _Vw = $k[--$j];
    $k[$j - 1] = _Vw;
    $forall($k[--$j], function() {
      var _W0 = $k[--$j] - 48;
      $k[$j++] = _W0;
      if (_W0 > 9) {
        var _W2 = $k[--$j] - 7;
        $k[$j++] = ~~(_W2 / 10);
        $k[$j++] = _W2 % 10;
      }
    });
    $astore($a($counttomark()));
    var _W5 = $k[--$j];
    $k[$j - 1] = _W5;
    var _W7 = $k[--$j];
    $k[$j++] = 0;
    $forall(_W7, function() {
      var _W8 = $k[--$j];
      var _W9 = $k[--$j];
      $k[$j++] = $f(_W8 + _W9 * 10) % 97;
    });
    if ($k[--$j] != 1) {
      $j -= 2;
      $k[$j++] = "bwipp.GS1badIBANchecksum#2967";
      $k[$j++] = "IBAN checksum incorrect";
      $k[$j++] = false;
      return true;
    }
    var _WC = $geti($k[--$j], 0, 2);
    $k[$j++] = _WC;
    $_.lintiso3166alpha2();
  };
  $_.lintzero = function() {
    if ($ne($k[--$j], "0")) {
      $j--;
      $k[$j++] = "bwipp.GS1zeroRequired#2972";
      $k[$j++] = "Zero is required";
      $k[$j++] = false;
      return true;
    }
  };
  $_.lintnonzero = function() {
    var _WE = $k[--$j];
    $k[$j++] = false;
    $forall(_WE, function() {
      if ($k[--$j] != 48) {
        $k[$j - 1] = true;
      }
    });
    if (!$k[--$j]) {
      $j--;
      $k[$j++] = "bwipp.GS1zeroNotPermitted#2977";
      $k[$j++] = "Zero not permitted";
      $k[$j++] = false;
      return true;
    }
  };
  $_.lintnozeroprefix = function() {
    var _WH = $k[--$j];
    if (_WH.length > 1 && $get(_WH, 0) == 48) {
      $j--;
      $k[$j++] = "bwipp.GS1badZeroPrefix#2982";
      $k[$j++] = "Zero prefix is not permitted";
      $k[$j++] = false;
      return true;
    }
  };
  $_.linthasnondigit = function() {
    var _WJ = $k[--$j];
    $k[$j++] = false;
    $forall(_WJ, function() {
      var _WK = $k[--$j];
      if (_WK < 48 || _WK > 57) {
        $k[$j - 1] = true;
        return true;
      }
    });
    if (!$k[--$j]) {
      $k[$j++] = "bwipp.GS1requiresNonDigit#2988";
      $k[$j++] = "A non-digit character is required";
      $k[$j++] = false;
      return true;
    }
  };
  $_.linthyphen = function() {
    if ($ne($k[--$j], "-")) {
      $j--;
      $k[$j++] = "bwipp.GS1hyphenRequired#2992";
      $k[$j++] = "A hyphen is required";
      $k[$j++] = false;
      return true;
    }
  };
  $_.lintyyyymmd0 = function() {
    var _WN = $k[$j - 1];
    var _WP = $cvi($geti(_WN, 4, 2));
    if (_WP < 1 || _WP > 12) {
      $j--;
      $k[$j++] = "bwipp.GS1badMonth#2996";
      $k[$j++] = "Invalid month";
      $k[$j++] = false;
      return true;
    }
    var _WQ = $k[$j - 1];
    var _WS = $cvi($geti(_WQ, 0, 4));
    $k[$j++] = _WS % 400 == 0 || _WS % 4 == 0 && _WS % 100 != 0;
    $k[$j++] = Infinity;
    $k[$j++] = 31;
    $r(3, -1);
    var _WU = $k[--$j] ? 29 : 28;
    $k[$j++] = _WU;
    $k[$j++] = 31;
    $k[$j++] = 30;
    $k[$j++] = 31;
    $k[$j++] = 30;
    $k[$j++] = 31;
    $k[$j++] = 31;
    $k[$j++] = 30;
    $k[$j++] = 31;
    $k[$j++] = 30;
    $k[$j++] = 31;
    var _WV = $a();
    var _WW = $k[--$j];
    if ($get(_WV, $cvi($geti(_WW, 4, 2)) - 1) < $cvi($geti(_WW, 6, 2))) {
      $j--;
      $k[$j++] = "bwipp.GS1badDay#3000";
      $k[$j++] = "Invalid day of month";
      $k[$j++] = false;
      return true;
    }
  };
  $_.lintyyyymmdd = function() {
    var _Wa = $k[$j - 1];
    if (_Wa.length != 8) {
      $j--;
      $k[$j++] = "bwipp.GS1badDateLength#3004";
      $k[$j++] = "Invalid length for yyyymmdd date";
      $k[$j++] = false;
      return true;
    }
    var _Wb = $k[$j - 1];
    if ($cvi($geti(_Wb, 6, 2)) < 1) {
      $j--;
      $k[$j++] = "bwipp.GS1badDay#3005";
      $k[$j++] = "Invalid day of month";
      $k[$j++] = false;
      return true;
    }
    $_.lintyyyymmd0();
  };
  $_.lintyymmd0 = function() {
    var _Wd = $k[$j - 1];
    var _Wf = $cvi($geti(_Wd, 0, 2));
    var _Wg = _Wf - 21;
    $k[$j++] = _Wf;
    $k[$j++] = _Wg;
    if (_Wg >= 51) {
      $k[$j - 1] = "19";
    } else {
      if ($k[--$j] <= -50) {
        $k[$j++] = "21";
      } else {
        $k[$j++] = "20";
      }
    }
    var _Wi = $k[--$j];
    $k[$j - 1] = _Wi;
    var _Wk = $s(8);
    $k[$j++] = _Wk;
    $k[$j++] = _Wk;
    $k[$j++] = 0;
    $r(4, -1);
    var _Wl = $k[--$j];
    var _Wm = $k[--$j];
    $puti($k[--$j], _Wm, _Wl);
    var _Wo = $k[$j - 1];
    $k[$j++] = _Wo;
    $k[$j++] = 2;
    $r(4, -1);
    var _Wp = $k[--$j];
    var _Wq = $k[--$j];
    $puti($k[--$j], _Wq, _Wp);
    $_.lintyyyymmd0();
  };
  $_.lintyymmdd = function() {
    var _Ws = $k[$j - 1];
    if (_Ws.length != 6) {
      $j--;
      $k[$j++] = "bwipp.GS1badDateLength#3017";
      $k[$j++] = "Invalid length for yymmdd date";
      $k[$j++] = false;
      return true;
    }
    var _Wt = $k[$j - 1];
    if ($cvi($geti(_Wt, 4, 2)) < 1) {
      $j--;
      $k[$j++] = "bwipp.GS1badDay#3018";
      $k[$j++] = "Invalid day of month";
      $k[$j++] = false;
      return true;
    }
    $_.lintyymmd0();
  };
  $_.linthh = function() {
    if ($cvi($geti($k[--$j], 0, 2)) > 23) {
      $j -= 2;
      $k[$j++] = "bwipp.GS1badHour#3023";
      $k[$j++] = "Invalid hour of day";
      $k[$j++] = false;
      return true;
    }
  };
  $_.lintmi = function() {
    if ($cvi($geti($k[--$j], 0, 2)) > 59) {
      $j--;
      $k[$j++] = "bwipp.GS1badMinute#3027";
      $k[$j++] = "Invalid minute in the hour";
      $k[$j++] = false;
      return true;
    }
  };
  $_.lintss = function() {
    if ($cvi($geti($k[--$j], 0, 2)) > 59) {
      $j--;
      $k[$j++] = "bwipp.GS1badSecond#3031";
      $k[$j++] = "Invalid second in the minute";
      $k[$j++] = false;
      return true;
    }
  };
  $_.linthhmi = function() {
    var _X1 = $k[$j - 1];
    if ($cvi($geti(_X1, 0, 2)) > 23) {
      $j -= 2;
      $k[$j++] = "bwipp.GS1badHour#3035";
      $k[$j++] = "Invalid hour of day";
      $k[$j++] = false;
      return true;
    }
    if ($cvi($geti($k[--$j], 2, 2)) > 59) {
      $j--;
      $k[$j++] = "bwipp.GS1badMinute#3036";
      $k[$j++] = "Invalid minute in the hour";
      $k[$j++] = false;
      return true;
    }
  };
  $_.lintmmoptss = function() {
    var _X5 = $k[$j - 1];
    var _X6 = _X5.length;
    if (_X6 != 2 && _X6 != 4) {
      $j--;
      $k[$j++] = "bwipp.GS1badTimeLength#3041";
      $k[$j++] = "Invalid length for optional minutes and seconds";
      $k[$j++] = false;
      return true;
    }
    var _X7 = $k[$j - 1];
    if ($cvi($geti(_X7, 0, 2)) > 59) {
      $j -= 2;
      $k[$j++] = "bwipp.GS1badMinute#3043";
      $k[$j++] = "Invalid minute in the hour";
      $k[$j++] = false;
      return true;
    }
    var _X9 = $k[$j - 1];
    if (_X9.length >= 4) {
      var _XA = $k[$j - 1];
      if ($cvi($geti(_XA, 2, 2)) > 59) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1badSecond#3045";
        $k[$j++] = "Invalid second in the minute";
        $k[$j++] = false;
        return true;
      }
    }
    $j--;
  };
  $_.lintyesno = function() {
    var _XC = $k[--$j];
    if ($ne(_XC, "0") && $ne(_XC, "1")) {
      $j--;
      $k[$j++] = "bwipp.GS1badBoolean#3052";
      $k[$j++] = "Neither 0 nor 1 for yes or no";
      $k[$j++] = false;
      return true;
    }
  };
  $_.lintwinding = function() {
    var _XD = $k[--$j];
    if ($ne(_XD, "0") && ($ne(_XD, "1") && $ne(_XD, "9"))) {
      $j--;
      $k[$j++] = "bwipp.GS1badWinding#3058";
      $k[$j++] = "Invalid winding direction";
      $k[$j++] = false;
      return true;
    }
  };
  $_.lintpieceoftotal = function() {
    var _XE = $k[$j - 1];
    if (_XE.length % 2 != 0) {
      $j -= 2;
      $k[$j++] = "bwipp.GS1badPieceTotalLength#3063";
      $k[$j++] = "Invalid piece/total length";
      $k[$j++] = false;
      return true;
    }
    var _XF = $k[$j - 1];
    var _XH = $cvi($geti(_XF, 0, ~~(_XF.length / 2)));
    $k[$j++] = _XH;
    if (_XH == 0) {
      $j -= 3;
      $k[$j++] = "bwipp.GS1badPieceNumber#3065";
      $k[$j++] = "Invalid piece number";
      $k[$j++] = false;
      return true;
    }
    var _XI = $k[--$j];
    var _XJ = $k[--$j];
    var _XK = ~~(_XJ.length / 2);
    var _XM = $cvi($geti(_XJ, _XK, _XK));
    $k[$j++] = _XI;
    $k[$j++] = _XM;
    if (_XM == 0) {
      $j -= 3;
      $k[$j++] = "bwipp.GS1badPieceTotal#3067";
      $k[$j++] = "Invalid total number";
      $k[$j++] = false;
      return true;
    }
    var _XN = $k[--$j];
    if ($gt($k[--$j], _XN)) {
      $j--;
      $k[$j++] = "bwipp.GS1pieceExceedsTotal#3068";
      $k[$j++] = "Piece number exceeds total";
      $k[$j++] = false;
      return true;
    }
  };
  $_.lintposinseqslash = function() {
    $search($k[--$j], "/");
    if (!$k[--$j]) {
      $j--;
      $k[$j++] = "bwipp.invalidPosInSeqFormat#3073";
      $k[$j++] = "Invalid <pos>/<end> format";
      $k[$j++] = false;
      return true;
    }
    var _XR = $k[--$j];
    $k[$j - 1] = _XR;
    var _XT = $k[$j - 1];
    if (_XT.length == 0) {
      $j -= 2;
      $k[$j++] = "bwipp.invalidPosInSeqFormat#3077";
      $k[$j++] = "Invalid <pos>/<end> format";
      $k[$j++] = false;
      return true;
    }
    var _XV = $k[$j - 2];
    if (_XV.length == 0) {
      $j -= 2;
      $k[$j++] = "bwipp.invalidPosInSeqFormat#3080";
      $k[$j++] = "Invalid <pos>/<end> format";
      $k[$j++] = false;
      return true;
    }
    var _XW = $k[$j - 1];
    $k[$j++] = true;
    $forall(_XW, function() {
      var _XX = $k[--$j];
      if (_XX < 48 || _XX > 57) {
        $k[$j - 1] = false;
        return true;
      }
    });
    if (!$k[--$j]) {
      $j -= 2;
      $k[$j++] = "bwipp.positionNotNumeric#3085";
      $k[$j++] = "Position is not numeric";
      $k[$j++] = false;
      return true;
    }
    var _Xa = $k[$j - 2];
    $k[$j++] = true;
    $forall(_Xa, function() {
      var _Xb = $k[--$j];
      if (_Xb < 48 || _Xb > 57) {
        $k[$j - 1] = false;
        return true;
      }
    });
    if (!$k[--$j]) {
      $j -= 2;
      $k[$j++] = "bwipp.endNotNumeric#3089";
      $k[$j++] = "End is not numeric";
      $k[$j++] = false;
      return true;
    }
    var _Xd = $k[$j - 1];
    if ($get(_Xd, 0) == 48) {
      $j -= 2;
      $k[$j++] = "bwipp.positionZeroPrefix#3090";
      $k[$j++] = "Position cannot have zero prefix";
      $k[$j++] = false;
      return true;
    }
    var _Xg = $k[$j - 2];
    if ($get(_Xg, 0) == 48) {
      $j -= 2;
      $k[$j++] = "bwipp.endZeroPrefix#3091";
      $k[$j++] = "End cannot have zero prefix";
      $k[$j++] = false;
      return true;
    }
    var _Xi = $k[--$j];
    if ($cvi($k[--$j]) < $cvi(_Xi)) {
      $k[$j++] = "bwipp.positionExceedsEnd#3093";
      $k[$j++] = "Position exceeds end";
      $k[$j++] = false;
      return true;
    }
  };
  $_.lintpcenc = function() {
    for (; ; ) {
      $search($k[--$j], "%");
      if (!$k[--$j]) {
        $j--;
        break;
      }
      $j -= 2;
      var _Xm = $k[$j - 1];
      if (_Xm.length < 2) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1badPercentEscape#3099";
        $k[$j++] = "Invalid % escape";
        $k[$j++] = false;
        break;
      }
      var _Xn = $k[$j - 1];
      var _Xo = $geti(_Xn, 0, 2);
      $k[$j++] = true;
      for (var _Xp = 0, _Xq = _Xo.length; _Xp < _Xq; _Xp++) {
        var _Xs = $s(1);
        $put(_Xs, 0, $get(_Xo, _Xp));
        $search("0123456789ABCDEFabcdef", _Xs);
        if (!$k[--$j]) {
          $j -= 2;
          $k[$j++] = false;
          break;
        }
        $j -= 3;
      }
      if (!$k[--$j]) {
        $j -= 2;
        $k[$j++] = "bwipp.GS1badPercentChars#3106";
        $k[$j++] = "Invalid characters for percent encoding";
        $k[$j++] = false;
        break;
      }
    }
  };
  $_.lintcouponcode = function() {
    var _Xv = $k[$j - 1];
    $k[$j++] = true;
    $forall(_Xv, function() {
      var _Xw = $k[--$j];
      if (_Xw < 48 || _Xw > 57) {
        $k[$j - 1] = false;
        return true;
      }
    });
    if (!$k[--$j]) {
      $j -= 2;
      $k[$j++] = "bwipp.GS1couponNotNumeric#3114";
      $k[$j++] = "Coupon not numeric";
      $k[$j++] = false;
      return true;
    }
    var _Xy = $k[$j - 1];
    if (_Xy.length < 1) {
      $j -= 2;
      $k[$j++] = "bwipp.GS1couponTooShortGCPVLI#3118";
      $k[$j++] = "Coupon too short: Missing GCP VLI";
      $k[$j++] = false;
      return true;
    }
    var _Xz = $k[$j - 1];
    var _Y1 = $cvi($geti(_Xz, 0, 1));
    $k[$j++] = _Y1;
    if (_Y1 > 6) {
      $j -= 2;
      $k[$j++] = "bwipp.GS1couponBadGCPVLI#3121";
      $k[$j++] = "Coupon GCP length indicator must be 0-6";
      $k[$j++] = false;
      return true;
    }
    var _Y2 = $k[--$j];
    var _Y3 = $k[$j - 1];
    $k[$j++] = _Y2 + 6 + 1;
    if (_Y2 + 6 + 1 > _Y3.length) {
      $j -= 3;
      $k[$j++] = "bwipp.GS1couponTooShortGCP#3125";
      $k[$j++] = "Coupon too short: GCP truncated";
      $k[$j++] = false;
      return true;
    }
    var _Y4 = $k[--$j];
    var _Y5 = $k[--$j];
    var _Y6 = $geti(_Y5, _Y4, $f(_Y5.length - _Y4));
    $k[$j++] = _Y6;
    if (_Y6.length < 6) {
      $j -= 2;
      $k[$j++] = "bwipp.GS1couponTooShortOfferCode#3131";
      $k[$j++] = "Coupon too short: Offer Code truncated";
      $k[$j++] = false;
      return true;
    }
    var _Y7 = $k[--$j];
    var _Y8 = $geti(_Y7, 6, _Y7.length - 6);
    $k[$j++] = _Y8;
    if (_Y8.length < 1) {
      $j -= 2;
      $k[$j++] = "bwipp.GS1couponTooShortSaveValueVLI#3137";
      $k[$j++] = "Coupon too short: Missing Save Value VLI";
      $k[$j++] = false;
      return true;
    }
    var _Y9 = $k[$j - 1];
    var _YB = $cvi($geti(_Y9, 0, 1));
    $k[$j++] = _YB;
    if (_YB < 1 || _YB > 5) {
      $j -= 2;
      $k[$j++] = "bwipp.GS1couponBadSaveValueVLI#3140";
      $k[$j++] = "Coupon Save Value length indicator must be 1-5";
      $k[$j++] = false;
      return true;
    }
    var _YC = $k[--$j];
    var _YD = $k[$j - 1];
    $k[$j++] = _YC + 1;
    if (_YC + 1 > _YD.length) {
      $j -= 3;
      $k[$j++] = "bwipp.GS1couponTooShortSaveValue#3144";
      $k[$j++] = "Coupon too short: Save Value truncated";
      $k[$j++] = false;
      return true;
    }
    var _YE = $k[--$j];
    var _YF = $k[--$j];
    var _YG = $geti(_YF, _YE, $f(_YF.length - _YE));
    $k[$j++] = _YG;
    if (_YG.length < 1) {
      $j -= 2;
      $k[$j++] = "bwipp.GS1couponTooShort1stPurchaseRequirementVLI#3150";
      $k[$j++] = "Coupon too short: Missing 1st Purchase Requirement VLI";
      $k[$j++] = false;
      return true;
    }
    var _YH = $k[$j - 1];
    var _YJ = $cvi($geti(_YH, 0, 1));
    $k[$j++] = _YJ;
    if (_YJ < 1 || _YJ > 5) {
      $j -= 2;
      $k[$j++] = "bwipp.GS1couponBad1stPurchaseRequirementVLI#3153";
      $k[$j++] = "Coupon 1st Purchase Requirement length indicator must be 1-5";
      $k[$j++] = false;
      return true;
    }
    var _YK = $k[--$j];
    var _YL = $k[$j - 1];
    $k[$j++] = _YK + 1;
    if (_YK + 1 > _YL.length) {
      $j -= 3;
      $k[$j++] = "bwipp.GS1couponTooShort1stPurchaseRequirement#3157";
      $k[$j++] = "Coupon too short: 1st Purchase Requirement truncated";
      $k[$j++] = false;
      return true;
    }
    var _YM = $k[--$j];
    var _YN = $k[--$j];
    var _YO = $geti(_YN, _YM, $f(_YN.length - _YM));
    $k[$j++] = _YO;
    if (_YO.length < 1) {
      $j -= 2;
      $k[$j++] = "bwipp.GS1couponTooShort1stPurchaseRequirementCode#3163";
      $k[$j++] = "Coupon too short: Missing 1st Purchase Requirement Code";
      $k[$j++] = false;
      return true;
    }
    var _YP = $k[$j - 1];
    var _YR = $cvi($geti(_YP, 0, 1));
    if (_YR > 4 && _YR != 9) {
      $j -= 2;
      $k[$j++] = "bwipp.GS1couponBad1stPurchaseRequirementCode#3166";
      $k[$j++] = "Coupon 1st Purchase Requirement Code must be 0-4 or 9";
      $k[$j++] = false;
      return true;
    }
    var _YS = $k[--$j];
    var _YT = $geti(_YS, 1, _YS.length - 1);
    $k[$j++] = _YT;
    if (_YT.length < 3) {
      $j -= 2;
      $k[$j++] = "bwipp.GS1couponTooShort1stPurchaseFamilyCode#3172";
      $k[$j++] = "Coupon too short: 1st Purchase Family Code truncated";
      $k[$j++] = false;
      return true;
    }
    var _YU = $k[--$j];
    var _YV = $geti(_YU, 3, _YU.length - 3);
    $k[$j++] = _YV;
    if (_YV.length >= 1) {
      var _YW = $k[$j - 1];
      if ($cvi($geti(_YW, 0, 1)) == 1) {
        var _YY = $k[--$j];
        var _YZ = $geti(_YY, 1, _YY.length - 1);
        $k[$j++] = _YZ;
        if (_YZ.length < 1) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponTooShortAdditionalPurchaseRulesCode#3182";
          $k[$j++] = "Coupon too short: Missing Additional Purchase Rules Code";
          $k[$j++] = false;
          return true;
        }
        var _Ya = $k[$j - 1];
        if ($cvi($geti(_Ya, 0, 1)) > 3) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponBadAdditionalPurchaseRulesCode#3185";
          $k[$j++] = "Coupon Additional Purchase Rules Code must be 0-3";
          $k[$j++] = false;
          return true;
        }
        var _Yc = $k[--$j];
        var _Yd = $geti(_Yc, 1, _Yc.length - 1);
        $k[$j++] = _Yd;
        if (_Yd.length < 1) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponTooShort2ndPurchaseRequirementVLI#3191";
          $k[$j++] = "Coupon too short: Missing 2nd Purchase Requirement VLI";
          $k[$j++] = false;
          return true;
        }
        var _Ye = $k[$j - 1];
        var _Yg = $cvi($geti(_Ye, 0, 1));
        $k[$j++] = _Yg;
        if (_Yg < 1 || _Yg > 5) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponBad2ndPurchaseRequirementVLI#3194";
          $k[$j++] = "Coupon 2nd Purchase Requirement length indicator must be 1-5";
          $k[$j++] = false;
          return true;
        }
        var _Yh = $k[--$j];
        var _Yi = $k[$j - 1];
        $k[$j++] = _Yh + 1;
        if (_Yh + 1 > _Yi.length) {
          $j -= 3;
          $k[$j++] = "bwipp.GS1couponTooShort2ndPurchaseRequirement#3198";
          $k[$j++] = "Coupon too short: 2nd Purchase Requirement truncated";
          $k[$j++] = false;
          return true;
        }
        var _Yj = $k[--$j];
        var _Yk = $k[--$j];
        var _Yl = $geti(_Yk, _Yj, $f(_Yk.length - _Yj));
        $k[$j++] = _Yl;
        if (_Yl.length < 1) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponTooShort2ndPurchaseRequirementCode#3204";
          $k[$j++] = "Coupon too short: Missing 2nd Purchase Requirement Code";
          $k[$j++] = false;
          return true;
        }
        var _Ym = $k[$j - 1];
        var _Yo = $cvi($geti(_Ym, 0, 1));
        if (_Yo > 4 && _Yo != 9) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponBad2ndPurchaseRequirementCode#3207";
          $k[$j++] = "Coupon 2nd Purchase Requirement Code must be 0-4 or 9";
          $k[$j++] = false;
          return true;
        }
        var _Yp = $k[--$j];
        var _Yq = $geti(_Yp, 1, _Yp.length - 1);
        $k[$j++] = _Yq;
        if (_Yq.length < 3) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponTooShort2ndPurchaseFamilyCode#3213";
          $k[$j++] = "Coupon too short: 2nd Purchase Family Code truncated";
          $k[$j++] = false;
          return true;
        }
        var _Yr = $k[--$j];
        var _Ys = $geti(_Yr, 3, _Yr.length - 3);
        $k[$j++] = _Ys;
        if (_Ys.length < 1) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponTooShort2ndPurchaseGCPVLI#3219";
          $k[$j++] = "Coupon too short: Missing 2nd Purchase GCP VLI";
          $k[$j++] = false;
          return true;
        }
        var _Yt = $k[$j - 1];
        var _Yv = $cvi($geti(_Yt, 0, 1));
        $k[$j++] = _Yv;
        if (_Yv > 6 && _Yv != 9) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponBad2ndPurchaseGCPVLI#3222";
          $k[$j++] = "Coupon 2nd Purchase GCP length indicator must be 0-6 or 9";
          $k[$j++] = false;
          return true;
        }
        var _Yw = $k[$j - 1];
        if (_Yw != 9) {
          var _Yx = $k[--$j];
          $k[$j++] = _Yx + 6;
        } else {
          $k[$j - 1] = 0;
        }
        var _Yy = $k[--$j];
        var _Yz = $k[$j - 1];
        $k[$j++] = _Yy + 1;
        if (_Yy + 1 > _Yz.length) {
          $j -= 3;
          $k[$j++] = "bwipp.GS1couponTooShort2ndPurchaseGCP#3226";
          $k[$j++] = "Coupon too short: 2nd Purchase GCP truncated";
          $k[$j++] = false;
          return true;
        }
        var _Z0 = $k[--$j];
        var _Z1 = $k[--$j];
        $k[$j++] = $geti(_Z1, _Z0, $f(_Z1.length - _Z0));
      }
    }
    var _Z3 = $k[$j - 1];
    if (_Z3.length >= 1) {
      var _Z4 = $k[$j - 1];
      if ($cvi($geti(_Z4, 0, 1)) == 2) {
        var _Z6 = $k[--$j];
        var _Z7 = $geti(_Z6, 1, _Z6.length - 1);
        $k[$j++] = _Z7;
        if (_Z7.length < 1) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponTooShort3rdPurchaseRequirementVLI#3238";
          $k[$j++] = "Coupon too short: Missing 3rd Purchase Requirement VLI";
          $k[$j++] = false;
          return true;
        }
        var _Z8 = $k[$j - 1];
        var _ZA = $cvi($geti(_Z8, 0, 1));
        $k[$j++] = _ZA;
        if (_ZA < 1 || _ZA > 5) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponBad3rdPurchaseRequirementVLI#3241";
          $k[$j++] = "Coupon 3rd Purchase Requirement length indicator must be 1-5";
          $k[$j++] = false;
          return true;
        }
        var _ZB = $k[--$j];
        var _ZC = $k[$j - 1];
        $k[$j++] = _ZB + 1;
        if (_ZB + 1 > _ZC.length) {
          $j -= 3;
          $k[$j++] = "bwipp.GS1couponTooShort3rdPurchaseRequirement#3245";
          $k[$j++] = "Coupon too short: 3rd Purchase Requirement truncated";
          $k[$j++] = false;
          return true;
        }
        var _ZD = $k[--$j];
        var _ZE = $k[--$j];
        var _ZF = $geti(_ZE, _ZD, $f(_ZE.length - _ZD));
        $k[$j++] = _ZF;
        if (_ZF.length < 1) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponTooShort3rdPurchaseRequirementCode#3251";
          $k[$j++] = "Coupon too short: Missing 3rd Purchase Requirement Code";
          $k[$j++] = false;
          return true;
        }
        var _ZG = $k[$j - 1];
        var _ZI = $cvi($geti(_ZG, 0, 1));
        if (_ZI > 4 && _ZI != 9) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponBad3rdPurchaseRequirementCode#3254";
          $k[$j++] = "Coupon 3rd Purchase Requirement Code must be 0-4 or 9";
          $k[$j++] = false;
          return true;
        }
        var _ZJ = $k[--$j];
        var _ZK = $geti(_ZJ, 1, _ZJ.length - 1);
        $k[$j++] = _ZK;
        if (_ZK.length < 3) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponTooShort3rdPurchaseFamilyCode#3260";
          $k[$j++] = "Coupon too short: 3rd Purchase Family Code truncated";
          $k[$j++] = false;
          return true;
        }
        var _ZL = $k[--$j];
        var _ZM = $geti(_ZL, 3, _ZL.length - 3);
        $k[$j++] = _ZM;
        if (_ZM.length < 1) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponTooShort3rdPurchaseGCPVLI#3266";
          $k[$j++] = "Coupon too short: Missing 3rd Purchase GCP VLI";
          $k[$j++] = false;
          return true;
        }
        var _ZN = $k[$j - 1];
        var _ZP = $cvi($geti(_ZN, 0, 1));
        $k[$j++] = _ZP;
        if (_ZP > 6 && _ZP != 9) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponBad3rdPurchaseGCPVLI#3269";
          $k[$j++] = "Coupon 3rd Purchase GCP length indicator must be 0-6 or 9";
          $k[$j++] = false;
          return true;
        }
        var _ZQ = $k[$j - 1];
        if (_ZQ != 9) {
          var _ZR = $k[--$j];
          $k[$j++] = _ZR + 6;
        } else {
          $k[$j - 1] = 0;
        }
        var _ZS = $k[--$j];
        var _ZT = $k[$j - 1];
        $k[$j++] = _ZS + 1;
        if (_ZS + 1 > _ZT.length) {
          $j -= 3;
          $k[$j++] = "bwipp.GS1couponTooShort3rdPurchaseGCP#3273";
          $k[$j++] = "Coupon too short: 3rd Purchase GCP truncated";
          $k[$j++] = false;
          return true;
        }
        var _ZU = $k[--$j];
        var _ZV = $k[--$j];
        $k[$j++] = $geti(_ZV, _ZU, $f(_ZV.length - _ZU));
      }
    }
    $_.couponexpire = -1;
    var _ZX = $k[$j - 1];
    if (_ZX.length >= 1) {
      var _ZY = $k[$j - 1];
      if ($cvi($geti(_ZY, 0, 1)) == 3) {
        var _Za = $k[--$j];
        var _Zb = $geti(_Za, 1, _Za.length - 1);
        $k[$j++] = _Zb;
        if (_Zb.length < 6) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponTooShortExpirationDate#3286";
          $k[$j++] = "Coupon too short: Expiration date";
          $k[$j++] = false;
          return true;
        }
        var _Zc = $k[$j - 1];
        var _Ze = $cvi($geti(_Zc, 2, 2));
        if (_Ze < 1 || _Ze > 12) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponExpirationDateBadMonth#3288";
          $k[$j++] = "Invalid month in expiration date";
          $k[$j++] = false;
          return true;
        }
        var _Zf = $k[$j - 1];
        var _Zh = $cvi($geti(_Zf, 0, 2));
        var _Zi = _Zh - 21;
        $k[$j++] = _Zh;
        $k[$j++] = _Zi;
        if (_Zi >= 51) {
          $j--;
          var _Zj = $k[--$j];
          $k[$j++] = _Zj + 1900;
        } else {
          if ($k[--$j] <= -50) {
            var _Zl = $k[--$j];
            $k[$j++] = _Zl + 2100;
          } else {
            var _Zm = $k[--$j];
            $k[$j++] = _Zm + 2e3;
          }
        }
        var _Zn = $k[--$j];
        $k[$j++] = _Zn % 400 == 0 || _Zn % 4 == 0 && _Zn % 100 != 0;
        $k[$j++] = Infinity;
        $k[$j++] = 31;
        $r(3, -1);
        var _Zp = $k[--$j] ? 29 : 28;
        $k[$j++] = _Zp;
        $k[$j++] = 31;
        $k[$j++] = 30;
        $k[$j++] = 31;
        $k[$j++] = 30;
        $k[$j++] = 31;
        $k[$j++] = 31;
        $k[$j++] = 30;
        $k[$j++] = 31;
        $k[$j++] = 30;
        $k[$j++] = 31;
        var _Zq = $a();
        var _Zr = $k[$j - 1];
        var _Zv = $cvi($geti(_Zr, 4, 2));
        if ($get(_Zq, $cvi($geti(_Zr, 2, 2)) - 1) < _Zv || _Zv < 1) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponExpirationDateBadDay#3295";
          $k[$j++] = "Invalid day of month in expiration date";
          $k[$j++] = false;
          return true;
        }
        var _Zw = $k[--$j];
        $_.couponexpire = $cvi($geti(_Zw, 0, 6));
        $k[$j++] = $geti(_Zw, 6, _Zw.length - 6);
      }
    }
    var _Zz = $k[$j - 1];
    if (_Zz.length >= 1) {
      var _a0 = $k[$j - 1];
      if ($cvi($geti(_a0, 0, 1)) == 4) {
        var _a2 = $k[--$j];
        var _a3 = $geti(_a2, 1, _a2.length - 1);
        $k[$j++] = _a3;
        if (_a3.length < 6) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponTooShortStartDate#3307";
          $k[$j++] = "Coupon too short: Start date";
          $k[$j++] = false;
          return true;
        }
        var _a4 = $k[$j - 1];
        var _a6 = $cvi($geti(_a4, 2, 2));
        if (_a6 < 1 || _a6 > 12) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponStartDateBadMonth#3309";
          $k[$j++] = "Invalid month in start date";
          $k[$j++] = false;
          return true;
        }
        var _a7 = $k[$j - 1];
        var _a9 = $cvi($geti(_a7, 0, 2));
        var _aA = _a9 - 21;
        $k[$j++] = _a9;
        $k[$j++] = _aA;
        if (_aA >= 51) {
          $j--;
          var _aB = $k[--$j];
          $k[$j++] = _aB + 1900;
        } else {
          if ($k[--$j] <= -50) {
            var _aD = $k[--$j];
            $k[$j++] = _aD + 2100;
          } else {
            var _aE = $k[--$j];
            $k[$j++] = _aE + 2e3;
          }
        }
        var _aF = $k[--$j];
        $k[$j++] = _aF % 400 == 0 || _aF % 4 == 0 && _aF % 100 != 0;
        $k[$j++] = Infinity;
        $k[$j++] = 31;
        $r(3, -1);
        var _aH = $k[--$j] ? 29 : 28;
        $k[$j++] = _aH;
        $k[$j++] = 31;
        $k[$j++] = 30;
        $k[$j++] = 31;
        $k[$j++] = 30;
        $k[$j++] = 31;
        $k[$j++] = 31;
        $k[$j++] = 30;
        $k[$j++] = 31;
        $k[$j++] = 30;
        $k[$j++] = 31;
        var _aI = $a();
        var _aJ = $k[$j - 1];
        var _aN = $cvi($geti(_aJ, 4, 2));
        if ($get(_aI, $cvi($geti(_aJ, 2, 2)) - 1) < _aN || _aN < 1) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponStartDateBadDay#3316";
          $k[$j++] = "Invalid day of month in start date";
          $k[$j++] = false;
          return true;
        }
        var _aO = $k[--$j];
        $_.couponstart = $cvi($geti(_aO, 0, 6));
        $k[$j++] = _aO;
        if ($_.couponexpire != -1 && $_.couponexpire < $_.couponstart) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponExpireDateBeforeStartDate#3319";
          $k[$j++] = "Coupon expires before it starts";
          $k[$j++] = false;
          return true;
        }
        var _aT = $k[--$j];
        $k[$j++] = $geti(_aT, 6, _aT.length - 6);
      }
    }
    var _aV = $k[$j - 1];
    if (_aV.length >= 1) {
      var _aW = $k[$j - 1];
      if ($cvi($geti(_aW, 0, 1)) == 5) {
        var _aY = $k[--$j];
        var _aZ = $geti(_aY, 1, _aY.length - 1);
        $k[$j++] = _aZ;
        if (_aZ.length < 1) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponTooShortSerialNumberVLI#3331";
          $k[$j++] = "Coupon too short: Missing Serial Number VLI";
          $k[$j++] = false;
          return true;
        }
        var _aa = $k[$j - 1];
        var _ab = $geti(_aa, 0, 1);
        $k[$j++] = $cvi(_ab) + 6 + 1;
        if ($cvi(_ab) + 6 + 1 > _aa.length) {
          $j -= 3;
          $k[$j++] = "bwipp.GS1couponTooShortSerialNumber#3335";
          $k[$j++] = "Coupon too short: Serial Number truncated";
          $k[$j++] = false;
          return true;
        }
        var _ac = $k[--$j];
        var _ad = $k[--$j];
        $k[$j++] = $geti(_ad, _ac, $f(_ad.length - _ac));
      }
    }
    var _af = $k[$j - 1];
    if (_af.length >= 1) {
      var _ag = $k[$j - 1];
      if ($cvi($geti(_ag, 0, 1)) == 6) {
        var _ai = $k[--$j];
        var _aj = $geti(_ai, 1, _ai.length - 1);
        $k[$j++] = _aj;
        if (_aj.length < 1) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponTooShortRetailerGCPGLNVLI#3347";
          $k[$j++] = "Coupon too short: Missing Retailer GCP/GLN VLI";
          $k[$j++] = false;
          return true;
        }
        var _ak = $k[$j - 1];
        var _am = $cvi($geti(_ak, 0, 1));
        $k[$j++] = _am;
        if (_am < 1 || _am > 7) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponBadRetailerGCPGLNVLI#3350";
          $k[$j++] = "Coupon Retailer GCP/GLN length indicator must be 1-7";
          $k[$j++] = false;
          return true;
        }
        var _an = $k[--$j];
        var _ao = $k[$j - 1];
        $k[$j++] = _an + 6 + 1;
        if (_an + 6 + 1 > _ao.length) {
          $j -= 3;
          $k[$j++] = "bwipp.GS1couponTooShortRetailerGCPGLN#3354";
          $k[$j++] = "Coupon too short: Retailer GCP/GLN truncated";
          $k[$j++] = false;
          return true;
        }
        var _ap = $k[--$j];
        var _aq = $k[--$j];
        $k[$j++] = $geti(_aq, _ap, $f(_aq.length - _ap));
      }
    }
    var _as = $k[$j - 1];
    if (_as.length >= 1) {
      var _at = $k[$j - 1];
      if ($cvi($geti(_at, 0, 1)) == 9) {
        var _av = $k[--$j];
        var _aw = $geti(_av, 1, _av.length - 1);
        $k[$j++] = _aw;
        if (_aw.length < 1) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponTooShortSaveValueCode#3366";
          $k[$j++] = "Coupon too short: Missing Save Value Code";
          $k[$j++] = false;
          return true;
        }
        var _ax = $k[$j - 1];
        var _az = $cvi($geti(_ax, 0, 1));
        if (_az > 6 || (_az == 3 || _az == 4)) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponBadSaveValueCode#3369";
          $k[$j++] = "Coupon Save Value Code must be 0,1,2,5 or 6";
          $k[$j++] = false;
          return true;
        }
        var _b0 = $k[--$j];
        var _b1 = $geti(_b0, 1, _b0.length - 1);
        $k[$j++] = _b1;
        if (_b1.length < 1) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponTooShortSaveValueAppliesToItem#3375";
          $k[$j++] = "Coupon too short: Missing Save Value Applies to Item";
          $k[$j++] = false;
          return true;
        }
        var _b2 = $k[$j - 1];
        if ($cvi($geti(_b2, 0, 1)) > 2) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponBadSaveValueAppliesToItem#3378";
          $k[$j++] = "Coupon Save Value Applies to Item must be 0-2";
          $k[$j++] = false;
          return true;
        }
        var _b4 = $k[--$j];
        var _b5 = $geti(_b4, 1, _b4.length - 1);
        $k[$j++] = _b5;
        if (_b5.length < 1) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponTooShortStoreCouponFlag#3384";
          $k[$j++] = "Coupon too short: Missing Store Coupon Flag";
          $k[$j++] = false;
          return true;
        }
        var _b6 = $k[--$j];
        var _b7 = $geti(_b6, 1, _b6.length - 1);
        $k[$j++] = _b7;
        if (_b7.length < 1) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponTooShortDontMultiplyFlag#3390";
          $k[$j++] = "Coupon too short: Missing Don't Multiply Flag";
          $k[$j++] = false;
          return true;
        }
        var _b8 = $k[$j - 1];
        if ($cvi($geti(_b8, 0, 1)) > 1) {
          $j -= 2;
          $k[$j++] = "bwipp.GS1couponBadDontMultiplyFlag#3393";
          $k[$j++] = "Don't Multiply Flag must be 0 or 1";
          $k[$j++] = false;
          return true;
        }
        var _bA = $k[--$j];
        $k[$j++] = $geti(_bA, 1, _bA.length - 1);
      }
    }
    var _bC = $k[$j - 1];
    if (_bC.length != 0) {
      $j -= 2;
      $k[$j++] = "bwipp.GS1couponUnrecognisedOptionalField#3400";
      $k[$j++] = "Coupon fields must be 1,2,3,4,5,6 or 9, increasing order";
      $k[$j++] = false;
      return true;
    }
    $j--;
  };
  $_.lintcouponposoffer = function() {
    var _bD = $k[$j - 1];
    $k[$j++] = true;
    $forall(_bD, function() {
      var _bE = $k[--$j];
      if (_bE < 48 || _bE > 57) {
        $k[$j - 1] = false;
        return true;
      }
    });
    if (!$k[--$j]) {
      $j -= 2;
      $k[$j++] = "bwipp.GS1couponNotNumeric#3409";
      $k[$j++] = "Coupon not numeric";
      $k[$j++] = false;
      return true;
    }
    var _bG = $k[$j - 1];
    if (_bG.length < 1) {
      $j -= 2;
      $k[$j++] = "bwipp.GS1couponTooShortFormatCode#3412";
      $k[$j++] = "Coupon too short: Missing Format Code";
      $k[$j++] = false;
      return true;
    }
    var _bH = $k[$j - 1];
    var _bI = $geti(_bH, 0, 1);
    if ($ne(_bI, "0") && $ne(_bI, "1")) {
      $j -= 2;
      $k[$j++] = "bwipp.GS1couponBadFormatCode#3415";
      $k[$j++] = "Coupon format must be 0 or 1";
      $k[$j++] = false;
      return true;
    }
    var _bJ = $k[--$j];
    var _bK = $geti(_bJ, 1, _bJ.length - 1);
    $k[$j++] = _bK;
    if (_bK.length < 1) {
      $j -= 2;
      $k[$j++] = "bwipp.GS1couponTooShortFunderVLI#3420";
      $k[$j++] = "Coupon too short: Missing Funder VLI";
      $k[$j++] = false;
      return true;
    }
    var _bL = $k[$j - 1];
    var _bN = $cvi($geti(_bL, 0, 1));
    $k[$j++] = _bN;
    if (_bN > 6) {
      $j -= 3;
      $k[$j++] = "bwipp.GS1couponBadFunderVLI#3423";
      $k[$j++] = "Coupon Funder length indicator must be 0-6";
      $k[$j++] = false;
      return true;
    }
    var _bO = $k[--$j];
    var _bP = $k[$j - 1];
    $k[$j++] = _bO + 6 + 1;
    if (_bO + 6 + 1 > _bP.length) {
      $j -= 3;
      $k[$j++] = "bwipp.GS1couponTooShortFunder#3427";
      $k[$j++] = "Coupon too short: Truncated Funder ID";
      $k[$j++] = false;
      return true;
    }
    var _bQ = $k[--$j];
    var _bR = $k[--$j];
    var _bS = $geti(_bR, _bQ, $f(_bR.length - _bQ));
    $k[$j++] = _bS;
    if (_bS.length < 6) {
      $j -= 2;
      $k[$j++] = "bwipp.GS1couponTooShortOfferCode#3432";
      $k[$j++] = "Coupon too short: Truncated Offer Code";
      $k[$j++] = false;
      return true;
    }
    var _bT = $k[--$j];
    var _bU = $geti(_bT, 6, _bT.length - 6);
    $k[$j++] = _bU;
    if (_bU.length < 1) {
      $j -= 2;
      $k[$j++] = "bwipp.GS1couponTooShortSnVLI#3437";
      $k[$j++] = "Coupon too short: Missing SN VLI";
      $k[$j++] = false;
      return true;
    }
    var _bV = $k[$j - 1];
    var _bW = $geti(_bV, 0, 1);
    $k[$j++] = $cvi(_bW) + 6 + 1;
    if ($cvi(_bW) + 6 + 1 > _bV.length) {
      $j -= 3;
      $k[$j++] = "bwipp.GS1couponTooShortSn#3442";
      $k[$j++] = "Coupon too short: Truncated SN";
      $k[$j++] = false;
      return true;
    }
    var _bX = $k[--$j];
    var _bY = $k[--$j];
    var _bZ = $geti(_bY, _bX, $f(_bY.length - _bX));
    $k[$j++] = _bZ;
    if (_bZ.length != 0) {
      $j -= 2;
      $k[$j++] = "bwipp.GS1couponTooLong#3446";
      $k[$j++] = "Coupon too long";
      $k[$j++] = false;
      return true;
    }
    $j--;
  };
  $_.lintlatitude = function() {
    var _ba = $k[$j - 1];
    if (_ba.length != 10) {
      $j--;
      $k[$j++] = "bwipp.GS1badLatitudeLength#3453";
      $k[$j++] = "Invalid length for a latitude";
      $k[$j++] = false;
      return true;
    }
    if ($cvi($k[--$j]) > $cvi("1800000000")) {
      $j--;
      $k[$j++] = "bwipp.GS1badLatitude#3457";
      $k[$j++] = "Invalid value for latitude";
      $k[$j++] = false;
      return true;
    }
  };
  $_.lintlongitude = function() {
    var _bc = $k[$j - 1];
    if (_bc.length != 10) {
      $j--;
      $k[$j++] = "bwipp.GS1badLongitudeLength#3462";
      $k[$j++] = "Invalid length for a longitude";
      $k[$j++] = false;
      return true;
    }
    if ($cvi($k[--$j]) > $cvi("3600000000")) {
      $j--;
      $k[$j++] = "bwipp.GS1badLongitude#3467";
      $k[$j++] = "Invalid value for longitude";
      $k[$j++] = false;
      return true;
    }
  };
  $k[$j++] = Infinity;
  var _be = $a(["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99"]);
  for (var _bf = 0, _bg = _be.length; _bf < _bg; _bf++) {
    var _bh = $get(_be, _bf);
    $k[$j++] = _bh;
    $k[$j++] = _bh;
  }
  $_.aidcmediatype = $d();
  $_.lintmediatype = function() {
    var _bm = $get($_.aidcmediatype, $k[--$j]) !== void 0;
    if (!_bm) {
      $j--;
      $k[$j++] = "bwipp.GS1UnknownMediaType#3479";
      $k[$j++] = "Unknown AIDC media type";
      $k[$j++] = false;
      return true;
    }
  };
  $k[$j++] = Infinity;
  var _bn = $a(["1A", "1B", "1D", "1F", "1G", "1W", "200", "201", "202", "203", "204", "205", "206", "210", "211", "212", "2C", "3A", "3H", "43", "44", "4A", "4B", "4C", "4D", "4F", "4G", "4H", "5H", "5L", "5M", "6H", "6P", "7A", "7B", "8", "8A", "8B", "8C", "9", "AA", "AB", "AC", "AD", "AF", "AG", "AH", "AI", "AJ", "AL", "AM", "AP", "APE/AT", "AV", "B4", "BB", "BC", "BD", "BE", "BF", "BG", "BGE", "BH", "BI", "BJ", "BK", "BL", "BM", "BME", "BN", "BO", "BP", "BQ", "BR", "BRI", "BS", "BT", "BU", "BV", "BW", "BX", "BY", "BZ", "CA", "CB", "CBL", "CC", "CCE", "CD", "CE", "CF", "CG", "CH", "CI", "CJ", "CK", "CL", "CM", "CN", "CO", "CP", "CQ", "CR", "CS", "CT", "CU", "CV", "CW", "CX", "CY", "CZ", "DA", "DB", "DC", "DG", "DH", "DI", "DJ", "DK", "DL", "DM", "DN", "DP", "DPE", "DR", "DS", "DT", "DU", "DV", "DW", "DX", "DY", "E1", "E2", "E3", "EC", "ED", "EE", "EF", "EG", "EH", "EI", "EN", "FB", "FC", "FD", "FE", "FI", "FL", "FO", "FOB", "FP", "FPE", "FR", "FT", "FW", "FX", "GB", "GI", "GL", "GR", "GU", "GY", "GZ", "HA", "HB", "HC", "HG", "HN", "HR", "IA", "IB", "IC", "ID", "IE", "IF", "IG", "IH", "IK", "IL", "IN", "IZ", "JB", "JC", "JG", "JR", "JT", "JY", "KG", "KI", "LAB", "LE", "LG", "LT", "LU", "LV", "LZ", "MA", "MB", "MC", "ME", "MPE", "MR", "MS", "MT", "MW", "MX", "NA", "NE", "NF", "NG", "NS", "NT", "NU", "NV", "OA", "OB", "OC", "OD", "OE", "OF", "OK", "OPE", "OT", "OU", "P2", "PA", "PAE", "PB", "PC", "PD", "PE", "PF", "PG", "PH", "PI", "PJ", "PK", "PL", "PLP", "PN", "PO", "POP", "PP", "PPE", "PR", "PT", "PU", "PUE", "PV", "PX", "PY", "PZ", "QA", "QB", "QC", "QD", "QF", "QG", "QH", "QJ", "QK", "QL", "QM", "QN", "QP", "QQ", "QR", "QS", "RB1", "RB2", "RB3", "RCB", "RD", "RG", "RJ", "RK", "RL", "RO", "RT", "RZ", "S1", "SA", "SB", "SC", "SD", "SE", "SEC", "SH", "SI", "SK", "SL", "SM", "SO", "SP", "SS", "ST", "STL", "SU", "SV", "SW", "SX", "SY", "SZ", "T1", "TB", "TC", "TD", "TE", "TEV", "TG", "THE", "TI", "TK", "TL", "TN", "TO", "TR", "TRE", "TS", "TT", "TTE", "TU", "TV", "TW", "TWE", "TY", "TZ", "UC", "UN", "UUE", "VA", "VG", "VI", "VK", "VL", "VN", "VO", "VP", "VQ", "VR", "VS", "VY", "WA", "WB", "WC", "WD", "WF", "WG", "WH", "WJ", "WK", "WL", "WM", "WN", "WP", "WQ", "WR", "WRP", "WS", "WT", "WU", "WV", "WW", "WX", "WY", "WZ", "X11", "X12", "X15", "X16", "X17", "X18", "X19", "X20", "X3", "XA", "XB", "XC", "XD", "XF", "XG", "XH", "XJ", "XK", "YA", "YB", "YC", "YD", "YF", "YG", "YH", "YJ", "YK", "YL", "YM", "YN", "YP", "YQ", "YR", "YS", "YT", "YV", "YW", "YX", "YY", "YZ", "ZA", "ZB", "ZC", "ZD", "ZF", "ZG", "ZH", "ZJ", "ZK", "ZL", "ZM", "ZN", "ZP", "ZQ", "ZR", "ZS", "ZT", "ZU", "ZV", "ZW", "ZX", "ZY", "ZZ"]);
  for (var _bo = 0, _bp = _bn.length; _bo < _bp; _bo++) {
    var _bq = $get(_bn, _bo);
    $k[$j++] = _bq;
    $k[$j++] = _bq;
  }
  $_.packagetype = $d();
  $_.lintpackagetype = function() {
    var _bv = $get($_.packagetype, $k[--$j]) !== void 0;
    if (!_bv) {
      $j--;
      $k[$j++] = "bwipp.GS1unknownPackageType#3523";
      $k[$j++] = "Unknown package type";
      $k[$j++] = false;
      return true;
    }
  };
  if (!$_.dontlint) {
    $k[$j++] = true;
    for (var _bz = 0, _by = $_.vals.length - 1; _bz <= _by; _bz += 1) {
      $_.ai = $get($_.ais, _bz);
      $_.val = $get($_.vals, _bz);
      var _c6 = $get($_.gs1syntax, $_.ai) !== void 0;
      if (_c6) {
        var _cA = $get($get($_.gs1syntax, $_.ai), "parts");
        $k[$j++] = _cA;
        $k[$j++] = 0;
        $forall(_cA, function() {
          var _cB = $k[$j - 1];
          if ($get(_cB, "opt")) {
            $k[$j - 1] = 0;
          } else {
            var _cE = $get($k[--$j], "min");
            $k[$j++] = _cE;
          }
          var _cF = $k[--$j];
          var _cG = $k[--$j];
          $k[$j++] = $f(_cG + _cF);
        });
        if ($k[--$j] > $_.val.length) {
          $j--;
          $k[$j++] = "bwipp.GS1valueTooShort#3537";
          $k[$j++] = "Too short";
          $k[$j++] = false;
          break;
        }
        var _cJ = $k[$j - 1];
        $k[$j++] = 0;
        $forall(_cJ, function() {
          var _cL = $get($k[--$j], "max");
          var _cM = $k[--$j];
          $k[$j++] = $f(_cM + _cL);
        });
        if ($k[--$j] < $_.val.length) {
          $j--;
          $k[$j++] = "bwipp.GS1valueTooLong#3540";
          $k[$j++] = "Too long";
          $k[$j++] = false;
          break;
        }
        $forall($k[--$j], function() {
          $_.props = $k[--$j];
          var _cS = $get($_.props, "max");
          var _cT = $_.val;
          var _cU = _cT.length;
          if (_cS > _cT.length) {
            var _ = _cU;
            _cU = _cS;
            _cS = _;
          }
          $_.eval = $geti($_.val, 0, _cS);
          var _cZ = $_.eval.length;
          $_.val = $geti($_.val, _cZ, $_.val.length - _cZ);
          if ($_.eval.length == 0) {
            if (!$get($_.props, "opt")) {
              $j--;
              $k[$j++] = "bwipp.GS1valueTooShort#3549";
              $k[$j++] = "Too short";
              $k[$j++] = false;
              return true;
            }
          } else {
            if ($_.eval.length < $get($_.props, "min")) {
              $j--;
              $k[$j++] = "bwipp.GS1valueTooShort#3553";
              $k[$j++] = "Too short";
              $k[$j++] = false;
              return true;
            }
            var _ci = /* @__PURE__ */ new Map([
              ["N", "lintnumeric"],
              ["X", "lintcset82"],
              ["Y", "lintcset39"],
              ["Z", "lintcset64"]
            ]);
            $k[$j++] = $_.eval;
            if ($_[$get(_ci, $get($_.props, "cset"))]() === true) {
              return true;
            }
            $forall($get($_.props, "linters"), function() {
              var _cs = $_[$k[--$j]];
              $k[$j++] = $_.eval;
              if (_cs() === true) {
                return true;
              }
            });
          }
        });
        var _ct = $k[$j - 1];
        if (!_ct) {
          break;
        }
        if ($_.val.length != 0) {
          $j--;
          $k[$j++] = "bwipp.GS1valueTooLong#3562";
          $k[$j++] = "Too long";
          $k[$j++] = false;
          break;
        }
      } else {
        $j--;
        $k[$j++] = "bwipp.GS1unknownAI#3565";
        $k[$j++] = "Unrecognised AI";
        $k[$j++] = false;
        break;
      }
    }
    if (!$k[--$j]) {
      var _cw = $k[--$j];
      var _cy = $s(_cw.length + $_.ai.length + 5);
      $puti(_cy, 0, "AI ");
      $puti(_cy, 3, $_.ai);
      $puti(_cy, 3 + $_.ai.length, ": ");
      $puti(_cy, 5 + $_.ai.length, _cw);
      $k[$j++] = _cy;
      bwipp_raiseerror();
    }
    $_.aiexists = function() {
      $_.this = $k[--$j];
      $_.patt = $k[--$j];
      for (var _d4 = 0; _d4 < 1; _d4++) {
        var _d7 = $get($_.aivals, $_.patt) !== void 0;
        if (_d7) {
          $k[$j++] = true;
          break;
        }
        if ($_.patt.length == 4) {
          if ($eq($geti($_.patt, 3, 1), "n")) {
            var _dD = $eq($geti($_.patt, 2, 1), "n") ? 2 : 3;
            $_.pfxlen = _dD;
            var _dE = $_.ais;
            $k[$j++] = false;
            for (var _dF = 0, _dG = _dE.length; _dF < _dG; _dF++) {
              var _dH = $get(_dE, _dF);
              $k[$j++] = _dH;
              if ($ne(_dH, $_.this) && _dH.length == 4) {
                if ($eq($geti($k[--$j], 0, $_.pfxlen), $geti($_.patt, 0, $_.pfxlen))) {
                  $k[$j - 1] = true;
                }
              } else {
                $j--;
              }
            }
            break;
          }
          $k[$j++] = false;
          break;
        }
        $k[$j++] = false;
        break;
      }
    };
    $_.vals;
    $_.aivals = /* @__PURE__ */ new Map();
    for (var _dS = 0, _dR = $_.vals.length - 1; _dS <= _dR; _dS += 1) {
      $_.ai = $get($_.ais, _dS);
      $_.val = $get($_.vals, _dS);
      var _dZ = $get($_.aivals, $_.ai) !== void 0;
      if (_dZ) {
        if ($ne($get($_.aivals, $_.ai), $_.val)) {
          var _df = $s($_.ai.length + 40);
          $puti(_df, 0, "Repeated AIs (");
          $puti(_df, 14, $_.ai);
          $puti(_df, 14 + $_.ai.length, ") must have the same value");
          $k[$j++] = "bwipp.GS1repeatedDifferingAIs#3615";
          $k[$j++] = _df;
          bwipp_raiseerror();
        }
      } else {
        $put($_.aivals, $_.ai, $_.val);
      }
    }
    for (var _dn = 0, _dm = $_.vals.length - 1; _dn <= _dm; _dn += 1) {
      $_.ai = $get($_.ais, _dn);
      var _ds = $get($_.gs1syntax, $_.ai);
      var _dt = $get(_ds, "ex") !== void 0;
      $k[$j++] = _ds;
      $k[$j++] = "ex";
      if (_dt) {
        var _du = $k[--$j];
        $forall($get($k[--$j], _du), function() {
          $_.patt = $k[--$j];
          $k[$j++] = $_.patt;
          $k[$j++] = $_.ai;
          $_.aiexists();
          if ($k[--$j]) {
            var _e3 = $s($_.ai.length + $_.patt.length + 36);
            $puti(_e3, 0, "AIs (");
            $puti(_e3, 5, $_.ai);
            $puti(_e3, 5 + $_.ai.length, ") and (");
            $puti(_e3, 12 + $_.ai.length, $_.patt);
            $puti(_e3, 12 + $_.ai.length + $_.patt.length, ") are mutually exclusive");
            $k[$j++] = "bwipp.GS1exclusiveAIs#3635";
            $k[$j++] = _e3;
            bwipp_raiseerror();
          }
        });
      } else {
        $j -= 2;
      }
      if ($_.lintreqs) {
        var _eD = $get($_.gs1syntax, $_.ai);
        var _eE = $get(_eD, "req") !== void 0;
        $k[$j++] = _eD;
        $k[$j++] = "req";
        if (_eE) {
          var _eF = $k[--$j];
          $forall($get($k[--$j], _eF), function() {
            var _eI = $k[--$j];
            $k[$j++] = false;
            $forall(_eI, function() {
              var _eJ = $k[--$j];
              $k[$j++] = true;
              $forall(_eJ, function() {
                $k[$j++] = $_.ai;
                $_.aiexists();
                if (!$k[--$j]) {
                  $k[$j - 1] = false;
                }
              });
              if ($k[--$j]) {
                $k[$j - 1] = true;
                return true;
              }
            });
            if (!$k[--$j]) {
              $k[$j++] = Infinity;
              $forall($get($get($_.gs1syntax, $_.ai), "req"), function() {
                $forall($k[--$j], function() {
                  $forall($k[--$j], function() {
                    $k[$j++] = "+";
                  });
                  $k[$j - 1] = " OR ";
                });
                $k[$j - 1] = " WITH ";
              });
              $j--;
              var _eU = $a();
              $k[$j++] = _eU;
              $k[$j++] = 0;
              for (var _eV = 0, _eW = _eU.length; _eV < _eW; _eV++) {
                var _eY = $k[--$j];
                $k[$j++] = $f(_eY + $get(_eU, _eV).length);
              }
              var _ea = $_.ai.length + 49;
              $k[$j++] = _ea;
              $k[$j++] = _ea;
              var _eb = $k[$j - 3];
              var _ed = $s($f($k[$j - 1] + _eb));
              var _ee = $k[$j - 2];
              $j -= 3;
              $k[$j++] = _ed;
              $k[$j++] = _ee;
              $r(3, -1);
              $forall($k[--$j], function() {
                var _eg = $k[--$j];
                var _eh = $k[--$j];
                var _ei = $k[$j - 1];
                $puti(_ei, _eh, _eg);
                $k[$j++] = $f(_eg.length + _eh);
              });
              $j--;
              var _ej = $k[--$j];
              $puti(_ej, 0, "One of more requisite AIs for AI (");
              $puti(_ej, 34, $_.ai);
              $puti(_ej, 34 + $_.ai.length, ") are missing: ");
              $k[$j++] = "bwipp.GS1missingAIs#3662";
              $k[$j++] = _ej;
              bwipp_raiseerror();
            }
          });
        } else {
          $j -= 2;
        }
      }
    }
  }
  $k[$j++] = $_.ais;
  $k[$j++] = $_.vals;
  $k[$j++] = $_.fncs;
  $_ = $__;
}
function bwipp_ean5() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.textfont = "OCR-B";
  $_.textsize = 12;
  $_.textxoffset = 0;
  $_.textyoffset = null;
  $_.height = 0.7;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.textyoffset == null) {
    $_.textyoffset = $_.height * 72 + 1;
  }
  if ($_.barcode.length != 5) {
    $k[$j++] = "bwipp.ean5badLength#4997";
    $k[$j++] = "EAN-5 add-on must be 5 digits";
    bwipp_raiseerror();
  }
  $forall($_.barcode, function() {
    var _6 = $k[--$j];
    if (_6 < 48 || _6 > 57) {
      $k[$j++] = "bwipp.ean5badCharacter#5001";
      $k[$j++] = "EAN-5 add-on must contain only digits";
      bwipp_raiseerror();
    }
  });
  $_.encs = $a(["3211", "2221", "2122", "1411", "1132", "1231", "1114", "1312", "1213", "3112", "112", "11"]);
  $_.barchars = "0123456789";
  $_.mirrormaps = $a(["11000", "10100", "10010", "10001", "01100", "00110", "00011", "01010", "01001", "00101"]);
  $_.checksum = 0;
  for (var _A = 0; _A <= 4; _A += 1) {
    $_.i = _A;
    $_.barchar = $get($_.barcode, $_.i) - 48;
    if ($_.i % 2 == 0) {
      $_.checksum = $f($_.barchar * 3 + $_.checksum);
    } else {
      $_.checksum = $f($_.barchar * 9 + $_.checksum);
    }
  }
  $_.checksum = $_.checksum % 10;
  $_.mirrormap = $get($_.mirrormaps, $_.checksum);
  $_.sbs = $s(31);
  $_.txt = $a(5);
  for (var _P = 0; _P <= 4; _P += 1) {
    $_.i = _P;
    if ($_.i == 0) {
      $puti($_.sbs, 0, $get($_.encs, 10));
    } else {
      $puti($_.sbs, ($_.i - 1) * 6 + 7, $get($_.encs, 11));
    }
    $search($_.barchars, $geti($_.barcode, $_.i, 1));
    $j--;
    $_.indx = $k[--$j].length;
    $j -= 2;
    $_.enc = $get($_.encs, $_.indx);
    if ($get($_.mirrormap, $_.i) == 49) {
      $_.enclen = $_.enc.length;
      $_.revenc = $s($_.enclen);
      for (var _o = 0, _n = $_.enclen - 1; _o <= _n; _o += 1) {
        $_.j = _o;
        $_.char = $get($_.enc, $_.j);
        $put($_.revenc, $_.enclen - $_.j - 1, $_.char);
      }
      $_.enc = $_.revenc;
    }
    $puti($_.sbs, $_.i * 6 + 3, $_.enc);
    $put($_.txt, $_.i, $a([$geti($_.barcode, $_.i, 1), ($_.i - 1) * 9 + 10 + $_.textxoffset, $_.textyoffset, $_.textfont, $_.textsize]));
  }
  $k[$j++] = Infinity;
  $k[$j++] = Infinity;
  var _1B = $_.sbs;
  for (var _1C = 0, _1D = _1B.length; _1C < _1D; _1C++) {
    $k[$j++] = $get(_1B, _1C) - 48;
  }
  var _1F = $a();
  $k[$j++] = Infinity;
  for (var _1G = 0; _1G < 16; _1G++) {
    $k[$j++] = $_.height;
  }
  var _1I = $a();
  $k[$j++] = Infinity;
  for (var _1J = 0; _1J < 16; _1J++) {
    $k[$j++] = 0;
  }
  var _1K = $a();
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "sbs";
  $k[$j++] = _1F;
  $k[$j++] = "bhs";
  $k[$j++] = _1I;
  $k[$j++] = "bbs";
  $k[$j++] = _1K;
  if ($_.includetext) {
    $k[$j++] = "txt";
    $k[$j++] = $_.txt;
  }
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  $k[$j++] = "guardrightpos";
  $k[$j++] = 5;
  $k[$j++] = "guardrightypos";
  $k[$j++] = $_.textyoffset + 4;
  $k[$j++] = "borderleft";
  $k[$j++] = 12;
  $k[$j++] = "borderright";
  $k[$j++] = 5;
  $k[$j++] = "bordertop";
  $k[$j++] = 10;
  var _1P = $d();
  $k[$j++] = _1P;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_ean2() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.textfont = "OCR-B";
  $_.textsize = 12;
  $_.textxoffset = 0;
  $_.textyoffset = null;
  $_.height = 0.7;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.textyoffset == null) {
    $_.textyoffset = $_.height * 72 + 1;
  }
  if ($_.barcode.length != 2) {
    $k[$j++] = "bwipp.ean2badLength#5142";
    $k[$j++] = "EAN-2 add-on must be 2 digits";
    bwipp_raiseerror();
  }
  $forall($_.barcode, function() {
    var _6 = $k[--$j];
    if (_6 < 48 || _6 > 57) {
      $k[$j++] = "bwipp.ean2badCharacter#5146";
      $k[$j++] = "EAN-2 add-on must contain only digits";
      bwipp_raiseerror();
    }
  });
  $_.encs = $a(["3211", "2221", "2122", "1411", "1132", "1231", "1114", "1312", "1213", "3112", "112", "11"]);
  $_.barchars = "0123456789";
  $_.mirrormaps = $a(["00", "01", "10", "11"]);
  $_.mirrormap = $get($_.mirrormaps, $cvi($geti($_.barcode, 0, 2)) % 4);
  $_.sbs = $s(13);
  $_.txt = $a(2);
  for (var _G = 0; _G <= 1; _G += 1) {
    $_.i = _G;
    if ($_.i == 0) {
      $puti($_.sbs, 0, $get($_.encs, 10));
    } else {
      $puti($_.sbs, ($_.i - 1) * 6 + 7, $get($_.encs, 11));
    }
    $search($_.barchars, $geti($_.barcode, $_.i, 1));
    $j--;
    $_.indx = $k[--$j].length;
    $j -= 2;
    $_.enc = $get($_.encs, $_.indx);
    if ($get($_.mirrormap, $_.i) == 49) {
      $_.enclen = $_.enc.length;
      $_.revenc = $s($_.enclen);
      for (var _f = 0, _e = $_.enclen - 1; _f <= _e; _f += 1) {
        $_.j = _f;
        $_.char = $get($_.enc, $_.j);
        $put($_.revenc, $_.enclen - $_.j - 1, $_.char);
      }
      $_.enc = $_.revenc;
    }
    $puti($_.sbs, $_.i * 6 + 3, $_.enc);
    $put($_.txt, $_.i, $a([$geti($_.barcode, $_.i, 1), ($_.i - 1) * 9 + 10 + $_.textxoffset, $_.textyoffset, $_.textfont, $_.textsize]));
  }
  $k[$j++] = Infinity;
  $k[$j++] = Infinity;
  var _12 = $_.sbs;
  for (var _13 = 0, _14 = _12.length; _13 < _14; _13++) {
    $k[$j++] = $get(_12, _13) - 48;
  }
  var _16 = $a();
  $k[$j++] = Infinity;
  for (var _17 = 0; _17 < 12; _17++) {
    $k[$j++] = $_.height;
  }
  var _19 = $a();
  $k[$j++] = Infinity;
  for (var _1A = 0; _1A < 12; _1A++) {
    $k[$j++] = 0;
  }
  var _1B = $a();
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "sbs";
  $k[$j++] = _16;
  $k[$j++] = "bhs";
  $k[$j++] = _19;
  $k[$j++] = "bbs";
  $k[$j++] = _1B;
  if ($_.includetext) {
    $k[$j++] = "txt";
    $k[$j++] = $_.txt;
  }
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  $k[$j++] = "guardrightpos";
  $k[$j++] = 5;
  $k[$j++] = "guardrightypos";
  $k[$j++] = $_.textyoffset + 4;
  $k[$j++] = "borderleft";
  $k[$j++] = 12;
  $k[$j++] = "borderright";
  $k[$j++] = 5;
  $k[$j++] = "bordertop";
  $k[$j++] = 10;
  var _1G = $d();
  $k[$j++] = _1G;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_ean13() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.textfont = "OCR-B";
  $_.textsize = 12;
  $_.textxoffset = -11;
  $_.textyoffset = -4;
  $_.height = 1;
  $_.addongap = 12;
  $_.addontextfont = "unset";
  $_.addontextsize = null;
  $_.addontextxoffset = null;
  $_.addontextyoffset = null;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $search($_.barcode, " ");
  if ($k[--$j]) {
    $_.barcode = $k[--$j];
    $j--;
    $_.addon = $k[--$j];
  } else {
    $j--;
    $_.addon = "";
  }
  if ($_.barcode.length != 12 && $_.barcode.length != 13) {
    $k[$j++] = "bwipp.ean13badLength#5286";
    $k[$j++] = "EAN-13 must be 12 or 13 digits";
    bwipp_raiseerror();
  }
  $forall($_.barcode, function() {
    var _9 = $k[--$j];
    if (_9 < 48 || _9 > 57) {
      $k[$j++] = "bwipp.ean13badCharacter#5290";
      $k[$j++] = "EAN-13 must contain only digits";
      bwipp_raiseerror();
    }
  });
  if ($_.addon.length != 0 && $_.addon.length != 2 && $_.addon.length != 5) {
    $k[$j++] = "bwipp.ean13badAddOnLength#5294";
    $k[$j++] = "Add-on for EAN-13 must be 2 or 5 digits";
    bwipp_raiseerror();
  }
  $_.pad = $s(13);
  $_.checksum = 0;
  for (var _E = 0; _E <= 11; _E += 1) {
    $_.i = _E;
    $_.barchar = $get($_.barcode, $_.i) - 48;
    if ($_.i % 2 == 0) {
      $_.checksum = $f($_.barchar + $_.checksum);
    } else {
      $_.checksum = $f($_.barchar * 3 + $_.checksum);
    }
  }
  $_.checksum = (10 - $_.checksum % 10) % 10;
  if ($_.barcode.length == 13) {
    if ($get($_.barcode, 12) != $_.checksum + 48) {
      $k[$j++] = "bwipp.ean13badCheckDigit#5312";
      $k[$j++] = "Incorrect EAN-13 check digit provided";
      bwipp_raiseerror();
    }
  }
  $puti($_.pad, 0, $_.barcode);
  $put($_.pad, 12, $_.checksum + 48);
  $_.barcode = $_.pad;
  $_.encs = $a(["3211", "2221", "2122", "1411", "1132", "1231", "1114", "1312", "1213", "3112", "111", "11111", "111"]);
  $_.barchars = "0123456789";
  $_.mirrormaps = $a(["000000", "001011", "001101", "001110", "010011", "011001", "011100", "010101", "010110", "011010"]);
  $_.sbs = $s(59);
  $_.txt = $a(13);
  $puti($_.sbs, 0, $get($_.encs, 10));
  $_.mirrormap = $get($_.mirrormaps, $get($_.barcode, 0) - 48);
  $put($_.txt, 0, $a([$geti($_.barcode, 0, 1), $_.textxoffset, $_.textyoffset, $_.textfont, $_.textsize]));
  for (var _r = 1; _r <= 6; _r += 1) {
    $_.i = _r;
    $search($_.barchars, $geti($_.barcode, $_.i, 1));
    $j--;
    $_.indx = $k[--$j].length;
    $j -= 2;
    $_.enc = $get($_.encs, $_.indx);
    if ($get($_.mirrormap, $_.i - 1) == 49) {
      $_.enclen = $_.enc.length;
      $_.revenc = $s($_.enclen);
      for (var _18 = 0, _17 = $_.enclen - 1; _18 <= _17; _18 += 1) {
        $_.j = _18;
        $_.char = $get($_.enc, $_.j);
        $put($_.revenc, $_.enclen - $_.j - 1, $_.char);
      }
      $_.enc = $_.revenc;
    }
    $puti($_.sbs, ($_.i - 1) * 4 + 3, $_.enc);
    $put($_.txt, $_.i, $a([$geti($_.barcode, $_.i, 1), ($_.i - 1) * 7 + 15 + $_.textxoffset, $_.textyoffset, $_.textfont, $_.textsize]));
  }
  $puti($_.sbs, (7 - 1) * 4 + 3, $get($_.encs, 11));
  for (var _1Y = 7; _1Y <= 12; _1Y += 1) {
    $_.i = _1Y;
    $search($_.barchars, $geti($_.barcode, $_.i, 1));
    $j--;
    $_.indx = $k[--$j].length;
    $j -= 2;
    $_.enc = $get($_.encs, $_.indx);
    $puti($_.sbs, ($_.i - 1) * 4 + 8, $_.enc);
    $put($_.txt, $_.i, $a([$geti($_.barcode, $_.i, 1), ($_.i - 1) * 7 + 19 + $_.textxoffset, $_.textyoffset, $_.textfont, $_.textsize]));
  }
  $puti($_.sbs, 56, $get($_.encs, 12));
  $k[$j++] = Infinity;
  var _1y = $_.sbs;
  for (var _1z = 0, _20 = _1y.length; _1z < _20; _1z++) {
    $k[$j++] = $get(_1y, _1z) - 48;
  }
  $_.sbs = $a();
  if ($_.includetext) {
    $k[$j++] = Infinity;
    $k[$j++] = $_.height;
    $k[$j++] = $_.height;
    for (var _26 = 0; _26 < 12; _26++) {
      $k[$j++] = $f($_.height - 0.075);
    }
    $k[$j++] = $_.height;
    $k[$j++] = $_.height;
    for (var _2A = 0; _2A < 12; _2A++) {
      $k[$j++] = $f($_.height - 0.075);
    }
    $k[$j++] = $_.height;
    $k[$j++] = $_.height;
    $_.bhs = $a();
    $k[$j++] = Infinity;
    $k[$j++] = 0;
    $k[$j++] = 0;
    for (var _2F = 0; _2F < 12; _2F++) {
      $k[$j++] = 0.075;
    }
    $k[$j++] = 0;
    $k[$j++] = 0;
    for (var _2G = 0; _2G < 12; _2G++) {
      $k[$j++] = 0.075;
    }
    $k[$j++] = 0;
    $k[$j++] = 0;
    $_.bbs = $a();
  } else {
    $k[$j++] = Infinity;
    for (var _2I = 0; _2I < 30; _2I++) {
      $k[$j++] = $_.height;
    }
    $_.bhs = $a();
    $k[$j++] = Infinity;
    for (var _2L = 0; _2L < 30; _2L++) {
      $k[$j++] = 0;
    }
    $_.bbs = $a();
    $_.txt = $a([]);
  }
  $_.guardrightypos = 0;
  if ($_.addon.length != 0) {
    $k[$j++] = Infinity;
    $k[$j++] = "dontdraw";
    $k[$j++] = true;
    $k[$j++] = "includetext";
    $k[$j++] = true;
    $k[$j++] = "height";
    $k[$j++] = $_.height;
    if ($_.includetext) {
      var _2R = $k[--$j];
      $k[$j++] = $f(_2R - 0.15);
    }
    $k[$j++] = "textxoffset";
    if ($_.addontextxoffset != null) {
      $k[$j++] = $_.addontextxoffset;
    } else {
      $k[$j++] = 95 + $_.addongap;
    }
    if ($_.addontextyoffset != null) {
      $k[$j++] = "textyoffset";
      $k[$j++] = $_.addontextyoffset;
    }
    $k[$j++] = "textsize";
    if ($_.addontextsize != null) {
      $k[$j++] = $_.addontextsize;
    } else {
      $k[$j++] = $_.textsize;
    }
    var _2b = $ne($_.addontextfont, "unset") ? $_.addontextfont : $_.textfont;
    $k[$j++] = "textfont";
    $k[$j++] = _2b;
    $_.addopts = $d();
    if ($_.addon.length == 2) {
      $k[$j++] = $_.addon;
      $k[$j++] = $_.addopts;
      bwipp_ean2();
    }
    if ($_.addon.length == 5) {
      $k[$j++] = $_.addon;
      $k[$j++] = $_.addopts;
      bwipp_ean5();
    }
    $_.addcode = $k[--$j];
    $k[$j++] = Infinity;
    $aload($_.sbs);
    $k[$j++] = $_.addongap;
    $aload($get($_.addcode, "sbs"));
    $_.sbs = $a();
    $k[$j++] = Infinity;
    $aload($_.bhs);
    $aload($get($_.addcode, "bhs"));
    $_.bhs = $a();
    $k[$j++] = Infinity;
    $aload($_.bbs);
    $aload($get($_.addcode, "bbs"));
    $_.bbs = $a();
    $k[$j++] = Infinity;
    $aload($_.txt);
    $aload($get($_.addcode, "txt"));
    $_.txt = $a();
    $_.guardrightypos = $_.height * 72 - 6;
  }
  $k[$j++] = Infinity;
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "sbs";
  $k[$j++] = $_.sbs;
  $k[$j++] = "bhs";
  $k[$j++] = $_.bhs;
  $k[$j++] = "bbs";
  $k[$j++] = $_.bbs;
  $k[$j++] = "txt";
  $k[$j++] = $_.txt;
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  $k[$j++] = "guardrightpos";
  if ($_.addon.length == 0) {
    $k[$j++] = 7;
  } else {
    $k[$j++] = 5;
  }
  $k[$j++] = "guardrightypos";
  $k[$j++] = $_.guardrightypos;
  $k[$j++] = "borderleft";
  $k[$j++] = 11;
  $k[$j++] = "borderright";
  if ($_.addon.length == 0) {
    $k[$j++] = 7;
  } else {
    $k[$j++] = 5;
  }
  $k[$j++] = "bordertop";
  $k[$j++] = 0;
  $k[$j++] = "borderbottom";
  $k[$j++] = 5;
  var _3A = $d();
  $k[$j++] = _3A;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_ean8() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.textfont = "OCR-B";
  $_.textsize = 12;
  $_.textxoffset = 4;
  $_.textyoffset = -4;
  $_.height = 1;
  $_.permitaddon = false;
  $_.addongap = 12;
  $_.addontextfont = "unset";
  $_.addontextsize = null;
  $_.addontextxoffset = null;
  $_.addontextyoffset = null;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $search($_.barcode, " ");
  if ($k[--$j]) {
    $_.barcode = $k[--$j];
    $j--;
    $_.addon = $k[--$j];
  } else {
    $j--;
    $_.addon = "";
  }
  if ($_.barcode.length != 7 && $_.barcode.length != 8) {
    $k[$j++] = "bwipp.ean8badLength#5507";
    $k[$j++] = "EAN-8 must be 7 or 8 digits";
    bwipp_raiseerror();
  }
  $forall($_.barcode, function() {
    var _9 = $k[--$j];
    if (_9 < 48 || _9 > 57) {
      $k[$j++] = "bwipp.ean8badCharacter#5511";
      $k[$j++] = "EAN-8 must contain only digits";
      bwipp_raiseerror();
    }
  });
  if ($_.addon.length != 0 && $_.addon.length != 2 && $_.addon.length != 5) {
    $k[$j++] = "bwipp.ean8badAddOnLength#5515";
    $k[$j++] = "Add-on for EAN-8 must be 2 or 5 digits";
    bwipp_raiseerror();
  }
  if (!$_.permitaddon && $_.addon.length != 0) {
    $k[$j++] = "bwipp.ean8badAddOnLength#5518";
    $k[$j++] = 'Non-standard use of add-on for EAN-8 requires "permitaddon" option';
    bwipp_raiseerror();
  }
  $_.pad = $s(8);
  $_.checksum = 0;
  for (var _G = 0; _G <= 6; _G += 1) {
    $_.i = _G;
    $_.barchar = $get($_.barcode, $_.i) - 48;
    if ($_.i % 2 != 0) {
      $_.checksum = $f($_.barchar + $_.checksum);
    } else {
      $_.checksum = $f($_.barchar * 3 + $_.checksum);
    }
  }
  $_.checksum = (10 - $_.checksum % 10) % 10;
  if ($_.barcode.length == 8) {
    if ($get($_.barcode, 7) != $_.checksum + 48) {
      $k[$j++] = "bwipp.ean8badCheckDigit#5536";
      $k[$j++] = "Incorrect EAN-8 check digit provided";
      bwipp_raiseerror();
    }
  }
  $puti($_.pad, 0, $_.barcode);
  $put($_.pad, 7, $_.checksum + 48);
  $_.barcode = $_.pad;
  $_.encs = $a(["3211", "2221", "2122", "1411", "1132", "1231", "1114", "1312", "1213", "3112", "111", "11111", "111"]);
  $_.barchars = "0123456789";
  $_.sbs = $s(43);
  $_.txt = $a(8);
  $puti($_.sbs, 0, $get($_.encs, 10));
  for (var _g = 0; _g <= 3; _g += 1) {
    $_.i = _g;
    $search($_.barchars, $geti($_.barcode, $_.i, 1));
    $j--;
    $_.indx = $k[--$j].length;
    $j -= 2;
    $_.enc = $get($_.encs, $_.indx);
    $puti($_.sbs, $_.i * 4 + 3, $_.enc);
    $put($_.txt, $_.i, $a([$geti($_.barcode, $_.i, 1), $_.i * 7 + $_.textxoffset, $_.textyoffset, $_.textfont, $_.textsize]));
  }
  $puti($_.sbs, 4 * 4 + 3, $get($_.encs, 11));
  for (var _16 = 4; _16 <= 7; _16 += 1) {
    $_.i = _16;
    $search($_.barchars, $geti($_.barcode, $_.i, 1));
    $j--;
    $_.indx = $k[--$j].length;
    $j -= 2;
    $_.enc = $get($_.encs, $_.indx);
    $puti($_.sbs, $_.i * 4 + 8, $_.enc);
    $put($_.txt, $_.i, $a([$geti($_.barcode, $_.i, 1), $_.i * 7 + $_.textxoffset + 4, $_.textyoffset, $_.textfont, $_.textsize]));
  }
  $puti($_.sbs, 40, $get($_.encs, 12));
  $k[$j++] = Infinity;
  var _1W = $_.sbs;
  for (var _1X = 0, _1Y = _1W.length; _1X < _1Y; _1X++) {
    $k[$j++] = $get(_1W, _1X) - 48;
  }
  $_.sbs = $a();
  if ($_.includetext) {
    $k[$j++] = Infinity;
    $k[$j++] = $_.height;
    $k[$j++] = $_.height;
    for (var _1e = 0; _1e < 8; _1e++) {
      $k[$j++] = $f($_.height - 0.075);
    }
    $k[$j++] = $_.height;
    $k[$j++] = $_.height;
    for (var _1i = 0; _1i < 8; _1i++) {
      $k[$j++] = $f($_.height - 0.075);
    }
    $k[$j++] = $_.height;
    $k[$j++] = $_.height;
    $_.bhs = $a();
    $k[$j++] = Infinity;
    $k[$j++] = 0;
    $k[$j++] = 0;
    for (var _1n = 0; _1n < 8; _1n++) {
      $k[$j++] = 0.075;
    }
    $k[$j++] = 0;
    $k[$j++] = 0;
    for (var _1o = 0; _1o < 8; _1o++) {
      $k[$j++] = 0.075;
    }
    $k[$j++] = 0;
    $k[$j++] = 0;
    $_.bbs = $a();
  } else {
    $k[$j++] = Infinity;
    for (var _1q = 0; _1q < 22; _1q++) {
      $k[$j++] = $_.height;
    }
    $_.bhs = $a();
    $k[$j++] = Infinity;
    for (var _1t = 0; _1t < 22; _1t++) {
      $k[$j++] = 0;
    }
    $_.bbs = $a();
    $_.txt = $a([]);
  }
  $_.guardrightypos = 0;
  if ($_.addon.length != 0) {
    $k[$j++] = Infinity;
    $k[$j++] = "dontdraw";
    $k[$j++] = true;
    $k[$j++] = "includetext";
    $k[$j++] = true;
    $k[$j++] = "height";
    $k[$j++] = $_.height;
    if ($_.includetext) {
      var _1z = $k[--$j];
      $k[$j++] = $f(_1z - 0.15);
    }
    $k[$j++] = "textxoffset";
    if ($_.addontextxoffset != null) {
      $k[$j++] = $_.addontextxoffset;
    } else {
      $k[$j++] = 67 + $_.addongap;
    }
    if ($_.addontextyoffset != null) {
      $k[$j++] = "textyoffset";
      $k[$j++] = $_.addontextyoffset;
    }
    $k[$j++] = "textsize";
    if ($_.addontextsize != null) {
      $k[$j++] = $_.addontextsize;
    } else {
      $k[$j++] = $_.textsize;
    }
    var _29 = $ne($_.addontextfont, "unset") ? $_.addontextfont : $_.textfont;
    $k[$j++] = "textfont";
    $k[$j++] = _29;
    $_.addopts = $d();
    if ($_.addon.length == 2) {
      $k[$j++] = $_.addon;
      $k[$j++] = $_.addopts;
      bwipp_ean2();
    }
    if ($_.addon.length == 5) {
      $k[$j++] = $_.addon;
      $k[$j++] = $_.addopts;
      bwipp_ean5();
    }
    $_.addcode = $k[--$j];
    $k[$j++] = Infinity;
    $aload($_.sbs);
    $k[$j++] = $_.addongap;
    $aload($get($_.addcode, "sbs"));
    $_.sbs = $a();
    $k[$j++] = Infinity;
    $aload($_.bhs);
    $aload($get($_.addcode, "bhs"));
    $_.bhs = $a();
    $k[$j++] = Infinity;
    $aload($_.bbs);
    $aload($get($_.addcode, "bbs"));
    $_.bbs = $a();
    $k[$j++] = Infinity;
    $aload($_.txt);
    $aload($get($_.addcode, "txt"));
    $_.txt = $a();
    $_.guardrightypos = $_.height * 72 - 6;
  }
  $k[$j++] = Infinity;
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "sbs";
  $k[$j++] = $_.sbs;
  $k[$j++] = "bhs";
  $k[$j++] = $_.bhs;
  $k[$j++] = "bbs";
  $k[$j++] = $_.bbs;
  $k[$j++] = "txt";
  $k[$j++] = $_.txt;
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  $k[$j++] = "guardleftpos";
  $k[$j++] = 7;
  $k[$j++] = "guardrightpos";
  if ($_.addon.length == 0) {
    $k[$j++] = 7;
  } else {
    $k[$j++] = 5;
  }
  $k[$j++] = "guardrightypos";
  $k[$j++] = $_.guardrightypos;
  $k[$j++] = "borderleft";
  $k[$j++] = 7;
  $k[$j++] = "borderright";
  if ($_.addon.length == 0) {
    $k[$j++] = 7;
  } else {
    $k[$j++] = 5;
  }
  $k[$j++] = "bordertop";
  $k[$j++] = 0;
  $k[$j++] = "borderbottom";
  $k[$j++] = 5;
  var _2i = $d();
  $k[$j++] = _2i;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_upca() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.textfont = "OCR-B";
  $_.textsize = 12;
  $_.textxoffset = -9;
  $_.textyoffset = -4;
  $_.height = 1;
  $_.addongap = 12;
  $_.addontextfont = "unset";
  $_.addontextsize = null;
  $_.addontextxoffset = null;
  $_.addontextyoffset = null;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $search($_.barcode, " ");
  if ($k[--$j]) {
    $_.barcode = $k[--$j];
    $j--;
    $_.addon = $k[--$j];
  } else {
    $j--;
    $_.addon = "";
  }
  if ($_.barcode.length == 7 || $_.barcode.length == 8) {
    $forall($_.barcode, function() {
      var _9 = $k[--$j];
      if (_9 < 48 || _9 > 57) {
        $k[$j++] = "bwipp.upcAupcEbadCharacter#5714";
        $k[$j++] = "UPC-E must contain only digits";
        bwipp_raiseerror();
      }
    });
    var _B = $get($_.barcode, 0);
    if (_B != 48 && _B != 49) {
      $k[$j++] = "bwipp.upcAupcEbadNumberSystem#5718";
      $k[$j++] = "UPC-E must have number system 0 or 1";
      bwipp_raiseerror();
    }
    for (var _C = 0; _C < 1; _C++) {
      var _E = $_.barcode.length == 8 ? 12 : 11;
      $_.upcacode = $s(_E);
      if ($get($_.barcode, 6) - 48 <= 2) {
        $puti($_.upcacode, 0, $geti($_.barcode, 0, 3));
        $puti($_.upcacode, 3, $geti($_.barcode, 6, 1));
        $puti($_.upcacode, 4, "0000");
        $puti($_.upcacode, 8, $geti($_.barcode, 3, 3));
        break;
      }
      if ($get($_.barcode, 6) - 48 == 3) {
        $puti($_.upcacode, 0, $geti($_.barcode, 0, 4));
        $puti($_.upcacode, 4, "00000");
        $puti($_.upcacode, 9, $geti($_.barcode, 4, 2));
        break;
      }
      if ($get($_.barcode, 6) - 48 == 4) {
        $puti($_.upcacode, 0, $geti($_.barcode, 0, 5));
        $puti($_.upcacode, 5, "00000");
        $puti($_.upcacode, 10, $geti($_.barcode, 5, 1));
        break;
      }
      if ($get($_.barcode, 6) - 48 >= 5) {
        $puti($_.upcacode, 0, $geti($_.barcode, 0, 6));
        $puti($_.upcacode, 6, "0000");
        $puti($_.upcacode, 10, $geti($_.barcode, 6, 1));
        break;
      }
    }
    if ($_.barcode.length == 8) {
      $puti($_.upcacode, 11, $geti($_.barcode, 7, 1));
    }
    $_.barcode = $_.upcacode;
  }
  if ($_.barcode.length != 11 && $_.barcode.length != 12) {
    $k[$j++] = "bwipp.upcAbadLength#5756";
    $k[$j++] = "UPC-A must be 11 or 12 digits";
    bwipp_raiseerror();
  }
  var _10 = $_.barcode;
  for (var _11 = 0, _12 = _10.length; _11 < _12; _11++) {
    var _13 = $get(_10, _11);
    if (_13 < 48 || _13 > 57) {
      $k[$j++] = "bwipp.upcAbadCharacter#5760";
      $k[$j++] = "UPC-A must contain only digits";
      bwipp_raiseerror();
    }
  }
  if ($_.addon.length != 0 && $_.addon.length != 2 && $_.addon.length != 5) {
    $k[$j++] = "bwipp.upcAbadAddOnLength#5764";
    $k[$j++] = "Add-on for UPC-A must be 2 or 5 digits";
    bwipp_raiseerror();
  }
  $_.pad = $s(12);
  $_.checksum = 0;
  for (var _18 = 0; _18 <= 10; _18 += 1) {
    $_.i = _18;
    $_.barchar = $get($_.barcode, $_.i) - 48;
    if ($_.i % 2 != 0) {
      $_.checksum = $_.checksum + $_.barchar;
    } else {
      $_.checksum = $_.checksum + $_.barchar * 3;
    }
  }
  $_.checksum = (10 - $_.checksum % 10) % 10;
  if ($_.barcode.length == 12) {
    if ($get($_.barcode, 11) != $_.checksum + 48) {
      $k[$j++] = "bwipp.upcAbadCheckDigit#5782";
      $k[$j++] = "Incorrect UPC check digit provided";
      bwipp_raiseerror();
    }
  }
  $puti($_.pad, 0, $_.barcode);
  $put($_.pad, 11, $_.checksum + 48);
  $_.barcode = $_.pad;
  $_.encs = $a(["3211", "2221", "2122", "1411", "1132", "1231", "1114", "1312", "1213", "3112", "111", "11111", "111"]);
  $_.barchars = "0123456789";
  $_.sbs = $s(59);
  $_.txt = $a(12);
  $puti($_.sbs, 0, $get($_.encs, 10));
  for (var _1Y = 0; _1Y <= 5; _1Y += 1) {
    $_.i = _1Y;
    $search($_.barchars, $geti($_.barcode, $_.i, 1));
    $j--;
    $_.indx = $k[--$j].length;
    $j -= 2;
    $_.enc = $get($_.encs, $_.indx);
    $puti($_.sbs, $_.i * 4 + 3, $_.enc);
    if ($_.i == 0) {
      $put($_.txt, 0, $a([$geti($_.barcode, 0, 1), $_.textxoffset, $_.textyoffset, $_.textfont, $_.textsize - 2]));
    } else {
      $put($_.txt, $_.i, $a([$geti($_.barcode, $_.i, 1), $_.i * 7 + 13 + $_.textxoffset, $_.textyoffset, $_.textfont, $_.textsize]));
    }
  }
  $puti($_.sbs, 6 * 4 + 3, $get($_.encs, 11));
  for (var _27 = 6; _27 <= 11; _27 += 1) {
    $_.i = _27;
    $search($_.barchars, $geti($_.barcode, $_.i, 1));
    $j--;
    $_.indx = $k[--$j].length;
    $j -= 2;
    $_.enc = $get($_.encs, $_.indx);
    $puti($_.sbs, $_.i * 4 + 8, $_.enc);
    if ($_.i == 11) {
      $put($_.txt, 11, $a([$geti($_.barcode, 11, 1), $_.textxoffset + 107, $_.textyoffset, $_.textfont, $_.textsize - 2]));
    } else {
      $put($_.txt, $_.i, $a([$geti($_.barcode, $_.i, 1), $_.i * 7 + $_.textxoffset + 17, $_.textyoffset, $_.textfont, $_.textsize]));
    }
  }
  $puti($_.sbs, 56, $get($_.encs, 12));
  $k[$j++] = Infinity;
  var _2g = $_.sbs;
  for (var _2h = 0, _2i = _2g.length; _2h < _2i; _2h++) {
    $k[$j++] = $get(_2g, _2h) - 48;
  }
  $_.sbs = $a();
  if ($_.includetext) {
    $k[$j++] = Infinity;
    for (var _2m = 0; _2m < 4; _2m++) {
      $k[$j++] = $_.height;
    }
    for (var _2o = 0; _2o < 10; _2o++) {
      $k[$j++] = $f($_.height - 0.075);
    }
    $k[$j++] = $_.height;
    $k[$j++] = $_.height;
    for (var _2s = 0; _2s < 10; _2s++) {
      $k[$j++] = $f($_.height - 0.075);
    }
    for (var _2u = 0; _2u < 4; _2u++) {
      $k[$j++] = $_.height;
    }
    $_.bhs = $a();
    $k[$j++] = Infinity;
    $k[$j++] = 0;
    $k[$j++] = 0;
    $k[$j++] = 0;
    $k[$j++] = 0;
    for (var _2x = 0; _2x < 10; _2x++) {
      $k[$j++] = 0.075;
    }
    $k[$j++] = 0;
    $k[$j++] = 0;
    for (var _2y = 0; _2y < 10; _2y++) {
      $k[$j++] = 0.075;
    }
    $k[$j++] = 0;
    $k[$j++] = 0;
    $k[$j++] = 0;
    $k[$j++] = 0;
    $_.bbs = $a();
  } else {
    $k[$j++] = Infinity;
    for (var _30 = 0; _30 < 30; _30++) {
      $k[$j++] = $_.height;
    }
    $_.bhs = $a();
    $k[$j++] = Infinity;
    for (var _33 = 0; _33 < 30; _33++) {
      $k[$j++] = 0;
    }
    $_.bbs = $a();
    $_.txt = $a([]);
  }
  $_.guardrightypos = 0;
  if ($_.addon.length != 0) {
    $k[$j++] = Infinity;
    $k[$j++] = "dontdraw";
    $k[$j++] = true;
    $k[$j++] = "includetext";
    $k[$j++] = true;
    $k[$j++] = "height";
    $k[$j++] = $_.height;
    if ($_.includetext) {
      var _39 = $k[--$j];
      $k[$j++] = $f(_39 - 0.15);
    }
    $k[$j++] = "textxoffset";
    if ($_.addontextxoffset != null) {
      $k[$j++] = $_.addontextxoffset;
    } else {
      $k[$j++] = 95 + $_.addongap;
    }
    if ($_.addontextyoffset != null) {
      $k[$j++] = "textyoffset";
      $k[$j++] = $_.addontextyoffset;
    }
    $k[$j++] = "textsize";
    if ($_.addontextsize != null) {
      $k[$j++] = $_.addontextsize;
    } else {
      $k[$j++] = $_.textsize;
    }
    var _3J = $ne($_.addontextfont, "unset") ? $_.addontextfont : $_.textfont;
    $k[$j++] = "textfont";
    $k[$j++] = _3J;
    $_.addopts = $d();
    if ($_.addon.length == 2) {
      $k[$j++] = $_.addon;
      $k[$j++] = $_.addopts;
      bwipp_ean2();
    }
    if ($_.addon.length == 5) {
      $k[$j++] = $_.addon;
      $k[$j++] = $_.addopts;
      bwipp_ean5();
    }
    $_.addcode = $k[--$j];
    $k[$j++] = Infinity;
    $aload($_.sbs);
    $k[$j++] = $_.addongap;
    $aload($get($_.addcode, "sbs"));
    $_.sbs = $a();
    $k[$j++] = Infinity;
    $aload($_.bhs);
    $aload($get($_.addcode, "bhs"));
    $_.bhs = $a();
    $k[$j++] = Infinity;
    $aload($_.bbs);
    $aload($get($_.addcode, "bbs"));
    $_.bbs = $a();
    $k[$j++] = Infinity;
    $aload($_.txt);
    $aload($get($_.addcode, "txt"));
    $_.txt = $a();
    $_.guardrightypos = $_.height * 72 - 6;
  }
  $k[$j++] = Infinity;
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "sbs";
  $k[$j++] = $_.sbs;
  $k[$j++] = "bhs";
  $k[$j++] = $_.bhs;
  $k[$j++] = "bbs";
  $k[$j++] = $_.bbs;
  $k[$j++] = "txt";
  $k[$j++] = $_.txt;
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  $k[$j++] = "guardrightpos";
  if ($_.addon.length == 0) {
    $k[$j++] = 9;
  } else {
    $k[$j++] = 5;
  }
  $k[$j++] = "guardrightypos";
  $k[$j++] = $_.guardrightypos;
  $k[$j++] = "borderleft";
  $k[$j++] = 9;
  $k[$j++] = "borderright";
  if ($_.addon.length == 0) {
    $k[$j++] = 9;
  } else {
    $k[$j++] = 5;
  }
  $k[$j++] = "bordertop";
  $k[$j++] = 0;
  $k[$j++] = "borderbottom";
  $k[$j++] = 5;
  var _3s = $d();
  $k[$j++] = _3s;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_upce() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.textfont = "OCR-B";
  $_.textsize = 12;
  $_.textxoffset = -9;
  $_.textyoffset = -4;
  $_.height = 1;
  $_.addongap = 12;
  $_.addontextfont = "unset";
  $_.addontextsize = null;
  $_.addontextxoffset = null;
  $_.addontextyoffset = null;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $search($_.barcode, " ");
  if ($k[--$j]) {
    $_.barcode = $k[--$j];
    $j--;
    $_.addon = $k[--$j];
  } else {
    $j--;
    $_.addon = "";
  }
  if ($_.barcode.length == 11 || $_.barcode.length == 12) {
    $forall($_.barcode, function() {
      var _9 = $k[--$j];
      if (_9 < 48 || _9 > 57) {
        $k[$j++] = "bwipp.upcEupcAbadCharacter#5967";
        $k[$j++] = "UPC-A must contain only digits";
        bwipp_raiseerror();
      }
    });
    for (var _A = 0; _A < 1; _A++) {
      var _C = $_.barcode.length == 12 ? 8 : 7;
      $_.upcecode = $s(_C);
      if ($get($_.barcode, 3) - 48 <= 2 && $eq($geti($_.barcode, 4, 4), "0000")) {
        $puti($_.upcecode, 0, $geti($_.barcode, 0, 3));
        $puti($_.upcecode, 3, $geti($_.barcode, 8, 3));
        $puti($_.upcecode, 6, $geti($_.barcode, 3, 1));
        break;
      }
      if ($eq($geti($_.barcode, 4, 5), "00000")) {
        $puti($_.upcecode, 0, $geti($_.barcode, 0, 4));
        $puti($_.upcecode, 4, $geti($_.barcode, 9, 2));
        $puti($_.upcecode, 6, "3");
        break;
      }
      if ($eq($geti($_.barcode, 5, 5), "00000")) {
        $puti($_.upcecode, 0, $geti($_.barcode, 0, 5));
        $puti($_.upcecode, 5, $geti($_.barcode, 10, 1));
        $puti($_.upcecode, 6, "4");
        break;
      }
      if ($get($_.barcode, 10) - 48 >= 5 && $eq($geti($_.barcode, 6, 4), "0000")) {
        $puti($_.upcecode, 0, $geti($_.barcode, 0, 6));
        $puti($_.upcecode, 6, $geti($_.barcode, 10, 1));
        break;
      }
      $k[$j++] = "bwipp.upcEupcAnotCompressible#5995";
      $k[$j++] = "UPC-A cannot be converted to a UPC-E";
      bwipp_raiseerror();
    }
    if ($_.barcode.length == 12) {
      $puti($_.upcecode, 7, $geti($_.barcode, 11, 1));
    }
    $_.barcode = $_.upcecode;
  }
  if ($_.barcode.length != 7 && $_.barcode.length != 8) {
    $k[$j++] = "bwipp.upcEbadLength#6005";
    $k[$j++] = "UPC-E must be 7 or 8 digits";
    bwipp_raiseerror();
  }
  var _10 = $_.barcode;
  for (var _11 = 0, _12 = _10.length; _11 < _12; _11++) {
    var _13 = $get(_10, _11);
    if (_13 < 48 || _13 > 57) {
      $k[$j++] = "bwipp.upcEbadCharacter#6009";
      $k[$j++] = "UPC-E must contain only digits";
      bwipp_raiseerror();
    }
  }
  if ($_.addon.length != 0 && $_.addon.length != 2 && $_.addon.length != 5) {
    $k[$j++] = "bwipp.upcEbadAddOnLength#6013";
    $k[$j++] = "Add-on for UPC-E must be 2 or 5 digits";
    bwipp_raiseerror();
  }
  var _18 = $get($_.barcode, 0);
  if (_18 != 48 && _18 != 49) {
    $k[$j++] = "bwipp.upcEbadNumberSystem#6018";
    $k[$j++] = "UPC-E must have number system 0 or 1";
    bwipp_raiseerror();
  }
  $_.encs = $a(["3211", "2221", "2122", "1411", "1132", "1231", "1114", "1312", "1213", "3112", "111", "111111"]);
  $_.barchars = "0123456789";
  $_.mirrormaps = $a(["000111", "001011", "001101", "001110", "010011", "011001", "011100", "010101", "010110", "011010"]);
  for (var _1C = 0; _1C < 1; _1C++) {
    $_.upcacode = $s(11);
    if ($get($_.barcode, 6) - 48 <= 2) {
      $puti($_.upcacode, 0, $geti($_.barcode, 0, 3));
      $puti($_.upcacode, 3, $geti($_.barcode, 6, 1));
      $puti($_.upcacode, 4, "0000");
      $puti($_.upcacode, 8, $geti($_.barcode, 3, 3));
      break;
    }
    if ($get($_.barcode, 6) - 48 == 3) {
      $puti($_.upcacode, 0, $geti($_.barcode, 0, 4));
      $puti($_.upcacode, 4, "00000");
      $puti($_.upcacode, 9, $geti($_.barcode, 4, 2));
      break;
    }
    if ($get($_.barcode, 6) - 48 == 4) {
      $puti($_.upcacode, 0, $geti($_.barcode, 0, 5));
      $puti($_.upcacode, 5, "00000");
      $puti($_.upcacode, 10, $geti($_.barcode, 5, 1));
      break;
    }
    if ($get($_.barcode, 6) - 48 >= 5) {
      $puti($_.upcacode, 0, $geti($_.barcode, 0, 6));
      $puti($_.upcacode, 6, "0000");
      $puti($_.upcacode, 10, $geti($_.barcode, 6, 1));
      break;
    }
  }
  $_.checksum = 0;
  for (var _1r = 0; _1r <= 10; _1r += 1) {
    $_.i = _1r;
    $_.barchar = $get($_.upcacode, $_.i) - 48;
    if ($_.i % 2 != 0) {
      $_.checksum = $_.checksum + $_.barchar;
    } else {
      $_.checksum = $_.checksum + $_.barchar * 3;
    }
  }
  $_.checksum = (10 - $_.checksum % 10) % 10;
  if ($_.barcode.length == 8) {
    if ($get($_.barcode, 7) != $_.checksum + 48) {
      $k[$j++] = "bwipp.upcEbadCheckDigit#6080";
      $k[$j++] = "Incorrect UPC check digit provided";
      bwipp_raiseerror();
    }
  }
  $_.pad = $s(8);
  $puti($_.pad, 0, $_.barcode);
  $put($_.pad, 7, $_.checksum + 48);
  $_.barcode = $_.pad;
  $_.txt = $a(8);
  $put($_.txt, 0, $a([$geti($_.barcode, 0, 1), $_.textxoffset, $_.textyoffset, $_.textfont, $_.textsize - 2]));
  $_.mirrormap = $get($_.mirrormaps, $_.checksum);
  if ($get($_.barcode, 0) == 48) {
    $_.invt = $s($_.mirrormap.length);
    for (var _2T = 0, _2S = $_.mirrormap.length - 1; _2T <= _2S; _2T += 1) {
      $_.i = _2T;
      if ($get($_.mirrormap, $_.i) == 48) {
        $put($_.invt, $_.i, 49);
      } else {
        $put($_.invt, $_.i, 48);
      }
    }
    $_.mirrormap = $_.invt;
  }
  $_.sbs = $s(33);
  $puti($_.sbs, 0, $get($_.encs, 10));
  for (var _2g = 1; _2g <= 6; _2g += 1) {
    $_.i = _2g;
    $search($_.barchars, $geti($_.barcode, $_.i, 1));
    $j--;
    $_.indx = $k[--$j].length;
    $j -= 2;
    $_.enc = $get($_.encs, $_.indx);
    if ($get($_.mirrormap, $_.i - 1) == 49) {
      $_.enclen = $_.enc.length;
      $_.revenc = $s($_.enclen);
      for (var _2x = 0, _2w = $_.enclen - 1; _2x <= _2w; _2x += 1) {
        $_.j = _2x;
        $_.char = $get($_.enc, $_.j);
        $put($_.revenc, $_.enclen - $_.j - 1, $_.char);
      }
      $_.enc = $_.revenc;
    }
    $puti($_.sbs, ($_.i - 1) * 4 + 3, $_.enc);
    $put($_.txt, $_.i, $a([$geti($_.barcode, $_.i, 1), ($_.i - 1) * 7 + 13 + $_.textxoffset, $_.textyoffset, $_.textfont, $_.textsize]));
  }
  $put($_.txt, 7, $a([$geti($_.barcode, 7, 1), 6 * 7 + 21 + $_.textxoffset, $_.textyoffset, $_.textfont, $_.textsize - 2]));
  $puti($_.sbs, 27, $get($_.encs, 11));
  $k[$j++] = Infinity;
  var _3V = $_.sbs;
  for (var _3W = 0, _3X = _3V.length; _3W < _3X; _3W++) {
    $k[$j++] = $get(_3V, _3W) - 48;
  }
  $_.sbs = $a();
  if ($_.includetext) {
    $k[$j++] = Infinity;
    $k[$j++] = $_.height;
    $k[$j++] = $_.height;
    for (var _3d = 0; _3d < 12; _3d++) {
      $k[$j++] = $f($_.height - 0.075);
    }
    $k[$j++] = $_.height;
    $k[$j++] = $_.height;
    $k[$j++] = $_.height;
    $_.bhs = $a();
    $k[$j++] = Infinity;
    $k[$j++] = 0;
    $k[$j++] = 0;
    for (var _3j = 0; _3j < 12; _3j++) {
      $k[$j++] = 0.075;
    }
    $k[$j++] = 0;
    $k[$j++] = 0;
    $k[$j++] = 0;
    $_.bbs = $a();
  } else {
    $k[$j++] = Infinity;
    for (var _3l = 0; _3l < 17; _3l++) {
      $k[$j++] = $_.height;
    }
    $_.bhs = $a();
    $k[$j++] = Infinity;
    for (var _3o = 0; _3o < 17; _3o++) {
      $k[$j++] = 0;
    }
    $_.bbs = $a();
    $_.txt = $a([]);
  }
  $_.guardrightypos = 0;
  if ($_.addon.length != 0) {
    $k[$j++] = Infinity;
    $k[$j++] = "dontdraw";
    $k[$j++] = true;
    $k[$j++] = "includetext";
    $k[$j++] = true;
    $k[$j++] = "height";
    $k[$j++] = $_.height;
    if ($_.includetext) {
      var _3u = $k[--$j];
      $k[$j++] = $f(_3u - 0.15);
    }
    $k[$j++] = "textxoffset";
    if ($_.addontextxoffset != null) {
      $k[$j++] = $_.addontextxoffset;
    } else {
      $k[$j++] = 51 + $_.addongap;
    }
    if ($_.addontextyoffset != null) {
      $k[$j++] = "textyoffset";
      $k[$j++] = $_.addontextyoffset;
    }
    $k[$j++] = "textsize";
    if ($_.addontextsize != null) {
      $k[$j++] = $_.addontextsize;
    } else {
      $k[$j++] = $_.textsize;
    }
    var _44 = $ne($_.addontextfont, "unset") ? $_.addontextfont : $_.textfont;
    $k[$j++] = "textfont";
    $k[$j++] = _44;
    $_.addopts = $d();
    if ($_.addon.length == 2) {
      $k[$j++] = $_.addon;
      $k[$j++] = $_.addopts;
      bwipp_ean2();
    }
    if ($_.addon.length == 5) {
      $k[$j++] = $_.addon;
      $k[$j++] = $_.addopts;
      bwipp_ean5();
    }
    $_.addcode = $k[--$j];
    $k[$j++] = Infinity;
    $aload($_.sbs);
    $k[$j++] = $_.addongap;
    $aload($get($_.addcode, "sbs"));
    $_.sbs = $a();
    $k[$j++] = Infinity;
    $aload($_.bhs);
    $aload($get($_.addcode, "bhs"));
    $_.bhs = $a();
    $k[$j++] = Infinity;
    $aload($_.bbs);
    $aload($get($_.addcode, "bbs"));
    $_.bbs = $a();
    $k[$j++] = Infinity;
    $aload($_.txt);
    $aload($get($_.addcode, "txt"));
    $_.txt = $a();
    $_.guardrightypos = $_.height * 72 - 6;
  }
  $k[$j++] = Infinity;
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "sbs";
  $k[$j++] = $_.sbs;
  $k[$j++] = "bhs";
  $k[$j++] = $_.bhs;
  $k[$j++] = "bbs";
  $k[$j++] = $_.bbs;
  $k[$j++] = "txt";
  $k[$j++] = $_.txt;
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  $k[$j++] = "guardrightpos";
  if ($_.addon.length == 0) {
    $k[$j++] = 9;
  } else {
    $k[$j++] = 5;
  }
  $k[$j++] = "guardrightypos";
  $k[$j++] = $_.guardrightypos;
  $k[$j++] = "borderleft";
  $k[$j++] = 9;
  $k[$j++] = "borderright";
  if ($_.addon.length == 0) {
    $k[$j++] = 9;
  } else {
    $k[$j++] = 5;
  }
  $k[$j++] = "bordertop";
  $k[$j++] = 0;
  $k[$j++] = "borderbottom";
  $k[$j++] = 5;
  var _4d = $d();
  $k[$j++] = _4d;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_isbn() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.isbntextfont = "OCR-A";
  $_.isbntextsize = 8;
  $_.isbntextxoffset = null;
  $_.isbntextyoffset = null;
  $_.height = 1;
  $_.addongap = 12;
  $_.legacy = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $search($_.barcode, " ");
  if ($k[--$j]) {
    $_.barcode = $k[--$j];
    $j--;
    $_.addon = $k[--$j];
  } else {
    $j--;
    $_.addon = "";
  }
  if ($_.barcode.length != 15 && $_.barcode.length != 17 && ($_.barcode.length != 11 && $_.barcode.length != 13)) {
    $k[$j++] = "bwipp.isbnBadLength#6249";
    $k[$j++] = "ISBN-13 must be 15 or 17 characters including dashes. ISBN-10 must be 11 or 13 characters including dashes";
    bwipp_raiseerror();
  }
  if ($_.addon.length != 0 && $_.addon.length != 2 && $_.addon.length != 5) {
    $k[$j++] = "bwipp.isbnBadAddOnLength#6252";
    $k[$j++] = "Add-on for ISBN must be 2 or 5 digits";
    bwipp_raiseerror();
  }
  if ($_.barcode.length >= 15) {
    var _F = $geti($_.barcode, 0, 4);
    if ($ne(_F, "978-") && $ne(_F, "979-")) {
      $k[$j++] = "bwipp.isbn13badPrefix#6256";
      $k[$j++] = "ISBN-13 prefix must be 978- or 979-";
      bwipp_raiseerror();
    }
    $_.wasdash = false;
    $_.numdash = 0;
    $_.numdigit = 0;
    var _H = $geti($_.barcode, 5, 9);
    for (var _I = 0, _J = _H.length; _I < _J; _I++) {
      var _K = $get(_H, _I);
      $k[$j++] = _K;
      if (_K == 45) {
        if ($_.wasdash) {
          $k[$j++] = "bwipp.isbn13adjacentDashes#6263";
          $k[$j++] = "ISBN-13 does not permit adjacent dashes";
          bwipp_raiseerror();
        }
        $_.wasdash = true;
        $_.numdash = $_.numdash + 1;
      }
      var _N = $k[--$j];
      if (_N >= 48 && _N <= 57) {
        $_.wasdash = false;
        $_.numdigit = $_.numdigit + 1;
      }
    }
    if ($_.numdash != 2 || $_.numdigit != 7) {
      $k[$j++] = "bwipp.isbn13numDashesDigits#6274";
      $k[$j++] = "Incorrect number of dashes and digits for ISBN-13";
      bwipp_raiseerror();
    }
    var _S = $get($_.barcode, 14);
    if (_S < 48 || _S > 57) {
      $k[$j++] = "bwipp.isbn13character15#6277";
      $k[$j++] = "ISBN-13 character 15 must be a digit";
      bwipp_raiseerror();
    }
    if ($_.barcode.length == 17) {
      if ($ne($geti($_.barcode, 15, 1), "-")) {
        $k[$j++] = "bwipp.isbn13character16#6281";
        $k[$j++] = "ISBN-13 penultimate character must be a dash";
        bwipp_raiseerror();
      }
      var _X = $get($_.barcode, 16);
      if (_X < 48 || _X > 57) {
        $k[$j++] = "bwipp.isbn13character17#6284";
        $k[$j++] = "ISBN-13 final character must be a digit";
        bwipp_raiseerror();
      }
    }
  } else {
    var _Z = $get($_.barcode, 0);
    if (_Z < 48 || _Z > 57) {
      $k[$j++] = "bwipp.isbn10FirstDigit#6289";
      $k[$j++] = "ISBN-10 first character must be a digit";
      bwipp_raiseerror();
    }
    $_.wasdash = false;
    $_.numdash = 0;
    $_.numdigit = 0;
    var _b = $geti($_.barcode, 1, 9);
    for (var _c = 0, _d = _b.length; _c < _d; _c++) {
      var _e = $get(_b, _c);
      $k[$j++] = _e;
      if (_e == 45) {
        if ($_.wasdash) {
          $k[$j++] = "bwipp.isbn10adjacentDashes#6296";
          $k[$j++] = "ISBN-10 does not permit adjacent dashes";
          bwipp_raiseerror();
        }
        $_.wasdash = true;
        $_.numdash = $_.numdash + 1;
      }
      var _h = $k[--$j];
      if (_h >= 48 && _h <= 57) {
        $_.wasdash = false;
        $_.numdigit = $_.numdigit + 1;
      }
    }
    if ($_.numdash != 2 || $_.numdigit != 7) {
      $k[$j++] = "bwipp.isbn10numDashesDigits#6307";
      $k[$j++] = "Incorrect number of dashes and digits for ISBN-10";
      bwipp_raiseerror();
    }
    var _m = $get($_.barcode, 10);
    if (_m < 48 || _m > 57) {
      $k[$j++] = "bwipp.isbn10character11#6310";
      $k[$j++] = "ISBN-10 character 11 must be a digit";
      bwipp_raiseerror();
    }
    if ($_.barcode.length == 13) {
      if ($ne($geti($_.barcode, 11, 1), "-")) {
        $k[$j++] = "bwipp.isbn10character12#6314";
        $k[$j++] = "ISBN-10 penultimate character must be a dash";
        bwipp_raiseerror();
      }
      var _r = $get($_.barcode, 12);
      if ((_r < 48 || _r > 57) && _r != 88) {
        $k[$j++] = "bwipp.isbn10character13#6317";
        $k[$j++] = "ISBN-10 final character must be a digit or X";
        bwipp_raiseerror();
      }
    }
  }
  $_.isbntxt = $_.barcode;
  if ($_.isbntxt.length <= 13) {
    $_.isbn = $s(10);
    $_.checksum = 0;
    $_.i = 0;
    $_.n = 0;
    for (; ; ) {
      $_.isbnchar = $get($_.isbntxt, $_.i) - 48;
      if ($_.isbnchar != -3) {
        $put($_.isbn, $_.n, $_.isbnchar + 48);
        if ($_.n < 9) {
          $_.checksum = $f($_.checksum + (10 - $_.n) * $_.isbnchar);
        }
        $_.n = $_.n + 1;
      }
      $_.i = $_.i + 1;
      if ($_.i == $_.isbntxt.length) {
        break;
      }
    }
    var _1B = (11 - $_.checksum % 11) % 11;
    $k[$j++] = "checksum";
    $k[$j++] = _1B;
    if (_1B == 10) {
      $k[$j - 1] = 40;
    }
    var _1C = $k[--$j];
    $_[$k[--$j]] = _1C + 48;
    $_.isbn = $geti($_.isbn, 0, 9);
    if ($_.isbntxt.length == 13) {
      if ($get($_.isbntxt, 12) != $_.checksum) {
        $k[$j++] = "bwipp.isbn10badCheckDigit#6345";
        $k[$j++] = "Incorrect ISBN-10 check digit provided";
        bwipp_raiseerror();
      }
    }
  }
  if (!$_.legacy || $_.isbntxt.length >= 15) {
    if ($_.isbntxt.length <= 13) {
      $_.pad = $s(15);
      $puti($_.pad, 0, "978-");
      $puti($_.pad, 4, $geti($_.isbntxt, 0, 11));
      $_.isbntxt = $_.pad;
    }
    $_.isbn = $s(13);
    $_.checksum = 0;
    $_.i = 0;
    $_.n = 0;
    for (; ; ) {
      $_.isbnchar = $get($_.isbntxt, $_.i) - 48;
      if ($_.isbnchar != -3) {
        $put($_.isbn, $_.n, $_.isbnchar + 48);
        if ($_.n < 12) {
          $k[$j++] = "checksum";
          $k[$j++] = $_.isbnchar;
          if ($_.n % 2 != 0) {
            var _1e = $k[--$j];
            $k[$j++] = _1e * 3;
          }
          var _1g = $k[--$j];
          $_[$k[--$j]] = $f(_1g + $_.checksum);
        }
        $_.n = $_.n + 1;
      }
      $_.i = $_.i + 1;
      if ($_.i == $_.isbntxt.length) {
        break;
      }
    }
    $_.checksum = (10 - $_.checksum % 10) % 10 + 48;
    $_.isbn = $geti($_.isbn, 0, 12);
    if ($_.isbntxt.length == 17) {
      if ($get($_.isbntxt, 16) != $_.checksum) {
        $k[$j++] = "bwipp.isbn13badCheckDigit#6380";
        $k[$j++] = "Incorrect ISBN-13 check digit provided";
        bwipp_raiseerror();
      }
    }
  }
  var _1u = $_.isbn.length == 12 ? 22 : 18;
  $_.pad = $s(_1u);
  $puti($_.pad, 0, "ISBN ");
  $puti($_.pad, 5, $_.isbntxt);
  $put($_.pad, $_.pad.length - 2, 45);
  $put($_.pad, $_.pad.length - 1, $_.checksum);
  $_.isbntxt = $_.pad;
  $_.barcode = $s(12);
  if ($_.isbn.length == 9) {
    $puti($_.barcode, 0, "978");
    $puti($_.barcode, 3, $_.isbn);
  } else {
    $puti($_.barcode, 0, $_.isbn);
  }
  if ($_.addon.length != 0) {
    var _2E = $s(12 + $_.addon.length + 1);
    $puti(_2E, 0, $_.barcode);
    $puti(_2E, 12, " ");
    $puti(_2E, 13, $_.addon);
    $_.barcode = _2E;
  }
  $put($_.options, "dontdraw", true);
  $put($_.options, "addongap", $_.addongap);
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_ean13();
  var _2M = $k[--$j];
  $_[$k[--$j]] = _2M;
  if ($_.includetext) {
    if ($_.isbntextxoffset == null) {
      $k[$j++] = "isbntextxoffset";
      if ($_.isbn.length == 9) {
        $k[$j++] = -1;
      } else {
        $k[$j++] = -12;
      }
      var _2R = $k[--$j];
      $_[$k[--$j]] = _2R;
    }
    if ($_.isbntextyoffset == null) {
      $_.isbntextyoffset = $_.height * 72 + 3;
    }
    var _2W = $get($_.args, "txt") !== void 0;
    if (_2W) {
      $_.txt = $get($_.args, "txt");
      $_.newtxt = $a($_.txt.length + 1);
      $puti($_.newtxt, 0, $_.txt);
      $put($_.newtxt, $_.newtxt.length - 1, $a([$_.isbntxt, $_.isbntextxoffset, $_.isbntextyoffset, $_.isbntextfont, $_.isbntextsize]));
      $put($_.args, "txt", $_.newtxt);
    } else {
      $put($_.args, "txt", $a([$a([$_.isbntxt, $_.isbntextxoffset, $_.isbntextyoffset, $_.isbntextfont, $_.isbntextsize])]));
    }
  }
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_ismn() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.ismntextfont = "OCR-A";
  $_.ismntextsize = 8;
  $_.ismntextxoffset = null;
  $_.ismntextyoffset = null;
  $_.height = 1;
  $_.addongap = 12;
  $_.legacy = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $search($_.barcode, " ");
  if ($k[--$j]) {
    $_.barcode = $k[--$j];
    $j--;
    $_.addon = $k[--$j];
  } else {
    $j--;
    $_.addon = "";
  }
  if ($_.barcode.length != 15 && $_.barcode.length != 17 && ($_.barcode.length != 11 && $_.barcode.length != 13)) {
    $k[$j++] = "bwipp.ismnBadLength#6499";
    $k[$j++] = "ISMN-13 must be 15 or 17 characters including dashes. ISMN-10 must be 11 or 13 characters including dashes";
    bwipp_raiseerror();
  }
  if ($_.addon.length != 0 && $_.addon.length != 2 && $_.addon.length != 5) {
    $k[$j++] = "bwipp.ismnBadAddOnLength#6502";
    $k[$j++] = "Add-on for ISMN must be 2 or 5 digits";
    bwipp_raiseerror();
  }
  if ($_.barcode.length >= 15) {
    if ($ne($geti($_.barcode, 0, 4), "979-")) {
      $k[$j++] = "bwipp.ismn13badPrefix#6506";
      $k[$j++] = "ISMN-13 prefix must be 979-";
      bwipp_raiseerror();
    }
    $_.wasdash = false;
    $_.numdash = 0;
    $_.numdigit = 0;
    var _H = $geti($_.barcode, 5, 9);
    for (var _I = 0, _J = _H.length; _I < _J; _I++) {
      var _K = $get(_H, _I);
      $k[$j++] = _K;
      if (_K == 45) {
        if ($_.wasdash) {
          $k[$j++] = "bwipp.ismn13adjacentDashes#6513";
          $k[$j++] = "ISMN-13 does not permit adjacent dashes";
          bwipp_raiseerror();
        }
        $_.wasdash = true;
        $_.numdash = $_.numdash + 1;
      }
      var _N = $k[--$j];
      if (_N >= 48 && _N <= 57) {
        $_.wasdash = false;
        $_.numdigit = $_.numdigit + 1;
      }
    }
    if ($_.numdash != 2 || $_.numdigit != 7) {
      $k[$j++] = "bwipp.ismn13numDashesDigits#6524";
      $k[$j++] = "Incorrect number of dashes and digits for ISMN-13";
      bwipp_raiseerror();
    }
    var _S = $get($_.barcode, 14);
    if (_S < 48 || _S > 57) {
      $k[$j++] = "bwipp.ismn13character15#6527";
      $k[$j++] = "ISMN-13 character 15 must be a digit";
      bwipp_raiseerror();
    }
    if ($_.barcode.length == 17) {
      if ($ne($geti($_.barcode, 15, 1), "-")) {
        $k[$j++] = "bwipp.ismn13character16#6531";
        $k[$j++] = "ISMN-13 penultimate character must be a dash";
        bwipp_raiseerror();
      }
      var _X = $get($_.barcode, 16);
      if (_X < 48 || _X > 57) {
        $k[$j++] = "bwipp.ismn13character17#6534";
        $k[$j++] = "ISMN-13 final character must be a digit";
        bwipp_raiseerror();
      }
    }
  } else {
    if ($ne($geti($_.barcode, 0, 2), "M-")) {
      $k[$j++] = "bwipp.ismn10badPrefix#6539";
      $k[$j++] = "ISMN-10 prefix must be M-";
      bwipp_raiseerror();
    }
    var _b = $get($_.barcode, 2);
    if (_b < 48 || _b > 57) {
      $k[$j++] = "bwipp.ismn10character3#6542";
      $k[$j++] = "ISMN-10 character 3 must be a digit";
      bwipp_raiseerror();
    }
    $_.wasdash = false;
    $_.numdash = 0;
    $_.numdigit = 0;
    var _d = $geti($_.barcode, 3, 7);
    for (var _e = 0, _f = _d.length; _e < _f; _e++) {
      var _g = $get(_d, _e);
      $k[$j++] = _g;
      if (_g == 45) {
        if ($_.wasdash) {
          $k[$j++] = "bwipp.ismn10adjacentDashes#6549";
          $k[$j++] = "ISMN-10 does not permit adjacent dashes";
          bwipp_raiseerror();
        }
        $_.wasdash = true;
        $_.numdash = $_.numdash + 1;
      }
      var _j = $k[--$j];
      if (_j >= 48 && _j <= 57) {
        $_.wasdash = false;
        $_.numdigit = $_.numdigit + 1;
      }
    }
    if ($_.numdash != 1 || $_.numdigit != 6) {
      $k[$j++] = "bwipp.ismn10numDashesDigits#6560";
      $k[$j++] = "Incorrect number of dashes and digits for ISMN-10";
      bwipp_raiseerror();
    }
    var _o = $get($_.barcode, 10);
    if (_o < 48 || _o > 57) {
      $k[$j++] = "bwipp.ismn10character11#6563";
      $k[$j++] = "ISMN-10 character 11 must be a digit";
      bwipp_raiseerror();
    }
    if ($_.barcode.length == 13) {
      var _r = $geti($_.barcode, 11, 1);
      if ($ne(_r, "-")) {
        $k[$j++] = "bwipp.ismn10character12#6567";
        $k[$j++] = "ISMN-10 penultimate character must be a dash";
        bwipp_raiseerror();
      }
      var _t = $get($_.barcode, 12);
      if ((_t < 48 || _t > 57) && _t != 88) {
        $k[$j++] = "bwipp.ismn10character13#6570";
        $k[$j++] = "ISMN-10 final character must be a digit or X";
        bwipp_raiseerror();
      }
    }
  }
  $_.ismntxt = $_.barcode;
  $_.legacytxt = "";
  if ($_.ismntxt.length <= 13) {
    $_.legacytxt = $_.ismntxt;
    $_.pad = $s($_.ismntxt.length + 4);
    $puti($_.pad, 0, "979-0-");
    $puti($_.pad, 6, $geti($_.ismntxt, 2, $_.ismntxt.length - 2));
    $_.ismntxt = $_.pad;
  }
  $_.ismn = $s(13);
  $_.checksum = 0;
  $_.i = 0;
  $_.n = 0;
  for (; ; ) {
    $_.ismnchar = $get($_.ismntxt, $_.i) - 48;
    if ($_.ismnchar != -3) {
      $put($_.ismn, $_.n, $_.ismnchar + 48);
      if ($_.n < 12) {
        if ($_.n % 2 == 0) {
          $_.checksum = $_.ismnchar + $_.checksum;
        } else {
          $_.checksum = $_.ismnchar * 3 + $_.checksum;
        }
      }
      $_.n = $_.n + 1;
    }
    $_.i = $_.i + 1;
    if ($_.i == $_.ismntxt.length) {
      break;
    }
  }
  $_.checksum = (10 - $_.checksum % 10) % 10 + 48;
  if ($_.barcode.length == 13 || $_.barcode.length == 17) {
    var _1Q = $_.barcode;
    if ($get(_1Q, _1Q.length - 1) != $_.checksum) {
      $k[$j++] = "bwipp.ismnBadCheckDigit#6612";
      $k[$j++] = "Incorrect ISMN check digit provided";
      bwipp_raiseerror();
    }
  }
  if ($_.legacy && $_.legacytxt.length != 0) {
    $_.ismntxt = $_.legacytxt;
    $_.pad = $s(18);
  } else {
    $_.pad = $s(22);
  }
  $puti($_.pad, 0, "ISMN ");
  $puti($_.pad, 5, $_.ismntxt);
  $put($_.pad, $_.pad.length - 2, 45);
  $put($_.pad, $_.pad.length - 1, $_.checksum);
  $_.ismntxt = $_.pad;
  $_.barcode = $geti($_.ismn, 0, 12);
  if ($_.addon.length != 0) {
    var _1l = $s(12 + $_.addon.length + 1);
    $puti(_1l, 0, $_.barcode);
    $puti(_1l, 12, " ");
    $puti(_1l, 13, $_.addon);
    $_.barcode = _1l;
  }
  $put($_.options, "dontdraw", true);
  $put($_.options, "addongap", $_.addongap);
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_ean13();
  var _1t = $k[--$j];
  $_[$k[--$j]] = _1t;
  if ($_.includetext) {
    if ($_.ismntextxoffset == null) {
      $k[$j++] = "ismntextxoffset";
      if ($_.ismntxt.length == 18) {
        $k[$j++] = -1;
      } else {
        $k[$j++] = -12;
      }
      var _1y = $k[--$j];
      $_[$k[--$j]] = _1y;
    }
    if ($_.ismntextyoffset == null) {
      $_.ismntextyoffset = $_.height * 72 + 3;
    }
    var _23 = $get($_.args, "txt") !== void 0;
    if (_23) {
      $_.txt = $get($_.args, "txt");
      $_.newtxt = $a($_.txt.length + 1);
      $puti($_.newtxt, 0, $_.txt);
      $put($_.newtxt, $_.newtxt.length - 1, $a([$_.ismntxt, $_.ismntextxoffset, $_.ismntextyoffset, $_.ismntextfont, $_.ismntextsize]));
      $put($_.args, "txt", $_.newtxt);
    } else {
      $put($_.args, "txt", $a([$a([$_.ismntxt, $_.ismntextxoffset, $_.ismntextyoffset, $_.ismntextfont, $_.ismntextsize])]));
    }
  }
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_issn() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.issntextfont = "OCR-A";
  $_.issntextsize = 8;
  $_.issntextxoffset = null;
  $_.issntextyoffset = null;
  $_.height = 1;
  $_.addongap = 12;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.issntxt = $k[--$j];
  $search($_.issntxt, " ");
  if ($k[--$j]) {
    $_.issntxt = $k[--$j];
    $j--;
    $_.seqvar = $k[--$j];
  } else {
    $j--;
    $_.seqvar = "00";
  }
  $search($_.seqvar, " ");
  if ($k[--$j]) {
    $_.seqvar = $k[--$j];
    $j--;
    $_.addon = $k[--$j];
  } else {
    $j--;
    $_.addon = "";
  }
  if ($_.issntxt.length != 8 && $_.issntxt.length != 9) {
    $k[$j++] = "bwipp.issnBadLength#6736";
    $k[$j++] = "ISSN must be 8 or 9 characters including dash, in the format XXXX-XXXX";
    bwipp_raiseerror();
  }
  var _D = $geti($_.issntxt, 0, 4);
  for (var _E = 0, _F = _D.length; _E < _F; _E++) {
    var _G = $get(_D, _E);
    if (_G < 48 || _G > 57) {
      $k[$j++] = "bwipp.issnFirstThroughFourthNotNumeric#6740";
      $k[$j++] = "ISSN first four characters must be numeral characters";
      bwipp_raiseerror();
    }
  }
  if ($ne($geti($_.issntxt, 4, 1), "-")) {
    $k[$j++] = "bwipp.issnNeedsDash#6744";
    $k[$j++] = "ISSN fifth character must be a dash";
    bwipp_raiseerror();
  }
  var _K = $geti($_.issntxt, 5, 3);
  for (var _L = 0, _M = _K.length; _L < _M; _L++) {
    var _N = $get(_K, _L);
    if (_N < 48 || _N > 57) {
      $k[$j++] = "bwipp.issnSixthThroughEighthNotNumeric#6748";
      $k[$j++] = "ISSN sixth through eighth characters must be numerals";
      bwipp_raiseerror();
    }
  }
  if ($_.issntxt.length == 9) {
    var _Q = $get($_.issntxt, 8);
    if ((_Q < 48 || _Q > 57) && _Q != 88) {
      $k[$j++] = "bwipp.issnNinthCharacterBadFormat#6753";
      $k[$j++] = "ISSN ninth character must be a number or the character X";
      bwipp_raiseerror();
    }
  }
  if ($_.seqvar.length != 2) {
    $k[$j++] = "bwipp.issnBadSequenceVariantLength#6757";
    $k[$j++] = "Sequence variant for ISSN must be 2 digits";
    bwipp_raiseerror();
  }
  $forall($_.seqvar, function() {
    var _T = $k[--$j];
    if (_T < 48 || _T > 57) {
      $k[$j++] = "bwipp.issnSequenceVariantBadCharacter#6761";
      $k[$j++] = "Sequence variant for ISSN must contain only digits";
      bwipp_raiseerror();
    }
  });
  if ($_.addon.length != 0 && $_.addon.length != 2 && $_.addon.length != 5) {
    $k[$j++] = "bwipp.issnBadAddOnLength#6765";
    $k[$j++] = "Add-on for ISSN must be 2 or 5 digits";
    bwipp_raiseerror();
  }
  $_.issn = $s(8);
  $_.checksum = 0;
  $_.i = 0;
  $_.n = 0;
  for (; ; ) {
    $_.issnchar = $get($_.issntxt, $_.i) - 48;
    if ($_.issnchar != -3) {
      $put($_.issn, $_.n, $_.issnchar + 48);
      if ($_.n < 7) {
        $_.checksum = $f($_.checksum + $_.issnchar * (8 - $_.n));
      }
      $_.n = $_.n + 1;
    }
    $_.i = $_.i + 1;
    if ($_.i == $_.issntxt.length) {
      break;
    }
  }
  $_.checksum = (11 - $_.checksum % 11) % 11;
  var _p = $_.checksum + 48;
  $k[$j++] = "checksum";
  $k[$j++] = _p;
  if (_p == 58) {
    $k[$j - 1] = 88;
  }
  var _q = $k[--$j];
  var _r = $k[--$j];
  $_[_r] = _q;
  if ($_.issntxt.length == 9) {
    if ($get($_.issntxt, 8) != $_.checksum) {
      $k[$j++] = "bwipp.issnBadCheckDigit#6788";
      $k[$j++] = "Incorrect ISSN check digit provided";
      bwipp_raiseerror();
    }
  }
  $_.pad = $s(14);
  $puti($_.pad, 0, "ISSN ");
  $puti($_.pad, 5, $_.issntxt);
  $put($_.pad, 13, $_.checksum);
  $_.issntxt = $_.pad;
  $_.barcode = $geti($_.issn, 0, 7);
  $_.barcode = $s(12);
  $puti($_.barcode, 0, "977");
  $puti($_.barcode, 3, $_.issn);
  $puti($_.barcode, 10, $_.seqvar);
  if ($_.addon.length != 0) {
    var _1D = $s(12 + $_.addon.length + 1);
    $puti(_1D, 0, $_.barcode);
    $puti(_1D, 12, " ");
    $puti(_1D, 13, $_.addon);
    $_.barcode = _1D;
  }
  $put($_.options, "dontdraw", true);
  $put($_.options, "addongap", $_.addongap);
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_ean13();
  var _1L = $k[--$j];
  $_[$k[--$j]] = _1L;
  if ($_.includetext) {
    if ($_.issntextxoffset == null) {
      $_.issntextxoffset = 10;
    }
    if ($_.issntextyoffset == null) {
      $_.issntextyoffset = $_.height * 72 + 3;
    }
    var _1S = $get($_.args, "txt") !== void 0;
    if (_1S) {
      $_.txt = $get($_.args, "txt");
      $_.newtxt = $a($_.txt.length + 1);
      $puti($_.newtxt, 0, $_.txt);
      $put($_.newtxt, $_.newtxt.length - 1, $a([$_.issntxt, $_.issntextxoffset, $_.issntextyoffset, $_.issntextfont, $_.issntextsize]));
      $put($_.args, "txt", $_.newtxt);
    } else {
      $put($_.args, "txt", $a([$a([$_.issntxt, $_.issntextxoffset, $_.issntextyoffset, $_.issntextfont, $_.issntextsize])]));
    }
  }
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_mands() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $_.barlen = $_.barcode.length;
  if ($_.barlen != 7 && $_.barlen != 8) {
    $k[$j++] = "bwipp.MandSbadLength#6884";
    $k[$j++] = "M&S barcode must be 7 or 8 characters";
    bwipp_raiseerror();
  }
  if ($_.barlen == 7) {
    var _7 = $strcpy($s(8), "00000000");
    $puti(_7, 1, $_.barcode);
    $_.barcode = _7;
  }
  $put($_.options, "dontdraw", true);
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_ean8();
  var _C = $k[--$j];
  $_[$k[--$j]] = _C;
  var _F = $get($_.args, "bbs");
  $put(_F, 10, $get(_F, 2));
  $put(_F, 11, $get(_F, 2));
  var _J = $get($_.args, "bhs");
  $put(_J, 10, $get(_J, 2));
  $put(_J, 11, $get(_J, 2));
  $_.txt = $get($_.args, "txt");
  if ($_.barlen == 7) {
    for (var _P = 0; _P <= 6; _P += 1) {
      var _Q = $_.txt;
      $puti($get($get(_Q, _P), 0), 0, $get($get(_Q, _P + 1), 0));
    }
    $puti($get($get($_.txt, 7), 0), 0, " ");
  }
  var _Y = $a(10);
  $puti(_Y, 0, $_.txt);
  $_.txt = _Y;
  var _b = $get($_.txt, 0);
  $put($_.txt, 8, $arrcpy($a(_b.length), _b));
  var _g = $get($_.txt, 0);
  $put($_.txt, 9, $arrcpy($a(_g.length), _g));
  $put($get($_.txt, 8), 0, "M");
  $put($get($_.txt, 8), 1, -12);
  $put($get($_.txt, 9), 0, "S");
  var _r = $get($_.txt, 9);
  $put(_r, 1, 69);
  $put($_.args, "txt", $_.txt);
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_code128() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.textfont = "OCR-B";
  $_.textsize = 10;
  $_.textxoffset = 0;
  $_.textyoffset = -8;
  $_.height = 1;
  $_.raw = false;
  $_.newencoder = false;
  $_.parse = false;
  $_.parsefnc = false;
  $_.suppressc = false;
  $_.unlatchextbeforec = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $_.sta = -1;
  $_.stb = -2;
  $_.stc = -3;
  $_.swa = -4;
  $_.swb = -5;
  $_.swc = -6;
  $_.fn1 = -7;
  $_.fn2 = -8;
  $_.fn3 = -9;
  $_.fn4 = -10;
  $_.sft = -11;
  $_.stp = -12;
  $_.lka = -13;
  $_.lkc = -14;
  var _A = /* @__PURE__ */ new Map([
    ["parse", $_.parse],
    ["parsefnc", $_.parsefnc],
    ["FNC1", $_.fn1],
    ["FNC2", $_.fn2],
    ["FNC3", $_.fn3],
    ["LNKA", $_.lka],
    ["LNKC", $_.lkc]
  ]);
  $_.fncvals = _A;
  $k[$j++] = "msg";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.fncvals;
  bwipp_parseinput();
  var _D = $k[--$j];
  $_[$k[--$j]] = _D;
  $_.msglen = $_.msg.length;
  $_.encoding = "legacy";
  if ($_.newencoder) {
    $_.encoding = "new";
  }
  if ($_.raw) {
    $_.encoding = "raw";
  }
  if ($eq($_.encoding, "raw")) {
    $_.cws = $a($_.barcode.length);
    $_.i = 0;
    $_.j = 0;
    for (; ; ) {
      if ($_.i == $_.barcode.length) {
        break;
      }
      $_.cw = $cvi($geti($_.barcode, $_.i + 1, 3));
      $put($_.cws, $_.j, $_.cw);
      $_.i = $_.i + 4;
      $_.j = $_.j + 1;
    }
    $_.cws = $geti($_.cws, 0, $_.j);
    $_.text = "";
  } else {
    $_.text = $s($_.msglen);
    for (var _c = 0, _b = $_.msglen - 1; _c <= _b; _c += 1) {
      $_.i = _c;
      var _h = $get($_.msg, $_.i);
      $k[$j++] = $_.text;
      $k[$j++] = $_.i;
      $k[$j++] = _h;
      if (_h < 0) {
        $k[$j - 1] = 32;
      }
      var _i = $k[--$j];
      var _j = $k[--$j];
      $put($k[--$j], _j, _i);
    }
  }
  $_.charmaps = $a([$a([32, 32, "00"]), $a(["!", "!", "01"]), $a(['"', '"', "02"]), $a(["#", "#", "03"]), $a(["$", "$", "04"]), $a(["%", "%", "05"]), $a(["&", "&", "06"]), $a(["'", "'", "07"]), $a([40, 40, "08"]), $a([41, 41, "09"]), $a(["*", "*", "10"]), $a(["+", "+", "11"]), $a([",", ",", "12"]), $a(["-", "-", "13"]), $a([".", ".", "14"]), $a(["/", "/", "15"]), $a(["0", "0", "16"]), $a(["1", "1", "17"]), $a(["2", "2", "18"]), $a(["3", "3", "19"]), $a(["4", "4", "20"]), $a(["5", "5", "21"]), $a(["6", "6", "22"]), $a(["7", "7", "23"]), $a(["8", "8", "24"]), $a(["9", "9", "25"]), $a([":", ":", "26"]), $a([";", ";", "27"]), $a(["<", "<", "28"]), $a(["=", "=", "29"]), $a([">", ">", "30"]), $a(["?", "?", "31"]), $a(["@", "@", "32"]), $a(["A", "A", "33"]), $a(["B", "B", "34"]), $a(["C", "C", "35"]), $a(["D", "D", "36"]), $a(["E", "E", "37"]), $a(["F", "F", "38"]), $a(["G", "G", "39"]), $a(["H", "H", "40"]), $a(["I", "I", "41"]), $a(["J", "J", "42"]), $a(["K", "K", "43"]), $a(["L", "L", "44"]), $a(["M", "M", "45"]), $a(["N", "N", "46"]), $a(["O", "O", "47"]), $a(["P", "P", "48"]), $a(["Q", "Q", "49"]), $a(["R", "R", "50"]), $a(["S", "S", "51"]), $a(["T", "T", "52"]), $a(["U", "U", "53"]), $a(["V", "V", "54"]), $a(["W", "W", "55"]), $a(["X", "X", "56"]), $a(["Y", "Y", "57"]), $a(["Z", "Z", "58"]), $a(["[", "[", "59"]), $a([92, 92, "60"]), $a(["]", "]", "61"]), $a(["^", "^", "62"]), $a(["_", "_", "63"]), $a([0, "`", "64"]), $a([1, "a", "65"]), $a([2, "b", "66"]), $a([3, "c", "67"]), $a([4, "d", "68"]), $a([5, "e", "69"]), $a([6, "f", "70"]), $a([7, "g", "71"]), $a([8, "h", "72"]), $a([9, "i", "73"]), $a([10, "j", "74"]), $a([11, "k", "75"]), $a([12, "l", "76"]), $a([13, "m", "77"]), $a([14, "n", "78"]), $a([15, "o", "79"]), $a([16, "p", "80"]), $a([17, "q", "81"]), $a([18, "r", "82"]), $a([19, "s", "83"]), $a([20, "t", "84"]), $a([21, "u", "85"]), $a([22, "v", "86"]), $a([23, "w", "87"]), $a([24, "x", "88"]), $a([25, "y", "89"]), $a([26, "z", "90"]), $a([27, "{", "91"]), $a([28, "|", "92"]), $a([29, "}", "93"]), $a([30, "~", "94"]), $a([31, 127, "95"]), $a([$_.fn3, $_.fn3, "96"]), $a([$_.fn2, $_.fn2, "97"]), $a([$_.sft, $_.sft, "98"]), $a([$_.swc, $_.swc, "99"]), $a([$_.swb, $_.fn4, $_.swb]), $a([$_.fn4, $_.swa, $_.swa]), $a([$_.fn1, $_.fn1, $_.fn1]), $a([$_.sta, $_.sta, $_.sta]), $a([$_.stb, $_.stb, $_.stb]), $a([$_.stc, $_.stc, $_.stc]), $a([$_.stp, $_.stp, $_.stp])]);
  $_.charvals = $a([/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map()]);
  for (var _31 = 0, _30 = $_.charmaps.length - 1; _31 <= _30; _31 += 1) {
    $_.i = _31;
    $_.encs = $get($_.charmaps, $_.i);
    for (var _35 = 0; _35 <= 2; _35 += 1) {
      $_.j = _35;
      var _38 = $get($_.encs, $_.j);
      $k[$j++] = _38;
      if ($eq($type(_38), "stringtype")) {
        var _3B = $get($k[--$j], 0);
        $k[$j++] = _3B;
      }
      $put($get($_.charvals, $_.j), $k[--$j], $_.i);
    }
  }
  if ($eq($_.encoding, "legacy")) {
    $_.seta = $get($_.charvals, 0);
    $put($_.seta, $_.lka, $get($_.seta, $_.swb));
    $put($_.seta, $_.lkc, $get($_.seta, $_.swc));
    $_.setb = $get($_.charvals, 1);
    $put($_.setb, $_.lka, $get($_.setb, $_.swc));
    $put($_.setb, $_.lkc, $get($_.setb, $_.swa));
    $_.setc = $get($_.charvals, 2);
    $put($_.setc, $_.lka, $get($_.setc, $_.swa));
    $put($_.setc, $_.lkc, $get($_.setc, $_.swb));
    $k[$j++] = Infinity;
    for (var _3u = 0, _3v = $_.msglen; _3u < _3v; _3u++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $_.numSA = $a();
    $k[$j++] = Infinity;
    for (var _3y = 0, _3z = $_.msglen; _3y < _3z; _3y++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $_.numEA = $a();
    for (var _42 = $_.msglen - 1; _42 >= 0; _42 -= 1) {
      $_.i = _42;
      if ($get($_.msg, $_.i) >= 0) {
        if ($get($_.msg, $_.i) >= 128) {
          $put($_.numEA, $_.i, $get($_.numEA, $_.i + 1) + 1);
        } else {
          $put($_.numSA, $_.i, $get($_.numSA, $_.i + 1) + 1);
        }
      }
    }
    $_.ea = false;
    $_.msgtmp = $a([]);
    for (var _4M = 0, _4L = $_.msglen - 1; _4M <= _4L; _4M += 1) {
      $_.i = _4M;
      $_.c = $get($_.msg, $_.i);
      if (!($_.ea != $_.c < 128) && $_.c >= 0) {
        if ($_.ea) {
          $k[$j++] = $_.numSA;
        } else {
          $k[$j++] = $_.numEA;
        }
        var _4Y = $get($k[--$j], $_.i);
        var _4b = $f(_4Y + $_.i) == $_.msglen ? 3 : 5;
        if (_4Y < _4b) {
          $k[$j++] = Infinity;
          $aload($_.msgtmp);
          $k[$j++] = $_.fn4;
          $_.msgtmp = $a();
        } else {
          $k[$j++] = Infinity;
          $aload($_.msgtmp);
          $k[$j++] = $_.fn4;
          $k[$j++] = $_.fn4;
          $_.msgtmp = $a();
          $_.ea = !$_.ea;
        }
      }
      $k[$j++] = Infinity;
      $aload($_.msgtmp);
      if ($_.c >= 0) {
        $k[$j++] = $_.c & 127;
      } else {
        $k[$j++] = $_.c;
      }
      $_.msgtmp = $a();
    }
    $_.msg = $_.msgtmp;
    $_.msglen = $_.msg.length;
    $_.numsscr = function() {
      $_.s = 0;
      $_.p = $k[--$j];
      for (; ; ) {
        if ($_.p >= $_.msglen) {
          break;
        }
        var _4w = $get($_.msg, $_.p);
        var _4y = $get($_.setc, _4w) !== void 0;
        $k[$j++] = _4w;
        if (!_4y) {
          $j--;
          break;
        }
        var _4z = $k[$j - 1];
        if (_4z <= -1) {
          var _51 = $k[--$j];
          if (_51 == $_.fn1 && $_.s % 2 == 0) {
            $_.s = $_.s + 1;
          } else {
            break;
          }
        } else {
          $j--;
        }
        $_.s = $_.s + 1;
        $_.p = $_.p + 1;
      }
      $k[$j++] = $_.s;
    };
    $_.enca = function() {
      $put($_.cws, $_.j, $get($_.seta, $k[--$j]));
      $_.j = $_.j + 1;
    };
    $_.encb = function() {
      $put($_.cws, $_.j, $get($_.setb, $k[--$j]));
      $_.j = $_.j + 1;
    };
    $_.encc = function() {
      var _5J = $k[$j - 1];
      if ($ne($type(_5J), "arraytype")) {
        var _5N = $get($_.setc, $k[--$j]);
        $k[$j++] = _5N;
      } else {
        $aload($k[--$j]);
        var _5P = $k[--$j];
        var _5Q = $k[--$j];
        $k[$j++] = $f(_5P - 48 + (_5Q - 48) * 10);
      }
      $put($_.cws, $_.j, $k[--$j]);
      $_.j = $_.j + 1;
    };
    $_.anotb = function() {
      var _5V = $k[--$j];
      var _5X = $get($_.seta, _5V) !== void 0;
      var _5Z = $get($_.setb, _5V) !== void 0;
      $k[$j++] = _5X && !_5Z;
    };
    $_.bnota = function() {
      var _5a = $k[--$j];
      var _5c = $get($_.setb, _5a) !== void 0;
      var _5e = $get($_.seta, _5a) !== void 0;
      $k[$j++] = _5c && !_5e;
    };
    $k[$j++] = Infinity;
    for (var _5g = 0, _5h = $_.msg.length; _5g < _5h; _5g++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 9999;
    $_.nextanotb = $a();
    $k[$j++] = Infinity;
    for (var _5k = 0, _5l = $_.msg.length; _5k < _5l; _5k++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 9999;
    $_.nextbnota = $a();
    for (var _5o = $_.msg.length - 1; _5o >= 0; _5o -= 1) {
      $_.i = _5o;
      $k[$j++] = $get($_.msg, $_.i);
      $_.anotb();
      if ($k[--$j]) {
        $put($_.nextanotb, $_.i, 0);
      } else {
        $put($_.nextanotb, $_.i, $get($_.nextanotb, $_.i + 1) + 1);
      }
      $k[$j++] = $get($_.msg, $_.i);
      $_.bnota();
      if ($k[--$j]) {
        $put($_.nextbnota, $_.i, 0);
      } else {
        $put($_.nextbnota, $_.i, $get($_.nextbnota, $_.i + 1) + 1);
      }
    }
    $_.abeforeb = function() {
      var _6B = $k[--$j];
      $k[$j++] = $lt($get($_.nextanotb, _6B), $get($_.nextbnota, _6B));
    };
    $_.bbeforea = function() {
      var _6G = $k[--$j];
      $k[$j++] = $lt($get($_.nextbnota, _6G), $get($_.nextanotb, _6G));
    };
    $_.cws = $a($_.barcode.length * 2 + 3);
    $_.j = 0;
    if ($_.msglen > 0) {
      $k[$j++] = 0;
      $_.numsscr();
    } else {
      $k[$j++] = -1;
    }
    $_.nums = $k[--$j];
    for (; ; ) {
      if ($_.msglen == 0) {
        $k[$j++] = $_.stb;
        $_.enca();
        $_.cset = "setb";
        break;
      }
      if ($_.msglen == 2 && $_.nums == 2) {
        $k[$j++] = $_.stc;
        $_.enca();
        $_.cset = "setc";
        break;
      }
      if ($_.nums >= 4) {
        $k[$j++] = $_.stc;
        $_.enca();
        $_.cset = "setc";
        break;
      }
      $k[$j++] = 0;
      $_.abeforeb();
      if ($k[--$j]) {
        $k[$j++] = $_.sta;
        $_.enca();
        $_.cset = "seta";
        break;
      }
      $k[$j++] = $_.stb;
      $_.enca();
      $_.cset = "setb";
      break;
    }
    $_.i = 0;
    for (; ; ) {
      if ($_.i == $_.msglen) {
        break;
      }
      $k[$j++] = $_.i;
      $_.numsscr();
      $_.nums = $k[--$j];
      for (; ; ) {
        if (($eq($_.cset, "seta") || $eq($_.cset, "setb")) && $_.nums >= 4 && $get($_.msg, $_.i) != $_.fn1) {
          if ($_.nums % 2 == 0) {
            $k[$j++] = $_.swc;
            if ($eq($_.cset, "seta")) {
              $_.enca();
            } else {
              $_.encb();
            }
            $_.cset = "setc";
            break;
          } else {
            $k[$j++] = $get($_.msg, $_.i);
            if ($eq($_.cset, "seta")) {
              $_.enca();
            } else {
              $_.encb();
            }
            $_.i = $_.i + 1;
            $k[$j++] = $_.i;
            $_.numsscr();
            if ($k[--$j] >= 4) {
              $k[$j++] = $_.swc;
              if ($eq($_.cset, "seta")) {
                $_.enca();
              } else {
                $_.encb();
              }
              $_.cset = "setc";
              break;
            }
          }
        }
        $k[$j++] = $eq($_.cset, "setb");
        $k[$j++] = $get($_.msg, $_.i);
        $_.anotb();
        var _70 = $k[--$j];
        if ($k[--$j] && _70) {
          if ($_.i < $_.msglen - 1) {
            $k[$j++] = $_.i + 1;
            $_.bbeforea();
            if ($k[--$j]) {
              $k[$j++] = $_.sft;
              $_.encb();
              $k[$j++] = $get($_.msg, $_.i);
              $_.enca();
              $_.i = $_.i + 1;
              break;
            }
          }
          $k[$j++] = $_.swa;
          $_.encb();
          $_.cset = "seta";
          break;
        }
        $k[$j++] = $eq($_.cset, "seta");
        $k[$j++] = $get($_.msg, $_.i);
        $_.bnota();
        var _7G = $k[--$j];
        if ($k[--$j] && _7G) {
          if ($_.i < $_.msglen - 1) {
            $k[$j++] = $_.i + 1;
            $_.abeforeb();
            if ($k[--$j]) {
              $k[$j++] = $_.sft;
              $_.enca();
              $k[$j++] = $get($_.msg, $_.i);
              $_.encb();
              $_.i = $_.i + 1;
              break;
            }
          }
          $k[$j++] = $_.swb;
          $_.enca();
          $_.cset = "setb";
          break;
        }
        if ($eq($_.cset, "setc") && $_.nums < 2 && ($get($_.msg, $_.i) > -1 || $get($_.msg, $_.i) == $_.fn4)) {
          $k[$j++] = $_.i;
          $_.abeforeb();
          if ($k[--$j]) {
            $k[$j++] = $_.swa;
            $_.encc();
            $_.cset = "seta";
            break;
          }
          $k[$j++] = $_.swb;
          $_.encc();
          $_.cset = "setb";
          break;
        }
        if ($eq($_.cset, "seta")) {
          $k[$j++] = $get($_.msg, $_.i);
          $_.enca();
          $_.i = $_.i + 1;
          break;
        }
        if ($eq($_.cset, "setb")) {
          $k[$j++] = $get($_.msg, $_.i);
          $_.encb();
          $_.i = $_.i + 1;
          break;
        }
        if ($eq($_.cset, "setc")) {
          if ($get($_.msg, $_.i) <= -1) {
            $k[$j++] = $get($_.msg, $_.i);
            $_.encc();
            $_.i = $_.i + 1;
          } else {
            $k[$j++] = $geti($_.msg, $_.i, 2);
            $_.encc();
            $_.i = $_.i + 2;
          }
          break;
        }
        break;
      }
    }
    $_.cws = $geti($_.cws, 0, $_.j);
  }
  if ($eq($_.encoding, "new")) {
    $k[$j++] = Infinity;
    $k[$j++] = $_.fn3;
    $k[$j++] = 96;
    $k[$j++] = $_.fn2;
    $k[$j++] = 97;
    $k[$j++] = $_.fn1;
    $k[$j++] = 102;
    $k[$j++] = $_.stp;
    $k[$j++] = 106;
    $k[$j++] = $_.lka;
    $k[$j++] = 100;
    $k[$j++] = $_.lkc;
    $k[$j++] = 99;
    $_.seta = $d();
    $k[$j++] = Infinity;
    $k[$j++] = $_.fn3;
    $k[$j++] = 96;
    $k[$j++] = $_.fn2;
    $k[$j++] = 97;
    $k[$j++] = $_.fn1;
    $k[$j++] = 102;
    $k[$j++] = $_.stp;
    $k[$j++] = 106;
    $k[$j++] = $_.lka;
    $k[$j++] = 99;
    $k[$j++] = $_.lkc;
    $k[$j++] = 101;
    $_.setb = $d();
    $k[$j++] = Infinity;
    $k[$j++] = $_.fn1;
    $k[$j++] = 102;
    $k[$j++] = $_.stp;
    $k[$j++] = 106;
    $k[$j++] = $_.lka;
    $k[$j++] = 101;
    $k[$j++] = $_.lkc;
    $k[$j++] = 100;
    $_.setc = $d();
    $_.latch_a0 = $a(["", "e", "e", "ee", "eee", "eee"]);
    $_.latch_b0 = $a(["d", "", "d", "ddd", "dd", "ddd"]);
    $_.latch_c0 = $a(["c", "c", "", "eec", "ddc", "dddc"]);
    $_.latch_a1 = $a(["ee", "eee", "eee", "", "e", "e"]);
    $_.latch_b1 = $a(["ddd", "dd", "ddd", "d", "", "d"]);
    $_.latch_c1 = $a(["eec", "ddc", "dddc", "c", "c", ""]);
    $k[$j++] = Infinity;
    var _8U = $_.latch_a0;
    for (var _8V = 0, _8W = _8U.length; _8V < _8W; _8V++) {
      $k[$j++] = $get(_8U, _8V).length;
    }
    $_.latch_length_a0 = $a();
    $k[$j++] = Infinity;
    var _8Z = $_.latch_a1;
    for (var _8a = 0, _8b = _8Z.length; _8a < _8b; _8a++) {
      $k[$j++] = $get(_8Z, _8a).length;
    }
    $_.latch_length_a1 = $a();
    $k[$j++] = Infinity;
    var _8e = $_.latch_b0;
    for (var _8f = 0, _8g = _8e.length; _8f < _8g; _8f++) {
      $k[$j++] = $get(_8e, _8f).length;
    }
    $_.latch_length_b0 = $a();
    $k[$j++] = Infinity;
    var _8j = $_.latch_b1;
    for (var _8k = 0, _8l = _8j.length; _8k < _8l; _8k++) {
      $k[$j++] = $get(_8j, _8k).length;
    }
    $_.latch_length_b1 = $a();
    $k[$j++] = Infinity;
    var _8o = $_.latch_c0;
    for (var _8p = 0, _8q = _8o.length; _8p < _8q; _8p++) {
      $k[$j++] = $get(_8o, _8p).length;
    }
    $_.latch_length_c0 = $a();
    $k[$j++] = Infinity;
    var _8t = $_.latch_c1;
    for (var _8u = 0, _8v = _8t.length; _8u < _8v; _8u++) {
      $k[$j++] = $get(_8t, _8u).length;
    }
    $_.latch_length_c1 = $a();
    $_.latch_sequence = $a([$_.latch_a0, $_.latch_b0, $_.latch_c0, $_.latch_a1, $_.latch_b1, $_.latch_c1]);
    var _95 = $a([function() {
      $_.enc_a0();
    }, function() {
      $_.enc_b0();
    }, function() {
      $_.enc_c();
    }, function() {
      $_.enc_a1();
    }, function() {
      $_.enc_b1();
    }, function() {
      $_.enc_c();
    }]);
    $_.encode = _95;
    $_.start_code = $a([103, 104, 105]);
    $_.state_priority = $a([1, 0, 2, 4, 3, 5]);
    $_.start_state = $a([0, 1, 2, 0, 1, 2]);
    $_.start_length = $a([1, 1, 1, 1, 1, 1]);
    $k[$j++] = Infinity;
    var _9A = $a([5, 4, 3, 2, 1, 0]);
    for (var _9B = 0, _9C = _9A.length; _9B < _9C; _9B++) {
      $k[$j++] = $get($_.state_priority, $get(_9A, _9B));
    }
    $_.reverse_priority = $a();
    $k[$j++] = Infinity;
    var _9H = $_.reverse_priority;
    for (var _9I = 0, _9J = _9H.length; _9I < _9J; _9I++) {
      var _9K = $get(_9H, _9I);
      $k[$j++] = _9K;
      $k[$j++] = $get($_.latch_length_a0, _9K);
      $k[$j++] = _9K;
    }
    $_.prioritized_latch_length_a0 = $a();
    $k[$j++] = Infinity;
    var _9O = $_.reverse_priority;
    for (var _9P = 0, _9Q = _9O.length; _9P < _9Q; _9P++) {
      var _9R = $get(_9O, _9P);
      $k[$j++] = _9R;
      $k[$j++] = $get($_.latch_length_a1, _9R);
      $k[$j++] = _9R;
    }
    $_.prioritized_latch_length_a1 = $a();
    $k[$j++] = Infinity;
    var _9V = $_.reverse_priority;
    for (var _9W = 0, _9X = _9V.length; _9W < _9X; _9W++) {
      var _9Y = $get(_9V, _9W);
      $k[$j++] = _9Y;
      $k[$j++] = $get($_.latch_length_b0, _9Y);
      $k[$j++] = _9Y;
    }
    $_.prioritized_latch_length_b0 = $a();
    $k[$j++] = Infinity;
    var _9c = $_.reverse_priority;
    for (var _9d = 0, _9e = _9c.length; _9d < _9e; _9d++) {
      var _9f = $get(_9c, _9d);
      $k[$j++] = _9f;
      $k[$j++] = $get($_.latch_length_b1, _9f);
      $k[$j++] = _9f;
    }
    $_.prioritized_latch_length_b1 = $a();
    $k[$j++] = Infinity;
    var _9j = $_.reverse_priority;
    for (var _9k = 0, _9l = _9j.length; _9k < _9l; _9k++) {
      var _9m = $get(_9j, _9k);
      $k[$j++] = _9m;
      $k[$j++] = $get($_.latch_length_c0, _9m);
      $k[$j++] = _9m;
    }
    $_.prioritized_latch_length_c0 = $a();
    $k[$j++] = Infinity;
    var _9q = $_.reverse_priority;
    for (var _9r = 0, _9s = _9q.length; _9r < _9s; _9r++) {
      var _9t = $get(_9q, _9r);
      $k[$j++] = _9t;
      $k[$j++] = $get($_.latch_length_c1, _9t);
      $k[$j++] = _9t;
    }
    $_.prioritized_latch_length_c1 = $a();
    $_.max_int = 2147483647;
    $_.can_a = function() {
      if ($_.c >= 0) {
        $k[$j++] = true;
      } else {
        var _A0 = $get($_.seta, $_.c) !== void 0;
        $k[$j++] = _A0;
      }
    };
    $_.can_b = function() {
      if ($_.c >= 0) {
        $k[$j++] = true;
      } else {
        var _A4 = $get($_.setb, $_.c) !== void 0;
        $k[$j++] = _A4;
      }
    };
    $_.can_c0 = function() {
      if ($_.num_digits >= 2) {
        $k[$j++] = true;
      } else {
        var _A8 = $get($_.setc, $_.c) !== void 0;
        $k[$j++] = _A8;
      }
    };
    $_.can_c1 = function() {
      if ($_.num_digits >= 2) {
        $k[$j++] = true;
      } else {
        var _AC = $get($_.setc, $_.c) !== void 0;
        $k[$j++] = _AC;
      }
    };
    if ($_.suppressc) {
      $_.can_c0 = function() {
        $k[$j++] = false;
      };
    }
    if ($_.suppressc || $_.unlatchextbeforec) {
      $_.can_c1 = function() {
        $k[$j++] = false;
      };
    }
    $_.out_a0 = function() {
      $k[$j++] = 1;
      if ($_.c >= 0) {
        if ($_.c >= 128) {
          var _AI = $k[--$j];
          $k[$j++] = _AI + 1;
        }
        if (($_.c & 127) >= 96) {
          var _AK = $k[--$j];
          $k[$j++] = _AK + 1;
        }
      }
    };
    $_.out_a1 = function() {
      $k[$j++] = 1;
      if ($_.c >= 0) {
        if ($_.c < 128) {
          var _AN = $k[--$j];
          $k[$j++] = _AN + 1;
        }
        if (($_.c & 127) >= 96) {
          var _AP = $k[--$j];
          $k[$j++] = _AP + 1;
        }
      }
    };
    $_.out_b0 = function() {
      $k[$j++] = 1;
      if ($_.c >= 0) {
        if ($_.c >= 128) {
          var _AS = $k[--$j];
          $k[$j++] = _AS + 1;
        }
        if (($_.c & 127) < 32) {
          var _AU = $k[--$j];
          $k[$j++] = _AU + 1;
        }
      }
    };
    $_.out_b1 = function() {
      $k[$j++] = 1;
      if ($_.c >= 0) {
        if ($_.c < 128) {
          var _AX = $k[--$j];
          $k[$j++] = _AX + 1;
        }
        if (($_.c & 127) < 32) {
          var _AZ = $k[--$j];
          $k[$j++] = _AZ + 1;
        }
      }
    };
    $_.map_ab = function() {
      var _Aa = $k[$j - 1];
      if (_Aa < 32) {
        var _Ab = $k[--$j];
        $k[$j++] = _Ab + 64;
      } else {
        var _Ac = $k[--$j];
        $k[$j++] = _Ac - 32;
      }
    };
    $_.enc_a0 = function() {
      $k[$j++] = Infinity;
      if ($_.c < 0) {
        $k[$j++] = $get($_.seta, $_.c);
      } else {
        if ($_.c >= 128) {
          $k[$j++] = 101;
        }
        var _Aj = $_.c & 127;
        $k[$j++] = _Aj;
        if (_Aj >= 96) {
          var _Ak = $k[--$j];
          $k[$j++] = 98;
          $k[$j++] = _Ak;
        }
        $_.map_ab();
      }
      var _Al = $a();
      $k[$j++] = _Al;
    };
    $_.enc_a1 = function() {
      $k[$j++] = Infinity;
      if ($_.c < 0) {
        $k[$j++] = $get($_.seta, $_.c);
      } else {
        if ($_.c < 128) {
          $k[$j++] = 101;
        }
        var _As = $_.c & 127;
        $k[$j++] = _As;
        if (_As >= 96) {
          var _At = $k[--$j];
          $k[$j++] = 98;
          $k[$j++] = _At;
        }
        $_.map_ab();
      }
      var _Au = $a();
      $k[$j++] = _Au;
    };
    $_.enc_b0 = function() {
      $k[$j++] = Infinity;
      if ($_.c < 0) {
        $k[$j++] = $get($_.setb, $_.c);
      } else {
        if ($_.c >= 128) {
          $k[$j++] = 100;
        }
        var _B1 = $_.c & 127;
        $k[$j++] = _B1;
        if (_B1 < 32) {
          var _B2 = $k[--$j];
          $k[$j++] = 98;
          $k[$j++] = _B2;
        }
        $_.map_ab();
      }
      var _B3 = $a();
      $k[$j++] = _B3;
    };
    $_.enc_b1 = function() {
      $k[$j++] = Infinity;
      if ($_.c < 0) {
        $k[$j++] = $get($_.setb, $_.c);
      } else {
        if ($_.c < 128) {
          $k[$j++] = 100;
        }
        var _BA = $_.c & 127;
        $k[$j++] = _BA;
        if (_BA < 32) {
          var _BB = $k[--$j];
          $k[$j++] = 98;
          $k[$j++] = _BB;
        }
        $_.map_ab();
      }
      var _BC = $a();
      $k[$j++] = _BC;
    };
    $_.enc_c = function() {
      $k[$j++] = Infinity;
      if ($_.c < 0) {
        $k[$j++] = $get($_.setc, $_.c);
      } else {
        $k[$j++] = $f(($get($_.msg, $_.n) - 48) * 10 + ($get($_.msg, $_.n + 1) - 48));
      }
      var _BN = $a();
      $k[$j++] = _BN;
    };
    $_.get_best_prior_state = function() {
      var _BQ = $get($_.bln_0, $k[--$j]);
      $_.len = $f($k[--$j] + _BQ);
      $_.o = $k[--$j];
      var _BV = $get($_.bln_0, $k[--$j]);
      var _BX = $f($k[--$j] + _BV);
      $k[$j++] = _BX;
      if (_BX < $_.len) {
        $_.len = $k[--$j];
        $_.o = $k[--$j];
      } else {
        $j -= 2;
      }
      var _Bd = $get($_.bln_0, $k[--$j]);
      var _Bf = $f($k[--$j] + _Bd);
      $k[$j++] = _Bf;
      if (_Bf < $_.len) {
        $_.len = $k[--$j];
        $_.o = $k[--$j];
      } else {
        $j -= 2;
      }
      var _Bl = $get($_.bln_0, $k[--$j]);
      var _Bn = $f($k[--$j] + _Bl);
      $k[$j++] = _Bn;
      if (_Bn < $_.len) {
        $_.len = $k[--$j];
        $_.o = $k[--$j];
      } else {
        $j -= 2;
      }
      var _Bt = $get($_.bln_0, $k[--$j]);
      var _Bv = $f($k[--$j] + _Bt);
      $k[$j++] = _Bv;
      if (_Bv < $_.len) {
        $_.len = $k[--$j];
        $_.o = $k[--$j];
      } else {
        $j -= 2;
      }
      var _C1 = $get($_.bln_0, $k[--$j]);
      if ($f($k[--$j] + _C1) < $_.len) {
        $_.o = $k[--$j];
      } else {
        $j--;
      }
      $k[$j++] = $_.o;
    };
    $_.bln_0 = $_.start_length;
    $_.bln_1 = $_.start_length;
    $k[$j++] = Infinity;
    for (var _C8 = 0; _C8 < 4; _C8++) {
      $k[$j++] = $a([0, 0, 0, 0, 0, 0]);
    }
    $_.bln = $a();
    $_.bps_0 = $_.start_state;
    $_.bps_1 = $_.start_state;
    $k[$j++] = Infinity;
    for (var _CD = 0; _CD < 4; _CD++) {
      $k[$j++] = $a([0, 0, 0, 0, 0, 0]);
    }
    $_.bps = $a();
    $k[$j++] = Infinity;
    for (var _CH = 0, _CI = $_.msg.length; _CH < _CI; _CH++) {
      $k[$j++] = $a([0, 0, 0, 0, 0, 0]);
    }
    $_.path = $a();
    $_.make_tables = function() {
      $_.num_digits = 0;
      for (var _CN = 0, _CM = $_.msg.length - 1; _CN <= _CM; _CN += 1) {
        $_.n = _CN;
        $_.c = $get($_.msg, $_.n);
        $k[$j++] = "num_digits";
        if ($_.c >= 48 && $_.c < 58) {
          $k[$j++] = $_.num_digits + 1;
        } else {
          $k[$j++] = 0;
        }
        var _CU = $k[--$j];
        $_[$k[--$j]] = _CU;
        $_.bln_2 = $_.bln_1;
        $_.bln_1 = $_.bln_0;
        $_.bln_0 = $get($_.bln, $_.n & 3);
        $_.bps_2 = $_.bps_1;
        $_.bps_1 = $_.bps_0;
        $_.bps_0 = $get($_.bps, $_.n & 3);
        $k[$j++] = "bps_c";
        if ($_.num_digits >= 2) {
          $k[$j++] = $_.bps_2;
        } else {
          $k[$j++] = $_.bps_1;
        }
        var _Cj = $k[--$j];
        $_[$k[--$j]] = _Cj;
        $k[$j++] = "bln_c";
        if ($_.num_digits >= 2) {
          $k[$j++] = $_.bln_2;
        } else {
          $k[$j++] = $_.bln_1;
        }
        var _Co = $k[--$j];
        $_[$k[--$j]] = _Co;
        $k[$j++] = $_.bln_0;
        $k[$j++] = 0;
        $_.can_a();
        if ($k[--$j]) {
          $_.p = $get($_.bps_1, 0);
          $put($get($_.path, $_.n), 0, $_.p);
          $k[$j++] = $f($get($_.bln_1, $_.p) + $get($_.latch_length_a0, $_.p));
          $_.out_a0();
          var _D4 = $k[--$j];
          var _D5 = $k[--$j];
          $k[$j++] = $f(_D5 + _D4);
        } else {
          $k[$j++] = $_.max_int;
        }
        var _D7 = $k[--$j];
        var _D8 = $k[--$j];
        $put($k[--$j], _D8, _D7);
        $k[$j++] = $_.bln_0;
        $k[$j++] = 3;
        $_.can_a();
        if ($k[--$j]) {
          $_.p = $get($_.bps_1, 3);
          $put($get($_.path, $_.n), 3, $_.p);
          $k[$j++] = $f($get($_.bln_1, $_.p) + $get($_.latch_length_a1, $_.p));
          $_.out_a1();
          var _DO = $k[--$j];
          var _DP = $k[--$j];
          $k[$j++] = $f(_DP + _DO);
        } else {
          $k[$j++] = $_.max_int;
        }
        var _DR = $k[--$j];
        var _DS = $k[--$j];
        $put($k[--$j], _DS, _DR);
        $k[$j++] = $_.bln_0;
        $k[$j++] = 1;
        $_.can_b();
        if ($k[--$j]) {
          $_.p = $get($_.bps_1, 1);
          $put($get($_.path, $_.n), 1, $_.p);
          $k[$j++] = $f($get($_.bln_1, $_.p) + $get($_.latch_length_b0, $_.p));
          $_.out_b0();
          var _Di = $k[--$j];
          var _Dj = $k[--$j];
          $k[$j++] = $f(_Dj + _Di);
        } else {
          $k[$j++] = $_.max_int;
        }
        var _Dl = $k[--$j];
        var _Dm = $k[--$j];
        $put($k[--$j], _Dm, _Dl);
        $k[$j++] = $_.bln_0;
        $k[$j++] = 4;
        $_.can_b();
        if ($k[--$j]) {
          $_.p = $get($_.bps_1, 4);
          $put($get($_.path, $_.n), 4, $_.p);
          $k[$j++] = $f($get($_.bln_1, $_.p) + $get($_.latch_length_b1, $_.p));
          $_.out_b1();
          var _E2 = $k[--$j];
          var _E3 = $k[--$j];
          $k[$j++] = $f(_E3 + _E2);
        } else {
          $k[$j++] = $_.max_int;
        }
        var _E5 = $k[--$j];
        var _E6 = $k[--$j];
        $put($k[--$j], _E6, _E5);
        $k[$j++] = $_.bln_0;
        $k[$j++] = 2;
        $_.can_c0();
        if ($k[--$j]) {
          $_.p = $get($_.bps_c, 2);
          $put($get($_.path, $_.n), 2, $_.p);
          $k[$j++] = $f($get($_.bln_c, $_.p) + $get($_.latch_length_c0, $_.p)) + 1;
        } else {
          $k[$j++] = $_.max_int;
        }
        var _EN = $k[--$j];
        var _EO = $k[--$j];
        $put($k[--$j], _EO, _EN);
        $k[$j++] = $_.bln_0;
        $k[$j++] = 5;
        $_.can_c1();
        if ($k[--$j]) {
          $_.p = $get($_.bps_c, 5);
          $put($get($_.path, $_.n), 5, $_.p);
          $k[$j++] = $f($get($_.bln_c, $_.p) + $get($_.latch_length_c1, $_.p)) + 1;
        } else {
          $k[$j++] = $_.max_int;
        }
        var _Ef = $k[--$j];
        var _Eg = $k[--$j];
        $put($k[--$j], _Eg, _Ef);
        $k[$j++] = $_.bps_0;
        $k[$j++] = 0;
        $aload($_.prioritized_latch_length_a0);
        $_.get_best_prior_state();
        var _Ek = $k[--$j];
        var _El = $k[--$j];
        $put($k[--$j], _El, _Ek);
        $k[$j++] = $_.bps_0;
        $k[$j++] = 3;
        $aload($_.prioritized_latch_length_a1);
        $_.get_best_prior_state();
        var _Ep = $k[--$j];
        var _Eq = $k[--$j];
        $put($k[--$j], _Eq, _Ep);
        $k[$j++] = $_.bps_0;
        $k[$j++] = 1;
        $aload($_.prioritized_latch_length_b0);
        $_.get_best_prior_state();
        var _Eu = $k[--$j];
        var _Ev = $k[--$j];
        $put($k[--$j], _Ev, _Eu);
        $k[$j++] = $_.bps_0;
        $k[$j++] = 4;
        $aload($_.prioritized_latch_length_b1);
        $_.get_best_prior_state();
        var _Ez = $k[--$j];
        var _F0 = $k[--$j];
        $put($k[--$j], _F0, _Ez);
        $k[$j++] = $_.bps_0;
        $k[$j++] = 2;
        $aload($_.prioritized_latch_length_c0);
        $_.get_best_prior_state();
        var _F4 = $k[--$j];
        var _F5 = $k[--$j];
        $put($k[--$j], _F5, _F4);
        $k[$j++] = $_.bps_0;
        $k[$j++] = 5;
        $aload($_.prioritized_latch_length_c1);
        $_.get_best_prior_state();
        var _F9 = $k[--$j];
        var _FA = $k[--$j];
        $put($k[--$j], _FA, _F9);
      }
    };
    $_.backtrack = function() {
      $_.n = $_.msg.length;
      var _FD = $_.reverse_priority;
      for (var _FE = 0, _FF = _FD.length; _FE < _FF; _FE++) {
        var _FG = $get(_FD, _FE);
        var _FI = $get($_.bln_0, _FG);
        $k[$j++] = _FG;
        $k[$j++] = _FI;
        $k[$j++] = _FI;
      }
      $j--;
      $_.len = $k[--$j];
      $_.state = $k[--$j];
      for (var _FL = 0; _FL < 5; _FL++) {
        if ($lt($k[--$j], $_.len)) {
          $_.len = $k[--$j];
          $_.state = $k[--$j];
        } else {
          $j -= 2;
        }
      }
      $k[$j++] = $a($_.len);
      for (; ; ) {
        if ($_.n <= 0) {
          break;
        }
        $_.prior_state = $get($get($_.path, $_.n - 1), $_.state);
        $k[$j++] = Infinity;
        $forall($get($get($_.latch_sequence, $_.state), $_.prior_state));
        $_.latch = $a();
        var _Fk = ($_.state == 2 || $_.state == 5) && $get($_.msg, $_.n - 1) >= 48 ? 2 : 1;
        $_.n = $_.n - _Fk;
        $_.c = $get($_.msg, $_.n);
        $k[$j++] = "enc";
        if ($get($_.encode, $_.state)() === true) {
          break;
        }
        var _Fr = $k[--$j];
        $_[$k[--$j]] = _Fr;
        $_.len = $f($_.len - $_.latch.length - $_.enc.length);
        var _Fw = $k[--$j];
        var _Fx = $_.len;
        var _Fy = $_.latch;
        $puti(_Fw, _Fx, _Fy);
        $puti(_Fw, $f(_Fx + _Fy.length), $_.enc);
        $_.state = $_.prior_state;
        $k[$j++] = _Fw;
      }
      var _G1 = $k[$j - 1];
      $put(_G1, 0, $get($_.start_code, $_.state));
    };
    $_.make_tables();
    $_.backtrack();
    $_.cws = $k[--$j];
  }
  $_.j = $_.cws.length;
  var _G8 = $a($_.j + 2);
  $puti(_G8, 0, $_.cws);
  $_.cws = _G8;
  $_.csum = $get($_.cws, 0);
  for (var _GE = 1, _GD = $_.j - 1; _GE <= _GD; _GE += 1) {
    $_.i = _GE;
    $_.csum = $f($_.csum + $get($_.cws, $_.i) * $_.i);
  }
  $_.csum = $_.csum % 103;
  $put($_.cws, $_.j, $_.csum);
  $put($_.cws, $_.j + 1, 106);
  var _GR = $get($_.options, "debugcws") !== void 0;
  if (_GR) {
    $k[$j++] = "bwipp.debugcws#7483";
    $k[$j++] = $_.cws;
    bwipp_raiseerror();
  }
  $_.encs = $a(["212222", "222122", "222221", "121223", "121322", "131222", "122213", "122312", "132212", "221213", "221312", "231212", "112232", "122132", "122231", "113222", "123122", "123221", "223211", "221132", "221231", "213212", "223112", "312131", "311222", "321122", "321221", "312212", "322112", "322211", "212123", "212321", "232121", "111323", "131123", "131321", "112313", "132113", "132311", "211313", "231113", "231311", "112133", "112331", "132131", "113123", "113321", "133121", "313121", "211331", "231131", "213113", "213311", "213131", "311123", "311321", "331121", "312113", "312311", "332111", "314111", "221411", "431111", "111224", "111422", "121124", "121421", "141122", "141221", "112214", "112412", "122114", "122411", "142112", "142211", "241211", "221114", "413111", "241112", "134111", "111242", "121142", "121241", "114212", "124112", "124211", "411212", "421112", "421211", "212141", "214121", "412121", "111143", "111341", "131141", "114113", "114311", "411113", "411311", "113141", "114131", "311141", "411131", "211412", "211214", "211232", "2331112"]);
  $_.sbs = $s($_.cws.length * 6 + 1);
  for (var _GZ = 0, _GY = $_.cws.length - 1; _GZ <= _GY; _GZ += 1) {
    $_.i = _GZ;
    $puti($_.sbs, $_.i * 6, $get($_.encs, $get($_.cws, $_.i)));
  }
  $k[$j++] = Infinity;
  $k[$j++] = Infinity;
  var _Gh = $_.sbs;
  for (var _Gi = 0, _Gj = _Gh.length; _Gi < _Gj; _Gi++) {
    $k[$j++] = $get(_Gh, _Gi) - 48;
  }
  var _Gl = $a();
  $k[$j++] = Infinity;
  for (var _Gn = 0, _Go = ~~(($_.sbs.length + 1) / 2); _Gn < _Go; _Gn++) {
    $k[$j++] = $_.height;
  }
  var _Gq = $a();
  $k[$j++] = Infinity;
  for (var _Gs = 0, _Gt = ~~(($_.sbs.length + 1) / 2); _Gs < _Gt; _Gs++) {
    $k[$j++] = 0;
  }
  var _Gu = $a();
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "sbs";
  $k[$j++] = _Gl;
  $k[$j++] = "bhs";
  $k[$j++] = _Gq;
  $k[$j++] = "bbs";
  $k[$j++] = _Gu;
  $k[$j++] = "txt";
  $k[$j++] = $a([$a([$_.text, $_.textxoffset, $_.textyoffset, $_.textfont, $_.textsize])]);
  $k[$j++] = "textxalign";
  $k[$j++] = "center";
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  var _H3 = $d();
  $k[$j++] = _H3;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_gs1_128() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.textfont = "OCR-B";
  $_.textsize = 10;
  $_.textxoffset = 0;
  $_.textyoffset = -8;
  $_.height = 0.5;
  $_.linkagea = false;
  $_.linkagec = false;
  $_.parse = false;
  $_.dontlint = false;
  $_.lintreqs = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.linkagea && $_.linkagec) {
    $k[$j++] = "bwipp.gs1128badLinkage#7580";
    $k[$j++] = "linkagea and linkagec cannot be used together";
    bwipp_raiseerror();
  }
  $_.text = $_.barcode;
  $k[$j++] = $_.barcode;
  $k[$j++] = "ai";
  bwipp_gs1process();
  $_.fncs = $k[--$j];
  $_.vals = $k[--$j];
  $_.ais = $k[--$j];
  $_.fnc1 = -1;
  $_.c128 = $a([$_.fnc1]);
  for (var _D = 0, _C = $_.ais.length - 1; _D <= _C; _D += 1) {
    $_.i = _D;
    $_.ai = $get($_.ais, $_.i);
    $_.val = $get($_.vals, $_.i);
    var _N = $a($_.c128.length + $_.ai.length + $_.val.length);
    $puti(_N, 0, $_.c128);
    $k[$j++] = _N;
    $k[$j++] = _N;
    $k[$j++] = $_.c128.length;
    var _R = Infinity;
    var _S = $_.ai;
    $k[$j++] = _R;
    $forall(_S);
    var _T = $a();
    var _U = $k[--$j];
    $puti($k[--$j], _U, _T);
    var _W = $k[$j - 1];
    $k[$j++] = _W;
    $k[$j++] = $_.c128.length + $_.ai.length;
    var _a = Infinity;
    var _b = $_.val;
    $k[$j++] = _a;
    $forall(_b);
    var _c = $a();
    var _d = $k[--$j];
    $puti($k[--$j], _d, _c);
    $_.c128 = $k[--$j];
    if ($_.i != $_.ais.length - 1 && $get($_.fncs, $_.i)) {
      var _m = $a($_.c128.length + 1);
      $puti(_m, 0, $_.c128);
      $put(_m, $_.c128.length, $_.fnc1);
      $_.c128 = _m;
    }
  }
  $_.barcode = $s(($_.c128.length + 1) * 5);
  $_.i = 0;
  $_.j = 0;
  for (; ; ) {
    if ($_.i == $_.c128.length) {
      break;
    }
    var _w = $get($_.c128, $_.i);
    $k[$j++] = _w;
    if (_w == $_.fnc1) {
      $j--;
      $puti($_.barcode, $_.j, "^FNC1");
      $_.j = $_.j + 4;
    } else {
      $put($_.barcode, $_.j, $k[--$j]);
    }
    $_.i = $_.i + 1;
    $_.j = $_.j + 1;
  }
  if ($_.linkagea || $_.linkagec) {
    $k[$j++] = $_.barcode;
    $k[$j++] = $_.j;
    if ($_.linkagea) {
      $k[$j++] = "^LNKA";
    } else {
      $k[$j++] = "^LNKC";
    }
    var _1B = $k[--$j];
    var _1C = $k[--$j];
    $puti($k[--$j], _1C, _1B);
    $_.j = $_.j + 5;
  }
  $_.barcode = $geti($_.barcode, 0, $_.j);
  delete $_.options["parse"];
  $put($_.options, "height", $_.height);
  $put($_.options, "dontdraw", true);
  $put($_.options, "parsefnc", true);
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_code128();
  var _1P = $k[--$j];
  $_[$k[--$j]] = _1P;
  $put($_.args, "txt", $a([$a([$_.text, $_.textxoffset, $_.textyoffset, $_.textfont, $_.textsize])]));
  $put($_.args, "textxalign", "center");
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_ean14() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.textfont = "OCR-B";
  $_.textsize = 10;
  $_.textxoffset = 0;
  $_.textyoffset = -8;
  $_.height = 1;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $_.text = $_.barcode;
  var _3 = $_.barcode;
  $k[$j++] = $s(_3.length);
  $k[$j++] = 0;
  $forall(_3, function() {
    var _5 = $k[$j - 1];
    if (_5 != 32) {
      var _6 = $k[--$j];
      var _7 = $k[--$j];
      var _8 = $k[$j - 1];
      $put(_8, _7, _6);
      $k[$j++] = _7 + 1;
    } else {
      $j--;
    }
  });
  var _9 = $k[--$j];
  $_.barcode = $geti($k[--$j], 0, _9);
  $_.hasspace = $_.text.length != $_.barcode.length;
  if ($_.barcode.length != 17 && $_.barcode.length != 18) {
    $k[$j++] = "bwipp.ean14badLength#7695";
    $k[$j++] = "EAN-14 must be 13 or 14 digits";
    bwipp_raiseerror();
  }
  if ($ne($geti($_.barcode, 0, 4), "(01)")) {
    $k[$j++] = "bwipp.ean14badAI#7698";
    $k[$j++] = "EAN-14 must begin with (01) application identifier";
    bwipp_raiseerror();
  }
  var _K = $geti($_.barcode, 4, $_.barcode.length - 4);
  for (var _L = 0, _M = _K.length; _L < _M; _L++) {
    var _N = $get(_K, _L);
    if (_N < 48 || _N > 57) {
      $k[$j++] = "bwipp.ean14badCharacter#7702";
      $k[$j++] = "EAN-14 must contain only digits";
      bwipp_raiseerror();
    }
  }
  $_.checksum = 0;
  for (var _O = 0; _O <= 12; _O += 1) {
    $_.i = _O;
    $k[$j++] = "checksum";
    $k[$j++] = $_.checksum;
    $k[$j++] = $get($_.barcode, $_.i + 4) - 48;
    if ($_.i % 2 == 0) {
      var _U = $k[--$j];
      $k[$j++] = _U * 3;
    }
    var _V = $k[--$j];
    var _W = $k[--$j];
    $_[$k[--$j]] = $f(_W + _V);
  }
  $_.checksum = (10 - $_.checksum % 10) % 10;
  if ($_.barcode.length == 18) {
    if ($get($_.barcode, 17) != $_.checksum + 48) {
      $k[$j++] = "bwipp.ean14badCheckDigit#7715";
      $k[$j++] = "Incorrect EAN-14 check digit provided";
      bwipp_raiseerror();
    }
  } else {
    var _d = $s(18);
    $puti(_d, 0, $_.barcode);
    $put(_d, 17, $_.checksum + 48);
    $_.barcode = _d;
    var _i = $_.hasspace ? 2 : 1;
    var _j = $s($_.text.length + _i);
    $puti(_j, _j.length - 2, " ");
    $put(_j, _j.length - 1, $_.checksum + 48);
    $puti(_j, 0, $_.text);
    $_.text = _j;
  }
  $_.gtin = $geti($_.barcode, 4, 14);
  $_.barcode = $s(21);
  $puti($_.barcode, 0, "^FNC101");
  var _r = $_.gtin;
  $puti($_.barcode, 7, _r);
  $put($_.options, "dontdraw", true);
  $put($_.options, "parsefnc", true);
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_code128();
  var _w = $k[--$j];
  $_[$k[--$j]] = _w;
  $put($_.args, "txt", $a([$a([$_.text, $_.textxoffset, $_.textyoffset, $_.textfont, $_.textsize])]));
  $put($_.args, "textxalign", "center");
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_sscc18() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.textfont = "OCR-B";
  $_.textsize = 10;
  $_.textxoffset = 0;
  $_.textyoffset = -8;
  $_.height = 1;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $_.text = $_.barcode;
  var _3 = $_.barcode;
  $k[$j++] = $s(_3.length);
  $k[$j++] = 0;
  $forall(_3, function() {
    var _5 = $k[$j - 1];
    if (_5 != 32) {
      var _6 = $k[--$j];
      var _7 = $k[--$j];
      var _8 = $k[$j - 1];
      $put(_8, _7, _6);
      $k[$j++] = _7 + 1;
    } else {
      $j--;
    }
  });
  var _9 = $k[--$j];
  $_.barcode = $geti($k[--$j], 0, _9);
  $_.hasspace = $_.text.length != $_.barcode.length;
  if ($_.barcode.length != 21 && $_.barcode.length != 22) {
    $k[$j++] = "bwipp.sscc18badLength#7799";
    $k[$j++] = "SSCC-18 must be 17 or 18 digits";
    bwipp_raiseerror();
  }
  if ($ne($geti($_.barcode, 0, 4), "(00)")) {
    $k[$j++] = "bwipp.sscc18badAI#7802";
    $k[$j++] = "SSCC-18 must begin with (00) application identifier";
    bwipp_raiseerror();
  }
  var _K = $geti($_.barcode, 4, $_.barcode.length - 4);
  for (var _L = 0, _M = _K.length; _L < _M; _L++) {
    var _N = $get(_K, _L);
    if (_N < 48 || _N > 57) {
      $k[$j++] = "bwipp.sscc18badCharacter#7806";
      $k[$j++] = "SSCC-18 must contain only digits";
      bwipp_raiseerror();
    }
  }
  $_.checksum = 0;
  for (var _O = 0; _O <= 16; _O += 1) {
    $_.i = _O;
    $k[$j++] = "checksum";
    $k[$j++] = $_.checksum;
    $k[$j++] = $get($_.barcode, $_.i + 4) - 48;
    if ($_.i % 2 == 0) {
      var _U = $k[--$j];
      $k[$j++] = _U * 3;
    }
    var _V = $k[--$j];
    var _W = $k[--$j];
    $_[$k[--$j]] = $f(_W + _V);
  }
  $_.checksum = (10 - $_.checksum % 10) % 10;
  if ($_.barcode.length == 22) {
    if ($get($_.barcode, 21) != $_.checksum + 48) {
      $k[$j++] = "bwipp.sscc18badCheckDigit#7819";
      $k[$j++] = "Incorrect SSCC-18 check digit provided";
      bwipp_raiseerror();
    }
  } else {
    var _d = $s(22);
    $puti(_d, 0, $_.barcode);
    $put(_d, 21, $_.checksum + 48);
    $_.barcode = _d;
    var _i = $_.hasspace ? 2 : 1;
    var _j = $s($_.text.length + _i);
    $puti(_j, _j.length - 2, " ");
    $put(_j, _j.length - 1, $_.checksum + 48);
    $puti(_j, 0, $_.text);
    $_.text = _j;
  }
  $_.sscc = $geti($_.barcode, 4, 18);
  $_.barcode = $s(25);
  $puti($_.barcode, 0, "^FNC100");
  var _r = $_.sscc;
  $puti($_.barcode, 7, _r);
  $put($_.options, "dontdraw", true);
  $put($_.options, "parsefnc", true);
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_code128();
  var _w = $k[--$j];
  $_[$k[--$j]] = _w;
  $put($_.args, "txt", $a([$a([$_.text, $_.textxoffset, $_.textyoffset, $_.textfont, $_.textsize])]));
  $put($_.args, "textxalign", "center");
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_code39() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includecheck = false;
  $_.validatecheck = false;
  $_.includetext = false;
  $_.includecheckintext = false;
  $_.hidestars = false;
  $_.textfont = "OCR-B";
  $_.textsize = 10;
  $_.textyoffset = -8;
  $_.height = 1;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length == 0) {
    $k[$j++] = "bwipp.code39emptyData#7899";
    $k[$j++] = "The data must not be empty";
    bwipp_raiseerror();
  }
  $_.encs = $a(["1113313111", "3113111131", "1133111131", "3133111111", "1113311131", "3113311111", "1133311111", "1113113131", "3113113111", "1133113111", "3111131131", "1131131131", "3131131111", "1111331131", "3111331111", "1131331111", "1111133131", "3111133111", "1131133111", "1111333111", "3111111331", "1131111331", "3131111311", "1111311331", "3111311311", "1131311311", "1111113331", "3111113311", "1131113311", "1111313311", "3311111131", "1331111131", "3331111111", "1311311131", "3311311111", "1331311111", "1311113131", "3311113111", "1331113111", "1313131111", "1313111311", "1311131311", "1113131311", "1311313111"]);
  $_.barchars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
  $_.charvals = /* @__PURE__ */ new Map();
  for (var _4 = 0; _4 <= 42; _4 += 1) {
    $put($_.charvals, $geti($_.barchars, _4, 1), _4);
  }
  for (var _B = 0, _A = $_.barcode.length - 1; _B <= _A; _B += 1) {
    var _F = $get($_.charvals, $geti($_.barcode, _B, 1)) !== void 0;
    if (!_F) {
      $k[$j++] = "bwipp.code39badCharacter#7927";
      $k[$j++] = "Code 39 must contain only digits, capital letters, spaces and the symbols -.$/+%";
      bwipp_raiseerror();
    }
  }
  $k[$j++] = "barlen";
  $k[$j++] = $_.barcode.length;
  if ($_.validatecheck) {
    var _I = $k[--$j];
    $k[$j++] = _I - 1;
  }
  var _J = $k[--$j];
  $_[$k[--$j]] = _J;
  $_.checksum = 0;
  for (var _N = 0, _M = $_.barlen - 1; _N <= _M; _N += 1) {
    $_.checksum = $f($get($_.charvals, $geti($_.barcode, _N, 1)) + $_.checksum);
  }
  $_.checksum = $_.checksum % 43;
  if ($_.validatecheck) {
    if ($get($_.barcode, $_.barlen) != $get($_.barchars, $_.checksum)) {
      $k[$j++] = "bwipp.code39badCheckDigit#7941";
      $k[$j++] = "Incorrect Code 39 check digit provided";
      bwipp_raiseerror();
    }
    $_.barcode = $geti($_.barcode, 0, $_.barlen);
    $_.includecheck = true;
  }
  var _g = $_.includecheck ? 3 : 2;
  $_.sbs = $s($f($_.barlen + _g) * 10);
  var _k = $_.includecheck ? 3 : 2;
  $_.txt = $a($f($_.barlen + _k));
  $puti($_.sbs, 0, $get($_.encs, 43));
  if (!$_.hidestars) {
    $put($_.txt, 0, $a(["*", 0, $_.textyoffset, $_.textfont, $_.textsize]));
  } else {
    $put($_.txt, 0, $a(["", 0, $_.textyoffset, $_.textfont, $_.textsize]));
  }
  for (var _12 = 0, _11 = $_.barlen - 1; _12 <= _11; _12 += 1) {
    $_.i = _12;
    $_.indx = $get($_.charvals, $geti($_.barcode, $_.i, 1));
    $puti($_.sbs, $_.i * 10 + 10, $get($_.encs, $_.indx));
    $put($_.txt, $_.i + 1, $a([$geti($_.barcode, $_.i, 1), ($_.i + 1) * 16, $_.textyoffset, $_.textfont, $_.textsize]));
  }
  if ($_.includecheck) {
    $puti($_.sbs, $_.barlen * 10 + 10, $get($_.encs, $_.checksum));
    if ($_.includecheckintext) {
      $put($_.txt, $_.barlen + 1, $a([$geti($_.barchars, $_.checksum, 1), ($_.barlen + 1) * 16, $_.textyoffset, $_.textfont, $_.textsize]));
    } else {
      $put($_.txt, $_.barlen + 1, $a(["", ($_.barlen + 1) * 16, $_.textyoffset, $_.textfont, $_.textsize]));
    }
    $puti($_.sbs, $_.barlen * 10 + 20, $get($_.encs, 43));
    if (!$_.hidestars) {
      $put($_.txt, $_.barlen + 2, $a(["*", ($_.barlen + 2) * 16, $_.textyoffset, $_.textfont, $_.textsize]));
    } else {
      $put($_.txt, $_.barlen + 2, $a(["", ($_.barlen + 2) * 16, $_.textyoffset, $_.textfont, $_.textsize]));
    }
  } else {
    $puti($_.sbs, $_.barlen * 10 + 10, $get($_.encs, 43));
    if (!$_.hidestars) {
      $put($_.txt, $_.barlen + 1, $a(["*", ($_.barlen + 1) * 16, $_.textyoffset, $_.textfont, $_.textsize]));
    } else {
      $put($_.txt, $_.barlen + 1, $a(["", ($_.barlen + 1) * 16, $_.textyoffset, $_.textfont, $_.textsize]));
    }
  }
  $k[$j++] = Infinity;
  $k[$j++] = Infinity;
  var _2N = $_.sbs;
  for (var _2O = 0, _2P = _2N.length; _2O < _2P; _2O++) {
    $k[$j++] = $get(_2N, _2O) - 48;
  }
  var _2R = $a();
  $k[$j++] = Infinity;
  for (var _2T = 0, _2U = ~~(($_.sbs.length + 1) / 2); _2T < _2U; _2T++) {
    $k[$j++] = $_.height;
  }
  var _2W = $a();
  $k[$j++] = Infinity;
  for (var _2Y = 0, _2Z = ~~(($_.sbs.length + 1) / 2); _2Y < _2Z; _2Y++) {
    $k[$j++] = 0;
  }
  var _2a = $a();
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "sbs";
  $k[$j++] = _2R;
  $k[$j++] = "bhs";
  $k[$j++] = _2W;
  $k[$j++] = "bbs";
  $k[$j++] = _2a;
  if ($_.includetext) {
    $k[$j++] = "txt";
    $k[$j++] = $_.txt;
  }
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  var _2e = $d();
  $k[$j++] = _2e;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_code39ext() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.parse = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  var _3 = /* @__PURE__ */ new Map([
    ["parse", $_.parse],
    ["parseonly", true],
    ["parsefnc", false]
  ]);
  $_.fncvals = _3;
  $k[$j++] = "barcode";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.fncvals;
  bwipp_parseinput();
  var _6 = $k[--$j];
  $_[$k[--$j]] = _6;
  $_.barlen = $_.barcode.length;
  delete $_.options["parse"];
  $forall($_.barcode, function() {
    if ($k[--$j] >= 128) {
      $k[$j++] = "bwipp.code39extBadCharacter#8061";
      $k[$j++] = "Code 39 Extended must contain only ASCII characters";
      bwipp_raiseerror();
    }
  });
  $_.extencs = $a(["%U", "$A", "$B", "$C", "$D", "$E", "$F", "$G", "$H", "$I", "$J", "$K", "$L", "$M", "$N", "$O", "$P", "$Q", "$R", "$S", "$T", "$U", "$V", "$W", "$X", "$Y", "$Z", "%A", "%B", "%C", "%D", "%E", " ", "/A", "/B", "/C", "/D", "/E", "/F", "/G", "/H", "/I", "/J", "/K", "/L", "-", ".", "/O", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "/Z", "%F", "%G", "%H", "%I", "%J", "%V", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "%K", "%L", "%M", "%N", "%O", "%W", "+A", "+B", "+C", "+D", "+E", "+F", "+G", "+H", "+I", "+J", "+K", "+L", "+M", "+N", "+O", "+P", "+Q", "+R", "+S", "+T", "+U", "+V", "+W", "+X", "+Y", "+Z", "%P", "%Q", "%R", "%S", "%T"]);
  $_.newcode = $s($_.barlen * 2);
  $_.newtext = $s($_.barlen * 2);
  $_.j = 0;
  for (var _K = 0, _J = $_.barlen - 1; _K <= _J; _K += 1) {
    $_.i = _K;
    $_.extchar = $get($_.extencs, $get($_.barcode, $_.i));
    $puti($_.newcode, $_.j, $_.extchar);
    var _X = $get($_.barcode, $_.i);
    $k[$j++] = $_.newtext;
    $k[$j++] = $_.j;
    $k[$j++] = _X;
    if (_X < 32 || _X == 127) {
      $k[$j - 1] = 32;
    }
    var _Y = $k[--$j];
    var _Z = $k[--$j];
    $put($k[--$j], _Z, _Y);
    if ($_.extchar.length != 1) {
      $put($_.newtext, $_.j + 1, 32);
    }
    $_.j = $_.j + $_.extchar.length;
  }
  $_.newcode = $geti($_.newcode, 0, $_.j);
  $_.newtext = $geti($_.newtext, 0, $_.j);
  $put($_.options, "dontdraw", true);
  $k[$j++] = "args";
  $k[$j++] = $_.newcode;
  $k[$j++] = $_.options;
  bwipp_code39();
  var _p = $k[--$j];
  $_[$k[--$j]] = _p;
  if ($_.includetext) {
    $_.txt = $get($_.args, "txt");
    for (var _w = 0, _v = $_.newtext.length - 1; _w <= _v; _w += 1) {
      $_.i = _w;
      $_.txtentry = $get($_.txt, $_.i + 1);
      $put($_.txtentry, 0, $geti($_.newtext, $_.i, 1));
      $put($_.txt, $_.i + 1, $_.txtentry);
    }
    $put($_.args, "txt", $_.txt);
  }
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_code32() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.textfont = "OCR-B";
  $_.textsize = 10;
  $_.textyoffset = -8;
  $_.textxoffset = 0;
  $_.height = 1;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length != 8 && $_.barcode.length != 9) {
    $k[$j++] = "bwipp.code32badLength#8160";
    $k[$j++] = "Italian Pharmacode must be 8 or 9 digits";
    bwipp_raiseerror();
  }
  $forall($_.barcode, function() {
    var _5 = $k[--$j];
    if (_5 < 48 || _5 > 57) {
      $k[$j++] = "bwipp.code32badCharacter#8164";
      $k[$j++] = "Italian Pharmacode must contain only digits";
      bwipp_raiseerror();
    }
  });
  $_.checksum = 0;
  for (var _6 = 0; _6 <= 7; _6 += 1) {
    $_.i = _6;
    $k[$j++] = $get($_.barcode, $_.i) - 48;
    if ($_.i % 2 != 0) {
      var _B = $k[--$j];
      $k[$j++] = _B * 2;
    }
    var _C = $k[$j - 1];
    if (_C > 9) {
      var _D = $k[--$j];
      $k[$j++] = _D - 9;
    }
    $_.checksum = $f($k[--$j] + $_.checksum);
  }
  $_.checksum = $_.checksum % 10;
  if ($_.barcode.length == 9) {
    if ($get($_.barcode, 8) != $_.checksum + 48) {
      $k[$j++] = "bwipp.code32badCheckDigit#8178";
      $k[$j++] = "Incorrect Italian Pharmacode check digit provided";
      bwipp_raiseerror();
    }
  }
  var _L = $s(10);
  $puti(_L, 0, $_.barcode);
  $put(_L, 8, $_.checksum + 48);
  $_.text = _L;
  $_.val = $cvrs($s(6), $cvi($_.text), 32);
  $_.barcode = $s(6);
  for (var _S = 0; _S <= 5; _S += 1) {
    $put($_.barcode, _S, 48);
  }
  $puti($_.barcode, 6 - $_.val.length, $_.val);
  for (var _X = 0; _X <= 5; _X += 1) {
    var _Z = $get($_.barcode, _X);
    $k[$j++] = _X;
    $k[$j++] = _Z;
    $k[$j++] = _Z;
    for (var _a = 0, _b = "AEIO".length; _a < _b; _a++) {
      if ($k[--$j] >= $get("AEIO", _a)) {
        var _e = $k[--$j];
        $k[$j++] = _e + 1;
      }
      var _f = $k[$j - 1];
      $k[$j++] = _f;
    }
    $k[$j - 1] = $_.barcode;
    var _h = $k[$j - 2];
    var _i = $k[$j - 3];
    $put($k[$j - 1], _i, _h);
    $j -= 3;
  }
  $puti($_.text, 1, $geti($_.text, 0, 9));
  $put($_.text, 0, 65);
  $put($_.options, "dontdraw", true);
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_code39();
  var _r = $k[--$j];
  $_[$k[--$j]] = _r;
  $put($_.args, "txt", $a([$a([$_.text, $_.textxoffset, $_.textyoffset, $_.textfont, $_.textsize])]));
  $put($_.args, "textxalign", "center");
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_pzn() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.textfont = "OCR-B";
  $_.textsize = 10;
  $_.textyoffset = -8;
  $_.textxoffset = 0;
  $_.height = 1;
  $_.pzn8 = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.pzn8) {
    if ($_.barcode.length != 7 && $_.barcode.length != 8) {
      $k[$j++] = "bwipp.pzn8badLength#8261";
      $k[$j++] = "PZN8 must be 7 or 8 digits";
      bwipp_raiseerror();
    }
  } else {
    if ($_.barcode.length != 6 && $_.barcode.length != 7) {
      $k[$j++] = "bwipp.pzn7badLength#8265";
      $k[$j++] = "PZN7 must be 6 or 7 digits";
      bwipp_raiseerror();
    }
  }
  $forall($_.barcode, function() {
    var _8 = $k[--$j];
    if (_8 < 48 || _8 > 57) {
      $k[$j++] = "bwipp.pznBadCharacter#8270";
      $k[$j++] = "PZN must contain only digits";
      bwipp_raiseerror();
    }
  });
  var _A = $_.pzn8 ? 9 : 8;
  $_.msglen = _A;
  $_.checksum = 0;
  for (var _D = 0, _C = $_.msglen - 3; _D <= _C; _D += 1) {
    $_.i = _D;
    var _J = $_.pzn8 ? 1 : 2;
    $_.checksum = $f(($get($_.barcode, $_.i) - 48) * ($_.i + _J) + $_.checksum);
  }
  $_.checksum = $_.checksum % 11;
  if ($_.checksum == 10) {
    $k[$j++] = "bwipp.pznBadInputSequence#8284";
    $k[$j++] = "Incorrect PZN input sequence provided";
    bwipp_raiseerror();
  }
  if ($_.barcode.length == $_.msglen - 1) {
    if ($get($_.barcode, $_.msglen - 2) != $_.checksum + 48) {
      $k[$j++] = "bwipp.pznBadCheckDigit#8288";
      $k[$j++] = "Incorrect PZN check digit provided";
      bwipp_raiseerror();
    }
  }
  var _U = $s($_.msglen);
  $put(_U, 0, 45);
  $puti(_U, 1, $_.barcode);
  $put(_U, $_.msglen - 1, $_.checksum + 48);
  $_.msg = _U;
  $put($_.options, "dontdraw", true);
  $k[$j++] = "args";
  $k[$j++] = $_.msg;
  $k[$j++] = $_.options;
  bwipp_code39();
  var _b = $k[--$j];
  $_[$k[--$j]] = _b;
  $_.text = $s($_.msglen + 5);
  $puti($_.text, 0, "PZN - ");
  $puti($_.text, 6, $geti($_.msg, 1, $_.msglen - 1));
  var _r = $a([$a([$_.text, $_.textxoffset, $_.textyoffset, $_.textfont, $_.textsize])]);
  $put($_.args, "txt", _r);
  $put($_.args, "textxalign", "center");
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_code93() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includecheck = false;
  $_.includetext = false;
  $_.textfont = "OCR-B";
  $_.textsize = 10;
  $_.textyoffset = -8;
  $_.height = 1;
  $_.parse = false;
  $_.parsefnc = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $_.encs = $a(["131112", "111213", "111312", "111411", "121113", "121212", "121311", "111114", "131211", "141111", "211113", "211212", "211311", "221112", "221211", "231111", "112113", "112212", "112311", "122112", "132111", "111123", "111222", "111321", "121122", "131121", "212112", "212211", "211122", "211221", "221121", "222111", "112122", "112221", "122121", "123111", "121131", "311112", "311211", "321111", "112131", "113121", "211131", "121221", "312111", "311121", "122211", "111141", "1111411"]);
  $_.barchars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
  $_.charvals = /* @__PURE__ */ new Map();
  for (var _3 = 0; _3 <= 42; _3 += 1) {
    $put($_.charvals, $get($_.barchars, _3), _3);
  }
  $_.sft1 = -1;
  $_.sft2 = -2;
  $_.sft3 = -3;
  $_.sft4 = -4;
  $put($_.charvals, $_.sft1, 43);
  $put($_.charvals, $_.sft2, 44);
  $put($_.charvals, $_.sft3, 45);
  $put($_.charvals, $_.sft4, 46);
  var _M = /* @__PURE__ */ new Map([
    ["parse", $_.parse],
    ["parsefnc", $_.parsefnc],
    ["SFT$", $_.sft1],
    ["SFT%", $_.sft2],
    ["SFT/", $_.sft3],
    ["SFT+", $_.sft4]
  ]);
  $_.fncvals = _M;
  $k[$j++] = "msg";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.fncvals;
  bwipp_parseinput();
  var _P = $k[--$j];
  $_[$k[--$j]] = _P;
  $_.msglen = $_.msg.length;
  $forall($_.msg, function() {
    var _V = $get($_.charvals, $k[--$j]) !== void 0;
    if (!_V) {
      $k[$j++] = "bwipp.code93BadCharacter#8405";
      $k[$j++] = "Code 93 must only contain digits, capital letters, spaces, the symbols -.$/+ and shift non-data characters";
      bwipp_raiseerror();
    }
  });
  if ($_.includecheck) {
    $_.sbs = $s($_.msglen * 6 + 25);
  } else {
    $_.sbs = $s($_.msglen * 6 + 13);
  }
  $_.txt = $a($_.msglen);
  $puti($_.sbs, 0, $get($_.encs, 47));
  $_.checksum1 = 0;
  $_.checksum2 = 0;
  for (var _i = 0, _h = $_.msglen - 1; _i <= _h; _i += 1) {
    $_.i = _i;
    $_.indx = $get($_.charvals, $get($_.msg, $_.i));
    $puti($_.sbs, $_.i * 6 + 6, $get($_.encs, $_.indx));
    var _v = $get($_.msg, $_.i);
    $k[$j++] = "char";
    $k[$j++] = _v;
    if (_v < 0) {
      $k[$j - 1] = " ";
    } else {
      var _w = $s(1);
      $k[$j++] = _w;
      $k[$j++] = _w;
      $k[$j++] = 0;
      $r(4, -1);
      var _x = $k[--$j];
      var _y = $k[--$j];
      $put($k[--$j], _y, _x);
    }
    var _10 = $k[--$j];
    $_[$k[--$j]] = _10;
    $put($_.txt, $_.i, $a([$_.char, $_.i * 9 + 9, $_.textyoffset, $_.textfont, $_.textsize]));
    $_.checksum1 = $f($_.checksum1 + (($_.msglen - $_.i - 1) % 20 + 1) * $_.indx);
    $_.checksum2 = $f($_.checksum2 + (($_.msglen - $_.i) % 15 + 1) * $_.indx);
  }
  if ($_.includecheck) {
    $_.checksum1 = $_.checksum1 % 47;
    $_.checksum2 = $f($_.checksum2 + $_.checksum1) % 47;
    $puti($_.sbs, $_.msglen * 6 + 6, $get($_.encs, $_.checksum1));
    $puti($_.sbs, $_.msglen * 6 + 12, $get($_.encs, $_.checksum2));
    $puti($_.sbs, $_.msglen * 6 + 18, $get($_.encs, 48));
  } else {
    $puti($_.sbs, $_.msglen * 6 + 6, $get($_.encs, 48));
  }
  $k[$j++] = Infinity;
  $k[$j++] = Infinity;
  var _1e = $_.sbs;
  for (var _1f = 0, _1g = _1e.length; _1f < _1g; _1f++) {
    $k[$j++] = $get(_1e, _1f) - 48;
  }
  var _1i = $a();
  $k[$j++] = Infinity;
  for (var _1k = 0, _1l = ~~(($_.sbs.length + 1) / 2); _1k < _1l; _1k++) {
    $k[$j++] = $_.height;
  }
  var _1n = $a();
  $k[$j++] = Infinity;
  for (var _1p = 0, _1q = ~~(($_.sbs.length + 1) / 2); _1p < _1q; _1p++) {
    $k[$j++] = 0;
  }
  var _1r = $a();
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "sbs";
  $k[$j++] = _1i;
  $k[$j++] = "bhs";
  $k[$j++] = _1n;
  $k[$j++] = "bbs";
  $k[$j++] = _1r;
  if ($_.includetext) {
    $k[$j++] = "txt";
    $k[$j++] = $_.txt;
  }
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  var _1v = $d();
  $k[$j++] = _1v;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_code93ext() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.parse = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  var _3 = /* @__PURE__ */ new Map([
    ["parse", $_.parse],
    ["parseonly", true],
    ["parsefnc", false]
  ]);
  $_.fncvals = _3;
  $k[$j++] = "barcode";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.fncvals;
  bwipp_parseinput();
  var _6 = $k[--$j];
  $_[$k[--$j]] = _6;
  $_.barlen = $_.barcode.length;
  delete $_.options["parse"];
  $_.extencs = $a(["^SFT%U", "^SFT$A", "^SFT$B", "^SFT$C", "^SFT$D", "^SFT$E", "^SFT$F", "^SFT$G", "^SFT$H", "^SFT$I", "^SFT$J", "^SFT$K", "^SFT$L", "^SFT$M", "^SFT$N", "^SFT$O", "^SFT$P", "^SFT$Q", "^SFT$R", "^SFT$S", "^SFT$T", "^SFT$U", "^SFT$V", "^SFT$W", "^SFT$X", "^SFT$Y", "^SFT$Z", "^SFT%A", "^SFT%B", "^SFT%C", "^SFT%D", "^SFT%E", " ", "^SFT/A", "^SFT/B", "^SFT/C", "$", "%", "^SFT/F", "^SFT/G", "^SFT/H", "^SFT/I", "^SFT/J", "+", "^SFT/L", "-", ".", "/", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "^SFT/Z", "^SFT%F", "^SFT%G", "^SFT%H", "^SFT%I", "^SFT%J", "^SFT%V", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "^SFT%K", "^SFT%L", "^SFT%M", "^SFT%N", "^SFT%O", "^SFT%W", "^SFT+A", "^SFT+B", "^SFT+C", "^SFT+D", "^SFT+E", "^SFT+F", "^SFT+G", "^SFT+H", "^SFT+I", "^SFT+J", "^SFT+K", "^SFT+L", "^SFT+M", "^SFT+N", "^SFT+O", "^SFT+P", "^SFT+Q", "^SFT+R", "^SFT+S", "^SFT+T", "^SFT+U", "^SFT+V", "^SFT+W", "^SFT+X", "^SFT+Y", "^SFT+Z", "^SFT%P", "^SFT%Q", "^SFT%R", "^SFT%S", "^SFT%T"]);
  $_.newcode = $s($_.barlen * 6);
  $_.newtext = $s($_.barlen * 6);
  $_.j = 0;
  $_.k = 0;
  for (var _I = 0, _H = $_.barlen - 1; _I <= _H; _I += 1) {
    $_.i = _I;
    var _L = $get($_.barcode, $_.i);
    $k[$j++] = _L;
    if (_L > 127) {
      $j--;
      $k[$j++] = "bwipp.code93extbadCharacter#8542";
      $k[$j++] = "Code 93 Extended only support ASCII characters with values 0 to 127";
      bwipp_raiseerror();
    }
    $_.extchar = $get($_.extencs, $k[--$j]);
    $_.extlen = $_.extchar.length;
    $puti($_.newcode, $_.j, $_.extchar);
    var _X = $get($_.barcode, $_.i);
    $k[$j++] = $_.newtext;
    $k[$j++] = $_.k;
    $k[$j++] = _X;
    if (_X < 32 || _X == 127) {
      $k[$j - 1] = 32;
    }
    var _Y = $k[--$j];
    var _Z = $k[--$j];
    $put($k[--$j], _Z, _Y);
    if ($_.extlen != 1) {
      $put($_.newtext, $_.k + 1, 32);
    }
    $_.j = $_.j + $_.extlen;
    var _i = $_.extlen == 1 ? 1 : 2;
    $_.k = $_.k + _i;
  }
  $_.newcode = $geti($_.newcode, 0, $_.j);
  $_.newtext = $geti($_.newtext, 0, $_.k);
  $put($_.options, "dontdraw", true);
  $put($_.options, "parsefnc", true);
  $k[$j++] = "args";
  $k[$j++] = $_.newcode;
  $k[$j++] = $_.options;
  bwipp_code93();
  var _t = $k[--$j];
  $_[$k[--$j]] = _t;
  if ($_.includetext) {
    $_.txt = $get($_.args, "txt");
    for (var _10 = 0, _z = $_.newtext.length - 1; _10 <= _z; _10 += 1) {
      $_.i = _10;
      $_.txtentry = $get($_.txt, $_.i);
      $put($_.txtentry, 0, $geti($_.newtext, $_.i, 1));
      $put($_.txt, $_.i, $_.txtentry);
    }
    $put($_.args, "txt", $_.txt);
  }
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_interleaved2of5() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includecheck = false;
  $_.includetext = false;
  $_.includecheckintext = false;
  $_.textfont = "OCR-B";
  $_.textsize = 10;
  $_.textyoffset = -8;
  $_.height = 1;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $forall($_.barcode, function() {
    var _3 = $k[--$j];
    if (_3 < 48 || _3 > 57) {
      $k[$j++] = "bwipp.interleaved2of5badCharacter#8628";
      $k[$j++] = "Interleaved 2 of 5 must contain only digits";
      bwipp_raiseerror();
    }
  });
  $_.barlen = $_.barcode.length;
  if ($_.barlen % 2 == 0 && $_.includecheck || $_.barlen % 2 != 0 && !$_.includecheck) {
    $_.pad = $s($_.barlen + 1);
    $put($_.pad, 0, 48);
    $puti($_.pad, 1, $_.barcode);
    $_.barcode = $_.pad;
    $_.barlen = $_.barlen + 1;
  }
  if ($_.includecheck) {
    $_.checksum = 0;
    for (var _J = 0, _I = $_.barlen - 1; _J <= _I; _J += 1) {
      $_.i = _J;
      if ($_.i % 2 == 0) {
        $_.checksum = $_.checksum + ($get($_.barcode, $_.i) - 48) * 3;
      } else {
        $_.checksum = $_.checksum + ($get($_.barcode, $_.i) - 48);
      }
    }
    $_.checksum = (10 - $_.checksum % 10) % 10;
    $_.pad = $s($_.barlen + 1);
    $puti($_.pad, 0, $_.barcode);
    $put($_.pad, $_.barlen, $_.checksum + 48);
    $_.barcode = $_.pad;
    $_.barlen = $_.barlen + 1;
  }
  $_.encs = $a(["11221", "21112", "12112", "22111", "11212", "21211", "12211", "11122", "21121", "12121", "1111", "2111"]);
  $_.barchars = "0123456789";
  $_.sbs = $s($_.barlen * 5 + 8);
  $_.txt = $a($_.barlen);
  $puti($_.sbs, 0, $get($_.encs, 10));
  for (var _o = 0, _n = $_.barlen - 1; _o <= _n; _o += 2) {
    $_.i = _o;
    $search($_.barchars, $geti($_.barcode, $_.i, 1));
    $j--;
    $_.indx = $k[--$j].length;
    $j -= 2;
    $_.enca = $get($_.encs, $_.indx);
    $search($_.barchars, $geti($_.barcode, $_.i + 1, 1));
    $j--;
    $_.indx = $k[--$j].length;
    $j -= 2;
    $_.encb = $get($_.encs, $_.indx);
    $_.intl = $s($_.enca.length * 2);
    for (var _19 = 0, _18 = $_.enca.length - 1; _19 <= _18; _19 += 1) {
      $_.j = _19;
      $_.achar = $get($_.enca, $_.j);
      $_.bchar = $get($_.encb, $_.j);
      $put($_.intl, $_.j * 2, $_.achar);
      $put($_.intl, $_.j * 2 + 1, $_.bchar);
    }
    $puti($_.sbs, $_.i * 5 + 4, $_.intl);
    $put($_.txt, $_.i, $a([$geti($_.barcode, $_.i, 1), $_.i * 9 + 4, $_.textyoffset, $_.textfont, $_.textsize]));
    if ($_.includecheck && !$_.includecheckintext && $_.barlen - 2 == $_.i) {
      $put($_.txt, $_.i + 1, $a([" ", ($_.i + 1) * 9 + 4, $_.textyoffset, $_.textfont, $_.textsize]));
    } else {
      $put($_.txt, $_.i + 1, $a([$geti($_.barcode, $_.i + 1, 1), ($_.i + 1) * 9 + 4, $_.textyoffset, $_.textfont, $_.textsize]));
    }
  }
  $puti($_.sbs, $_.barlen * 5 + 4, $get($_.encs, 11));
  $k[$j++] = Infinity;
  $k[$j++] = Infinity;
  var _1y = $_.sbs;
  for (var _1z = 0, _20 = _1y.length; _1z < _20; _1z++) {
    $k[$j++] = $get(_1y, _1z) - 48;
  }
  var _22 = $a();
  $k[$j++] = Infinity;
  for (var _24 = 0, _25 = ~~(($_.sbs.length + 1) / 2); _24 < _25; _24++) {
    $k[$j++] = $_.height;
  }
  var _27 = $a();
  $k[$j++] = Infinity;
  for (var _29 = 0, _2A = ~~(($_.sbs.length + 1) / 2); _29 < _2A; _29++) {
    $k[$j++] = 0;
  }
  var _2B = $a();
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "sbs";
  $k[$j++] = _22;
  $k[$j++] = "bhs";
  $k[$j++] = _27;
  $k[$j++] = "bbs";
  $k[$j++] = _2B;
  if ($_.includetext) {
    $k[$j++] = "txt";
    $k[$j++] = $_.txt;
  }
  $k[$j++] = "barratio";
  $k[$j++] = 2;
  $k[$j++] = "spaceratio";
  $k[$j++] = 2;
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  var _2F = $d();
  $k[$j++] = _2F;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_itf14() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.includecheckintext = true;
  $_.textfont = "OCR-B";
  $_.textsize = 10;
  $_.textxoffset = 0;
  $_.textyoffset = -3.5;
  $_.height = 0.5;
  $_.showborder = true;
  $_.borderwidth = 4;
  $_.borderleft = 10;
  $_.borderright = 10;
  $_.bordertop = -0.55;
  $_.borderbottom = -0.55;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $_.text = $_.barcode;
  var _3 = $_.barcode;
  $k[$j++] = $s(_3.length);
  $k[$j++] = 0;
  $forall(_3, function() {
    var _5 = $k[$j - 1];
    if (_5 != 32) {
      var _6 = $k[--$j];
      var _7 = $k[--$j];
      var _8 = $k[$j - 1];
      $put(_8, _7, _6);
      $k[$j++] = _7 + 1;
    } else {
      $j--;
    }
  });
  var _9 = $k[--$j];
  $_.barcode = $geti($k[--$j], 0, _9);
  $_.hasspace = $_.text.length != $_.barcode.length;
  if ($_.barcode.length != 13 && $_.barcode.length != 14) {
    $k[$j++] = "bwipp.itf14badLength#8796";
    $k[$j++] = "ITF-14 must be 13 or 14 digits";
    bwipp_raiseerror();
  }
  var _G = $_.barcode;
  for (var _H = 0, _I = _G.length; _H < _I; _H++) {
    var _J = $get(_G, _H);
    if (_J < 48 || _J > 57) {
      $k[$j++] = "bwipp.itf14badCharacter#8800";
      $k[$j++] = "ITF-14 must contain only digits";
      bwipp_raiseerror();
    }
  }
  $_.checksum = 0;
  for (var _K = 0; _K <= 12; _K += 1) {
    $_.i = _K;
    $k[$j++] = "checksum";
    $k[$j++] = $_.checksum;
    $k[$j++] = $get($_.barcode, $_.i) - 48;
    if ($_.i % 2 == 0) {
      var _Q = $k[--$j];
      $k[$j++] = _Q * 3;
    }
    var _R = $k[--$j];
    var _S = $k[--$j];
    $_[$k[--$j]] = $f(_S + _R);
  }
  $_.checksum = (10 - $_.checksum % 10) % 10;
  if ($_.barcode.length == 14) {
    if ($get($_.barcode, 13) != $_.checksum + 48) {
      $k[$j++] = "bwipp.itf14badCheckDigit#8813";
      $k[$j++] = "Incorrect ITF-14 check digit provided";
      bwipp_raiseerror();
    }
  } else {
    var _Z = $s(14);
    $puti(_Z, 0, $_.barcode);
    $put(_Z, 13, $_.checksum + 48);
    $_.barcode = _Z;
    var _e = $_.hasspace ? 2 : 1;
    var _f = $s($_.text.length + _e);
    $puti(_f, _f.length - 2, " ");
    $put(_f, _f.length - 1, $_.checksum + 48);
    $puti(_f, 0, $_.text);
    $_.text = _f;
  }
  var _i = $_.options;
  $put(_i, "dontdraw", true);
  $put($_.options, "showborder", $_.showborder);
  $put($_.options, "borderwidth", $_.borderwidth);
  $put($_.options, "borderleft", $_.borderleft);
  $put($_.options, "borderright", $_.borderright);
  var _r = $_.options;
  $put(_r, "bordertop", $_.bordertop);
  $put($_.options, "borderbottom", $_.borderbottom);
  $put($_.options, "height", $_.height);
  $put($_.options, "textyoffset", $_.textyoffset);
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_interleaved2of5();
  var _11 = $k[--$j];
  $_[$k[--$j]] = _11;
  $put($_.args, "txt", $a([$a([$_.text, $_.textxoffset, $_.textyoffset, $_.textfont, $_.textsize])]));
  $put($_.args, "textxalign", "center");
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_identcode() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.textfont = "OCR-B";
  $_.textsize = 10;
  $_.textxoffset = 0;
  $_.textyoffset = -8;
  $_.height = 1;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length != 11 && $_.barcode.length != 12) {
    $k[$j++] = "bwipp.identcodeBadLength#8891";
    $k[$j++] = "Deutsche Post Identcode must be 11 or 12 digits";
    bwipp_raiseerror();
  }
  $forall($_.barcode, function() {
    var _5 = $k[--$j];
    if (_5 < 48 || _5 > 57) {
      $k[$j++] = "bwipp.identcodeBadCharacter#8895";
      $k[$j++] = "Deutsche Post Identcode must contain only digits";
      bwipp_raiseerror();
    }
  });
  $_.checksum = 0;
  for (var _6 = 0; _6 <= 10; _6 += 1) {
    $_.i = _6;
    $k[$j++] = "checksum";
    $k[$j++] = $_.checksum;
    $k[$j++] = $get($_.barcode, $_.i) - 48;
    if ($_.i % 2 == 0) {
      var _C = $k[--$j];
      $k[$j++] = _C * 4;
    } else {
      var _D = $k[--$j];
      $k[$j++] = _D * 9;
    }
    var _E = $k[--$j];
    var _F = $k[--$j];
    $_[$k[--$j]] = $f(_F + _E);
  }
  $_.checksum = (10 - $_.checksum % 10) % 10;
  if ($_.barcode.length == 12) {
    if ($get($_.barcode, 11) != $_.checksum + 48) {
      $k[$j++] = "bwipp.identcodeBadCheckDigit#8908";
      $k[$j++] = "Incorrect Deutsche Post Identcode check digit provided";
      bwipp_raiseerror();
    }
  }
  var _M = $s(12);
  $puti(_M, 0, $_.barcode);
  $put(_M, 11, $_.checksum + 48);
  $_.barcode = _M;
  $_.text = $strcpy($s(16), "  .       .     ");
  $puti($_.text, 0, $geti($_.barcode, 0, 2));
  $puti($_.text, 3, $geti($_.barcode, 2, 3));
  $puti($_.text, 7, $geti($_.barcode, 5, 3));
  $puti($_.text, 11, $geti($_.barcode, 8, 3));
  $puti($_.text, 15, $geti($_.barcode, 11, 1));
  $put($_.options, "dontdraw", true);
  $put($_.options, "includecheck", false);
  var _i = $_.barcode;
  $k[$j++] = "args";
  $k[$j++] = _i;
  $k[$j++] = $_.options;
  bwipp_interleaved2of5();
  var _k = $k[--$j];
  $_[$k[--$j]] = _k;
  var _r = $_.textsize;
  $put($_.args, "txt", $a([$a([$_.text, $_.textxoffset, $_.textyoffset, $_.textfont, _r])]));
  $put($_.args, "textxalign", "center");
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_leitcode() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.textfont = "OCR-B";
  $_.textsize = 10;
  $_.textxoffset = 0;
  $_.textyoffset = -8;
  $_.height = 1;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length != 13 && $_.barcode.length != 14) {
    $k[$j++] = "bwipp.leitcodeBadLength#8981";
    $k[$j++] = "Deutsche Post Leitcode must be 13 or 14 digits";
    bwipp_raiseerror();
  }
  $forall($_.barcode, function() {
    var _5 = $k[--$j];
    if (_5 < 48 || _5 > 57) {
      $k[$j++] = "bwipp.leitcodeBadCharacter#8985";
      $k[$j++] = "Deutsche Post Leitcode must contain only digits";
      bwipp_raiseerror();
    }
  });
  $_.checksum = 0;
  for (var _6 = 0; _6 <= 12; _6 += 1) {
    $_.i = _6;
    $k[$j++] = "checksum";
    $k[$j++] = $_.checksum;
    $k[$j++] = $get($_.barcode, $_.i) - 48;
    if ($_.i % 2 == 0) {
      var _C = $k[--$j];
      $k[$j++] = _C * 4;
    } else {
      var _D = $k[--$j];
      $k[$j++] = _D * 9;
    }
    var _E = $k[--$j];
    var _F = $k[--$j];
    $_[$k[--$j]] = $f(_F + _E);
  }
  $_.checksum = (10 - $_.checksum % 10) % 10;
  if ($_.barcode.length == 14) {
    if ($get($_.barcode, 13) != $_.checksum + 48) {
      $k[$j++] = "bwipp.leitcodeBadCheckDigit#8998";
      $k[$j++] = "Incorrect Deutsche Post Leitcode check digit provided";
      bwipp_raiseerror();
    }
  }
  var _M = $s(14);
  $puti(_M, 0, $_.barcode);
  $put(_M, 13, $_.checksum + 48);
  $_.barcode = _M;
  $_.text = $strcpy($s(18), "     .   .   .    ");
  $puti($_.text, 0, $geti($_.barcode, 0, 5));
  $puti($_.text, 6, $geti($_.barcode, 5, 3));
  $puti($_.text, 10, $geti($_.barcode, 8, 3));
  $puti($_.text, 14, $geti($_.barcode, 11, 2));
  $puti($_.text, 17, $geti($_.barcode, 13, 1));
  $put($_.options, "dontdraw", true);
  $put($_.options, "includecheck", false);
  var _i = $_.barcode;
  $k[$j++] = "args";
  $k[$j++] = _i;
  $k[$j++] = $_.options;
  bwipp_interleaved2of5();
  var _k = $k[--$j];
  $_[$k[--$j]] = _k;
  var _r = $_.textsize;
  $put($_.args, "txt", $a([$a([$_.text, $_.textxoffset, $_.textyoffset, $_.textfont, _r])]));
  $put($_.args, "textxalign", "center");
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_databaromni() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.height = 33 / 72;
  $_.linkage = false;
  $_.format = "omni";
  $_.barxmult = 33;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length != 17 && $_.barcode.length != 18) {
    $k[$j++] = "bwipp.databaromniBadLength#9070";
    $k[$j++] = "GS1 DataBar Omnidirectional must be 13 or 14 digits";
    bwipp_raiseerror();
  }
  if ($ne($geti($_.barcode, 0, 4), "(01)")) {
    $k[$j++] = "bwipp.databaromniBadAI#9073";
    $k[$j++] = "GS1 DataBar Omnidirectional must begin with (01) application identifier";
    bwipp_raiseerror();
  }
  var _8 = $geti($_.barcode, 4, $_.barcode.length - 4);
  for (var _9 = 0, _A = _8.length; _9 < _A; _9++) {
    var _B = $get(_8, _9);
    if (_B < 48 || _B > 57) {
      $k[$j++] = "bwipp.databaromniBadCharacter#9077";
      $k[$j++] = "GS1 DataBar Omnidirectional must contain only digits";
      bwipp_raiseerror();
    }
  }
  if ($_.barxmult < 33) {
    $k[$j++] = "bwipp.databarStackedOmniBarXmult#9082";
    $k[$j++] = "GS1 DataBar Stacked Omnidirectional must have a barxmult of at least 33";
    bwipp_raiseerror();
  }
  if ($ne($_.format, "omni") && $ne($_.format, "stacked") && $ne($_.format, "stackedomni") && $ne($_.format, "truncated")) {
    $k[$j++] = "bwipp.databaromniBadFormat#9086";
    $k[$j++] = "Valid formats are omni, stacked, stackedomni and truncated";
    bwipp_raiseerror();
  }
  if ($eq($_.format, "truncated")) {
    $_.height = 13 / 72;
  }
  $_.checksum = 0;
  for (var _I = 0; _I <= 12; _I += 1) {
    $_.i = _I;
    $k[$j++] = "checksum";
    $k[$j++] = $_.checksum;
    $k[$j++] = $get($_.barcode, $_.i + 4) - 48;
    if ($_.i % 2 == 0) {
      var _O = $k[--$j];
      $k[$j++] = _O * 3;
    }
    var _P = $k[--$j];
    var _Q = $k[--$j];
    $_[$k[--$j]] = $f(_Q + _P);
  }
  $_.checksum = (10 - $_.checksum % 10) % 10;
  if ($_.barcode.length == 18) {
    if ($get($_.barcode, 17) != $_.checksum + 48) {
      $k[$j++] = "bwipp.databaromniBadCheckDigit#9102";
      $k[$j++] = "Incorrect GS1 DataBar Omnidirectional check digit provided";
      bwipp_raiseerror();
    }
  }
  var _X = $s(18);
  $puti(_X, 0, $_.barcode);
  $put(_X, 17, $_.checksum + 48);
  $_.barcode = _X;
  $_.txt = $a($_.barcode.length);
  for (var _e = 0, _d = $_.barcode.length - 1; _e <= _d; _e += 1) {
    $_.i = _e;
    $put($_.txt, $_.i, $a([$geti($_.barcode, $_.i, 1), 0, 0, "", 0]));
  }
  $_.ncr = function() {
    var _l = $k[--$j];
    var _m = $k[--$j];
    var _n = $f(_m - _l);
    if (_l < $f(_m - _l)) {
      var _ = _n;
      _n = _l;
      _l = _;
    }
    $k[$j++] = _n;
    $k[$j++] = 1;
    $k[$j++] = 1;
    for (var _p = _m, _o = _l + 1; _p >= _o; _p -= 1) {
      var _q = $k[--$j];
      var _r = $k[$j - 1];
      var _s = $k[$j - 2];
      $k[$j++] = _q * _p;
      if ($le(_r, _s)) {
        var _t = $k[--$j];
        var _u = $k[--$j];
        $k[$j++] = _u + 1;
        $k[$j++] = ~~(_t / _u);
      }
    }
    for (; ; ) {
      var _w = $k[$j - 2];
      var _x = $k[$j - 3];
      if ($gt(_w, _x)) {
        break;
      }
      var _y = $k[--$j];
      var _z = $k[--$j];
      $k[$j++] = _z + 1;
      $k[$j++] = ~~(_y / _z);
    }
    var _10 = $k[--$j];
    $k[$j - 1] = _10;
    var _12 = $k[--$j];
    $k[$j - 1] = _12;
  };
  $_.getRSSwidths = function() {
    $_.oe = $k[--$j];
    $_.el = $k[--$j];
    $_.mw = $k[--$j];
    $_.nm = $k[--$j];
    $_.val = $k[--$j];
    $_.out = $a($_.el);
    $_.mask = 0;
    for (var _1D = 0, _1C = $_.el - 2; _1D <= _1C; _1D += 1) {
      $_.bar = _1D;
      $_.ew = 1;
      var _1F = $_.bar;
      $_.mask = $_.mask | (_1F < 0 ? 1 >>> -_1F : 1 << _1F);
      for (; ; ) {
        $k[$j++] = "sval";
        $k[$j++] = $f($_.nm - $_.ew) - 1;
        $k[$j++] = $f($_.el - $_.bar) - 2;
        $_.ncr();
        var _1K = $k[--$j];
        $_[$k[--$j]] = _1K;
        if ($_.oe && $_.mask == 0 && $f($_.nm - $_.ew - $_.el * 2 + $_.bar * 2) >= -2) {
          $k[$j++] = "sval";
          $k[$j++] = $_.sval;
          $k[$j++] = $f($_.nm - $_.ew - $_.el + $_.bar);
          $k[$j++] = $f($_.el - $_.bar) - 2;
          $_.ncr();
          var _1Z = $k[--$j];
          var _1a = $k[--$j];
          $_[$k[--$j]] = $f(_1a - _1Z);
        }
        if ($f($_.el - $_.bar) > 2) {
          $_.lval = 0;
          for (var _1k = $f($_.nm - $_.ew - $_.el + $_.bar) + 2, _1j = $_.mw + 1; _1k >= _1j; _1k -= 1) {
            $k[$j++] = $f($_.nm - _1k - $_.ew) - 1;
            $k[$j++] = $f($_.el - $_.bar) - 3;
            $_.ncr();
            $_.lval = $f($k[--$j] + $_.lval);
          }
          $_.sval = $f($_.sval - $_.lval * ($_.el - $_.bar - 1));
        } else {
          if ($f($_.nm - $_.ew) > $_.mw) {
            $_.sval = $_.sval - 1;
          }
        }
        $_.val = $f($_.val - $_.sval);
        if ($_.val < 0) {
          break;
        }
        $_.ew = $_.ew + 1;
        var _24 = $_.bar;
        $_.mask = $_.mask & ~(_24 < 0 ? 1 >>> -_24 : 1 << _24);
      }
      $_.val = $f($_.val + $_.sval);
      $_.nm = $f($_.nm - $_.ew);
      $put($_.out, $_.bar, $_.ew);
    }
    $put($_.out, $_.el - 1, $_.nm);
    $k[$j++] = $_.out;
  };
  $k[$j++] = Infinity;
  var _2H = $_.linkage ? 1 : 0;
  var _2J = $geti($_.barcode, 4, 13);
  $k[$j++] = _2H;
  for (var _2K = 0, _2L = _2J.length; _2K < _2L; _2K++) {
    $k[$j++] = $get(_2J, _2K) - 48;
  }
  $_.binval = $a();
  for (var _2O = 0; _2O <= 12; _2O += 1) {
    $_.i = _2O;
    var _2P = $_.binval;
    var _2Q = $_.i;
    $put(_2P, _2Q + 1, $f($get(_2P, _2Q + 1) + $get($_.binval, $_.i) % 4537077 * 10));
    $put($_.binval, $_.i, ~~($get($_.binval, $_.i) / 4537077));
  }
  $_.right = $get($_.binval, 13) % 4537077;
  var _2c = $_.binval;
  $put(_2c, 13, ~~($get(_2c, 13) / 4537077));
  $_.left = 0;
  $_.i = true;
  for (var _2e = 0; _2e <= 13; _2e += 1) {
    $_.j = _2e;
    var _2h = $get($_.binval, $_.j);
    $k[$j++] = _2h;
    if (_2h == 0 && $_.i) {
      $j--;
    } else {
      $_.i = false;
      $k[$j++] = "left";
      $k[$j++] = $_.left;
      var _2l = $k[$j - 3];
      var _2m = $k[$j - 1];
      $_[$k[$j - 2]] = $f(_2m + _2l * ~~$pow(10, 13 - $_.j));
      $j -= 3;
    }
  }
  $_.d1 = ~~($_.left / 1597);
  $_.d2 = $_.left % 1597;
  $_.d3 = ~~($_.right / 1597);
  $_.d4 = $_.right % 1597;
  $_.tab164 = $a([160, 0, 12, 4, 8, 1, 161, 1, 960, 161, 10, 6, 6, 3, 80, 10, 2014, 961, 8, 8, 4, 5, 31, 34, 2714, 2015, 6, 10, 3, 6, 10, 70, 2840, 2715, 4, 12, 1, 8, 1, 126]);
  $_.tab154 = $a([335, 0, 5, 10, 2, 7, 4, 84, 1035, 336, 7, 8, 4, 5, 20, 35, 1515, 1036, 9, 6, 6, 3, 48, 10, 1596, 1516, 11, 4, 8, 1, 81, 1]);
  $_.i = 0;
  for (; ; ) {
    if ($_.d1 <= $get($_.tab164, $_.i)) {
      $aload($geti($_.tab164, $_.i + 1, 7));
      $_.d1te = $k[--$j];
      $_.d1to = $k[--$j];
      $_.d1mwe = $k[--$j];
      $_.d1mwo = $k[--$j];
      $_.d1ele = $k[--$j];
      $_.d1elo = $k[--$j];
      $_.d1gs = $k[--$j];
      break;
    }
    $_.i = $_.i + 8;
  }
  $_.i = 0;
  for (; ; ) {
    if ($_.d2 <= $get($_.tab154, $_.i)) {
      $aload($geti($_.tab154, $_.i + 1, 7));
      $_.d2te = $k[--$j];
      $_.d2to = $k[--$j];
      $_.d2mwe = $k[--$j];
      $_.d2mwo = $k[--$j];
      $_.d2ele = $k[--$j];
      $_.d2elo = $k[--$j];
      $_.d2gs = $k[--$j];
      break;
    }
    $_.i = $_.i + 8;
  }
  $_.i = 0;
  for (; ; ) {
    if ($_.d3 <= $get($_.tab164, $_.i)) {
      $aload($geti($_.tab164, $_.i + 1, 7));
      $_.d3te = $k[--$j];
      $_.d3to = $k[--$j];
      $_.d3mwe = $k[--$j];
      $_.d3mwo = $k[--$j];
      $_.d3ele = $k[--$j];
      $_.d3elo = $k[--$j];
      $_.d3gs = $k[--$j];
      break;
    }
    $_.i = $_.i + 8;
  }
  $_.i = 0;
  for (; ; ) {
    if ($_.d4 <= $get($_.tab154, $_.i)) {
      $aload($geti($_.tab154, $_.i + 1, 7));
      $_.d4te = $k[--$j];
      $_.d4to = $k[--$j];
      $_.d4mwe = $k[--$j];
      $_.d4mwo = $k[--$j];
      $_.d4ele = $k[--$j];
      $_.d4elo = $k[--$j];
      $_.d4gs = $k[--$j];
      break;
    }
    $_.i = $_.i + 8;
  }
  $k[$j++] = "d1wo";
  $k[$j++] = ~~($f($_.d1 - $_.d1gs) / $_.d1te);
  $k[$j++] = $_.d1elo;
  $k[$j++] = $_.d1mwo;
  $k[$j++] = 4;
  $k[$j++] = false;
  $_.getRSSwidths();
  var _3y = $k[--$j];
  $_[$k[--$j]] = _3y;
  $k[$j++] = "d1we";
  $k[$j++] = $f($_.d1 - $_.d1gs) % $_.d1te;
  $k[$j++] = $_.d1ele;
  $k[$j++] = $_.d1mwe;
  $k[$j++] = 4;
  $k[$j++] = true;
  $_.getRSSwidths();
  var _45 = $k[--$j];
  $_[$k[--$j]] = _45;
  $k[$j++] = "d2wo";
  $k[$j++] = $f($_.d2 - $_.d2gs) % $_.d2to;
  $k[$j++] = $_.d2elo;
  $k[$j++] = $_.d2mwo;
  $k[$j++] = 4;
  $k[$j++] = true;
  $_.getRSSwidths();
  var _4C = $k[--$j];
  $_[$k[--$j]] = _4C;
  $k[$j++] = "d2we";
  $k[$j++] = ~~($f($_.d2 - $_.d2gs) / $_.d2to);
  $k[$j++] = $_.d2ele;
  $k[$j++] = $_.d2mwe;
  $k[$j++] = 4;
  $k[$j++] = false;
  $_.getRSSwidths();
  var _4J = $k[--$j];
  $_[$k[--$j]] = _4J;
  $k[$j++] = "d3wo";
  $k[$j++] = ~~($f($_.d3 - $_.d3gs) / $_.d3te);
  $k[$j++] = $_.d3elo;
  $k[$j++] = $_.d3mwo;
  $k[$j++] = 4;
  $k[$j++] = false;
  $_.getRSSwidths();
  var _4Q = $k[--$j];
  $_[$k[--$j]] = _4Q;
  $k[$j++] = "d3we";
  $k[$j++] = $f($_.d3 - $_.d3gs) % $_.d3te;
  $k[$j++] = $_.d3ele;
  $k[$j++] = $_.d3mwe;
  $k[$j++] = 4;
  $k[$j++] = true;
  $_.getRSSwidths();
  var _4X = $k[--$j];
  $_[$k[--$j]] = _4X;
  $k[$j++] = "d4wo";
  $k[$j++] = $f($_.d4 - $_.d4gs) % $_.d4to;
  $k[$j++] = $_.d4elo;
  $k[$j++] = $_.d4mwo;
  $k[$j++] = 4;
  $k[$j++] = true;
  $_.getRSSwidths();
  var _4e = $k[--$j];
  $_[$k[--$j]] = _4e;
  $k[$j++] = "d4we";
  $k[$j++] = ~~($f($_.d4 - $_.d4gs) / $_.d4to);
  $k[$j++] = $_.d4ele;
  $k[$j++] = $_.d4mwe;
  $k[$j++] = 4;
  $k[$j++] = false;
  $_.getRSSwidths();
  var _4l = $k[--$j];
  $_[$k[--$j]] = _4l;
  $_.d1w = $a(8);
  for (var _4o = 0; _4o <= 3; _4o += 1) {
    $_.i = _4o;
    $put($_.d1w, $_.i * 2, $get($_.d1wo, $_.i));
    $put($_.d1w, $_.i * 2 + 1, $get($_.d1we, $_.i));
  }
  $_.d2w = $a(8);
  for (var _50 = 0; _50 <= 3; _50 += 1) {
    $_.i = _50;
    $put($_.d2w, 7 - $_.i * 2, $get($_.d2wo, $_.i));
    $put($_.d2w, 6 - $_.i * 2, $get($_.d2we, $_.i));
  }
  $_.d3w = $a(8);
  for (var _5C = 0; _5C <= 3; _5C += 1) {
    $_.i = _5C;
    $put($_.d3w, 7 - $_.i * 2, $get($_.d3wo, $_.i));
    $put($_.d3w, 6 - $_.i * 2, $get($_.d3we, $_.i));
  }
  $_.d4w = $a(8);
  for (var _5O = 0; _5O <= 3; _5O += 1) {
    $_.i = _5O;
    $put($_.d4w, $_.i * 2, $get($_.d4wo, $_.i));
    $put($_.d4w, $_.i * 2 + 1, $get($_.d4we, $_.i));
  }
  $k[$j++] = Infinity;
  $aload($_.d1w);
  $aload($_.d2w);
  $aload($_.d3w);
  $aload($_.d4w);
  $_.widths = $a();
  $_.checkweights = $a([1, 3, 9, 27, 2, 6, 18, 54, 58, 72, 24, 8, 29, 36, 12, 4, 74, 51, 17, 32, 37, 65, 48, 16, 64, 34, 23, 69, 49, 68, 46, 59]);
  $_.checkwidths = $a([3, 8, 2, 1, 1, 3, 5, 5, 1, 1, 3, 3, 7, 1, 1, 3, 1, 9, 1, 1, 2, 7, 4, 1, 1, 2, 5, 6, 1, 1, 2, 3, 8, 1, 1, 1, 5, 7, 1, 1, 1, 3, 9, 1, 1]);
  $_.checksum = 0;
  for (var _5h = 0; _5h <= 31; _5h += 1) {
    $_.i = _5h;
    $_.checksum = $f($_.checksum + $get($_.widths, $_.i) * $get($_.checkweights, $_.i));
  }
  $_.checksum = $_.checksum % 79;
  if ($_.checksum >= 8) {
    $_.checksum = $_.checksum + 1;
  }
  if ($_.checksum >= 72) {
    $_.checksum = $_.checksum + 1;
  }
  $_.checklt = $geti($_.checkwidths, ~~($_.checksum / 9) * 5, 5);
  $_.checkrtrev = $geti($_.checkwidths, $_.checksum % 9 * 5, 5);
  $_.checkrt = $a(5);
  for (var _61 = 0; _61 <= 4; _61 += 1) {
    $_.i = _61;
    $put($_.checkrt, $_.i, $get($_.checkrtrev, 4 - $_.i));
  }
  if ($eq($_.format, "omni") || $eq($_.format, "truncated")) {
    $k[$j++] = Infinity;
    $k[$j++] = 1;
    $aload($_.d1w);
    $aload($_.checklt);
    $aload($_.d2w);
    $aload($_.d4w);
    $aload($_.checkrt);
    $aload($_.d3w);
    $k[$j++] = 1;
    $k[$j++] = 1;
    $_.sbs = $a();
    $k[$j++] = Infinity;
    var _6G = $_.sbs;
    $k[$j++] = Infinity;
    for (var _6I = 0, _6J = ~~(($_.sbs.length + 1) / 2); _6I < _6J; _6I++) {
      $k[$j++] = $_.height;
    }
    var _6L = $a();
    $k[$j++] = Infinity;
    for (var _6N = 0, _6O = ~~(($_.sbs.length + 1) / 2); _6N < _6O; _6N++) {
      $k[$j++] = 0;
    }
    var _6P = $a();
    $k[$j++] = "ren";
    $k[$j++] = "renlinear";
    $k[$j++] = "sbs";
    $k[$j++] = _6G;
    $k[$j++] = "bhs";
    $k[$j++] = _6L;
    $k[$j++] = "bbs";
    $k[$j++] = _6P;
    $k[$j++] = "txt";
    $k[$j++] = $_.txt;
    $k[$j++] = "textxalign";
    $k[$j++] = "center";
    $k[$j++] = "borderleft";
    $k[$j++] = 0;
    $k[$j++] = "borderright";
    $k[$j++] = 0;
    $k[$j++] = "opt";
    $k[$j++] = $_.options;
    var _6S = $d();
    $k[$j++] = _6S;
    if (!$_.dontdraw) {
      bwipp_renlinear();
    }
  } else {
    $k[$j++] = Infinity;
    $k[$j++] = 1;
    $k[$j++] = 1;
    $aload($_.d1w);
    $aload($_.checklt);
    $aload($_.d2w);
    $k[$j++] = 1;
    $k[$j++] = 1;
    $k[$j++] = 0;
    $_.top = $a();
    $k[$j++] = Infinity;
    $k[$j++] = 1;
    $k[$j++] = 1;
    $aload($_.d4w);
    $aload($_.checkrt);
    $aload($_.d3w);
    $k[$j++] = 1;
    $k[$j++] = 1;
    $k[$j++] = 0;
    $_.bot = $a();
    for (var _6c = 0; _6c <= 24; _6c += 2) {
      $_.i = _6c;
      for (var _6g = 0, _6h = $get($_.top, $_.i); _6g < _6h; _6g++) {
        $k[$j++] = 0;
      }
      for (var _6l = 0, _6m = $get($_.top, $_.i + 1); _6l < _6m; _6l++) {
        $k[$j++] = 1;
      }
    }
    $astore($a(50));
    $_.top = $k[--$j];
    for (var _6p = 0; _6p <= 24; _6p += 2) {
      $_.i = _6p;
      for (var _6t = 0, _6u = $get($_.bot, $_.i); _6t < _6u; _6t++) {
        $k[$j++] = 1;
      }
      for (var _6y = 0, _6z = $get($_.bot, $_.i + 1); _6y < _6z; _6y++) {
        $k[$j++] = 0;
      }
    }
    $astore($a(50));
    $_.bot = $k[--$j];
    if ($eq($_.format, "stacked")) {
      $_.sep = $a(50);
      $put($_.sep, 0, 0);
      for (var _75 = 1; _75 <= 49; _75 += 1) {
        $_.i = _75;
        if ($eq($get($_.top, $_.i), $get($_.bot, $_.i))) {
          $put($_.sep, $_.i, 1 - $get($_.top, $_.i));
        } else {
          $put($_.sep, $_.i, 1 - $get($_.sep, $_.i - 1));
        }
      }
      $puti($_.sep, 0, $a([0, 0, 0, 0]));
      $puti($_.sep, 46, $a([0, 0, 0, 0]));
      $k[$j++] = Infinity;
      for (var _7Q = 0; _7Q < 5; _7Q++) {
        $aload($_.top);
      }
      $aload($_.sep);
      for (var _7T = 0; _7T < 7; _7T++) {
        $aload($_.bot);
      }
      $_.pixs = $a();
      $_.pixy = ~~($_.pixs.length / 50);
    }
    if ($eq($_.format, "stackedomni")) {
      $k[$j++] = Infinity;
      $forall($_.top, function() {
        var _7Z = $k[--$j];
        $k[$j++] = 1 - _7Z;
      });
      $_.sep1 = $a();
      $puti($_.sep1, 0, $a([0, 0, 0, 0]));
      $puti($_.sep1, 46, $a([0, 0, 0, 0]));
      for (var _7f = 18; _7f <= 30; _7f += 1) {
        $_.i = _7f;
        if ($get($_.top, $_.i) == 0) {
          if ($get($_.top, $_.i - 1) == 1) {
            $k[$j++] = 1;
          } else {
            var _7p = $get($_.sep1, $_.i - 1) == 0 ? 1 : 0;
            $k[$j++] = _7p;
          }
        } else {
          $k[$j++] = 0;
        }
        $put($_.sep1, $_.i, $k[--$j]);
      }
      $k[$j++] = Infinity;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      for (var _7t = 0; _7t < 21; _7t++) {
        $k[$j++] = 0;
        $k[$j++] = 1;
      }
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $_.sep2 = $a();
      $k[$j++] = Infinity;
      $forall($_.bot, function() {
        var _7w = $k[--$j];
        $k[$j++] = 1 - _7w;
      });
      $_.sep3 = $a();
      $puti($_.sep3, 0, $a([0, 0, 0, 0]));
      $puti($_.sep3, 46, $a([0, 0, 0, 0]));
      for (var _82 = 19; _82 <= 31; _82 += 1) {
        $_.i = _82;
        if ($get($_.bot, $_.i) == 0) {
          if ($get($_.bot, $_.i - 1) == 1) {
            $k[$j++] = 1;
          } else {
            var _8C = $get($_.sep3, $_.i - 1) == 0 ? 1 : 0;
            $k[$j++] = _8C;
          }
        } else {
          $k[$j++] = 0;
        }
        $put($_.sep3, $_.i, $k[--$j]);
      }
      $_.f3 = $a([1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1]);
      $k[$j++] = true;
      for (var _8H = 0; _8H <= 12; _8H += 1) {
        var _8M = $k[--$j];
        $k[$j++] = _8M && $eq($get($_.bot, _8H + 19), $get($_.f3, _8H));
      }
      if ($k[--$j]) {
        $puti($_.sep3, 19, $a([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]));
      }
      $k[$j++] = Infinity;
      for (var _8R = 0, _8S = $_.barxmult; _8R < _8S; _8R++) {
        $aload($_.top);
      }
      $aload($_.sep1);
      $aload($_.sep2);
      $aload($_.sep3);
      for (var _8Y = 0, _8Z = $_.barxmult; _8Y < _8Z; _8Y++) {
        $aload($_.bot);
      }
      $_.pixs = $a();
      $_.pixy = ~~($_.pixs.length / 50);
    }
    var _8h = /* @__PURE__ */ new Map([
      ["ren", "renmatrix"],
      ["pixs", $_.pixs],
      ["pixx", 50],
      ["pixy", $_.pixy],
      ["height", $_.pixy / 72],
      ["width", 50 / 72],
      ["borderleft", 0],
      ["borderright", 0],
      ["bordertop", 0],
      ["borderbottom", 0],
      ["opt", $_.options]
    ]);
    $k[$j++] = _8h;
    if (!$_.dontdraw) {
      bwipp_renmatrix();
    }
  }
  $_ = $__;
}
function bwipp_databarstacked() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length != 17 && $_.barcode.length != 18) {
    $k[$j++] = "bwipp.databarstackedBadLength#9532";
    $k[$j++] = "GS1 DataBar Stacked must be 13 or 14 digits";
    bwipp_raiseerror();
  }
  if ($ne($geti($_.barcode, 0, 4), "(01)")) {
    $k[$j++] = "bwipp.databarstackedBadAI#9535";
    $k[$j++] = "GS1 DataBar Stacked must begin with (01) application identifier";
    bwipp_raiseerror();
  }
  var _8 = $geti($_.barcode, 4, $_.barcode.length - 4);
  for (var _9 = 0, _A = _8.length; _9 < _A; _9++) {
    var _B = $get(_8, _9);
    if (_B < 48 || _B > 57) {
      $k[$j++] = "bwipp.databarstackedBadCharacter#9539";
      $k[$j++] = "GS1 DataBar Stacked must contain only digits";
      bwipp_raiseerror();
    }
  }
  $_.checksum = 0;
  for (var _C = 0; _C <= 12; _C += 1) {
    $_.i = _C;
    $k[$j++] = "checksum";
    $k[$j++] = $_.checksum;
    $k[$j++] = $get($_.barcode, $_.i + 4) - 48;
    if ($_.i % 2 == 0) {
      var _I = $k[--$j];
      $k[$j++] = _I * 3;
    }
    var _J = $k[--$j];
    var _K = $k[--$j];
    $_[$k[--$j]] = $f(_K + _J);
  }
  $_.checksum = (10 - $_.checksum % 10) % 10;
  if ($_.barcode.length == 18) {
    if ($get($_.barcode, 17) != $_.checksum + 48) {
      $k[$j++] = "bwipp.databarstackedBadCheckDigit#9552";
      $k[$j++] = "Incorrect GS1 DataBar Stacked check digit provided";
      bwipp_raiseerror();
    }
  }
  var _R = $s(18);
  $puti(_R, 0, $_.barcode);
  $put(_R, 17, $_.checksum + 48);
  $_.barcode = _R;
  $put($_.options, "dontdraw", true);
  $put($_.options, "format", "stacked");
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_databaromni();
  var _Y = $k[--$j];
  $_[$k[--$j]] = _Y;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_databarstackedomni() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($ne($geti($_.barcode, 0, 4), "(01)")) {
    $k[$j++] = "bwipp.databarstackedomniBadAI#9610";
    $k[$j++] = "GS1 DataBar Stacked Omnidirectional must begin with (01) application identifier";
    bwipp_raiseerror();
  }
  if ($_.barcode.length != 17 && $_.barcode.length != 18) {
    $k[$j++] = "bwipp.databarstackedomniBadLength#9613";
    $k[$j++] = "GS1 DataBar Stacked Omnidirectional must be 13 or 14 digits";
    bwipp_raiseerror();
  }
  var _8 = $geti($_.barcode, 4, $_.barcode.length - 4);
  for (var _9 = 0, _A = _8.length; _9 < _A; _9++) {
    var _B = $get(_8, _9);
    if (_B < 48 || _B > 57) {
      $k[$j++] = "bwipp.databarstackedomniBadCharacter#9617";
      $k[$j++] = "GS1 DataBar Stacked Omnidirectional must contain only digits";
      bwipp_raiseerror();
    }
  }
  $_.checksum = 0;
  for (var _C = 0; _C <= 12; _C += 1) {
    $_.i = _C;
    $k[$j++] = "checksum";
    $k[$j++] = $_.checksum;
    $k[$j++] = $get($_.barcode, $_.i + 4) - 48;
    if ($_.i % 2 == 0) {
      var _I = $k[--$j];
      $k[$j++] = _I * 3;
    }
    var _J = $k[--$j];
    var _K = $k[--$j];
    $_[$k[--$j]] = $f(_K + _J);
  }
  $_.checksum = (10 - $_.checksum % 10) % 10;
  if ($_.barcode.length == 18) {
    if ($get($_.barcode, 17) != $_.checksum + 48) {
      $k[$j++] = "bwipp.databarstackedomniBadCheckDigit#9630";
      $k[$j++] = "Incorrect GS1 DataBar Stacked Omnidirectional check digit provided";
      bwipp_raiseerror();
    }
  }
  var _R = $s(18);
  $puti(_R, 0, $_.barcode);
  $put(_R, 17, $_.checksum + 48);
  $_.barcode = _R;
  $put($_.options, "dontdraw", true);
  $put($_.options, "format", "stackedomni");
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_databaromni();
  var _Y = $k[--$j];
  $_[$k[--$j]] = _Y;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_databartruncated() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length != 17 && $_.barcode.length != 18) {
    $k[$j++] = "bwipp.databartruncatedBadLength#9688";
    $k[$j++] = "GS1 DataBar Truncated must be 13 or 14 digits";
    bwipp_raiseerror();
  }
  if ($ne($geti($_.barcode, 0, 4), "(01)")) {
    $k[$j++] = "bwipp.databartruncatedBadAI#9691";
    $k[$j++] = "GS1 DataBar Truncated must begin with (01) application identifier";
    bwipp_raiseerror();
  }
  var _8 = $geti($_.barcode, 4, $_.barcode.length - 4);
  for (var _9 = 0, _A = _8.length; _9 < _A; _9++) {
    var _B = $get(_8, _9);
    if (_B < 48 || _B > 57) {
      $k[$j++] = "bwipp.databartruncatedBadCharacter#9695";
      $k[$j++] = "GS1 DataBar Truncated must contain only digits";
      bwipp_raiseerror();
    }
  }
  $_.checksum = 0;
  for (var _C = 0; _C <= 12; _C += 1) {
    $_.i = _C;
    $k[$j++] = "checksum";
    $k[$j++] = $_.checksum;
    $k[$j++] = $get($_.barcode, $_.i + 4) - 48;
    if ($_.i % 2 == 0) {
      var _I = $k[--$j];
      $k[$j++] = _I * 3;
    }
    var _J = $k[--$j];
    var _K = $k[--$j];
    $_[$k[--$j]] = $f(_K + _J);
  }
  $_.checksum = (10 - $_.checksum % 10) % 10;
  if ($_.barcode.length == 18) {
    if ($get($_.barcode, 17) != $_.checksum + 48) {
      $k[$j++] = "bwipp.databartruncatedBadCheckDigit#9708";
      $k[$j++] = "Incorrect GS1 DataBar Truncated check digit provided";
      bwipp_raiseerror();
    }
  }
  var _R = $s(18);
  $puti(_R, 0, $_.barcode);
  $put(_R, 17, $_.checksum + 48);
  $_.barcode = _R;
  $put($_.options, "dontdraw", true);
  $put($_.options, "format", "truncated");
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_databaromni();
  var _Y = $k[--$j];
  $_[$k[--$j]] = _Y;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_databarlimited() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.height = 10 / 72;
  $_.linkage = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length != 17 && $_.barcode.length != 18) {
    $k[$j++] = "bwipp.databarlimitedBadLength#9771";
    $k[$j++] = "GS1 DataBar Limited must be 13 or 14 digits";
    bwipp_raiseerror();
  }
  if ($ne($geti($_.barcode, 0, 4), "(01)")) {
    $k[$j++] = "bwipp.databarlimitedBadAI#9774";
    $k[$j++] = "GS1 DataBar Limited must begin with (01) application identifier";
    bwipp_raiseerror();
  }
  var _7 = $get($_.barcode, 4);
  if (_7 < 48 || _7 > 49) {
    $k[$j++] = "bwipp.databarlimitedBadStartDigit#9777";
    $k[$j++] = "GS1 DataBar Limited must begin with 0 or 1";
    bwipp_raiseerror();
  }
  var _A = $geti($_.barcode, 5, $_.barcode.length - 5);
  for (var _B = 0, _C = _A.length; _B < _C; _B++) {
    var _D = $get(_A, _B);
    if (_D < 48 || _D > 57) {
      $k[$j++] = "bwipp.databarlimitedBadCharacter#9781";
      $k[$j++] = "GS1 DataBar Limited must contain only digits";
      bwipp_raiseerror();
    }
  }
  $_.checksum = 0;
  for (var _E = 0; _E <= 12; _E += 1) {
    $_.i = _E;
    $k[$j++] = "checksum";
    $k[$j++] = $_.checksum;
    $k[$j++] = $get($_.barcode, $_.i + 4) - 48;
    if ($_.i % 2 == 0) {
      var _K = $k[--$j];
      $k[$j++] = _K * 3;
    }
    var _L = $k[--$j];
    var _M = $k[--$j];
    $_[$k[--$j]] = $f(_M + _L);
  }
  $_.checksum = (10 - $_.checksum % 10) % 10;
  if ($_.barcode.length == 18) {
    if ($get($_.barcode, 17) != $_.checksum + 48) {
      $k[$j++] = "bwipp.databarlimitedBadCheckDigit#9794";
      $k[$j++] = "Incorrect GS1 DataBar Limited check digit provided";
      bwipp_raiseerror();
    }
  }
  var _T = $s(18);
  $puti(_T, 0, $_.barcode);
  $put(_T, 17, $_.checksum + 48);
  $_.barcode = _T;
  $_.linkval = $a([2, 0, 1, 5, 1, 3, 3, 5, 3, 1, 0, 9, 6]);
  $k[$j++] = Infinity;
  var _Z = $geti($_.barcode, 4, 13);
  for (var _a = 0, _b = _Z.length; _a < _b; _a++) {
    $k[$j++] = $get(_Z, _a) - 48;
  }
  $_.binval = $a();
  if ($_.linkage) {
    for (var _h = 0, _g = $_.binval.length - 1; _h <= _g; _h += 1) {
      $_.i = _h;
      $put($_.binval, $_.i, $f($get($_.binval, $_.i) + $get($_.linkval, $_.i)));
    }
  }
  $_.txt = $a($_.barcode.length);
  for (var _u = 0, _t = $_.barcode.length - 1; _u <= _t; _u += 1) {
    $_.i = _u;
    $put($_.txt, $_.i, $a([$geti($_.barcode, $_.i, 1), 0, 0, "", 0]));
  }
  $_.ncr = function() {
    var _11 = $k[--$j];
    var _12 = $k[--$j];
    var _13 = $f(_12 - _11);
    if (_11 < $f(_12 - _11)) {
      var _ = _13;
      _13 = _11;
      _11 = _;
    }
    $k[$j++] = _13;
    $k[$j++] = 1;
    $k[$j++] = 1;
    for (var _15 = _12, _14 = _11 + 1; _15 >= _14; _15 -= 1) {
      var _16 = $k[--$j];
      var _17 = $k[$j - 1];
      var _18 = $k[$j - 2];
      $k[$j++] = _16 * _15;
      if ($le(_17, _18)) {
        var _19 = $k[--$j];
        var _1A = $k[--$j];
        $k[$j++] = _1A + 1;
        $k[$j++] = ~~(_19 / _1A);
      }
    }
    for (; ; ) {
      var _1C = $k[$j - 2];
      var _1D = $k[$j - 3];
      if ($gt(_1C, _1D)) {
        break;
      }
      var _1E = $k[--$j];
      var _1F = $k[--$j];
      $k[$j++] = _1F + 1;
      $k[$j++] = ~~(_1E / _1F);
    }
    var _1G = $k[--$j];
    $k[$j - 1] = _1G;
    var _1I = $k[--$j];
    $k[$j - 1] = _1I;
  };
  $_.getRSSwidths = function() {
    $_.oe = $k[--$j];
    $_.el = $k[--$j];
    $_.mw = $k[--$j];
    $_.nm = $k[--$j];
    $_.val = $k[--$j];
    $_.out = $a($_.el);
    $_.mask = 0;
    for (var _1T = 0, _1S = $_.el - 2; _1T <= _1S; _1T += 1) {
      $_.bar = _1T;
      $_.ew = 1;
      var _1V = $_.bar;
      $_.mask = $_.mask | (_1V < 0 ? 1 >>> -_1V : 1 << _1V);
      for (; ; ) {
        $k[$j++] = "sval";
        $k[$j++] = $f($_.nm - $_.ew) - 1;
        $k[$j++] = $f($_.el - $_.bar) - 2;
        $_.ncr();
        var _1a = $k[--$j];
        $_[$k[--$j]] = _1a;
        if ($_.oe && $_.mask == 0 && $f($_.nm - $_.ew - $_.el * 2 + $_.bar * 2) >= -2) {
          $k[$j++] = "sval";
          $k[$j++] = $_.sval;
          $k[$j++] = $f($_.nm - $_.ew - $_.el + $_.bar);
          $k[$j++] = $f($_.el - $_.bar) - 2;
          $_.ncr();
          var _1p = $k[--$j];
          var _1q = $k[--$j];
          $_[$k[--$j]] = $f(_1q - _1p);
        }
        if ($f($_.el - $_.bar) > 2) {
          $_.lval = 0;
          for (var _20 = $f($_.nm - $_.ew - $_.el + $_.bar) + 2, _1z = $_.mw + 1; _20 >= _1z; _20 -= 1) {
            $k[$j++] = $f($_.nm - _20 - $_.ew) - 1;
            $k[$j++] = $f($_.el - $_.bar) - 3;
            $_.ncr();
            $_.lval = $f($k[--$j] + $_.lval);
          }
          $_.sval = $f($_.sval - $_.lval * ($_.el - $_.bar - 1));
        } else {
          if ($f($_.nm - $_.ew) > $_.mw) {
            $_.sval = $_.sval - 1;
          }
        }
        $_.val = $f($_.val - $_.sval);
        if ($_.val < 0) {
          break;
        }
        $_.ew = $_.ew + 1;
        var _2K = $_.bar;
        $_.mask = $_.mask & ~(_2K < 0 ? 1 >>> -_2K : 1 << _2K);
      }
      $_.val = $f($_.val + $_.sval);
      $_.nm = $f($_.nm - $_.ew);
      $put($_.out, $_.bar, $_.ew);
    }
    $put($_.out, $_.el - 1, $_.nm);
    $k[$j++] = $_.out;
  };
  for (var _2W = 0; _2W <= 11; _2W += 1) {
    $_.i = _2W;
    var _2X = $_.binval;
    var _2Y = $_.i;
    $put(_2X, _2Y + 1, $f($get(_2X, _2Y + 1) + $get($_.binval, $_.i) % 2013571 * 10));
    $put($_.binval, $_.i, ~~($get($_.binval, $_.i) / 2013571));
  }
  $_.d2 = $get($_.binval, 12) % 2013571;
  var _2k = $_.binval;
  $put(_2k, 12, ~~($get(_2k, 12) / 2013571));
  $_.d1 = 0;
  $_.i = true;
  for (var _2m = 0; _2m <= 12; _2m += 1) {
    $_.j = _2m;
    var _2p = $get($_.binval, $_.j);
    $k[$j++] = _2p;
    if (_2p == 0 && $_.i) {
      $j--;
    } else {
      $_.i = false;
      $k[$j++] = "d1";
      $k[$j++] = $_.d1;
      var _2t = $k[$j - 3];
      var _2u = $k[$j - 1];
      $_[$k[$j - 2]] = $f(_2u + _2t * ~~$pow(10, 12 - $_.j));
      $j -= 3;
    }
  }
  $_.tab267 = $a([183063, 0, 17, 9, 6, 3, 6538, 28, 820063, 183064, 13, 13, 5, 4, 875, 728, 1000775, 820064, 9, 17, 3, 6, 28, 6454, 1491020, 1000776, 15, 11, 5, 4, 2415, 203, 1979844, 1491021, 11, 15, 4, 5, 203, 2408, 1996938, 1979845, 19, 7, 8, 1, 17094, 1, 2013570, 1996939, 7, 19, 1, 8, 1, 16632]);
  $_.i = 0;
  for (; ; ) {
    if ($_.d1 <= $get($_.tab267, $_.i)) {
      $aload($geti($_.tab267, $_.i + 1, 7));
      $_.d1te = $k[--$j];
      $_.d1to = $k[--$j];
      $_.d1mwe = $k[--$j];
      $_.d1mwo = $k[--$j];
      $_.d1ele = $k[--$j];
      $_.d1elo = $k[--$j];
      $_.d1gs = $k[--$j];
      break;
    }
    $_.i = $_.i + 8;
  }
  $_.i = 0;
  for (; ; ) {
    if ($_.d2 <= $get($_.tab267, $_.i)) {
      $aload($geti($_.tab267, $_.i + 1, 7));
      $_.d2te = $k[--$j];
      $_.d2to = $k[--$j];
      $_.d2mwe = $k[--$j];
      $_.d2mwo = $k[--$j];
      $_.d2ele = $k[--$j];
      $_.d2elo = $k[--$j];
      $_.d2gs = $k[--$j];
      break;
    }
    $_.i = $_.i + 8;
  }
  $k[$j++] = "d1wo";
  $k[$j++] = ~~($f($_.d1 - $_.d1gs) / $_.d1te);
  $k[$j++] = $_.d1elo;
  $k[$j++] = $_.d1mwo;
  $k[$j++] = 7;
  $k[$j++] = false;
  $_.getRSSwidths();
  var _3X = $k[--$j];
  $_[$k[--$j]] = _3X;
  $k[$j++] = "d1we";
  $k[$j++] = $f($_.d1 - $_.d1gs) % $_.d1te;
  $k[$j++] = $_.d1ele;
  $k[$j++] = $_.d1mwe;
  $k[$j++] = 7;
  $k[$j++] = true;
  $_.getRSSwidths();
  var _3e = $k[--$j];
  $_[$k[--$j]] = _3e;
  $k[$j++] = "d2wo";
  $k[$j++] = ~~($f($_.d2 - $_.d2gs) / $_.d2te);
  $k[$j++] = $_.d2elo;
  $k[$j++] = $_.d2mwo;
  $k[$j++] = 7;
  $k[$j++] = false;
  $_.getRSSwidths();
  var _3l = $k[--$j];
  $_[$k[--$j]] = _3l;
  $k[$j++] = "d2we";
  $k[$j++] = $f($_.d2 - $_.d2gs) % $_.d2te;
  $k[$j++] = $_.d2ele;
  $k[$j++] = $_.d2mwe;
  $k[$j++] = 7;
  $k[$j++] = true;
  $_.getRSSwidths();
  var _3s = $k[--$j];
  $_[$k[--$j]] = _3s;
  $_.d1w = $a(14);
  for (var _3v = 0; _3v <= 6; _3v += 1) {
    $_.i = _3v;
    $put($_.d1w, $_.i * 2, $get($_.d1wo, $_.i));
    $put($_.d1w, $_.i * 2 + 1, $get($_.d1we, $_.i));
  }
  $_.d2w = $a(14);
  for (var _47 = 0; _47 <= 6; _47 += 1) {
    $_.i = _47;
    $put($_.d2w, $_.i * 2, $get($_.d2wo, $_.i));
    $put($_.d2w, $_.i * 2 + 1, $get($_.d2we, $_.i));
  }
  $k[$j++] = Infinity;
  $aload($_.d1w);
  $aload($_.d2w);
  $_.widths = $a();
  $_.checkweights = $a([1, 3, 9, 27, 81, 65, 17, 51, 64, 14, 42, 37, 22, 66, 20, 60, 2, 6, 18, 54, 73, 41, 34, 13, 39, 28, 84, 74]);
  $k[$j++] = Infinity;
  for (var _4M = 0; _4M <= 43; _4M += 1) {
    $k[$j++] = _4M;
  }
  $k[$j++] = 45;
  $k[$j++] = 52;
  $k[$j++] = 57;
  for (var _4N = 63; _4N <= 66; _4N += 1) {
    $k[$j++] = _4N;
  }
  for (var _4O = 73; _4O <= 79; _4O += 1) {
    $k[$j++] = _4O;
  }
  $k[$j++] = 82;
  for (var _4P = 126; _4P <= 130; _4P += 1) {
    $k[$j++] = _4P;
  }
  $k[$j++] = 132;
  for (var _4Q = 141; _4Q <= 146; _4Q += 1) {
    $k[$j++] = _4Q;
  }
  for (var _4R = 210; _4R <= 217; _4R += 1) {
    $k[$j++] = _4R;
  }
  $k[$j++] = 220;
  for (var _4S = 316; _4S <= 320; _4S += 1) {
    $k[$j++] = _4S;
  }
  $k[$j++] = 322;
  $k[$j++] = 323;
  $k[$j++] = 326;
  $k[$j++] = 337;
  $_.checkseq = $a();
  $_.checksum = 0;
  for (var _4V = 0; _4V <= 27; _4V += 1) {
    $_.i = _4V;
    $_.checksum = $f($_.checksum + $get($_.widths, $_.i) * $get($_.checkweights, $_.i));
  }
  $_.checksum = $_.checksum % 89;
  $_.seq = $get($_.checkseq, $_.checksum);
  $k[$j++] = "swidths";
  $k[$j++] = ~~($_.seq / 21);
  $k[$j++] = 8;
  $k[$j++] = 3;
  $k[$j++] = 6;
  $k[$j++] = false;
  $_.getRSSwidths();
  var _4i = $k[--$j];
  $_[$k[--$j]] = _4i;
  $k[$j++] = "bwidths";
  $k[$j++] = $_.seq % 21;
  $k[$j++] = 8;
  $k[$j++] = 3;
  $k[$j++] = 6;
  $k[$j++] = false;
  $_.getRSSwidths();
  var _4l = $k[--$j];
  $_[$k[--$j]] = _4l;
  $_.checkwidths = $a([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1]);
  for (var _4o = 0; _4o <= 5; _4o += 1) {
    $_.i = _4o;
    $put($_.checkwidths, $_.i * 2, $get($_.swidths, $_.i));
    $put($_.checkwidths, $_.i * 2 + 1, $get($_.bwidths, $_.i));
  }
  $k[$j++] = Infinity;
  $k[$j++] = 1;
  $aload($_.d1w);
  $aload($_.checkwidths);
  $aload($_.d2w);
  $k[$j++] = 1;
  $k[$j++] = 1;
  $k[$j++] = 5;
  $_.sbs = $a();
  $k[$j++] = Infinity;
  var _53 = $_.sbs;
  $k[$j++] = Infinity;
  for (var _55 = 0, _56 = ~~(($_.sbs.length + 1) / 2); _55 < _56; _55++) {
    $k[$j++] = $_.height;
  }
  var _58 = $a();
  $k[$j++] = Infinity;
  for (var _5A = 0, _5B = ~~(($_.sbs.length + 1) / 2); _5A < _5B; _5A++) {
    $k[$j++] = 0;
  }
  var _5C = $a();
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "sbs";
  $k[$j++] = _53;
  $k[$j++] = "bhs";
  $k[$j++] = _58;
  $k[$j++] = "bbs";
  $k[$j++] = _5C;
  $k[$j++] = "txt";
  $k[$j++] = $_.txt;
  $k[$j++] = "textxalign";
  $k[$j++] = "center";
  $k[$j++] = "borderleft";
  $k[$j++] = 0;
  $k[$j++] = "borderright";
  $k[$j++] = 0;
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  var _5F = $d();
  $k[$j++] = _5F;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_databarexpanded() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.parse = false;
  $_.dontlint = false;
  $_.lintreqs = true;
  $_.dontdraw = false;
  $_.height = 34 / 72;
  $_.format = "expanded";
  $_.segments = -1;
  $_.linkage = false;
  $_.barxmult = 34;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barxmult < 34) {
    $k[$j++] = "bwipp.databarStackedOmniBarXmult#10075";
    $k[$j++] = "GS1 DataBar Expanded Stacked must have a barxmult of at least 34";
    bwipp_raiseerror();
  }
  if ($ne($_.format, "expanded") && $ne($_.format, "expandedstacked")) {
    $k[$j++] = "bwipp.databarexpandedBadFormat#10079";
    $k[$j++] = "Valid formats are expanded and expandedstacked";
    bwipp_raiseerror();
  }
  if ($_.segments == -1) {
    var _7 = $eq($_.format, "expandedstacked") ? 4 : 22;
    $_.segments = _7;
  } else {
    if ($_.segments < 2 || $_.segments > 22 || $_.segments % 2 != 0) {
      $k[$j++] = "bwipp.gs1databarexpandedBadSegments#10086";
      $k[$j++] = "The number of segments must be even from 2 to 22";
      bwipp_raiseerror();
    }
  }
  $k[$j++] = $_.barcode;
  $k[$j++] = "ai";
  bwipp_gs1process();
  $_.fncs = $k[--$j];
  $_.vals = $k[--$j];
  $_.ais = $k[--$j];
  for (; ; ) {
    if ($_.ais.length == 2) {
      if ($eq($get($_.ais, 0), "01") && $eq($get($_.ais, 1), "3103")) {
        if ($eq($geti($get($_.vals, 0), 0, 1), "9") && $cvi($get($_.vals, 1)) <= 32767) {
          $k[$j++] = "0100";
          $k[$j++] = false;
          break;
        }
      }
    }
    if ($_.ais.length == 2) {
      if ($eq($get($_.ais, 0), "01") && $eq($get($_.ais, 1), "3202")) {
        if ($eq($geti($get($_.vals, 0), 0, 1), "9") && $cvi($get($_.vals, 1)) <= 9999) {
          $k[$j++] = "0101";
          $k[$j++] = false;
          break;
        }
      }
    }
    if ($_.ais.length == 2) {
      if ($eq($get($_.ais, 0), "01") && $eq($get($_.ais, 1), "3203")) {
        if ($eq($geti($get($_.vals, 0), 0, 1), "9") && $cvi($get($_.vals, 1)) <= 22767) {
          $k[$j++] = "0101";
          $k[$j++] = false;
          break;
        }
      }
    }
    var _k = $_.ais.length;
    if (_k == 2 || _k == 3) {
      $k[$j++] = "ai310x";
      $k[$j++] = false;
      for (var _l = 3100; _l <= 3109; _l += 1) {
        var _q = $k[--$j];
        $k[$j++] = _q || $eq($cvrs($s(4), _l, 10), $get($_.ais, 1));
      }
      var _r = $k[--$j];
      $_[$k[--$j]] = _r;
      $k[$j++] = "ai320x";
      $k[$j++] = false;
      for (var _t = 3200; _t <= 3209; _t += 1) {
        var _y = $k[--$j];
        $k[$j++] = _y || $eq($cvrs($s(4), _t, 10), $get($_.ais, 1));
      }
      var _z = $k[--$j];
      $_[$k[--$j]] = _z;
      if ($_.ais.length == 3) {
        var _12 = $a(["11", "13", "15", "17"]);
        $k[$j++] = "aibad";
        $k[$j++] = true;
        for (var _13 = 0, _14 = _12.length; _13 < _14; _13++) {
          var _18 = $k[--$j];
          $k[$j++] = _18 && $ne($get(_12, _13), $get($_.ais, 2));
        }
        var _19 = $k[--$j];
        $_[$k[--$j]] = _19;
      } else {
        $_.aibad = false;
      }
      if ($eq($get($_.ais, 0), "01") && ($_.ai310x || $_.ai320x) && !$_.aibad) {
        if ($_.ais.length == 3) {
          var _1P = $cvi($geti($get($_.vals, 2), 2, 2));
          var _1T = $cvi($geti($get($_.vals, 2), 4, 2));
          if ($eq($geti($get($_.vals, 0), 0, 1), "9") && $cvi($get($_.vals, 1)) <= 99999 && (_1P >= 1 && _1P <= 12) && (_1T >= 0 && _1T <= 31)) {
            if ($_.ai310x && $eq($get($_.ais, 2), "11")) {
              $k[$j++] = "0111000";
              $k[$j++] = false;
              break;
            }
            if ($_.ai320x && $eq($get($_.ais, 2), "11")) {
              $k[$j++] = "0111001";
              $k[$j++] = false;
              break;
            }
            if ($_.ai310x && $eq($get($_.ais, 2), "13")) {
              $k[$j++] = "0111010";
              $k[$j++] = false;
              break;
            }
            if ($_.ai320x && $eq($get($_.ais, 2), "13")) {
              $k[$j++] = "0111011";
              $k[$j++] = false;
              break;
            }
            if ($_.ai310x && $eq($get($_.ais, 2), "15")) {
              $k[$j++] = "0111100";
              $k[$j++] = false;
              break;
            }
            if ($_.ai320x && $eq($get($_.ais, 2), "15")) {
              $k[$j++] = "0111101";
              $k[$j++] = false;
              break;
            }
            if ($_.ai310x && $eq($get($_.ais, 2), "17")) {
              $k[$j++] = "0111110";
              $k[$j++] = false;
              break;
            }
            if ($_.ai320x && $eq($get($_.ais, 2), "17")) {
              $k[$j++] = "0111111";
              $k[$j++] = false;
              break;
            }
          }
        } else {
          if ($eq($geti($get($_.vals, 0), 0, 1), "9") && $cvi($get($_.vals, 1)) <= 99999) {
            if ($_.ai310x) {
              $k[$j++] = "0111000";
              $k[$j++] = false;
              break;
            }
            if ($_.ai320x) {
              $k[$j++] = "0111001";
              $k[$j++] = false;
              break;
            }
          }
        }
      }
    }
    if ($_.ais.length >= 2) {
      $k[$j++] = "ai392x";
      $k[$j++] = false;
      for (var _20 = 3920; _20 <= 3923; _20 += 1) {
        var _25 = $k[--$j];
        $k[$j++] = _25 || $eq($cvrs($s(4), _20, 10), $get($_.ais, 1));
      }
      var _26 = $k[--$j];
      $_[$k[--$j]] = _26;
      if ($eq($get($_.ais, 0), "01") && $_.ai392x) {
        if ($eq($geti($get($_.vals, 0), 0, 1), "9")) {
          $k[$j++] = "01100";
          $k[$j++] = true;
          break;
        }
      }
    }
    if ($_.ais.length >= 2) {
      $k[$j++] = "ai393x";
      $k[$j++] = false;
      for (var _2F = 3930; _2F <= 3933; _2F += 1) {
        var _2K = $k[--$j];
        $k[$j++] = _2K || $eq($cvrs($s(4), _2F, 10), $get($_.ais, 1));
      }
      var _2L = $k[--$j];
      $_[$k[--$j]] = _2L;
      if ($eq($get($_.ais, 0), "01") && $_.ai393x) {
        if ($eq($geti($get($_.vals, 0), 0, 1), "9")) {
          $k[$j++] = "01101";
          $k[$j++] = true;
          break;
        }
      }
    }
    if ($eq($get($_.ais, 0), "01")) {
      $k[$j++] = "1";
      $k[$j++] = true;
      break;
    }
    $k[$j++] = "00";
    $k[$j++] = true;
    break;
  }
  $_.gpfallow = $k[--$j];
  $_.method = $k[--$j];
  $_.conv12to40 = function() {
    var _2Y = $strcpy($s(40), "0000000000000000000000000000000000000000");
    var _2Z = $k[--$j];
    var _2d = $cvrs($s(10), $cvi($geti(_2Z, 0, 3)), 2);
    $puti($geti(_2Y, 0, 10), 10 - _2d.length, _2d);
    var _2h = $cvrs($s(10), $cvi($geti(_2Z, 3, 3)), 2);
    $puti($geti(_2Y, 10, 10), 10 - _2h.length, _2h);
    var _2l = $cvrs($s(10), $cvi($geti(_2Z, 6, 3)), 2);
    $puti($geti(_2Y, 20, 10), 10 - _2l.length, _2l);
    var _2p = $cvrs($s(10), $cvi($geti(_2Z, 9, 3)), 2);
    $puti($geti(_2Y, 30, 10), 10 - _2p.length, _2p);
    $k[$j++] = _2Y;
  };
  $_.conv13to44 = function() {
    var _2r = $strcpy($s(44), "00000000000000000000000000000000000000000000");
    var _2s = $k[--$j];
    var _2w = $cvrs($s(4), $cvi($geti(_2s, 0, 1)), 2);
    $puti($geti(_2r, 0, 4), 4 - _2w.length, _2w);
    $k[$j++] = _2r;
    $k[$j++] = _2r;
    $k[$j++] = $geti(_2s, 1, 12);
    $_.conv12to40();
    var _2y = $k[--$j];
    $puti($k[--$j], 4, _2y);
  };
  $_.tobin = function() {
    var _31 = $s($k[--$j]);
    $k[$j++] = _31;
    for (var _33 = 0, _32 = _31.length - 1; _33 <= _32; _33 += 1) {
      var _34 = $k[$j - 1];
      $put(_34, _33, 48);
    }
    var _35 = $k[$j - 1];
    $k[$j++] = _35;
    var _36 = $k[$j - 3];
    var _37 = $k[$j - 1];
    $k[$j - 3] = $k[$j - 2];
    $j -= 2;
    var _39 = $cvrs($s(_37.length), _36, 2);
    $puti(_37, _37.length - _39.length, _39);
  };
  $_.fnc1 = -1;
  $_.lnumeric = -2;
  $_.lalphanumeric = -3;
  $_.liso646 = -4;
  if ($eq($_.method, "00")) {
    $_.cdf = $a([]);
    $_.gpf = $a([]);
  }
  if ($eq($_.method, "1")) {
    $k[$j++] = "cdf";
    $k[$j++] = $geti($get($_.vals, 0), 0, 13);
    $_.conv13to44();
    var _3H = $k[--$j];
    $_[$k[--$j]] = _3H;
    $k[$j++] = Infinity;
    var _3J = $_.cdf;
    for (var _3K = 0, _3L = _3J.length; _3K < _3L; _3K++) {
      $k[$j++] = $get(_3J, _3K) - 48;
    }
    $_.cdf = $a();
    $_.gpf = $a([]);
    $_.ais = $geti($_.ais, 1, $_.ais.length - 1);
    $_.vals = $geti($_.vals, 1, $_.vals.length - 1);
    $_.fncs = $geti($_.fncs, 1, $_.fncs.length - 1);
  }
  if ($eq($_.method, "0100")) {
    $_.cdf = $s(55);
    $k[$j++] = $_.cdf;
    $k[$j++] = 0;
    $k[$j++] = $geti($get($_.vals, 0), 1, 12);
    $_.conv12to40();
    var _3e = $k[--$j];
    var _3f = $k[--$j];
    $puti($k[--$j], _3f, _3e);
    $k[$j++] = $_.cdf;
    $k[$j++] = 40;
    $k[$j++] = $cvi($get($_.vals, 1));
    $k[$j++] = 15;
    $_.tobin();
    var _3k = $k[--$j];
    var _3l = $k[--$j];
    $puti($k[--$j], _3l, _3k);
    $k[$j++] = Infinity;
    var _3n = $_.cdf;
    for (var _3o = 0, _3p = _3n.length; _3o < _3p; _3o++) {
      $k[$j++] = $get(_3n, _3o) - 48;
    }
    $_.cdf = $a();
    $_.gpf = $a([]);
    $_.ais = $a([]);
    $_.vals = $a([]);
    $_.fncs = $a([]);
  }
  if ($eq($_.method, "0101")) {
    $_.cdf = $s(55);
    $k[$j++] = $_.cdf;
    $k[$j++] = 0;
    $k[$j++] = $geti($get($_.vals, 0), 1, 12);
    $_.conv12to40();
    var _42 = $k[--$j];
    var _43 = $k[--$j];
    $puti($k[--$j], _43, _42);
    if ($eq($get($_.ais, 1), "3202")) {
      $k[$j++] = $cvi($get($_.vals, 1));
      $k[$j++] = 15;
      $_.tobin();
    } else {
      $k[$j++] = $cvi($get($_.vals, 1)) + 1e4;
      $k[$j++] = 15;
      $_.tobin();
    }
    $puti($_.cdf, 40, $k[--$j]);
    $k[$j++] = Infinity;
    var _4D = $_.cdf;
    for (var _4E = 0, _4F = _4D.length; _4E < _4F; _4E++) {
      $k[$j++] = $get(_4D, _4E) - 48;
    }
    $_.cdf = $a();
    $_.gpf = $a([]);
    $_.ais = $a([]);
    $_.vals = $a([]);
    $_.fncs = $a([]);
  }
  if ($_.method.length == 7) {
    $_.cdf = $s(76);
    $k[$j++] = $_.cdf;
    $k[$j++] = 0;
    $k[$j++] = $geti($get($_.vals, 0), 1, 12);
    $_.conv12to40();
    var _4S = $k[--$j];
    var _4T = $k[--$j];
    $puti($k[--$j], _4T, _4S);
    var _4V = $s(6);
    $puti(_4V, 0, $geti($get($_.ais, 1), 3, 1));
    $puti(_4V, 1, $geti($get($_.vals, 1), 1, 5));
    $k[$j++] = $cvi(_4V);
    $k[$j++] = 20;
    $_.tobin();
    $puti($_.cdf, 40, $k[--$j]);
    if ($_.ais.length == 3) {
      var _4g = $get($_.vals, 2);
      $k[$j++] = $cvi($geti(_4g, 0, 2)) * 384 + (($cvi($geti(_4g, 2, 2)) - 1) * 32 + $cvi($geti(_4g, 4, 2)));
    } else {
      $k[$j++] = 38400;
    }
    $k[$j++] = 16;
    $_.tobin();
    $puti($_.cdf, 60, $k[--$j]);
    $k[$j++] = Infinity;
    var _4m = $_.cdf;
    for (var _4n = 0, _4o = _4m.length; _4n < _4o; _4n++) {
      $k[$j++] = $get(_4m, _4n) - 48;
    }
    $_.cdf = $a();
    $_.gpf = $a([]);
    $_.ais = $a([]);
    $_.vals = $a([]);
    $_.fncs = $a([]);
  }
  if ($eq($_.method, "01100")) {
    $_.cdf = $s(42);
    $k[$j++] = $_.cdf;
    $k[$j++] = 0;
    $k[$j++] = $geti($get($_.vals, 0), 1, 12);
    $_.conv12to40();
    var _51 = $k[--$j];
    var _52 = $k[--$j];
    $puti($k[--$j], _52, _51);
    $k[$j++] = $_.cdf;
    $k[$j++] = 40;
    $k[$j++] = $cvi($geti($get($_.ais, 1), 3, 1));
    $k[$j++] = 2;
    $_.tobin();
    var _58 = $k[--$j];
    var _59 = $k[--$j];
    $puti($k[--$j], _59, _58);
    $k[$j++] = Infinity;
    var _5B = $_.cdf;
    for (var _5C = 0, _5D = _5B.length; _5C < _5D; _5C++) {
      $k[$j++] = $get(_5B, _5C) - 48;
    }
    $_.cdf = $a();
    $k[$j++] = Infinity;
    $forall($get($_.vals, 1));
    if ($_.ais.length > 2) {
      $k[$j++] = $_.fnc1;
    }
    $_.gpf = $a();
    $_.ais = $geti($_.ais, 2, $_.ais.length - 2);
    $_.vals = $geti($_.vals, 2, $_.vals.length - 2);
    $_.fncs = $geti($_.fncs, 2, $_.fncs.length - 2);
  }
  if ($eq($_.method, "01101")) {
    $_.cdf = $s(52);
    $k[$j++] = $_.cdf;
    $k[$j++] = 0;
    $k[$j++] = $geti($get($_.vals, 0), 1, 12);
    $_.conv12to40();
    var _5a = $k[--$j];
    var _5b = $k[--$j];
    $puti($k[--$j], _5b, _5a);
    $k[$j++] = $_.cdf;
    $k[$j++] = 40;
    $k[$j++] = $cvi($geti($get($_.ais, 1), 3, 1));
    $k[$j++] = 2;
    $_.tobin();
    var _5h = $k[--$j];
    var _5i = $k[--$j];
    $puti($k[--$j], _5i, _5h);
    $k[$j++] = $_.cdf;
    $k[$j++] = 42;
    $k[$j++] = $cvi($geti($get($_.vals, 1), 0, 3));
    $k[$j++] = 10;
    $_.tobin();
    var _5o = $k[--$j];
    var _5p = $k[--$j];
    $puti($k[--$j], _5p, _5o);
    $k[$j++] = Infinity;
    var _5r = $_.cdf;
    for (var _5s = 0, _5t = _5r.length; _5s < _5t; _5s++) {
      $k[$j++] = $get(_5r, _5s) - 48;
    }
    $_.cdf = $a();
    $k[$j++] = Infinity;
    var _5x = $get($_.vals, 1);
    var _5y = $geti(_5x, 3, _5x.length - 3);
    for (var _5z = 0, _60 = _5y.length; _5z < _60; _5z++) {
      $k[$j++] = $get(_5y, _5z);
    }
    if ($_.ais.length > 2) {
      $k[$j++] = $_.fnc1;
    }
    $_.gpf = $a();
    $_.ais = $geti($_.ais, 2, $_.ais.length - 2);
    $_.vals = $geti($_.vals, 2, $_.vals.length - 2);
    $_.fncs = $geti($_.fncs, 2, $_.fncs.length - 2);
  }
  if ($_.gpfallow) {
    $_.vlf = $a(2);
  } else {
    $_.vlf = $a([]);
  }
  $k[$j++] = Infinity;
  for (var _6H = 0; _6H <= 119; _6H += 1) {
    var _6J = $strcpy($s(2), "00");
    var _6L = $cvrs($s(2), _6H, 11);
    $puti(_6J, 2 - _6L.length, _6L);
    $k[$j++] = _6H;
    $k[$j++] = _6J;
    if ($get(_6J, 0) == 65) {
      var _6N = $k[$j - 1];
      $put(_6N, 0, 94);
    }
    var _6O = $k[$j - 1];
    if ($get(_6O, 1) == 65) {
      var _6Q = $k[$j - 1];
      $put(_6Q, 1, 94);
    }
    var _6R = $k[--$j];
    var _6U = $strcpy($s(7), "0000000");
    var _6W = $cvrs($s(7), $k[--$j] + 8, 2);
    $puti(_6U, 7 - _6W.length, _6W);
    $k[$j++] = _6R;
    $k[$j++] = _6U;
  }
  $k[$j++] = $_.lalphanumeric;
  $k[$j++] = "0000";
  $_.numeric = $d();
  $k[$j++] = Infinity;
  for (var _6Z = 48; _6Z <= 57; _6Z += 1) {
    $k[$j++] = _6Z;
    $k[$j++] = _6Z - 43;
    $k[$j++] = 5;
    $_.tobin();
  }
  $k[$j++] = $_.fnc1;
  $k[$j++] = "01111";
  for (var _6b = 65; _6b <= 90; _6b += 1) {
    $k[$j++] = _6b;
    $k[$j++] = _6b - 33;
    $k[$j++] = 6;
    $_.tobin();
  }
  $k[$j++] = 42;
  $k[$j++] = "111010";
  for (var _6c = 44; _6c <= 47; _6c += 1) {
    $k[$j++] = _6c;
    $k[$j++] = _6c + 15;
    $k[$j++] = 6;
    $_.tobin();
  }
  $k[$j++] = $_.lnumeric;
  $k[$j++] = "000";
  $k[$j++] = $_.liso646;
  $k[$j++] = "00100";
  $_.alphanumeric = $d();
  $k[$j++] = Infinity;
  for (var _6g = 48; _6g <= 57; _6g += 1) {
    $k[$j++] = _6g;
    $k[$j++] = _6g - 43;
    $k[$j++] = 5;
    $_.tobin();
  }
  $k[$j++] = $_.fnc1;
  $k[$j++] = "01111";
  for (var _6i = 65; _6i <= 90; _6i += 1) {
    $k[$j++] = _6i;
    $k[$j++] = _6i - 1;
    $k[$j++] = 7;
    $_.tobin();
  }
  for (var _6j = 97; _6j <= 122; _6j += 1) {
    $k[$j++] = _6j;
    $k[$j++] = _6j - 7;
    $k[$j++] = 7;
    $_.tobin();
  }
  $k[$j++] = 33;
  $k[$j++] = "11101000";
  $k[$j++] = 34;
  $k[$j++] = "11101001";
  for (var _6k = 37; _6k <= 47; _6k += 1) {
    $k[$j++] = _6k;
    $k[$j++] = _6k + 197;
    $k[$j++] = 8;
    $_.tobin();
  }
  for (var _6l = 58; _6l <= 63; _6l += 1) {
    $k[$j++] = _6l;
    $k[$j++] = _6l + 187;
    $k[$j++] = 8;
    $_.tobin();
  }
  $k[$j++] = 95;
  $k[$j++] = "11111011";
  $k[$j++] = 32;
  $k[$j++] = "11111100";
  $k[$j++] = $_.lnumeric;
  $k[$j++] = "000";
  $k[$j++] = $_.lalphanumeric;
  $k[$j++] = "00100";
  $_.iso646 = $d();
  for (var _6s = 0, _6r = $_.ais.length - 1; _6s <= _6r; _6s += 1) {
    $_.i = _6s;
    $_.ai = $get($_.ais, $_.i);
    $_.val = $get($_.vals, $_.i);
    var _72 = $a($_.gpf.length + $_.ai.length + $_.val.length);
    $puti(_72, 0, $_.gpf);
    $k[$j++] = _72;
    $k[$j++] = _72;
    $k[$j++] = $_.gpf.length;
    var _76 = Infinity;
    var _77 = $_.ai;
    $k[$j++] = _76;
    $forall(_77);
    var _78 = $a();
    var _79 = $k[--$j];
    $puti($k[--$j], _79, _78);
    var _7B = $k[$j - 1];
    $k[$j++] = _7B;
    $k[$j++] = $_.gpf.length + $_.ai.length;
    var _7F = Infinity;
    var _7G = $_.val;
    $k[$j++] = _7F;
    $forall(_7G);
    var _7H = $a();
    var _7I = $k[--$j];
    $puti($k[--$j], _7I, _7H);
    $_.gpf = $k[--$j];
    if ($_.i != $_.ais.length - 1 && $get($_.fncs, $_.i)) {
      var _7R = $a($_.gpf.length + 1);
      $puti(_7R, 0, $_.gpf);
      $put(_7R, $_.gpf.length, $_.fnc1);
      $_.gpf = _7R;
    }
  }
  $_.rembits = function() {
    var _7V = $k[--$j];
    var _7W = 48;
    var _7X = ~~$ceil(_7V / 12) * 12;
    if (~~$ceil(_7V / 12) * 12 < 48) {
      var _2 = _7W;
      _7W = _7X;
      _7X = _2;
    }
    var _7Y = ~~(_7X / 12);
    $k[$j++] = _7V;
    $k[$j++] = _7X;
    $k[$j++] = _7Y;
    if (_7Y % $_.segments == 1) {
      var _7a = $k[--$j];
      $k[$j - 1] = (_7a + 1) * 12;
    } else {
      $j--;
    }
    var _7c = $k[--$j];
    var _7d = $k[--$j];
    $k[$j++] = $f(_7c - _7d);
  };
  $_.encode = function() {
    var _7e = $k[$j - 1];
    if ($ne(_7e, "raw")) {
      var _7f = $k[--$j];
      var _7h = $get(_7f, $k[--$j]);
      $k[$j++] = _7h;
    } else {
      $j--;
    }
    var _7i = $k[$j - 1];
    if (_7i.length + $_.j >= 252) {
      $j--;
      $k[$j++] = "bwipp.gs1databarexpandedTooLong#10374";
      $k[$j++] = "Maximum length exceeded";
      bwipp_raiseerror();
    }
    $k[$j++] = Infinity;
    var _7k = $k[--$j];
    var _7l = $k[--$j];
    $k[$j++] = _7k;
    $forall(_7l, function() {
      var _7m = $k[--$j];
      $k[$j++] = _7m - 48;
    });
    var _7n = $a();
    $puti($_.gpfenc, $_.j, _7n);
    $_.j = _7n.length + $_.j;
  };
  $k[$j++] = Infinity;
  for (var _7s = 0, _7t = $_.gpf.length; _7s < _7t; _7s++) {
    $k[$j++] = 0;
  }
  $k[$j++] = 0;
  $k[$j++] = -1;
  $_.numericruns = $a();
  $k[$j++] = Infinity;
  for (var _7w = 0, _7x = $_.gpf.length; _7w < _7x; _7w++) {
    $k[$j++] = 0;
  }
  $k[$j++] = 0;
  $_.alphanumericruns = $a();
  $k[$j++] = Infinity;
  for (var _80 = 0, _81 = $_.gpf.length; _80 < _81; _80++) {
    $k[$j++] = 0;
  }
  $k[$j++] = 9999;
  $_.nextiso646only = $a();
  for (var _84 = $_.gpf.length - 1; _84 >= 0; _84 -= 1) {
    $_.i = _84;
    var _89 = $strcpy($s(2), "00");
    var _8C = $get($_.gpf, $_.i);
    $k[$j++] = $get($_.gpf, $_.i);
    $k[$j++] = _89;
    $k[$j++] = _89;
    $k[$j++] = 0;
    $k[$j++] = _8C;
    if (_8C == $_.fnc1) {
      $k[$j - 1] = 94;
    }
    var _8E = $k[--$j];
    var _8F = $k[--$j];
    $put($k[--$j], _8F, _8E);
    if ($_.i < $_.gpf.length - 1) {
      var _8J = $k[$j - 1];
      var _8M = $get($_.gpf, $_.i + 1);
      $k[$j++] = _8J;
      $k[$j++] = 1;
      $k[$j++] = _8M;
      if (_8M == $_.fnc1) {
        $k[$j - 1] = 94;
      }
      var _8O = $k[--$j];
      var _8P = $k[--$j];
      $put($k[--$j], _8P, _8O);
    }
    var _8T = $get($_.numeric, $k[--$j]) !== void 0;
    if (_8T) {
      $put($_.numericruns, $_.i, $get($_.numericruns, $_.i + 2) + 2);
    } else {
      $put($_.numericruns, $_.i, 0);
    }
    var _8b = $k[$j - 1];
    var _8d = $get($_.alphanumeric, _8b) !== void 0;
    if (_8d) {
      $put($_.alphanumericruns, $_.i, $get($_.alphanumericruns, $_.i + 1) + 1);
    } else {
      $put($_.alphanumericruns, $_.i, 0);
    }
    var _8l = $k[--$j];
    var _8n = $get($_.iso646, _8l) !== void 0;
    var _8p = $get($_.alphanumeric, _8l) !== void 0;
    if (_8n && !_8p) {
      $put($_.nextiso646only, $_.i, 0);
    } else {
      $put($_.nextiso646only, $_.i, $get($_.nextiso646only, $_.i + 1) + 1);
    }
  }
  $_.gpfenc = $a(252);
  $_.i = 0;
  $_.j = 0;
  $_.mode = "numeric";
  for (; ; ) {
    if ($_.i == $_.gpf.length) {
      break;
    }
    for (; ; ) {
      if ($eq($_.mode, "numeric")) {
        if ($_.i <= $_.gpf.length - 2) {
          var _93 = $s(2);
          var _96 = $get($_.gpf, $_.i);
          $k[$j++] = _93;
          $k[$j++] = _93;
          $k[$j++] = 0;
          $k[$j++] = _96;
          if (_96 == $_.fnc1) {
            $k[$j - 1] = 94;
          }
          var _98 = $k[--$j];
          var _99 = $k[--$j];
          $put($k[--$j], _99, _98);
          var _9B = $k[$j - 1];
          var _9E = $get($_.gpf, $_.i + 1);
          $k[$j++] = _9B;
          $k[$j++] = 1;
          $k[$j++] = _9E;
          if (_9E == $_.fnc1) {
            $k[$j - 1] = 94;
          }
          var _9G = $k[--$j];
          var _9H = $k[--$j];
          $put($k[--$j], _9H, _9G);
          var _9J = $k[$j - 1];
          var _9L = $get($_.numeric, _9J) !== void 0;
          if (_9L) {
            $k[$j++] = $_.numeric;
            $_.encode();
            $_.i = $_.i + 2;
            break;
          }
          $k[$j - 1] = $_.lalphanumeric;
          $k[$j++] = $_.numeric;
          $_.encode();
          $_.mode = "alphanumeric";
          break;
        } else {
          var _9S = $get($_.gpf, $_.i);
          if (_9S < 48 || _9S > 57) {
            $k[$j++] = $_.lalphanumeric;
            $k[$j++] = $_.numeric;
            $_.encode();
            $_.mode = "alphanumeric";
            break;
          }
          $k[$j++] = "rem";
          $k[$j++] = 12 + 1 + $_.method.length + $_.vlf.length + $_.cdf.length + $_.j;
          $_.rembits();
          var _9Z = $k[--$j];
          $_[$k[--$j]] = _9Z;
          if ($_.rem >= 4 && $_.rem <= 6) {
            var _9g = $geti($strcpy($s(6), "000000"), 0, $_.rem);
            var _9l = $cvrs($s(4), $get($_.gpf, $_.i) - 47, 2);
            $puti(_9g, 4 - _9l.length, _9l);
            $k[$j++] = _9g;
            $k[$j++] = "raw";
            $_.encode();
            $_.i = $_.i + 1;
            break;
          } else {
            var _9n = $s(2);
            $put(_9n, 0, $get($_.gpf, $_.i));
            $put(_9n, 1, 94);
            $k[$j++] = _9n;
            $k[$j++] = $_.numeric;
            $_.encode();
            $_.i = $_.i + 1;
            break;
          }
        }
      }
      if ($eq($_.mode, "alphanumeric")) {
        if ($get($_.gpf, $_.i) == $_.fnc1) {
          $k[$j++] = $_.fnc1;
          $k[$j++] = $_.alphanumeric;
          $_.encode();
          $_.mode = "numeric";
          $_.i = $_.i + 1;
          break;
        }
        var _A3 = $get($_.gpf, $_.i);
        var _A5 = $get($_.iso646, _A3) !== void 0;
        var _A7 = $get($_.alphanumeric, _A3) !== void 0;
        if (_A5 && !_A7) {
          $k[$j++] = $_.liso646;
          $k[$j++] = $_.alphanumeric;
          $_.encode();
          $_.mode = "iso646";
          break;
        }
        if ($get($_.numericruns, $_.i) >= 6) {
          $k[$j++] = $_.lnumeric;
          $k[$j++] = $_.alphanumeric;
          $_.encode();
          $_.mode = "numeric";
          break;
        }
        var _AH = $get($_.numericruns, $_.i);
        if (_AH >= 4 && $f(_AH + $_.i) == $_.gpf.length) {
          $k[$j++] = $_.lnumeric;
          $k[$j++] = $_.alphanumeric;
          $_.encode();
          $_.mode = "numeric";
          break;
        }
        $k[$j++] = $get($_.gpf, $_.i);
        $k[$j++] = $_.alphanumeric;
        $_.encode();
        $_.i = $_.i + 1;
        break;
      }
      if ($eq($_.mode, "iso646")) {
        if ($get($_.gpf, $_.i) == $_.fnc1) {
          $k[$j++] = $_.fnc1;
          $k[$j++] = $_.iso646;
          $_.encode();
          $_.mode = "numeric";
          $_.i = $_.i + 1;
          break;
        }
        if ($get($_.numericruns, $_.i) >= 4 && $get($_.nextiso646only, $_.i) >= 10) {
          $k[$j++] = $_.lnumeric;
          $k[$j++] = $_.iso646;
          $_.encode();
          $_.mode = "numeric";
          break;
        }
        if ($get($_.alphanumericruns, $_.i) >= 5 && $get($_.nextiso646only, $_.i) >= 10) {
          $k[$j++] = $_.lalphanumeric;
          $k[$j++] = $_.iso646;
          $_.encode();
          $_.mode = "alphanumeric";
          break;
        }
        $k[$j++] = $get($_.gpf, $_.i);
        $k[$j++] = $_.iso646;
        $_.encode();
        $_.i = $_.i + 1;
        break;
      }
    }
  }
  $_.gpf = $geti($_.gpfenc, 0, $_.j);
  var _B1 = 1 + 12 + $_.method.length + $_.vlf.length + $_.cdf.length + $_.gpf.length;
  $k[$j++] = _B1;
  $k[$j++] = _B1;
  $_.rembits();
  var _B2 = $k[--$j];
  $_.pad = $a(_B2);
  $k[$j++] = _B2;
  if ($_.vlf.length != 0) {
    var _B5 = $k[--$j];
    var _B7 = ~~($f($k[--$j] + _B5) / 12);
    $put($_.vlf, 0, _B7 % 2);
    var _B9 = _B7 <= 14 ? 0 : 1;
    $put($_.vlf, 1, _B9);
  } else {
    $j -= 2;
  }
  if ($_.pad.length > 0) {
    for (var _BE = 0, _BD = $_.pad.length - 1; _BE <= _BD; _BE += 5) {
      $_.i = _BE;
      var _BF = $_.pad;
      var _BG = $_.i;
      var _BH = $a([0, 0, 1, 0, 0]);
      var _BI = $_.pad;
      var _BJ = $_.i;
      var _BK = 5;
      var _BL = _BI.length - _BJ;
      if (_BI.length - _BJ > 5) {
        var _ = _BK;
        _BK = _BL;
        _BL = _;
      }
      $puti(_BF, _BG, $geti(_BH, 0, _BL));
    }
    if ($eq($_.mode, "numeric")) {
      $k[$j++] = Infinity;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $aload($_.pad);
      $_.pad = $geti($a(), 0, $_.pad.length);
    }
  }
  $k[$j++] = Infinity;
  var _BT = $_.linkage ? 1 : 0;
  $k[$j++] = _BT;
  $forall($_.method, function() {
    var _BV = $k[--$j];
    $k[$j++] = _BV - 48;
  });
  $aload($_.vlf);
  $aload($_.cdf);
  $aload($_.gpf);
  $aload($_.pad);
  $_.binval = $a();
  $_.datalen = ~~($_.binval.length / 12);
  $_.ncr = function() {
    var _Bc = $k[--$j];
    var _Bd = $k[--$j];
    var _Be = $f(_Bd - _Bc);
    if (_Bc < $f(_Bd - _Bc)) {
      var _2 = _Be;
      _Be = _Bc;
      _Bc = _2;
    }
    $k[$j++] = _Be;
    $k[$j++] = 1;
    $k[$j++] = 1;
    for (var _Bg = _Bd, _Bf = _Bc + 1; _Bg >= _Bf; _Bg -= 1) {
      var _Bh = $k[--$j];
      var _Bi = $k[$j - 1];
      var _Bj = $k[$j - 2];
      $k[$j++] = _Bh * _Bg;
      if ($le(_Bi, _Bj)) {
        var _Bk = $k[--$j];
        var _Bl = $k[--$j];
        $k[$j++] = _Bl + 1;
        $k[$j++] = ~~(_Bk / _Bl);
      }
    }
    for (; ; ) {
      var _Bn = $k[$j - 2];
      var _Bo = $k[$j - 3];
      if ($gt(_Bn, _Bo)) {
        break;
      }
      var _Bp = $k[--$j];
      var _Bq = $k[--$j];
      $k[$j++] = _Bq + 1;
      $k[$j++] = ~~(_Bp / _Bq);
    }
    var _Br = $k[--$j];
    $k[$j - 1] = _Br;
    var _Bt = $k[--$j];
    $k[$j - 1] = _Bt;
  };
  $_.getRSSwidths = function() {
    $_.oe = $k[--$j];
    $_.el = $k[--$j];
    $_.mw = $k[--$j];
    $_.nm = $k[--$j];
    $_.val = $k[--$j];
    $_.out = $a($_.el);
    $_.mask = 0;
    for (var _C4 = 0, _C3 = $_.el - 2; _C4 <= _C3; _C4 += 1) {
      $_.bar = _C4;
      $_.ew = 1;
      var _C6 = $_.bar;
      $_.mask = $_.mask | (_C6 < 0 ? 1 >>> -_C6 : 1 << _C6);
      for (; ; ) {
        $k[$j++] = "sval";
        $k[$j++] = $f($_.nm - $_.ew) - 1;
        $k[$j++] = $f($_.el - $_.bar) - 2;
        $_.ncr();
        var _CB = $k[--$j];
        $_[$k[--$j]] = _CB;
        if ($_.oe && $_.mask == 0 && $f($_.nm - $_.ew - $_.el * 2 + $_.bar * 2) >= -2) {
          $k[$j++] = "sval";
          $k[$j++] = $_.sval;
          $k[$j++] = $f($_.nm - $_.ew - $_.el + $_.bar);
          $k[$j++] = $f($_.el - $_.bar) - 2;
          $_.ncr();
          var _CQ = $k[--$j];
          var _CR = $k[--$j];
          $_[$k[--$j]] = $f(_CR - _CQ);
        }
        if ($f($_.el - $_.bar) > 2) {
          $_.lval = 0;
          for (var _Cb = $f($_.nm - $_.ew - $_.el + $_.bar) + 2, _Ca = $_.mw + 1; _Cb >= _Ca; _Cb -= 1) {
            $k[$j++] = $f($_.nm - _Cb - $_.ew) - 1;
            $k[$j++] = $f($_.el - $_.bar) - 3;
            $_.ncr();
            $_.lval = $f($k[--$j] + $_.lval);
          }
          $_.sval = $f($_.sval - $_.lval * ($_.el - $_.bar - 1));
        } else {
          if ($f($_.nm - $_.ew) > $_.mw) {
            $_.sval = $_.sval - 1;
          }
        }
        $_.val = $f($_.val - $_.sval);
        if ($_.val < 0) {
          break;
        }
        $_.ew = $_.ew + 1;
        var _Cv = $_.bar;
        $_.mask = $_.mask & ~(_Cv < 0 ? 1 >>> -_Cv : 1 << _Cv);
      }
      $_.val = $f($_.val + $_.sval);
      $_.nm = $f($_.nm - $_.ew);
      $put($_.out, $_.bar, $_.ew);
    }
    $put($_.out, $_.el - 1, $_.nm);
    $k[$j++] = $_.out;
  };
  $_.tab174 = $a([347, 0, 12, 5, 7, 2, 87, 4, 1387, 348, 10, 7, 5, 4, 52, 20, 2947, 1388, 8, 9, 4, 5, 30, 52, 3987, 2948, 6, 11, 3, 6, 10, 104, 4191, 3988, 4, 13, 1, 8, 1, 204]);
  $_.dxw = $a($_.datalen);
  for (var _DD = 0, _DC = $_.datalen - 1; _DD <= _DC; _DD += 1) {
    $_.x = _DD;
    $_.d = $geti($_.binval, $_.x * 12, 12);
    $k[$j++] = "d";
    $k[$j++] = 0;
    for (var _DH = 0; _DH <= 11; _DH += 1) {
      $_.j = _DH;
      var _DM = $k[--$j];
      $k[$j++] = $f(_DM + ~~$pow(2, 11 - $_.j) * $get($_.d, $_.j));
    }
    var _DN = $k[--$j];
    $_[$k[--$j]] = _DN;
    $_.j = 0;
    for (; ; ) {
      if ($le($_.d, $get($_.tab174, $_.j))) {
        $aload($geti($_.tab174, $_.j + 1, 7));
        $_.dte = $k[--$j];
        $_.dto = $k[--$j];
        $_.dmwe = $k[--$j];
        $_.dmwo = $k[--$j];
        $_.dele = $k[--$j];
        $_.delo = $k[--$j];
        $_.dgs = $k[--$j];
        break;
      }
      $_.j = $_.j + 8;
    }
    $k[$j++] = "dwo";
    $k[$j++] = ~~($f($_.d - $_.dgs) / $_.dte);
    $k[$j++] = $_.delo;
    $k[$j++] = $_.dmwo;
    $k[$j++] = 4;
    $k[$j++] = true;
    $_.getRSSwidths();
    var _Dj = $k[--$j];
    $_[$k[--$j]] = _Dj;
    $k[$j++] = "dwe";
    $k[$j++] = $f($_.d - $_.dgs) % $_.dte;
    $k[$j++] = $_.dele;
    $k[$j++] = $_.dmwe;
    $k[$j++] = 4;
    $k[$j++] = false;
    $_.getRSSwidths();
    var _Dq = $k[--$j];
    $_[$k[--$j]] = _Dq;
    $_.dw = $a(8);
    if ($_.x % 2 == 0) {
      for (var _Du = 0; _Du <= 3; _Du += 1) {
        $_.j = _Du;
        $put($_.dw, 7 - $_.j * 2, $get($_.dwo, $_.j));
        $put($_.dw, 6 - $_.j * 2, $get($_.dwe, $_.j));
      }
    } else {
      for (var _E5 = 0; _E5 <= 3; _E5 += 1) {
        $_.j = _E5;
        $put($_.dw, $_.j * 2, $get($_.dwo, $_.j));
        $put($_.dw, $_.j * 2 + 1, $get($_.dwe, $_.j));
      }
    }
    $put($_.dxw, $_.x, $_.dw);
  }
  $_.finderwidths = $a([1, 8, 4, 1, 1, 1, 1, 4, 8, 1, 3, 6, 4, 1, 1, 1, 1, 4, 6, 3, 3, 4, 6, 1, 1, 1, 1, 6, 4, 3, 3, 2, 8, 1, 1, 1, 1, 8, 2, 3, 2, 6, 5, 1, 1, 1, 1, 5, 6, 2, 2, 2, 9, 1, 1, 1, 1, 9, 2, 2]);
  $_.finderseq = $a([$a([0, 1]), $a([0, 3, 2]), $a([0, 5, 2, 7]), $a([0, 9, 2, 7, 4]), $a([0, 9, 2, 7, 6, 11]), $a([0, 9, 2, 7, 8, 11, 10]), $a([0, 1, 2, 3, 4, 5, 6, 7]), $a([0, 1, 2, 3, 4, 5, 6, 9, 8]), $a([0, 1, 2, 3, 4, 5, 6, 9, 10, 11]), $a([0, 1, 2, 3, 4, 7, 6, 9, 8, 11, 10])]);
  $_.seq = $get($_.finderseq, ~~(($_.datalen - 2) / 2));
  $_.fxw = $a($_.seq.length);
  for (var _Ed = 0, _Ec = $_.seq.length - 1; _Ed <= _Ec; _Ed += 1) {
    $_.x = _Ed;
    $put($_.fxw, $_.x, $geti($_.finderwidths, $get($_.seq, $_.x) * 5, 5));
  }
  $_.checkweights = $a([-1, -1, -1, -1, -1, -1, -1, -1, 77, 96, 32, 81, 27, 9, 3, 1, 20, 60, 180, 118, 143, 7, 21, 63, 205, 209, 140, 117, 39, 13, 145, 189, 193, 157, 49, 147, 19, 57, 171, 91, 132, 44, 85, 169, 197, 136, 186, 62, 185, 133, 188, 142, 4, 12, 36, 108, 50, 87, 29, 80, 97, 173, 128, 113, 150, 28, 84, 41, 123, 158, 52, 156, 166, 196, 206, 139, 187, 203, 138, 46, 76, 17, 51, 153, 37, 111, 122, 155, 146, 119, 110, 107, 106, 176, 129, 43, 16, 48, 144, 10, 30, 90, 59, 177, 164, 125, 112, 178, 200, 137, 116, 109, 70, 210, 208, 202, 184, 130, 179, 115, 190, 204, 68, 93, 31, 151, 191, 134, 148, 22, 66, 198, 172, 94, 71, 2, 40, 154, 192, 64, 162, 54, 18, 6, 120, 149, 25, 75, 14, 42, 126, 167, 175, 199, 207, 69, 23, 78, 26, 79, 103, 98, 83, 38, 114, 131, 182, 124, 159, 53, 88, 170, 127, 183, 61, 161, 55, 165, 73, 8, 24, 72, 5, 15, 89, 100, 174, 58, 160, 194, 135, 45]);
  $k[$j++] = Infinity;
  $forall($_.seq, function() {
    $aload($geti($_.checkweights, $k[--$j] * 16, 16));
  });
  var _Er = $a();
  $_.checkweightseq = $geti(_Er, 8, _Er.length - 8);
  $k[$j++] = Infinity;
  var _Et = $_.dxw;
  for (var _Eu = 0, _Ev = _Et.length; _Eu < _Ev; _Eu++) {
    $aload($get(_Et, _Eu));
  }
  $_.widths = $a();
  $_.checksum = 0;
  for (var _F0 = 0, _Ez = $_.widths.length - 1; _F0 <= _Ez; _F0 += 1) {
    $_.i = _F0;
    $_.checksum = $f($_.checksum + $get($_.widths, $_.i) * $get($_.checkweightseq, $_.i));
  }
  $_.checksum = $f($_.checksum % 211 + ($_.datalen - 3) * 211);
  $_.i = 0;
  for (; ; ) {
    if ($_.checksum <= $get($_.tab174, $_.i)) {
      $aload($geti($_.tab174, $_.i + 1, 7));
      $_.cte = $k[--$j];
      $_.cto = $k[--$j];
      $_.cmwe = $k[--$j];
      $_.cmwo = $k[--$j];
      $_.cele = $k[--$j];
      $_.celo = $k[--$j];
      $_.cgs = $k[--$j];
      break;
    }
    $_.i = $_.i + 8;
  }
  $k[$j++] = "cwo";
  $k[$j++] = ~~($f($_.checksum - $_.cgs) / $_.cte);
  $k[$j++] = $_.celo;
  $k[$j++] = $_.cmwo;
  $k[$j++] = 4;
  $k[$j++] = true;
  $_.getRSSwidths();
  var _FU = $k[--$j];
  $_[$k[--$j]] = _FU;
  $k[$j++] = "cwe";
  $k[$j++] = $f($_.checksum - $_.cgs) % $_.cte;
  $k[$j++] = $_.cele;
  $k[$j++] = $_.cmwe;
  $k[$j++] = 4;
  $k[$j++] = false;
  $_.getRSSwidths();
  var _Fb = $k[--$j];
  $_[$k[--$j]] = _Fb;
  $_.cw = $a(8);
  for (var _Fe = 0; _Fe <= 3; _Fe += 1) {
    $_.i = _Fe;
    $put($_.cw, $_.i * 2, $get($_.cwo, $_.i));
    $put($_.cw, $_.i * 2 + 1, $get($_.cwe, $_.i));
  }
  var _Fp = $a(22);
  $put(_Fp, 0, $_.cw);
  $puti(_Fp, 1, $_.dxw);
  $_.dxw = $geti(_Fp, 0, $_.datalen + 1);
  $_.datalen = $_.dxw.length;
  $_.rows = $a(~~$ceil($_.datalen / $_.segments));
  $_.numrows = $_.rows.length;
  for (var _G1 = 0, _G0 = $_.numrows - 1; _G1 <= _G0; _G1 += 1) {
    $_.r = _G1;
    $k[$j++] = Infinity;
    if ($_.segments % 4 != 0 && $_.r % 2 == 1) {
      $k[$j++] = 0;
    }
    $k[$j++] = 1;
    $k[$j++] = 1;
    for (var _G6 = 0, _G5 = $_.segments - 1; _G6 <= _G5; _G6 += 1) {
      $_.pos = _G6 + $_.r * $_.segments;
      if ($_.pos < $_.datalen) {
        $aload($get($_.dxw, $_.pos));
        if ($_.pos % 2 == 0) {
          $aload($get($_.fxw, ~~($_.pos / 2)));
        }
      }
    }
    var _GI = $counttomark() + 2;
    $k[$j++] = 1;
    $k[$j++] = 1;
    $astore($a(_GI));
    $put($_.rows, $_.r, $k[--$j]);
    $j--;
  }
  if ($ne($_.format, "expandedstacked")) {
    var _GP = $get($_.rows, 0);
    $_.sbs = $geti(_GP, 1, _GP.length - 1);
    $k[$j++] = Infinity;
    $k[$j++] = 1;
    for (var _GT = 0, _GS = $_.datalen - 1; _GT <= _GS; _GT += 1) {
      $_.i = _GT;
      $aload($get($_.dxw, $_.i));
      if ($_.i % 2 == 0) {
        $aload($get($_.fxw, ~~($_.i / 2)));
      }
    }
    $k[$j++] = 1;
    $k[$j++] = 1;
    $_.sbs = $a();
    $k[$j++] = Infinity;
    var _Gc = $_.sbs;
    $k[$j++] = Infinity;
    for (var _Ge = 0, _Gf = ~~(($_.sbs.length + 1) / 2); _Ge < _Gf; _Ge++) {
      $k[$j++] = $_.height;
    }
    var _Gh = $a();
    $k[$j++] = Infinity;
    for (var _Gj = 0, _Gk = ~~(($_.sbs.length + 1) / 2); _Gj < _Gk; _Gj++) {
      $k[$j++] = 0;
    }
    var _Gl = $a();
    $k[$j++] = "ren";
    $k[$j++] = "renlinear";
    $k[$j++] = "sbs";
    $k[$j++] = _Gc;
    $k[$j++] = "bhs";
    $k[$j++] = _Gh;
    $k[$j++] = "bbs";
    $k[$j++] = _Gl;
    $k[$j++] = "borderleft";
    $k[$j++] = 0;
    $k[$j++] = "borderright";
    $k[$j++] = 0;
    $k[$j++] = "bordertop";
    $k[$j++] = 0;
    $k[$j++] = "borderbottom";
    $k[$j++] = 0;
    $k[$j++] = "opt";
    $k[$j++] = $_.options;
    var _Gn = $d();
    $k[$j++] = _Gn;
    if (!$_.dontdraw) {
      bwipp_renlinear();
    }
  } else {
    $_.seps = $a($_.numrows);
    for (var _Gt = 0, _Gs = $_.numrows - 1; _Gt <= _Gs; _Gt += 1) {
      $_.r = _Gt;
      $_.row = $get($_.rows, $_.r);
      $k[$j++] = Infinity;
      for (var _Gz = 0, _Gy = $_.row.length - 1; _Gz <= _Gy; _Gz += 2) {
        $_.i = _Gz;
        for (var _H3 = 0, _H4 = $get($_.row, $_.i); _H3 < _H4; _H3++) {
          $k[$j++] = 0;
        }
        if ($_.i < $_.row.length - 1) {
          for (var _HA = 0, _HB = $get($_.row, $_.i + 1); _HA < _HB; _HA++) {
            $k[$j++] = 1;
          }
        }
      }
      $astore($a($counttomark()));
      $_.row = $k[--$j];
      $k[$j - 1] = Infinity;
      $forall($_.row, function() {
        var _HG = $k[--$j];
        $k[$j++] = 1 - _HG;
      });
      $_.sep = $a();
      $k[$j++] = Infinity;
      for (var _HK = 19, _HJ = $_.row.length - 13; _HK <= _HJ; _HK += 98) {
        $k[$j++] = _HK;
      }
      for (var _HN = 68, _HM = $_.row.length - 13; _HN <= _HM; _HN += 98) {
        $k[$j++] = _HN;
      }
      $_.finderpos = $a();
      var _HP = $_.finderpos;
      for (var _HQ = 0, _HR = _HP.length; _HQ < _HR; _HQ++) {
        var _HS = $get(_HP, _HQ);
        for (var _HU = _HS, _HT = _HS + 14; _HU <= _HT; _HU += 1) {
          $_.i = _HU;
          if ($get($_.row, $_.i) == 0) {
            if ($get($_.row, $_.i - 1) == 1) {
              $k[$j++] = 1;
            } else {
              var _He = $get($_.sep, $_.i - 1) == 0 ? 1 : 0;
              $k[$j++] = _He;
            }
          } else {
            $k[$j++] = 0;
          }
          $put($_.sep, $_.i, $k[--$j]);
        }
      }
      $puti($_.sep, 0, $a([0, 0, 0, 0]));
      $puti($_.sep, $_.row.length - 4, $a([0, 0, 0, 0]));
      if ($_.segments % 4 == 0 && $_.r % 2 == 1) {
        if ($get($_.rows, $_.r).length != $get($_.rows, 0).length && $_.finderpos.length % 2 == 1) {
          $k[$j++] = Infinity;
          $k[$j++] = 0;
          $aload($_.row);
          $_.row = $a();
          $k[$j++] = Infinity;
          $k[$j++] = 0;
          $aload($_.sep);
          $_.sep = $a();
        } else {
          for (var _I0 = $_.row.length - 1; _I0 >= 0; _I0 -= 1) {
            $k[$j++] = $get($_.row, _I0);
          }
          $astore($_.row);
          $j--;
          for (var _I5 = $_.sep.length - 1; _I5 >= 0; _I5 -= 1) {
            $k[$j++] = $get($_.sep, _I5);
          }
          $astore($_.sep);
          $j--;
        }
      }
      $put($_.rows, $_.r, $_.row);
      $put($_.seps, $_.r, $_.sep);
    }
    $_.pixx = $get($_.rows, 0).length;
    $k[$j++] = Infinity;
    for (var _II = 0, _IJ = $_.pixx; _II < _IJ; _II++) {
      $k[$j++] = 0;
    }
    var _IK = $a();
    $puti(_IK, 0, $get($_.rows, $_.numrows - 1));
    $put($_.rows, $_.numrows - 1, _IK);
    $k[$j++] = Infinity;
    for (var _IR = 0, _IS = $_.pixx; _IR < _IS; _IR++) {
      $k[$j++] = 0;
    }
    var _IT = $a();
    $puti(_IT, 0, $get($_.seps, $_.numrows - 1));
    $put($_.seps, $_.numrows - 1, _IT);
    $k[$j++] = Infinity;
    for (var _Ia = 0, _Ib = ~~($_.pixx / 2) + 1; _Ia < _Ib; _Ia++) {
      $k[$j++] = 0;
      $k[$j++] = 1;
    }
    $_.sep = $geti($a(), 0, $_.pixx);
    $puti($_.sep, 0, $a([0, 0, 0, 0]));
    $puti($_.sep, $_.pixx - 4, $a([0, 0, 0, 0]));
    $k[$j++] = Infinity;
    for (var _Im = 0, _Il = $_.numrows - 1; _Im <= _Il; _Im += 1) {
      $_.r = _Im;
      if ($_.r != 0) {
        $aload($get($_.seps, $_.r));
      }
      for (var _Is = 0, _It = $_.barxmult; _Is < _It; _Is++) {
        $aload($get($_.rows, $_.r));
      }
      if ($_.r != $_.numrows - 1) {
        $aload($get($_.seps, $_.r));
        $aload($_.sep);
      }
    }
    $_.pixs = $a();
    var _JC = /* @__PURE__ */ new Map([
      ["ren", "renmatrix"],
      ["pixs", $_.pixs],
      ["pixx", $_.pixx],
      ["pixy", ~~($_.pixs.length / $_.pixx)],
      ["height", ~~($_.pixs.length / $_.pixx) / 72],
      ["width", $_.pixx / 72],
      ["borderleft", 0],
      ["borderright", 0],
      ["bordertop", 0],
      ["borderbottom", 0],
      ["opt", $_.options]
    ]);
    $k[$j++] = _JC;
    if (!$_.dontdraw) {
      bwipp_renmatrix();
    }
  }
  $_ = $__;
}
function bwipp_databarexpandedstacked() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $put($_.options, "dontdraw", true);
  $put($_.options, "format", "expandedstacked");
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_databarexpanded();
  var _6 = $k[--$j];
  $_[$k[--$j]] = _6;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_gs1northamericancoupon() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.coupontextfont = "OCR-B";
  $_.coupontextsize = 9;
  $_.coupontextxoffset = null;
  $_.coupontextyoffset = null;
  $_.parse = false;
  $_.dontlint = false;
  $_.lintreqs = true;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $k[$j++] = $_.barcode;
  $k[$j++] = "ai";
  bwipp_gs1process();
  $j--;
  $_.vals = $k[--$j];
  $_.ais = $k[--$j];
  if ($_.ais.length != 1) {
    $k[$j++] = "bwipp.gs1northamericancouponBadAIStructure#11001";
    $k[$j++] = "A GS1 North American Coupon should consist of a single AI (8110)";
    bwipp_raiseerror();
  }
  if ($ne($get($_.ais, 0), "8110")) {
    $k[$j++] = "bwipp.gs1northamericancouponBadAIStructure#11004";
    $k[$j++] = "A GS1 North American Coupon should consist of a single AI (8110)";
    bwipp_raiseerror();
  }
  $_.val = $get($_.vals, 0);
  $_.vli = $get($_.val, 0) - 48;
  if ($_.vli < 0 || $_.vli > 6) {
    $k[$j++] = "bwipp.gs1northamericancouponBadVLI#11011";
    $k[$j++] = "The AI (8110) data should start with a Company Prefix length indicator in the range 0 to 6";
    bwipp_raiseerror();
  }
  $_.gcp = $geti($_.val, 1, $_.vli + 6);
  $_.cod = $geti($_.val, $_.vli + 7, 6);
  $_.coupontext = $s($_.gcp.length + 7);
  $puti($_.coupontext, 0, $_.gcp);
  $puti($_.coupontext, $_.gcp.length, "-");
  $puti($_.coupontext, $_.gcp.length + 1, $_.cod);
  $put($_.options, "dontdraw", true);
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_databarexpandedstacked();
  var _W = $k[--$j];
  $_[$k[--$j]] = _W;
  if ($_.includetext) {
    if ($_.coupontextxoffset == null) {
      $_.coupontextxoffset = 0;
    }
    if ($_.coupontextyoffset == null) {
      $_.coupontextyoffset = $get($_.args, "height") * 72 + 3;
    }
    var _e = $get($_.args, "txt") !== void 0;
    if (_e) {
      $_.txt = $get($_.args, "txt");
      $_.newtxt = $a($_.txt.length + 1);
      $puti($_.newtxt, 0, $_.txt);
      $put($_.newtxt, $_.newtxt.length - 1, $a([$_.coupontext, $_.coupontextxoffset, $_.coupontextyoffset, $_.coupontextfont, $_.coupontextsize]));
      $put($_.args, "txt", $_.newtxt);
    } else {
      $put($_.args, "txt", $a([$a([$_.coupontext, $_.coupontextxoffset, $_.coupontextyoffset, $_.coupontextfont, $_.coupontextsize])]));
    }
  }
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_pharmacode() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.height = 8 * 2.835 / 72;
  $_.nwidth = 0.5 * 2.835;
  $_.wwidth = 1.5 * 2.835;
  $_.swidth = 1 * 2.835;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length < 1 || $_.barcode.length > 6) {
    $k[$j++] = "bwipp.pharmacodeBadLength#11091";
    $k[$j++] = "Pharmacode must be 1 to 6 digits";
    bwipp_raiseerror();
  }
  $forall($_.barcode, function() {
    var _5 = $k[--$j];
    if (_5 < 48 || _5 > 57) {
      $k[$j++] = "bwipp.pharmacodeBadCharacter#11095";
      $k[$j++] = "Pharmacode must contain only digits";
      bwipp_raiseerror();
    }
  });
  var _7 = $cvi($_.barcode);
  if (_7 < 3 || _7 > 131070) {
    $k[$j++] = "bwipp.pharmacodeBadValue#11099";
    $k[$j++] = "Pharmacode value must be between 3 and 131070";
    bwipp_raiseerror();
  }
  $_.txt = $a($_.barcode.length);
  for (var _C = 0, _B = $_.barcode.length - 1; _C <= _B; _C += 1) {
    $_.i = _C;
    $put($_.txt, $_.i, $a([$geti($_.barcode, $_.i, 1), 0, 0, "", 0]));
  }
  $_.barcode = $cvrs($s(17), $cvi($_.barcode) + 1, 2);
  $_.barcode = $geti($_.barcode, 1, $_.barcode.length - 1);
  $_.barlen = $_.barcode.length;
  $_.sbs = $a($_.barlen * 2);
  for (var _U = 0, _T = $_.barlen - 1; _U <= _T; _U += 1) {
    $_.i = _U;
    $_.enc = $geti($_.barcode, $_.i, 1);
    if ($eq($_.enc, "0")) {
      $put($_.sbs, $_.i * 2, $_.nwidth);
    } else {
      $put($_.sbs, $_.i * 2, $_.wwidth);
    }
    $put($_.sbs, $_.i * 2 + 1, $_.swidth);
  }
  $k[$j++] = Infinity;
  var _i = $_.sbs;
  $k[$j++] = Infinity;
  for (var _k = 0, _l = ~~(($_.sbs.length + 1) / 2); _k < _l; _k++) {
    $k[$j++] = $_.height;
  }
  var _n = $a();
  $k[$j++] = Infinity;
  for (var _p = 0, _q = ~~(($_.sbs.length + 1) / 2); _p < _q; _p++) {
    $k[$j++] = 0;
  }
  var _r = $a();
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "sbs";
  $k[$j++] = _i;
  $k[$j++] = "bhs";
  $k[$j++] = _n;
  $k[$j++] = "bbs";
  $k[$j++] = _r;
  $k[$j++] = "txt";
  $k[$j++] = $_.txt;
  $k[$j++] = "textxalign";
  $k[$j++] = "center";
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  var _u = $d();
  $k[$j++] = _u;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_pharmacode2() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.height = 4;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length < 1 || $_.barcode.length > 8) {
    $k[$j++] = "bwipp.pharmacode2BadLength#11180";
    $k[$j++] = "Two-track Pharmacode must be 1 to 6 digits";
    bwipp_raiseerror();
  }
  $forall($_.barcode, function() {
    var _5 = $k[--$j];
    if (_5 < 48 || _5 > 57) {
      $k[$j++] = "bwipp.pharmacode2badCharacter#11184";
      $k[$j++] = "Two-track Pharmacode must contain only digits";
      bwipp_raiseerror();
    }
  });
  var _7 = $cvi($_.barcode);
  if (_7 < 4 || _7 > 64570080) {
    $k[$j++] = "bwipp.pharmacode2badValue#11188";
    $k[$j++] = "Two-track Pharmacode value must be between 4 and 64570080";
    bwipp_raiseerror();
  }
  $_.txt = $a($_.barcode.length);
  for (var _C = 0, _B = $_.barcode.length - 1; _C <= _B; _C += 1) {
    $_.i = _C;
    $put($_.txt, $_.i, $a([$geti($_.barcode, $_.i, 1), 0, 0, "", 0]));
  }
  $_.encstr = $s(16);
  $_.sbs = $a(32);
  $_.bar = 1 / 25.4 * $_.height;
  $_.spc = 1 / 25.4 * 72;
  $_.i = 15;
  $_.val = $cvi($_.barcode);
  for (; ; ) {
    if ($_.val == 0) {
      break;
    }
    var _P = $_.val % 3;
    $_.val = ~~($f($_.val - $get($a([3, 1, 2]), _P)) / 3);
    $put($_.encstr, $_.i, $get($a([2, 0, 1]), _P));
    $_.i = $_.i - 1;
  }
  $_.encstr = $geti($_.encstr, $_.i + 1, 15 - $_.i);
  $_.bhs = $a($_.encstr.length);
  $_.bbs = $a($_.encstr.length);
  for (var _i = 0, _h = $_.encstr.length - 1; _i <= _h; _i += 1) {
    $_.i = _i;
    var _l = $get($_.encstr, $_.i);
    $put($_.bhs, $_.i, $_.bar * $get($a([1, 1, 2]), _l));
    $put($_.bbs, $_.i, $get($a([0, $_.bar, 0]), _l));
  }
  $k[$j++] = Infinity;
  var _w = $_.bhs;
  var _x = $_.bbs;
  $k[$j++] = Infinity;
  for (var _z = 0, _10 = $_.encstr.length * 2; _z < _10; _z++) {
    $k[$j++] = $_.spc;
  }
  var _12 = $a();
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "bhs";
  $k[$j++] = _w;
  $k[$j++] = "bbs";
  $k[$j++] = _x;
  $k[$j++] = "sbs";
  $k[$j++] = _12;
  $k[$j++] = "txt";
  $k[$j++] = $_.txt;
  $k[$j++] = "textxalign";
  $k[$j++] = "center";
  $k[$j++] = "textyoffset";
  $k[$j++] = 4;
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  var _15 = $d();
  $k[$j++] = _15;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_code2of5() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includecheck = false;
  $_.validatecheck = false;
  $_.includetext = false;
  $_.includecheckintext = false;
  $_.textfont = "OCR-B";
  $_.textsize = 10;
  $_.textyoffset = -8;
  $_.height = 1;
  $_.version = "industrial";
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length == 0) {
    $k[$j++] = "bwipp.code2of5emptyData#11287";
    $k[$j++] = "The data must not be empty";
    bwipp_raiseerror();
  }
  $forall($_.barcode, function() {
    var _4 = $k[--$j];
    if (_4 < 48 || _4 > 57) {
      $k[$j++] = "bwipp.code2of5badCharacter#11295";
      $k[$j++] = "Code 25 must contain only digits";
      bwipp_raiseerror();
    }
  });
  $k[$j++] = "barlen";
  $k[$j++] = $_.barcode.length;
  if ($_.validatecheck) {
    var _7 = $k[--$j];
    $k[$j++] = _7 - 1;
  }
  var _8 = $k[--$j];
  $_[$k[--$j]] = _8;
  $_.checksum = 0;
  for (var _C = 0, _B = $_.barlen - 1; _C <= _B; _C += 1) {
    $_.i = _C;
    $k[$j++] = "checksum";
    $k[$j++] = $_.checksum;
    $k[$j++] = $get($_.barcode, $_.i) - 48;
    if ($f($_.barlen - $_.i) % 2 != 0) {
      var _J = $k[--$j];
      $k[$j++] = _J * 3;
    }
    var _K = $k[--$j];
    var _L = $k[--$j];
    $_[$k[--$j]] = $f(_L + _K);
  }
  $_.checksum = (10 - $_.checksum % 10) % 10;
  if ($_.validatecheck) {
    if ($get($_.barcode, $_.barlen) != $_.checksum + 48) {
      $k[$j++] = "bwipp.code2of5badCheckDigit#11309";
      $k[$j++] = "Incorrect Code 25 check digit provided";
      bwipp_raiseerror();
    }
    $_.barcode = $geti($_.barcode, 0, $_.barlen);
    $_.includecheck = true;
  }
  var _b = /* @__PURE__ */ new Map([
    ["industrial", $a(["1111313111", "3111111131", "1131111131", "3131111111", "1111311131", "3111311111", "1131311111", "1111113131", "3111113111", "1131113111", "313111", "31113"])],
    ["iata", $a(["1111313111", "3111111131", "1131111131", "3131111111", "1111311131", "3111311111", "1131311111", "1111113131", "3111113111", "1131113111", "1111", "311"])],
    ["matrix", $a(["113311", "311131", "131131", "331111", "113131", "313111", "133111", "111331", "311311", "131311", "311111", "31111"])],
    ["coop", $a(["331111", "111331", "113131", "113311", "131131", "131311", "133111", "311131", "311311", "313111", "3131", "133"])],
    ["datalogic", $a(["113311", "311131", "131131", "331111", "113131", "313111", "133111", "111331", "311311", "131311", "1111", "311"])]
  ]);
  $_.versions = _b;
  var _f = $get($_.versions, $_.version) !== void 0;
  if (!_f) {
    $k[$j++] = "bwipp.code2of5badVersion#11344";
    $k[$j++] = "Unrecognised Code 25 version";
    bwipp_raiseerror();
  }
  $_.encs = $get($_.versions, $_.version);
  $_.cs = $get($_.encs, 0).length;
  $k[$j++] = "cw";
  $k[$j++] = 0;
  $forall($get($_.encs, 0), function() {
    var _n = $k[--$j];
    var _o = $k[--$j];
    $k[$j++] = $f(_o + (_n - 48));
  });
  var _p = $k[--$j];
  $_[$k[--$j]] = _p;
  $_.ss = $get($_.encs, 10).length;
  $k[$j++] = "sw";
  $k[$j++] = 0;
  $forall($get($_.encs, 10), function() {
    var _v = $k[--$j];
    var _w = $k[--$j];
    $k[$j++] = $f(_w + (_v - 48));
  });
  var _x = $k[--$j];
  $_[$k[--$j]] = _x;
  $_.es = $get($_.encs, 11).length;
  $_.barchars = "0123456789";
  $k[$j++] = "sbs";
  $k[$j++] = $_.barlen;
  if ($_.includecheck) {
    var _14 = $k[--$j];
    $k[$j++] = _14 + 1;
  }
  var _19 = $s($f($k[--$j] * $_.cs + $_.ss + $_.es));
  $_[$k[--$j]] = _19;
  $k[$j++] = "txt";
  $k[$j++] = $_.barlen;
  if ($_.includecheck) {
    var _1D = $k[--$j];
    $k[$j++] = _1D + 1;
  }
  var _1F = $a($k[--$j]);
  $_[$k[--$j]] = _1F;
  $puti($_.sbs, 0, $get($_.encs, 10));
  for (var _1M = 0, _1L = $_.barlen - 1; _1M <= _1L; _1M += 1) {
    $_.i = _1M;
    $search($_.barchars, $geti($_.barcode, $_.i, 1));
    $j--;
    $_.indx = $k[--$j].length;
    $j -= 2;
    $_.enc = $get($_.encs, $_.indx);
    $puti($_.sbs, $_.i * $_.cs + $_.ss, $_.enc);
    $put($_.txt, $_.i, $a([$geti($_.barcode, $_.i, 1), $f($_.i * $_.cw + $_.sw), $_.textyoffset, $_.textfont, $_.textsize]));
  }
  if ($_.includecheck) {
    $puti($_.sbs, $f($_.barlen * $_.cs + $_.ss), $get($_.encs, $_.checksum));
    $puti($_.sbs, $f($_.barlen * $_.cs + $_.cs + $_.ss), $get($_.encs, 11));
    if ($_.includecheckintext) {
      $put($_.txt, $_.barlen, $a([$geti($_.barchars, $_.checksum, 1), $f($_.barlen * $_.cw + $_.sw), $_.textyoffset, $_.textfont, $_.textsize]));
    } else {
      $put($_.txt, $_.barlen, $a([" ", $f($_.barlen * $_.cw + $_.sw), $_.textyoffset, $_.textfont, $_.textsize]));
    }
  } else {
    $puti($_.sbs, $f($_.barlen * $_.cs + $_.ss), $get($_.encs, 11));
  }
  $k[$j++] = Infinity;
  $k[$j++] = Infinity;
  $forall($_.sbs, function() {
    var _2U = $k[--$j];
    $k[$j++] = _2U - 48;
  });
  var _2V = $a();
  $k[$j++] = Infinity;
  for (var _2X = 0, _2Y = ~~(($_.sbs.length + 1) / 2); _2X < _2Y; _2X++) {
    $k[$j++] = $_.height;
  }
  var _2a = $a();
  $k[$j++] = Infinity;
  for (var _2c = 0, _2d = ~~(($_.sbs.length + 1) / 2); _2c < _2d; _2c++) {
    $k[$j++] = 0;
  }
  var _2e = $a();
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "sbs";
  $k[$j++] = _2V;
  $k[$j++] = "bhs";
  $k[$j++] = _2a;
  $k[$j++] = "bbs";
  $k[$j++] = _2e;
  if ($_.includetext) {
    $k[$j++] = "txt";
    $k[$j++] = $_.txt;
  }
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  var _2i = $d();
  $k[$j++] = _2i;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_industrial2of5() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $put($_.options, "dontdraw", true);
  $put($_.options, "version", "industrial");
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_code2of5();
  var _6 = $k[--$j];
  $_[$k[--$j]] = _6;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_iata2of5() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $put($_.options, "dontdraw", true);
  $put($_.options, "version", "iata");
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_code2of5();
  var _6 = $k[--$j];
  $_[$k[--$j]] = _6;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_matrix2of5() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $put($_.options, "dontdraw", true);
  $put($_.options, "version", "matrix");
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_code2of5();
  var _6 = $k[--$j];
  $_[$k[--$j]] = _6;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_coop2of5() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $put($_.options, "dontdraw", true);
  $put($_.options, "version", "coop");
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_code2of5();
  var _6 = $k[--$j];
  $_[$k[--$j]] = _6;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_datalogic2of5() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $put($_.options, "dontdraw", true);
  $put($_.options, "version", "datalogic");
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_code2of5();
  var _6 = $k[--$j];
  $_[$k[--$j]] = _6;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_code11() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includecheck = false;
  $_.validatecheck = false;
  $_.includetext = false;
  $_.includecheckintext = false;
  $_.textfont = "OCR-B";
  $_.textsize = 10;
  $_.textyoffset = -8;
  $_.height = 1;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length == 0) {
    $k[$j++] = "bwipp.code11emptyData#11692";
    $k[$j++] = "The data must not be empty";
    bwipp_raiseerror();
  }
  $_.encs = $a(["111131", "311131", "131131", "331111", "113131", "313111", "133111", "111331", "311311", "311111", "113111", "113311"]);
  $_.barchars = "0123456789-";
  $_.charvals = /* @__PURE__ */ new Map();
  for (var _4 = 0; _4 <= 10; _4 += 1) {
    $put($_.charvals, $geti($_.barchars, _4, 1), _4);
  }
  for (var _B = 0, _A = $_.barcode.length - 1; _B <= _A; _B += 1) {
    var _F = $get($_.charvals, $geti($_.barcode, _B, 1)) !== void 0;
    if (!_F) {
      $k[$j++] = "bwipp.code11badCharacter#11714";
      $k[$j++] = "Code 11 must contain only digits and dashes";
      bwipp_raiseerror();
    }
  }
  $_.barlen = $_.barcode.length;
  if ($_.validatecheck) {
    if ($_.barlen == 11) {
      $k[$j++] = "bwipp.code11badLength#11721";
      $k[$j++] = "Code 11 cannot be 11 characters using check digits";
      bwipp_raiseerror();
    }
    var _L = $_.barlen <= 10 ? 1 : 2;
    $_.barlen = $_.barlen - _L;
  }
  $k[$j++] = "numchecks";
  if ($_.includecheck || $_.validatecheck) {
    var _P = $_.barlen >= 10 ? 2 : 1;
    $k[$j++] = _P;
  } else {
    $k[$j++] = 0;
  }
  var _Q = $k[--$j];
  $_[$k[--$j]] = _Q;
  $_.checksum1 = 0;
  $_.checksum2 = 0;
  for (var _U = 0, _T = $_.barlen - 1; _U <= _T; _U += 1) {
    $_.i = _U;
    $_.indx = $get($_.charvals, $geti($_.barcode, $_.i, 1));
    $_.checksum1 = $f($_.checksum1 + (($_.barlen - $_.i - 1) % 10 + 1) * $_.indx);
    $_.checksum2 = $f($_.checksum2 + (($_.barlen - $_.i) % 9 + 1) * $_.indx);
  }
  $_.checksum1 = $_.checksum1 % 11;
  $_.checksum2 = $f($_.checksum2 + $_.checksum1) % 11;
  if ($_.validatecheck) {
    if ($_.numchecks == 1) {
      var _r = $_.checksum1;
      if ($get($_.barcode, $_.barlen) != $get($_.barchars, _r)) {
        $k[$j++] = "bwipp.code11badCheckDigit#11739";
        $k[$j++] = "Incorrect Code 11 check digit provided";
        bwipp_raiseerror();
      }
    } else {
      if ($get($_.barcode, $_.barlen) != $get($_.barchars, $_.checksum1) || $get($_.barcode, $_.barlen + 1) != $get($_.barchars, $_.checksum2)) {
        $k[$j++] = "bwipp.code11badCheckDigits#11744";
        $k[$j++] = "Incorrect Code 11 check digits provided";
        bwipp_raiseerror();
      }
    }
    $_.barcode = $geti($_.barcode, 0, $_.barlen);
    $_.includecheck = true;
  }
  $_.sbs = $s($f($_.barlen + $_.numchecks) * 6 + 12);
  $_.txt = $a($f($_.barlen + $_.numchecks));
  $puti($_.sbs, 0, $get($_.encs, 11));
  $_.xpos = 8;
  for (var _1J = 0, _1I = $_.barlen - 1; _1J <= _1I; _1J += 1) {
    $_.i = _1J;
    $_.indx = $get($_.charvals, $geti($_.barcode, $_.i, 1));
    $_.enc = $get($_.encs, $_.indx);
    $puti($_.sbs, $_.i * 6 + 6, $_.enc);
    $put($_.txt, $_.i, $a([$geti($_.barcode, $_.i, 1), $_.xpos, $_.textyoffset, $_.textfont, $_.textsize]));
    for (var _1f = 0; _1f <= 5; _1f += 1) {
      $_.xpos = $f($get($_.enc, _1f) - 48 + $_.xpos);
    }
  }
  if ($_.includecheck) {
    if ($_.barlen >= 10) {
      $puti($_.sbs, $_.barlen * 6 + 6, $get($_.encs, $_.checksum1));
      $puti($_.sbs, $_.barlen * 6 + 12, $get($_.encs, $_.checksum2));
      if ($_.includecheckintext) {
        $put($_.txt, $_.barlen, $a([$geti($_.barchars, $_.checksum1, 1), $_.xpos, $_.textyoffset, $_.textfont, $_.textsize]));
        $_.enc = $get($_.encs, $_.checksum1);
        for (var _29 = 0; _29 <= 5; _29 += 1) {
          $_.xpos = $f($get($_.enc, _29) - 48 + $_.xpos);
        }
        $put($_.txt, $_.barlen + 1, $a([$geti($_.barchars, $_.checksum2, 1), $_.xpos, $_.textyoffset, $_.textfont, $_.textsize]));
      } else {
        $put($_.txt, $_.barlen, $a(["", $_.xpos, $_.textyoffset, $_.textfont, $_.textsize]));
        $put($_.txt, $_.barlen + 1, $a(["", $_.xpos, $_.textyoffset, $_.textfont, $_.textsize]));
      }
      $puti($_.sbs, $_.barlen * 6 + 18, $get($_.encs, 11));
    } else {
      $puti($_.sbs, $_.barlen * 6 + 6, $get($_.encs, $_.checksum1));
      if ($_.includecheckintext) {
        $put($_.txt, $_.barlen, $a([$geti($_.barchars, $_.checksum1, 1), $_.xpos, $_.textyoffset, $_.textfont, $_.textsize]));
      } else {
        $put($_.txt, $_.barlen, $a(["", $_.xpos, $_.textyoffset, $_.textfont, $_.textsize]));
      }
      $puti($_.sbs, $_.barlen * 6 + 12, $get($_.encs, 11));
    }
  } else {
    $puti($_.sbs, $_.barlen * 6 + 6, $get($_.encs, 11));
  }
  $k[$j++] = Infinity;
  $k[$j++] = Infinity;
  var _3A = $_.sbs;
  for (var _3B = 0, _3C = _3A.length; _3B < _3C; _3B++) {
    $k[$j++] = $get(_3A, _3B) - 48;
  }
  var _3E = $a();
  $k[$j++] = Infinity;
  for (var _3G = 0, _3H = ~~(($_.sbs.length + 1) / 2); _3G < _3H; _3G++) {
    $k[$j++] = $_.height;
  }
  var _3J = $a();
  $k[$j++] = Infinity;
  for (var _3L = 0, _3M = ~~(($_.sbs.length + 1) / 2); _3L < _3M; _3L++) {
    $k[$j++] = 0;
  }
  var _3N = $a();
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "sbs";
  $k[$j++] = _3E;
  $k[$j++] = "bhs";
  $k[$j++] = _3J;
  $k[$j++] = "bbs";
  $k[$j++] = _3N;
  if ($_.includetext) {
    $k[$j++] = "txt";
    $k[$j++] = $_.txt;
  }
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  var _3R = $d();
  $k[$j++] = _3R;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_bc412() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includecheck = false;
  $_.validatecheck = false;
  $_.includetext = false;
  $_.includecheckintext = false;
  $_.includestartstop = false;
  $_.semi = false;
  $_.textfont = "OCR-B";
  $_.textsize = 10;
  $_.textyoffset = -8;
  $_.height = 1;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length == 0) {
    $k[$j++] = "bwipp.bc412emptyData#11864";
    $k[$j++] = "The data must not be empty";
    bwipp_raiseerror();
  }
  if ($_.semi) {
    $_.includestartstop = true;
  }
  $_.barchars = "0R9GLVHA8EZ4NTS1J2Q6C7DYKBUIX3FWP5M";
  $_.charvals = /* @__PURE__ */ new Map();
  for (var _4 = 0; _4 <= 34; _4 += 1) {
    $put($_.charvals, $geti($_.barchars, _4, 1), _4);
  }
  for (var _B = 0, _A = $_.barcode.length - 1; _B <= _A; _B += 1) {
    var _F = $get($_.charvals, $geti($_.barcode, _B, 1)) !== void 0;
    if (!_F) {
      $k[$j++] = "bwipp.bc412badCharacter#11884";
      $k[$j++] = "BC412 must contain only digits and capital letters except O";
      bwipp_raiseerror();
    }
  }
  if ($_.semi) {
    if ($_.validatecheck) {
      if ($_.barcode.length < 8 || $_.barcode.length > 19) {
        $k[$j++] = "bwipp.bc412semivalidateBadLength#11892";
        $k[$j++] = "BC412 semi with check digit must be 8 to 19 characters long";
        bwipp_raiseerror();
      }
    } else {
      if ($_.barcode.length < 7 || $_.barcode.length > 18) {
        $k[$j++] = "bwipp.bc412semiBadLength#11896";
        $k[$j++] = "BC412 semi must be 7 to 18 characters long";
        bwipp_raiseerror();
      }
    }
    $_.barlen = $_.barcode.length;
    if (!$_.validatecheck) {
      $_.barlen = $_.barlen + 1;
      $_.sbarcode = $s($_.barlen);
      $put($_.sbarcode, 0, $get($_.barcode, 0));
      $put($_.sbarcode, 1, 48);
      $puti($_.sbarcode, 2, $geti($_.barcode, 1, $_.barlen - 2));
      $_.barcode = $_.sbarcode;
    }
    $_.sumodd = 0;
    $_.sumeven = 0;
    for (var _c = 0, _b = $_.barlen - 1; _c <= _b; _c += 1) {
      $_.i = _c;
      $k[$j++] = $get($_.charvals, $geti($_.barcode, $_.i, 1));
      if ($_.i % 2 == 0) {
        $_.sumodd = $f($k[--$j] + $_.sumodd);
      } else {
        $_.sumeven = $f($k[--$j] + $_.sumeven);
      }
    }
    $_.checksum = $f($_.sumodd % 35 + $_.sumeven % 35 * 2) % 35;
    if ($_.validatecheck) {
      if ($_.checksum != 0) {
        $k[$j++] = "bwipp.bc412semiBadCheckDigit#11922";
        $k[$j++] = "Incorrect BC412 semi check digit provided";
        bwipp_raiseerror();
      }
    } else {
      $_.checksum = $_.checksum * 17 % 35;
      $put($_.barcode, 1, $get($_.barchars, $_.checksum));
    }
  } else {
    $k[$j++] = "barlen";
    $k[$j++] = $_.barcode.length;
    if ($_.validatecheck) {
      var _y = $k[--$j];
      $k[$j++] = _y - 1;
    }
    var _z = $k[--$j];
    $_[$k[--$j]] = _z;
    $_.checksum = 0;
    for (var _13 = 0, _12 = $_.barlen - 1; _13 <= _12; _13 += 1) {
      $_.checksum = $f($get($_.charvals, $geti($_.barcode, _13, 1)) + $_.checksum);
    }
    $_.checksum = $_.checksum % 35;
    if ($_.validatecheck) {
      if ($get($_.barcode, $_.barlen) != $get($_.barchars, $_.checksum)) {
        $k[$j++] = "bwipp.bc412badCheckDigit#11939";
        $k[$j++] = "Incorrect BC412 check digit provided";
        bwipp_raiseerror();
      }
      $_.barcode = $geti($_.barcode, 0, $_.barlen);
      $_.includecheck = true;
    }
  }
  $_.encs = $a(["11111115", "13111212", "11131113", "12111213", "12121311", "13131111", "12111312", "11131212", "11121411", "11151111", "15111111", "11111511", "12131211", "13121112", "13111311", "11111214", "12121113", "11111313", "13111113", "11121213", "11141112", "11121312", "11141211", "14121111", "12121212", "11131311", "13121211", "12111411", "14111211", "11111412", "12111114", "14111112", "12141111", "11121114", "12131112", "12", "111"]);
  $_.sbs = $s(($_.barlen + 1) * 8 + 5);
  if ($_.includecheck) {
    $_.txt = $a($_.barlen + 1);
  } else {
    $_.txt = $a($_.barlen);
  }
  if ($_.includestartstop) {
    $puti($_.sbs, 0, $get($_.encs, 35));
    $_.pos = 2;
    $_.txtpos = 3;
  } else {
    $_.pos = 0;
    $_.txtpos = 0;
  }
  for (var _1Z = 0, _1Y = $_.barlen - 1; _1Z <= _1Y; _1Z += 1) {
    $_.i = _1Z;
    $_.indx = $get($_.charvals, $geti($_.barcode, $_.i, 1));
    $puti($_.sbs, $_.pos, $get($_.encs, $_.indx));
    $put($_.txt, $_.i, $a([$geti($_.barcode, $_.i, 1), $_.i * 12 + $_.txtpos, $_.textyoffset, $_.textfont, $_.textsize]));
    $_.pos = $_.pos + 8;
  }
  if ($_.includecheck) {
    $puti($_.sbs, $_.pos, $get($_.encs, $_.checksum));
    if ($_.includecheckintext) {
      $put($_.txt, $_.barlen, $a([$geti($_.barchars, $_.checksum, 1), $_.barlen * 12 + $_.txtpos, $_.textyoffset, $_.textfont, $_.textsize]));
    } else {
      $put($_.txt, $_.barlen, $a(["", $_.barlen * 12 + $_.txtpos, $_.textyoffset, $_.textfont, $_.textsize]));
    }
    $_.pos = $_.pos + 8;
  }
  if ($_.includestartstop) {
    $puti($_.sbs, $_.pos, $get($_.encs, 36));
    $_.pos = $_.pos + 3;
  }
  $_.sbs = $geti($_.sbs, 0, $_.pos);
  $k[$j++] = Infinity;
  $k[$j++] = Infinity;
  var _2W = $_.sbs;
  for (var _2X = 0, _2Y = _2W.length; _2X < _2Y; _2X++) {
    $k[$j++] = $get(_2W, _2X) - 48;
  }
  var _2a = $a();
  $k[$j++] = Infinity;
  for (var _2c = 0, _2d = ~~(($_.sbs.length + 1) / 2); _2c < _2d; _2c++) {
    $k[$j++] = $_.height;
  }
  var _2f = $a();
  $k[$j++] = Infinity;
  for (var _2h = 0, _2i = ~~(($_.sbs.length + 1) / 2); _2h < _2i; _2h++) {
    $k[$j++] = 0;
  }
  var _2j = $a();
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "sbs";
  $k[$j++] = _2a;
  $k[$j++] = "bhs";
  $k[$j++] = _2f;
  $k[$j++] = "bbs";
  $k[$j++] = _2j;
  if ($_.includetext) {
    $k[$j++] = "txt";
    $k[$j++] = $_.txt;
  }
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  var _2n = $d();
  $k[$j++] = _2n;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_rationalizedCodabar() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.altstartstop = false;
  $_.includecheck = false;
  $_.validatecheck = false;
  $_.includetext = false;
  $_.includecheckintext = false;
  $_.textfont = "OCR-B";
  $_.textsize = 10;
  $_.textyoffset = -8;
  $_.height = 1;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length < 2 || $_.barcode.length < 3 && $_.validatecheck) {
    $k[$j++] = "bwipp.rationalizedCodabarBadLength#12067";
    $k[$j++] = "Codabar must be at least 2 characters in length excluding any check digit";
    bwipp_raiseerror();
  }
  $_.encs = $a(["11111331", "11113311", "11131131", "33111111", "11311311", "31111311", "13111131", "13113111", "13311111", "31131111", "11133111", "11331111", "31113131", "31311131", "31313111", "11313131", "11331311", "13131131", "11131331", "11133311"]);
  $_.barcharsnormal = "0123456789-$:/.+ABCD";
  $_.barcharsalt = "0123456789-$:/.+TN*E";
  var _8 = $_.altstartstop ? $_.barcharsalt : $_.barcharsnormal;
  $_.barchars = _8;
  $_.charvals = /* @__PURE__ */ new Map();
  for (var _9 = 0; _9 <= 19; _9 += 1) {
    $put($_.charvals, $geti($_.barchars, _9, 1), _9);
  }
  $_.bodyvals = /* @__PURE__ */ new Map();
  for (var _D = 0; _D <= 15; _D += 1) {
    $put($_.bodyvals, $geti($_.barchars, _D, 1), _D);
  }
  $_.ssvals = /* @__PURE__ */ new Map();
  for (var _H = 16; _H <= 19; _H += 1) {
    $put($_.ssvals, $geti($_.barchars, _H, 1), _H);
  }
  var _O = $get($_.ssvals, $geti($_.barcode, 0, 1)) !== void 0;
  var _T = $get($_.ssvals, $geti($_.barcode, $_.barcode.length - 1, 1)) !== void 0;
  if (!_O || !_T) {
    if ($_.altstartstop) {
      $k[$j++] = "bwipp.rationalizedCodabarBadAltStartStop#12099";
      $k[$j++] = "Codabar start and stop characters must be one of E N T or *";
      bwipp_raiseerror();
    } else {
      $k[$j++] = "bwipp.rationalizedCodabarBadStartStop#12101";
      $k[$j++] = "Codabar start and stop characters must be one of A B C or D";
      bwipp_raiseerror();
    }
  }
  for (var _X = 1, _W = $_.barcode.length - 2; _X <= _W; _X += 1) {
    var _b = $get($_.bodyvals, $geti($_.barcode, _X, 1)) !== void 0;
    if (!_b) {
      $k[$j++] = "bwipp.rationalizedCodabarBadCharacter#12106";
      $k[$j++] = "Codabar body must contain only digits and symbols - $ : / . +";
      bwipp_raiseerror();
    }
  }
  $k[$j++] = "barlen";
  $k[$j++] = $_.barcode.length;
  if ($_.validatecheck) {
    var _e = $k[--$j];
    $k[$j++] = _e - 1;
  }
  var _f = $k[--$j];
  $_[$k[--$j]] = _f;
  $_.checksum = 0;
  for (var _j = 0, _i = $_.barlen - 2; _j <= _i; _j += 1) {
    $_.checksum = $f($get($_.charvals, $geti($_.barcode, _j, 1)) + $_.checksum);
  }
  var _r = $geti($_.barcode, $_.barcode.length - 1, 1);
  $_.checksum = $f($get($_.charvals, _r) + $_.checksum);
  $_.checksum = (16 - $_.checksum % 16) % 16;
  if ($_.validatecheck) {
    if ($get($_.barcode, $_.barlen - 1) != $get($_.barchars, $_.checksum)) {
      $k[$j++] = "bwipp.rationalizedCodabarBadCheckDigit#12122";
      $k[$j++] = "Incorrect Codabar check digit provided";
      bwipp_raiseerror();
    }
    var _14 = $s($_.barlen);
    $puti(_14, 0, $geti($_.barcode, 0, $_.barlen - 1));
    $puti(_14, $_.barlen - 1, $geti($_.barcode, $_.barlen, 1));
    $_.barcode = _14;
    $_.includecheck = true;
  }
  $k[$j++] = "sbs";
  $k[$j++] = $_.barlen;
  if ($_.includecheck) {
    var _1E = $k[--$j];
    $k[$j++] = _1E + 1;
  }
  var _1G = $s($k[--$j] * 8);
  $_[$k[--$j]] = _1G;
  $k[$j++] = "txt";
  $k[$j++] = $_.barlen;
  if ($_.includecheck) {
    var _1K = $k[--$j];
    $k[$j++] = _1K + 1;
  }
  var _1M = $a($k[--$j]);
  $_[$k[--$j]] = _1M;
  $_.xpos = 0;
  for (var _1Q = 0, _1P = $_.barlen - 2; _1Q <= _1P; _1Q += 1) {
    $_.i = _1Q;
    $_.indx = $get($_.charvals, $geti($_.barcode, $_.i, 1));
    $_.enc = $get($_.encs, $_.indx);
    $puti($_.sbs, $_.i * 8, $_.enc);
    $put($_.txt, $_.i, $a([$geti($_.barcode, $_.i, 1), $_.xpos, $_.textyoffset, $_.textfont, $_.textsize]));
    for (var _1m = 0; _1m <= 7; _1m += 1) {
      $_.xpos = $f($get($_.enc, _1m) - 48 + $_.xpos);
    }
  }
  if ($_.includecheck) {
    $puti($_.sbs, $_.barlen * 8 - 8, $get($_.encs, $_.checksum));
    if ($_.includecheckintext) {
      $put($_.txt, $_.barlen - 1, $a([$geti($_.barchars, $_.checksum, 1), $_.xpos, $_.textyoffset, $_.textfont, $_.textsize]));
    } else {
      $put($_.txt, $_.barlen - 1, $a([" ", $_.xpos, $_.textyoffset, $_.textfont, $_.textsize]));
    }
    for (var _2E = 0; _2E <= 7; _2E += 1) {
      $_.xpos = $f($get($get($_.encs, $_.checksum), _2E) - 48 + $_.xpos);
    }
    $_.indx = $get($_.charvals, $geti($_.barcode, $_.barlen - 1, 1));
    $_.enc = $get($_.encs, $_.indx);
    $puti($_.sbs, $_.barlen * 8, $_.enc);
    $put($_.txt, $_.barlen, $a([$geti($_.barcode, $_.barlen - 1, 1), $_.xpos, $_.textyoffset, $_.textfont, $_.textsize]));
  } else {
    $_.indx = $get($_.charvals, $geti($_.barcode, $_.barlen - 1, 1));
    $_.enc = $get($_.encs, $_.indx);
    $puti($_.sbs, $_.barlen * 8 - 8, $_.enc);
    $put($_.txt, $_.barlen - 1, $a([$geti($_.barcode, $_.barlen - 1, 1), $_.xpos, $_.textyoffset, $_.textfont, $_.textsize]));
  }
  $k[$j++] = Infinity;
  $k[$j++] = Infinity;
  $forall($_.sbs, function() {
    var _31 = $k[--$j];
    $k[$j++] = _31 - 48;
  });
  var _32 = $a();
  $k[$j++] = Infinity;
  for (var _34 = 0, _35 = ~~(($_.sbs.length + 1) / 2); _34 < _35; _34++) {
    $k[$j++] = $_.height;
  }
  var _37 = $a();
  $k[$j++] = Infinity;
  for (var _39 = 0, _3A = ~~(($_.sbs.length + 1) / 2); _39 < _3A; _39++) {
    $k[$j++] = 0;
  }
  var _3B = $a();
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "sbs";
  $k[$j++] = _32;
  $k[$j++] = "bhs";
  $k[$j++] = _37;
  $k[$j++] = "bbs";
  $k[$j++] = _3B;
  if ($_.includetext) {
    $k[$j++] = "txt";
    $k[$j++] = $_.txt;
  }
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  var _3F = $d();
  $k[$j++] = _3F;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_onecode() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.height = 0.15;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $_.barlen = $_.barcode.length;
  $forall($_.barcode, function() {
    var _4 = $k[--$j];
    if (_4 < 48 || _4 > 57) {
      $k[$j++] = "bwipp.onecodeBadCharacter#12232";
      $k[$j++] = "The data must contain only digits";
      bwipp_raiseerror();
    }
  });
  if ($_.barlen != 20 && $_.barlen != 25 && $_.barlen != 29 && $_.barlen != 31) {
    $k[$j++] = "bwipp.onecodeInvalidLength#12237";
    $k[$j++] = "The data must be 20, 25, 29 or 31 digits";
    bwipp_raiseerror();
  }
  $k[$j++] = Infinity;
  var _B = $eq($geti($_.barcode, 5, 1), "9") ? 14 : 11;
  $k[$j++] = 2;
  $k[$j++] = 2;
  $k[$j++] = 5;
  $k[$j++] = 5;
  $k[$j++] = _B;
  $k[$j++] = _B;
  $k[$j++] = 20;
  $k[$j++] = 20;
  $k[$j++] = 25;
  $k[$j++] = 25;
  $k[$j++] = 29;
  $k[$j++] = 29;
  $_.txtdict = $d();
  $_.txt = $a($_.barlen + 6);
  $_.spacecnt = 0;
  for (var _H = 0, _G = $_.barlen - 1; _H <= _G; _H += 1) {
    $_.i = _H;
    var _K = $get($_.txtdict, $_.i) !== void 0;
    if (_K) {
      $put($_.txt, $_.i + $_.spacecnt, $a([" ", 0, 0, "", 0]));
      $_.spacecnt = $_.spacecnt + 1;
    }
    $put($_.txt, $_.i + $_.spacecnt, $a([$geti($_.barcode, $_.i, 1), 0, 0, "", 0]));
  }
  $_.txt = $geti($_.txt, 0, $_.barcode.length + $_.spacecnt);
  $_.normalize = function() {
    $_.base = $k[--$j];
    $_.num = $k[--$j];
    for (var _e = $_.num.length - 1; _e >= 1; _e -= 1) {
      $_.i = _e;
      var _f = $_.num;
      var _g = $_.i;
      $put(_f, _g - 1, $f($get(_f, _g - 1) + ~~($get($_.num, $_.i) / $_.base)));
      $put($_.num, $_.i, $get($_.num, $_.i) % $_.base);
    }
    for (; ; ) {
      if ($lt($get($_.num, 0), $_.base)) {
        break;
      }
      $k[$j++] = Infinity;
      $k[$j++] = 0;
      $aload($_.num);
      $_.num = $a();
      $put($_.num, 0, $f($get($_.num, 0) + ~~($get($_.num, 1) / $_.base)));
      $put($_.num, 1, $get($_.num, 1) % $_.base);
    }
    $k[$j++] = Infinity;
    $_.i = true;
    var _17 = $_.num;
    for (var _18 = 0, _19 = _17.length; _18 < _19; _18++) {
      var _1A = $get(_17, _18);
      $k[$j++] = _1A;
      if (_1A == 0 && $_.i) {
        $j--;
      } else {
        $_.i = false;
      }
    }
    $_.num = $a();
    if ($_.num.length == 0) {
      $_.num = $a([0]);
    }
    $k[$j++] = $_.num;
  };
  $_.bigadd = function() {
    var _1G = $k[--$j];
    var _1H = $k[--$j];
    $_.offset = $abs(_1G.length - _1H.length);
    if (_1G.length < _1H.length) {
      var _ = _1G;
      _1G = _1H;
      _1H = _;
    }
    $_.a = _1G;
    $_.b = _1H;
    for (var _1K = 0, _1J = $_.b.length - 1; _1K <= _1J; _1K += 1) {
      var _1L = $_.a;
      var _1M = $_.offset;
      $put(_1L, _1K + _1M, $f($get(_1L, _1K + _1M) + $get($_.b, _1K)));
    }
    $k[$j++] = $_.a;
  };
  var _1V = /* @__PURE__ */ new Map([
    [20, $a([0])],
    [25, $a([1])],
    [29, $a([1, 0, 0, 0, 0, 1])],
    [31, $a([1, 0, 0, 0, 1, 0, 0, 0, 0, 1])]
  ]);
  $_.startvals = _1V;
  $k[$j++] = "binval";
  $k[$j++] = $get($_.startvals, $_.barlen);
  $k[$j++] = Infinity;
  var _1c = $geti($_.barcode, 20, $_.barlen - 20);
  for (var _1d = 0, _1e = _1c.length; _1d < _1e; _1d++) {
    $k[$j++] = $get(_1c, _1d) - 48;
  }
  var _1g = $a();
  $k[$j++] = _1g;
  $_.bigadd();
  var _1h = $k[--$j];
  $_[$k[--$j]] = _1h;
  $k[$j++] = Infinity;
  $aload($_.binval);
  $k[$j++] = $get($_.barcode, 0) - 48;
  $_.binval = $a();
  $k[$j++] = Infinity;
  var _1n = $_.binval;
  for (var _1o = 0, _1p = _1n.length; _1o < _1p; _1o++) {
    $k[$j++] = $get(_1n, _1o) * 5;
  }
  var _1r = $a();
  $k[$j++] = "binval";
  $k[$j++] = _1r;
  $k[$j++] = $a([$get($_.barcode, 1) - 48]);
  $_.bigadd();
  $k[$j++] = 10;
  $_.normalize();
  var _1v = $k[--$j];
  $_[$k[--$j]] = _1v;
  $k[$j++] = Infinity;
  $aload($_.binval);
  var _1z = $geti($_.barcode, 2, 18);
  for (var _20 = 0, _21 = _1z.length; _20 < _21; _20++) {
    $k[$j++] = $get(_1z, _20) - 48;
  }
  $_.binval = $a();
  $_.bytes = $a(13);
  var _25 = $_.binval;
  $_.bintmp = $arrcpy($a(_25.length), _25);
  for (var _28 = 12; _28 >= 0; _28 -= 1) {
    $_.i = _28;
    for (var _2B = 0, _2A = $_.bintmp.length - 2; _2B <= _2A; _2B += 1) {
      $_.j = _2B;
      var _2C = $_.bintmp;
      var _2D = $_.j;
      $put(_2C, _2D + 1, $f($get(_2C, _2D + 1) + $get($_.bintmp, $_.j) % 256 * 10));
      $put($_.bintmp, $_.j, ~~($get($_.bintmp, $_.j) / 256));
    }
    $put($_.bytes, $_.i, $get($_.bintmp, $_.bintmp.length - 1) % 256);
    var _2S = $_.bintmp;
    var _2T = $_.bintmp;
    $put(_2S, _2T.length - 1, ~~($get(_2S, _2T.length - 1) / 256));
  }
  $_.fcs = 2047;
  $_.dat = $get($_.bytes, 0) << 5;
  for (var _2X = 0; _2X < 6; _2X++) {
    if ((($_.fcs ^ $_.dat) & 1024) != 0) {
      $_.fcs = $_.fcs << 1 ^ 3893;
    } else {
      $_.fcs = $_.fcs << 1;
    }
    $_.fcs = $_.fcs & 2047;
    $_.dat = $_.dat << 1;
  }
  for (var _2e = 1; _2e <= 12; _2e += 1) {
    $_.dat = $get($_.bytes, _2e) << 3;
    for (var _2h = 0; _2h < 8; _2h++) {
      if ((($_.fcs ^ $_.dat) & 1024) != 0) {
        $_.fcs = $_.fcs << 1 ^ 3893;
      } else {
        $_.fcs = $_.fcs << 1;
      }
      $_.fcs = $_.fcs & 2047;
      $_.dat = $_.dat << 1;
    }
  }
  $_.codewords = $a(10);
  for (var _2p = 9; _2p >= 0; _2p -= 1) {
    $_.i = _2p;
    var _2r = $_.i == 9 ? 636 : 1365;
    $_.b = _2r;
    for (var _2u = 0, _2t = $_.binval.length - 2; _2u <= _2t; _2u += 1) {
      $_.j = _2u;
      var _2v = $_.binval;
      var _2w = $_.j;
      $put(_2v, _2w + 1, $f($get(_2v, _2w + 1) + $get($_.binval, $_.j) % $_.b * 10));
      $put($_.binval, $_.j, ~~($get($_.binval, $_.j) / $_.b));
    }
    $put($_.codewords, $_.i, $get($_.binval, $_.binval.length - 1) % $_.b);
    var _3E = $_.binval;
    var _3F = $_.binval;
    $put(_3E, _3F.length - 1, ~~($get(_3E, _3F.length - 1) / $_.b));
  }
  $put($_.codewords, 9, $get($_.codewords, 9) * 2);
  if (($_.fcs & 1024) != 0) {
    $put($_.codewords, 0, $get($_.codewords, 0) + 659);
  }
  $_.tab513 = $a([31, 7936, 47, 7808, 55, 7552, 59, 7040, 61, 6016, 62, 3968, 79, 7744, 87, 7488, 91, 6976, 93, 5952, 94, 3904, 103, 7360, 107, 6848, 109, 5824, 110, 3776, 115, 6592, 117, 5568, 118, 3520, 121, 5056, 122, 3008, 124, 1984, 143, 7712, 151, 7456, 155, 6944, 157, 5920, 158, 3872, 167, 7328, 171, 6816, 173, 5792, 174, 3744, 179, 6560, 181, 5536, 182, 3488, 185, 5024, 186, 2976, 188, 1952, 199, 7264, 203, 6752, 205, 5728, 206, 3680, 211, 6496, 213, 5472, 214, 3424, 217, 4960, 218, 2912, 220, 1888, 227, 6368, 229, 5344, 230, 3296, 233, 4832, 234, 2784, 236, 1760, 241, 4576, 242, 2528, 244, 1504, 248, 992, 271, 7696, 279, 7440, 283, 6928, 285, 5904, 286, 3856, 295, 7312, 299, 6800, 301, 5776, 302, 3728, 307, 6544, 309, 5520, 310, 3472, 313, 5008, 314, 2960, 316, 1936, 327, 7248, 331, 6736, 333, 5712, 334, 3664, 339, 6480, 341, 5456, 342, 3408, 345, 4944, 346, 2896, 348, 1872, 355, 6352, 357, 5328, 358, 3280, 361, 4816, 362, 2768, 364, 1744, 369, 4560, 370, 2512, 372, 1488, 376, 976, 391, 7216, 395, 6704, 397, 5680, 398, 3632, 403, 6448, 405, 5424, 406, 3376, 409, 4912, 410, 2864, 412, 1840, 419, 6320, 421, 5296, 422, 3248, 425, 4784, 426, 2736, 428, 1712, 433, 4528, 434, 2480, 436, 1456, 440, 944, 451, 6256, 453, 5232, 454, 3184, 457, 4720, 458, 2672, 460, 1648, 465, 4464, 466, 2416, 468, 1392, 472, 880, 481, 4336, 482, 2288, 484, 1264, 488, 752, 527, 7688, 535, 7432, 539, 6920, 541, 5896, 542, 3848, 551, 7304, 555, 6792, 557, 5768, 558, 3720, 563, 6536, 565, 5512, 566, 3464, 569, 5e3, 570, 2952, 572, 1928, 583, 7240, 587, 6728, 589, 5704, 590, 3656, 595, 6472, 597, 5448, 598, 3400, 601, 4936, 602, 2888, 604, 1864, 611, 6344, 613, 5320, 614, 3272, 617, 4808, 618, 2760, 620, 1736, 625, 4552, 626, 2504, 628, 1480, 632, 968, 647, 7208, 651, 6696, 653, 5672, 654, 3624, 659, 6440, 661, 5416, 662, 3368, 665, 4904, 666, 2856, 668, 1832, 675, 6312, 677, 5288, 678, 3240, 681, 4776, 682, 2728, 684, 1704, 689, 4520, 690, 2472, 692, 1448, 696, 936, 707, 6248, 709, 5224, 710, 3176, 713, 4712, 714, 2664, 716, 1640, 721, 4456, 722, 2408, 724, 1384, 728, 872, 737, 4328, 738, 2280, 740, 1256, 775, 7192, 779, 6680, 781, 5656, 782, 3608, 787, 6424, 789, 5400, 790, 3352, 793, 4888, 794, 2840, 796, 1816, 803, 6296, 805, 5272, 806, 3224, 809, 4760, 810, 2712, 812, 1688, 817, 4504, 818, 2456, 820, 1432, 824, 920, 835, 6232, 837, 5208, 838, 3160, 841, 4696, 842, 2648, 844, 1624, 849, 4440, 850, 2392, 852, 1368, 865, 4312, 866, 2264, 868, 1240, 899, 6200, 901, 5176, 902, 3128, 905, 4664, 906, 2616, 908, 1592, 913, 4408, 914, 2360, 916, 1336, 929, 4280, 930, 2232, 932, 1208, 961, 4216, 962, 2168, 964, 1144, 1039, 7684, 1047, 7428, 1051, 6916, 1053, 5892, 1054, 3844, 1063, 7300, 1067, 6788, 1069, 5764, 1070, 3716, 1075, 6532, 1077, 5508, 1078, 3460, 1081, 4996, 1082, 2948, 1084, 1924, 1095, 7236, 1099, 6724, 1101, 5700, 1102, 3652, 1107, 6468, 1109, 5444, 1110, 3396, 1113, 4932, 1114, 2884, 1116, 1860, 1123, 6340, 1125, 5316, 1126, 3268, 1129, 4804, 1130, 2756, 1132, 1732, 1137, 4548, 1138, 2500, 1140, 1476, 1159, 7204, 1163, 6692, 1165, 5668, 1166, 3620, 1171, 6436, 1173, 5412, 1174, 3364, 1177, 4900, 1178, 2852, 1180, 1828, 1187, 6308, 1189, 5284, 1190, 3236, 1193, 4772, 1194, 2724, 1196, 1700, 1201, 4516, 1202, 2468, 1204, 1444, 1219, 6244, 1221, 5220, 1222, 3172, 1225, 4708, 1226, 2660, 1228, 1636, 1233, 4452, 1234, 2404, 1236, 1380, 1249, 4324, 1250, 2276, 1287, 7188, 1291, 6676, 1293, 5652, 1294, 3604, 1299, 6420, 1301, 5396, 1302, 3348, 1305, 4884, 1306, 2836, 1308, 1812, 1315, 6292, 1317, 5268, 1318, 3220, 1321, 4756, 1322, 2708, 1324, 1684, 1329, 4500, 1330, 2452, 1332, 1428, 1347, 6228, 1349, 5204, 1350, 3156, 1353, 4692, 1354, 2644, 1356, 1620, 1361, 4436, 1362, 2388, 1377, 4308, 1378, 2260, 1411, 6196, 1413, 5172, 1414, 3124, 1417, 4660, 1418, 2612, 1420, 1588, 1425, 4404, 1426, 2356, 1441, 4276, 1442, 2228, 1473, 4212, 1474, 2164, 1543, 7180, 1547, 6668, 1549, 5644, 1550, 3596, 1555, 6412, 1557, 5388, 1558, 3340, 1561, 4876, 1562, 2828, 1564, 1804, 1571, 6284, 1573, 5260, 1574, 3212, 1577, 4748, 1578, 2700, 1580, 1676, 1585, 4492, 1586, 2444, 1603, 6220, 1605, 5196, 1606, 3148, 1609, 4684, 1610, 2636, 1617, 4428, 1618, 2380, 1633, 4300, 1634, 2252, 1667, 6188, 1669, 5164, 1670, 3116, 1673, 4652, 1674, 2604, 1681, 4396, 1682, 2348, 1697, 4268, 1698, 2220, 1729, 4204, 1730, 2156, 1795, 6172, 1797, 5148, 1798, 3100, 1801, 4636, 1802, 2588, 1809, 4380, 1810, 2332, 1825, 4252, 1826, 2204, 1857, 4188, 1858, 2140, 1921, 4156, 1922, 2108, 2063, 7682, 2071, 7426, 2075, 6914, 2077, 5890, 2078, 3842, 2087, 7298, 2091, 6786, 2093, 5762, 2094, 3714, 2099, 6530, 2101, 5506, 2102, 3458, 2105, 4994, 2106, 2946, 2119, 7234, 2123, 6722, 2125, 5698, 2126, 3650, 2131, 6466, 2133, 5442, 2134, 3394, 2137, 4930, 2138, 2882, 2147, 6338, 2149, 5314, 2150, 3266, 2153, 4802, 2154, 2754, 2161, 4546, 2162, 2498, 2183, 7202, 2187, 6690, 2189, 5666, 2190, 3618, 2195, 6434, 2197, 5410, 2198, 3362, 2201, 4898, 2202, 2850, 2211, 6306, 2213, 5282, 2214, 3234, 2217, 4770, 2218, 2722, 2225, 4514, 2226, 2466, 2243, 6242, 2245, 5218, 2246, 3170, 2249, 4706, 2250, 2658, 2257, 4450, 2258, 2402, 2273, 4322, 2311, 7186, 2315, 6674, 2317, 5650, 2318, 3602, 2323, 6418, 2325, 5394, 2326, 3346, 2329, 4882, 2330, 2834, 2339, 6290, 2341, 5266, 2342, 3218, 2345, 4754, 2346, 2706, 2353, 4498, 2354, 2450, 2371, 6226, 2373, 5202, 2374, 3154, 2377, 4690, 2378, 2642, 2385, 4434, 2401, 4306, 2435, 6194, 2437, 5170, 2438, 3122, 2441, 4658, 2442, 2610, 2449, 4402, 2465, 4274, 2497, 4210, 2567, 7178, 2571, 6666, 2573, 5642, 2574, 3594, 2579, 6410, 2581, 5386, 2582, 3338, 2585, 4874, 2586, 2826, 2595, 6282, 2597, 5258, 2598, 3210, 2601, 4746, 2602, 2698, 2609, 4490, 2627, 6218, 2629, 5194, 2630, 3146, 2633, 4682, 2641, 4426, 2657, 4298, 2691, 6186, 2693, 5162, 2694, 3114, 2697, 4650, 2705, 4394, 2721, 4266, 2753, 4202, 2819, 6170, 2821, 5146, 2822, 3098, 2825, 4634, 2833, 4378, 2849, 4250, 2881, 4186, 2945, 4154, 3079, 7174, 3083, 6662, 3085, 5638, 3086, 3590, 3091, 6406, 3093, 5382, 3094, 3334, 3097, 4870, 3107, 6278, 3109, 5254, 3110, 3206, 3113, 4742, 3121, 4486, 3139, 6214, 3141, 5190, 3145, 4678, 3153, 4422, 3169, 4294, 3203, 6182, 3205, 5158, 3209, 4646, 3217, 4390, 3233, 4262, 3265, 4198, 3331, 6166, 3333, 5142, 3337, 4630, 3345, 4374, 3361, 4246, 3393, 4182, 3457, 4150, 3587, 6158, 3589, 5134, 3593, 4622, 3601, 4366, 3617, 4238, 3649, 4174, 3713, 4142, 3841, 4126, 4111, 7681, 4119, 7425, 4123, 6913, 4125, 5889, 4135, 7297, 4139, 6785, 4141, 5761, 4147, 6529, 4149, 5505, 4153, 4993, 4167, 7233, 4171, 6721, 4173, 5697, 4179, 6465, 4181, 5441, 4185, 4929, 4195, 6337, 4197, 5313, 4201, 4801, 4209, 4545, 4231, 7201, 4235, 6689, 4237, 5665, 4243, 6433, 4245, 5409, 4249, 4897, 4259, 6305, 4261, 5281, 4265, 4769, 4273, 4513, 4291, 6241, 4293, 5217, 4297, 4705, 4305, 4449, 4359, 7185, 4363, 6673, 4365, 5649, 4371, 6417, 4373, 5393, 4377, 4881, 4387, 6289, 4389, 5265, 4393, 4753, 4401, 4497, 4419, 6225, 4421, 5201, 4425, 4689, 4483, 6193, 4485, 5169, 4489, 4657, 4615, 7177, 4619, 6665, 4621, 5641, 4627, 6409, 4629, 5385, 4633, 4873, 4643, 6281, 4645, 5257, 4649, 4745, 4675, 6217, 4677, 5193, 4739, 6185, 4741, 5161, 4867, 6169, 4869, 5145, 5127, 7173, 5131, 6661, 5133, 5637, 5139, 6405, 5141, 5381, 5155, 6277, 5157, 5253, 5187, 6213, 5251, 6181, 5379, 6165, 5635, 6157, 6151, 7171, 6155, 6659, 6163, 6403, 6179, 6275, 6211, 5189, 4681, 4433, 4321, 3142, 2634, 2386, 2274, 1612, 1364, 1252, 856, 744, 496]);
  $_.tab213 = $a([3, 6144, 5, 5120, 6, 3072, 9, 4608, 10, 2560, 12, 1536, 17, 4352, 18, 2304, 20, 1280, 24, 768, 33, 4224, 34, 2176, 36, 1152, 40, 640, 48, 384, 65, 4160, 66, 2112, 68, 1088, 72, 576, 80, 320, 96, 192, 129, 4128, 130, 2080, 132, 1056, 136, 544, 144, 288, 257, 4112, 258, 2064, 260, 1040, 264, 528, 513, 4104, 514, 2056, 516, 1032, 1025, 4100, 1026, 2052, 2049, 4098, 4097, 2050, 1028, 520, 272, 160]);
  $_.chars = $a(10);
  for (var _3T = 0; _3T <= 9; _3T += 1) {
    $_.i = _3T;
    var _3W = $get($_.codewords, $_.i);
    $k[$j++] = _3W;
    if (_3W <= 1286) {
      var _3Z = $get($_.tab513, $k[--$j]);
      $k[$j++] = _3Z;
    } else {
      var _3c = $get($_.tab213, $k[--$j] - 1287);
      $k[$j++] = _3c;
    }
    $k[$j++] = $_.chars;
    $k[$j++] = $_.i;
    var _3f = $k[$j - 3];
    var _3g = $k[$j - 1];
    $put($k[$j - 2], _3g, _3f);
    $j -= 3;
  }
  for (var _3i = 9; _3i >= 0; _3i -= 1) {
    $_.i = _3i;
    if ((~~$pow(2, $_.i) & $_.fcs) != 0) {
      $put($_.chars, $_.i, $get($_.chars, $_.i) ^ 8191);
    }
  }
  $_.barmap = $a([7, 2, 4, 3, 1, 10, 0, 0, 9, 12, 2, 8, 5, 5, 6, 11, 8, 9, 3, 1, 0, 1, 5, 12, 2, 5, 1, 8, 4, 4, 9, 11, 6, 3, 8, 10, 3, 9, 7, 6, 5, 11, 1, 4, 8, 5, 2, 12, 9, 10, 0, 2, 7, 1, 6, 7, 3, 6, 4, 9, 0, 3, 8, 6, 6, 4, 2, 7, 1, 1, 9, 9, 7, 10, 5, 2, 4, 0, 3, 8, 6, 2, 0, 4, 8, 11, 1, 0, 9, 8, 3, 12, 2, 6, 7, 7, 5, 1, 4, 10, 1, 12, 6, 9, 7, 3, 8, 0, 5, 8, 9, 7, 4, 6, 2, 10, 3, 4, 0, 5, 8, 4, 5, 7, 7, 11, 1, 9, 6, 0, 9, 6, 0, 6, 4, 8, 2, 1, 3, 2, 5, 9, 8, 12, 4, 11, 6, 1, 9, 5, 7, 4, 3, 3, 1, 2, 0, 7, 2, 0, 1, 3, 4, 1, 6, 10, 3, 5, 8, 7, 9, 4, 2, 11, 5, 6, 0, 8, 7, 12, 4, 2, 8, 1, 5, 10, 3, 0, 9, 3, 0, 9, 6, 5, 2, 4, 7, 8, 1, 7, 5, 0, 4, 5, 2, 3, 0, 10, 6, 12, 9, 2, 3, 11, 1, 6, 8, 8, 7, 9, 5, 4, 0, 11, 1, 5, 2, 2, 9, 1, 4, 12, 8, 3, 6, 6, 7, 0, 3, 7, 4, 7, 7, 5, 0, 12, 1, 11, 2, 9, 9, 0, 6, 8, 5, 3, 3, 10, 8, 2]);
  $_.bbs = $a(65);
  $_.bhs = $a(65);
  for (var _3u = 0; _3u <= 64; _3u += 1) {
    $_.i = _3u;
    $_.dec = ($get($_.chars, $get($_.barmap, $_.i * 4)) & ~~$pow(2, $get($_.barmap, $_.i * 4 + 1))) != 0;
    $_.asc = ($get($_.chars, $get($_.barmap, $_.i * 4 + 2)) & ~~$pow(2, $get($_.barmap, $_.i * 4 + 3))) != 0;
    if (!$_.dec && !$_.asc) {
      $put($_.bbs, $_.i, 3 * $_.height / 8);
      $put($_.bhs, $_.i, 2 * $_.height / 8);
    }
    if (!$_.dec && $_.asc) {
      $put($_.bbs, $_.i, 3 * $_.height / 8);
      $put($_.bhs, $_.i, 5 * $_.height / 8);
    }
    if ($_.dec && !$_.asc) {
      $put($_.bbs, $_.i, 0 * $_.height / 8);
      $put($_.bhs, $_.i, 5 * $_.height / 8);
    }
    if ($_.dec && $_.asc) {
      $put($_.bbs, $_.i, 0 * $_.height / 8);
      $put($_.bhs, $_.i, 8 * $_.height / 8);
    }
  }
  $k[$j++] = Infinity;
  var _4h = $_.bbs;
  var _4i = $_.bhs;
  $k[$j++] = Infinity;
  for (var _4k = 0, _4l = $_.bhs.length - 1; _4k < _4l; _4k++) {
    $k[$j++] = 1.44;
    $k[$j++] = 1.872;
  }
  $k[$j++] = 1.44;
  var _4m = $a();
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "bbs";
  $k[$j++] = _4h;
  $k[$j++] = "bhs";
  $k[$j++] = _4i;
  $k[$j++] = "sbs";
  $k[$j++] = _4m;
  $k[$j++] = "txt";
  $k[$j++] = $_.txt;
  $k[$j++] = "textxalign";
  $k[$j++] = "left";
  $k[$j++] = "textfont";
  $k[$j++] = "OCR-B";
  $k[$j++] = "textyoffset";
  $k[$j++] = 1;
  $k[$j++] = "textxoffset";
  $k[$j++] = -0.3;
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  var _4p = $d();
  $k[$j++] = _4p;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_postnet() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.validatecheck = false;
  $_.includecheckintext = false;
  $_.textfont = "OCR-B";
  $_.textsize = 10;
  $_.textyoffset = -8;
  $_.height = 0.125;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $k[$j++] = "barlen";
  $k[$j++] = $_.barcode.length;
  if ($_.validatecheck) {
    var _4 = $k[--$j];
    $k[$j++] = _4 - 1;
  }
  var _5 = $k[--$j];
  $_[$k[--$j]] = _5;
  if ($_.barlen != 5 && $_.barlen != 9 && $_.barlen != 11) {
    $k[$j++] = "bwipp.postnetBadLength#12597";
    $k[$j++] = "USPS POSTNET must be 5, 9 or 11 digits excluding check digit";
    bwipp_raiseerror();
  }
  $forall($_.barcode, function() {
    var _B = $k[--$j];
    if (_B < 48 || _B > 57) {
      $k[$j++] = "bwipp.postnetBadCharacter#12601";
      $k[$j++] = "USPS POSTNET must contain only digits";
      bwipp_raiseerror();
    }
  });
  $_.barchars = "0123456789";
  $_.encs = $a(["55222", "22255", "22525", "22552", "25225", "25252", "25522", "52225", "52252", "52522", "5", "5"]);
  $_.checksum = 0;
  for (var _G = 0, _F = $_.barlen - 1; _G <= _F; _G += 1) {
    $_.i = _G;
    $_.checksum = $f($_.checksum + ($get($_.barcode, $_.i) - 48));
  }
  $_.checksum = (10 - $_.checksum % 10) % 10;
  if ($_.validatecheck) {
    if ($get($_.barcode, $_.barlen) != $get($_.barchars, $_.checksum)) {
      $k[$j++] = "bwipp.postnetBadCheckDigit#12625";
      $k[$j++] = "Incorrect USPS POSTNET check digit provided";
      bwipp_raiseerror();
    }
    $_.barcode = $geti($_.barcode, 0, $_.barlen);
  }
  $_.bhs = $a($_.barlen * 5 + 7);
  $_.txt = $a($_.barlen + 1);
  $_.enc = $get($_.encs, 10);
  $_.heights = $a($_.enc.length);
  for (var _g = 0, _f = $_.enc.length - 1; _g <= _f; _g += 1) {
    $_.j = _g;
    $put($_.heights, $_.j, $cvi($geti($_.enc, $_.j, 1)) * $_.height / 5);
  }
  $puti($_.bhs, 0, $_.heights);
  for (var _r = 0, _q = $_.barlen - 1; _r <= _q; _r += 1) {
    $_.i = _r;
    $_.enc = $get($_.encs, $get($_.barcode, $_.i) - 48);
    $_.heights = $a($_.enc.length);
    for (var _11 = 0, _10 = $_.enc.length - 1; _11 <= _10; _11 += 1) {
      $_.j = _11;
      $put($_.heights, $_.j, $cvi($geti($_.enc, $_.j, 1)) * $_.height / 5);
    }
    $puti($_.bhs, $_.i * 5 + 1, $_.heights);
    $put($_.txt, $_.i, $a([$geti($_.barcode, $_.i, 1), ($_.i * 5 + 1) * 3.312, $_.textyoffset, $_.textfont, $_.textsize]));
  }
  $_.enc = $get($_.encs, $_.checksum);
  $_.heights = $a($_.enc.length);
  for (var _1S = 0, _1R = $_.enc.length - 1; _1S <= _1R; _1S += 1) {
    $_.j = _1S;
    $put($_.heights, $_.j, $cvi($geti($_.enc, $_.j, 1)) * $_.height / 5);
  }
  $puti($_.bhs, $_.barlen * 5 + 1, $_.heights);
  if ($_.includecheckintext) {
    $put($_.txt, $_.barlen, $a([$geti($_.barchars, $_.checksum, 1), ($_.barlen * 5 + 1) * 3.312, $_.textyoffset, $_.textfont, $_.textsize]));
  } else {
    $put($_.txt, $_.barlen, $a([" ", ($_.barlen * 5 + 1) * 72 / 25, $_.textyoffset, $_.textfont, $_.textsize]));
  }
  $_.enc = $get($_.encs, 11);
  $_.heights = $a($_.enc.length);
  for (var _20 = 0, _1z = $_.enc.length - 1; _20 <= _1z; _20 += 1) {
    $_.j = _20;
    $put($_.heights, $_.j, $cvi($geti($_.enc, $_.j, 1)) * $_.height / 5);
  }
  $puti($_.bhs, $_.barlen * 5 + 6, $_.heights);
  $k[$j++] = Infinity;
  var _2A = $_.bhs;
  $k[$j++] = Infinity;
  for (var _2C = 0, _2D = $_.bhs.length; _2C < _2D; _2C++) {
    $k[$j++] = 0;
  }
  var _2E = $a();
  $k[$j++] = Infinity;
  for (var _2G = 0, _2H = $_.bhs.length - 1; _2G < _2H; _2G++) {
    $k[$j++] = 1.44;
    $k[$j++] = 1.872;
  }
  $k[$j++] = 1.44;
  var _2I = $a();
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "bhs";
  $k[$j++] = _2A;
  $k[$j++] = "bbs";
  $k[$j++] = _2E;
  $k[$j++] = "sbs";
  $k[$j++] = _2I;
  if ($_.includetext) {
    $k[$j++] = "txt";
    $k[$j++] = $_.txt;
  }
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  var _2M = $d();
  $k[$j++] = _2M;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_planet() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.validatecheck = false;
  $_.includecheckintext = false;
  $_.textfont = "OCR-B";
  $_.textsize = 10;
  $_.textyoffset = -8;
  $_.height = 0.125;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $k[$j++] = "barlen";
  $k[$j++] = $_.barcode.length;
  if ($_.validatecheck) {
    var _4 = $k[--$j];
    $k[$j++] = _4 - 1;
  }
  var _5 = $k[--$j];
  $_[$k[--$j]] = _5;
  if ($_.barlen != 11 && $_.barlen != 13) {
    $k[$j++] = "bwipp.planetBadLength#12745";
    $k[$j++] = "USPS PLANET must be 11 or 13 digits excluding check digit";
    bwipp_raiseerror();
  }
  $forall($_.barcode, function() {
    var _A = $k[--$j];
    if (_A < 48 || _A > 57) {
      $k[$j++] = "bwipp.planetBadCharacter#12749";
      $k[$j++] = "USPS PLANET must contain only digits";
      bwipp_raiseerror();
    }
  });
  $_.barchars = "0123456789";
  $_.encs = $a(["22555", "55522", "55252", "55225", "52552", "52525", "52255", "25552", "25525", "25255", "5", "5"]);
  $_.checksum = 0;
  for (var _F = 0, _E = $_.barlen - 1; _F <= _E; _F += 1) {
    $_.i = _F;
    $_.checksum = $f($_.checksum + ($get($_.barcode, $_.i) - 48));
  }
  $_.checksum = (10 - $_.checksum % 10) % 10;
  if ($_.validatecheck) {
    if ($get($_.barcode, $_.barlen) != $get($_.barchars, $_.checksum)) {
      $k[$j++] = "bwipp.planetBadCheckDigit#12774";
      $k[$j++] = "Incorrect USPS PLANET check digit provided";
      bwipp_raiseerror();
    }
    $_.barcode = $geti($_.barcode, 0, $_.barlen);
  }
  $_.bhs = $a($_.barlen * 5 + 7);
  $_.txt = $a($_.barlen + 1);
  $_.enc = $get($_.encs, 10);
  $_.heights = $a($_.enc.length);
  for (var _f = 0, _e = $_.enc.length - 1; _f <= _e; _f += 1) {
    $_.j = _f;
    $put($_.heights, $_.j, $cvi($geti($_.enc, $_.j, 1)) * $_.height / 5);
  }
  $puti($_.bhs, 0, $_.heights);
  for (var _q = 0, _p = $_.barlen - 1; _q <= _p; _q += 1) {
    $_.i = _q;
    $_.enc = $get($_.encs, $get($_.barcode, $_.i) - 48);
    $_.heights = $a($_.enc.length);
    for (var _10 = 0, _z = $_.enc.length - 1; _10 <= _z; _10 += 1) {
      $_.j = _10;
      $put($_.heights, $_.j, $cvi($geti($_.enc, $_.j, 1)) * $_.height / 5);
    }
    $puti($_.bhs, $_.i * 5 + 1, $_.heights);
    $put($_.txt, $_.i, $a([$geti($_.barcode, $_.i, 1), ($_.i * 5 + 1) * 3.312, $_.textyoffset, $_.textfont, $_.textsize]));
  }
  $_.enc = $get($_.encs, $_.checksum);
  $_.heights = $a($_.enc.length);
  for (var _1R = 0, _1Q = $_.enc.length - 1; _1R <= _1Q; _1R += 1) {
    $_.j = _1R;
    $put($_.heights, $_.j, $cvi($geti($_.enc, $_.j, 1)) * $_.height / 5);
  }
  $puti($_.bhs, $_.barlen * 5 + 1, $_.heights);
  if ($_.includecheckintext) {
    $put($_.txt, $_.barlen, $a([$geti($_.barchars, $_.checksum, 1), ($_.barlen * 5 + 1) * 3.312, $_.textyoffset, $_.textfont, $_.textsize]));
  } else {
    $put($_.txt, $_.barlen, $a([" ", ($_.barlen * 5 + 1) * 72 / 25, $_.textyoffset, $_.textfont, $_.textsize]));
  }
  $_.enc = $get($_.encs, 11);
  $_.heights = $a($_.enc.length);
  for (var _1z = 0, _1y = $_.enc.length - 1; _1z <= _1y; _1z += 1) {
    $_.j = _1z;
    $put($_.heights, $_.j, $cvi($geti($_.enc, $_.j, 1)) * $_.height / 5);
  }
  $puti($_.bhs, $_.barlen * 5 + 6, $_.heights);
  $k[$j++] = Infinity;
  var _29 = $_.bhs;
  $k[$j++] = Infinity;
  for (var _2B = 0, _2C = $_.bhs.length; _2B < _2C; _2B++) {
    $k[$j++] = 0;
  }
  var _2D = $a();
  $k[$j++] = Infinity;
  for (var _2F = 0, _2G = $_.bhs.length - 1; _2F < _2G; _2F++) {
    $k[$j++] = 1.44;
    $k[$j++] = 1.872;
  }
  $k[$j++] = 1.44;
  var _2H = $a();
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "bhs";
  $k[$j++] = _29;
  $k[$j++] = "bbs";
  $k[$j++] = _2D;
  $k[$j++] = "sbs";
  $k[$j++] = _2H;
  if ($_.includetext) {
    $k[$j++] = "txt";
    $k[$j++] = $_.txt;
  }
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  var _2L = $d();
  $k[$j++] = _2L;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_royalmail() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.validatecheck = false;
  $_.includecheckintext = false;
  $_.textfont = "OCR-B";
  $_.textsize = 10;
  $_.textyoffset = -8;
  $_.height = 0.175;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length == 0) {
    $k[$j++] = "bwipp.royalmailEmptyData#12889";
    $k[$j++] = "The data must not be empty";
    bwipp_raiseerror();
  }
  $_.barchars = "ZUVWXY501234B6789AHCDEFGNIJKLMTOPQRS";
  $_.charvals = /* @__PURE__ */ new Map();
  for (var _3 = 0; _3 <= 35; _3 += 1) {
    $put($_.charvals, $geti($_.barchars, _3, 1), _3);
  }
  $_.encs = $a(["3300", "2211", "2301", "2310", "3201", "3210", "1122", "0033", "0123", "0132", "1023", "1032", "1302", "0213", "0303", "0312", "1203", "1212", "1320", "0231", "0321", "0330", "1221", "1230", "3102", "2013", "2103", "2112", "3003", "3012", "3120", "2031", "2121", "2130", "3021", "3030", "2", "3"]);
  for (var _B = 0, _A = $_.barcode.length - 1; _B <= _A; _B += 1) {
    var _F = $get($_.charvals, $geti($_.barcode, _B, 1)) !== void 0;
    if (!_F) {
      $k[$j++] = "bwipp.royalmailBadCharacter#12915";
      $k[$j++] = "RM4SCC must contain only capital letters and digits";
      bwipp_raiseerror();
    }
  }
  $k[$j++] = "barlen";
  $k[$j++] = $_.barcode.length;
  if ($_.validatecheck) {
    var _I = $k[--$j];
    $k[$j++] = _I - 1;
  }
  var _J = $k[--$j];
  $_[$k[--$j]] = _J;
  $_.checksumrow = 0;
  $_.checksumcol = 0;
  for (var _N = 0, _M = $_.barlen - 1; _N <= _M; _N += 1) {
    $_.i = _N;
    $_.indx = $get($_.charvals, $geti($_.barcode, $_.i, 1));
    $_.checksumrow = $_.checksumrow + ~~($_.indx / 6);
    $_.checksumcol = $f($_.checksumcol + $_.indx % 6);
  }
  $_.checksum = $f($_.checksumrow % 6 * 6 + $_.checksumcol % 6);
  if ($_.validatecheck) {
    if ($get($_.barcode, $_.barlen) != $get($_.barchars, $_.checksum)) {
      $k[$j++] = "bwipp.royalmailBadCheckDigit#12932";
      $k[$j++] = "Incorrect RM4SCC check digit provided";
      bwipp_raiseerror();
    }
    $_.barcode = $geti($_.barcode, 0, $_.barlen);
  }
  $_.encstr = $s($_.barlen * 4 + 6);
  $_.txt = $a($_.barlen + 1);
  $puti($_.encstr, 0, $get($_.encs, 36));
  for (var _s = 0, _r = $_.barlen - 1; _s <= _r; _s += 1) {
    $_.i = _s;
    $_.indx = $get($_.charvals, $geti($_.barcode, $_.i, 1));
    $puti($_.encstr, $_.i * 4 + 1, $get($_.encs, $_.indx));
    $put($_.txt, $_.i, $a([$geti($_.barcode, $_.i, 1), ($_.i * 4 + 1) * 3.312, $_.textyoffset, $_.textfont, $_.textsize]));
  }
  $puti($_.encstr, $_.barlen * 4 + 1, $get($_.encs, $_.checksum));
  if ($_.includecheckintext) {
    $put($_.txt, $_.barlen, $a([$geti($_.barchars, $_.checksum, 1), ($_.barlen * 4 + 1) * 3.312, $_.textyoffset, $_.textfont, $_.textsize]));
  } else {
    $put($_.txt, $_.barlen, $a([" ", ($_.barlen * 4 + 1) * 3.312, $_.textyoffset, $_.textfont, $_.textsize]));
  }
  $puti($_.encstr, $_.barlen * 4 + 5, $get($_.encs, 37));
  $_.bbs = $a($_.encstr.length);
  $_.bhs = $a($_.encstr.length);
  for (var _1k = 0, _1j = $_.encstr.length - 1; _1k <= _1j; _1k += 1) {
    $_.i = _1k;
    $_.enc = $geti($_.encstr, $_.i, 1);
    if ($eq($_.enc, "0")) {
      $put($_.bbs, $_.i, 3 * $_.height / 8);
      $put($_.bhs, $_.i, 2 * $_.height / 8);
    }
    if ($eq($_.enc, "1")) {
      $put($_.bbs, $_.i, 0 * $_.height / 8);
      $put($_.bhs, $_.i, 5 * $_.height / 8);
    }
    if ($eq($_.enc, "2")) {
      $put($_.bbs, $_.i, 3 * $_.height / 8);
      $put($_.bhs, $_.i, 5 * $_.height / 8);
    }
    if ($eq($_.enc, "3")) {
      $put($_.bbs, $_.i, 0 * $_.height / 8);
      $put($_.bhs, $_.i, 8 * $_.height / 8);
    }
  }
  $k[$j++] = Infinity;
  var _2G = $_.bbs;
  var _2H = $_.bhs;
  $k[$j++] = Infinity;
  for (var _2J = 0, _2K = $_.bhs.length - 1; _2J < _2K; _2J++) {
    $k[$j++] = 1.44;
    $k[$j++] = 1.872;
  }
  $k[$j++] = 1.44;
  var _2L = $a();
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "bbs";
  $k[$j++] = _2G;
  $k[$j++] = "bhs";
  $k[$j++] = _2H;
  $k[$j++] = "sbs";
  $k[$j++] = _2L;
  if ($_.includetext) {
    $k[$j++] = "txt";
    $k[$j++] = $_.txt;
  }
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  var _2P = $d();
  $k[$j++] = _2P;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_auspost() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.textfont = "OCR-B";
  $_.textsize = 10;
  $_.textyoffset = -8;
  $_.height = 0.175;
  $_.custinfoenc = "character";
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($ne($_.custinfoenc, "character") && $ne($_.custinfoenc, "numeric")) {
    $k[$j++] = "bwipp.auspostBadCustinfoEncoding#13045";
    $k[$j++] = "Customer information encoding must be either character or numeric";
    bwipp_raiseerror();
  }
  $_.encs = $a(["000", "001", "002", "010", "011", "012", "020", "021", "022", "100", "101", "102", "110", "111", "112", "120", "121", "122", "200", "201", "202", "210", "211", "212", "220", "221", "222", "300", "301", "302", "310", "311", "312", "320", "321", "322", "023", "030", "031", "032", "033", "103", "113", "123", "130", "131", "132", "133", "203", "213", "223", "230", "231", "232", "233", "303", "313", "323", "330", "331", "332", "333", "003", "013", "00", "01", "02", "10", "11", "12", "20", "21", "22", "30", "13", "3"]);
  $_.barchars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz #";
  var _5 = /* @__PURE__ */ new Map([
    ["11", 37],
    ["45", 37],
    ["59", 52],
    ["62", 67]
  ]);
  $_.fcclen = _5;
  $_.barlen = $_.barcode.length;
  if ($_.barlen < 10) {
    $k[$j++] = "bwipp.auspostTooShort#13075";
    $k[$j++] = "The data length must be at least 10";
    bwipp_raiseerror();
  }
  $_.txt = $a($_.barlen - 2);
  $k[$j++] = $_.fcclen;
  if ($_.barlen >= 2) {
    $k[$j++] = $geti($_.barcode, 0, 2);
  } else {
    $k[$j++] = "";
  }
  var _F = $k[$j - 1];
  var _G = $k[$j - 2];
  var _H = $get(_G, _F) !== void 0;
  if (!_H) {
    $j -= 2;
    $k[$j++] = "bwipp.auspostBadFCC#13082";
    $k[$j++] = "Must begin with an FCC, either 11, 45, 59 or 62";
    bwipp_raiseerror();
  }
  var _I = $k[--$j];
  $_.encstr = $s($get($k[--$j], _I));
  $k[$j++] = true;
  for (var _M = 0; _M < 1; _M++) {
    if ($_.barlen < 10) {
      $k[$j - 1] = false;
      break;
    }
    var _P = $geti($_.barcode, 2, 8);
    for (var _Q = 0, _R = _P.length; _Q < _R; _Q++) {
      var _S = $get(_P, _Q);
      if (_S < 48 || _S > 57) {
        $k[$j - 1] = false;
        break;
      }
    }
  }
  if (!$k[--$j]) {
    $k[$j++] = "bwipp.auspostIncompleteDPID#13093";
    $k[$j++] = "The DPID must be 8 digits";
    bwipp_raiseerror();
  }
  var _W = $eq($_.custinfoenc, "numeric") ? 2 : 3;
  if (($_.barlen - 10) * _W > $_.encstr.length - 22 - 14) {
    $k[$j++] = "bwipp.auspostTooLong#13099";
    $k[$j++] = "The message is too long";
    bwipp_raiseerror();
  }
  $puti($_.encstr, 0, $get($_.encs, 74));
  for (var _b = 0; _b <= 1; _b += 1) {
    $_.i = _b;
    $puti($_.encstr, $_.i * 2 + 2, $get($_.encs, $cvi($geti($_.barcode, $_.i, 1)) + 64));
  }
  for (var _j = 2; _j <= 9; _j += 1) {
    $_.i = _j;
    $puti($_.encstr, $_.i * 2 + 2, $get($_.encs, $cvi($geti($_.barcode, $_.i, 1)) + 64));
    $put($_.txt, $_.i - 2, $a([$geti($_.barcode, $_.i, 1), (($_.i - 2) * 2 + 6) * 3.312, $_.textyoffset, $_.textfont, $_.textsize]));
  }
  if ($eq($_.custinfoenc, "numeric")) {
    for (var _14 = 0, _13 = $_.barlen - 11; _14 <= _13; _14 += 1) {
      $_.i = _14;
      var _18 = $get($_.barcode, $_.i + 10);
      $k[$j++] = $_.encs;
      $k[$j++] = _18;
      if (_18 < 48 || _18 > 57) {
        $k[$j++] = "bwipp.auspostInvalidCustinfoDigit#13126";
        $k[$j++] = "The customer information data contains a non-digit character";
        bwipp_raiseerror();
      }
      var _19 = $k[--$j];
      $puti($_.encstr, $_.i * 2 + 22, $get($k[--$j], _19 - 48 + 64));
      $put($_.txt, $_.i + 8, $a([$geti($_.barcode, $_.i + 10, 1), ($_.i * 2 + 22) * 3.312, $_.textyoffset, $_.textfont, $_.textsize]));
    }
    $_.ciflen = ($_.barlen - 10) * 2;
  } else {
    for (var _1R = 0, _1Q = $_.barlen - 11; _1R <= _1Q; _1R += 1) {
      $_.i = _1R;
      $search($_.barchars, $geti($_.barcode, $_.i + 10, 1));
      if (!$k[--$j]) {
        $j--;
        $k[$j++] = "bwipp.auspostInvalidCustinfoCharacter#13138";
        $k[$j++] = "The customer information contains an invalid character";
        bwipp_raiseerror();
      }
      $_.indx = $k[--$j].length;
      $j -= 2;
      $_.enc = $get($_.encs, $_.indx);
      $puti($_.encstr, $_.i * 3 + 22, $_.enc);
      $put($_.txt, $_.i + 8, $a([$geti($_.barcode, $_.i + 10, 1), ($_.i * 3 + 22) * 3.312, $_.textyoffset, $_.textfont, $_.textsize]));
    }
    $_.ciflen = ($_.barlen - 10) * 3;
  }
  for (var _1s = 22 + $_.ciflen, _1r = $_.encstr.length - 14; _1s <= _1r; _1s += 1) {
    $puti($_.encstr, _1s, $get($_.encs, 75));
  }
  $_.rstable = $a(64 * 64);
  $k[$j++] = $_.rstable;
  $k[$j++] = 0;
  $k[$j++] = Infinity;
  for (var _1y = 0; _1y < 64; _1y++) {
    $k[$j++] = 0;
  }
  var _1z = $a();
  var _20 = $k[--$j];
  $puti($k[--$j], _20, _1z);
  $k[$j++] = $_.rstable;
  $k[$j++] = 64;
  $k[$j++] = Infinity;
  for (var _23 = 0; _23 <= 63; _23 += 1) {
    $k[$j++] = _23;
  }
  var _24 = $a();
  var _25 = $k[--$j];
  $puti($k[--$j], _25, _24);
  $_.prev = 1;
  for (var _27 = 0; _27 < 64; _27++) {
    $_.next = $_.prev << 1;
    if (($_.next & 64) != 0) {
      $_.next = $_.next ^ 67;
    }
    for (var _2B = 0; _2B <= 63; _2B += 1) {
      $_.j = _2B;
      $_.nextcell = function() {
        $k[$j++] = $_.rstable;
        $k[$j++] = 64 * $_.next + $_.j;
      };
      $_.nextcell();
      var _2J = $k[--$j];
      $put($k[--$j], _2J, $get($_.rstable, 64 * $_.prev + $_.j) << 1);
      $_.nextcell();
      var _2L = $k[--$j];
      if (($get($k[--$j], _2L) & 64) != 0) {
        $_.nextcell();
        $_.nextcell();
        var _2O = $k[--$j];
        var _2Q = $get($k[--$j], _2O);
        var _2R = $k[--$j];
        $put($k[--$j], _2R, _2Q ^ 67);
      }
    }
    $_.prev = $_.next;
  }
  $_.rscodes = $a(~~(($_.encstr.length - 16) / 3) + 4);
  $k[$j++] = $_.rscodes;
  $k[$j++] = 0;
  $k[$j++] = Infinity;
  for (var _2Y = 0; _2Y < 4; _2Y++) {
    $k[$j++] = 0;
  }
  var _2Z = $a();
  var _2a = $k[--$j];
  $puti($k[--$j], _2a, _2Z);
  for (var _2e = 2, _2d = $_.encstr.length - 16; _2e <= _2d; _2e += 3) {
    $_.i = _2e;
    $put($_.rscodes, $_.rscodes.length - ~~(($_.i - 2) / 3) - 1, $cvi($geti($_.encstr, $_.i, 1)) * 16 + $cvi($geti($_.encstr, $_.i + 1, 1)) * 4 + $cvi($geti($_.encstr, $_.i + 2, 1)));
  }
  for (var _2s = $_.rscodes.length - 5; _2s >= 0; _2s -= 1) {
    $_.i = _2s;
    for (var _2t = 0; _2t <= 4; _2t += 1) {
      $_.j = _2t;
      $put($_.rscodes, $_.i + $_.j, $xo($get($_.rscodes, $_.i + $_.j), $get($_.rstable, $f(64 * $get($a([48, 17, 29, 30, 1]), $_.j) + $get($_.rscodes, $_.i + 4)))));
    }
  }
  $_.checkcode = $strcpy($s(12), "000000000000");
  for (var _3B = 0; _3B <= 3; _3B += 1) {
    $_.i = _3B;
    $_.enc = $cvrs($s(3), $get($_.rscodes, 3 - $_.i), 4);
    $puti($_.checkcode, $_.i * 3 + (3 - $_.enc.length), $_.enc);
  }
  $puti($_.encstr, $_.encstr.length - 14, $_.checkcode);
  $puti($_.encstr, $_.encstr.length - 2, $get($_.encs, 74));
  $_.bbs = $a($_.encstr.length);
  $_.bhs = $a($_.encstr.length);
  for (var _3Y = 0, _3X = $_.encstr.length - 1; _3Y <= _3X; _3Y += 1) {
    $_.i = _3Y;
    $_.enc = $geti($_.encstr, $_.i, 1);
    if ($eq($_.enc, "0")) {
      $put($_.bbs, $_.i, 0 * $_.height / 8);
      $put($_.bhs, $_.i, 8 * $_.height / 8);
    }
    if ($eq($_.enc, "1")) {
      $put($_.bbs, $_.i, 3 * $_.height / 8);
      $put($_.bhs, $_.i, 5 * $_.height / 8);
    }
    if ($eq($_.enc, "2")) {
      $put($_.bbs, $_.i, 0 * $_.height / 8);
      $put($_.bhs, $_.i, 5 * $_.height / 8);
    }
    if ($eq($_.enc, "3")) {
      $put($_.bbs, $_.i, 3 * $_.height / 8);
      $put($_.bhs, $_.i, 2 * $_.height / 8);
    }
  }
  $k[$j++] = Infinity;
  var _44 = $_.bbs;
  var _45 = $_.bhs;
  $k[$j++] = Infinity;
  for (var _47 = 0, _48 = $_.bhs.length - 1; _47 < _48; _47++) {
    $k[$j++] = 1.44;
    $k[$j++] = 1.872;
  }
  $k[$j++] = 1.44;
  var _49 = $a();
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "bbs";
  $k[$j++] = _44;
  $k[$j++] = "bhs";
  $k[$j++] = _45;
  $k[$j++] = "sbs";
  $k[$j++] = _49;
  if ($_.includetext) {
    $k[$j++] = "txt";
    $k[$j++] = $_.txt;
  }
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  var _4D = $d();
  $k[$j++] = _4D;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_kix() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.textfont = "OCR-B";
  $_.textsize = 10;
  $_.textyoffset = -8;
  $_.height = 0.175;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length == 0) {
    $k[$j++] = "bwipp.kixEmptyData#13291";
    $k[$j++] = "The data must not be empty";
    bwipp_raiseerror();
  }
  $_.encs = $a(["0033", "0123", "0132", "1023", "1032", "1122", "0213", "0303", "0312", "1203", "1212", "1302", "0231", "0321", "0330", "1221", "1230", "1320", "2013", "2103", "2112", "3003", "3012", "3102", "2031", "2121", "2130", "3021", "3030", "3120", "2211", "2301", "2310", "3201", "3210", "3300"]);
  $_.barchars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  $_.charvals = /* @__PURE__ */ new Map();
  for (var _4 = 0; _4 <= 35; _4 += 1) {
    $put($_.charvals, $geti($_.barchars, _4, 1), _4);
  }
  for (var _B = 0, _A = $_.barcode.length - 1; _B <= _A; _B += 1) {
    var _F = $get($_.charvals, $geti($_.barcode, _B, 1)) !== void 0;
    if (!_F) {
      $k[$j++] = "bwipp.kixBadCharacter#13316";
      $k[$j++] = "KIX must contain only capital letters and digits";
      bwipp_raiseerror();
    }
  }
  $_.barlen = $_.barcode.length;
  $_.encstr = $s($_.barlen * 4);
  $_.txt = $a($_.barlen);
  for (var _N = 0, _M = $_.barlen - 1; _N <= _M; _N += 1) {
    $_.i = _N;
    $_.indx = $get($_.charvals, $geti($_.barcode, $_.i, 1));
    $puti($_.encstr, $_.i * 4, $get($_.encs, $_.indx));
    $put($_.txt, $_.i, $a([$geti($_.barcode, $_.i, 1), $_.i * 4 * 3.312, $_.textyoffset, $_.textfont, $_.textsize]));
  }
  $_.bbs = $a($_.encstr.length);
  $_.bhs = $a($_.encstr.length);
  for (var _o = 0, _n = $_.encstr.length - 1; _o <= _n; _o += 1) {
    $_.i = _o;
    $_.enc = $geti($_.encstr, $_.i, 1);
    if ($eq($_.enc, "0")) {
      $put($_.bbs, $_.i, 3 * $_.height / 8);
      $put($_.bhs, $_.i, 2 * $_.height / 8);
    }
    if ($eq($_.enc, "1")) {
      $put($_.bbs, $_.i, 0 * $_.height / 8);
      $put($_.bhs, $_.i, 5 * $_.height / 8);
    }
    if ($eq($_.enc, "2")) {
      $put($_.bbs, $_.i, 3 * $_.height / 8);
      $put($_.bhs, $_.i, 5 * $_.height / 8);
    }
    if ($eq($_.enc, "3")) {
      $put($_.bbs, $_.i, 0 * $_.height / 8);
      $put($_.bhs, $_.i, 8 * $_.height / 8);
    }
  }
  $k[$j++] = Infinity;
  var _1K = $_.bbs;
  var _1L = $_.bhs;
  $k[$j++] = Infinity;
  for (var _1N = 0, _1O = $_.bhs.length - 1; _1N < _1O; _1N++) {
    $k[$j++] = 1.44;
    $k[$j++] = 1.872;
  }
  $k[$j++] = 1.44;
  var _1P = $a();
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "bbs";
  $k[$j++] = _1K;
  $k[$j++] = "bhs";
  $k[$j++] = _1L;
  $k[$j++] = "sbs";
  $k[$j++] = _1P;
  if ($_.includetext) {
    $k[$j++] = "txt";
    $k[$j++] = $_.txt;
  }
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  var _1T = $d();
  $k[$j++] = _1T;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_japanpost() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.includecheckintext = false;
  $_.textfont = "OCR-B";
  $_.textsize = 10;
  $_.textyoffset = -8;
  $_.height = 0.175;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length == 0) {
    $k[$j++] = "bwipp.japanpostEmptyData#13415";
    $k[$j++] = "The data must not be empty";
    bwipp_raiseerror();
  }
  $forall($_.barcode, function() {
    var _4 = $k[--$j];
    if (!(_4 >= 48 && _4 <= 57 || (_4 >= 65 && _4 <= 90 || _4 == 45))) {
      $k[$j++] = "bwipp.japanpostBadCharacter#13425";
      $k[$j++] = "Japan Post must contain only digits, capital letters and the dash symbol";
      bwipp_raiseerror();
    }
  });
  $_.encs = $a(["300", "330", "312", "132", "321", "303", "123", "231", "213", "033", "030", "120", "102", "210", "012", "201", "021", "003", "333", "31", "13"]);
  $_.barchars = "0123456789-ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  $_.barlen = $_.barcode.length;
  $_.encstr = $s((20 + 1) * 3 + 4);
  $_.digits = $a(20);
  $_.txt = $a($_.barlen + 1);
  $puti($_.encstr, 0, $get($_.encs, 19));
  $_.checksum = 0;
  $_.j = 0;
  $_.i = 0;
  $k[$j++] = true;
  for (var _H = 0, _G = $_.barlen - 1; _H <= _G; _H += 1) {
    $_.i = _H;
    $search($_.barchars, $geti($_.barcode, $_.i, 1));
    $j--;
    $_.indx = $k[--$j].length;
    $j -= 2;
    if ($_.indx >= 11 && $_.indx < 37) {
      if ($_.j > 18) {
        $k[$j - 1] = false;
        break;
      }
      $_.digit = ~~(($_.indx - 1) / 10) + 10;
      $puti($_.encstr, $_.j * 3 + 2, $get($_.encs, $_.digit));
      $_.checksum = $_.checksum + $_.digit;
      $put($_.digits, $_.j, $_.digit);
      $_.j = $_.j + 1;
    }
    if ($_.j > 19) {
      $k[$j - 1] = false;
      break;
    }
    $_.digit = 0;
    if ($_.indx == 37) {
      $_.digit = 14;
    }
    if ($_.indx >= 11 && $_.indx < 37) {
      $_.digit = ($_.indx - 1) % 10;
    }
    if ($_.indx < 11) {
      $_.digit = $_.indx;
    }
    $puti($_.encstr, $_.j * 3 + 2, $get($_.encs, $_.digit));
    $_.checksum = $_.checksum + $_.digit;
    $put($_.digits, $_.j, $_.digit);
    $put($_.txt, $_.i, $a([$geti($_.barcode, $_.i, 1), ($_.j * 3 + 2) * 3.312, $_.textyoffset, $_.textfont, $_.textsize]));
    $_.j = $_.j + 1;
  }
  if (!$k[--$j]) {
    $k[$j++] = "bwipp.japanpostTooLong#13489";
    $k[$j++] = "The input is too long";
    bwipp_raiseerror();
  }
  for (var _17 = $_.j, _16 = 20 - 1; _17 <= _16; _17 += 1) {
    $_.k = _17;
    $puti($_.encstr, $_.k * 3 + 2, $get($_.encs, 14));
    $_.checksum = $_.checksum + 14;
    $put($_.digits, $_.k, 14);
  }
  $_.checksum = 19 - $_.checksum % 19;
  $puti($_.encstr, 2 + 20 * 3, $get($_.encs, $_.checksum));
  $puti($_.encstr, 2 + 21 * 3, $get($_.encs, 20));
  $_.checkdigit = " ";
  if ($_.includecheckintext) {
    $_.checkdigit = $geti($_.barchars, $_.checksum, 1);
  }
  $put($_.txt, $_.i + 1, $a([$_.checkdigit, (20 * 3 + 2) * 3.312, $_.textyoffset, $_.textfont, $_.textsize]));
  $puti($_.encstr, (20 + 1) * 3 + 2, $get($_.encs, 20));
  $_.bbs = $a(21 * 3 + 4);
  $_.bhs = $a($_.bbs.length);
  for (var _1g = 0, _1f = $_.bbs.length - 1; _1g <= _1f; _1g += 1) {
    $_.i = _1g;
    $_.enc = $geti($_.encstr, $_.i, 1);
    $_.bunit = 0;
    $_.hunit = 0;
    if ($eq($_.enc, "0")) {
      $_.bunit = 3;
      $_.hunit = 2;
    }
    if ($eq($_.enc, "1")) {
      $_.bunit = 0;
      $_.hunit = 5;
    }
    if ($eq($_.enc, "2")) {
      $_.bunit = 3;
      $_.hunit = 5;
    }
    if ($eq($_.enc, "3")) {
      $_.bunit = 0;
      $_.hunit = 8;
    }
    $put($_.bbs, $_.i, $_.bunit * $_.height / 8);
    $put($_.bhs, $_.i, $_.hunit * $_.height / 8);
  }
  $k[$j++] = Infinity;
  var _1w = $_.bbs;
  var _1x = $_.bhs;
  $k[$j++] = Infinity;
  for (var _1z = 0, _20 = $_.bhs.length - 1; _1z < _20; _1z++) {
    $k[$j++] = 1.44;
    $k[$j++] = 1.872;
  }
  $k[$j++] = 1.44;
  var _21 = $a();
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "bbs";
  $k[$j++] = _1w;
  $k[$j++] = "bhs";
  $k[$j++] = _1x;
  $k[$j++] = "sbs";
  $k[$j++] = _21;
  if ($_.includetext) {
    $k[$j++] = "txt";
    $k[$j++] = $_.txt;
  }
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  var _25 = $d();
  $k[$j++] = _25;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_msi() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includecheck = false;
  $_.includetext = false;
  $_.includecheckintext = false;
  $_.checktype = "unset";
  $_.badmod11 = false;
  $_.textfont = "OCR-B";
  $_.textsize = 10;
  $_.textyoffset = -8;
  $_.height = 1;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($ne($_.checktype, "unset") && !$_.includecheck) {
    $k[$j++] = "bwipp.msiCheckTypeWithoutCheck#13606";
    $k[$j++] = "checktype requires includecheck";
    bwipp_raiseerror();
  }
  if ($_.badmod11 && ($ne($_.checktype, "mod11") && $ne($_.checktype, "ncrmod11") && $ne($_.checktype, "mod1110") && $ne($_.checktype, "ncrmod1110"))) {
    $k[$j++] = "bwipp.msiBadMod11Mismatch#13610";
    $k[$j++] = "badmod11 requires checktype with mod11";
    bwipp_raiseerror();
  }
  if ($eq($_.checktype, "unset")) {
    $_.checktype = "mod10";
  }
  $forall($_.barcode, function() {
    var _B = $k[--$j];
    if (_B < 48 || _B > 57) {
      $k[$j++] = "bwipp.msiBadCharacter#13620";
      $k[$j++] = "MSI must contain only digits";
      bwipp_raiseerror();
    }
  });
  $_.encs = $a(["12121212", "12121221", "12122112", "12122121", "12211212", "12211221", "12212112", "12212121", "21121212", "21121221", "21", "121"]);
  $_.barchars = "0123456789";
  $_.barlen = $_.barcode.length;
  $_.txtlen = $_.barlen;
  $_.mod10 = function() {
    $_.code = $k[--$j];
    $k[$j++] = 0;
    $k[$j++] = 0;
    $forall($_.code, function() {
      var _I = $k[--$j];
      var _J = $k[--$j];
      var _K = $k[--$j];
      $k[$j++] = $f(_I - 48 + _J * 10);
      $k[$j++] = _K;
    });
    $j--;
    var _L = $k[--$j];
    $k[$j++] = _L * 2;
    $k[$j++] = 0;
    for (; ; ) {
      var _M = $k[--$j];
      var _N = $k[--$j];
      var _O = ~~(_N / 10);
      $k[$j++] = $f(_M + _N % 10);
      $k[$j++] = _O;
      if (_O == 0) {
        $j--;
        break;
      }
      var _P = $k[--$j];
      var _Q = $k[--$j];
      $k[$j++] = _P;
      $k[$j++] = _Q;
    }
    $k[$j++] = 0;
    $k[$j++] = 0;
    $forall($_.code, function() {
      var _S = $k[--$j];
      var _T = $k[--$j];
      var _U = $k[--$j];
      $k[$j++] = $f(_T + (_S - 48));
      $k[$j++] = _U;
    });
    var _V = $k[--$j];
    $k[$j - 1] = _V;
    var _X = $k[--$j];
    var _a = $s($_.code.length + 1);
    $puti(_a, 0, $_.code);
    $put(_a, $_.code.length, (10 - $f($k[--$j] + _X) % 10) % 10 + 48);
    $k[$j++] = _a;
  };
  $_.mod11 = function() {
    $_.code = $k[--$j];
    $k[$j++] = $_.code.length - 1;
    $forall($_.code, function() {
      var _g = $k[--$j];
      var _h = $k[--$j];
      $k[$j++] = _g - 48;
      $k[$j++] = _h % 6 + 2;
      $k[$j++] = _h - 1;
    });
    $k[$j - 1] = 0;
    for (var _j = 0, _k = $_.code.length; _j < _k; _j++) {
      var _l = $k[$j - 2];
      var _m = $k[$j - 3];
      var _n = $k[$j - 1];
      $j -= 3;
      $k[$j++] = $f(_n + _m * _l);
    }
    var _p = (11 - $k[--$j] % 11) % 11;
    $k[$j++] = _p;
    if (_p == 10) {
      if ($_.badmod11) {
        $j--;
        var _s = $s($_.code.length + 2);
        $puti(_s, 0, $_.code);
        $puti(_s, $_.code.length, "10");
        $k[$j++] = _s;
      } else {
        $j--;
        $k[$j++] = "bwipp.msiBadMod11NotSpecified#13657";
        $k[$j++] = "mod11 check digit is 10 but badmod11 not specified";
        bwipp_raiseerror();
      }
    } else {
      var _w = $s($_.code.length + 1);
      $puti(_w, 0, $_.code);
      $k[$j++] = _w;
      $k[$j++] = _w;
      $k[$j++] = $_.code.length;
      $r(4, -1);
      var _z = $k[--$j];
      var _10 = $k[--$j];
      $put($k[--$j], _10, _z + 48);
    }
  };
  $_.ncrmod11 = function() {
    $_.code = $k[--$j];
    $k[$j++] = $_.code.length - 1;
    $forall($_.code, function() {
      var _15 = $k[--$j];
      var _16 = $k[--$j];
      $k[$j++] = _15 - 48;
      $k[$j++] = _16 % 8 + 2;
      $k[$j++] = _16 - 1;
    });
    $k[$j - 1] = 0;
    for (var _18 = 0, _19 = $_.code.length; _18 < _19; _18++) {
      var _1A = $k[$j - 2];
      var _1B = $k[$j - 3];
      var _1C = $k[$j - 1];
      $j -= 3;
      $k[$j++] = $f(_1C + _1B * _1A);
    }
    var _1E = (11 - $k[--$j] % 11) % 11;
    $k[$j++] = _1E;
    if (_1E == 10) {
      if ($_.badmod11) {
        $j--;
        var _1H = $s($_.code.length + 2);
        $puti(_1H, 0, $_.code);
        $puti(_1H, $_.code.length, "10");
        $k[$j++] = _1H;
      } else {
        $j--;
        $k[$j++] = "bwipp.msiBadMod11NotSpecified#13673";
        $k[$j++] = "mod11 check digit is 10 but badmod11 not specified";
        bwipp_raiseerror();
      }
    } else {
      var _1L = $s($_.code.length + 1);
      $puti(_1L, 0, $_.code);
      $k[$j++] = _1L;
      $k[$j++] = _1L;
      $k[$j++] = $_.code.length;
      $r(4, -1);
      var _1O = $k[--$j];
      var _1P = $k[--$j];
      $put($k[--$j], _1P, _1O + 48);
    }
  };
  var _1R = /* @__PURE__ */ new Map([
    ["mod10", function() {
      $_.mod10();
    }],
    ["mod1010", function() {
      $_.mod10();
      $_.mod10();
    }],
    ["mod11", function() {
      $_.mod11();
    }],
    ["ncrmod11", function() {
      $_.ncrmod11();
    }],
    ["mod1110", function() {
      $_.mod11();
      $_.mod10();
    }],
    ["ncrmod1110", function() {
      $_.ncrmod11();
      $_.mod10();
    }]
  ]);
  $_.checkfunc = _1R;
  if ($_.includecheck) {
    var _1U = $_.checkfunc;
    var _1V = $_.checktype;
    var _1W = $get(_1U, _1V) !== void 0;
    $k[$j++] = _1U;
    $k[$j++] = _1V;
    if (!_1W) {
      $j -= 2;
      $k[$j++] = "bwipp.msiBadCharacter#13694";
      $k[$j++] = "MSI checktype must be mod10, mod1010, mod11, ncrmod11, mod1110 or ncrmod1110";
      bwipp_raiseerror();
    }
    var _1X = $k[--$j];
    var _1Z = $get($k[--$j], _1X);
    $k[$j++] = $_.barcode;
    if (_1Z() === true) {
      return true;
    }
    $_.barcode = $k[--$j];
    $_.barlen = $_.barcode.length;
    if ($_.includecheckintext) {
      $_.txtlen = $_.barlen;
    }
  }
  $_.sbs = $s($_.barlen * 8 + 5);
  $_.txt = $a($_.barlen);
  $puti($_.sbs, 0, $get($_.encs, 10));
  for (var _1o = 0, _1n = $_.barlen - 1; _1o <= _1n; _1o += 1) {
    $_.i = _1o;
    $search($_.barchars, $geti($_.barcode, $_.i, 1));
    $j--;
    $_.indx = $k[--$j].length;
    $j -= 2;
    $_.enc = $get($_.encs, $_.indx);
    $puti($_.sbs, $_.i * 8 + 2, $_.enc);
    $put($_.txt, $_.i, $a([$geti($_.barcode, $_.i, 1), $_.i * 12 + 3, $_.textyoffset, $_.textfont, $_.textsize]));
  }
  $puti($_.sbs, $_.barlen * 8 + 2, $get($_.encs, 11));
  $k[$j++] = Infinity;
  $k[$j++] = Infinity;
  var _2E = $_.sbs;
  for (var _2F = 0, _2G = _2E.length; _2F < _2G; _2F++) {
    $k[$j++] = $get(_2E, _2F) - 48;
  }
  var _2I = $a();
  $k[$j++] = Infinity;
  for (var _2K = 0, _2L = ~~(($_.sbs.length + 1) / 2); _2K < _2L; _2K++) {
    $k[$j++] = $_.height;
  }
  var _2N = $a();
  $k[$j++] = Infinity;
  for (var _2P = 0, _2Q = ~~(($_.sbs.length + 1) / 2); _2P < _2Q; _2P++) {
    $k[$j++] = 0;
  }
  var _2R = $a();
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "sbs";
  $k[$j++] = _2I;
  $k[$j++] = "bhs";
  $k[$j++] = _2N;
  $k[$j++] = "bbs";
  $k[$j++] = _2R;
  if ($_.includetext) {
    $k[$j++] = "txt";
    $k[$j++] = $geti($_.txt, 0, $_.txtlen);
  }
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  var _2X = $d();
  $k[$j++] = _2X;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_plessey() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.validatecheck = false;
  $_.includecheckintext = false;
  $_.unidirectional = false;
  $_.textfont = "OCR-B";
  $_.textsize = 10;
  $_.textyoffset = -8;
  $_.height = 1;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length == 0) {
    $k[$j++] = "bwipp.plesseyEmptyData#13785";
    $k[$j++] = "The data must not be empty";
    bwipp_raiseerror();
  }
  $_.barchars = "0123456789ABCDEF";
  $_.charvals = /* @__PURE__ */ new Map();
  for (var _3 = 0; _3 <= 15; _3 += 1) {
    $put($_.charvals, $geti($_.barchars, _3, 1), _3);
  }
  $_.encs = $a(["14141414", "32141414", "14321414", "32321414", "14143214", "32143214", "14323214", "32323214", "14141432", "32141432", "14321432", "32321432", "14143232", "32143232", "14323232", "32323232", "32321432", "541412323", "323"]);
  for (var _B = 0, _A = $_.barcode.length - 1; _B <= _A; _B += 1) {
    var _F = $get($_.charvals, $geti($_.barcode, _B, 1)) !== void 0;
    if (!_F) {
      $k[$j++] = "bwipp.plesseyBadCharacter#13809";
      $k[$j++] = "Plessey must contain only digits and letters A B C D E F";
      bwipp_raiseerror();
    }
  }
  $k[$j++] = "barlen";
  $k[$j++] = $_.barcode.length;
  if ($_.validatecheck) {
    var _I = $k[--$j];
    $k[$j++] = _I - 2;
  }
  var _J = $k[--$j];
  $_[$k[--$j]] = _J;
  $_.checkbits = $a($_.barlen * 4 + 8);
  $puti($_.checkbits, $_.barlen * 4, $a([0, 0, 0, 0, 0, 0, 0, 0]));
  for (var _S = 0, _R = $_.barlen - 1; _S <= _R; _S += 1) {
    $_.i = _S;
    $_.indx = $get($_.charvals, $geti($_.barcode, $_.i, 1));
    $puti($_.checkbits, $_.i * 4, $a([$_.indx & 1, $_.indx >>> 1 & 1, $_.indx >>> 2 & 1, $_.indx >>> 3]));
  }
  $_.checksalt = $a([1, 1, 1, 1, 0, 1, 0, 0, 1]);
  for (var _i = 0, _h = $_.barlen * 4 - 1; _i <= _h; _i += 1) {
    $_.i = _i;
    if ($get($_.checkbits, $_.i) == 1) {
      for (var _m = 0; _m <= 8; _m += 1) {
        $_.j = _m;
        $put($_.checkbits, $_.i + $_.j, $xo($get($_.checkbits, $_.i + $_.j), $get($_.checksalt, $_.j)));
      }
    }
  }
  $_.checkval = 0;
  for (var _x = 0; _x <= 7; _x += 1) {
    $_.i = _x;
    $_.checkval = $f($_.checkval + ~~$pow(2, $_.i) * $get($_.checkbits, $f($_.barlen * 4 + $_.i)));
  }
  $_.checksum1 = $_.checkval & 15;
  $_.checksum2 = $_.checkval >>> 4;
  if ($_.validatecheck) {
    if ($get($_.barcode, $_.barlen) != $get($_.barchars, $_.checksum1) || $get($_.barcode, $_.barlen + 1) != $get($_.barchars, $_.checksum2)) {
      $k[$j++] = "bwipp.plesseyBadCheckDigits#13848";
      $k[$j++] = "Incorrect Plessey check digits provided";
      bwipp_raiseerror();
    }
    $_.barcode = $geti($_.barcode, 0, $_.barlen);
  }
  var _1O = $_.unidirectional ? 27 : 33;
  $_.sbs = $s($f($_.barlen * 8 + _1O));
  $_.txt = $a($_.barlen + 2);
  $puti($_.sbs, 0, $get($_.encs, 16));
  for (var _1X = 0, _1W = $_.barlen - 1; _1X <= _1W; _1X += 1) {
    $_.i = _1X;
    $_.indx = $get($_.charvals, $geti($_.barcode, $_.i, 1));
    $puti($_.sbs, $_.i * 8 + 8, $get($_.encs, $_.indx));
    $put($_.txt, $_.i, $a([$geti($_.barcode, $_.i, 1), $_.i * 20 + 20, $_.textyoffset, $_.textfont, $_.textsize]));
  }
  $puti($_.sbs, $_.barlen * 8 + 8, $get($_.encs, $_.checksum1));
  $puti($_.sbs, $_.barlen * 8 + 16, $get($_.encs, $_.checksum2));
  if ($_.includecheckintext) {
    $put($_.txt, $_.barlen, $a([$geti($_.barchars, $_.checksum1, 1), $_.barlen * 20 + 20, $_.textyoffset, $_.textfont, $_.textsize]));
    $put($_.txt, $_.barlen + 1, $a([$geti($_.barchars, $_.checksum2, 1), ($_.barlen + 1) * 20 + 20, $_.textyoffset, $_.textfont, $_.textsize]));
  } else {
    $put($_.txt, $_.barlen, $a([" ", $_.barlen * 20 + 20, $_.textyoffset, $_.textfont, $_.textsize]));
    $put($_.txt, $_.barlen + 1, $a([" ", ($_.barlen + 1) * 20 + 20, $_.textyoffset, $_.textfont, $_.textsize]));
  }
  var _2f = $_.unidirectional ? 18 : 17;
  $puti($_.sbs, $_.barlen * 8 + 24, $get($_.encs, _2f));
  $k[$j++] = Infinity;
  $k[$j++] = Infinity;
  var _2h = $_.sbs;
  for (var _2i = 0, _2j = _2h.length; _2i < _2j; _2i++) {
    $k[$j++] = $get(_2h, _2i) - 48;
  }
  var _2l = $a();
  $k[$j++] = Infinity;
  for (var _2n = 0, _2o = ~~(($_.sbs.length + 1) / 2); _2n < _2o; _2n++) {
    $k[$j++] = $_.height;
  }
  var _2q = $a();
  $k[$j++] = Infinity;
  for (var _2s = 0, _2t = ~~(($_.sbs.length + 1) / 2); _2s < _2t; _2s++) {
    $k[$j++] = 0;
  }
  var _2u = $a();
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "sbs";
  $k[$j++] = _2l;
  $k[$j++] = "bhs";
  $k[$j++] = _2q;
  $k[$j++] = "bbs";
  $k[$j++] = _2u;
  if ($_.includetext) {
    $k[$j++] = "txt";
    $k[$j++] = $_.txt;
  }
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  var _2y = $d();
  $k[$j++] = _2y;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_telepen() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.numeric = false;
  $_.dontdraw = false;
  $_.includetext = false;
  $_.textfont = "OCR-B";
  $_.textsize = 10;
  $_.textyoffset = -8;
  $_.height = 1;
  $_.parse = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  var _3 = /* @__PURE__ */ new Map([
    ["parse", $_.parse],
    ["parseonly", true],
    ["parsefnc", false]
  ]);
  $_.fncvals = _3;
  $k[$j++] = "barcode";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.fncvals;
  bwipp_parseinput();
  var _6 = $k[--$j];
  $_[$k[--$j]] = _6;
  $_.barlen = $_.barcode.length;
  delete $_.options["parse"];
  if ($_.numeric && $_.barlen % 2 != 0) {
    $k[$j++] = "bwipp.telepenNumericOddLength#13955";
    $k[$j++] = "Telepen Numeric must have an even length";
    bwipp_raiseerror();
  }
  $_.encs = $a(["31313131", "1131313111", "33313111", "1111313131", "3111313111", "11333131", "13133131", "111111313111", "31333111", "1131113131", "33113131", "1111333111", "3111113131", "1113133111", "1311133111", "111111113131", "3131113111", "11313331", "333331", "111131113111", "31113331", "1133113111", "1313113111", "1111113331", "31131331", "113111113111", "3311113111", "1111131331", "311111113111", "1113111331", "1311111331", "11111111113111", "31313311", "1131311131", "33311131", "1111313311", "3111311131", "11333311", "13133311", "111111311131", "31331131", "1131113311", "33113311", "1111331131", "3111113311", "1113131131", "1311131131", "111111113311", "3131111131", "1131131311", "33131311", "111131111131", "3111131311", "1133111131", "1313111131", "111111131311", "3113111311", "113111111131", "3311111131", "111113111311", "311111111131", "111311111311", "131111111311", "11111111111131", "3131311111", "11313133", "333133", "111131311111", "31113133", "1133311111", "1313311111", "1111113133", "313333", "113111311111", "3311311111", "11113333", "311111311111", "11131333", "13111333", "11111111311111", "31311133", "1131331111", "33331111", "1111311133", "3111331111", "11331133", "13131133", "111111331111", "3113131111", "1131111133", "33111133", "111113131111", "3111111133", "111311131111", "131111131111", "111111111133", "31311313", "113131111111", "3331111111", "1111311313", "311131111111", "11331313", "13131313", "11111131111111", "3133111111", "1131111313", "33111313", "111133111111", "3111111313", "111313111111", "131113111111", "111111111313", "313111111111", "1131131113", "33131113", "11113111111111", "3111131113", "113311111111", "131311111111", "111111131113", "3113111113", "11311111111111", "331111111111", "111113111113", "31111111111111", "111311111113", "131111111113", "1111111111111111"]);
  $_.sbs = $s($_.barlen * 16 + 48);
  $_.txt = $a($_.barlen);
  $_.enc = $get($_.encs, 95);
  $puti($_.sbs, 0, $_.enc);
  $_.l = $_.enc.length;
  $_.checksum = 0;
  $_.i = 0;
  $_.j = 0;
  for (; ; ) {
    if ($_.i == $_.barlen) {
      break;
    }
    if ($_.numeric) {
      if ($get($_.barcode, $_.i) > 16) {
        $_.np = $geti($_.barcode, $_.i, 2);
        var _X = $get($_.np, 0);
        var _Z = $get($_.np, 1);
        if (_X < 48 || _X > 57 || (_Z < 48 || _Z > 57) && !(_Z == 88)) {
          $k[$j++] = -1;
        } else {
          var _e = $get($_.np, 1) - 48;
          $k[$j++] = $get($_.np, 0) - 48;
          $k[$j++] = _e;
          if (_e != 40) {
            var _f = $k[--$j];
            var _g = $k[--$j];
            $k[$j++] = $f(_f + _g * 10) + 10;
          } else {
            $j--;
          }
          var _h = $k[--$j];
          $k[$j++] = _h + 17;
        }
        var _i = $k[$j - 1];
        if (_i == -1) {
          $k[$j++] = "bwipp.telepenInvalidNumericCharacter#14021";
          $k[$j++] = "Telepen Numeric may contain only digits, or X in even positions";
          bwipp_raiseerror();
        }
        $_.indx = $k[--$j];
        $put($_.txt, $_.j, $a([$_.np, $_.j * 16 + 16, $_.textyoffset, $_.textfont, $_.textsize]));
        $_.i = $_.i + 2;
      } else {
        $_.indx = $get($_.barcode, $_.i);
        $put($_.txt, $_.j, $a([" ", $_.j * 16 + 16, $_.textyoffset, $_.textfont, $_.textsize]));
        $_.i = $_.i + 1;
      }
    } else {
      $_.indx = $get($_.barcode, $_.i);
      if ($_.indx > 127) {
        $k[$j++] = "bwipp.telepenInvalidAlphaCharacter#14034";
        $k[$j++] = "Telepen Alpha characters must have ordinal values 0 to 127";
        bwipp_raiseerror();
      }
      if ($_.indx >= 32 && $_.indx <= 126) {
        $put($_.txt, $_.j, $a([$geti($_.barcode, $_.i, 1), $_.j * 16 + 16, $_.textyoffset, $_.textfont, $_.textsize]));
      } else {
        $put($_.txt, $_.j, $a([" ", $_.j * 16 + 16, $_.textyoffset, $_.textfont, $_.textsize]));
      }
      $_.i = $_.i + 1;
    }
    $_.checksum = $f($_.checksum + $_.indx);
    $_.enc = $get($_.encs, $_.indx);
    $puti($_.sbs, $_.l, $_.enc);
    $_.l = $_.l + $_.enc.length;
    $_.j = $_.j + 1;
  }
  $_.checksum = (127 - $_.checksum % 127) % 127;
  $_.enc = $get($_.encs, $_.checksum);
  $puti($_.sbs, $_.l, $_.enc);
  $_.l = $_.l + $_.enc.length;
  $_.enc = $get($_.encs, 122);
  $puti($_.sbs, $_.l, $_.enc);
  $_.l = $_.l + $_.enc.length;
  $_.sbs = $geti($_.sbs, 0, $_.l);
  $_.txt = $geti($_.txt, 0, $_.j);
  $k[$j++] = Infinity;
  $k[$j++] = Infinity;
  var _1z = $_.sbs;
  for (var _20 = 0, _21 = _1z.length; _20 < _21; _20++) {
    $k[$j++] = $get(_1z, _20) - 48;
  }
  var _23 = $a();
  $k[$j++] = Infinity;
  for (var _25 = 0, _26 = ~~(($_.sbs.length + 1) / 2); _25 < _26; _25++) {
    $k[$j++] = $_.height;
  }
  var _28 = $a();
  $k[$j++] = Infinity;
  for (var _2A = 0, _2B = ~~(($_.sbs.length + 1) / 2); _2A < _2B; _2A++) {
    $k[$j++] = 0;
  }
  var _2C = $a();
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "sbs";
  $k[$j++] = _23;
  $k[$j++] = "bhs";
  $k[$j++] = _28;
  $k[$j++] = "bbs";
  $k[$j++] = _2C;
  if ($_.includetext) {
    $k[$j++] = "txt";
    $k[$j++] = $_.txt;
  }
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  var _2G = $d();
  $k[$j++] = _2G;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_telepennumeric() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $put($_.options, "dontdraw", true);
  $put($_.options, "numeric", true);
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_telepen();
  var _6 = $k[--$j];
  $_[$k[--$j]] = _6;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_posicode() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.textfont = "OCR-B";
  $_.textsize = 10;
  $_.textxoffset = 0;
  $_.textyoffset = -8;
  $_.height = 1;
  $_.encoding = "auto";
  $_.version = "a";
  $_.checkoffset = 0;
  $_.raw = false;
  $_.parse = false;
  $_.parsefnc = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  var _1 = $k[--$j];
  $_.barcode = _1;
  $_.la0 = -1;
  $_.la1 = -2;
  $_.la2 = -3;
  $_.sf0 = -4;
  $_.sf1 = -5;
  $_.sf2 = -6;
  $_.fn1 = -7;
  $_.fn2 = -8;
  $_.fn3 = -9;
  $_.fn4 = -10;
  var _r = $a([$_.sf1, $_.sf0, $_.fn3]);
  $_.charmapsnormal = $a([$a(["0", "^", "'"]), $a(["1", ";", 27]), $a(["2", "<", 28]), $a(["3", "=", 29]), $a(["4", ">", 30]), $a(["5", "?", 31]), $a(["6", "@", "!"]), $a(["7", "[", '"']), $a(["8", 92, "#"]), $a(["9", "]", "&"]), $a(["A", "a", 1]), $a(["B", "b", 2]), $a(["C", "c", 3]), $a(["D", "d", 4]), $a(["E", "e", 5]), $a(["F", "f", 6]), $a(["G", "g", 7]), $a(["H", "h", 8]), $a(["I", "i", 9]), $a(["J", "j", 10]), $a(["K", "k", 11]), $a(["L", "l", 12]), $a(["M", "m", 13]), $a(["N", "n", 14]), $a(["O", "o", 15]), $a(["P", "p", 16]), $a(["Q", "q", 17]), $a(["R", "r", 18]), $a(["S", "s", 19]), $a(["T", "t", 20]), $a(["U", "u", 21]), $a(["V", "v", 22]), $a(["W", "w", 23]), $a(["X", "x", 24]), $a(["Y", "y", 25]), $a(["Z", "z", 26]), $a(["-", "_", 40]), $a([".", "`", 41]), $a([" ", 127, 0]), $a(["$", "{", "*"]), $a(["/", "|", ","]), $a(["+", "}", ":"]), $a(["%", "~", $_.fn1]), $a([$_.la1, $_.la0, $_.fn2]), _r, $a([$_.sf2, $_.sf2, $_.fn4])]);
  $_.chapmapslimited = $a([$a(["0", -98, -98]), $a(["1", -98, -98]), $a(["2", -98, -98]), $a(["3", -98, -98]), $a(["4", -98, -98]), $a(["5", -98, -98]), $a(["6", -98, -98]), $a(["7", -98, -98]), $a(["8", -98, -98]), $a(["9", -98, -98]), $a(["A", -98, -98]), $a(["B", -98, -98]), $a(["C", -98, -98]), $a(["D", -98, -98]), $a(["E", -98, -98]), $a(["F", -98, -98]), $a(["G", -98, -98]), $a(["H", -98, -98]), $a(["I", -98, -98]), $a(["J", -98, -98]), $a(["K", -98, -98]), $a(["L", -98, -98]), $a(["M", -98, -98]), $a(["N", -98, -98]), $a(["O", -98, -98]), $a(["P", -98, -98]), $a(["Q", -98, -98]), $a(["R", -98, -98]), $a(["S", -98, -98]), $a(["T", -98, -98]), $a(["U", -98, -98]), $a(["V", -98, -98]), $a(["W", -98, -98]), $a(["X", -98, -98]), $a(["Y", -98, -98]), $a(["Z", -98, -98]), $a(["-", -98, -98]), $a([".", -98, -98])]);
  if ($ne($_.version, "a") && $ne($_.version, "b") && $ne($_.version, "limiteda") && $ne($_.version, "limitedb")) {
    $k[$j++] = "bwipp.posicodeInvalidVersion#14226";
    $k[$j++] = "The version must be either a, b, limiteda or limitedb";
    bwipp_raiseerror();
  }
  $k[$j++] = "charmaps";
  if ($eq($_.version, "a") || $eq($_.version, "b")) {
    $k[$j++] = $_.charmapsnormal;
  } else {
    $k[$j++] = $_.chapmapslimited;
  }
  var _1j = $k[--$j];
  $_[$k[--$j]] = _1j;
  $_.charmaps;
  $_.charmaps;
  $_.charmaps;
  $_.charvals = $a([/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map()]);
  for (var _1r = 0, _1q = $_.charmaps.length - 1; _1r <= _1q; _1r += 1) {
    $_.i = _1r;
    $_.encs = $get($_.charmaps, $_.i);
    for (var _1v = 0; _1v <= 2; _1v += 1) {
      $_.j = _1v;
      var _1y = $get($_.encs, $_.j);
      $k[$j++] = _1y;
      if ($eq($type(_1y), "stringtype")) {
        var _21 = $get($k[--$j], 0);
        $k[$j++] = _21;
      }
      $put($get($_.charvals, $_.j), $k[--$j], $_.i);
    }
  }
  $_.set0 = $get($_.charvals, 0);
  $_.set1 = $get($_.charvals, 1);
  $_.set2 = $get($_.charvals, 2);
  if ($eq($_.version, "limiteda") || $eq($_.version, "limitedb")) {
    for (var _2H = 0, _2G = $_.barcode.length - 1; _2H <= _2G; _2H += 1) {
      var _2M = $get($_.set0, $get($geti($_.barcode, _2H, 1), 0)) !== void 0;
      if (!_2M) {
        $k[$j++] = "bwipp.posicodeBadCharacter#14252";
        $k[$j++] = "Posicode limited must contain only digits, capital letters, and the symbols - and .";
        bwipp_raiseerror();
      }
    }
  }
  if ($_.raw) {
    $_.encoding = "raw";
  }
  if ($eq($_.encoding, "raw")) {
    $_.cws = $a($_.barcode.length);
    $_.i = 0;
    $_.j = 0;
    for (; ; ) {
      if ($_.i == $_.barcode.length) {
        break;
      }
      $_.cw = $cvi($geti($_.barcode, $_.i + 1, 3));
      $put($_.cws, $_.j, $_.cw);
      $_.i = $_.i + 4;
      $_.j = $_.j + 1;
    }
    $_.cws = $geti($_.cws, 0, $_.j);
    $_.text = "";
  }
  if ($eq($_.encoding, "auto")) {
    var _2k = /* @__PURE__ */ new Map([
      ["parse", $_.parse],
      ["parsefnc", $_.parsefnc],
      ["FNC1", $_.fn1],
      ["FNC2", $_.fn2],
      ["FNC3", $_.fn3]
    ]);
    $_.fncvals = _2k;
    $k[$j++] = "msg";
    $k[$j++] = $_.barcode;
    $k[$j++] = $_.fncvals;
    bwipp_parseinput();
    var _2n = $k[--$j];
    $_[$k[--$j]] = _2n;
    $_.msglen = $_.msg.length;
    $_.text = $s($_.msglen);
    for (var _2u = 0, _2t = $_.msglen - 1; _2u <= _2t; _2u += 1) {
      $_.i = _2u;
      var _2z = $get($_.msg, $_.i);
      $k[$j++] = $_.text;
      $k[$j++] = $_.i;
      $k[$j++] = _2z;
      if (_2z < 0) {
        $k[$j - 1] = 32;
      }
      var _30 = $k[--$j];
      var _31 = $k[--$j];
      $put($k[--$j], _31, _30);
    }
    $k[$j++] = Infinity;
    for (var _34 = 0, _35 = $_.msglen; _34 < _35; _34++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $_.numSA = $a();
    $k[$j++] = Infinity;
    for (var _38 = 0, _39 = $_.msglen; _38 < _39; _38++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $_.numEA = $a();
    for (var _3C = $_.msglen - 1; _3C >= 0; _3C -= 1) {
      $_.i = _3C;
      if ($get($_.msg, $_.i) >= 0) {
        if ($get($_.msg, $_.i) >= 128) {
          $put($_.numEA, $_.i, $get($_.numEA, $_.i + 1) + 1);
        } else {
          $put($_.numSA, $_.i, $get($_.numSA, $_.i + 1) + 1);
        }
      }
    }
    $_.ea = false;
    $_.msgtmp = $a([]);
    for (var _3W = 0, _3V = $_.msglen - 1; _3W <= _3V; _3W += 1) {
      $_.i = _3W;
      $_.c = $get($_.msg, $_.i);
      if (!($_.ea != $_.c < 128) && $_.c >= 0) {
        if ($_.ea) {
          $k[$j++] = $_.numSA;
        } else {
          $k[$j++] = $_.numEA;
        }
        var _3i = $get($k[--$j], $_.i);
        var _3l = $f(_3i + $_.i) == $_.msglen ? 3 : 5;
        if (_3i < _3l) {
          $k[$j++] = Infinity;
          $aload($_.msgtmp);
          $k[$j++] = $_.fn4;
          $_.msgtmp = $a();
        } else {
          $k[$j++] = Infinity;
          $aload($_.msgtmp);
          $k[$j++] = $_.fn4;
          $k[$j++] = $_.fn4;
          $_.msgtmp = $a();
          $_.ea = !$_.ea;
        }
      }
      $k[$j++] = Infinity;
      $aload($_.msgtmp);
      if ($_.c >= 0) {
        $k[$j++] = $_.c & 127;
      } else {
        $k[$j++] = $_.c;
      }
      $_.msgtmp = $a();
    }
    $_.msg = $_.msgtmp;
    $_.msglen = $_.msg.length;
    $_.enc = function() {
      var _41 = $k[--$j];
      $put($_.cws, $_.j, $get(_41, $k[--$j]));
      $_.j = $_.j + 1;
    };
    $_.cws = $a($_.msglen * 2);
    $_.i = 0;
    $_.j = 0;
    $_.cset = "set0";
    for (; ; ) {
      if ($_.i == $_.msglen) {
        break;
      }
      for (; ; ) {
        $_.char1 = $get($_.msg, $_.i);
        $k[$j++] = "char2";
        if ($_.i + 1 < $_.msglen) {
          $k[$j++] = $get($_.msg, $_.i + 1);
        } else {
          $k[$j++] = -99;
        }
        var _4J = $k[--$j];
        $_[$k[--$j]] = _4J;
        var _4O = $get($_[$_.cset], $_.char1) !== void 0;
        if (_4O) {
          $k[$j++] = $_.char1;
          $k[$j++] = $_[$_.cset];
          $_.enc();
          $_.i = $_.i + 1;
          break;
        }
        var _4V = $get($_.set2, $_.char1) !== void 0;
        if (_4V) {
          $k[$j++] = $_.sf2;
          $k[$j++] = $_[$_.cset];
          $_.enc();
          $k[$j++] = $_.char1;
          $k[$j++] = $_.set2;
          $_.enc();
          $_.i = $_.i + 1;
          break;
        }
        var _4f = $get($_[$_.cset], $_.char2) !== void 0;
        if (!_4f) {
          if ($eq($_.cset, "set0")) {
            $k[$j++] = $_.la1;
            $k[$j++] = $_[$_.cset];
            $_.enc();
            $_.cset = "set1";
          } else {
            $k[$j++] = $_.la0;
            $k[$j++] = $_[$_.cset];
            $_.enc();
            $_.cset = "set0";
          }
          break;
        } else {
          if ($eq($_.cset, "set0")) {
            $k[$j++] = $_.sf1;
            $k[$j++] = $_[$_.cset];
            $_.enc();
            $k[$j++] = $_.char1;
            $k[$j++] = $_.set1;
            $_.enc();
          } else {
            $k[$j++] = $_.sf0;
            $k[$j++] = $_[$_.cset];
            $_.enc();
            $k[$j++] = $_.char1;
            $k[$j++] = $_.set0;
            $_.enc();
          }
          $_.i = $_.i + 1;
          break;
        }
      }
    }
    $_.cws = $geti($_.cws, 0, $_.j);
  }
  var _56 = /* @__PURE__ */ new Map([
    ["a", $a(["141112", "131212", "121312", "111412", "131113", "121213", "111313", "121114", "111214", "111115", "181111", "171211", "161311", "151411", "141511", "131611", "121711", "111811", "171112", "161212", "151312", "141412", "131512", "121612", "111712", "161113", "151213", "141313", "131413", "121513", "111613", "151114", "141214", "131314", "121414", "111514", "141115", "131215", "121315", "111415", "131116", "121216", "111316", "121117", "111217", "111118", "1<111112", "111111111;1"])],
    ["b", $a(["151213", "141313", "131413", "121513", "141214", "131314", "121414", "131215", "121315", "121216", "191212", "181312", "171412", "161512", "151612", "141712", "131812", "121912", "181213", "171313", "161413", "151513", "141613", "131713", "121813", "171214", "161314", "151414", "141514", "131614", "121714", "161215", "151315", "141415", "131515", "121615", "151216", "141316", "131416", "121516", "141217", "131317", "121417", "131218", "121318", "121219", "1<121312", "121212121<1"])],
    ["limiteda", $a(["111411", "111312", "111213", "111114", "121311", "121212", "121113", "141111", "131211", "131112", "171111", "161211", "151311", "141411", "131511", "121611", "111711", "161112", "151212", "141312", "131412", "121512", "111612", "151113", "141213", "131313", "121413", "111513", "141114", "131214", "121314", "111414", "131115", "121215", "111315", "121116", "111216", "111117", "151111", "1"])],
    ["limitedb", $a(["121512", "121413", "121314", "121215", "131412", "131313", "131214", "151212", "141312", "141213", "181212", "171312", "161412", "151512", "141612", "131712", "121812", "171213", "161313", "151413", "141513", "131613", "121713", "161214", "151314", "141414", "131514", "121614", "151215", "141315", "131415", "121515", "141216", "131316", "121416", "131217", "121317", "121218", "141212", "1"])]
  ]);
  $_.encmaps = _56;
  $_.encs = $get($_.encmaps, $_.version);
  $_.c2w = $a([$a([495, 330, 210, 126, 70, 35, 15, 5]), $a([165, 120, 84, 56, 35, 20, 10, 4]), $a([45, 36, 28, 21, 15, 10, 6, 3]), $a([9, 8, 7, 6, 5, 4, 3, 2]), $a([1, 1, 1, 1, 1, 1, 1, 1])]);
  $_.v = 0;
  var _5I = $_.cws;
  for (var _5J = 0, _5K = _5I.length; _5J < _5K; _5J++) {
    $_.cw = $get(_5I, _5J);
    for (var _5M = 0; _5M < 6; _5M++) {
      if ((($_.cw ^ $_.v) & 1) != 0) {
        $_.v = $_.v ^ 7682;
      }
      $_.v = $_.v >>> 1;
      $_.cw = $_.cw >>> 1;
    }
  }
  $_.v = $_.v + $_.checkoffset;
  if ($eq($_.version, "limiteda") || $eq($_.version, "limitedb")) {
    $_.v = $_.v & 1023;
    if ($_.v > 824 && $_.v < 853) {
      $_.v = $_.v + 292;
    }
  } else {
    $_.v = ($_.v & 1023) + 45;
  }
  $_.d = $a([2, 2, 2, 2, 2, 2]);
  $_.r = 0;
  $_.c = 0;
  $_.w = 0;
  $_.sum = 0;
  for (; ; ) {
    if ($_.sum == $_.v) {
      break;
    }
    $_.t = $f($_.sum + $get($get($_.c2w, $_.r), $_.c));
    if ($_.t == $_.v) {
      $_.w = $_.w + 1;
      $put($_.d, $_.r, $_.w + 2);
      $_.sum = $_.t;
    }
    if ($_.t > $_.v) {
      $put($_.d, $_.r, $_.w + 2);
      $_.r = $_.r + 1;
      $_.w = 0;
    }
    if ($_.t < $_.v) {
      $_.c = $_.c + 1;
      $_.w = $_.w + 1;
      $_.sum = $_.t;
    }
  }
  $k[$j++] = 20;
  for (var _62 = 0; _62 <= 4; _62 += 1) {
    var _65 = $k[--$j];
    $k[$j++] = $f(_65 - $get($_.d, _62));
  }
  $put($_.d, 5, $k[--$j]);
  if ($eq($_.version, "b") || $eq($_.version, "limitedb")) {
    $k[$j++] = Infinity;
    var _6A = $_.d;
    for (var _6B = 0, _6C = _6A.length; _6B < _6C; _6B++) {
      $k[$j++] = $get(_6A, _6B) + 1;
    }
    $_.d = $a();
  }
  $_.cbs = $strcpy($s(12), "111111111111");
  for (var _6H = 5; _6H >= 0; _6H -= 1) {
    $_.i = _6H;
    $put($_.cbs, (5 - $_.i) * 2 + 1, $get($_.d, $_.i) + 47);
  }
  $_.sbs = $s($_.cws.length * 6 + 31);
  var _6R = $get($_.encs, $_.encs.length - 2);
  $puti($_.sbs, 0, _6R);
  $_.j = _6R.length;
  for (var _6V = 0, _6U = $_.cws.length - 1; _6V <= _6U; _6V += 1) {
    $_.i = _6V;
    $puti($_.sbs, $_.j, $get($_.encs, $get($_.cws, $_.i)));
    $_.j = $_.j + 6;
  }
  $puti($_.sbs, $_.j, $_.cbs);
  $_.j = $_.j + 12;
  var _6k = $get($_.encs, $_.encs.length - 1);
  $puti($_.sbs, $_.j, _6k);
  $_.j = _6k.length + $_.j;
  $_.sbs = $geti($_.sbs, 0, $_.j);
  $k[$j++] = Infinity;
  $k[$j++] = Infinity;
  var _6r = $_.sbs;
  for (var _6s = 0, _6t = _6r.length; _6s < _6t; _6s++) {
    $k[$j++] = $get(_6r, _6s) - 48;
  }
  var _6v = $a();
  $k[$j++] = Infinity;
  for (var _6x = 0, _6y = ~~(($_.sbs.length + 1) / 2); _6x < _6y; _6x++) {
    $k[$j++] = $_.height;
  }
  var _70 = $a();
  $k[$j++] = Infinity;
  for (var _72 = 0, _73 = ~~(($_.sbs.length + 1) / 2); _72 < _73; _72++) {
    $k[$j++] = 0;
  }
  var _74 = $a();
  var _7C = /* @__PURE__ */ new Map([
    ["a", 0],
    ["b", 0],
    ["limiteda", 12],
    ["limitedb", 13]
  ]);
  var _7F = /* @__PURE__ */ new Map([
    ["a", 0],
    ["b", 0],
    ["limiteda", 12],
    ["limitedb", 13]
  ]);
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "sbs";
  $k[$j++] = _6v;
  $k[$j++] = "bhs";
  $k[$j++] = _70;
  $k[$j++] = "bbs";
  $k[$j++] = _74;
  $k[$j++] = "txt";
  $k[$j++] = $a([$a([$_.text, $_.textxoffset, $_.textyoffset, $_.textfont, $_.textsize])]);
  $k[$j++] = "textxalign";
  $k[$j++] = "center";
  $k[$j++] = "borderleft";
  $k[$j++] = $get(_7C, $_.version);
  $k[$j++] = "borderright";
  $k[$j++] = $get(_7F, $_.version);
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  var _7J = $d();
  $k[$j++] = _7J;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_codablockf() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.rows = -1;
  $_.columns = 8;
  $_.rowheight = 10;
  $_.sepheight = 1;
  $_.parse = false;
  $_.parsefnc = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.columns < 4 || $_.columns > 62) {
    $k[$j++] = "bwipp.codablockfBadColumns#14582";
    $k[$j++] = "Codablock F must have 4 to 62 columns";
    bwipp_raiseerror();
  }
  if ($_.rows != -1 && ($_.rows < 2 || $_.rows > 44)) {
    $k[$j++] = "bwipp.codablockfBadRows#14586";
    $k[$j++] = "Codablock F must have 2 to 44 rows";
    bwipp_raiseerror();
  }
  if ($_.rowheight < 8) {
    $k[$j++] = "bwipp.codablockfBadRowHeight#14590";
    $k[$j++] = "Codablock F must have rowheight of at least 8";
    bwipp_raiseerror();
  }
  if ($_.sepheight < 1) {
    $k[$j++] = "bwipp.codablockfBadSepHeight#14594";
    $k[$j++] = "Codablock F must have sepheight of at least 1";
    bwipp_raiseerror();
  }
  $k[$j++] = "c";
  if ($_.columns >= 4 && $_.columns <= 62) {
    $k[$j++] = $_.columns;
  } else {
    $k[$j++] = 8;
  }
  var _C = $k[--$j];
  $_[$k[--$j]] = _C;
  $k[$j++] = "rows";
  if ($_.rows >= 2 && $_.rows <= 44) {
    $k[$j++] = $_.rows;
  } else {
    $k[$j++] = -1;
  }
  var _H = $k[--$j];
  $_[$k[--$j]] = _H;
  $_.swa = -1;
  $_.swb = -2;
  $_.swc = -3;
  $_.sft = -4;
  $_.fn1 = -5;
  $_.fn2 = -6;
  $_.fn3 = -7;
  $_.fn4 = -8;
  $_.sta = -9;
  $_.stp = -10;
  var _N = /* @__PURE__ */ new Map([
    ["parse", $_.parse],
    ["parsefnc", $_.parsefnc],
    ["FNC1", $_.fn1],
    ["FNC3", $_.fn3]
  ]);
  $_.fncvals = _N;
  $k[$j++] = "msg";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.fncvals;
  bwipp_parseinput();
  var _Q = $k[--$j];
  $_[$k[--$j]] = _Q;
  $_.msglen = $_.msg.length;
  $_.msgtmp = $a([]);
  var _U = $_.msg;
  for (var _V = 0, _W = _U.length; _V < _W; _V++) {
    $_.char = $get(_U, _V);
    $k[$j++] = Infinity;
    $aload($_.msgtmp);
    if ($_.char < 128) {
      $k[$j++] = $_.char;
    } else {
      $k[$j++] = $_.fn4;
      $k[$j++] = $_.char & 127;
    }
    $_.msgtmp = $a();
  }
  $_.kmsg = $_.msg;
  $_.msg = $_.msgtmp;
  $_.msglen = $_.msg.length;
  $_.charmaps = $a([$a([32, 32, "00"]), $a(["!", "!", "01"]), $a(['"', '"', "02"]), $a(["#", "#", "03"]), $a(["$", "$", "04"]), $a(["%", "%", "05"]), $a(["&", "&", "06"]), $a(["'", "'", "07"]), $a([40, 40, "08"]), $a([41, 41, "09"]), $a(["*", "*", "10"]), $a(["+", "+", "11"]), $a([",", ",", "12"]), $a(["-", "-", "13"]), $a([".", ".", "14"]), $a(["/", "/", "15"]), $a(["0", "0", "16"]), $a(["1", "1", "17"]), $a(["2", "2", "18"]), $a(["3", "3", "19"]), $a(["4", "4", "20"]), $a(["5", "5", "21"]), $a(["6", "6", "22"]), $a(["7", "7", "23"]), $a(["8", "8", "24"]), $a(["9", "9", "25"]), $a([":", ":", "26"]), $a([";", ";", "27"]), $a(["<", "<", "28"]), $a(["=", "=", "29"]), $a([">", ">", "30"]), $a(["?", "?", "31"]), $a(["@", "@", "32"]), $a(["A", "A", "33"]), $a(["B", "B", "34"]), $a(["C", "C", "35"]), $a(["D", "D", "36"]), $a(["E", "E", "37"]), $a(["F", "F", "38"]), $a(["G", "G", "39"]), $a(["H", "H", "40"]), $a(["I", "I", "41"]), $a(["J", "J", "42"]), $a(["K", "K", "43"]), $a(["L", "L", "44"]), $a(["M", "M", "45"]), $a(["N", "N", "46"]), $a(["O", "O", "47"]), $a(["P", "P", "48"]), $a(["Q", "Q", "49"]), $a(["R", "R", "50"]), $a(["S", "S", "51"]), $a(["T", "T", "52"]), $a(["U", "U", "53"]), $a(["V", "V", "54"]), $a(["W", "W", "55"]), $a(["X", "X", "56"]), $a(["Y", "Y", "57"]), $a(["Z", "Z", "58"]), $a(["[", "[", "59"]), $a([92, 92, "60"]), $a(["]", "]", "61"]), $a(["^", "^", "62"]), $a(["_", "_", "63"]), $a([0, "`", "64"]), $a([1, "a", "65"]), $a([2, "b", "66"]), $a([3, "c", "67"]), $a([4, "d", "68"]), $a([5, "e", "69"]), $a([6, "f", "70"]), $a([7, "g", "71"]), $a([8, "h", "72"]), $a([9, "i", "73"]), $a([10, "j", "74"]), $a([11, "k", "75"]), $a([12, "l", "76"]), $a([13, "m", "77"]), $a([14, "n", "78"]), $a([15, "o", "79"]), $a([16, "p", "80"]), $a([17, "q", "81"]), $a([18, "r", "82"]), $a([19, "s", "83"]), $a([20, "t", "84"]), $a([21, "u", "85"]), $a([22, "v", "86"]), $a([23, "w", "87"]), $a([24, "x", "88"]), $a([25, "y", "89"]), $a([26, "z", "90"]), $a([27, "{", "91"]), $a([28, "|", "92"]), $a([29, "}", "93"]), $a([30, "~", "94"]), $a([31, 127, "95"]), $a([$_.fn3, $_.fn3, "96"]), $a([$_.fn2, $_.fn2, "97"]), $a([$_.sft, $_.sft, "98"]), $a([$_.swc, $_.swc, "99"]), $a([$_.swb, $_.fn4, $_.swb]), $a([$_.fn4, $_.swa, $_.swa]), $a([$_.fn1, $_.fn1, $_.fn1]), $a([$_.sta, $_.sta, $_.sta]), $a([$_.stp, $_.stp, $_.stp])]);
  $_.charvals = $a([/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map()]);
  for (var _2p = 0, _2o = $_.charmaps.length - 1; _2p <= _2o; _2p += 1) {
    $_.i = _2p;
    $_.encs = $get($_.charmaps, $_.i);
    for (var _2t = 0; _2t <= 2; _2t += 1) {
      $_.j = _2t;
      var _2w = $get($_.encs, $_.j);
      $k[$j++] = _2w;
      if ($eq($type(_2w), "stringtype")) {
        var _2z = $get($k[--$j], 0);
        $k[$j++] = _2z;
      }
      $put($get($_.charvals, $_.j), $k[--$j], $_.i);
    }
  }
  $_.seta = $get($_.charvals, 0);
  $_.setb = $get($_.charvals, 1);
  $_.setc = $get($_.charvals, 2);
  $_.numsscr = function() {
    $_.n = 0;
    $_.s = 0;
    $_.p = $k[--$j];
    for (; ; ) {
      if ($_.p >= $_.msglen) {
        break;
      }
      if ($_.p != 0) {
        if ($get($_.msg, $_.p - 1) == $_.fn4) {
          break;
        }
      }
      var _3M = $get($_.msg, $_.p);
      var _3O = $get($_.setc, _3M) !== void 0;
      $k[$j++] = _3M;
      if (!_3O) {
        $j--;
        break;
      }
      if ($k[--$j] == $_.fn1) {
        if ($_.s % 2 == 0) {
          $_.s = $_.s + 1;
        } else {
          break;
        }
      }
      $_.n = $_.n + 1;
      $_.s = $_.s + 1;
      $_.p = $_.p + 1;
    }
    $k[$j++] = $_.n;
    $k[$j++] = $_.s;
  };
  $_.enca = function() {
    $put($_.cws, $_.j, $get($_.seta, $k[--$j]));
    $_.j = $_.j + 1;
  };
  $_.encb = function() {
    $put($_.cws, $_.j, $get($_.setb, $k[--$j]));
    $_.j = $_.j + 1;
  };
  $_.encc = function() {
    var _3k = $k[$j - 1];
    if ($ne($type(_3k), "arraytype")) {
      var _3o = $get($_.setc, $k[--$j]);
      $k[$j++] = _3o;
    } else {
      $aload($k[--$j]);
      var _3q = $k[--$j];
      var _3r = $k[--$j];
      $k[$j++] = $f(_3q - 48 + (_3r - 48) * 10);
    }
    $put($_.cws, $_.j, $k[--$j]);
    $_.j = $_.j + 1;
  };
  $_.anotb = function() {
    var _3w = $k[--$j];
    var _3y = $get($_.seta, _3w) !== void 0;
    var _40 = $get($_.setb, _3w) !== void 0;
    $k[$j++] = _3y && !_40;
  };
  $_.bnota = function() {
    var _41 = $k[--$j];
    var _43 = $get($_.setb, _41) !== void 0;
    var _45 = $get($_.seta, _41) !== void 0;
    $k[$j++] = _43 && !_45;
  };
  $k[$j++] = Infinity;
  for (var _47 = 0, _48 = $_.msg.length; _47 < _48; _47++) {
    $k[$j++] = 0;
  }
  $k[$j++] = 9999;
  $_.nextanotb = $a();
  $k[$j++] = Infinity;
  for (var _4B = 0, _4C = $_.msg.length; _4B < _4C; _4B++) {
    $k[$j++] = 0;
  }
  $k[$j++] = 9999;
  $_.nextbnota = $a();
  for (var _4F = $_.msg.length - 1; _4F >= 0; _4F -= 1) {
    $_.i = _4F;
    $k[$j++] = $get($_.msg, $_.i);
    $_.anotb();
    if ($k[--$j]) {
      $put($_.nextanotb, $_.i, 0);
    } else {
      $put($_.nextanotb, $_.i, $get($_.nextanotb, $_.i + 1) + 1);
    }
    $k[$j++] = $get($_.msg, $_.i);
    $_.bnota();
    if ($k[--$j]) {
      $put($_.nextbnota, $_.i, 0);
    } else {
      $put($_.nextbnota, $_.i, $get($_.nextbnota, $_.i + 1) + 1);
    }
  }
  $_.abeforeb = function() {
    var _4c = $k[--$j];
    $k[$j++] = $lt($get($_.nextanotb, _4c), $get($_.nextbnota, _4c));
  };
  $_.bbeforea = function() {
    var _4h = $k[--$j];
    $k[$j++] = $lt($get($_.nextbnota, _4h), $get($_.nextanotb, _4h));
  };
  $_.padrow = function() {
    for (var _4n = 0, _4o = $k[--$j]; _4n < _4o; _4n++) {
      for (; ; ) {
        if ($eq($_.cset, "seta")) {
          $k[$j++] = $_.swc;
          $_.enca();
          $_.cset = "setc";
          break;
        }
        if ($eq($_.cset, "setb")) {
          $k[$j++] = $_.swc;
          $_.encb();
          $_.cset = "setc";
          break;
        }
        if ($eq($_.cset, "setc")) {
          $k[$j++] = $_.swb;
          $_.encc();
          $_.cset = "setb";
          break;
        }
      }
    }
  };
  $_.encafitsrow = function() {
    if ($_.rem <= 2 && $get($_.msg, $_.i) == $_.fn4) {
      var _54 = $_.rem == 2 && $get($_.msg, $_.i + 1) <= 95;
      $k[$j++] = _54;
      if (_54) {
        $k[$j++] = $_.fn4;
        $_.enca();
        $k[$j++] = $get($_.msg, $_.i + 1);
        $_.enca();
        $_.i = $_.i + 2;
      }
    } else {
      $k[$j++] = $get($_.msg, $_.i);
      $_.enca();
      $_.i = $_.i + 1;
      $k[$j++] = true;
    }
  };
  $_.encbfitsrow = function() {
    if ($_.rem <= 2 && $get($_.msg, $_.i) == $_.fn4) {
      var _5N = $_.rem == 2 && $get($_.msg, $_.i + 1) >= 32;
      $k[$j++] = _5N;
      if (_5N) {
        $k[$j++] = $_.fn4;
        $_.encb();
        $k[$j++] = $get($_.msg, $_.i + 1);
        $_.encb();
        $_.i = $_.i + 2;
      }
    } else {
      $k[$j++] = $get($_.msg, $_.i);
      $_.encb();
      $_.i = $_.i + 1;
      $k[$j++] = true;
    }
  };
  $_.cws = $a(($_.c + 5) * 44);
  $_.i = 0;
  $_.j = 0;
  $_.r = 1;
  $_.lastrow = false;
  for (; ; ) {
    if ($_.lastrow) {
      break;
    }
    if ($_.r > 44) {
      $k[$j++] = "bwipp.codablockfTooBig#14803";
      $k[$j++] = "Maximum length exceeded";
      bwipp_raiseerror();
    }
    $k[$j++] = $_.sta;
    $_.enca();
    if ($_.i < $_.msglen) {
      $k[$j++] = $_.i;
      $_.numsscr();
    } else {
      $k[$j++] = -1;
      $k[$j++] = -1;
    }
    $_.nums = $k[--$j];
    $_.nchars = $k[--$j];
    for (; ; ) {
      if ($_.msglen == 0) {
        $k[$j++] = $_.swb;
        $_.enca();
        $_.cset = "setb";
        break;
      }
      if ($_.nums >= 2) {
        $k[$j++] = $_.swc;
        $_.enca();
        $_.cset = "setc";
        break;
      }
      $k[$j++] = $_.i;
      $_.abeforeb();
      if ($k[--$j]) {
        $k[$j++] = $_.sft;
        $_.enca();
        $_.cset = "seta";
        break;
      }
      $k[$j++] = $_.swb;
      $_.enca();
      $_.cset = "setb";
      break;
    }
    $_.j = $_.j + 1;
    $_.endofrow = false;
    for (; ; ) {
      $_.rem = $f($_.c + 3 - $_.j % ($_.c + 5));
      if ($_.i == $_.msglen || $_.endofrow) {
        break;
      }
      $k[$j++] = $_.i;
      $_.numsscr();
      $_.nums = $k[--$j];
      $_.nchars = $k[--$j];
      $k[$j++] = "remnums";
      if ($_.nums > $_.rem * 2) {
        $k[$j++] = $_.rem * 2;
      } else {
        $k[$j++] = $_.nums;
      }
      var _63 = $k[--$j];
      $_[$k[--$j]] = _63;
      for (; ; ) {
        if (($eq($_.cset, "seta") || $eq($_.cset, "setb")) && $_.remnums >= 4 && $get($_.msg, $_.i) != $_.fn1) {
          if ($_.remnums % 2 == 0 && $_.rem >= 3) {
            $k[$j++] = $_.swc;
            if ($eq($_.cset, "seta")) {
              $_.enca();
            } else {
              $_.encb();
            }
            $_.cset = "setc";
            for (var _6G = 0; _6G < 2; _6G++) {
              if ($get($_.msg, $_.i) == $_.fn1) {
                $k[$j++] = $_.fn1;
                $_.encc();
                $_.i = $_.i + 1;
              } else {
                $k[$j++] = $geti($_.msg, $_.i, 2);
                $_.encc();
                $_.i = $_.i + 2;
              }
            }
            break;
          }
          if ($_.remnums % 2 != 0 && $_.rem >= 4) {
            $k[$j++] = $get($_.msg, $_.i);
            if ($eq($_.cset, "seta")) {
              $_.enca();
            } else {
              $_.encb();
            }
            $_.i = $_.i + 1;
            $k[$j++] = $_.swc;
            if ($eq($_.cset, "seta")) {
              $_.enca();
            } else {
              $_.encb();
            }
            $_.cset = "setc";
            for (var _6a = 0; _6a < 2; _6a++) {
              if ($get($_.msg, $_.i) == $_.fn1) {
                $k[$j++] = $_.fn1;
                $_.encc();
                $_.i = $_.i + 1;
              } else {
                $k[$j++] = $geti($_.msg, $_.i, 2);
                $_.encc();
                $_.i = $_.i + 2;
              }
            }
            break;
          }
        }
        $k[$j++] = $eq($_.cset, "setb");
        $k[$j++] = $get($_.msg, $_.i);
        $_.anotb();
        var _6p = $k[--$j];
        var _6q = $k[--$j];
        if (_6q && _6p && $_.rem >= 2) {
          if ($_.i < $_.msglen - 1) {
            $k[$j++] = $_.i + 1;
            $_.bbeforea();
            if ($k[--$j]) {
              $k[$j++] = $_.sft;
              $_.encb();
              $k[$j++] = $get($_.msg, $_.i);
              $_.enca();
              $_.i = $_.i + 1;
              break;
            }
          }
          $k[$j++] = $_.swa;
          $_.encb();
          $_.cset = "seta";
          $k[$j++] = $get($_.msg, $_.i);
          $_.enca();
          $_.i = $_.i + 1;
          break;
        }
        $k[$j++] = $eq($_.cset, "seta");
        $k[$j++] = $get($_.msg, $_.i);
        $_.bnota();
        var _7A = $k[--$j];
        var _7B = $k[--$j];
        if (_7B && _7A && $_.rem >= 2) {
          if ($_.i < $_.msglen - 1) {
            $k[$j++] = $_.i + 1;
            $_.abeforeb();
            if ($k[--$j]) {
              $k[$j++] = $_.sft;
              $_.enca();
              $k[$j++] = $get($_.msg, $_.i);
              $_.encb();
              $_.i = $_.i + 1;
              break;
            }
          }
          $k[$j++] = $_.swb;
          $_.enca();
          $_.cset = "setb";
          $k[$j++] = $get($_.msg, $_.i);
          $_.encb();
          $_.i = $_.i + 1;
          break;
        }
        if ($eq($_.cset, "setc") && $_.remnums < 2 && $_.rem >= 2) {
          $_.rem = $_.rem - 1;
          $k[$j++] = $_.i;
          $_.abeforeb();
          if ($k[--$j]) {
            $k[$j++] = $_.swa;
            $_.encc();
            $_.cset = "seta";
            $_.encafitsrow();
            if ($k[--$j]) {
              break;
            }
          } else {
            $k[$j++] = $_.swb;
            $_.encc();
            $_.cset = "setb";
            $_.encbfitsrow();
            if ($k[--$j]) {
              break;
            }
          }
        }
        var _7g = $get($_.seta, $get($_.msg, $_.i)) !== void 0;
        if ($eq($_.cset, "seta") && _7g && $_.rem >= 1) {
          $_.encafitsrow();
          if ($k[--$j]) {
            break;
          }
        }
        var _7o = $get($_.setb, $get($_.msg, $_.i)) !== void 0;
        if ($eq($_.cset, "setb") && _7o && $_.rem >= 1) {
          $_.encbfitsrow();
          if ($k[--$j]) {
            break;
          }
        }
        if ($eq($_.cset, "setc") && $_.remnums >= 2 && $_.rem >= 1) {
          if ($get($_.msg, $_.i) == $_.fn1) {
            $k[$j++] = $_.fn1;
            $_.encc();
            $_.i = $_.i + 1;
          } else {
            $k[$j++] = $geti($_.msg, $_.i, 2);
            $_.encc();
            $_.i = $_.i + 2;
          }
          break;
        }
        $_.endofrow = true;
        break;
      }
    }
    if (($_.r >= $_.rows || $_.rows == -1) && $_.r > 1 && $_.i == $_.msglen && $_.rem >= 2) {
      $k[$j++] = $_.rem - 2;
      $_.padrow();
      $_.j = $_.j + 3;
      $k[$j++] = $_.stp;
      $_.enca();
      $_.lastrow = true;
    } else {
      $k[$j++] = $_.rem;
      $_.padrow();
      $_.j = $_.j + 1;
      $k[$j++] = $_.stp;
      $_.enca();
      $_.r = $_.r + 1;
    }
  }
  $_.cws = $geti($_.cws, 0, $_.j);
  $k[$j++] = Infinity;
  for (var _8L = 64; _8L <= 95; _8L += 1) {
    $k[$j++] = _8L;
  }
  for (var _8M = 0; _8M <= 15; _8M += 1) {
    $k[$j++] = _8M;
  }
  for (var _8N = 26; _8N <= 63; _8N += 1) {
    $k[$j++] = _8N;
  }
  $_.abmap = $a();
  $k[$j++] = Infinity;
  for (var _8P = 0; _8P <= 85; _8P += 1) {
    $k[$j++] = _8P;
  }
  $_.cmap = $a();
  $_.chkmsg = $a($_.kmsg.length);
  $_.j = 0;
  for (var _8W = 0, _8V = $_.kmsg.length - 1; _8W <= _8V; _8W += 1) {
    $_.i = _8W;
    $_.char = $get($_.kmsg, $_.i);
    if ($_.char >= 0) {
      $put($_.chkmsg, $_.j, $_.char);
      $_.j = $_.j + 1;
    }
    if ($_.char == $_.fn1 && $_.i != 0) {
      $put($_.chkmsg, $_.j, 29);
      $_.j = $_.j + 1;
    }
  }
  $_.t1 = 0;
  $_.t2 = 0;
  $_.k1 = 0;
  $_.k2 = 0;
  for (var _8n = 0, _8m = $_.j - 1; _8n <= _8m; _8n += 1) {
    $_.i = _8n;
    $_.t1 = $get($_.chkmsg, $_.i) * $_.i % 86;
    $_.t2 = $f($_.t1 + $get($_.chkmsg, $_.i)) % 86;
    $_.k1 = $f($_.k1 + $_.t2) % 86;
    $_.k2 = $f($_.k2 + $_.t1) % 86;
  }
  $k[$j++] = $_.cws;
  $k[$j++] = $_.cws.length - 4;
  if ($ne($_.cset, "setc")) {
    $k[$j++] = $_.abmap;
  } else {
    $k[$j++] = $_.cmap;
  }
  var _97 = $get($k[--$j], $_.k1);
  var _98 = $k[--$j];
  $put($k[--$j], _98, _97);
  $k[$j++] = $_.cws;
  $k[$j++] = $_.cws.length - 3;
  if ($ne($_.cset, "setc")) {
    $k[$j++] = $_.abmap;
  } else {
    $k[$j++] = $_.cmap;
  }
  var _9H = $get($k[--$j], $_.k2);
  var _9I = $k[--$j];
  $put($k[--$j], _9I, _9H);
  var _9K = $_.cws;
  $k[$j++] = _9K;
  $k[$j++] = 2;
  if ($get(_9K, 2 - 1) != 99) {
    $k[$j++] = $_.abmap;
  } else {
    $k[$j++] = $_.cmap;
  }
  var _9Q = $get($k[--$j], $_.r - 2);
  var _9R = $k[--$j];
  $put($k[--$j], _9R, _9Q);
  for (var _9V = 1, _9U = $_.r - 1; _9V <= _9U; _9V += 1) {
    $_.i = _9V;
    var _9W = $_.cws;
    var _9X = $_.i;
    var _9Y = $_.c;
    $k[$j++] = _9W;
    $k[$j++] = _9X * (_9Y + 5) + 2;
    if ($get(_9W, _9X * (_9Y + 5) + 2 - 1) != 99) {
      $k[$j++] = $_.abmap;
    } else {
      $k[$j++] = $_.cmap;
    }
    var _9e = $get($k[--$j], $_.i + 42);
    var _9f = $k[--$j];
    $put($k[--$j], _9f, _9e);
  }
  for (var _9j = 0, _9i = $_.r - 1; _9j <= _9i; _9j += 1) {
    $_.rcws = $geti($_.cws, _9j * ($_.c + 5), $_.c + 4);
    $_.csum = $get($_.rcws, 0);
    for (var _9s = 1, _9r = $_.rcws.length - 2; _9s <= _9r; _9s += 1) {
      $_.i = _9s;
      $_.csum = $f($_.csum + $get($_.rcws, $_.i) * $_.i);
    }
    $put($_.rcws, $_.rcws.length - 1, $_.csum % 103);
  }
  var _A2 = $get($_.options, "debugcws") !== void 0;
  if (_A2) {
    $k[$j++] = "bwipp.debugcws#15016";
    $k[$j++] = $_.cws;
    bwipp_raiseerror();
  }
  $_.encs = $a(["212222", "222122", "222221", "121223", "121322", "131222", "122213", "122312", "132212", "221213", "221312", "231212", "112232", "122132", "122231", "113222", "123122", "123221", "223211", "221132", "221231", "213212", "223112", "312131", "311222", "321122", "321221", "312212", "322112", "322211", "212123", "212321", "232121", "111323", "131123", "131321", "112313", "132113", "132311", "211313", "231113", "231311", "112133", "112331", "132131", "113123", "113321", "133121", "313121", "211331", "231131", "213113", "213311", "213131", "311123", "311321", "331121", "312113", "312311", "332111", "314111", "221411", "431111", "111224", "111422", "121124", "121421", "141122", "141221", "112214", "112412", "122114", "122411", "142112", "142211", "241211", "221114", "413111", "241112", "134111", "111242", "121142", "121241", "114212", "124112", "124211", "411212", "421112", "421211", "212141", "214121", "412121", "111143", "111341", "131141", "114113", "114311", "411113", "411311", "113141", "114131", "311141", "411131", "211412", "2331112"]);
  $_.rowbits = $a($_.r);
  for (var _AA = 0, _A9 = $_.r - 1; _AA <= _A9; _AA += 1) {
    $_.i = _AA;
    $k[$j++] = Infinity;
    var _AF = $geti($_.cws, $_.i * ($_.c + 5), $_.c + 5);
    for (var _AG = 0, _AH = _AF.length; _AG < _AH; _AG++) {
      $forall($get($_.encs, $get(_AF, _AG)), function() {
        var _AL = $k[--$j];
        $k[$j++] = _AL - 48;
      });
    }
    $_.sbs = $a();
    $k[$j++] = Infinity;
    var _AN = $_.sbs;
    $k[$j++] = 0;
    for (var _AO = 0, _AP = _AN.length; _AO < _AP; _AO++) {
      var _AR = $k[$j - 1];
      var _AS = _AR == 1 ? 0 : 1;
      for (var _AT = 0, _AU = $get(_AN, _AO); _AT < _AU; _AT++) {
        $k[$j++] = _AS;
      }
    }
    $astore($a($counttomark() - 1));
    var _AX = $k[--$j];
    $k[$j - 1] = _AX;
    var _AZ = $k[--$j];
    $k[$j - 1] = _AZ;
    $k[$j++] = $_.rowbits;
    $k[$j++] = $_.i;
    var _Ad = $k[$j - 3];
    var _Ae = $k[$j - 1];
    $put($k[$j - 2], _Ae, _Ad);
    $j -= 3;
  }
  $_.symwid = $_.c * 11 + 57;
  $k[$j++] = Infinity;
  for (var _Aj = 0, _Ak = $_.symwid * $_.sepheight; _Aj < _Ak; _Aj++) {
    $k[$j++] = 1;
  }
  for (var _An = 0, _Am = $_.r - 2; _An <= _Am; _An += 1) {
    $_.i = _An;
    for (var _Ap = 0, _Aq = $_.rowheight; _Ap < _Aq; _Ap++) {
      $aload($get($_.rowbits, $_.i));
    }
    for (var _Av = 0, _Aw = $_.sepheight; _Av < _Aw; _Av++) {
      $k[$j++] = 1;
      $k[$j++] = 1;
      $k[$j++] = 0;
      $k[$j++] = 1;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 1;
      $k[$j++] = 0;
      $k[$j++] = 0;
      for (var _Ay = 0, _Az = $_.symwid - 24; _Ay < _Az; _Ay++) {
        $k[$j++] = 1;
      }
      $k[$j++] = 1;
      $k[$j++] = 1;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 1;
      $k[$j++] = 1;
      $k[$j++] = 1;
      $k[$j++] = 0;
      $k[$j++] = 1;
      $k[$j++] = 0;
      $k[$j++] = 1;
      $k[$j++] = 1;
    }
  }
  for (var _B1 = 0, _B2 = $_.rowheight; _B1 < _B2; _B1++) {
    $aload($get($_.rowbits, $_.r - 1));
  }
  for (var _B8 = 0, _B9 = $_.symwid * $_.sepheight; _B8 < _B9; _B8++) {
    $k[$j++] = 1;
  }
  $_.pixs = $a();
  var _BJ = /* @__PURE__ */ new Map([
    ["ren", "renmatrix"],
    ["pixs", $_.pixs],
    ["pixx", $_.symwid],
    ["pixy", ~~($_.pixs.length / $_.symwid)],
    ["height", ~~($_.pixs.length / $_.symwid) / 72],
    ["width", $_.symwid / 72],
    ["opt", $_.options]
  ]);
  $k[$j++] = _BJ;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_code16k() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.sam = -1;
  $_.rows = 0;
  $_.rowheight = 8;
  $_.sepheight = 1;
  $_.raw = false;
  $_.parse = false;
  $_.parsefnc = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.rows != 0 && ($_.rows < 2 || $_.rows > 16)) {
    $k[$j++] = "bwipp.code16kBadRows#15133";
    $k[$j++] = "Code 16K must have 2 to 16 rows";
    bwipp_raiseerror();
  }
  if ($_.rowheight < 8) {
    $k[$j++] = "bwipp.code16kBadRowHeight#15137";
    $k[$j++] = "Code 16K must have rowheight of at least 8";
    bwipp_raiseerror();
  }
  if ($_.sepheight < 1) {
    $k[$j++] = "bwipp.code16kBadSepHeight#15141";
    $k[$j++] = "Code 16K must have sepheight of at least 1";
    bwipp_raiseerror();
  }
  if ($_.sam != -1) {
    $k[$j++] = true;
    for (var _8 = 0; _8 < 1; _8++) {
      var _9 = $_.sam;
      if (_9 < 12 || _9 > 99) {
        $k[$j - 1] = false;
        break;
      }
      if ($_.sam % 10 < 2) {
        $k[$j - 1] = false;
        break;
      }
      if (~~($_.sam / 10) > $_.sam % 10) {
        $k[$j - 1] = false;
        break;
      }
    }
    if (!$k[--$j]) {
      $k[$j++] = "bwipp.code16kBadSAM#15152";
      $k[$j++] = 'SAM must be formatted as "NM" for Nth of M symbols, from 2 to 9 symbols';
      bwipp_raiseerror();
    }
  }
  if ($_.sam != -1) {
    $_.rows = 16;
  }
  $_.swa = -1;
  $_.swb = -2;
  $_.swc = -3;
  $_.sa1 = -4;
  $_.sb1 = -5;
  $_.sc1 = -6;
  $_.sa2 = -7;
  $_.sb2 = -8;
  $_.sc2 = -9;
  $_.pad = -10;
  $_.sb3 = -11;
  $_.sc3 = -12;
  $_.fn1 = -13;
  $_.fn2 = -14;
  $_.fn3 = -15;
  $_.fn4 = -16;
  $_.charmaps = $a([$a([32, 32, "00"]), $a(["!", "!", "01"]), $a(['"', '"', "02"]), $a(["#", "#", "03"]), $a(["$", "$", "04"]), $a(["%", "%", "05"]), $a(["&", "&", "06"]), $a(["'", "'", "07"]), $a([40, 40, "08"]), $a([41, 41, "09"]), $a(["*", "*", "10"]), $a(["+", "+", "11"]), $a([",", ",", "12"]), $a(["-", "-", "13"]), $a([".", ".", "14"]), $a(["/", "/", "15"]), $a(["0", "0", "16"]), $a(["1", "1", "17"]), $a(["2", "2", "18"]), $a(["3", "3", "19"]), $a(["4", "4", "20"]), $a(["5", "5", "21"]), $a(["6", "6", "22"]), $a(["7", "7", "23"]), $a(["8", "8", "24"]), $a(["9", "9", "25"]), $a([":", ":", "26"]), $a([";", ";", "27"]), $a(["<", "<", "28"]), $a(["=", "=", "29"]), $a([">", ">", "30"]), $a(["?", "?", "31"]), $a(["@", "@", "32"]), $a(["A", "A", "33"]), $a(["B", "B", "34"]), $a(["C", "C", "35"]), $a(["D", "D", "36"]), $a(["E", "E", "37"]), $a(["F", "F", "38"]), $a(["G", "G", "39"]), $a(["H", "H", "40"]), $a(["I", "I", "41"]), $a(["J", "J", "42"]), $a(["K", "K", "43"]), $a(["L", "L", "44"]), $a(["M", "M", "45"]), $a(["N", "N", "46"]), $a(["O", "O", "47"]), $a(["P", "P", "48"]), $a(["Q", "Q", "49"]), $a(["R", "R", "50"]), $a(["S", "S", "51"]), $a(["T", "T", "52"]), $a(["U", "U", "53"]), $a(["V", "V", "54"]), $a(["W", "W", "55"]), $a(["X", "X", "56"]), $a(["Y", "Y", "57"]), $a(["Z", "Z", "58"]), $a(["[", "[", "59"]), $a([92, 92, "60"]), $a(["]", "]", "61"]), $a(["^", "^", "62"]), $a(["_", "_", "63"]), $a([0, "`", "64"]), $a([1, "a", "65"]), $a([2, "b", "66"]), $a([3, "c", "67"]), $a([4, "d", "68"]), $a([5, "e", "69"]), $a([6, "f", "70"]), $a([7, "g", "71"]), $a([8, "h", "72"]), $a([9, "i", "73"]), $a([10, "j", "74"]), $a([11, "k", "75"]), $a([12, "l", "76"]), $a([13, "m", "77"]), $a([14, "n", "78"]), $a([15, "o", "79"]), $a([16, "p", "80"]), $a([17, "q", "81"]), $a([18, "r", "82"]), $a([19, "s", "83"]), $a([20, "t", "84"]), $a([21, "u", "85"]), $a([22, "v", "86"]), $a([23, "w", "87"]), $a([24, "x", "88"]), $a([25, "y", "89"]), $a([26, "z", "90"]), $a([27, "{", "91"]), $a([28, "|", "92"]), $a([29, "}", "93"]), $a([30, "~", "94"]), $a([31, 127, "95"]), $a([$_.fn3, $_.fn3, "96"]), $a([$_.fn2, $_.fn2, "97"]), $a([$_.sb1, $_.sa1, "98"]), $a([$_.swc, $_.swc, "99"]), $a([$_.swb, $_.fn4, $_.swb]), $a([$_.fn4, $_.swa, $_.swa]), $a([$_.fn1, $_.fn1, $_.fn1]), $a([$_.pad, $_.pad, $_.pad]), $a([$_.sb2, $_.sa2, $_.sb1]), $a([$_.sc2, $_.sc2, $_.sb2]), $a([$_.sc3, $_.sc3, $_.sb3])]);
  $_.charvals = $a([/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map()]);
  for (var _2V = 0, _2U = $_.charmaps.length - 1; _2V <= _2U; _2V += 1) {
    $_.i = _2V;
    $_.encs = $get($_.charmaps, $_.i);
    for (var _2Z = 0; _2Z <= 2; _2Z += 1) {
      $_.j = _2Z;
      var _2c = $get($_.encs, $_.j);
      $k[$j++] = _2c;
      if ($eq($type(_2c), "stringtype")) {
        var _2f = $get($k[--$j], 0);
        $k[$j++] = _2f;
      }
      $put($get($_.charvals, $_.j), $k[--$j], $_.i);
    }
  }
  $_.seta = $get($_.charvals, 0);
  $_.setb = $get($_.charvals, 1);
  $_.setc = $get($_.charvals, 2);
  if ($_.raw) {
    $_.cws = $a($_.barcode.length);
    $_.i = 0;
    $_.j = 0;
    for (; ; ) {
      if ($_.i >= $_.barcode.length - 3) {
        break;
      }
      if ($get($_.barcode, $_.i) != 94) {
        break;
      }
      var _32 = $geti($_.barcode, $_.i + 1, 3);
      $k[$j++] = _32;
      $k[$j++] = false;
      for (var _33 = 0, _34 = _32.length; _33 < _34; _33++) {
        var _35 = $get(_32, _33);
        if (_35 < 48 || _35 > 57) {
          $k[$j - 1] = true;
        }
      }
      if ($k[--$j]) {
        $j--;
        break;
      }
      $_.cw = $cvi($k[--$j]);
      $put($_.cws, $_.j, $_.cw);
      $_.i = $_.i + 4;
      $_.j = $_.j + 1;
    }
    if ($_.i != $_.barcode.length) {
      $k[$j++] = "bwipp.code16kBadRawFormat#15241";
      $k[$j++] = "raw data must be formatted as ^NNN";
      bwipp_raiseerror();
    }
    $_.cws = $geti($_.cws, 0, $_.j);
  } else {
    var _3N = /* @__PURE__ */ new Map([
      ["parse", $_.parse],
      ["parsefnc", $_.parsefnc],
      ["eci", true],
      ["FNC1", $_.fn1],
      ["FNC2", $_.fn2],
      ["FNC3", $_.fn3]
    ]);
    $_.fncvals = _3N;
    $k[$j++] = "msg";
    $k[$j++] = $_.barcode;
    $k[$j++] = $_.fncvals;
    bwipp_parseinput();
    var _3Q = $k[--$j];
    $_[$k[--$j]] = _3Q;
    $_.msglen = $_.msg.length;
    $k[$j++] = Infinity;
    for (var _3U = 0, _3V = $_.msglen; _3U < _3V; _3U++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $_.numSA = $a();
    $k[$j++] = Infinity;
    for (var _3Y = 0, _3Z = $_.msglen; _3Y < _3Z; _3Y++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $_.numEA = $a();
    for (var _3c = $_.msglen - 1; _3c >= 0; _3c -= 1) {
      $_.i = _3c;
      if ($get($_.msg, $_.i) >= 0) {
        if ($get($_.msg, $_.i) >= 128) {
          $put($_.numEA, $_.i, $get($_.numEA, $_.i + 1) + 1);
        } else {
          $put($_.numSA, $_.i, $get($_.numSA, $_.i + 1) + 1);
        }
      }
    }
    $_.ea = false;
    $_.msgtmp = $a([]);
    for (var _3w = 0, _3v = $_.msglen - 1; _3w <= _3v; _3w += 1) {
      $_.i = _3w;
      $_.c = $get($_.msg, $_.i);
      if (!($_.ea != $_.c < 128) && $_.c >= 0) {
        if ($_.ea) {
          $k[$j++] = $_.numSA;
        } else {
          $k[$j++] = $_.numEA;
        }
        var _48 = $get($k[--$j], $_.i);
        var _4B = $f(_48 + $_.i) == $_.msglen ? 3 : 5;
        if (_48 < _4B) {
          $k[$j++] = Infinity;
          $aload($_.msgtmp);
          $k[$j++] = $_.fn4;
          $_.msgtmp = $a();
        } else {
          $k[$j++] = Infinity;
          $aload($_.msgtmp);
          $k[$j++] = $_.fn4;
          $k[$j++] = $_.fn4;
          $_.msgtmp = $a();
          $_.ea = !$_.ea;
        }
      }
      $k[$j++] = Infinity;
      $aload($_.msgtmp);
      if ($_.c >= 0) {
        $k[$j++] = $_.c & 127;
      } else {
        $k[$j++] = $_.c;
      }
      $_.msgtmp = $a();
    }
    $_.msg = $_.msgtmp;
    $_.msglen = $_.msg.length;
    $_.numsscr = function() {
      $_.n = 0;
      $_.s = 0;
      $_.p = $k[--$j];
      for (; ; ) {
        if ($_.p >= $_.msglen) {
          break;
        }
        var _4W = $get($_.msg, $_.p);
        var _4Y = $get($_.setc, _4W) !== void 0;
        $k[$j++] = _4W;
        if (!_4Y) {
          $j--;
          break;
        }
        if ($k[--$j] == $_.fn1) {
          if ($_.s % 2 == 0) {
            $_.s = $_.s + 1;
          } else {
            break;
          }
        }
        $_.n = $_.n + 1;
        $_.s = $_.s + 1;
        $_.p = $_.p + 1;
      }
      $k[$j++] = $_.n;
      $k[$j++] = $_.s;
    };
    $_.enca = function() {
      $put($_.cws, $_.j, $get($_.seta, $k[--$j]));
      $_.j = $_.j + 1;
    };
    $_.encb = function() {
      $put($_.cws, $_.j, $get($_.setb, $k[--$j]));
      $_.j = $_.j + 1;
    };
    $_.encc = function() {
      var _4u = $k[$j - 1];
      if ($ne($type(_4u), "arraytype")) {
        var _4y = $get($_.setc, $k[--$j]);
        $k[$j++] = _4y;
      } else {
        $aload($k[--$j]);
        var _50 = $k[--$j];
        var _51 = $k[--$j];
        $k[$j++] = $f(_50 - 48 + (_51 - 48) * 10);
      }
      $put($_.cws, $_.j, $k[--$j]);
      $_.j = $_.j + 1;
    };
    $_.anotb = function() {
      var _56 = $k[--$j];
      var _58 = $get($_.seta, _56) !== void 0;
      var _5A = $get($_.setb, _56) !== void 0;
      $k[$j++] = _58 && !_5A;
    };
    $_.bnota = function() {
      var _5B = $k[--$j];
      var _5D = $get($_.setb, _5B) !== void 0;
      var _5F = $get($_.seta, _5B) !== void 0;
      $k[$j++] = _5D && !_5F;
    };
    $k[$j++] = Infinity;
    for (var _5H = 0, _5I = $_.msg.length; _5H < _5I; _5H++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 9999;
    $_.nextanotb = $a();
    $k[$j++] = Infinity;
    for (var _5L = 0, _5M = $_.msg.length; _5L < _5M; _5L++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 9999;
    $_.nextbnota = $a();
    for (var _5P = $_.msg.length - 1; _5P >= 0; _5P -= 1) {
      $_.i = _5P;
      $k[$j++] = $get($_.msg, $_.i);
      $_.anotb();
      if ($k[--$j]) {
        $put($_.nextanotb, $_.i, 0);
      } else {
        $put($_.nextanotb, $_.i, $get($_.nextanotb, $_.i + 1) + 1);
      }
      $k[$j++] = $get($_.msg, $_.i);
      $_.bnota();
      if ($k[--$j]) {
        $put($_.nextbnota, $_.i, 0);
      } else {
        $put($_.nextbnota, $_.i, $get($_.nextbnota, $_.i + 1) + 1);
      }
    }
    $_.abeforeb = function() {
      var _5m = $k[--$j];
      $k[$j++] = $lt($get($_.nextanotb, _5m), $get($_.nextbnota, _5m));
    };
    $_.bbeforea = function() {
      var _5r = $k[--$j];
      $k[$j++] = $lt($get($_.nextbnota, _5r), $get($_.nextanotb, _5r));
    };
    $_.cws = $a($_.barcode.length * 2 + 3);
    $_.i = 0;
    $_.j = 0;
    for (; ; ) {
      if ($_.sam != -1) {
        $put($_.cws, 0, ~~($_.sam / 10) - 1);
        $put($_.cws, 1, $_.sam % 10 - 1);
        $_.j = 2;
        $_.cset = "setb";
        $_.mode = 7;
        break;
      }
      if ($_.msglen == 0) {
        $_.cset = "setb";
        $_.mode = 1;
        break;
      }
      if ($_.msglen >= 2) {
        $k[$j++] = $get($_.msg, 0) == $_.fn1;
        $k[$j++] = 1;
        $_.numsscr();
        var _68 = $k[--$j];
        $k[$j - 1] = _68;
        var _6A = $k[--$j];
        var _6B = $k[--$j];
        if (_6B && _6A >= 2) {
          $_.cset = "setc";
          $_.mode = 4;
          $_.i = 1;
          break;
        }
      }
      if ($get($_.msg, 0) == $_.fn1) {
        $_.cset = "setb";
        $_.mode = 3;
        $_.i = 1;
        break;
      }
      if ($_.msglen >= 2) {
        $k[$j++] = 0;
        $_.numsscr();
        var _6G = $k[--$j];
        $k[$j - 1] = _6G;
        var _6I = $k[--$j];
        if (_6I >= 2 && _6I % 2 == 0) {
          $_.cset = "setc";
          $_.mode = 2;
          break;
        }
        $k[$j++] = 0;
        $_.numsscr();
        var _6J = $k[--$j];
        $k[$j - 1] = _6J;
        var _6L = $k[--$j];
        if (_6L >= 3 && _6L % 2 == 1) {
          $k[$j++] = $get($_.msg, 0);
          $_.encb();
          $_.cset = "setc";
          $_.mode = 5;
          $_.i = 1;
          break;
        }
        var _6R = $get($_.setb, $get($_.msg, 0)) !== void 0;
        $k[$j++] = _6R;
        $k[$j++] = 1;
        $_.numsscr();
        var _6S = $k[--$j];
        $k[$j - 1] = _6S;
        var _6U = $k[--$j];
        var _6V = $k[--$j];
        if (_6V && (_6U >= 2 && _6U % 2 == 0)) {
          $k[$j++] = $get($_.msg, 0);
          $_.encb();
          $_.cset = "setc";
          $_.mode = 5;
          $_.i = 1;
          break;
        }
        var _6b = $get($_.setb, $get($_.msg, 0)) !== void 0;
        $k[$j++] = _6b;
        $k[$j++] = 1;
        $_.numsscr();
        var _6c = $k[--$j];
        $k[$j - 1] = _6c;
        var _6e = $k[--$j];
        var _6f = $k[--$j];
        if (_6f && (_6e >= 3 && _6e % 2 == 1)) {
          $k[$j++] = $get($_.msg, 0);
          $_.encb();
          $k[$j++] = $get($_.msg, 1);
          $_.encb();
          $_.cset = "setc";
          $_.mode = 6;
          $_.i = 2;
          break;
        }
        var _6n = $get($_.setb, $get($_.msg, 0)) !== void 0;
        var _6r = $get($_.setb, $get($_.msg, 1)) !== void 0;
        $k[$j++] = _6n && _6r;
        $k[$j++] = 2;
        $_.numsscr();
        var _6s = $k[--$j];
        $k[$j - 1] = _6s;
        var _6u = $k[--$j];
        var _6v = $k[--$j];
        if (_6v && (_6u >= 2 && _6u % 2 == 0)) {
          $k[$j++] = $get($_.msg, 0);
          $_.encb();
          $k[$j++] = $get($_.msg, 1);
          $_.encb();
          $_.cset = "setc";
          $_.mode = 6;
          $_.i = 2;
          break;
        }
      }
      $k[$j++] = 0;
      $_.abeforeb();
      if ($k[--$j]) {
        $_.cset = "seta";
        $_.mode = 0;
        break;
      }
      $_.cset = "setb";
      $_.mode = 1;
      break;
    }
    for (; ; ) {
      if ($_.i == $_.msglen) {
        break;
      }
      $k[$j++] = $_.i;
      $_.numsscr();
      $_.nums = $k[--$j];
      $_.nchars = $k[--$j];
      for (; ; ) {
        if ($eq($_.cset, "seta")) {
          if ($_.i < $_.msglen - 1) {
            $k[$j++] = $get($_.msg, $_.i);
            $_.bnota();
            $k[$j++] = $_.i + 1;
            $_.abeforeb();
            var _7D = $k[--$j];
            if ($k[--$j] && _7D) {
              $k[$j++] = $_.sb1;
              $_.enca();
              $k[$j++] = $get($_.msg, $_.i);
              $_.encb();
              $_.i = $_.i + 1;
              break;
            }
          }
          if ($_.i < $_.msglen - 2) {
            $k[$j++] = $get($_.msg, $_.i);
            $_.bnota();
            $k[$j++] = $get($_.msg, $_.i + 1);
            $_.bnota();
            var _7S = $k[--$j];
            var _7T = $k[--$j];
            $k[$j++] = $an(_7T, _7S);
            $k[$j++] = $_.i + 2;
            $_.abeforeb();
            var _7V = $k[--$j];
            if ($k[--$j] && _7V) {
              $k[$j++] = $_.sb2;
              $_.enca();
              $k[$j++] = $get($_.msg, $_.i);
              $_.encb();
              $k[$j++] = $get($_.msg, $_.i + 1);
              $_.encb();
              $_.i = $_.i + 2;
              break;
            }
          }
          $k[$j++] = $get($_.msg, $_.i);
          $_.bnota();
          if ($k[--$j]) {
            $k[$j++] = $_.swb;
            $_.enca();
            $_.cset = "setb";
            break;
          }
          if ($_.i < $_.msglen - 4) {
            var _7r = $get($_.seta, $get($_.msg, $_.i + 4)) !== void 0;
            if ($_.nums == 4 && _7r) {
              $k[$j++] = $_.sc2;
              $_.enca();
              for (var _7t = 0; _7t < 2; _7t++) {
                if ($get($_.msg, $_.i) == $_.fn1) {
                  $k[$j++] = $_.fn1;
                  $_.encc();
                  $_.i = $_.i + 1;
                } else {
                  $k[$j++] = $geti($_.msg, $_.i, 2);
                  $_.encc();
                  $_.i = $_.i + 2;
                }
              }
              break;
            }
          }
          if ($_.i < $_.msglen - 6) {
            var _8B = $get($_.seta, $get($_.msg, $_.i + 6)) !== void 0;
            if ($_.nums == 6 && _8B) {
              $k[$j++] = $_.sc3;
              $_.enca();
              for (var _8D = 0; _8D < 3; _8D++) {
                if ($get($_.msg, $_.i) == $_.fn1) {
                  $k[$j++] = $_.fn1;
                  $_.encc();
                  $_.i = $_.i + 1;
                } else {
                  $k[$j++] = $geti($_.msg, $_.i, 2);
                  $_.encc();
                  $_.i = $_.i + 2;
                }
              }
              break;
            }
          }
          if ($_.nums >= 4 && $_.nums % 2 == 0) {
            $k[$j++] = $_.swc;
            $_.enca();
            $_.cset = "setc";
            break;
          }
          $k[$j++] = $get($_.msg, $_.i);
          $_.enca();
          $_.i = $_.i + 1;
          break;
        }
        if ($eq($_.cset, "setb")) {
          if ($_.i < $_.msglen - 1) {
            $k[$j++] = $get($_.msg, $_.i);
            $_.anotb();
            $k[$j++] = $_.i + 1;
            $_.bbeforea();
            var _8c = $k[--$j];
            if ($k[--$j] && _8c) {
              $k[$j++] = $_.sa1;
              $_.encb();
              $k[$j++] = $get($_.msg, $_.i);
              $_.enca();
              $_.i = $_.i + 1;
              break;
            }
          }
          if ($_.i < $_.msglen - 2) {
            $k[$j++] = $get($_.msg, $_.i);
            $_.anotb();
            $k[$j++] = $get($_.msg, $_.i + 1);
            $_.anotb();
            var _8r = $k[--$j];
            var _8s = $k[--$j];
            $k[$j++] = $an(_8s, _8r);
            $k[$j++] = $_.i + 2;
            $_.bbeforea();
            var _8u = $k[--$j];
            if ($k[--$j] && _8u) {
              $k[$j++] = $_.sa2;
              $_.encb();
              $k[$j++] = $get($_.msg, $_.i);
              $_.enca();
              $k[$j++] = $get($_.msg, $_.i + 1);
              $_.enca();
              $_.i = $_.i + 2;
              break;
            }
          }
          $k[$j++] = $get($_.msg, $_.i);
          $_.anotb();
          if ($k[--$j]) {
            $k[$j++] = $_.swa;
            $_.encb();
            $_.cset = "seta";
            break;
          }
          if ($_.i < $_.msglen - 4) {
            var _9G = $get($_.setb, $get($_.msg, $_.i + 4)) !== void 0;
            if ($_.nums == 4 && _9G) {
              $k[$j++] = $_.sc2;
              $_.encb();
              for (var _9I = 0; _9I < 2; _9I++) {
                if ($get($_.msg, $_.i) == $_.fn1) {
                  $k[$j++] = $_.fn1;
                  $_.encc();
                  $_.i = $_.i + 1;
                } else {
                  $k[$j++] = $geti($_.msg, $_.i, 2);
                  $_.encc();
                  $_.i = $_.i + 2;
                }
              }
              break;
            }
          }
          if ($_.i < $_.msglen - 6) {
            var _9a = $get($_.setb, $get($_.msg, $_.i + 6)) !== void 0;
            if ($_.nums == 6 && _9a) {
              $k[$j++] = $_.sc3;
              $_.encb();
              for (var _9c = 0; _9c < 3; _9c++) {
                if ($get($_.msg, $_.i) == $_.fn1) {
                  $k[$j++] = $_.fn1;
                  $_.encc();
                  $_.i = $_.i + 1;
                } else {
                  $k[$j++] = $geti($_.msg, $_.i, 2);
                  $_.encc();
                  $_.i = $_.i + 2;
                }
              }
              break;
            }
          }
          if ($_.nums >= 4 && $_.nums % 2 == 0) {
            $k[$j++] = $_.swc;
            $_.encb();
            $_.cset = "setc";
            break;
          }
          $k[$j++] = $get($_.msg, $_.i);
          $_.encb();
          $_.i = $_.i + 1;
          break;
        }
        if ($eq($_.cset, "setc")) {
          if ($_.nums >= 2) {
            if ($get($_.msg, $_.i) == $_.fn1) {
              $k[$j++] = $_.fn1;
              $_.encc();
              $_.i = $_.i + 1;
            } else {
              $k[$j++] = $geti($_.msg, $_.i, 2);
              $_.encc();
              $_.i = $_.i + 2;
            }
            break;
          }
          if ($_.i < $_.msglen - 1) {
            var _AC = $get($_.setb, $get($_.msg, $_.i)) !== void 0;
            $k[$j++] = _AC;
            $k[$j++] = $_.i + 1;
            $_.numsscr();
            var _AE = $k[--$j];
            $k[$j - 1] = _AE;
            var _AG = $k[--$j];
            var _AH = $k[--$j];
            if (_AH && (_AG >= 2 && _AG % 2 == 0)) {
              $k[$j++] = $_.sb1;
              $_.encc();
              $k[$j++] = $get($_.msg, $_.i);
              $_.encb();
              $_.i = $_.i + 1;
              break;
            }
          }
          if ($_.i < $_.msglen - 1) {
            var _AT = $get($_.setb, $get($_.msg, $_.i)) !== void 0;
            $k[$j++] = _AT;
            $k[$j++] = $_.i + 1;
            $_.numsscr();
            var _AV = $k[--$j];
            $k[$j - 1] = _AV;
            var _AX = $k[--$j];
            var _AY = $k[--$j];
            if (_AY && (_AX >= 3 && _AX % 2 == 1)) {
              $k[$j++] = $_.sb2;
              $_.encc();
              $k[$j++] = $get($_.msg, $_.i);
              $_.encb();
              $k[$j++] = $get($_.msg, $_.i + 1);
              $_.encb();
              $_.i = $_.i + 2;
              break;
            }
          }
          if ($_.i < $_.msglen - 2) {
            var _An = $get($_.setb, $get($_.msg, $_.i)) !== void 0;
            var _As = $get($_.setb, $get($_.msg, $_.i + 1)) !== void 0;
            $k[$j++] = _An && _As;
            $k[$j++] = $_.i + 2;
            $_.numsscr();
            var _Au = $k[--$j];
            $k[$j - 1] = _Au;
            var _Aw = $k[--$j];
            var _Ax = $k[--$j];
            if (_Ax && (_Aw >= 2 && _Aw % 2 == 0)) {
              $k[$j++] = $_.sb2;
              $_.encc();
              $k[$j++] = $get($_.msg, $_.i);
              $_.encb();
              $k[$j++] = $get($_.msg, $_.i + 1);
              $_.encb();
              $_.i = $_.i + 2;
              break;
            }
          }
          if ($_.i < $_.msglen - 3) {
            var _BC = $get($_.setb, $get($_.msg, $_.i)) !== void 0;
            var _BH = $get($_.setb, $get($_.msg, $_.i + 1)) !== void 0;
            $k[$j++] = _BC && _BH;
            $k[$j++] = $_.i + 2;
            $_.numsscr();
            var _BJ = $k[--$j];
            $k[$j - 1] = _BJ;
            var _BL = $k[--$j];
            var _BM = $k[--$j];
            if (_BM && (_BL >= 3 && _BL % 2 == 1)) {
              $k[$j++] = $_.sb3;
              $_.encc();
              $k[$j++] = $get($_.msg, $_.i);
              $_.encb();
              $k[$j++] = $get($_.msg, $_.i + 1);
              $_.encb();
              $k[$j++] = $get($_.msg, $_.i + 2);
              $_.encb();
              $_.i = $_.i + 3;
              break;
            }
          }
          if ($_.i < $_.msglen - 3) {
            var _Be = $get($_.setb, $get($_.msg, $_.i)) !== void 0;
            var _Bj = $get($_.setb, $get($_.msg, $_.i + 1)) !== void 0;
            var _Bo = $get($_.setb, $get($_.msg, $_.i + 2)) !== void 0;
            $k[$j++] = _Be && _Bj && _Bo;
            $k[$j++] = $_.i + 3;
            $_.numsscr();
            var _Bq = $k[--$j];
            $k[$j - 1] = _Bq;
            var _Bs = $k[--$j];
            var _Bt = $k[--$j];
            if (_Bt && (_Bs >= 2 && _Bs % 2 == 0)) {
              $k[$j++] = $_.sb3;
              $_.encc();
              $k[$j++] = $get($_.msg, $_.i);
              $_.encb();
              $k[$j++] = $get($_.msg, $_.i + 1);
              $_.encb();
              $k[$j++] = $get($_.msg, $_.i + 2);
              $_.encb();
              $_.i = $_.i + 3;
              break;
            }
          }
          $k[$j++] = $_.i;
          $_.abeforeb();
          if ($k[--$j]) {
            $k[$j++] = $_.swa;
            $_.encc();
            $_.cset = "seta";
            break;
          }
          $k[$j++] = $_.swb;
          $_.encc();
          $_.cset = "setb";
          break;
        }
        break;
      }
    }
    $_.cws = $geti($_.cws, 0, $_.j);
  }
  $_.metrics = $a([$a([2, 7]), $a([3, 12]), $a([4, 17]), $a([5, 22]), $a([6, 27]), $a([7, 32]), $a([8, 37]), $a([9, 42]), $a([10, 47]), $a([11, 52]), $a([12, 57]), $a([13, 62]), $a([14, 67]), $a([15, 72]), $a([16, 77])]);
  $_.urows = $_.rows;
  var _CU = $_.metrics;
  for (var _CV = 0, _CW = _CU.length; _CV < _CW; _CV++) {
    $_.m = $get(_CU, _CV);
    $_.r = $get($_.m, 0);
    $_.dcws = $get($_.m, 1);
    $_.okay = true;
    if ($_.urows != 0 && $_.urows != $_.r) {
      $_.okay = false;
    }
    if ($_.cws.length > $_.dcws) {
      $_.okay = false;
    }
    if ($_.okay) {
      break;
    }
  }
  if (!$_.okay) {
    $k[$j++] = "bwipp.code16kNoValidSymbol#15731";
    $k[$j++] = "Maximum length exceeded or data too large for given options";
    bwipp_raiseerror();
  }
  $k[$j++] = Infinity;
  $aload($_.cws);
  for (var _Cm = 0, _Cn = $f($_.dcws - $_.cws.length); _Cm < _Cn; _Cm++) {
    $k[$j++] = 103;
  }
  $_.cws = $a();
  $k[$j++] = Infinity;
  $k[$j++] = $f(($_.r - 2) * 7 + $_.mode);
  $aload($_.cws);
  $_.cws = $a();
  $k[$j++] = 0;
  for (var _Cv = 0, _Cu = $_.dcws; _Cv <= _Cu; _Cv += 1) {
    var _Cy = $k[--$j];
    $k[$j++] = $f(_Cy + (_Cv + 2) * $get($_.cws, _Cv));
  }
  $_.c1 = $k[--$j] % 107;
  $k[$j++] = 0;
  for (var _D2 = 0, _D1 = $_.dcws; _D2 <= _D1; _D2 += 1) {
    var _D5 = $k[--$j];
    $k[$j++] = $f(_D5 + (_D2 + 1) * $get($_.cws, _D2));
  }
  $_.c2 = $f($k[--$j] + $_.c1 * ($_.dcws + 2)) % 107;
  $k[$j++] = Infinity;
  $aload($_.cws);
  $k[$j++] = $_.c1;
  $k[$j++] = $_.c2;
  $_.cws = $a();
  var _DE = $get($_.options, "debugcws") !== void 0;
  if (_DE) {
    $k[$j++] = "bwipp.debugcws#15747";
    $k[$j++] = $_.cws;
    bwipp_raiseerror();
  }
  $_.encs = $a(["212222", "222122", "222221", "121223", "121322", "131222", "122213", "122312", "132212", "221213", "221312", "231212", "112232", "122132", "122231", "113222", "123122", "123221", "223211", "221132", "221231", "213212", "223112", "312131", "311222", "321122", "321221", "312212", "322112", "322211", "212123", "212321", "232121", "111323", "131123", "131321", "112313", "132113", "132311", "211313", "231113", "231311", "112133", "112331", "132131", "113123", "113321", "133121", "313121", "211331", "231131", "213113", "213311", "213131", "311123", "311321", "331121", "312113", "312311", "332111", "314111", "221411", "431111", "111224", "111422", "121124", "121421", "141122", "141221", "112214", "112412", "122114", "122411", "142112", "142211", "241211", "221114", "413111", "241112", "134111", "111242", "121142", "121241", "114212", "124112", "124211", "411212", "421112", "421211", "212141", "214121", "412121", "111143", "111341", "131141", "114113", "114311", "411113", "411311", "113141", "114131", "311141", "411131", "211412", "211214", "211232", "211133"]);
  $_.startencs = $a(["3211", "2221", "2122", "1411", "1132", "1231", "1114", "3112", "3211", "2221", "2122", "1411", "1132", "1231", "1114", "3112"]);
  $_.stopencsodd = $a(["3211", "2221", "2122", "1411", "1132", "1231", "1114", "3112", "1132", "1231", "1114", "3112", "3211", "2221", "2122", "1411"]);
  $_.stopencseven = $a(["2122", "1411", "1132", "1231", "1114", "3112", "1132", "1231", "1114", "3112", "3211", "2221", "2122", "1411", "3211", "2221"]);
  if ($_.sam == -1 || ~~($_.sam / 10) % 2 == 1) {
    $_.stopencs = $_.stopencsodd;
  } else {
    $_.stopencs = $_.stopencseven;
  }
  $_.rowbits = $a($_.r);
  for (var _DT = 0, _DS = $_.r - 1; _DT <= _DS; _DT += 1) {
    $_.i = _DT;
    $k[$j++] = Infinity;
    $k[$j++] = 10;
    $forall($get($_.startencs, $_.i), function() {
      var _DX = $k[--$j];
      $k[$j++] = _DX - 48;
    });
    var _Da = $geti($_.cws, $_.i * 5, 5);
    $k[$j++] = 1;
    for (var _Db = 0, _Dc = _Da.length; _Db < _Dc; _Db++) {
      $forall($get($_.encs, $get(_Da, _Db)), function() {
        var _Dg = $k[--$j];
        $k[$j++] = _Dg - 48;
      });
    }
    $forall($get($_.stopencs, $_.i), function() {
      var _Dk = $k[--$j];
      $k[$j++] = _Dk - 48;
    });
    $k[$j++] = 1;
    $_.sbs = $a();
    $k[$j++] = Infinity;
    var _Dm = $_.sbs;
    $k[$j++] = 1;
    for (var _Dn = 0, _Do = _Dm.length; _Dn < _Do; _Dn++) {
      var _Dq = $k[$j - 1];
      var _Dr = _Dq == 0 ? 1 : 0;
      for (var _Ds = 0, _Dt = $get(_Dm, _Dn); _Ds < _Dt; _Ds++) {
        $k[$j++] = _Dr;
      }
    }
    $astore($a($counttomark() - 1));
    var _Dw = $k[--$j];
    $k[$j - 1] = _Dw;
    var _Dy = $k[--$j];
    $k[$j - 1] = _Dy;
    $k[$j++] = $_.rowbits;
    $k[$j++] = $_.i;
    var _E2 = $k[$j - 3];
    var _E3 = $k[$j - 1];
    $put($k[$j - 2], _E3, _E2);
    $j -= 3;
  }
  $k[$j++] = Infinity;
  for (var _E6 = 0, _E7 = 81 * $_.sepheight; _E6 < _E7; _E6++) {
    $k[$j++] = 1;
  }
  for (var _EA = 0, _E9 = $_.r - 2; _EA <= _E9; _EA += 1) {
    $_.i = _EA;
    for (var _EC = 0, _ED = $_.rowheight; _EC < _ED; _EC++) {
      $aload($get($_.rowbits, $_.i));
    }
    for (var _EI = 0, _EJ = $_.sepheight; _EI < _EJ; _EI++) {
      for (var _EK = 0; _EK < 10; _EK++) {
        $k[$j++] = 0;
      }
      for (var _EL = 0; _EL < 70; _EL++) {
        $k[$j++] = 1;
      }
      $k[$j++] = 0;
    }
  }
  for (var _EN = 0, _EO = $_.rowheight; _EN < _EO; _EN++) {
    $aload($get($_.rowbits, $_.r - 1));
  }
  for (var _ET = 0, _EU = 81 * $_.sepheight; _ET < _EU; _ET++) {
    $k[$j++] = 1;
  }
  $_.pixs = $a();
  var _Ea = /* @__PURE__ */ new Map([
    ["ren", "renmatrix"],
    ["pixs", $_.pixs],
    ["pixx", 81],
    ["pixy", ~~($_.pixs.length / 81)],
    ["height", ~~($_.pixs.length / 81) / 72],
    ["width", 81 / 72],
    ["opt", $_.options]
  ]);
  $k[$j++] = _Ea;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_code49() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.sam = -1;
  $_.append = false;
  $_.rows = 0;
  $_.rowheight = 8;
  $_.sepheight = 1;
  $_.parse = false;
  $_.parsefnc = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.rows != 0 && ($_.rows < 2 || $_.rows > 8)) {
    $k[$j++] = "bwipp.code49badRows#15885";
    $k[$j++] = "Code 49 must have 2 to 8 rows";
    bwipp_raiseerror();
  }
  if ($_.rowheight < 8) {
    $k[$j++] = "bwipp.code49badRowHeight#15889";
    $k[$j++] = "Code 49 must have rowheight of at least 8";
    bwipp_raiseerror();
  }
  if ($_.sepheight < 1) {
    $k[$j++] = "bwipp.code49badSepHeight#15893";
    $k[$j++] = "Code 49 must have sepheight of at least 1";
    bwipp_raiseerror();
  }
  if ($_.append && $_.sam != -1) {
    $k[$j++] = "bwipp.code49samAndAppend#15897";
    $k[$j++] = "sam and append cannot be specified together";
    bwipp_raiseerror();
  }
  if ($_.sam != -1) {
    $k[$j++] = true;
    for (var _A = 0; _A < 1; _A++) {
      var _B = $_.sam;
      if (_B < 12 || _B > 99) {
        $k[$j - 1] = false;
        break;
      }
      if ($_.sam % 10 < 2) {
        $k[$j - 1] = false;
        break;
      }
      if (~~($_.sam / 10) > $_.sam % 10) {
        $k[$j - 1] = false;
        break;
      }
    }
    if (!$k[--$j]) {
      $k[$j++] = "bwipp.code49badSAM#15908";
      $k[$j++] = 'SAM must be formatted as "NM" for Nth of M symbols, from 2 to 9 symbols';
      bwipp_raiseerror();
    }
  }
  $_.s1 = -1;
  $_.s2 = -2;
  $_.fn1 = -3;
  $_.fn2 = -4;
  $_.fn3 = -5;
  $_.ns = -6;
  var _M = /* @__PURE__ */ new Map([
    ["parse", $_.parse],
    ["parsefnc", $_.parsefnc],
    ["FNC1", $_.fn1],
    ["FNC2", $_.fn2],
    ["FNC3", $_.fn3]
  ]);
  $_.fncvals = _M;
  $k[$j++] = "msg";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.fncvals;
  bwipp_parseinput();
  var _P = $k[--$j];
  $_[$k[--$j]] = _P;
  $_.msglen = $_.msg.length;
  $forall($_.msg, function() {
    if ($k[--$j] > 127) {
      $k[$j++] = "bwipp.code49badCharacter#15931";
      $k[$j++] = "Code 49 can only support ASCII characters with values 0 to 127";
      bwipp_raiseerror();
    }
  });
  $_.charmap = $a(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "-", ".", " ", "$", "/", "+", "%", $_.s1, $_.s2, $_.fn1, $_.fn2, $_.fn3, $_.ns]);
  $_.charvals = /* @__PURE__ */ new Map();
  for (var _b = 0; _b <= 48; _b += 1) {
    $_.i = _b;
    var _e = $get($_.charmap, $_.i);
    $k[$j++] = _e;
    if ($eq($type(_e), "stringtype")) {
      var _h = $get($k[--$j], 0);
      $k[$j++] = _h;
    }
    $put($_.charvals, $k[--$j], $_.i);
  }
  $_.combos = $a(["1 ", "1A", "1B", "1C", "1D", "1E", "1F", "1G", "1H", "1I", "1J", "1K", "1L", "1M", "1N", "1O", "1P", "1Q", "1R", "1S", "1T", "1U", "1V", "1W", "1X", "1Y", "1Z", "11", "12", "13", "14", "15", "  ", "16", "17", "18", " $", " %", "19", "10", "1-", "1.", "1$", " +", "1/", " -", " .", " /", " 0", " 1", " 2", " 3", " 4", " 5", " 6", " 7", " 8", " 9", "1+", "21", "22", "23", "24", "25", "26", " A", " B", " C", " D", " E", " F", " G", " H", " I", " J", " K", " L", " M", " N", " O", " P", " Q", " R", " S", " T", " U", " V", " W", " X", " Y", " Z", "27", "28", "29", "20", "2-", "2.", "2A", "2B", "2C", "2D", "2E", "2F", "2G", "2H", "2I", "2J", "2K", "2L", "2M", "2N", "2O", "2P", "2Q", "2R", "2S", "2T", "2U", "2V", "2W", "2X", "2Y", "2Z", "2$", "2/", "2+", "2%", "2 "]);
  for (var _m = 0; _m <= 127; _m += 1) {
    $_.i = _m;
    var _p = $get($_.combos, $_.i);
    $_.c1 = $get(_p, 0);
    $_.c2 = $get(_p, 1);
    if ($_.c1 == 49) {
      $put($_.charvals, $_.i, $a([$get($_.charvals, $_.s1), $get($_.charvals, $_.c2)]));
    }
    if ($_.c1 == 50) {
      $put($_.charvals, $_.i, $a([$get($_.charvals, $_.s2), $get($_.charvals, $_.c2)]));
    }
  }
  $_.encodealpha = function() {
    var _1F = $get($_.charvals, $k[--$j]);
    $k[$j++] = _1F;
    if ($ne($type(_1F), "arraytype")) {
      $astore($a(1));
    }
    var _1I = $k[--$j];
    $puti($_.cws, $_.j, _1I);
    $_.j = _1I.length + $_.j;
  };
  $_.base48 = function() {
    var _1M = $k[--$j];
    $k[$j++] = 0;
    $forall(_1M, function() {
      var _1N = $k[--$j];
      var _1O = $k[--$j];
      $k[$j++] = $f(_1N - 48 + _1O * 10);
    });
    $k[$j++] = Infinity;
    var _1P = $k[$j - 2];
    var _1Q = $k[$j - 3];
    $k[$j - 3] = $k[$j - 1];
    $j -= 2;
    $k[$j++] = _1P;
    for (var _1R = 0, _1S = _1Q - 1; _1R < _1S; _1R++) {
      var _1T = $k[--$j];
      $k[$j++] = _1T % 48;
      $k[$j++] = ~~(_1T / 48);
    }
    var _1U = $a();
    var _1V = Infinity;
    var _1W = _1U;
    $k[$j++] = _1V;
    $k[$j++] = _1W;
    for (var _1X = _1W.length - 1; _1X >= 0; _1X -= 1) {
      var _1Y = $k[--$j];
      $k[$j++] = $get(_1Y, _1X);
      $k[$j++] = _1Y;
    }
    $j--;
    var _1a = $a();
    $puti($_.cws, $_.j, _1a);
    $_.j = _1a.length + $_.j;
  };
  $_.encodenumeric = function() {
    $_.nums = $k[--$j];
    var _1g = $_.nums.length;
    var _1h = _1g % 5;
    $k[$j++] = "pre";
    $k[$j++] = _1g;
    $k[$j++] = _1h;
    if (_1h != 2) {
      var _1i = $k[--$j];
      var _1j = $k[--$j];
      $k[$j++] = $f(_1j - _1i);
    } else {
      var _1k = $k[--$j];
      var _1l = $k[--$j];
      $k[$j++] = $f(_1l - _1k) - 5;
    }
    var _1m = $k[--$j];
    $_[$k[--$j]] = _1m;
    for (var _1q = 0, _1p = $_.pre - 1; _1q <= _1p; _1q += 5) {
      $k[$j++] = 3;
      $k[$j++] = $geti($_.nums, _1q, 5);
      $_.base48();
    }
    $_.nums = $geti($_.nums, $_.pre, $f($_.nums.length - $_.pre));
    var _1z = $_.nums.length;
    $k[$j++] = _1z;
    if (_1z == 1) {
      $k[$j++] = $get($_.nums, $_.i);
      $_.encodealpha();
    }
    var _23 = $k[$j - 1];
    if (_23 == 3) {
      $k[$j++] = 2;
      $k[$j++] = $_.nums;
      $_.base48();
    }
    var _25 = $k[$j - 1];
    if (_25 == 4) {
      $k[$j++] = 3;
      $k[$j++] = Infinity;
      $k[$j++] = 49;
      $k[$j++] = 48;
      $aload($_.nums);
      var _27 = $a();
      $k[$j++] = _27;
      $_.base48();
    }
    if ($k[--$j] == 7) {
      $k[$j++] = 3;
      $k[$j++] = Infinity;
      $k[$j++] = 49;
      $k[$j++] = 48;
      $aload($geti($_.nums, 0, 4));
      var _2B = $a();
      $k[$j++] = _2B;
      $_.base48();
      $k[$j++] = 2;
      $k[$j++] = $geti($_.nums, 4, 3);
      $_.base48();
    }
  };
  $k[$j++] = Infinity;
  for (var _2F = 0, _2G = $_.msglen; _2F < _2G; _2F++) {
    $k[$j++] = 0;
  }
  $k[$j++] = 0;
  $_.numericruns = $a();
  for (var _2J = $_.msglen - 1; _2J >= 0; _2J -= 1) {
    $_.i = _2J;
    var _2M = $get($_.msg, $_.i);
    if (_2M >= 48 && _2M <= 57) {
      $put($_.numericruns, $_.i, $get($_.numericruns, $_.i + 1) + 1);
    } else {
      $put($_.numericruns, $_.i, 0);
    }
  }
  $_.cws = $a($_.msglen * 2 + 1);
  $_.samval = $a([12, 22, 13, 23, 33, 14, 24, 34, 44, 15, 25, 35, 45, 55, 16, 26, 36, 46, 56, 66, 17, 27, 37, 47, 57, 67, 77, 18, 28, 38, 48, 58, 68, 78, 88, 19, 29, 39, 49, 59, 69, 79, 89, 99]);
  for (; ; ) {
    if ($_.append) {
      $_.mode = 1;
      $_.method = "alpha";
      $_.i = 0;
      $_.j = 0;
      break;
    }
    if ($_.sam != -1) {
      $_.mode = 3;
      $k[$j++] = $_.cws;
      $k[$j++] = 0;
      for (var _2b = 0; _2b <= 43; _2b += 1) {
        $k[$j++] = _2b;
        if ($get($_.samval, _2b) != $_.sam) {
          $j--;
        }
      }
      var _2f = $k[--$j];
      var _2g = $k[--$j];
      $put($k[--$j], _2g, _2f + 1);
      $_.method = "alpha";
      $_.i = 0;
      $_.j = 1;
      break;
    }
    if ($get($_.numericruns, 0) >= 5) {
      $_.mode = 2;
      $_.method = "numeric";
      $_.i = 0;
      $_.j = 0;
      break;
    }
    var _2n = $get($_.charvals, $get($_.msg, 0));
    $k[$j++] = _2n;
    if ($ne($type(_2n), "arraytype")) {
      $j--;
      $_.mode = 0;
      $_.method = "alpha";
      $_.i = 0;
      $_.j = 0;
      break;
    }
    var _2r = $get($k[--$j], 0) == 43 ? 4 : 5;
    $_.mode = _2r;
    $put($_.cws, 0, $get($get($_.charvals, $get($_.msg, 0)), 1));
    $_.method = "alpha";
    $_.i = 1;
    $_.j = 1;
    break;
  }
  for (; ; ) {
    if ($_.i == $_.msglen) {
      break;
    }
    for (; ; ) {
      if ($eq($_.method, "alpha")) {
        if ($get($_.numericruns, $_.i) >= 5) {
          $k[$j++] = $_.ns;
          $_.encodealpha();
          $_.method = "numeric";
          break;
        }
        $k[$j++] = $get($_.msg, $_.i);
        $_.encodealpha();
        $_.i = $_.i + 1;
        break;
      }
      if ($eq($_.method, "numeric")) {
        if ($get($_.numericruns, $_.i) < 5) {
          $k[$j++] = $_.ns;
          $_.encodealpha();
          $_.method = "alpha";
          break;
        }
        $k[$j++] = $geti($_.msg, $_.i, $get($_.numericruns, $_.i));
        $_.encodenumeric();
        $_.i = $f($_.i + $get($_.numericruns, $_.i));
        break;
      }
    }
  }
  $_.cws = $geti($_.cws, 0, $_.j);
  $_.metrics = $a([$a([2, 9]), $a([3, 16]), $a([4, 23]), $a([5, 30]), $a([6, 37]), $a([7, 42]), $a([8, 49])]);
  $_.urows = $_.rows;
  var _3b = $_.metrics;
  for (var _3c = 0, _3d = _3b.length; _3c < _3d; _3c++) {
    $_.m = $get(_3b, _3c);
    $_.r = $get($_.m, 0);
    $_.dcws = $get($_.m, 1);
    $_.okay = true;
    if ($_.urows != 0 && $_.urows != $_.r) {
      $_.okay = false;
    }
    if ($_.cws.length > $_.dcws) {
      $_.okay = false;
    }
    if ($_.okay) {
      break;
    }
  }
  if (!$_.okay) {
    $k[$j++] = "bwipp.code49noValidSymbol#16125";
    $k[$j++] = "Maximum length exceeded";
    bwipp_raiseerror();
  }
  $k[$j++] = Infinity;
  $aload($_.cws);
  for (var _3t = 0, _3u = $f($_.dcws - $_.cws.length); _3t < _3u; _3t++) {
    $k[$j++] = 48;
  }
  $_.cws = $a();
  $_.ccs = $a($_.r * 8);
  $_.j = 0;
  for (var _40 = 0, _3z = $_.r - 2; _40 <= _3z; _40 += 1) {
    $_.i = _40;
    $_.cc = $geti($_.cws, $_.j, 7);
    $puti($_.ccs, $_.i * 8, $_.cc);
    var _49 = $_.cc;
    $k[$j++] = $_.ccs;
    $k[$j++] = $_.i * 8 + 7;
    $k[$j++] = 0;
    for (var _4A = 0, _4B = _49.length; _4A < _4B; _4A++) {
      var _4D = $k[--$j];
      $k[$j++] = $f(_4D + $get(_49, _4A));
    }
    var _4E = $k[--$j];
    var _4F = $k[--$j];
    $put($k[--$j], _4F, _4E % 49);
    $_.j = $_.j + 7;
  }
  if ($_.j < $_.dcws) {
    $puti($_.ccs, $_.ccs.length - 8, $geti($_.cws, $_.j, $f($_.dcws - $_.j)));
  }
  $_.cr7 = $f(($_.r - 2) * 7 + $_.mode);
  $put($_.ccs, $_.ccs.length - 2, $_.cr7);
  var _4W = $a([1, 9, 31, 26, 2, 12, 17, 23, 37, 18, 22, 6, 27, 44, 15, 43, 39, 11, 13, 5, 41, 33, 36, 8, 4, 32, 3, 19, 40, 25, 29, 10, 24, 30]);
  $k[$j++] = _4W;
  $k[$j++] = _4W;
  $k[$j++] = Infinity;
  var _4X = $k[--$j];
  var _4Z = $geti($k[--$j], 0, 32);
  $k[$j++] = _4X;
  $k[$j++] = 20;
  $aload(_4Z);
  $_.weightx = $a();
  var _4b = $k[$j - 1];
  $k[$j++] = _4b;
  $k[$j++] = Infinity;
  var _4c = $k[--$j];
  var _4e = $geti($k[--$j], 1, 32);
  $k[$j++] = _4c;
  $k[$j++] = 16;
  $aload(_4e);
  $_.weighty = $a();
  $k[$j++] = Infinity;
  var _4g = $k[--$j];
  var _4i = $geti($k[--$j], 2, 32);
  $k[$j++] = _4g;
  $k[$j++] = 38;
  $aload(_4i);
  $_.weightz = $a();
  $_.calccheck = function() {
    $_.weights = $k[--$j];
    $_.score = 0;
    for (var _4o = 0, _4n = ~~(($_.r - 1) * 8 / 2) - 1; _4o <= _4n; _4o += 1) {
      $_.i = _4o;
      $_.score = $f(($get($_.ccs, $_.i * 2) * 49 + $get($_.ccs, $_.i * 2 + 1)) * $get($_.weights, $_.i + 1) + $_.score);
    }
    $k[$j++] = $_.score;
  };
  $_.lastrow = $geti($_.ccs, $_.ccs.length - 8, 8);
  if ($_.r >= 7) {
    $k[$j++] = $_.cr7 * $get($_.weightz, 0);
    $k[$j++] = $_.weightz;
    $_.calccheck();
    var _58 = $k[--$j];
    var _5A = $f($k[--$j] + _58) % 2401;
    $k[$j++] = ~~(_5A / 49);
    $k[$j++] = _5A % 49;
    $astore($a(2));
    $k[$j++] = $_.lastrow;
    $k[$j++] = 0;
    var _5D = $k[$j - 3];
    var _5E = $k[$j - 1];
    $puti($k[$j - 2], _5E, _5D);
    $j -= 3;
  }
  $_.wr1 = $f($get($_.lastrow, 0) * 49 + $get($_.lastrow, 1));
  $k[$j++] = $_.cr7 * $get($_.weighty, 0);
  $k[$j++] = $_.weighty;
  $_.calccheck();
  var _5O = $k[--$j];
  var _5U = $f($k[--$j] + _5O + $_.wr1 * $get($_.weighty, $_.r * 4 - 3)) % 2401;
  $_.wr2 = _5U;
  $k[$j++] = ~~(_5U / 49);
  $k[$j++] = _5U % 49;
  $astore($a(2));
  $k[$j++] = $_.lastrow;
  $k[$j++] = 2;
  var _5X = $k[$j - 3];
  var _5Y = $k[$j - 1];
  $puti($k[$j - 2], _5Y, _5X);
  $j -= 3;
  $k[$j++] = $_.cr7 * $get($_.weightx, 0);
  $k[$j++] = $_.weightx;
  $_.calccheck();
  var _5e = $k[--$j];
  var _5o = $f($k[--$j] + _5e + $_.wr1 * $get($_.weightx, $_.r * 4 - 3) + $_.wr2 * $get($_.weightx, $_.r * 4 - 2)) % 2401;
  $k[$j++] = ~~(_5o / 49);
  $k[$j++] = _5o % 49;
  $astore($a(2));
  $k[$j++] = $_.lastrow;
  $k[$j++] = 4;
  var _5r = $k[$j - 3];
  var _5s = $k[$j - 1];
  $puti($k[$j - 2], _5s, _5r);
  $j -= 3;
  var _5w = $geti($_.ccs, $_.ccs.length - 8, 7);
  $k[$j++] = 0;
  for (var _5x = 0, _5y = _5w.length; _5x < _5y; _5x++) {
    var _60 = $k[--$j];
    $k[$j++] = $f(_60 + $get(_5w, _5x));
  }
  $put($_.ccs, $_.ccs.length - 1, $k[--$j] % 49);
  var _65 = $get($_.options, "debugcws") !== void 0;
  if (_65) {
    $k[$j++] = "bwipp.debugcws#16196";
    $k[$j++] = $_.ccs;
    bwipp_raiseerror();
  }
  $_.patterns = $a([$a(["11521132", "25112131", "14212132", "25121221", "14221222", "12412132", "23321221", "12421222", "21521221", "15112222", "15121312", "13312222", "24221311", "13321312", "11512222", "22421311", "11521312", "25112311", "14212312", "23312311", "12412312", "21512311", "16121131", "14321131", "12521131", "15212131", "15221221", "13412131", "13421221", "11612131", "16112221", "16121311", "14312221", "14321311", "12512221", "12521311", "15212311", "13412311", "11612311", "11131135", "31131133", "51131131", "21122134", "41122132", "21131224", "41131222", "11113135", "31113133", "51113131", "11122225", "31122223", "51122221", "11131315", "31131313", "51131311", "21113224", "41113222", "21122314", "41122312", "11113315", "31113313", "51113311", "12131134", "32131132", "21231133", "41231131", "22122133", "42122131", "11222134", "22131223", "42131221", "11231224", "31231222", "12113134", "32113132", "12122224", "32122222", "12131314", "32131312", "21231313", "41231311", "22113223", "42113221", "11213224", "22122313", "42122311", "11222314", "31222312", "12113314", "32113312", "21213313", "41213311", "13131133", "33131131", "22231132", "11331133", "31331131", "23122132", "12222133", "23131222", "12231223", "32231221", "21331222", "13113133", "33113131", "13122223", "33122221", "11313133", "13131313", "33131311", "11322223", "22231312", "11331313", "31331311", "23113222", "12213223", "23122312", "12222313", "32222311", "21322312", "13113313", "33113311", "22213312", "11313313", "31313311", "14131132", "23231131", "12331132", "21431131", "24122131", "13222132", "24131221", "13231222", "11422132", "22331221", "11431222", "14113132", "14122222", "12313132", "14131312", "12322222", "23231311", "12331312", "21431311", "24113221", "13213222", "24122311", "13222312", "11413222", "22322311", "11422312", "14113312", "23213311", "12313312", "21413311", "15131131", "13331131", "14222131", "14231221", "12422131", "12431221", "15113131", "15122221", "13313131", "15131311", "13322221", "11513131", "13331311", "11522221", "14213221", "14222311", "12413221", "12422311", "15113311", "13313311", "11513311", "11141134", "31141132", "21132133", "41132131", "21141223", "41141221", "11123134", "31123132", "11132224", "31132222", "11141314", "31141312", "21114133", "41114131", "21123223", "41123221", "21132313", "41132311", "11114224", "31114222", "11123314", "31123312", "21114313", "41114311", "12141133", "32141131", "21241132", "22132132", "11232133", "22141222", "11241223", "31241221", "12123133", "32123131", "12132223", "32132221", "12141313", "32141311", "21241312", "22114132", "11214133", "22123222", "11223223", "22132312", "11232313", "31232311", "12114223", "32114221", "12123313", "32123311", "21223312", "22114312", "11214313", "31214311", "13141132", "22241131", "11341132", "23132131", "12232132", "23141221", "12241222", "21341221", "13123132", "13132222", "11323132", "13141312", "11332222", "22241311", "11341312", "23114131", "12214132", "23123221", "12223222", "23132311", "12232312", "21332311", "13114222", "13123312", "11314222", "22223311", "11323312", "23114311", "12214312", "21314311", "14141131", "12341131", "13232131", "13241221", "11432131", "14123131", "14132221", "12323131", "14141311", "12332221", "12341311", "13214131", "13223221", "11414131", "13232311", "11423221", "11432311", "14114221", "14123311", "12314221", "12323311", "13214311", "11414311", "11151133", "31151131", "21142132", "21151222", "11133133", "31133131", "11142223", "31142221", "11151313", "31151311", "21124132", "21133222", "21142312", "11115133", "31115131", "11124223", "31124221", "11133313", "31133311", "21115222", "21124312", "12151132", "21251131", "22142131", "11242132", "22151221", "11251222", "12133132", "12142222", "12151312", "21251311", "22124131", "11224132", "22133221", "11233222", "22142311", "11242312", "12115132", "12124222", "12133312", "21233311", "22115221", "11215222", "22124311", "11224312", "13151131", "12242131", "12251221", "13133131", "13142221", "11333131", "13151311", "11342221", "12224131", "12233221", "12242311", "13115131", "13124221", "11315131", "13133311", "11324221", "11333311", "12215221", "12224311", "11161132", "21152131", "21161221", "11143132", "11152222", "11161312", "21134131", "21143221", "21152311", "11125132", "11134222", "11143312", "21116131", "21125221", "21134311", "12161131", "11252131", "12143131", "12152221", "12161311", "11234131", "11243221", "11252311", "12125131", "12134221", "12143311", "11216131", "11225221", "11234311", "11111236", "31111234", "51111232", "21111325", "41111323", "61111321", "11111416", "31111414", "51111412", "31211143", "51211141", "12111235", "32111233", "52111231", "21211234", "41211232", "22111324", "42111322", "11211325", "31211323", "51211321", "12111415", "32111413", "52111411", "21211414", "41211412", "12211144", "32211142", "21311143", "41311141", "13111234", "33111232", "22211233", "42211231", "11311234", "31311232", "23111323", "43111321", "12211324", "32211322", "21311323", "41311321", "13111414", "33111412", "22211413", "42211411", "11311414", "31311412", "13211143", "33211141", "22311142", "11411143", "31411141", "14111233", "34111231", "23211232", "12311233", "32311231", "21411232", "24111322", "13211323", "33211321", "22311322", "11411323", "31411321", "14111413", "34111411", "23211412", "12311413", "32311411", "21411412", "14211142", "23311141", "12411142", "21511141", "15111232", "24211231", "13311232", "22411231", "11511232", "25111321", "14211322", "23311321", "12411322", "21511321", "15111412", "24211411", "13311412", "22411411", "11511412", "15211141", "13411141", "11611141", "16111231", "14311231", "12511231", "15211321", "13411321", "11611321", "16111411", "14311411", "12511411", "21121144", "41121142", "11112145", "31112143", "51112141", "11121235", "31121233", "51121231", "21112234", "41112232", "21121324", "41121322", "11112325", "31112323", "51112321", "11121415", "31121413", "51121411", "21112414", "41112412", "22121143", "42121141", "11221144", "31221142", "12112144", "32112142", "12121234", "32121232", "21221233", "41221231", "22112233", "42112231", "11212234", "22121323", "42121321", "11221324", "31221322", "12112324", "32112322", "12121414", "32121412", "21221413", "41221411", "22112413", "42112411", "11212414", "31212412", "23121142", "12221143", "32221141", "21321142", "13112143", "33112141", "13121233", "33121231", "11312143", "22221232", "11321233", "31321231", "23112232", "12212233", "23121322", "12221323", "32221321", "21321322", "13112323", "33112321", "13121413", "33121411", "11312323", "22221412", "11321413", "31321411", "23112412", "12212413", "32212411", "21312412", "24121141", "13221142", "22321141", "11421142", "14112142", "14121232", "12312142", "23221231", "12321232", "21421231", "24112231", "13212232", "24121321", "13221322", "11412232", "22321321", "11421322", "14112322", "14121412", "12312322", "23221411", "12321412", "21421411", "24112411", "13212412", "22312411", "11412412", "14221141", "12421141", "15112141", "15121231", "13312141", "13321231", "11512141", "11521231", "14212231", "14221321", "12412231", "12421321", "15112321", "15121411", "13312321", "13321411", "11512321", "11521411", "14212411", "12412411", "21131143", "41131141", "11122144", "31122142", "11131234", "31131232", "21113143", "41113141", "21122233", "41122231", "21131323", "41131321", "11113234", "31113232", "11122324", "31122322", "11131414", "31131412", "21113323", "41113321", "21122413", "41122411", "11113414", "31113412", "22131142", "11231143", "31231141", "12122143", "32122141", "12131233", "32131231", "21231232", "22113142", "11213143", "22122232", "11222233", "22131322", "11231323", "31231321", "12113233", "32113231", "12122323", "32122321", "12131413", "32131411", "21231412", "22113322", "11213323", "22122412", "11222413", "31222411", "12113413", "32113411", "21213412", "23131141", "12231142", "21331141", "13122142", "13131232", "11322142", "22231231", "11331232", "23113141", "12213142", "23122231", "12222232", "23131321", "12231322", "21331321", "13113232", "13122322", "11313232", "13131412", "11322322", "22231411", "11331412", "23113321", "12213322", "23122411", "12222412", "21322411", "13113412", "22213411", "11313412", "13231141", "11431141", "14122141", "14131231", "12322141", "12331231", "13213141", "13222231", "11413141", "13231321", "11422231", "11431321", "14113231", "14122321", "12313231", "14131411", "12322321", "12331411", "13213321", "13222411", "11413321", "11422411", "14113411", "12313411", "21141142", "11132143", "31132141", "11141233", "31141231", "21123142", "21132232", "21141322", "11114143", "31114141", "11123233", "31123231", "11132323", "31132321", "11141413", "31141411", "21114232", "21123322", "21132412", "11114323", "31114321", "11123413", "31123411", "22141141", "11241142", "12132142", "12141232", "21241231", "22123141", "11223142", "22132231", "11232232", "22141321", "11241322", "12114142", "12123232", "12132322", "12141412", "21241411", "22114231", "11214232", "22123321", "11223322", "22132411", "11232412", "12114322", "12123412", "21223411", "12241141", "13132141", "13141231", "11332141", "11341231", "12223141", "12232231", "12241321", "13114141", "13123231", "11314141", "13132321", "11323231", "13141411", "11332321", "11341411", "12214231", "12223321", "12232411", "13114321", "13123411", "11314321", "11323411", "21151141", "11142142", "11151232", "21133141", "21142231", "21151321", "11124142", "11133232", "11142322", "11151412", "21115141", "21124231", "21133321", "21142411", "11115232", "11124322", "11133412", "11251141", "12142141", "12151231", "11233141", "11242231", "11251321", "12124141", "12133231", "12142321", "12151411", "11215141", "11224231", "11233321", "11242411", "12115231", "12124321", "12133411", "11152141", "11161231", "11134141", "11143231", "11152321", "11161411", "11116141", "11125231", "11134321", "11143411", "21111244", "41111242", "11111335", "31111333", "51111331", "21111424", "41111422", "11111515", "31111513", "51111511", "21211153", "41211151", "22111243", "42111241", "11211244", "31211242", "12111334", "32111332", "21211333", "41211331", "22111423", "42111421", "11211424", "31211422", "12111514", "32111512", "21211513", "41211511", "22211152", "11311153", "31311151", "23111242", "12211243", "32211241", "21311242", "13111333", "33111331", "22211332", "11311333", "31311331", "23111422", "12211423", "32211421", "21311422", "13111513", "33111511", "22211512", "11311513", "31311511", "23211151", "12311152", "21411151", "24111241", "13211242", "22311241", "11411242", "14111332", "23211331", "12311332", "21411331", "24111421", "13211422", "22311421", "11411422", "14111512", "23211511", "12311512", "21411511", "13311151", "11511151", "14211241", "12411241", "15111331", "13311331", "11511331", "14211421", "12411421", "15111511", "13311511", "11511511", "31121152", "21112153", "41112151", "21121243", "41121241", "11112244", "31112242", "11121334", "31121332", "21112333", "41112331", "21121423", "41121421", "11112424", "31112422", "11121514", "31121512", "21112513", "41112511", "12121153", "32121151", "21221152", "22112152", "11212153", "22121242", "11221243", "31221241", "12112243", "32112241", "12121333", "32121331", "21221332", "22112332", "11212333", "22121422", "11221423", "31221421", "12112423", "32112421", "12121513", "32121511", "21221512", "22112512", "11212513", "31212511", "13121152", "22221151", "11321152", "23112151", "12212152", "23121241", "12221242", "21321241", "13112242", "13121332", "11312242", "22221331", "11321332", "23112331", "12212332", "23121421", "12221422", "21321421", "13112422", "13121512", "11312422", "22221511", "11321512", "23112511", "12212512", "21312511", "14121151", "12321151", "13212151", "13221241", "11412151", "11421241", "14112241", "14121331", "12312241", "12321331", "13212331", "13221421", "11412331", "11421421", "14112421", "14121511", "12312421", "12321511", "13212511", "11412511", "11131153", "31131151", "21122152", "21131242", "11113153", "31113151", "11122243", "31122241", "11131333", "31131331", "21113242", "21122332", "21131422", "11113333", "31113331", "11122423", "31122421", "11131513", "31131511", "21113422", "21122512", "12131152", "21231151", "22122151", "11222152", "22131241", "11231242", "12113152", "12122242", "12131332", "21231331", "22113241", "11213242", "22122331", "11222332", "22131421", "11231422", "12113332", "12122422", "12131512", "21231511", "22113421", "11213422", "22122511", "11222512", "13131151", "11331151", "12222151", "12231241", "13113151", "13122241", "11313151", "13131331", "11322241", "11331331", "12213241", "12222331", "12231421", "13113331", "13122421", "11313331", "13131511", "11322421", "11331511", "12213421", "12222511", "11141152", "21132151", "21141241", "11123152", "11132242", "11141332", "21114151", "21123241", "21132331", "21141421", "11114242", "11123332", "11132422", "11141512", "21114331", "21123421", "21132511", "12141151", "11232151", "11241241", "12123151", "12132241", "12141331", "11214151", "11223241", "11232331", "11241421", "12114241", "12123331", "12132421", "12141511", "11214331", "11223421", "11232511", "11151151", "11133151", "11142241", "11151331", "11115151", "11124241", "11133331", "11142421", "11151511", "11111254", "31111252", "21111343", "41111341", "11111434", "31111432", "21111523", "41111521", "11111614", "31111612", "31211161", "12111253", "32111251", "21211252", "22111342", "11211343", "31211341", "12111433", "32111431", "21211432", "22111522", "11211523", "31211521", "12111613", "32111611", "21211612", "12211162", "21311161", "13111252", "22211251", "11311252", "23111341", "12211342", "21311341", "13111432", "22211431", "11311432", "23111521", "12211522", "21311521", "13111612", "22211611", "11311612", "13211161", "11411161", "14111251", "12311251", "13211341", "11411341", "14111431", "12311431", "13211521", "11411521", "14111611", "12311611", "21121162", "11112163", "31112161", "11121253", "31121251", "21112252", "21121342", "11112343", "31112341", "11121433", "31121431", "21112432", "21121522", "11112523", "31112521", "11121613", "31121611", "22121161", "11221162", "12112162", "12121252", "21221251", "22112251", "11212252", "22121341", "11221342", "12112342", "12121432", "21221431", "22112431", "11212432", "22121521", "11221522", "12112522", "12121612", "21221611", "12221161", "13112161", "13121251", "11312161", "11321251", "32121115", "52121113", "21221116", "41221114", "61221112", "22112116", "42112114", "31212115", "51212113", "13121116", "33121114", "22221115", "42221113", "11321116", "31321114", "51321112", "23112115", "43112113", "12212116", "32212114", "52212112", "21312115", "41312113", "61312111", "14121115", "34121113", "23221114", "43221112", "12321115", "32321113", "52321111", "21421114", "41421112", "24112114", "13212115", "33212113", "22312114", "42312112", "11412115", "31412113", "51412111", "15121114", "24221113", "13321114", "33321112", "22421113", "42421111", "11521114", "31521112", "25112113", "14212114", "34212112", "23312113", "43312111", "12412114", "32412112", "21512113", "41512111", "16121113", "25221112", "14321113", "34321111", "23421112", "12521113", "32521111", "15212113", "24312112", "13412113", "33412111", "22512112", "11612113", "31612111", "31131115", "51131113", "21122116", "41122114", "61122112", "31113115", "51113113", "12131116", "32131114", "52131112", "21231115", "41231113", "61231111", "22122115", "42122113", "11222116", "31222114", "51222112", "12113116", "32113114", "52113112", "21213115", "41213113", "61213111", "13131115", "33131113", "22231114", "42231112", "11331115", "31331113", "51331111", "23122114", "43122112", "12222115", "32222113", "52222111", "21322114", "41322112", "13113115", "33113113", "22213114", "42213112", "11313115", "31313113", "51313111", "14131114", "34131112", "23231113", "43231111", "12331114", "32331112", "21431113", "41431111", "24122113", "13222114", "33222112", "22322113", "42322111", "11422114", "31422112", "14113114", "34113112", "23213113", "43213111", "12313114", "32313112", "21413113", "41413111", "15131113", "24231112", "13331113", "33331111", "22431112", "25122112", "14222113", "34222111", "23322112", "12422113", "32422111", "21522112", "15113113", "24213112", "13313113", "33313111", "22413112", "11513113", "31513111", "16131112", "25231111", "14331112", "23431111", "15222112", "24322111", "13422112", "22522111", "16113112", "25213111", "14313112", "23413111", "12513112", "21613111", "11141116", "31141114", "51141112", "21132115", "41132113", "61132111", "11123116", "31123114", "51123112", "21114115", "41114113", "61114111", "12141115", "32141113", "52141111", "21241114", "41241112", "22132114", "42132112", "11232115", "31232113", "51232111", "12123115", "32123113", "52123111", "21223114", "41223112", "22114114", "42114112", "11214115", "31214113", "51214111", "13141114", "33141112", "22241113", "42241111", "11341114", "31341112", "23132113", "43132111", "12232114", "32232112", "21332113", "41332111", "13123114", "33123112", "22223113", "42223111", "11323114", "31323112", "23114113", "43114111", "12214114", "32214112", "21314113", "41314111", "14141113", "34141111", "23241112", "12341113", "32341111", "24132112", "13232113", "33232111", "22332112", "11432113", "31432111", "14123113", "34123111", "23223112", "12323113", "32323111", "21423112", "24114112", "13214113", "33214111", "22314112", "11414113", "31414111", "15141112", "24241111", "13341112", "25132111", "14232112", "23332111", "12432112", "15123112", "24223111", "13323112", "22423111", "11523112", "25114111", "14214112", "23314111", "12414112", "21514111", "16141111", "14341111", "15232111", "13432111", "16123111", "14323111", "12523111", "15214111", "13414111", "11614111", "11151115", "31151113", "51151111", "21142114", "41142112", "11133115", "31133113", "51133111", "21124114", "41124112", "11115115", "31115113", "51115111", "12151114", "32151112", "21251113", "41251111", "22142113", "42142111", "11242114", "31242112", "12133114", "32133112", "21233113", "41233111", "22124113", "42124111", "11224114", "31224112", "12115114", "32115112", "21215113", "41215111", "13151113", "33151111", "22251112", "23142112", "12242113", "32242111", "21342112", "13133113", "33133111", "22233112", "11333113", "31333111", "23124112", "12224113", "32224111", "21324112", "13115113", "33115111", "22215112", "11315113", "31315111", "14151112", "23251111", "24142111", "13242112", "22342111", "14133112", "23233111", "12333112", "21433111", "24124111", "13224112", "22324111", "11424112", "14115112", "23215111", "12315112", "21415111", "15151111", "14242111", "15133111", "13333111", "14224111", "12424111", "15115111", "13315111", "11515111", "11161114", "31161112", "21152113", "41152111", "11143114", "31143112", "21134113", "41134111", "11125114", "31125112", "21116113", "41116111", "12161113", "32161111", "22152112", "11252113", "31252111", "12143113", "32143111", "21243112", "22134112", "11234113", "31234111", "12125113", "32125111", "21225112", "22116112", "11216113", "31216111", "13161112", "23152111", "12252112", "13143112", "22243111", "11343112", "23134111", "12234112", "21334111", "13125112", "22225111", "11325112", "23116111", "12216112", "21316111", "14161111", "13252111", "14143111", "12343111", "13234111", "11434111", "14125111", "12325111", "13216111", "11416111", "31111216", "51111214", "31211125", "51211123", "32111215", "52111213", "21211216", "41211214", "61211212", "12211126", "32211124", "52211122", "21311125", "41311123", "61311121", "13111216", "33111214", "22211215", "42211213", "11311216", "31311214", "51311212", "13211125", "33211123", "22311124", "42311122", "11411125", "31411123", "51411121", "14111215", "34111213", "23211214", "43211212", "12311215", "32311213", "52311211", "21411214", "41411212", "14211124", "34211122", "23311123", "43311121", "12411124", "32411122", "21511123", "41511121", "15111214", "24211213", "13311214", "33311212", "22411213", "42411211", "11511214", "31511212", "15211123", "24311122", "13411123", "33411121", "22511122", "11611123", "31611121", "16111213", "25211212", "14311213", "34311211", "23411212", "12511213", "32511211", "21611212", "21121126", "41121124", "61121122", "31112125", "51112123", "31121215", "51121213", "21112216", "41112214", "61112212", "22121125", "42121123", "11221126", "31221124", "51221122", "12112126", "32112124", "52112122", "12121216", "32121214", "52121212", "21221215", "41221213", "61221211", "22112215", "42112213", "11212216", "31212214", "51212212", "23121124", "43121122", "12221125", "32221123", "52221121", "21321124", "41321122", "13112125", "33112123", "13121215", "33121213", "11312125", "22221214", "42221212", "11321215", "31321213", "51321211", "23112214", "43112212", "12212215", "32212213", "52212211", "21312214", "41312212", "24121123", "13221124", "33221122", "22321123", "42321121", "11421124", "31421122", "14112124", "34112122", "14121214", "34121212", "12312124", "23221213", "43221211", "12321214", "32321212", "21421213", "41421211", "24112213", "13212214", "33212212", "22312213", "42312211", "11412214", "31412212", "25121122", "14221123", "34221121", "23321122", "12421123", "32421121", "21521122", "15112123", "15121213", "13312123", "24221212", "13321213", "33321211", "11512123", "22421212", "11521213", "31521211", "25112212", "14212213", "34212211", "23312212", "12412213", "32412211", "21512212", "15221122", "24321121", "13421122", "22521121", "16112122", "16121212", "14312122", "25221211", "14321212", "12512122", "23421211", "12521212", "15212212", "24312211", "13412212", "22512211", "11612212", "21131125", "41131123", "61131121", "11122126", "31122124", "51122122", "11131216", "31131214", "51131212", "21113125", "41113123", "61113121", "21122215", "41122213", "61122211", "11113216", "31113214", "51113212", "22131124", "42131122", "11231125", "31231123", "51231121", "12122125", "32122123", "52122121", "12131215", "32131213", "52131211", "21231214", "41231212", "22113124", "42113122", "11213125", "22122214", "42122212", "11222215", "31222213", "51222211", "12113215", "32113213", "52113211", "21213214", "41213212", "23131123", "43131121", "12231124", "32231122", "21331123", "41331121", "13122124", "33122122", "13131214", "33131212", "11322124", "22231213", "42231211", "11331214", "31331212", "23113123", "43113121", "12213124", "23122213", "43122211", "12222214", "32222212", "21322213", "41322211", "13113214", "33113212", "22213213", "42213211", "11313214", "31313212", "24131122", "13231123", "33231121", "22331122", "11431123", "31431121", "14122123", "34122121", "14131213", "34131211", "12322123", "23231212", "12331213", "32331211", "21431212", "24113122", "13213123", "24122212", "13222213", "33222211", "11413123", "22322212", "11422213", "31422211", "14113213", "34113211", "23213212", "12313213", "32313211", "21413212", "25131121", "14231122", "23331121", "12431122", "15122122", "15131212", "13322122", "24231211", "13331212", "11522122", "22431211", "25113121", "14213122", "25122211", "14222212", "12413122", "23322211", "12422212", "21522211", "15113212", "24213211", "13313212", "22413211", "11513212", "15231121", "13431121", "16122121", "16131211", "14322121", "14331211", "12522121", "15213121", "15222211", "13413121", "13422211", "11613121", "16113211", "14313211", "12513211", "21141124", "41141122", "11132125", "31132123", "51132121", "11141215", "31141213", "51141211", "21123124", "41123122", "21132214", "41132212", "11114125", "31114123", "51114121", "11123215", "31123213", "51123211", "21114214", "41114212", "22141123", "42141121", "11241124", "31241122", "12132124", "32132122", "12141214", "32141212", "21241213", "41241211", "22123123", "42123121", "11223124", "22132213", "42132211", "11232214", "31232212", "12114124", "32114122", "12123214", "32123212", "21223213", "41223211", "22114213", "42114211", "11214214", "31214212", "23141122", "12241123", "32241121", "21341122", "13132123", "33132121", "13141213", "33141211", "11332123", "22241212", "11341213", "31341211", "23123122", "12223123", "23132212", "12232213", "32232211", "21332212", "13114123", "33114121", "13123213", "33123211", "11314123", "22223212", "11323213", "31323211", "23114212", "12214213", "32214211", "21314212", "24141121", "13241122", "22341121", "14132122", "14141212", "12332122", "23241211", "12341212", "24123121", "13223122", "24132211", "13232212", "11423122", "22332211", "11432212", "14114122", "14123212", "12314122", "23223211", "12323212", "21423211", "24114211", "13214212", "22314211", "11414212", "14241121", "15132121", "15141211", "13332121", "13341211", "14223121", "14232211", "12423121", "12432211", "15114121", "15123211", "13314121", "13323211", "11514121", "11523211", "14214211", "12414211", "21151123", "41151121", "11142124", "31142122", "11151214", "31151212", "21133123", "41133121", "21142213", "41142211", "11124124", "31124122", "11133214", "31133212", "21115123", "41115121", "21124213", "41124211", "11115214", "31115212", "22151122", "11251123", "31251121", "12142123", "32142121", "12151213", "32151211", "21251212", "22133122", "11233123", "22142212", "11242213", "31242211", "12124123", "32124121", "12133213", "32133211", "21233212", "22115122", "11215123", "22124212", "11224213", "31224211", "12115213", "32115211", "21215212", "23151121", "12251122", "13142122", "13151212", "11342122", "22251211", "23133121", "12233122", "23142211", "12242212", "21342211", "13124122", "13133212", "11324122", "22233211", "11333212", "23115121", "12215122", "23124211", "12224212", "21324211", "13115212", "22215211", "11315212", "13251121", "14142121", "14151211", "12342121", "13233121", "13242211", "11433121", "14124121", "14133211", "12324121", "12333211", "13215121", "13224211", "11415121", "11424211", "14115211", "12315211", "21161122", "11152123", "31152121", "11161213", "31161211", "21143122", "21152212", "11134123", "31134121", "11143213", "31143211", "21125122", "21134212", "11116123", "31116121", "11125213", "31125211", "22161121", "12152122", "12161212", "22143121", "11243122", "22152211", "11252212", "12134122", "12143212", "21243211", "22125121", "11225122", "22134211", "11234212", "12116122", "12125212", "21225211", "13152121", "13161211", "12243121", "12252211", "13134121", "13143211", "11334121", "11343211", "12225121", "12234211", "13116121", "13125211", "11316121", "11325211", "21111226", "41111224", "61111222", "31111315", "51111313", "21211135", "41211133", "61211131", "22111225", "42111223", "11211226", "31211224", "51211222", "12111316", "32111314", "52111312", "21211315", "41211313", "61211311", "22211134", "42211132", "11311135", "31311133", "51311131", "23111224", "43111222", "12211225", "32211223", "52211221", "21311224", "41311222", "13111315", "33111313", "22211314", "42211312", "11311315", "31311313", "51311311", "23211133", "43211131", "12311134", "32311132", "21411133", "41411131", "24111223", "13211224", "33211222", "22311223", "42311221", "11411224", "31411222", "14111314", "34111312", "23211313", "43211311", "12311314", "32311312", "21411313", "41411311", "24211132", "13311133", "33311131", "22411132", "11511133", "31511131", "25111222", "14211223", "34211221", "23311222", "12411223", "32411221", "21511222", "15111313", "24211312", "13311313", "33311311", "22411312", "11511313", "31511311", "25211131", "14311132", "23411131", "12511132", "21611131", "15211222", "24311221", "13411222", "22511221", "11611222", "16111312", "25211311", "14311312", "23411311", "12511312", "21611311", "31121134", "51121132", "21112135", "41112133", "61112131", "21121225", "41121223", "61121221", "11112226", "31112224", "51112222", "11121316", "31121314", "51121312", "21112315", "41112313", "61112311", "12121135", "32121133", "52121131", "21221134", "41221132", "22112134", "42112132", "11212135", "22121224", "42121222", "11221225", "31221223", "51221221", "12112225", "32112223", "52112221", "12121315", "32121313", "52121311", "21221314", "41221312", "22112314", "42112312", "11212315", "31212313", "51212311", "13121134", "33121132", "22221133", "42221131", "11321134", "31321132", "23112133", "43112131", "12212134", "23121223", "43121221", "12221224", "32221222", "21321223", "41321221", "13112224", "33112222", "13121314", "33121312", "11312224", "22221313", "42221311", "11321314", "31321312", "23112313", "43112311", "12212314", "32212312", "21312313", "41312311", "14121133", "34121131", "23221132", "12321133", "32321131", "21421132", "24112132", "13212133", "24121222", "13221223", "33221221", "11412133", "22321222", "11421223", "31421221", "14112223", "34112221", "14121313", "34121311", "12312223", "23221312", "12321313", "32321311", "21421312", "24112312", "13212313", "33212311", "22312312", "11412313", "31412311", "15121132", "24221131", "13321132", "22421131"]), $a(["22121116", "42121114", "31221115", "51221113", "32112115", "52112113", "21212116", "41212114", "61212112", "23121115", "43121113", "12221116", "32221114", "52221112", "21321115", "41321113", "61321111", "13112116", "33112114", "22212115", "42212113", "11312116", "31312114", "51312112", "24121114", "13221115", "33221113", "22321114", "42321112", "11421115", "31421113", "51421111", "14112115", "34112113", "23212114", "43212112", "12312115", "32312113", "52312111", "21412114", "41412112", "25121113", "14221114", "34221112", "23321113", "43321111", "12421114", "32421112", "21521113", "41521111", "15112114", "24212113", "13312114", "33312112", "22412113", "42412111", "11512114", "31512112", "15221113", "24321112", "13421113", "33421111", "22521112", "16112113", "25212112", "14312113", "34312111", "23412112", "12512113", "32512111", "21612112", "21131116", "41131114", "61131112", "31122115", "51122113", "21113116", "41113114", "61113112", "22131115", "42131113", "11231116", "31231114", "51231112", "12122116", "32122114", "52122112", "21222115", "41222113", "61222111", "22113115", "42113113", "11213116", "31213114", "51213112", "23131114", "43131112", "12231115", "32231113", "52231111", "21331114", "41331112", "13122115", "33122113", "22222114", "42222112", "11322115", "31322113", "51322111", "23113114", "43113112", "12213115", "32213113", "52213111", "21313114", "41313112", "24131113", "13231114", "33231112", "22331113", "42331111", "11431114", "31431112", "14122114", "34122112", "23222113", "43222111", "12322114", "32322112", "21422113", "41422111", "24113113", "13213114", "33213112", "22313113", "42313111", "11413114", "31413112", "25131112", "14231113", "34231111", "23331112", "12431113", "32431111", "15122113", "24222112", "13322113", "33322111", "22422112", "11522113", "31522111", "25113112", "14213113", "34213111", "23313112", "12413113", "32413111", "21513112", "15231112", "24331111", "13431112", "16122112", "25222111", "14322112", "23422111", "12522112", "15213112", "24313111", "13413112", "22513111", "11613112", "21141115", "41141113", "61141111", "11132116", "31132114", "51132112", "21123115", "41123113", "61123111", "11114116", "31114114", "51114112", "22141114", "42141112", "11241115", "31241113", "51241111", "12132115", "32132113", "52132111", "21232114", "41232112", "22123114", "42123112", "11223115", "31223113", "51223111", "12114115", "32114113", "52114111", "21214114", "41214112", "23141113", "43141111", "12241114", "32241112", "21341113", "41341111", "13132114", "33132112", "22232113", "42232111", "11332114", "31332112", "23123113", "43123111", "12223114", "32223112", "21323113", "41323111", "13114114", "33114112", "22214113", "42214111", "11314114", "31314112", "24141112", "13241113", "33241111", "22341112", "14132113", "34132111", "23232112", "12332113", "32332111", "21432112", "24123112", "13223113", "33223111", "22323112", "11423113", "31423111", "14114113", "34114111", "23214112", "12314113", "32314111", "21414112", "25141111", "14241112", "23341111", "15132112", "24232111", "13332112", "22432111", "25123111", "14223112", "23323111", "12423112", "21523111", "15114112", "24214111", "13314112", "22414111", "11514112", "15241111", "16132111", "14332111", "15223111", "13423111", "16114111", "14314111", "12514111", "21151114", "41151112", "11142115", "31142113", "51142111", "21133114", "41133112", "11124115", "31124113", "51124111", "21115114", "41115112", "22151113", "42151111", "11251114", "31251112", "12142114", "32142112", "21242113", "41242111", "22133113", "42133111", "11233114", "31233112", "12124114", "32124112", "21224113", "41224111", "22115113", "42115111", "11215114", "31215112", "23151112", "12251113", "32251111", "13142113", "33142111", "22242112", "11342113", "31342111", "23133112", "12233113", "32233111", "21333112", "13124113", "33124111", "22224112", "11324113", "31324111", "23115112", "12215113", "32215111", "21315112", "24151111", "13251112", "14142112", "23242111", "12342112", "24133111", "13233112", "22333111", "11433112", "14124112", "23224111", "12324112", "21424111", "24115111", "13215112", "22315111", "11415112", "14251111", "15142111", "13342111", "14233111", "12433111", "15124111", "13324111", "11524111", "14215111", "12415111", "21161113", "41161111", "11152114", "31152112", "21143113", "41143111", "11134114", "31134112", "21125113", "41125111", "11116114", "31116112", "22161112", "12152113", "32152111", "21252112", "22143112", "11243113", "31243111", "12134113", "32134111", "21234112", "22125112", "11225113", "31225111", "12116113", "32116111", "21216112", "23161111", "13152112", "22252111", "23143111", "12243112", "21343111", "13134112", "22234111", "11334112", "23125111", "12225112", "21325111", "13116112", "22216111", "11316112", "14152111", "13243111", "14134111", "12334111", "13225111", "11425111", "14116111", "12316111", "41111215", "61111213", "21211126", "41211124", "61211122", "22111216", "42111214", "31211215", "51211213", "22211125", "42211123", "11311126", "31311124", "51311122", "23111215", "43111213", "12211216", "32211214", "52211212", "21311215", "41311213", "61311211", "23211124", "43211122", "12311125", "32311123", "52311121", "21411124", "41411122", "24111214", "13211215", "33211213", "22311214", "42311212", "11411215", "31411213", "51411211", "24211123", "13311124", "33311122", "22411123", "42411121", "11511124", "31511122", "25111213", "14211214", "34211212", "23311213", "43311211", "12411214", "32411212", "21511213", "41511211", "25211122", "14311123", "34311121", "23411122", "12511123", "32511121", "21611122", "15211213", "24311212", "13411213", "33411211", "22511212", "11611213", "31611211", "31121125", "51121123", "21112126", "41112124", "61112122", "21121216", "41121214", "61121212", "31112215", "51112213", "12121126", "32121124", "52121122", "21221125", "41221123", "61221121", "22112125", "42112123", "11212126", "22121215", "42121213", "11221216", "31221214", "51221212", "12112216", "32112214", "52112212", "21212215", "41212213", "61212211", "13121125", "33121123", "22221124", "42221122", "11321125", "31321123", "51321121", "23112124", "43112122", "12212125", "23121214", "43121212", "12221215", "32221213", "52221211", "21321214", "41321212", "13112215", "33112213", "22212214", "42212212", "11312215", "31312213", "51312211", "14121124", "34121122", "23221123", "43221121", "12321124", "32321122", "21421123", "41421121", "24112123", "13212124", "24121213", "13221214", "33221212", "11412124", "22321213", "42321211", "11421214", "31421212", "14112214", "34112212", "23212213", "43212211", "12312214", "32312212", "21412213", "41412211", "15121123", "24221122", "13321123", "33321121", "22421122", "11521123", "31521121", "25112122", "14212123", "25121212", "14221213", "34221211", "12412123", "23321212", "12421213", "32421211", "21521212", "15112213", "24212212", "13312213", "33312211", "22412212", "11512213", "31512211", "16121122", "25221121", "14321122", "23421121", "12521122", "15212122", "15221212", "13412122", "24321211", "13421212", "11612122", "22521211", "16112212", "25212211", "14312212", "23412211", "12512212", "21612211", "11131126", "31131124", "51131122", "21122125", "41122123", "61122121", "21131215", "41131213", "61131211", "11113126", "31113124", "51113122", "11122216", "31122214", "51122212", "21113215", "41113213", "61113211", "12131125", "32131123", "52131121", "21231124", "41231122", "22122124", "42122122", "11222125", "22131214", "42131212", "11231215", "31231213", "51231211", "12113125", "32113123", "52113121", "12122215", "32122213", "52122211", "21222214", "41222212", "22113214", "42113212", "11213215", "31213213", "51213211", "13131124", "33131122", "22231123", "42231121", "11331124", "31331122", "23122123", "43122121", "12222124", "23131213", "43131211", "12231214", "32231212", "21331213", "41331211", "13113124", "33113122", "13122214", "33122212", "11313124", "22222213", "42222211", "11322214", "31322212", "23113213", "43113211", "12213214", "32213212", "21313213", "41313211", "14131123", "34131121", "23231122", "12331123", "32331121", "21431122", "24122122", "13222123", "24131212", "13231213", "33231211", "11422123", "22331212", "11431213", "31431211", "14113123", "34113121", "14122213", "34122211", "12313123", "23222212", "12322213", "32322211", "21422212", "24113212", "13213213", "33213211", "22313212", "11413213", "31413211", "15131122", "24231121", "13331122", "22431121", "25122121", "14222122", "25131211", "14231212", "12422122", "23331211", "12431212", "15113122", "15122212", "13313122", "24222211", "13322212", "11513122", "22422211", "11522212", "25113211", "14213212", "23313211", "12413212", "21513211", "16131121", "14331121", "15222121", "15231211", "13422121", "13431211", "16113121", "16122211", "14313121", "14322211", "12513121", "12522211", "15213211", "13413211", "11613211", "11141125", "31141123", "51141121", "21132124", "41132122", "21141214", "41141212", "11123125", "31123123", "51123121", "11132215", "31132213", "51132211", "21114124", "41114122", "21123214", "41123212", "11114215", "31114213", "51114211", "12141124", "32141122", "21241123", "41241121", "22132123", "42132121", "11232124", "22141213", "42141211", "11241214", "31241212", "12123124", "32123122", "12132214", "32132212", "21232213", "41232211", "22114123", "42114121", "11214124", "22123213", "42123211", "11223214", "31223212", "12114214", "32114212", "21214213", "41214211", "13141123", "33141121", "22241122", "11341123", "31341121", "23132122", "12232123", "23141212", "12241213", "32241211", "21341212", "13123123", "33123121", "13132213", "33132211", "11323123", "22232212", "11332213", "31332211", "23114122", "12214123", "23123212", "12223213", "32223211", "21323212", "13114213", "33114211", "22214212", "11314213", "31314211", "14141122", "23241121", "12341122", "24132121", "13232122", "24141211", "13241212", "11432122", "22341211", "14123122", "14132212", "12323122", "23232211", "12332212", "21432211", "24114121", "13214122", "24123211", "13223212", "11414122", "22323211", "11423212", "14114212", "23214211", "12314212", "21414211", "15141121", "13341121", "14232121", "14241211", "12432121", "15123121", "15132211", "13323121", "13332211", "11523121", "14214121", "14223211", "12414121", "12423211", "15114211", "13314211", "11514211", "11151124", "31151122", "21142123", "41142121", "21151213", "41151211", "11133124", "31133122", "11142214", "31142212", "21124123", "41124121", "21133213", "41133211", "11115124", "31115122", "11124214", "31124212", "21115213", "41115211", "12151123", "32151121", "21251122", "22142122", "11242123", "22151212", "11251213", "31251211", "12133123", "32133121", "12142213", "32142211", "21242212", "22124122", "11224123", "22133212", "11233213", "31233211", "12115123", "32115121", "12124213", "32124211", "21224212", "22115212", "11215213", "31215211", "13151122", "22251121", "23142121", "12242122", "23151211", "12251212", "13133122", "13142212", "11333122", "22242211", "11342212", "23124121", "12224122", "23133211", "12233212", "21333211", "13115122", "13124212", "11315122", "22224211", "11324212", "23115211", "12215212", "21315211", "14151121", "13242121", "13251211", "14133121", "14142211", "12333121", "12342211", "13224121", "13233211", "11424121", "11433211", "14115121", "14124211", "12315121", "12324211", "13215211", "11415211", "11161123", "31161121", "21152122", "21161212", "11143123", "31143121", "11152213", "31152211", "21134122", "21143212", "11125123", "31125121", "11134213", "31134211", "21116122", "21125212", "12161122", "22152121", "11252122", "22161211", "12143122", "12152212", "21252211", "22134121", "11234122", "22143211", "11243212", "12125122", "12134212", "21234211", "22116121", "11216122", "22125211", "11225212", "13161121", "12252121", "13143121", "13152211", "11343121", "12234121", "12243211", "13125121", "13134211", "11325121", "11334211", "12216121", "12225211", "31111225", "51111223", "21111316", "41111314", "61111312", "31211134", "51211132", "12111226", "32111224", "52111222", "21211225", "41211223", "61211221", "22111315", "42111313", "11211316", "31211314", "51211312", "12211135", "32211133", "52211131", "21311134", "41311132", "13111225", "33111223", "22211224", "42211222", "11311225", "31311223", "51311221", "23111314", "43111312", "12211315", "32211313", "52211311", "21311314", "41311312", "13211134", "33211132", "22311133", "42311131", "11411134", "31411132", "14111224", "34111222", "23211223", "43211221", "12311224", "32311222", "21411223", "41411221", "24111313", "13211314", "33211312", "22311313", "42311311", "11411314", "31411312", "14211133", "34211131", "23311132", "12411133", "32411131", "21511132", "15111223", "24211222", "13311223", "33311221", "22411222", "11511223", "31511221", "25111312", "14211313", "34211311", "23311312", "12411313", "32411311", "21511312", "15211132", "24311131", "13411132", "22511131", "11611132", "16111222", "25211221", "14311222", "23411221", "12511222", "21611221", "15211312", "24311311", "13411312", "22511311", "11611312", "21121135", "41121133", "61121131", "11112136", "31112134", "51112132", "11121226", "31121224", "51121222", "21112225", "41112223", "61112221", "21121315", "41121313", "61121311", "11112316", "31112314", "51112312", "22121134", "42121132", "11221135", "31221133", "51221131", "12112135", "32112133", "52112131", "12121225", "32121223", "52121221", "21221224", "41221222", "22112224", "42112222", "11212225", "22121314", "42121312", "11221315", "31221313", "51221311", "12112315", "32112313", "52112311", "21212314", "41212312", "23121133", "43121131", "12221134", "32221132", "21321133", "41321131", "13112134", "33112132", "13121224", "33121222", "11312134", "22221223", "42221221", "11321224", "31321222", "23112223", "43112221", "12212224", "23121313", "43121311", "12221314", "32221312", "21321313", "41321311", "13112314", "33112312", "22212313", "42212311", "11312314", "31312312", "24121132", "13221133", "33221131", "22321132", "11421133", "31421131", "14112133", "34112131", "14121223", "34121221", "12312133", "23221222", "12321223", "32321221", "21421222", "24112222", "13212223", "24121312", "13221313", "33221311", "11412223", "22321312", "11421313", "31421311", "14112313", "34112311", "23212312", "12312313", "32312311", "21412312", "25121131", "14221132", "23321131", "12421132", "21521131", "15112132", "15121222", "13312132", "24221221", "13321222", "11512132", "22421221", "11521222", "25112221", "14212222", "25121311", "14221312", "12412222", "23321311", "12421312", "21521311", "15112312", "24212311", "13312312", "22412311", "11512312", "15221131", "13421131", "16112131", "16121221", "14312131", "14321221", "12512131", "12521221", "15212221", "15221311", "13412221", "13421311", "11612221", "16112311", "14312311", "12512311", "21131134", "41131132", "11122135", "31122133", "51122131", "11131225", "31131223", "51131221", "21113134", "41113132", "21122224", "41122222", "21131314", "41131312", "11113225", "31113223", "51113221", "11122315", "31122313", "51122311", "21113314", "41113312", "22131133", "42131131", "11231134", "31231132", "12122134", "32122132", "12131224", "32131222", "21231223", "41231221", "22113133", "42113131", "11213134", "22122223", "42122221", "11222224", "22131313", "42131311", "11231314", "31231312", "12113224", "32113222", "12122314", "32122312", "21222313", "41222311", "22113313", "42113311", "11213314", "31213312", "23131132", "12231133", "32231131", "21331132", "13122133", "33122131", "13131223", "33131221", "11322133", "22231222", "11331223", "31331221", "23113132", "12213133", "23122222", "12222223", "23131312", "12231313", "32231311", "21331312", "13113223", "33113221", "13122313", "33122311", "11313223", "22222312", "11322313", "31322311", "23113312", "12213313", "32213311", "21313312", "24131131", "13231132", "22331131", "11431132", "14122132", "14131222", "12322132", "23231221", "12331222", "21431221", "24113131", "13213132", "24122221", "13222222", "24131311", "11413132", "13231312", "11422222", "22331311", "11431312", "14113222", "14122312", "12313222", "23222311", "12322312", "21422311", "24113311", "13213312", "22313311", "11413312", "14231131", "12431131", "15122131", "15131221", "13322131", "13331221", "11522131", "14213131", "14222221", "12413131", "14231311", "12422221", "12431311", "15113221", "15122311", "13313221", "13322311", "11513221", "11522311", "14213311", "12413311", "21141133", "41141131", "11132134", "31132132", "11141224", "31141222", "21123133", "41123131", "21132223", "41132221", "21141313", "41141311", "11114134", "31114132", "11123224", "31123222", "11132314", "31132312", "21114223", "41114221", "21123313", "41123311", "11114314", "31114312", "22141132", "11241133", "31241131", "12132133", "32132131", "12141223", "32141221", "21241222", "22123132", "11223133", "22132222", "11232223", "22141312", "11241313", "31241311", "12114133", "32114131", "12123223", "32123221", "12132313", "32132311", "21232312", "22114222", "11214223", "22123312", "11223313", "31223311", "12114313", "32114311", "21214312", "23141131", "12241132", "21341131", "13132132", "13141222", "11332132", "22241221", "11341222", "23123131", "12223132", "23132221", "12232222", "23141311", "12241312", "21341311", "13114132", "13123222", "11314132", "13132312", "11323222", "22232311", "11332312", "23114221", "12214222", "23123311", "12223312", "21323311", "13114312", "22214311", "11314312", "13241131", "14132131", "14141221", "12332131", "12341221", "13223131", "13232221", "11423131", "13241311", "11432221", "14114131", "14123221", "12314131", "14132311", "12323221", "12332311", "13214221", "13223311", "11414221", "11423311", "14114311", "12314311", "21151132", "11142133", "31142131", "11151223", "31151221", "21133132", "21142222", "21151312", "11124133", "31124131", "11133223", "31133221", "11142313", "31142311", "21115132", "21124222", "21133312", "11115223", "31115221", "11124313", "31124311", "22151131", "11251132", "12142132", "12151222", "21251221", "22133131", "11233132", "22142221", "11242222", "22151311", "11251312", "12124132", "12133222", "12142312", "21242311", "22115131", "11215132", "22124221", "11224222", "22133311", "11233312", "12115222", "12124312", "21224311", "12251131", "13142131", "13151221", "11342131", "12233131", "12242221", "12251311", "13124131", "13133221", "11324131", "13142311", "11333221", "11342311", "12215131", "12224221", "12233311", "13115221", "13124311", "11315221", "11324311", "21161131", "11152132", "11161222", "21143131", "21152221", "21161311", "11134132", "11143222", "11152312", "21125131", "21134221", "21143311", "11116132", "11125222", "11134312", "12152131", "12161221", "11243131", "11252221", "12134131", "12143221", "12152311", "11225131", "11234221", "11243311", "12116131", "12125221", "12134311", "21111235", "41111233", "61111231", "11111326", "31111324", "51111322", "21111415", "41111413", "61111411", "21211144", "41211142", "22111234", "42111232", "11211235", "31211233", "51211231", "12111325", "32111323", "52111321", "21211324", "41211322", "22111414", "42111412", "11211415", "31211413", "51211411", "22211143", "42211141", "11311144", "31311142", "23111233", "43111231", "12211234", "32211232", "21311233", "41311231", "13111324", "33111322", "22211323", "42211321", "11311324", "31311322", "23111413", "43111411", "12211414", "32211412", "21311413", "41311411", "23211142", "12311143", "32311141", "21411142", "24111232", "13211233", "33211231", "22311232", "11411233", "31411231", "14111323", "34111321", "23211322", "12311323", "32311321", "21411322", "24111412", "13211413", "33211411", "22311412", "11411413", "31411411", "24211141", "13311142", "22411141", "11511142", "25111231", "14211232", "23311231", "12411232", "21511231", "15111322", "24211321", "13311322", "22411321", "11511322", "25111411", "14211412", "23311411", "12411412", "21511411", "14311141", "12511141", "15211231", "13411231", "11611231", "16111321", "14311321", "12511321", "15211411", "13411411", "11611411", "31121143", "51121141", "21112144", "41112142", "21121234", "41121232", "11112235", "31112233", "51112231", "11121325", "31121323", "51121321", "21112324", "41112322", "21121414", "41121412", "11112415", "31112413", "51112411", "12121144", "32121142", "21221143", "41221141", "22112143", "42112141", "11212144", "22121233", "42121231", "11221234", "31221232", "12112234", "32112232", "12121324", "32121322", "21221323", "41221321", "22112323", "42112321", "11212324", "22121413", "42121411", "11221414", "31221412", "12112414", "32112412", "21212413", "41212411", "13121143", "33121141", "22221142", "11321143", "31321141", "23112142", "12212143", "23121232", "12221233", "32221231", "21321232", "13112233", "33112231", "13121323", "33121321", "11312233", "22221322", "11321323", "31321321", "23112322", "12212323", "23121412", "12221413", "32221411", "21321412", "13112413", "33112411", "22212412", "11312413", "31312411", "14121142", "23221141", "12321142", "21421141", "24112141", "13212142", "24121231", "13221232", "11412142", "22321231", "11421232", "14112232", "14121322", "12312232", "23221321", "12321322", "21421321", "24112321", "13212322", "24121411", "13221412", "11412322", "22321411", "11421412", "14112412", "23212411", "12312412", "21412411", "15121141", "13321141", "11521141", "14212141", "14221231", "12412141", "12421231", "15112231", "15121321", "13312231", "13321321", "11512231", "11521321", "14212321", "14221411", "12412321", "12421411", "15112411", "13312411", "11512411", "11131144", "31131142", "21122143", "41122141", "21131233", "41131231", "11113144", "31113142", "11122234", "31122232", "11131324", "31131322", "21113233", "41113231", "21122323", "41122321", "21131413", "41131411", "11113324", "31113322", "11122414", "31122412", "21113413", "41113411", "12131143", "32131141", "21231142", "22122142", "11222143", "22131232", "11231233", "31231231", "12113143", "32113141", "12122233", "32122231", "12131323", "32131321", "21231322", "22113232", "11213233", "22122322", "11222323", "22131412", "11231413", "31231411", "12113323", "32113321", "12122413", "32122411", "21222412", "22113412", "11213413", "31213411", "13131142", "22231141", "11331142", "23122141", "12222142", "23131231", "12231232", "21331231", "13113142", "13122232", "11313142", "13131322", "11322232", "22231321", "11331322", "23113231", "12213232", "23122321", "12222322", "23131411", "12231412", "21331411", "13113322", "13122412", "11313322", "22222411", "11322412", "23113411", "12213412", "21313411", "14131141", "12331141", "13222141", "13231231", "11422141", "11431231", "14113141", "14122231", "12313141", "14131321", "12322231", "12331321", "13213231", "13222321", "11413231", "13231411", "11422321", "11431411", "14113321", "14122411", "12313321", "12322411", "13213411", "11413411", "11141143", "31141141", "21132142", "21141232", "11123143", "31123141", "11132233", "31132231", "11141323", "31141321", "21114142", "21123232", "21132322", "21141412", "11114233", "31114231", "11123323", "31123321", "11132413", "31132411", "21114322", "21123412", "12141142", "21241141", "22132141", "11232142", "22141231", "11241232", "12123142", "12132232", "12141322", "21241321", "22114141", "11214142", "22123231", "11223232", "22132321", "11232322", "22141411", "11241412", "12114232", "12123322", "12132412", "21232411", "22114321", "11214322", "22123411", "11223412", "13141141", "11341141", "12232141", "12241231", "13123141", "13132231", "11323141", "13141321", "11332231", "11341321", "12214141", "12223231", "12232321", "12241411", "13114231", "13123321", "11314231", "13132411", "11323321", "11332411", "12214321", "12223411", "11151142", "21142141", "21151231", "11133142", "11142232", "11151322", "21124141", "21133231", "21142321", "21151411", "11115142", "11124232", "11133322", "11142412", "21115231", "21124321", "21133411", "12151141", "11242141", "11251231", "12133141", "12142231", "12151321", "11224141", "11233231", "11242321", "11251411", "12115141", "12124231", "12133321", "12142411", "11215231", "11224321", "11233411", "11161141", "11143141", "11152231", "11161321", "11125141", "11134231", "11143321", "11152411", "11111245", "31111243", "51111241", "21111334", "41111332", "11111425", "31111423", "51111421", "21111514", "41111512", "31211152", "12111244", "32111242", "21211243", "41211241", "22111333", "42111331", "11211334", "31211332", "12111424", "32111422", "21211423", "41211421", "22111513", "42111511", "11211514", "31211512", "12211153", "32211151", "21311152", "13111243", "33111241", "22211242", "11311243", "31311241", "23111332", "12211333", "32211331", "21311332", "13111423", "33111421", "22211422", "11311423", "31311421", "23111512", "12211513", "32211511", "21311512", "13211152", "22311151", "11411152", "14111242", "23211241", "12311242", "21411241", "24111331", "13211332", "22311331", "11411332", "14111422", "23211421", "12311422", "21411421", "24111511", "13211512", "22311511", "11411512", "14211151", "12411151", "15111241", "13311241", "11511241", "14211331", "12411331", "15111421", "13311421", "11511421", "14211511", "12411511", "21121153", "41121151", "11112154", "31112152", "11121244", "31121242", "21112243", "41112241", "21121333", "41121331", "11112334", "31112332", "11121424", "31121422", "21112423", "41112421", "21121513", "41121511", "11112514", "31112512", "22121152", "11221153", "31221151", "12112153", "32112151", "12121243", "32121241", "21221242", "22112242", "11212243", "22121332", "11221333", "31221331", "12112333", "32112331", "12121423", "32121421", "21221422", "22112422", "11212423", "22121512", "11221513", "31221511", "12112513", "32112511", "21212512", "23121151", "12221152", "21321151", "13112152", "13121242", "11312152", "22221241", "11321242", "23112241", "12212242", "23121331", "12221332", "21321331", "13112332", "13121422", "11312332", "22221421", "11321422", "23112421", "12212422", "23121511", "12221512", "21321511", "13112512", "22212511", "11312512", "13221151", "11421151", "14112151", "14121241", "12312151", "12321241", "13212241", "13221331", "11412241", "11421331", "14112331", "14121421", "12312331", "12321421", "13212421", "13221511", "11412421", "11421511", "14112511", "12312511", "21131152", "11122153", "31122151", "11131243", "31131241", "21113152", "21122242", "21131332", "11113243", "31113241", "11122333", "31122331", "11131423", "31131421", "21113332", "21122422", "21131512", "11113423", "31113421", "11122513", "31122511", "22131151", "11231152", "12122152", "12131242", "21231241", "22113151", "11213152", "22122241", "11222242", "22131331", "11231332", "12113242", "12122332", "12131422", "21231421", "22113331", "11213332", "22122421", "11222422", "22131511", "11231512", "12113422", "12122512", "21222511", "12231151", "13122151", "13131241", "11322151", "11331241", "12213151", "12222241", "12231331", "13113241", "13122331", "11313241", "13131421", "11322331", "11331421", "12213331", "12222421", "12231511", "13113421", "13122511", "11313421", "11322511", "21141151", "11132152", "11141242", "21123151", "21132241", "21141331", "11114152", "11123242", "11132332", "11141422", "21114241", "21123331", "21132421", "21141511", "11114332", "11123422", "11132512", "11241151", "12132151", "12141241", "11223151", "11232241", "11241331", "12114151", "12123241", "12132331", "12141421", "11214241", "11223331", "11232421", "11241511", "12114331", "12123421", "12132511", "11142151", "11151241", "11124151", "11133241", "11142331", "11151421", "11115241", "11124331", "11133421", "11142511", "21111253", "41111251", "11111344", "31111342", "21111433", "41111431", "11111524", "31111522", "21111613", "41111611", "21211162", "22111252", "11211253", "31211251", "12111343", "32111341", "21211342", "22111432", "11211433", "31211431", "12111523", "32111521", "21211522", "22111612", "11211613", "31211611", "22211161", "11311162", "23111251", "12211252", "21311251", "13111342", "22211341", "11311342", "23111431", "12211432", "21311431", "13111522", "22211521", "11311522", "23111611", "12211612", "21311611", "12311161", "13211251", "11411251", "14111341", "12311341", "13211431", "11411431", "14111521", "12311521", "13211611", "11411611", "31121161", "21112162", "21121252", "11112253", "31112251", "11121343", "31121341", "21112342", "21121432", "11112433", "31112431", "11121523", "31121521", "21112522", "21121612", "12121162", "21221161", "22112161", "11212162", "22121251", "11221252", "12112252", "12121342", "21221341", "22112341", "11212342", "22121431", "11221432", "12112432", "12121522", "21221521", "22112521", "11212522", "22121611", "11221612", "13121161", "11321161", "12212161", "12221251", "13112251", "13121341", "11312251", "11321341", "12212341", "12221431", "13112431", "13121521", "11312431", "11321521", "12212521", "12221611", "11131162", "21122161", "21131251", "11113162"])]);
  $_.parity = $a(["1001", "0101", "1100", "0011", "1010", "0110", "1111", "0000"]);
  $_.rowbits = $a($_.r);
  for (var _6G = 0, _6F = $_.r - 1; _6G <= _6F; _6G += 1) {
    $_.i = _6G;
    $k[$j++] = "p";
    if ($_.i != $_.r - 1) {
      $k[$j++] = $get($_.parity, $_.i);
    } else {
      $k[$j++] = "0000";
    }
    var _6M = $k[--$j];
    $_[$k[--$j]] = _6M;
    $_.ccrow = $geti($_.ccs, $_.i * 8, 8);
    $k[$j++] = Infinity;
    for (var _6R = 0; _6R <= 7; _6R += 2) {
      $aload($geti($_.ccrow, _6R, 2));
      var _6U = $k[--$j];
      var _6V = $k[--$j];
      $k[$j++] = $f(_6U + _6V * 49);
    }
    $_.scrow = $a();
    $k[$j++] = Infinity;
    $k[$j++] = 10;
    $k[$j++] = 1;
    $k[$j++] = 1;
    for (var _6X = 0; _6X <= 3; _6X += 1) {
      $_.j = _6X;
      $forall($get($get($_.patterns, $get($_.p, $_.j) - 48), $get($_.scrow, $_.j)), function() {
        var _6h = $k[--$j];
        $k[$j++] = _6h - 48;
      });
    }
    $k[$j++] = 4;
    $k[$j++] = 1;
    $_.sbs = $a();
    $k[$j++] = Infinity;
    var _6j = $_.sbs;
    $k[$j++] = 1;
    for (var _6k = 0, _6l = _6j.length; _6k < _6l; _6k++) {
      var _6n = $k[$j - 1];
      var _6o = _6n == 0 ? 1 : 0;
      for (var _6p = 0, _6q = $get(_6j, _6k); _6p < _6q; _6p++) {
        $k[$j++] = _6o;
      }
    }
    $astore($a($counttomark() - 1));
    var _6t = $k[--$j];
    $k[$j - 1] = _6t;
    var _6v = $k[--$j];
    $k[$j - 1] = _6v;
    $k[$j++] = $_.rowbits;
    $k[$j++] = $_.i;
    var _6z = $k[$j - 3];
    var _70 = $k[$j - 1];
    $put($k[$j - 2], _70, _6z);
    $j -= 3;
  }
  $k[$j++] = Infinity;
  for (var _73 = 0, _74 = 81 * $_.sepheight; _73 < _74; _73++) {
    $k[$j++] = 1;
  }
  for (var _77 = 0, _76 = $_.r - 2; _77 <= _76; _77 += 1) {
    $_.i = _77;
    for (var _79 = 0, _7A = $_.rowheight; _79 < _7A; _79++) {
      $aload($get($_.rowbits, $_.i));
    }
    for (var _7F = 0, _7G = $_.sepheight; _7F < _7G; _7F++) {
      for (var _7H = 0; _7H < 10; _7H++) {
        $k[$j++] = 0;
      }
      for (var _7I = 0; _7I < 70; _7I++) {
        $k[$j++] = 1;
      }
      $k[$j++] = 0;
    }
  }
  for (var _7K = 0, _7L = $_.rowheight; _7K < _7L; _7K++) {
    $aload($get($_.rowbits, $_.r - 1));
  }
  for (var _7Q = 0, _7R = 81 * $_.sepheight; _7Q < _7R; _7Q++) {
    $k[$j++] = 1;
  }
  $_.pixs = $a();
  var _7X = /* @__PURE__ */ new Map([
    ["ren", "renmatrix"],
    ["pixs", $_.pixs],
    ["pixx", 81],
    ["pixy", ~~($_.pixs.length / 81)],
    ["height", ~~($_.pixs.length / 81) / 72],
    ["width", 81 / 72],
    ["opt", $_.options]
  ]);
  $k[$j++] = _7X;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_flattermarken() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.includetext = false;
  $_.textfont = "OCR-B";
  $_.textsize = 10;
  $_.textyoffset = -8;
  $_.height = 0.3;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $forall($_.barcode, function() {
    var _3 = $k[--$j];
    if (_3 < 48 || _3 > 57) {
      $k[$j++] = "bwipp.flattermarkenBadCharacter#17258";
      $k[$j++] = "Flattermarken must contain only digits";
      bwipp_raiseerror();
    }
  });
  $_.encs = $a(["0018", "0117", "0216", "0315", "0414", "0513", "0612", "0711", "0810", "0900"]);
  $_.barchars = "1234567890";
  $_.barlen = $_.barcode.length;
  $_.sbs = $s($_.barlen * 4);
  $_.txt = $a($_.barlen);
  for (var _D = 0, _C = $_.barlen - 1; _D <= _C; _D += 1) {
    $_.i = _D;
    $search($_.barchars, $geti($_.barcode, $_.i, 1));
    $j--;
    $_.indx = $k[--$j].length;
    $j -= 2;
    $_.enc = $get($_.encs, $_.indx);
    $puti($_.sbs, $_.i * 4, $_.enc);
    $put($_.txt, $_.i, $a([$geti($_.barcode, $_.i, 1), $_.i * 9, $_.textyoffset, $_.textfont, $_.textsize]));
  }
  $k[$j++] = Infinity;
  $k[$j++] = Infinity;
  var _Z = $_.sbs;
  for (var _a = 0, _b = _Z.length; _a < _b; _a++) {
    $k[$j++] = $get(_Z, _a) - 48;
  }
  var _d = $a();
  $k[$j++] = Infinity;
  for (var _f = 0, _g = ~~(($_.sbs.length + 1) / 2); _f < _g; _f++) {
    $k[$j++] = $_.height;
  }
  var _i = $a();
  $k[$j++] = Infinity;
  for (var _k = 0, _l = ~~(($_.sbs.length + 1) / 2); _k < _l; _k++) {
    $k[$j++] = 0;
  }
  var _m = $a();
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "sbs";
  $k[$j++] = _d;
  $k[$j++] = "bhs";
  $k[$j++] = _i;
  $k[$j++] = "bbs";
  $k[$j++] = _m;
  $k[$j++] = "txt";
  $k[$j++] = $_.txt;
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  var _p = $d();
  $k[$j++] = _p;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_raw() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.height = 1;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $forall($_.barcode, function() {
    var _3 = $k[--$j];
    if (_3 < 49 || _3 > 57) {
      $k[$j++] = "bwipp.rawBadCharacter#17344";
      $k[$j++] = "Raw must contain only digits 1 to 9";
      bwipp_raiseerror();
    }
  });
  $k[$j++] = Infinity;
  $k[$j++] = Infinity;
  $forall($_.barcode, function() {
    var _5 = $k[--$j];
    $k[$j++] = _5 - 48;
  });
  var _6 = $a();
  $k[$j++] = Infinity;
  for (var _8 = 0, _9 = ~~(($_.barcode.length + 1) / 2); _8 < _9; _8++) {
    $k[$j++] = $_.height;
  }
  var _B = $a();
  $k[$j++] = Infinity;
  for (var _D = 0, _E = ~~(($_.barcode.length + 1) / 2); _D < _E; _D++) {
    $k[$j++] = 0;
  }
  var _F = $a();
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "sbs";
  $k[$j++] = _6;
  $k[$j++] = "bhs";
  $k[$j++] = _B;
  $k[$j++] = "bbs";
  $k[$j++] = _F;
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  var _H = $d();
  $k[$j++] = _H;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_daft() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.height = 0.175;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length == 0) {
    $k[$j++] = "bwipp.daftEmptyData#17397";
    $k[$j++] = "The data must not be empty";
    bwipp_raiseerror();
  }
  $forall($_.barcode, function() {
    var _4 = $k[--$j];
    if (_4 != 68 && (_4 != 65 && (_4 != 70 && _4 != 84))) {
      $k[$j++] = "bwipp.daftBadCharacter#17402";
      $k[$j++] = "DAFT must contain only characters D, A, F and T";
      bwipp_raiseerror();
    }
  });
  $_.barlen = $_.barcode.length;
  $_.bbs = $a($_.barlen);
  $_.bhs = $a($_.barlen);
  for (var _C = 0, _B = $_.barlen - 1; _C <= _B; _C += 1) {
    $_.i = _C;
    $_.enc = $geti($_.barcode, $_.i, 1);
    if ($eq($_.enc, "D")) {
      $put($_.bbs, $_.i, 0 * $_.height / 8);
      $put($_.bhs, $_.i, 5 * $_.height / 8);
    }
    if ($eq($_.enc, "A")) {
      $put($_.bbs, $_.i, 3 * $_.height / 8);
      $put($_.bhs, $_.i, 5 * $_.height / 8);
    }
    if ($eq($_.enc, "F")) {
      $put($_.bbs, $_.i, 0 * $_.height / 8);
      $put($_.bhs, $_.i, 8 * $_.height / 8);
    }
    if ($eq($_.enc, "T")) {
      $put($_.bbs, $_.i, 3 * $_.height / 8);
      $put($_.bhs, $_.i, 2 * $_.height / 8);
    }
  }
  $k[$j++] = Infinity;
  var _i = $_.bbs;
  var _j = $_.bhs;
  $k[$j++] = Infinity;
  for (var _l = 0, _m = $_.bhs.length - 1; _l < _m; _l++) {
    $k[$j++] = 1.44;
    $k[$j++] = 1.872;
  }
  $k[$j++] = 1.44;
  var _n = $a();
  $k[$j++] = "ren";
  $k[$j++] = "renlinear";
  $k[$j++] = "bbs";
  $k[$j++] = _i;
  $k[$j++] = "bhs";
  $k[$j++] = _j;
  $k[$j++] = "sbs";
  $k[$j++] = _n;
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  var _p = $d();
  $k[$j++] = _p;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_symbol() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $_.fimasbs = $a([2.25, 2.25, 2.25, 11.25, 2.25, 11.25, 2.25, 2.25, 2.25]);
  $k[$j++] = Infinity;
  for (var _4 = 0, _5 = ~~($_.fimasbs.length / 2) + 1; _4 < _5; _4++) {
    $k[$j++] = 0.625;
  }
  $_.fimabhs = $a();
  $k[$j++] = Infinity;
  for (var _8 = 0, _9 = ~~($_.fimasbs.length / 2) + 1; _8 < _9; _8++) {
    $k[$j++] = 0;
  }
  $_.fimabbs = $a();
  $_.fimbsbs = $a([2.25, 6.75, 2.25, 2.25, 2.25, 6.25, 2.25, 2.25, 2.25, 6.75, 2.25]);
  $k[$j++] = Infinity;
  for (var _D = 0, _E = ~~($_.fimbsbs.length / 2) + 1; _D < _E; _D++) {
    $k[$j++] = 0.625;
  }
  $_.fimbbhs = $a();
  $k[$j++] = Infinity;
  for (var _H = 0, _I = ~~($_.fimbsbs.length / 2) + 1; _H < _I; _H++) {
    $k[$j++] = 0;
  }
  $_.fimbbbs = $a();
  $_.fimcsbs = $a([2.25, 2.25, 2.25, 6.75, 2.25, 6.75, 2.25, 6.75, 2.25, 2.25, 2.25]);
  $k[$j++] = Infinity;
  for (var _M = 0, _N = ~~($_.fimcsbs.length / 2) + 1; _M < _N; _M++) {
    $k[$j++] = 0.625;
  }
  $_.fimcbhs = $a();
  $k[$j++] = Infinity;
  for (var _Q = 0, _R = ~~($_.fimcsbs.length / 2) + 1; _Q < _R; _Q++) {
    $k[$j++] = 0;
  }
  $_.fimcbbs = $a();
  $_.fimdsbs = $a([2.25, 2.25, 2.25, 2.25, 2.25, 6.75, 2.25, 6.75, 2.25, 2.25, 2.25, 2.25, 2.25]);
  $k[$j++] = Infinity;
  for (var _V = 0, _W = ~~($_.fimdsbs.length / 2) + 1; _V < _W; _V++) {
    $k[$j++] = 0.625;
  }
  $_.fimdbhs = $a();
  $k[$j++] = Infinity;
  for (var _Z = 0, _a = ~~($_.fimdsbs.length / 2) + 1; _Z < _a; _Z++) {
    $k[$j++] = 0;
  }
  $_.fimdbbs = $a();
  $_.fimesbs = $a([2.25, 6.75, 2.25, 15.75, 2.25, 6.75, 2.25]);
  $k[$j++] = Infinity;
  for (var _e = 0, _f = ~~($_.fimesbs.length / 2) + 1; _e < _f; _e++) {
    $k[$j++] = 0.625;
  }
  $_.fimebhs = $a();
  $k[$j++] = Infinity;
  for (var _i = 0, _j = ~~($_.fimesbs.length / 2) + 1; _i < _j; _i++) {
    $k[$j++] = 0;
  }
  $_.fimebbs = $a();
  $k[$j++] = Infinity;
  for (var _l = 0; _l < 100; _l++) {
    $k[$j++] = 1;
    $k[$j++] = 1;
  }
  $k[$j++] = 1;
  $_.zebrasbs = $a();
  $k[$j++] = Infinity;
  for (var _o = 0, _p = ~~($_.zebrasbs.length / 2) + 1; _o < _p; _o++) {
    $k[$j++] = 1;
  }
  $_.zebrabhs = $a();
  $k[$j++] = Infinity;
  for (var _s = 0, _t = ~~($_.zebrasbs.length / 2) + 1; _s < _t; _s++) {
    $k[$j++] = 0;
  }
  $_.zebrabbs = $a();
  $_.checksize = 199;
  $k[$j++] = Infinity;
  var _v = $_.checksize;
  for (var _w = 0, _x = ~~(_v * _v / 2); _w < _x; _w++) {
    $k[$j++] = 1;
    $k[$j++] = 0;
  }
  $k[$j++] = 1;
  $_.checkpixs = $a();
  var _z = /* @__PURE__ */ new Map([
    ["renlinear", bwipp_renlinear],
    ["renmatrix", bwipp_renmatrix]
  ]);
  $_.renmap = _z;
  var _1V = /* @__PURE__ */ new Map([
    ["fima", function() {
      var _14 = /* @__PURE__ */ new Map([
        ["ren", "renlinear"],
        ["sbs", $_.fimasbs],
        ["bhs", $_.fimabhs],
        ["bbs", $_.fimabbs]
      ]);
      $k[$j++] = _14;
    }],
    ["fimb", function() {
      var _18 = /* @__PURE__ */ new Map([
        ["ren", "renlinear"],
        ["sbs", $_.fimbsbs],
        ["bhs", $_.fimbbhs],
        ["bbs", $_.fimbbbs]
      ]);
      $k[$j++] = _18;
    }],
    ["fimc", function() {
      var _1C = /* @__PURE__ */ new Map([
        ["ren", "renlinear"],
        ["sbs", $_.fimcsbs],
        ["bhs", $_.fimcbhs],
        ["bbs", $_.fimcbbs]
      ]);
      $k[$j++] = _1C;
    }],
    ["fimd", function() {
      var _1G = /* @__PURE__ */ new Map([
        ["ren", "renlinear"],
        ["sbs", $_.fimdsbs],
        ["bhs", $_.fimdbhs],
        ["bbs", $_.fimdbbs]
      ]);
      $k[$j++] = _1G;
    }],
    ["fime", function() {
      var _1K = /* @__PURE__ */ new Map([
        ["ren", "renlinear"],
        ["sbs", $_.fimesbs],
        ["bhs", $_.fimebhs],
        ["bbs", $_.fimebbs]
      ]);
      $k[$j++] = _1K;
    }],
    ["zebra", function() {
      var _1O = /* @__PURE__ */ new Map([
        ["ren", "renlinear"],
        ["sbs", $_.zebrasbs],
        ["bhs", $_.zebrabhs],
        ["bbs", $_.zebrabbs]
      ]);
      $k[$j++] = _1O;
    }],
    ["check", function() {
      var _1U = /* @__PURE__ */ new Map([
        ["ren", "renmatrix"],
        ["pixs", $_.checkpixs],
        ["pixx", $_.checksize],
        ["pixy", $_.checksize],
        ["height", $_.checksize / 72],
        ["width", $_.checksize / 72]
      ]);
      $k[$j++] = _1U;
    }]
  ]);
  $_.symbols = _1V;
  var _1Y = $get($_.symbols, $_.barcode) !== void 0;
  if (!_1Y) {
    $k[$j++] = "bwipp.symbolUnknownSymbol#17531";
    $k[$j++] = "Unknown symbol name provided";
    bwipp_raiseerror();
  }
  if ($get($_.symbols, $_.barcode)() === true) {
    return true;
  }
  var _1c = $k[$j - 1];
  $put(_1c, "opt", $_.options);
  if (!$_.dontdraw) {
    var _1f = $k[$j - 1];
    if ($get($_.renmap, $get(_1f, "ren"))() === true) {
      return true;
    }
  }
  $_ = $__;
}
function bwipp_pdf417() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.compact = false;
  $_.eclevel = -1;
  $_.fixedeclevel = false;
  $_.columns = 0;
  $_.rows = 0;
  $_.rowmult = 3;
  $_.ccc = false;
  $_.raw = false;
  $_.parse = false;
  $_.parsefnc = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length == 0) {
    $k[$j++] = "bwipp.pdf417emptyData#17591";
    $k[$j++] = "The data must not be empty";
    bwipp_raiseerror();
  }
  if ($_.eclevel != -1 && ($_.eclevel < 0 || $_.eclevel > 8)) {
    $k[$j++] = "bwipp.pdf417InvalidErrorCorrectionLevel#17595";
    $k[$j++] = "Valid error correction levels are 0 to 8";
    bwipp_raiseerror();
  }
  if ($_.ccc && $_.raw) {
    $k[$j++] = "bwipp.pdf417cccAndRaw#17599";
    $k[$j++] = "Cannot combine ccc and raw";
    bwipp_raiseerror();
  }
  if ($_.ccc && $_.compact) {
    $k[$j++] = "bwipp.pdf417cccAndCompact#17603";
    $k[$j++] = "Cannot combine ccc and compact";
    bwipp_raiseerror();
  }
  if ($_.rows != 0 && ($_.rows < 3 || $_.rows > 90)) {
    $k[$j++] = "bwipp.pdf417invalidRows#17607";
    $k[$j++] = "There must be between 3 and 90 rows";
    bwipp_raiseerror();
  }
  if ($_.columns != 0 && ($_.columns < 1 || $_.columns > 30)) {
    $k[$j++] = "bwipp.pdf417invalidColumns#17611";
    $k[$j++] = "There must be between 1 and 30 columns";
    bwipp_raiseerror();
  }
  if ($_.rowmult <= 0) {
    $k[$j++] = "bwipp.pdf417badRowMult#17615";
    $k[$j++] = "The row multiplier must be greater than zero";
    bwipp_raiseerror();
  }
  $_.T = 0;
  $_.N = 1;
  $_.B = 2;
  $_.A = 0;
  $_.L = 1;
  $_.M = 2;
  $_.P = 3;
  $_.tl = -1;
  $_.nl = -2;
  $_.bl = -3;
  $_.bl6 = -4;
  $_.bs = -5;
  $_.al = -6;
  $_.ll = -7;
  $_.ml = -8;
  $_.pl = -9;
  $_.as = -10;
  $_.ps = -11;
  $_.charmaps = $a([$a(["A", "a", "0", ";"]), $a(["B", "b", "1", "<"]), $a(["C", "c", "2", ">"]), $a(["D", "d", "3", "@"]), $a(["E", "e", "4", "["]), $a(["F", "f", "5", 92]), $a(["G", "g", "6", "]"]), $a(["H", "h", "7", "_"]), $a(["I", "i", "8", "`"]), $a(["J", "j", "9", "~"]), $a(["K", "k", "&", "!"]), $a(["L", "l", 13, 13]), $a(["M", "m", 9, 9]), $a(["N", "n", ",", ","]), $a(["O", "o", ":", ":"]), $a(["P", "p", "#", 10]), $a(["Q", "q", "-", "-"]), $a(["R", "r", ".", "."]), $a(["S", "s", "$", "$"]), $a(["T", "t", "/", "/"]), $a(["U", "u", "+", '"']), $a(["V", "v", "%", "|"]), $a(["W", "w", "*", "*"]), $a(["X", "x", "=", 40]), $a(["Y", "y", "^", 41]), $a(["Z", "z", $_.pl, "?"]), $a([" ", " ", " ", "{"]), $a([$_.ll, $_.as, $_.ll, "}"]), $a([$_.ml, $_.ml, $_.al, "'"]), $a([$_.ps, $_.ps, $_.ps, $_.al])]);
  $_.charvals = $a([/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map()]);
  $_.alltext = /* @__PURE__ */ new Map();
  for (var _10 = 0, _z = $_.charmaps.length - 1; _10 <= _z; _10 += 1) {
    $_.i = _10;
    $_.encs = $get($_.charmaps, $_.i);
    for (var _14 = 0; _14 <= 3; _14 += 1) {
      $_.j = _14;
      var _17 = $get($_.encs, $_.j);
      $k[$j++] = _17;
      if ($eq($type(_17), "stringtype")) {
        var _1A = $get($k[--$j], 0);
        $k[$j++] = _1A;
      }
      var _1B = $k[--$j];
      $put($get($_.charvals, $_.j), _1B, $_.i);
      $put($_.alltext, _1B, -1);
    }
  }
  $_.e = 1e4;
  $_.latlen = $a([$a([0, 1, 1, 2]), $a([2, 0, 1, 2]), $a([1, 1, 0, 1]), $a([1, 2, 2, 0])]);
  $_.latseq = $a([$a([$a([]), $a([$_.ll]), $a([$_.ml]), $a([$_.ml, $_.pl])]), $a([$a([$_.ml, $_.al]), $a([]), $a([$_.ml]), $a([$_.ml, $_.pl])]), $a([$a([$_.al]), $a([$_.ll]), $a([]), $a([$_.pl])]), $a([$a([$_.al]), $a([$_.al, $_.ll]), $a([$_.al, $_.ml]), $a([])])]);
  $_.shftlen = $a([$a([$_.e, $_.e, $_.e, 1]), $a([1, $_.e, $_.e, 1]), $a([$_.e, $_.e, $_.e, 1]), $a([$_.e, $_.e, $_.e, $_.e])]);
  $k[$j++] = Infinity;
  $k[$j++] = $_.tl;
  $k[$j++] = 900;
  $k[$j++] = $_.bl;
  $k[$j++] = 901;
  $k[$j++] = $_.bl6;
  $k[$j++] = 924;
  $k[$j++] = $_.nl;
  $k[$j++] = 902;
  $k[$j++] = $_.bs;
  $k[$j++] = 913;
  $_.latchcws = $d();
  if ($_.raw) {
    $_.datcws = $a($_.barcode.length);
    $_.i = 0;
    $_.j = 0;
    for (; ; ) {
      if ($_.i >= $_.barcode.length - 3) {
        break;
      }
      if ($get($_.barcode, $_.i) != 94) {
        break;
      }
      var _2W = $geti($_.barcode, $_.i + 1, 3);
      $k[$j++] = _2W;
      $k[$j++] = false;
      for (var _2X = 0, _2Y = _2W.length; _2X < _2Y; _2X++) {
        var _2Z = $get(_2W, _2X);
        if (_2Z < 48 || _2Z > 57) {
          $k[$j - 1] = true;
        }
      }
      if ($k[--$j]) {
        $j--;
        break;
      }
      $_.cw = $cvi($k[--$j]);
      $put($_.datcws, $_.j, $_.cw);
      $_.i = $_.i + 4;
      $_.j = $_.j + 1;
    }
    if ($_.i != $_.barcode.length) {
      $k[$j++] = "bwipp.pdf417badRawFormat#17727";
      $k[$j++] = "raw data must be formatted as ^NNN";
      bwipp_raiseerror();
    }
    $_.datcws = $geti($_.datcws, 0, $_.j);
  }
  $_.encb = function() {
    $_.in = $k[--$j];
    $_.inlen = $_.in.length;
    $_.out = $a(~~($_.inlen / 6) * 5 + $_.inlen % 6);
    for (var _2t = 0, _2s = ~~($_.inlen / 6) - 1; _2t <= _2s; _2t += 1) {
      $_.k = _2t;
      $k[$j++] = Infinity;
      $aload($geti($_.in, $_.k * 6, 3));
      $_.msbs = $a();
      $k[$j++] = Infinity;
      $aload($_.msbs);
      var _2z = $k[--$j];
      var _30 = $k[--$j];
      var _31 = $k[--$j];
      $k[$j++] = $f(_2z + _30 * 256 + _31 * 65536);
      for (var _32 = 0; _32 < 3; _32++) {
        var _33 = $k[--$j];
        $k[$j++] = _33 % 900;
        $k[$j++] = ~~(_33 / 900);
      }
      $_.mscs = $a();
      $k[$j++] = Infinity;
      $aload($geti($_.in, $_.k * 6 + 3, 3));
      $_.lsbs = $a();
      $k[$j++] = Infinity;
      $aload($_.lsbs);
      var _3A = $k[--$j];
      var _3B = $k[--$j];
      var _3C = $k[--$j];
      $k[$j++] = $f(_3A + _3B * 256 + _3C * 65536);
      for (var _3D = 0; _3D < 3; _3D++) {
        var _3E = $k[--$j];
        $k[$j++] = _3E % 900;
        $k[$j++] = ~~(_3E / 900);
      }
      $_.lscs = $a();
      var _3H = $get($_.lscs, 0);
      var _3J = $get($_.mscs, 0);
      $put($_.out, $_.k * 5 + 4, $f(_3H + _3J * 316) % 900);
      var _3N = $get($_.lscs, 1);
      var _3P = $get($_.mscs, 0);
      var _3R = $get($_.mscs, 1);
      $put($_.out, $_.k * 5 + 3, $f(~~((_3H + _3J * 316) / 900) + _3N + _3P * 641 + _3R * 316) % 900);
      var _3V = $get($_.lscs, 2);
      var _3X = $get($_.mscs, 0);
      var _3Z = $get($_.mscs, 1);
      var _3b = $get($_.mscs, 2);
      $put($_.out, $_.k * 5 + 2, $f(~~((~~((_3H + _3J * 316) / 900) + _3N + _3P * 641 + _3R * 316) / 900) + _3V + _3X * 20 + _3Z * 641 + _3b * 316) % 900);
      var _3f = $get($_.lscs, 3);
      var _3h = $get($_.mscs, 1);
      var _3j = $get($_.mscs, 2);
      $put($_.out, $_.k * 5 + 1, $f(~~((~~((~~((_3H + _3J * 316) / 900) + _3N + _3P * 641 + _3R * 316) / 900) + _3V + _3X * 20 + _3Z * 641 + _3b * 316) / 900) + _3f + _3h * 20 + _3j * 641) % 900);
      $put($_.out, $_.k * 5, $f(~~((~~((~~((~~((_3H + _3J * 316) / 900) + _3N + _3P * 641 + _3R * 316) / 900) + _3V + _3X * 20 + _3Z * 641 + _3b * 316) / 900) + _3f + _3h * 20 + _3j * 641) / 900) + $get($_.mscs, 2) * 20) % 900);
    }
    $_.rem = $_.inlen % 6;
    if ($_.rem != 0) {
      $k[$j++] = $_.out;
      $k[$j++] = $_.out.length - $_.rem;
      $k[$j++] = Infinity;
      $aload($geti($_.in, $_.inlen - $_.rem, $_.rem));
      var _40 = $a();
      var _41 = $k[--$j];
      $puti($k[--$j], _41, _40);
    }
    $k[$j++] = $_.out;
  };
  if ($_.ccc) {
    $_.barlen = $_.barcode.length;
    $_.datcws = $a(~~($_.barlen / 6) * 5 + $_.barlen % 6 + 2);
    $put($_.datcws, 0, 920);
    var _4C = $_.barlen % 6 == 0 ? 924 : 901;
    $put($_.datcws, 1, _4C);
    $k[$j++] = $_.datcws;
    $k[$j++] = 2;
    $k[$j++] = Infinity;
    $forall($_.barcode);
    var _4F = $a();
    $k[$j++] = _4F;
    $_.encb();
    var _4G = $k[--$j];
    var _4H = $k[--$j];
    $puti($k[--$j], _4H, _4G);
  }
  if (!$_.raw && !$_.ccc) {
    var _4N = /* @__PURE__ */ new Map([
      ["parse", $_.parse],
      ["parsefnc", $_.parsefnc],
      ["eci", true]
    ]);
    $_.fncvals = _4N;
    $k[$j++] = "msg";
    $k[$j++] = $_.barcode;
    $k[$j++] = $_.fncvals;
    bwipp_parseinput();
    var _4Q = $k[--$j];
    $_[$k[--$j]] = _4Q;
    $_.msglen = $_.msg.length;
    $k[$j++] = Infinity;
    for (var _4U = 0, _4V = $_.msglen; _4U < _4V; _4U++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $_.numdigits = $a();
    $k[$j++] = Infinity;
    for (var _4Y = 0, _4Z = $_.msglen; _4Y < _4Z; _4Y++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $_.numtext = $a();
    $k[$j++] = Infinity;
    for (var _4c = 0, _4d = $_.msglen; _4c < _4d; _4c++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $_.numbytes = $a();
    $k[$j++] = Infinity;
    for (var _4g = 0, _4h = $_.msglen; _4g < _4h; _4g++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $_.iseci = $a();
    for (var _4k = $_.msglen - 1; _4k >= 0; _4k -= 1) {
      $_.i = _4k;
      var _4n = $get($_.msg, $_.i);
      if (_4n >= 48 && _4n <= 57) {
        $put($_.numdigits, $_.i, $get($_.numdigits, $_.i + 1) + 1);
      }
      var _4x = $get($_.alltext, $get($_.msg, $_.i)) !== void 0;
      if (_4x && $get($_.numdigits, $_.i) < 13) {
        $put($_.numtext, $_.i, $get($_.numtext, $_.i + 1) + 1);
      }
      if ($get($_.msg, $_.i) >= 0 && $get($_.numtext, $_.i) < 5 && $get($_.numdigits, $_.i) < 13) {
        $put($_.numbytes, $_.i, $get($_.numbytes, $_.i + 1) + 1);
      }
      $put($_.iseci, $_.i, $get($_.msg, $_.i) <= -1e6);
    }
    $_.numdigits = $geti($_.numdigits, 0, $_.msglen);
    $_.numtext = $geti($_.numtext, 0, $_.msglen);
    $_.numbytes = $geti($_.numbytes, 0, $_.msglen);
    $_.seq = $a([]);
    $_.seqlen = 0;
    $_.state = $_.T;
    $_.p = 0;
    for (; ; ) {
      if ($_.p == $_.msglen) {
        break;
      }
      if ($get($_.iseci, $_.p)) {
        $_.eci = $get($_.msg, $_.p);
        $k[$j++] = Infinity;
        $aload($_.seq);
        $k[$j++] = $a([$_.eci]);
        $_.seq = $a();
        $_.p = $_.p + 1;
        $k[$j++] = "seqlen";
        $k[$j++] = $_.seqlen;
        if ($_.eci <= -1810900) {
          $k[$j++] = 2;
        } else {
          var _5q = $_.eci <= -1000900 ? 3 : 2;
          $k[$j++] = _5q;
        }
        var _5r = $k[--$j];
        var _5s = $k[--$j];
        $_[$k[--$j]] = $f(_5s + _5r);
      } else {
        $_.n = $get($_.numdigits, $_.p);
        if ($_.n >= 13 || $_.n == $_.msglen && $_.n >= 8) {
          $k[$j++] = Infinity;
          $aload($_.seq);
          $k[$j++] = $_.nl;
          $k[$j++] = Infinity;
          $aload($geti($_.msg, $_.p, $_.n));
          var _67 = $a();
          $k[$j++] = _67;
          $_.seq = $a();
          $_.state = $_.N;
          $_.p = $f($_.p + $_.n);
          $_.seqlen = $f($_.seqlen + 1 + $_.n);
        } else {
          $_.t = $get($_.numtext, $_.p);
          if ($_.t >= 5) {
            $k[$j++] = Infinity;
            $aload($_.seq);
            if ($_.state != $_.T) {
              $k[$j++] = $_.tl;
            }
            $k[$j++] = Infinity;
            $aload($geti($_.msg, $_.p, $_.t));
            var _6Q = $a();
            $k[$j++] = _6Q;
            $_.seq = $a();
            $_.state = $_.T;
            $_.p = $f($_.p + $_.t);
            $_.seqlen = $f($_.seqlen + 1 + $_.t);
          } else {
            $_.b = $get($_.numbytes, $_.p);
            if ($_.b == 1 && $_.state == $_.T) {
              $k[$j++] = Infinity;
              $aload($_.seq);
              $k[$j++] = $_.bs;
              $k[$j++] = $a([$get($_.msg, $_.p)]);
              $_.seq = $a();
              $_.p = $f($_.p + $_.b);
              $_.seqlen = $_.seqlen + 2;
            } else {
              $k[$j++] = Infinity;
              $aload($_.seq);
              var _6p = $_.b % 6 != 0 ? $_.bl : $_.bl6;
              $k[$j++] = _6p;
              $k[$j++] = Infinity;
              $aload($geti($_.msg, $_.p, $_.b));
              var _6u = $a();
              $k[$j++] = _6u;
              $_.seq = $a();
              $_.state = $_.B;
              $_.p = $f($_.p + $_.b);
              $_.seqlen = $f($_.seqlen + 1 + $_.b);
            }
          }
        }
      }
    }
    $_.enca = function() {
      var _75 = $get($get($_.charvals, $_.A), $k[--$j]);
      $k[$j++] = _75;
    };
    $_.encl = function() {
      var _7A = $get($get($_.charvals, $_.L), $k[--$j]);
      $k[$j++] = _7A;
    };
    $_.encm = function() {
      var _7F = $get($get($_.charvals, $_.M), $k[--$j]);
      $k[$j++] = _7F;
    };
    $_.encp = function() {
      var _7K = $get($get($_.charvals, $_.P), $k[--$j]);
      $k[$j++] = _7K;
    };
    $_.textencfuncs = $a(["enca", "encl", "encm", "encp"]);
    $_.addtotext = function() {
      $put($_.text, $_.l, $k[--$j]);
      $_.l = $_.l + 1;
    };
    $_.enct = function() {
      $_.in = $k[--$j];
      $_.curlen = $a([$_.e, $_.e, $_.e, $_.e]);
      $put($_.curlen, $_.submode, 0);
      $_.curseq = $a([$a([]), $a([]), $a([]), $a([])]);
      $forall($_.in, function() {
        $_.char = $k[--$j];
        for (; ; ) {
          $_.imp = false;
          var _7j = $a([$_.A, $_.L, $_.M, $_.P]);
          for (var _7k = 0, _7l = _7j.length; _7k < _7l; _7k++) {
            $_.x = $get(_7j, _7k);
            var _7r = $a([$_.A, $_.L, $_.M, $_.P]);
            for (var _7s = 0, _7t = _7r.length; _7s < _7t; _7s++) {
              $_.y = $get(_7r, _7s);
              $_.cost = $f($get($_.curlen, $_.x) + $get($get($_.latlen, $_.x), $_.y));
              if ($_.cost < $get($_.curlen, $_.y)) {
                $put($_.curlen, $_.y, $_.cost);
                $k[$j++] = $_.curseq;
                $k[$j++] = $_.y;
                $k[$j++] = Infinity;
                $aload($get($_.curseq, $_.x));
                $aload($get($get($_.latseq, $_.x), $_.y));
                var _8K = $a();
                var _8L = $k[--$j];
                $put($k[--$j], _8L, _8K);
                $_.imp = true;
              }
            }
          }
          if (!$_.imp) {
            break;
          }
        }
        $_.nxtlen = $a([$_.e, $_.e, $_.e, $_.e]);
        $_.nxtseq = $a(4);
        var _8Y = $a([$_.A, $_.L, $_.M, $_.P]);
        for (var _8Z = 0, _8a = _8Y.length; _8Z < _8a; _8Z++) {
          $_.x = $get(_8Y, _8Z);
          for (; ; ) {
            var _8g = $get($get($_.charvals, $_.x), $_.char) !== void 0;
            if (!_8g) {
              break;
            }
            $_.cost = $get($_.curlen, $_.x) + 1;
            if ($_.cost < $get($_.nxtlen, $_.x)) {
              $put($_.nxtlen, $_.x, $_.cost);
              $k[$j++] = $_.nxtseq;
              $k[$j++] = $_.x;
              $k[$j++] = Infinity;
              $aload($get($_.curseq, $_.x));
              $k[$j++] = $_.char;
              var _8x = $a();
              var _8y = $k[--$j];
              $put($k[--$j], _8y, _8x);
            }
            var _94 = $a([$_.A, $_.L, $_.M, $_.P]);
            for (var _95 = 0, _96 = _94.length; _95 < _96; _95++) {
              $_.y = $get(_94, _95);
              if ($ne($_.x, $_.y)) {
                $_.cost = $f($get($_.curlen, $_.y) + $get($get($_.shftlen, $_.y), $_.x)) + 1;
                if ($_.cost < $get($_.nxtlen, $_.y)) {
                  $put($_.nxtlen, $_.y, $_.cost);
                  $k[$j++] = $_.nxtseq;
                  $k[$j++] = $_.y;
                  $k[$j++] = Infinity;
                  $aload($get($_.curseq, $_.y));
                  var _9W = $_.x == $_.A ? $_.as : $_.ps;
                  $k[$j++] = _9W;
                  $k[$j++] = $_.char;
                  var _9Y = $a();
                  var _9Z = $k[--$j];
                  $put($k[--$j], _9Z, _9Y);
                }
              }
            }
            break;
          }
        }
        $_.curlen = $_.nxtlen;
        $_.curseq = $_.nxtseq;
      });
      $_.minseq = $_.e;
      var _9i = $a([$_.A, $_.L, $_.M, $_.P]);
      for (var _9j = 0, _9k = _9i.length; _9j < _9k; _9j++) {
        $_.k = $get(_9i, _9j);
        if ($get($_.curlen, $_.k) < $_.minseq) {
          $_.minseq = $get($_.curlen, $_.k);
          $_.txtseq = $get($_.curseq, $_.k);
        }
      }
      $_.text = $a($_.minseq);
      $_.k = 0;
      $_.l = 0;
      for (; ; ) {
        if ($_.k >= $_.txtseq.length) {
          break;
        }
        $_.char = $get($_.txtseq, $_.k);
        $k[$j++] = $_.char;
        if ($_[$get($_.textencfuncs, $_.submode)]() === true) {
          break;
        }
        $_.addtotext();
        $_.k = $_.k + 1;
        if ($_.char == $_.as || $_.char == $_.ps) {
          $k[$j++] = $get($_.txtseq, $_.k);
          if ($_.char == $_.as) {
            $_.enca();
          } else {
            $_.encp();
          }
          $_.addtotext();
          $_.k = $_.k + 1;
        }
        if ($_.char == $_.al) {
          $_.submode = $_.A;
        }
        if ($_.char == $_.ll) {
          $_.submode = $_.L;
        }
        if ($_.char == $_.ml) {
          $_.submode = $_.M;
        }
        if ($_.char == $_.pl) {
          $_.submode = $_.P;
        }
      }
      if ($_.text.length % 2 == 1) {
        if ($_.submode == $_.P) {
          $k[$j++] = "pad";
          $k[$j++] = $_.al;
          $_.encp();
          var _AZ = $k[--$j];
          $_[$k[--$j]] = _AZ;
          $_.submode = $_.A;
        } else {
          $_.nextecitext = false;
          for (var _Af = $_.i + 1, _Ae = $_.seq.length - 1; _Af <= _Ae; _Af += 1) {
            $_.ti = _Af;
            if ($ne($type($get($_.seq, $_.ti)), "arraytype")) {
              $_.nextecitext = false;
              break;
            }
            if ($get($get($_.seq, $_.ti), 0) > -1e6) {
              break;
            }
            $_.nextecitext = true;
          }
          if ($_.nextecitext) {
            if ($_.submode == $_.A) {
              var _Ay = $get($get($_.charvals, $_.L), $get($get($_.seq, $_.ti), 0)) !== void 0;
              if (_Ay) {
                $k[$j++] = "pad";
                $k[$j++] = $_.ll;
                $_.enca();
                var _B0 = $k[--$j];
                $_[$k[--$j]] = _B0;
                $_.submode = $_.L;
              } else {
                $k[$j++] = "pad";
                $k[$j++] = $_.ml;
                $_.enca();
                var _B4 = $k[--$j];
                $_[$k[--$j]] = _B4;
                $_.submode = $_.M;
              }
            } else {
              if ($_.submode == $_.M) {
                var _BG = $get($get($_.charvals, $_.L), $get($get($_.seq, $_.ti), 0)) !== void 0;
                if (_BG) {
                  $k[$j++] = "pad";
                  $k[$j++] = $_.ll;
                  $_.encm();
                  var _BI = $k[--$j];
                  $_[$k[--$j]] = _BI;
                  $_.submode = $_.L;
                } else {
                  var _BS = $get($get($_.charvals, $_.P), $get($get($_.seq, $_.ti), 0)) !== void 0;
                  if (_BS) {
                    $k[$j++] = "pad";
                    $k[$j++] = $_.pl;
                    $_.encm();
                    var _BU = $k[--$j];
                    $_[$k[--$j]] = _BU;
                    $_.submode = $_.P;
                  } else {
                    $k[$j++] = "pad";
                    $k[$j++] = $_.al;
                    $_.encm();
                    var _BY = $k[--$j];
                    $_[$k[--$j]] = _BY;
                    $_.submode = $_.A;
                  }
                }
              } else {
                $k[$j++] = "pad";
                $k[$j++] = $_.ml;
                $_.encl();
                var _Bc = $k[--$j];
                $_[$k[--$j]] = _Bc;
                $_.submode = $_.M;
              }
            }
          } else {
            $k[$j++] = "pad";
            $k[$j++] = $_.ps;
            if ($_[$get($_.textencfuncs, $_.submode)]() === true) {
              return true;
            }
            var _Bk = $k[--$j];
            $_[$k[--$j]] = _Bk;
          }
        }
        $k[$j++] = Infinity;
        $aload($_.text);
        $k[$j++] = $_.pad;
        $_.text = $a();
      }
      $_.out = $a(~~($_.text.length / 2));
      for (var _Bt = 0, _Bs = $_.out.length - 1; _Bt <= _Bs; _Bt += 1) {
        $_.k = _Bt;
        $put($_.out, $_.k, $f($get($_.text, $_.k * 2) * 30 + $get($_.text, $_.k * 2 + 1)));
      }
      $k[$j++] = $_.out;
    };
    $_.encn = function() {
      $_.in = $k[--$j];
      $_.out = $a([]);
      for (var _C7 = 0, _C6 = $_.in.length - 1; _C7 <= _C6; _C7 += 44) {
        $_.k = _C7;
        $k[$j++] = Infinity;
        var _CC = $_.in.length - $_.k;
        $k[$j++] = 1;
        $k[$j++] = $_.in;
        $k[$j++] = $_.k;
        $k[$j++] = _CC;
        if (_CC > 44) {
          $k[$j - 1] = 44;
        }
        var _CD = $k[--$j];
        var _CE = $k[--$j];
        var _CG = $geti($k[--$j], _CE, _CD);
        for (var _CH = 0, _CI = _CG.length; _CH < _CI; _CH++) {
          $k[$j++] = $get(_CG, _CH) - 48;
        }
        $_.gmod = $a();
        $_.cwn = $a([]);
        for (; ; ) {
          $_.dv = 900;
          $_.gmul = $a([]);
          $_.val = 0;
          for (; ; ) {
            if ($_.gmod.length == 0) {
              break;
            }
            $_.val = $f($_.val * 10 + $get($_.gmod, 0));
            $_.gmod = $geti($_.gmod, 1, $_.gmod.length - 1);
            if ($_.val < $_.dv) {
              if ($_.gmul.length != 0) {
                $k[$j++] = Infinity;
                $aload($_.gmul);
                $k[$j++] = 0;
                $_.gmul = $a();
              }
            } else {
              $k[$j++] = Infinity;
              $aload($_.gmul);
              $k[$j++] = ~~($_.val / $_.dv);
              $_.gmul = $a();
            }
            $_.val = $_.val % $_.dv;
          }
          $_.dv = $_.val;
          $k[$j++] = Infinity;
          $k[$j++] = $_.dv;
          $aload($_.cwn);
          $_.cwn = $a();
          $_.gmod = $_.gmul;
          if ($_.gmul.length == 0) {
            break;
          }
        }
        $k[$j++] = Infinity;
        $aload($_.out);
        $aload($_.cwn);
        $_.out = $a();
      }
      $k[$j++] = $_.out;
    };
    $_.ence = function() {
      var _Cr = -$get($k[--$j], 0) - 1e6;
      $k[$j++] = _Cr;
      if (_Cr <= 899) {
        var _Cs = $k[--$j];
        $k[$j++] = 927;
        $k[$j++] = _Cs;
        $astore($a(2));
      } else {
        var _Cu = $k[$j - 1];
        if (_Cu <= 810899) {
          var _Cv = $k[--$j];
          $k[$j++] = 926;
          $k[$j++] = ~~(_Cv / 900) - 1;
          $k[$j++] = _Cv % 900;
          $astore($a(3));
        } else {
          var _Cx = $k[$j - 1];
          if (_Cx <= 811799) {
            var _Cy = $k[--$j];
            $k[$j++] = 925;
            $k[$j++] = _Cy - 810900;
            $astore($a(2));
          } else {
            $k[$j++] = "bwipp.pdf417badECI#18089";
            $k[$j++] = "PDF417 supports ECIs 000000 to 811799";
            bwipp_raiseerror();
          }
        }
      }
    };
    $_.encfuncs = $a(["enct", "encn", "encb"]);
    $_.addtocws = function() {
      var _D1 = $k[--$j];
      $puti($_.datcws, $_.j, _D1);
      $_.j = _D1.length + $_.j;
    };
    $_.state = $_.T;
    $_.submode = $_.A;
    $_.datcws = $a($_.seqlen);
    $_.i = 0;
    $_.j = 0;
    for (; ; ) {
      if ($_.i >= $_.seq.length) {
        break;
      }
      $_.chars = $get($_.seq, $_.i);
      if ($eq($type($_.chars), "arraytype")) {
        if ($get($_.chars, 0) <= -1e6) {
          $k[$j++] = $_.chars;
          $_.ence();
          $_.addtocws();
        } else {
          $k[$j++] = $_.chars;
          if ($_[$get($_.encfuncs, $_.state)]() === true) {
            break;
          }
          $_.addtocws();
        }
      } else {
        $k[$j++] = $a([$get($_.latchcws, $_.chars)]);
        $_.addtocws();
        if ($_.chars == $_.tl) {
          $_.state = $_.T;
          $_.submode = $_.A;
        }
        if ($_.chars == $_.nl) {
          $_.state = $_.N;
        }
        if ($_.chars == $_.bl || $_.chars == $_.bl6) {
          $_.state = $_.B;
        }
        if ($_.chars == $_.bs) {
          $_.i = $_.i + 1;
          $k[$j++] = $get($_.seq, $_.i);
          $_.encb();
          $_.addtocws();
        }
      }
      $_.i = $_.i + 1;
    }
    $_.datcws = $geti($_.datcws, 0, $_.j);
  }
  $_.m = $_.datcws.length;
  if ($_.m > 926) {
    $k[$j++] = "bwipp.pdf417dataTooLong#18129";
    $k[$j++] = "The data is too long";
    bwipp_raiseerror();
  }
  if ($_.eclevel == -1) {
    if ($_.m <= 40) {
      $_.eclevel = 2;
    }
    if ($_.m >= 41 && $_.m <= 160) {
      $_.eclevel = 3;
    }
    if ($_.m >= 161 && $_.m <= 320) {
      $_.eclevel = 4;
    }
    if ($_.m >= 321) {
      $_.eclevel = 5;
    }
  }
  if (!$_.fixedeclevel) {
    $_.maxeclevel = ~~($log(928 - 1 - $_.m) / $log(2)) - 1;
    if ($_.eclevel > $_.maxeclevel) {
      $_.eclevel = $_.maxeclevel;
    }
  }
  $_.k = ~~$pow(2, $_.eclevel + 1);
  if ($_.columns == 0) {
    $_.columns = ~~$round($sqrt(($_.m + $_.k) / 3));
  }
  $k[$j++] = "c";
  if ($_.columns >= 1) {
    $k[$j++] = $_.columns;
  } else {
    $k[$j++] = 1;
  }
  var _E8 = $k[--$j];
  $_[$k[--$j]] = _E8;
  $_.r = ~~$ceil(($_.m + $_.k + 1) / $_.columns);
  if ($_.r < $_.rows && $_.rows <= 90) {
    $_.r = $_.rows;
  }
  if ($_.r < 3) {
    $_.r = 3;
  }
  if ($_.r > 90) {
    $k[$j++] = "bwipp.pdf417insufficientCapacity#18158";
    $k[$j++] = "Insufficient capacity in the symbol";
    bwipp_raiseerror();
  }
  if (!$_.fixedeclevel) {
    var _EK = $_.c;
    var _EL = $_.r;
    var _EM = $_.m;
    var _EN = 8;
    var _EO = ~~($log($f(_EK * _EL - 1 - _EM)) / $log(2)) - 1;
    if (~~($log($f(_EK * _EL - 1 - _EM)) / $log(2)) - 1 > 8) {
      var _ = _EN;
      _EN = _EO;
      _EO = _;
    }
    $_.maxeclevel = _EO;
    if ($_.maxeclevel > $_.eclevel) {
      $_.eclevel = $_.maxeclevel;
      $_.k = ~~$pow(2, $_.eclevel + 1);
    }
  }
  $_.n = $f($_.c * $_.r - $_.k);
  $_.cws = $a($_.c * $_.r + 1);
  $put($_.cws, 0, $_.n);
  $puti($_.cws, 1, $_.datcws);
  $k[$j++] = $_.cws;
  $k[$j++] = $_.m + 1;
  $k[$j++] = Infinity;
  for (var _Eh = 0, _Ei = $f($_.n - $_.m) - 1; _Eh < _Ei; _Eh++) {
    $k[$j++] = 900;
  }
  var _Ej = $a();
  var _Ek = $k[--$j];
  $puti($k[--$j], _Ek, _Ej);
  $k[$j++] = $_.cws;
  $k[$j++] = $_.n;
  $k[$j++] = Infinity;
  for (var _Ep = 0, _Eq = $_.k; _Ep < _Eq; _Ep++) {
    $k[$j++] = 0;
  }
  $k[$j++] = 0;
  var _Er = $a();
  var _Es = $k[--$j];
  $puti($k[--$j], _Es, _Er);
  $k[$j++] = Infinity;
  $k[$j++] = 1;
  for (var _Eu = 0; _Eu < 928; _Eu++) {
    var _Ev = $k[$j - 1];
    $k[$j++] = _Ev * 3 % 929;
  }
  $_.rsalog = $a();
  $_.rslog = $a(929);
  for (var _Ey = 1; _Ey <= 928; _Ey += 1) {
    $put($_.rslog, $get($_.rsalog, _Ey), _Ey);
  }
  $_.rsprod = function() {
    var _F3 = $k[$j - 1];
    var _F4 = $k[$j - 2];
    if (_F3 != 0 && _F4 != 0) {
      var _F7 = $get($_.rslog, $k[--$j]);
      var _FC = $get($_.rsalog, $f(_F7 + $get($_.rslog, $k[--$j])) % 928);
      $k[$j++] = _FC;
    } else {
      $j -= 2;
      $k[$j++] = 0;
    }
  };
  $k[$j++] = Infinity;
  $k[$j++] = 1;
  for (var _FE = 0, _FF = $_.k; _FE < _FF; _FE++) {
    $k[$j++] = 0;
  }
  $_.coeffs = $a();
  for (var _FJ = 1, _FI = $_.k; _FJ <= _FI; _FJ += 1) {
    $_.i = _FJ;
    $put($_.coeffs, $_.i, $get($_.coeffs, $_.i - 1));
    for (var _FQ = $_.i - 1; _FQ >= 1; _FQ -= 1) {
      $_.j = _FQ;
      $k[$j++] = $_.coeffs;
      $k[$j++] = $_.j;
      $k[$j++] = $get($_.coeffs, $_.j - 1);
      $k[$j++] = $get($_.coeffs, $_.j);
      $k[$j++] = $get($_.rsalog, $_.i);
      $_.rsprod();
      var _Fc = $k[--$j];
      var _Fd = $k[--$j];
      var _Fe = $k[--$j];
      $put($k[--$j], _Fe, $f(_Fd + _Fc) % 929);
    }
    $k[$j++] = $_.coeffs;
    $k[$j++] = 0;
    $k[$j++] = $get($_.coeffs, 0);
    $k[$j++] = $get($_.rsalog, $_.i);
    $_.rsprod();
    var _Fm = $k[--$j];
    var _Fn = $k[--$j];
    $put($k[--$j], _Fn, _Fm);
  }
  $_.coeffs = $geti($_.coeffs, 0, $_.coeffs.length - 1);
  for (var _Ft = $_.coeffs.length - 1; _Ft >= 0; _Ft -= 2) {
    var _Fu = $_.coeffs;
    $put(_Fu, _Ft, 929 - $get(_Fu, _Ft));
  }
  for (var _Fy = 0, _Fx = $_.n - 1; _Fy <= _Fx; _Fy += 1) {
    $_.t = $f($get($_.cws, _Fy) + $get($_.cws, $_.n)) % 929;
    for (var _G6 = 0, _G5 = $_.k - 1; _G6 <= _G5; _G6 += 1) {
      $_.j = _G6;
      $put($_.cws, $f($_.n + $_.j), $f($get($_.cws, $f($_.n + $_.j) + 1) + (929 - $_.t * $get($_.coeffs, $_.k - $_.j - 1) % 929)) % 929);
    }
  }
  for (var _GN = $_.n, _GM = $f($_.n + $_.k); _GN <= _GM; _GN += 1) {
    $put($_.cws, _GN, (929 - $get($_.cws, _GN)) % 929);
  }
  $_.cws = $geti($_.cws, 0, $_.cws.length - 1);
  var _GV = $get($_.options, "debugcws") !== void 0;
  if (_GV) {
    $k[$j++] = "bwipp.debugcws#18221";
    $k[$j++] = $_.cws;
    bwipp_raiseerror();
  }
  $_.clusters = $a([$a([120256, 125680, 128380, 120032, 125560, 128318, 108736, 119920, 108640, 86080, 108592, 86048, 110016, 120560, 125820, 109792, 120440, 125758, 88256, 109680, 88160, 89536, 110320, 120700, 89312, 110200, 120638, 89200, 110140, 89840, 110460, 89720, 110398, 89980, 128506, 119520, 125304, 128190, 107712, 119408, 125244, 107616, 119352, 84032, 107568, 119324, 84e3, 107544, 83984, 108256, 119672, 125374, 85184, 108144, 119612, 85088, 108088, 119582, 85040, 108060, 85728, 108408, 119742, 85616, 108348, 85560, 108318, 85880, 108478, 85820, 85790, 107200, 119152, 125116, 107104, 119096, 125086, 83008, 107056, 119068, 82976, 107032, 82960, 82952, 83648, 107376, 119228, 83552, 107320, 119198, 83504, 107292, 83480, 83468, 83824, 107452, 83768, 107422, 83740, 83900, 106848, 118968, 125022, 82496, 106800, 118940, 82464, 106776, 118926, 82448, 106764, 82440, 106758, 82784, 106936, 119006, 82736, 106908, 82712, 106894, 82700, 82694, 106974, 82830, 82240, 106672, 118876, 82208, 106648, 118862, 82192, 106636, 82184, 106630, 82180, 82352, 82328, 82316, 82080, 118830, 106572, 106566, 82050, 117472, 124280, 127678, 103616, 117360, 124220, 103520, 117304, 124190, 75840, 103472, 75808, 104160, 117624, 124350, 76992, 104048, 117564, 76896, 103992, 76848, 76824, 77536, 104312, 117694, 77424, 104252, 77368, 77340, 77688, 104382, 77628, 77758, 121536, 126320, 128700, 121440, 126264, 128670, 111680, 121392, 126236, 111648, 121368, 126222, 111632, 121356, 103104, 117104, 124092, 112320, 103008, 117048, 124062, 112224, 121656, 126366, 93248, 74784, 102936, 117006, 93216, 112152, 93200, 75456, 103280, 117180, 93888, 75360, 103224, 117150, 93792, 112440, 121758, 93744, 75288, 93720, 75632, 103356, 94064, 75576, 103326, 94008, 112542, 93980, 75708, 94140, 75678, 94110, 121184, 126136, 128606, 111168, 121136, 126108, 111136, 121112, 126094, 111120, 121100, 111112, 111108, 102752, 116920, 123998, 111456, 102704, 116892, 91712, 74272, 121244, 116878, 91680, 74256, 102668, 91664, 111372, 102662, 74244, 74592, 102840, 116958, 92e3, 74544, 102812, 91952, 111516, 102798, 91928, 74508, 74502, 74680, 102878, 92088, 74652, 92060, 74638, 92046, 92126, 110912, 121008, 126044, 110880, 120984, 126030, 110864, 120972, 110856, 120966, 110852, 110850, 74048, 102576, 116828, 90944, 74016, 102552, 116814, 90912, 111e3, 121038, 90896, 73992, 102534, 90888, 110982, 90884, 74160, 102620, 91056, 74136, 102606, 91032, 111054, 91020, 74118, 91014, 91100, 91086, 110752, 120920, 125998, 110736, 120908, 110728, 120902, 110724, 110722, 73888, 102488, 116782, 90528, 73872, 102476, 90512, 110796, 102470, 90504, 73860, 90500, 73858, 73944, 90584, 90572, 90566, 120876, 120870, 110658, 102444, 73800, 90312, 90308, 90306, 101056, 116080, 123580, 100960, 116024, 70720, 100912, 115996, 70688, 100888, 70672, 70664, 71360, 101232, 116156, 71264, 101176, 116126, 71216, 101148, 71192, 71180, 71536, 101308, 71480, 101278, 71452, 71612, 71582, 118112, 124600, 127838, 105024, 118064, 124572, 104992, 118040, 124558, 104976, 118028, 104968, 118022, 100704, 115896, 123486, 105312, 100656, 115868, 79424, 70176, 118172, 115854, 79392, 105240, 100620, 79376, 70152, 79368, 70496, 100792, 115934, 79712, 70448, 118238, 79664, 105372, 100750, 79640, 70412, 79628, 70584, 100830, 79800, 70556, 79772, 70542, 70622, 79838, 122176, 126640, 128860, 122144, 126616, 128846, 122128, 126604, 122120, 126598, 122116, 104768, 117936, 124508, 113472, 104736, 126684, 124494, 113440, 122264, 126670, 113424, 104712, 117894, 113416, 122246, 104706, 69952, 100528, 115804, 78656, 69920, 100504, 115790, 96064, 78624, 104856, 117966, 96032, 113560, 122318, 100486, 96016, 78600, 104838, 96008, 69890, 70064, 100572, 78768, 70040, 100558, 96176, 78744, 104910, 96152, 113614, 70022, 78726, 70108, 78812, 70094, 96220, 78798, 122016, 126552, 128814, 122e3, 126540, 121992, 126534, 121988, 121986, 104608, 117848, 124462, 113056, 104592, 126574, 113040, 122060, 117830, 113032, 104580, 113028, 104578, 113026, 69792, 100440, 115758, 78240, 69776, 100428, 95136, 78224, 104652, 100422, 95120, 113100, 69764, 95112, 78212, 69762, 78210, 69848, 100462, 78296, 69836, 95192, 78284, 69830, 95180, 78278, 69870, 95214, 121936, 126508, 121928, 126502, 121924, 121922, 104528, 117804, 112848, 104520, 117798, 112840, 121958, 112836, 104514, 112834, 69712, 100396, 78032, 69704, 100390, 94672, 78024, 104550, 94664, 112870, 69698, 94660, 78018, 94658, 78060, 94700, 94694, 126486, 121890, 117782, 104484, 104482, 69672, 77928, 94440, 69666, 77922, 99680, 68160, 99632, 68128, 99608, 115342, 68112, 99596, 68104, 99590, 68448, 99768, 115422, 68400, 99740, 68376, 99726, 68364, 68358, 68536, 99806, 68508, 68494, 68574, 101696, 116400, 123740, 101664, 116376, 101648, 116364, 101640, 116358, 101636, 67904, 99504, 115292, 72512, 67872, 116444, 115278, 72480, 101784, 116430, 72464, 67848, 99462, 72456, 101766, 67842, 68016, 99548, 72624, 67992, 99534, 72600, 101838, 72588, 67974, 68060, 72668, 68046, 72654, 118432, 124760, 127918, 118416, 124748, 118408, 124742, 118404, 118402, 101536, 116312, 105888, 101520, 116300, 105872, 118476, 116294, 105864, 101508, 105860, 101506, 105858, 67744, 99416, 72096, 67728, 116334, 80800, 72080, 101580, 99398, 80784, 105932, 67716, 80776, 72068, 67714, 72066, 67800, 99438, 72152, 67788, 80856, 72140, 67782, 80844, 72134, 67822, 72174, 80878, 126800, 128940, 126792, 128934, 126788, 126786, 118352, 124716, 122576, 126828, 124710, 122568, 126822, 122564, 118338, 122562, 101456, 116268, 105680, 101448, 116262, 114128, 105672, 118374, 114120, 122598, 101442, 114116, 105666, 114114, 67664, 99372, 71888, 67656, 99366, 80336, 71880, 101478, 97232, 80328, 105702, 67650, 97224, 114150, 71874, 97220, 67692, 71916, 67686, 80364, 71910, 97260, 80358, 97254, 126760, 128918, 126756, 126754, 118312, 124694, 122472, 126774, 122468, 118306, 122466, 101416, 116246, 105576, 101412, 113896, 105572, 101410, 113892, 105570, 113890, 67624, 99350, 71784, 101430, 80104, 71780, 67618, 96744, 80100, 71778, 96740, 80098, 96738, 71798, 96758, 126738, 122420, 122418, 105524, 113780, 113778, 71732, 79988, 96500, 96498, 66880, 66848, 98968, 66832, 66824, 66820, 66992, 66968, 66956, 66950, 67036, 67022, 1e5, 99984, 115532, 99976, 115526, 99972, 99970, 66720, 98904, 69024, 100056, 98892, 69008, 100044, 69e3, 100038, 68996, 66690, 68994, 66776, 98926, 69080, 100078, 69068, 66758, 69062, 66798, 69102, 116560, 116552, 116548, 116546, 99920, 102096, 116588, 115494, 102088, 116582, 102084, 99906, 102082, 66640, 68816, 66632, 98854, 73168, 68808, 66628, 73160, 68804, 66626, 73156, 68802, 66668, 68844, 66662, 73196, 68838, 73190, 124840, 124836, 124834, 116520, 118632, 124854, 118628, 116514, 118626, 99880, 115478, 101992, 116534, 106216, 101988, 99874, 106212, 101986, 106210, 66600, 98838, 68712, 99894, 72936, 68708, 66594, 81384, 72932, 68706, 81380, 72930, 66614, 68726, 72950, 81398, 128980, 128978, 124820, 126900, 124818, 126898, 116500, 118580, 116498, 122740, 118578, 122738, 99860, 101940, 99858, 106100, 101938, 114420]), $a([128352, 129720, 125504, 128304, 129692, 125472, 128280, 129678, 125456, 128268, 125448, 128262, 125444, 125792, 128440, 129758, 120384, 125744, 128412, 120352, 125720, 128398, 120336, 125708, 120328, 125702, 120324, 120672, 125880, 128478, 110144, 120624, 125852, 110112, 120600, 125838, 110096, 120588, 110088, 120582, 110084, 110432, 120760, 125918, 89664, 110384, 120732, 89632, 110360, 120718, 89616, 110348, 89608, 110342, 89952, 110520, 120798, 89904, 110492, 89880, 110478, 89868, 90040, 110558, 90012, 89998, 125248, 128176, 129628, 125216, 128152, 129614, 125200, 128140, 125192, 128134, 125188, 125186, 119616, 125360, 128220, 119584, 125336, 128206, 119568, 125324, 119560, 125318, 119556, 119554, 108352, 119728, 125404, 108320, 119704, 125390, 108304, 119692, 108296, 119686, 108292, 108290, 85824, 108464, 119772, 85792, 108440, 119758, 85776, 108428, 85768, 108422, 85764, 85936, 108508, 85912, 108494, 85900, 85894, 85980, 85966, 125088, 128088, 129582, 125072, 128076, 125064, 128070, 125060, 125058, 119200, 125144, 128110, 119184, 125132, 119176, 125126, 119172, 119170, 107424, 119256, 125166, 107408, 119244, 107400, 119238, 107396, 107394, 83872, 107480, 119278, 83856, 107468, 83848, 107462, 83844, 83842, 83928, 107502, 83916, 83910, 83950, 125008, 128044, 125e3, 128038, 124996, 124994, 118992, 125036, 118984, 125030, 118980, 118978, 106960, 119020, 106952, 119014, 106948, 106946, 82896, 106988, 82888, 106982, 82884, 82882, 82924, 82918, 124968, 128022, 124964, 124962, 118888, 124982, 118884, 118882, 106728, 118902, 106724, 106722, 82408, 106742, 82404, 82402, 124948, 124946, 118836, 118834, 106612, 106610, 124224, 127664, 129372, 124192, 127640, 129358, 124176, 127628, 124168, 127622, 124164, 124162, 117568, 124336, 127708, 117536, 124312, 127694, 117520, 124300, 117512, 124294, 117508, 117506, 104256, 117680, 124380, 104224, 117656, 124366, 104208, 117644, 104200, 117638, 104196, 104194, 77632, 104368, 117724, 77600, 104344, 117710, 77584, 104332, 77576, 104326, 77572, 77744, 104412, 77720, 104398, 77708, 77702, 77788, 77774, 128672, 129880, 93168, 128656, 129868, 92664, 128648, 129862, 92412, 128644, 128642, 124064, 127576, 129326, 126368, 124048, 129902, 126352, 128716, 127558, 126344, 124036, 126340, 124034, 126338, 117152, 124120, 127598, 121760, 117136, 124108, 121744, 126412, 124102, 121736, 117124, 121732, 117122, 121730, 103328, 117208, 124142, 112544, 103312, 117196, 112528, 121804, 117190, 112520, 103300, 112516, 103298, 112514, 75680, 103384, 117230, 94112, 75664, 103372, 94096, 112588, 103366, 94088, 75652, 94084, 75650, 75736, 103406, 94168, 75724, 94156, 75718, 94150, 75758, 128592, 129836, 91640, 128584, 129830, 91388, 128580, 91262, 128578, 123984, 127532, 126160, 123976, 127526, 126152, 128614, 126148, 123970, 126146, 116944, 124012, 121296, 116936, 124006, 121288, 126182, 121284, 116930, 121282, 102864, 116972, 111568, 102856, 116966, 111560, 121318, 111556, 102850, 111554, 74704, 102892, 92112, 74696, 102886, 92104, 111590, 92100, 74690, 92098, 74732, 92140, 74726, 92134, 128552, 129814, 90876, 128548, 90750, 128546, 123944, 127510, 126056, 128566, 126052, 123938, 126050, 116840, 123958, 121064, 116836, 121060, 116834, 121058, 102632, 116854, 111080, 121078, 111076, 102626, 111074, 74216, 102646, 91112, 74212, 91108, 74210, 91106, 74230, 91126, 128532, 90494, 128530, 123924, 126004, 123922, 126002, 116788, 120948, 116786, 120946, 102516, 110836, 102514, 110834, 73972, 90612, 73970, 90610, 128522, 123914, 125978, 116762, 120890, 102458, 110714, 123552, 127320, 129198, 123536, 127308, 123528, 127302, 123524, 123522, 116128, 123608, 127342, 116112, 123596, 116104, 123590, 116100, 116098, 101280, 116184, 123630, 101264, 116172, 101256, 116166, 101252, 101250, 71584, 101336, 116206, 71568, 101324, 71560, 101318, 71556, 71554, 71640, 101358, 71628, 71622, 71662, 127824, 129452, 79352, 127816, 129446, 79100, 127812, 78974, 127810, 123472, 127276, 124624, 123464, 127270, 124616, 127846, 124612, 123458, 124610, 115920, 123500, 118224, 115912, 123494, 118216, 124646, 118212, 115906, 118210, 100816, 115948, 105424, 100808, 115942, 105416, 118246, 105412, 100802, 105410, 70608, 100844, 79824, 70600, 100838, 79816, 105446, 79812, 70594, 79810, 70636, 79852, 70630, 79846, 129960, 95728, 113404, 129956, 95480, 113278, 129954, 95356, 95294, 127784, 129430, 78588, 128872, 129974, 95996, 78462, 128868, 127778, 95870, 128866, 123432, 127254, 124520, 123428, 126696, 128886, 123426, 126692, 124514, 126690, 115816, 123446, 117992, 115812, 122344, 117988, 115810, 122340, 117986, 122338, 100584, 115830, 104936, 100580, 113640, 104932, 100578, 113636, 104930, 113634, 70120, 100598, 78824, 70116, 96232, 78820, 70114, 96228, 78818, 96226, 70134, 78838, 129940, 94968, 113022, 129938, 94844, 94782, 127764, 78206, 128820, 127762, 95102, 128818, 123412, 124468, 123410, 126580, 124466, 126578, 115764, 117876, 115762, 122100, 117874, 122098, 100468, 104692, 100466, 113140, 104690, 113138, 69876, 78324, 69874, 95220, 78322, 95218, 129930, 94588, 94526, 127754, 128794, 123402, 124442, 126522, 115738, 117818, 121978, 100410, 104570, 112890, 69754, 78074, 94714, 94398, 123216, 127148, 123208, 127142, 123204, 123202, 115408, 123244, 115400, 123238, 115396, 115394, 99792, 115436, 99784, 115430, 99780, 99778, 68560, 99820, 68552, 99814, 68548, 68546, 68588, 68582, 127400, 129238, 72444, 127396, 72318, 127394, 123176, 127126, 123752, 123172, 123748, 123170, 123746, 115304, 123190, 116456, 115300, 116452, 115298, 116450, 99560, 115318, 101864, 99556, 101860, 99554, 101858, 68072, 99574, 72680, 68068, 72676, 68066, 72674, 68086, 72694, 129492, 80632, 105854, 129490, 80508, 80446, 127380, 72062, 127924, 127378, 80766, 127922, 123156, 123700, 123154, 124788, 123698, 124786, 115252, 116340, 115250, 118516, 116338, 118514, 99444, 101620, 99442, 105972, 101618, 105970, 67828, 72180, 67826, 80884, 72178, 80882, 97008, 114044, 96888, 113982, 96828, 96798, 129482, 80252, 130010, 97148, 80190, 97086, 127370, 127898, 128954, 123146, 123674, 124730, 126842, 115226, 116282, 118394, 122618, 99386, 101498, 105722, 114170, 67706, 71930, 80378, 96632, 113854, 96572, 96542, 80062, 96702, 96444, 96414, 96350, 123048, 123044, 123042, 115048, 123062, 115044, 115042, 99048, 115062, 99044, 99042, 67048, 99062, 67044, 67042, 67062, 127188, 68990, 127186, 123028, 123316, 123026, 123314, 114996, 115572, 114994, 115570, 98932, 100084, 98930, 100082, 66804, 69108, 66802, 69106, 129258, 73084, 73022, 127178, 127450, 123018, 123290, 123834, 114970, 115514, 116602, 98874, 99962, 102138, 66682, 68858, 73210, 81272, 106174, 81212, 81182, 72894, 81342, 97648, 114364, 97592, 114334, 97564, 97550, 81084, 97724, 81054, 97694, 97464, 114270, 97436, 97422, 80990, 97502, 97372, 97358, 97326, 114868, 114866, 98676, 98674, 66292, 66290, 123098, 114842, 115130, 98618, 99194, 66170, 67322, 69310, 73404, 73374, 81592, 106334, 81564, 81550, 73310, 81630, 97968, 114524, 97944, 114510, 97932, 97926, 81500, 98012, 81486, 97998, 97880, 114478, 97868, 97862, 81454, 97902, 97836, 97830, 69470, 73564, 73550, 81752, 106414, 81740, 81734, 73518, 81774, 81708, 81702]), $a([109536, 120312, 86976, 109040, 120060, 86496, 108792, 119934, 86256, 108668, 86136, 129744, 89056, 110072, 129736, 88560, 109820, 129732, 88312, 109694, 129730, 88188, 128464, 129772, 89592, 128456, 129766, 89340, 128452, 89214, 128450, 125904, 128492, 125896, 128486, 125892, 125890, 120784, 125932, 120776, 125926, 120772, 120770, 110544, 120812, 110536, 120806, 110532, 84928, 108016, 119548, 84448, 107768, 119422, 84208, 107644, 84088, 107582, 84028, 129640, 85488, 108284, 129636, 85240, 108158, 129634, 85116, 85054, 128232, 129654, 85756, 128228, 85630, 128226, 125416, 128246, 125412, 125410, 119784, 125430, 119780, 119778, 108520, 119798, 108516, 108514, 83424, 107256, 119166, 83184, 107132, 83064, 107070, 83004, 82974, 129588, 83704, 107390, 129586, 83580, 83518, 128116, 83838, 128114, 125172, 125170, 119284, 119282, 107508, 107506, 82672, 106876, 82552, 106814, 82492, 82462, 129562, 82812, 82750, 128058, 125050, 119034, 82296, 106686, 82236, 82206, 82366, 82108, 82078, 76736, 103920, 117500, 76256, 103672, 117374, 76016, 103548, 75896, 103486, 75836, 129384, 77296, 104188, 129380, 77048, 104062, 129378, 76924, 76862, 127720, 129398, 77564, 127716, 77438, 127714, 124392, 127734, 124388, 124386, 117736, 124406, 117732, 117730, 104424, 117750, 104420, 104418, 112096, 121592, 126334, 92608, 111856, 121468, 92384, 111736, 121406, 92272, 111676, 92216, 111646, 92188, 75232, 103160, 117118, 93664, 74992, 103036, 93424, 112252, 102974, 93304, 74812, 93244, 74782, 93214, 129332, 75512, 103294, 129908, 129330, 93944, 75388, 129906, 93820, 75326, 93758, 127604, 75646, 128756, 127602, 94078, 128754, 124148, 126452, 124146, 126450, 117236, 121844, 117234, 121842, 103412, 103410, 91584, 111344, 121212, 91360, 111224, 121150, 91248, 111164, 91192, 111134, 91164, 91150, 74480, 102780, 91888, 74360, 102718, 91768, 111422, 91708, 74270, 91678, 129306, 74620, 129850, 92028, 74558, 91966, 127546, 128634, 124026, 126202, 116986, 121338, 102906, 90848, 110968, 121022, 90736, 110908, 90680, 110878, 90652, 90638, 74104, 102590, 91e3, 74044, 90940, 74014, 90910, 74174, 91070, 90480, 110780, 90424, 110750, 90396, 90382, 73916, 90556, 73886, 90526, 90296, 110686, 90268, 90254, 73822, 90334, 90204, 90190, 71136, 101112, 116094, 70896, 100988, 70776, 100926, 70716, 70686, 129204, 71416, 101246, 129202, 71292, 71230, 127348, 71550, 127346, 123636, 123634, 116212, 116210, 101364, 101362, 79296, 105200, 118140, 79072, 105080, 118078, 78960, 105020, 78904, 104990, 78876, 78862, 70384, 100732, 79600, 70264, 100670, 79480, 105278, 79420, 70174, 79390, 129178, 70524, 129466, 79740, 70462, 79678, 127290, 127866, 123514, 124666, 115962, 118266, 100858, 113376, 122232, 126654, 95424, 113264, 122172, 95328, 113208, 122142, 95280, 113180, 95256, 113166, 95244, 78560, 104824, 117950, 95968, 78448, 104764, 95856, 113468, 104734, 95800, 78364, 95772, 78350, 95758, 70008, 100542, 78712, 69948, 96120, 78652, 69918, 96060, 78622, 96030, 70078, 78782, 96190, 94912, 113008, 122044, 94816, 112952, 122014, 94768, 112924, 94744, 112910, 94732, 94726, 78192, 104636, 95088, 78136, 104606, 95032, 113054, 95004, 78094, 94990, 69820, 78268, 69790, 95164, 78238, 95134, 94560, 112824, 121950, 94512, 112796, 94488, 112782, 94476, 94470, 78008, 104542, 94648, 77980, 94620, 77966, 94606, 69726, 78046, 94686, 94384, 112732, 94360, 112718, 94348, 94342, 77916, 94428, 77902, 94414, 94296, 112686, 94284, 94278, 77870, 94318, 94252, 94246, 68336, 99708, 68216, 99646, 68156, 68126, 68476, 68414, 127162, 123258, 115450, 99834, 72416, 101752, 116414, 72304, 101692, 72248, 101662, 72220, 72206, 67960, 99518, 72568, 67900, 72508, 67870, 72478, 68030, 72638, 80576, 105840, 118460, 80480, 105784, 118430, 80432, 105756, 80408, 105742, 80396, 80390, 72048, 101564, 80752, 71992, 101534, 80696, 71964, 80668, 71950, 80654, 67772, 72124, 67742, 80828, 72094, 80798, 114016, 122552, 126814, 96832, 113968, 122524, 96800, 113944, 122510, 96784, 113932, 96776, 113926, 96772, 80224, 105656, 118366, 97120, 80176, 105628, 97072, 114076, 105614, 97048, 80140, 97036, 80134, 97030, 71864, 101470, 80312, 71836, 97208, 80284, 71822, 97180, 80270, 97166, 67678, 71902, 80350, 97246, 96576, 113840, 122460, 96544, 113816, 122446, 96528, 113804, 96520, 113798, 96516, 96514, 80048, 105564, 96688, 80024, 105550, 96664, 113870, 96652, 80006, 96646, 71772, 80092, 71758, 96732, 80078, 96718, 96416, 113752, 122414, 96400, 113740, 96392, 113734, 96388, 96386, 79960, 105518, 96472, 79948, 96460, 79942, 96454, 71726, 79982, 96494, 96336, 113708, 96328, 113702, 96324, 96322, 79916, 96364, 79910, 96358, 96296, 113686, 96292, 96290, 79894, 96310, 66936, 99006, 66876, 66846, 67006, 68976, 100028, 68920, 99998, 68892, 68878, 66748, 69052, 66718, 69022, 73056, 102072, 116574, 73008, 102044, 72984, 102030, 72972, 72966, 68792, 99934, 73144, 68764, 73116, 68750, 73102, 66654, 68830, 73182, 81216, 106160, 118620, 81184, 106136, 118606, 81168, 106124, 81160, 106118, 81156, 81154, 72880, 101980, 81328, 72856, 101966, 81304, 106190, 81292, 72838, 81286, 68700, 72924, 68686, 81372, 72910, 81358, 114336, 122712, 126894, 114320, 122700, 114312, 122694, 114308, 114306, 81056, 106072, 118574, 97696, 81040, 106060, 97680, 114380, 106054, 97672, 81028, 97668, 81026, 97666, 72792, 101934, 81112, 72780, 97752, 81100, 72774, 97740, 81094, 97734, 68654, 72814, 81134, 97774, 114256, 122668, 114248, 122662, 114244, 114242, 80976, 106028, 97488, 80968, 106022, 97480, 114278, 97476, 80962, 97474, 72748, 81004, 72742, 97516, 80998, 97510, 114216, 122646, 114212, 114210, 80936, 106006, 97384, 80932, 97380, 80930, 97378, 72726, 80950, 97398, 114196, 114194, 80916, 97332, 80914, 97330, 66236, 66206, 67256, 99166, 67228, 67214, 66142, 67294, 69296, 100188, 69272, 100174, 69260, 69254, 67164, 69340, 67150, 69326, 73376, 102232, 116654, 73360, 102220, 73352, 102214, 73348, 73346, 69208, 100142, 73432, 102254, 73420, 69190, 73414, 67118, 69230, 73454, 106320, 118700, 106312, 118694, 106308, 106306, 73296, 102188, 81616, 106348, 102182, 81608, 73284, 81604, 73282, 81602, 69164, 73324, 69158, 81644, 73318, 81638, 122792, 126934, 122788, 122786, 106280, 118678, 114536, 106276, 114532, 106274, 114530, 73256, 102166, 81512, 73252, 98024, 81508, 73250, 98020, 81506, 98018, 69142, 73270, 81526, 98038, 122772, 122770, 106260, 114484, 106258, 114482, 73236, 81460, 73234, 97908, 81458, 97906, 122762, 106250, 114458, 73226, 81434, 97850, 66396, 66382, 67416, 99246, 67404, 67398, 66350, 67438, 69456, 100268, 69448, 100262, 69444, 69442, 67372, 69484, 67366, 69478, 102312, 116694, 102308, 102306, 69416, 100246, 73576, 102326, 73572, 69410, 73570, 67350, 69430, 73590, 118740, 118738, 102292, 106420, 102290, 106418, 69396, 73524, 69394, 81780, 73522, 81778, 118730, 102282, 106394, 69386, 73498, 81722, 66476, 66470, 67496, 99286, 67492, 67490, 66454, 67510, 100308, 100306, 67476, 69556, 67474, 69554, 116714])]);
  $_.cwtobits = function() {
    var _Ge = $get($_.clusters, $k[--$j]);
    $_.v = $get(_Ge, $k[--$j]);
    $k[$j++] = Infinity;
    for (var _Gh = 0; _Gh < 17; _Gh++) {
      $k[$j++] = 0;
    }
    var _Gk = $cvrs($s(17), $_.v, 2);
    for (var _Gl = 0, _Gm = _Gk.length; _Gl < _Gm; _Gl++) {
      $k[$j++] = $get(_Gk, _Gl) - 48;
    }
    var _Go = $a();
    $k[$j++] = $geti(_Go, _Go.length - 17, 17);
  };
  if ($_.compact) {
    $_.rwid = 17 * $_.c + 17 + 17 + 1;
  } else {
    $_.rwid = 17 * $_.c + 17 + 17 + 17 + 18;
  }
  $_.pixs = $a($_.rwid * $_.r * $_.rowmult);
  for (var _Gz = 0, _Gy = $_.r - 1; _Gz <= _Gy; _Gz += 1) {
    $_.i = _Gz;
    if ($_.i % 3 == 0) {
      $_.lcw = ~~($_.i / 3) * 30 + ~~(($_.r - 1) / 3);
      $_.rcw = $f(~~($_.i / 3) * 30 + $_.c) - 1;
    }
    if ($_.i % 3 == 1) {
      $_.lcw = ~~($_.i / 3) * 30 + $_.eclevel * 3 + ($_.r - 1) % 3;
      $_.rcw = ~~($_.i / 3) * 30 + ~~(($_.r - 1) / 3);
    }
    if ($_.i % 3 == 2) {
      $_.lcw = $f(~~($_.i / 3) * 30 + $_.c) - 1;
      $_.rcw = ~~($_.i / 3) * 30 + $_.eclevel * 3 + ($_.r - 1) % 3;
    }
    $k[$j++] = Infinity;
    $k[$j++] = 1;
    $k[$j++] = 1;
    $k[$j++] = 1;
    $k[$j++] = 1;
    $k[$j++] = 1;
    $k[$j++] = 1;
    $k[$j++] = 1;
    $k[$j++] = 1;
    $k[$j++] = 0;
    $k[$j++] = 1;
    $k[$j++] = 0;
    $k[$j++] = 1;
    $k[$j++] = 0;
    $k[$j++] = 1;
    $k[$j++] = 0;
    $k[$j++] = 0;
    $k[$j++] = 0;
    $k[$j++] = $_.lcw;
    $k[$j++] = $_.i % 3;
    $_.cwtobits();
    $aload($k[--$j]);
    var _HO = $geti($_.cws, $_.c * $_.i, $_.c);
    for (var _HP = 0, _HQ = _HO.length; _HP < _HQ; _HP++) {
      $k[$j++] = $get(_HO, _HP);
      $k[$j++] = $_.i % 3;
      $_.cwtobits();
      $aload($k[--$j]);
    }
    if ($_.compact) {
      $k[$j++] = 1;
    } else {
      $k[$j++] = $_.rcw;
      $k[$j++] = $_.i % 3;
      $_.cwtobits();
      $aload($k[--$j]);
      $k[$j++] = 1;
      $k[$j++] = 1;
      $k[$j++] = 1;
      $k[$j++] = 1;
      $k[$j++] = 1;
      $k[$j++] = 1;
      $k[$j++] = 1;
      $k[$j++] = 0;
      $k[$j++] = 1;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 1;
      $k[$j++] = 0;
      $k[$j++] = 1;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 1;
    }
    var _HY = $a();
    $k[$j++] = _HY;
    for (var _Hb = 0, _Ha = $_.rowmult - 1; _Hb <= _Ha; _Hb += 1) {
      var _Hg = $k[$j - 1];
      $puti($_.pixs, (_Hb + $_.i * $_.rowmult) * $_.rwid, _Hg);
    }
    $j--;
  }
  var _Hp = /* @__PURE__ */ new Map([
    ["ren", "renmatrix"],
    ["pixs", $_.pixs],
    ["pixx", $_.rwid],
    ["pixy", $_.r * $_.rowmult],
    ["height", $_.r * $_.rowmult / 72],
    ["width", $_.rwid / 72],
    ["borderleft", 2],
    ["borderright", 2],
    ["bordertop", 2],
    ["borderbottom", 2],
    ["opt", $_.options]
  ]);
  $k[$j++] = _Hp;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_pdf417compact() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $put($_.options, "dontdraw", true);
  $put($_.options, "compact", true);
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_pdf417();
  var _6 = $k[--$j];
  $_[$k[--$j]] = _6;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_micropdf417() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.version = "unset";
  $_.columns = 0;
  $_.rows = 0;
  $_.rowmult = 2;
  $_.cca = false;
  $_.ccb = false;
  $_.raw = false;
  $_.parse = false;
  $_.parsefnc = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length == 0) {
    $k[$j++] = "bwipp.micropdf417emptyData#18631";
    $k[$j++] = "The data must not be empty";
    bwipp_raiseerror();
  }
  if ($_.rowmult <= 0) {
    $k[$j++] = "bwipp.micropdf417badRowMult#18635";
    $k[$j++] = "The row multiplier must be greater than zero";
    bwipp_raiseerror();
  }
  if ($_.cca && $_.ccb || ($_.cca && $_.raw || $_.ccb && $_.raw)) {
    $k[$j++] = "bwipp.micropdf417ccaAndCcb#18639";
    $k[$j++] = "Cannot combine cca, ccb and raw";
    bwipp_raiseerror();
  }
  if ($ne($_.version, "unset")) {
    $search($_.version, "x");
    if ($k[--$j]) {
      var _D = $k[--$j];
      $k[$j - 1] = _D;
      var _F = $k[$j - 1];
      var _G = $k[$j - 2];
      $k[$j++] = _G;
      $k[$j++] = _F;
      $astore($a(2));
      $forall($k[--$j], function() {
        var _J = $k[$j - 1];
        $k[$j++] = true;
        if (_J.length == 0) {
          $k[$j - 1] = false;
        }
        var _K = $k[--$j];
        var _L = $k[--$j];
        $k[$j++] = _K;
        $forall(_L, function() {
          var _M = $k[--$j];
          if (_M < 48 || _M > 57) {
            $k[$j - 1] = false;
          }
        });
        if (!$k[--$j]) {
          $k[$j++] = "bwipp.micropdf417BadVersionBadRowOrColumn#18653";
          $k[$j++] = "version must be formatted as RxC";
          bwipp_raiseerror();
        }
      });
      $_.rows = $cvi($k[--$j]);
      $_.columns = $cvi($k[--$j]);
    } else {
      $j--;
      $k[$j++] = "bwipp.micropdf417badVersionFormat#18659";
      $k[$j++] = "version must be formatted as RxC";
      bwipp_raiseerror();
    }
  }
  $_.T = 0;
  $_.N = 1;
  $_.B = 2;
  $_.A = 0;
  $_.L = 1;
  $_.M = 2;
  $_.P = 3;
  $_.tl = -1;
  $_.nl = -2;
  $_.bl = -3;
  $_.bl6 = -4;
  $_.bs = -5;
  $_.al = -6;
  $_.ll = -7;
  $_.ml = -8;
  $_.pl = -9;
  $_.as = -10;
  $_.ps = -11;
  $_.m05 = -12;
  $_.m06 = -13;
  $_.charmaps = $a([$a(["A", "a", "0", ";"]), $a(["B", "b", "1", "<"]), $a(["C", "c", "2", ">"]), $a(["D", "d", "3", "@"]), $a(["E", "e", "4", "["]), $a(["F", "f", "5", 92]), $a(["G", "g", "6", "]"]), $a(["H", "h", "7", "_"]), $a(["I", "i", "8", "`"]), $a(["J", "j", "9", "~"]), $a(["K", "k", "&", "!"]), $a(["L", "l", 13, 13]), $a(["M", "m", 9, 9]), $a(["N", "n", ",", ","]), $a(["O", "o", ":", ":"]), $a(["P", "p", "#", 10]), $a(["Q", "q", "-", "-"]), $a(["R", "r", ".", "."]), $a(["S", "s", "$", "$"]), $a(["T", "t", "/", "/"]), $a(["U", "u", "+", '"']), $a(["V", "v", "%", "|"]), $a(["W", "w", "*", "*"]), $a(["X", "x", "=", 40]), $a(["Y", "y", "^", 41]), $a(["Z", "z", $_.pl, "?"]), $a([" ", " ", " ", "{"]), $a([$_.ll, $_.as, $_.ll, "}"]), $a([$_.ml, $_.ml, $_.al, "'"]), $a([$_.ps, $_.ps, $_.ps, $_.al])]);
  $_.charvals = $a([/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map()]);
  $_.alltext = /* @__PURE__ */ new Map();
  for (var _19 = 0, _18 = $_.charmaps.length - 1; _19 <= _18; _19 += 1) {
    $_.i = _19;
    $_.encs = $get($_.charmaps, $_.i);
    for (var _1D = 0; _1D <= 3; _1D += 1) {
      $_.j = _1D;
      var _1G = $get($_.encs, $_.j);
      $k[$j++] = _1G;
      if ($eq($type(_1G), "stringtype")) {
        var _1J = $get($k[--$j], 0);
        $k[$j++] = _1J;
      }
      var _1K = $k[--$j];
      $put($get($_.charvals, $_.j), _1K, $_.i);
      $put($_.alltext, _1K, -1);
    }
  }
  $_.e = 1e4;
  $_.latlen = $a([$a([0, 1, 1, 2]), $a([2, 0, 1, 2]), $a([1, 1, 0, 1]), $a([1, 2, 2, 0])]);
  $_.latseq = $a([$a([$a([]), $a([$_.ll]), $a([$_.ml]), $a([$_.ml, $_.pl])]), $a([$a([$_.ml, $_.al]), $a([]), $a([$_.ml]), $a([$_.ml, $_.pl])]), $a([$a([$_.al]), $a([$_.ll]), $a([]), $a([$_.pl])]), $a([$a([$_.al]), $a([$_.al, $_.ll]), $a([$_.al, $_.ml]), $a([])])]);
  $_.shftlen = $a([$a([$_.e, $_.e, $_.e, 1]), $a([1, $_.e, $_.e, 1]), $a([$_.e, $_.e, $_.e, 1]), $a([$_.e, $_.e, $_.e, $_.e])]);
  if ($_.raw || $_.cca) {
    $_.datcws = $a($_.barcode.length);
    $_.i = 0;
    $_.j = 0;
    for (; ; ) {
      if ($_.i >= $_.barcode.length - 3) {
        break;
      }
      if ($get($_.barcode, $_.i) != 94) {
        break;
      }
      var _2a = $geti($_.barcode, $_.i + 1, 3);
      $k[$j++] = _2a;
      $k[$j++] = false;
      for (var _2b = 0, _2c = _2a.length; _2b < _2c; _2b++) {
        var _2d = $get(_2a, _2b);
        if (_2d < 48 || _2d > 57) {
          $k[$j - 1] = true;
        }
      }
      if ($k[--$j]) {
        $j--;
        break;
      }
      $_.cw = $cvi($k[--$j]);
      $put($_.datcws, $_.j, $_.cw);
      $_.i = $_.i + 4;
      $_.j = $_.j + 1;
    }
    if ($_.i != $_.barcode.length) {
      $k[$j++] = "bwipp.micropdf417badCcaRawFormat#18771";
      $k[$j++] = "cca and raw data must be formatted as ^NNN";
      bwipp_raiseerror();
    }
    $_.datcws = $geti($_.datcws, 0, $_.j);
  }
  $_.encb = function() {
    $_.in = $k[--$j];
    $_.inlen = $_.in.length;
    $_.out = $a(~~($_.inlen / 6) * 5 + $_.inlen % 6);
    for (var _2x = 0, _2w = ~~($_.inlen / 6) - 1; _2x <= _2w; _2x += 1) {
      $_.k = _2x;
      $k[$j++] = Infinity;
      $aload($geti($_.in, $_.k * 6, 3));
      $_.msbs = $a();
      $k[$j++] = Infinity;
      $aload($_.msbs);
      var _33 = $k[--$j];
      var _34 = $k[--$j];
      var _35 = $k[--$j];
      $k[$j++] = $f(_33 + _34 * 256 + _35 * 65536);
      for (var _36 = 0; _36 < 3; _36++) {
        var _37 = $k[--$j];
        $k[$j++] = _37 % 900;
        $k[$j++] = ~~(_37 / 900);
      }
      $_.mscs = $a();
      $k[$j++] = Infinity;
      $aload($geti($_.in, $_.k * 6 + 3, 3));
      $_.lsbs = $a();
      $k[$j++] = Infinity;
      $aload($_.lsbs);
      var _3E = $k[--$j];
      var _3F = $k[--$j];
      var _3G = $k[--$j];
      $k[$j++] = $f(_3E + _3F * 256 + _3G * 65536);
      for (var _3H = 0; _3H < 3; _3H++) {
        var _3I = $k[--$j];
        $k[$j++] = _3I % 900;
        $k[$j++] = ~~(_3I / 900);
      }
      $_.lscs = $a();
      var _3L = $get($_.lscs, 0);
      var _3N = $get($_.mscs, 0);
      $put($_.out, $_.k * 5 + 4, $f(_3L + _3N * 316) % 900);
      var _3R = $get($_.lscs, 1);
      var _3T = $get($_.mscs, 0);
      var _3V = $get($_.mscs, 1);
      $put($_.out, $_.k * 5 + 3, $f(~~((_3L + _3N * 316) / 900) + _3R + _3T * 641 + _3V * 316) % 900);
      var _3Z = $get($_.lscs, 2);
      var _3b = $get($_.mscs, 0);
      var _3d = $get($_.mscs, 1);
      var _3f = $get($_.mscs, 2);
      $put($_.out, $_.k * 5 + 2, $f(~~((~~((_3L + _3N * 316) / 900) + _3R + _3T * 641 + _3V * 316) / 900) + _3Z + _3b * 20 + _3d * 641 + _3f * 316) % 900);
      var _3j = $get($_.lscs, 3);
      var _3l = $get($_.mscs, 1);
      var _3n = $get($_.mscs, 2);
      $put($_.out, $_.k * 5 + 1, $f(~~((~~((~~((_3L + _3N * 316) / 900) + _3R + _3T * 641 + _3V * 316) / 900) + _3Z + _3b * 20 + _3d * 641 + _3f * 316) / 900) + _3j + _3l * 20 + _3n * 641) % 900);
      $put($_.out, $_.k * 5, $f(~~((~~((~~((~~((_3L + _3N * 316) / 900) + _3R + _3T * 641 + _3V * 316) / 900) + _3Z + _3b * 20 + _3d * 641 + _3f * 316) / 900) + _3j + _3l * 20 + _3n * 641) / 900) + $get($_.mscs, 2) * 20) % 900);
    }
    $_.rem = $_.inlen % 6;
    if ($_.rem != 0) {
      $k[$j++] = $_.out;
      $k[$j++] = $_.out.length - $_.rem;
      $k[$j++] = Infinity;
      $aload($geti($_.in, $_.inlen - $_.rem, $_.rem));
      var _44 = $a();
      var _45 = $k[--$j];
      $puti($k[--$j], _45, _44);
    }
    $k[$j++] = $_.out;
  };
  if ($_.ccb) {
    $_.barlen = $_.barcode.length;
    $_.datcws = $a(~~($_.barlen / 6) * 5 + $_.barlen % 6 + 2);
    $put($_.datcws, 0, 920);
    var _4G = $_.barlen % 6 == 0 ? 924 : 901;
    $put($_.datcws, 1, _4G);
    $k[$j++] = $_.datcws;
    $k[$j++] = 2;
    $k[$j++] = Infinity;
    $forall($_.barcode);
    var _4J = $a();
    $k[$j++] = _4J;
    $_.encb();
    var _4K = $k[--$j];
    var _4L = $k[--$j];
    $puti($k[--$j], _4L, _4K);
  }
  if (!$_.raw && !$_.cca && !$_.ccb) {
    var _4S = /* @__PURE__ */ new Map([
      ["parse", $_.parse],
      ["parsefnc", $_.parsefnc],
      ["eci", true]
    ]);
    $_.fncvals = _4S;
    $k[$j++] = "msg";
    $k[$j++] = $_.barcode;
    $k[$j++] = $_.fncvals;
    bwipp_parseinput();
    var _4V = $k[--$j];
    $_[$k[--$j]] = _4V;
    $_.msglen = $_.msg.length;
    if ($_.msglen >= 9) {
      $aload($geti($_.msg, 0, 7));
      var _4b = $k[--$j];
      $k[$j - 1] = _4b == 29;
      var _4d = $k[--$j];
      var _4e = $k[--$j];
      var _4f = $k[--$j];
      var _4g = $k[--$j];
      var _4h = $k[--$j];
      var _4i = $k[--$j];
      if (_4d && _4e == 48 && _4f == 30 && _4g == 62 && _4h == 41 && _4i == 91) {
        $aload($geti($_.msg, $_.msglen - 2, 2));
        var _4m = $k[--$j];
        var _4n = $k[--$j];
        if (_4m == 4 && _4n == 30) {
          if ($get($_.msg, 5) == 53) {
            $k[$j++] = Infinity;
            $k[$j++] = $_.m05;
            $aload($geti($_.msg, 7, $_.msg.length - 9));
            $_.msg = $a();
          } else {
            if ($get($_.msg, 5) == 54) {
              $k[$j++] = Infinity;
              $k[$j++] = $_.m06;
              $aload($geti($_.msg, 7, $_.msg.length - 9));
              $_.msg = $a();
            }
          }
        }
      }
    }
    $_.msglen = $_.msg.length;
    $k[$j++] = Infinity;
    for (var _54 = 0, _55 = $_.msglen; _54 < _55; _54++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $_.numdigits = $a();
    $k[$j++] = Infinity;
    for (var _58 = 0, _59 = $_.msglen; _58 < _59; _58++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $_.numtext = $a();
    $k[$j++] = Infinity;
    for (var _5C = 0, _5D = $_.msglen; _5C < _5D; _5C++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $_.numbytes = $a();
    $k[$j++] = Infinity;
    for (var _5G = 0, _5H = $_.msglen; _5G < _5H; _5G++) {
      $k[$j++] = 0;
    }
    $_.iseci = $a();
    for (var _5K = $_.msglen - 1; _5K >= 0; _5K -= 1) {
      $_.i = _5K;
      var _5N = $get($_.msg, $_.i);
      if (_5N >= 48 && _5N <= 57) {
        $put($_.numdigits, $_.i, $get($_.numdigits, $_.i + 1) + 1);
      }
      var _5X = $get($_.alltext, $get($_.msg, $_.i)) !== void 0;
      if (_5X && $get($_.numdigits, $_.i) < 13) {
        $put($_.numtext, $_.i, $get($_.numtext, $_.i + 1) + 1);
      }
      if ($get($_.msg, $_.i) >= 0 && $get($_.numtext, $_.i) < 5 && $get($_.numdigits, $_.i) < 13) {
        $put($_.numbytes, $_.i, $get($_.numbytes, $_.i + 1) + 1);
      }
      $put($_.iseci, $_.i, $get($_.msg, $_.i) <= -1e6);
    }
    $_.numdigits = $geti($_.numdigits, 0, $_.msglen);
    $_.numtext = $geti($_.numtext, 0, $_.msglen);
    $_.numbytes = $geti($_.numbytes, 0, $_.msglen);
    $_.seq = $a([]);
    $_.seqlen = 0;
    $_.state = $_.B;
    $_.p = 0;
    for (; ; ) {
      if ($_.p == $_.msglen) {
        break;
      }
      var _6F = $get($_.msg, $_.p);
      if ($_.p == 0 && (_6F == $_.m05 || _6F == $_.m06)) {
        $k[$j++] = Infinity;
        $aload($_.seq);
        var _6N = $get($_.msg, $_.p) == $_.m05 ? $_.m05 : $_.m06;
        $k[$j++] = _6N;
        $_.seq = $a();
        $_.p = $_.p + 1;
        $_.seqlen = $_.seqlen + 1;
      } else {
        if ($get($_.iseci, $_.p)) {
          $_.eci = $get($_.msg, $_.p);
          $k[$j++] = Infinity;
          $aload($_.seq);
          $k[$j++] = $a([$_.eci]);
          $_.seq = $a();
          $_.p = $_.p + 1;
          $k[$j++] = "seqlen";
          $k[$j++] = $_.seqlen;
          if ($_.eci <= -1810900) {
            $k[$j++] = 2;
          } else {
            var _6f = $_.eci <= -1000900 ? 3 : 2;
            $k[$j++] = _6f;
          }
          var _6g = $k[--$j];
          var _6h = $k[--$j];
          $_[$k[--$j]] = $f(_6h + _6g);
        } else {
          $_.n = $get($_.numdigits, $_.p);
          if ($_.n >= 13 || $_.n == $_.msglen && $_.n >= 8) {
            $k[$j++] = Infinity;
            $aload($_.seq);
            $k[$j++] = $_.nl;
            $k[$j++] = Infinity;
            $aload($geti($_.msg, $_.p, $_.n));
            var _6w = $a();
            $k[$j++] = _6w;
            $_.seq = $a();
            $_.state = $_.N;
            $_.p = $f($_.p + $_.n);
            $_.seqlen = $f($_.seqlen + 1 + $_.n);
          } else {
            $_.t = $get($_.numtext, $_.p);
            if ($_.t >= 5) {
              $k[$j++] = Infinity;
              $aload($_.seq);
              if ($_.state != $_.T) {
                $k[$j++] = $_.tl;
              }
              $k[$j++] = Infinity;
              $aload($geti($_.msg, $_.p, $_.t));
              var _7F = $a();
              $k[$j++] = _7F;
              $_.seq = $a();
              $_.state = $_.T;
              $_.p = $f($_.p + $_.t);
              $_.seqlen = $f($_.seqlen + 1 + $_.t);
            } else {
              $_.b = $get($_.numbytes, $_.p);
              if ($_.b == 1 && $_.state == $_.T) {
                $k[$j++] = Infinity;
                $aload($_.seq);
                $k[$j++] = $_.bs;
                $k[$j++] = $a([$get($_.msg, $_.p)]);
                $_.seq = $a();
                $_.p = $f($_.p + $_.b);
                $_.seqlen = $_.seqlen + 2;
              } else {
                $k[$j++] = Infinity;
                $aload($_.seq);
                var _7e = $_.b % 6 != 0 ? $_.bl : $_.bl6;
                $k[$j++] = _7e;
                $k[$j++] = Infinity;
                $aload($geti($_.msg, $_.p, $_.b));
                var _7j = $a();
                $k[$j++] = _7j;
                $_.seq = $a();
                $_.state = $_.B;
                $_.p = $f($_.p + $_.b);
                $_.seqlen = $f($_.seqlen + 1 + $_.b);
              }
            }
          }
        }
      }
    }
    $k[$j++] = Infinity;
    $k[$j++] = $_.tl;
    $k[$j++] = 900;
    $k[$j++] = $_.bl;
    $k[$j++] = 901;
    $k[$j++] = $_.bl6;
    $k[$j++] = 924;
    $k[$j++] = $_.nl;
    $k[$j++] = 902;
    $k[$j++] = $_.bs;
    $k[$j++] = 913;
    $k[$j++] = $_.m05;
    $k[$j++] = 916;
    $k[$j++] = $_.m06;
    $k[$j++] = 917;
    $_.latchcws = $d();
    $_.enca = function() {
      var _82 = $get($get($_.charvals, $_.A), $k[--$j]);
      $k[$j++] = _82;
    };
    $_.encl = function() {
      var _87 = $get($get($_.charvals, $_.L), $k[--$j]);
      $k[$j++] = _87;
    };
    $_.encm = function() {
      var _8C = $get($get($_.charvals, $_.M), $k[--$j]);
      $k[$j++] = _8C;
    };
    $_.encp = function() {
      var _8H = $get($get($_.charvals, $_.P), $k[--$j]);
      $k[$j++] = _8H;
    };
    $_.textencfuncs = $a(["enca", "encl", "encm", "encp"]);
    $_.addtotext = function() {
      $put($_.text, $_.l, $k[--$j]);
      $_.l = $_.l + 1;
    };
    $_.enct = function() {
      $_.in = $k[--$j];
      $_.curlen = $a([$_.e, $_.e, $_.e, $_.e]);
      $put($_.curlen, $_.submode, 0);
      $_.curseq = $a([$a([]), $a([]), $a([]), $a([])]);
      $forall($_.in, function() {
        $_.char = $k[--$j];
        for (; ; ) {
          $_.imp = false;
          var _8g = $a([$_.A, $_.L, $_.M, $_.P]);
          for (var _8h = 0, _8i = _8g.length; _8h < _8i; _8h++) {
            $_.x = $get(_8g, _8h);
            var _8o = $a([$_.A, $_.L, $_.M, $_.P]);
            for (var _8p = 0, _8q = _8o.length; _8p < _8q; _8p++) {
              $_.y = $get(_8o, _8p);
              $_.cost = $f($get($_.curlen, $_.x) + $get($get($_.latlen, $_.x), $_.y));
              if ($_.cost < $get($_.curlen, $_.y)) {
                $put($_.curlen, $_.y, $_.cost);
                $k[$j++] = $_.curseq;
                $k[$j++] = $_.y;
                $k[$j++] = Infinity;
                $aload($get($_.curseq, $_.x));
                $aload($get($get($_.latseq, $_.x), $_.y));
                var _9H = $a();
                var _9I = $k[--$j];
                $put($k[--$j], _9I, _9H);
                $_.imp = true;
              }
            }
          }
          if (!$_.imp) {
            break;
          }
        }
        $_.nxtlen = $a([$_.e, $_.e, $_.e, $_.e]);
        $_.nxtseq = $a(4);
        var _9V = $a([$_.A, $_.L, $_.M, $_.P]);
        for (var _9W = 0, _9X = _9V.length; _9W < _9X; _9W++) {
          $_.x = $get(_9V, _9W);
          for (; ; ) {
            var _9d = $get($get($_.charvals, $_.x), $_.char) !== void 0;
            if (!_9d) {
              break;
            }
            $_.cost = $get($_.curlen, $_.x) + 1;
            if ($_.cost < $get($_.nxtlen, $_.x)) {
              $put($_.nxtlen, $_.x, $_.cost);
              $k[$j++] = $_.nxtseq;
              $k[$j++] = $_.x;
              $k[$j++] = Infinity;
              $aload($get($_.curseq, $_.x));
              $k[$j++] = $_.char;
              var _9u = $a();
              var _9v = $k[--$j];
              $put($k[--$j], _9v, _9u);
            }
            var _A1 = $a([$_.A, $_.L, $_.M, $_.P]);
            for (var _A2 = 0, _A3 = _A1.length; _A2 < _A3; _A2++) {
              $_.y = $get(_A1, _A2);
              if ($ne($_.x, $_.y)) {
                $_.cost = $f($get($_.curlen, $_.y) + $get($get($_.shftlen, $_.y), $_.x)) + 1;
                if ($_.cost < $get($_.nxtlen, $_.y)) {
                  $put($_.nxtlen, $_.y, $_.cost);
                  $k[$j++] = $_.nxtseq;
                  $k[$j++] = $_.y;
                  $k[$j++] = Infinity;
                  $aload($get($_.curseq, $_.y));
                  var _AT = $_.x == $_.A ? $_.as : $_.ps;
                  $k[$j++] = _AT;
                  $k[$j++] = $_.char;
                  var _AV = $a();
                  var _AW = $k[--$j];
                  $put($k[--$j], _AW, _AV);
                }
              }
            }
            break;
          }
        }
        $_.curlen = $_.nxtlen;
        $_.curseq = $_.nxtseq;
      });
      $_.minseq = $_.e;
      var _Af = $a([$_.A, $_.L, $_.M, $_.P]);
      for (var _Ag = 0, _Ah = _Af.length; _Ag < _Ah; _Ag++) {
        $_.k = $get(_Af, _Ag);
        if ($get($_.curlen, $_.k) < $_.minseq) {
          $_.minseq = $get($_.curlen, $_.k);
          $_.txtseq = $get($_.curseq, $_.k);
        }
      }
      $_.text = $a($_.minseq);
      $_.k = 0;
      $_.l = 0;
      for (; ; ) {
        if ($_.k >= $_.txtseq.length) {
          break;
        }
        $_.char = $get($_.txtseq, $_.k);
        $k[$j++] = $_.char;
        if ($_[$get($_.textencfuncs, $_.submode)]() === true) {
          break;
        }
        $_.addtotext();
        $_.k = $_.k + 1;
        if ($_.char == $_.as || $_.char == $_.ps) {
          $k[$j++] = $get($_.txtseq, $_.k);
          if ($_.char == $_.as) {
            $_.enca();
          } else {
            $_.encp();
          }
          $_.addtotext();
          $_.k = $_.k + 1;
        }
        if ($_.char == $_.al) {
          $_.submode = $_.A;
        }
        if ($_.char == $_.ll) {
          $_.submode = $_.L;
        }
        if ($_.char == $_.ml) {
          $_.submode = $_.M;
        }
        if ($_.char == $_.pl) {
          $_.submode = $_.P;
        }
      }
      if ($_.text.length % 2 == 1) {
        if ($_.submode == $_.P) {
          $k[$j++] = "pad";
          $k[$j++] = $_.al;
          $_.encp();
          var _BW = $k[--$j];
          $_[$k[--$j]] = _BW;
          $_.submode = $_.A;
        } else {
          $_.nextecitext = false;
          for (var _Bc = $_.i + 1, _Bb = $_.seq.length - 1; _Bc <= _Bb; _Bc += 1) {
            $_.ti = _Bc;
            if ($ne($type($get($_.seq, $_.ti)), "arraytype")) {
              $_.nextecitext = false;
              break;
            }
            if ($get($get($_.seq, $_.ti), 0) > -1e6) {
              break;
            }
            $_.nextecitext = true;
          }
          if ($_.nextecitext) {
            if ($_.submode == $_.A) {
              var _Bv = $get($get($_.charvals, $_.L), $get($get($_.seq, $_.ti), 0)) !== void 0;
              if (_Bv) {
                $k[$j++] = "pad";
                $k[$j++] = $_.ll;
                $_.enca();
                var _Bx = $k[--$j];
                $_[$k[--$j]] = _Bx;
                $_.submode = $_.L;
              } else {
                $k[$j++] = "pad";
                $k[$j++] = $_.ml;
                $_.enca();
                var _C1 = $k[--$j];
                $_[$k[--$j]] = _C1;
                $_.submode = $_.M;
              }
            } else {
              if ($_.submode == $_.M) {
                var _CD = $get($get($_.charvals, $_.L), $get($get($_.seq, $_.ti), 0)) !== void 0;
                if (_CD) {
                  $k[$j++] = "pad";
                  $k[$j++] = $_.ll;
                  $_.encm();
                  var _CF = $k[--$j];
                  $_[$k[--$j]] = _CF;
                  $_.submode = $_.L;
                } else {
                  var _CP = $get($get($_.charvals, $_.P), $get($get($_.seq, $_.ti), 0)) !== void 0;
                  if (_CP) {
                    $k[$j++] = "pad";
                    $k[$j++] = $_.pl;
                    $_.encm();
                    var _CR = $k[--$j];
                    $_[$k[--$j]] = _CR;
                    $_.submode = $_.P;
                  } else {
                    $k[$j++] = "pad";
                    $k[$j++] = $_.al;
                    $_.encm();
                    var _CV = $k[--$j];
                    $_[$k[--$j]] = _CV;
                    $_.submode = $_.A;
                  }
                }
              } else {
                $k[$j++] = "pad";
                $k[$j++] = $_.ml;
                $_.encl();
                var _CZ = $k[--$j];
                $_[$k[--$j]] = _CZ;
                $_.submode = $_.M;
              }
            }
          } else {
            $k[$j++] = "pad";
            $k[$j++] = $_.ps;
            if ($_[$get($_.textencfuncs, $_.submode)]() === true) {
              return true;
            }
            var _Ch = $k[--$j];
            $_[$k[--$j]] = _Ch;
          }
        }
        $k[$j++] = Infinity;
        $aload($_.text);
        $k[$j++] = $_.pad;
        $_.text = $a();
      }
      $_.out = $a(~~($_.text.length / 2));
      for (var _Cq = 0, _Cp = $_.out.length - 1; _Cq <= _Cp; _Cq += 1) {
        $_.k = _Cq;
        $put($_.out, $_.k, $f($get($_.text, $_.k * 2) * 30 + $get($_.text, $_.k * 2 + 1)));
      }
      $k[$j++] = $_.out;
    };
    $_.encn = function() {
      $_.in = $k[--$j];
      $_.out = $a([]);
      for (var _D4 = 0, _D3 = $_.in.length - 1; _D4 <= _D3; _D4 += 44) {
        $_.k = _D4;
        $k[$j++] = Infinity;
        var _D9 = $_.in.length - $_.k;
        $k[$j++] = 1;
        $k[$j++] = $_.in;
        $k[$j++] = $_.k;
        $k[$j++] = _D9;
        if (_D9 > 44) {
          $k[$j - 1] = 44;
        }
        var _DA = $k[--$j];
        var _DB = $k[--$j];
        var _DD = $geti($k[--$j], _DB, _DA);
        for (var _DE = 0, _DF = _DD.length; _DE < _DF; _DE++) {
          $k[$j++] = $get(_DD, _DE) - 48;
        }
        $_.gmod = $a();
        $_.cwn = $a([]);
        for (; ; ) {
          $_.dv = 900;
          $_.gmul = $a([]);
          $_.val = 0;
          for (; ; ) {
            if ($_.gmod.length == 0) {
              break;
            }
            $_.val = $f($_.val * 10 + $get($_.gmod, 0));
            $_.gmod = $geti($_.gmod, 1, $_.gmod.length - 1);
            if ($_.val < $_.dv) {
              if ($_.gmul.length != 0) {
                $k[$j++] = Infinity;
                $aload($_.gmul);
                $k[$j++] = 0;
                $_.gmul = $a();
              }
            } else {
              $k[$j++] = Infinity;
              $aload($_.gmul);
              $k[$j++] = ~~($_.val / $_.dv);
              $_.gmul = $a();
            }
            $_.val = $_.val % $_.dv;
          }
          $_.dv = $_.val;
          $k[$j++] = Infinity;
          $k[$j++] = $_.dv;
          $aload($_.cwn);
          $_.cwn = $a();
          $_.gmod = $_.gmul;
          if ($_.gmul.length == 0) {
            break;
          }
        }
        $k[$j++] = Infinity;
        $aload($_.out);
        $aload($_.cwn);
        $_.out = $a();
      }
      $k[$j++] = $_.out;
    };
    $_.ence = function() {
      var _Do = -$get($k[--$j], 0) - 1e6;
      $k[$j++] = _Do;
      if (_Do <= 899) {
        var _Dp = $k[--$j];
        $k[$j++] = 927;
        $k[$j++] = _Dp;
        $astore($a(2));
      } else {
        var _Dr = $k[$j - 1];
        if (_Dr <= 810899) {
          var _Ds = $k[--$j];
          $k[$j++] = 926;
          $k[$j++] = ~~(_Ds / 900) - 1;
          $k[$j++] = _Ds % 900;
          $astore($a(3));
        } else {
          var _Du = $k[$j - 1];
          if (_Du <= 811799) {
            var _Dv = $k[--$j];
            $k[$j++] = 925;
            $k[$j++] = _Dv - 810900;
            $astore($a(2));
          } else {
            $k[$j++] = "bwipp.pdf417badECI#19167";
            $k[$j++] = "PDF417 supports ECIs 000000 to 811799";
            bwipp_raiseerror();
          }
        }
      }
    };
    $_.encfuncs = $a(["enct", "encn", "encb"]);
    $_.addtocws = function() {
      var _Dy = $k[--$j];
      $puti($_.datcws, $_.j, _Dy);
      $_.j = _Dy.length + $_.j;
    };
    $_.datcws = $a($_.seqlen);
    $_.i = 0;
    $_.j = 0;
    for (; ; ) {
      if ($_.i >= $_.seq.length) {
        break;
      }
      $_.chars = $get($_.seq, $_.i);
      if ($eq($type($_.chars), "arraytype")) {
        if ($get($_.chars, 0) <= -1e6) {
          $k[$j++] = $_.chars;
          $_.ence();
          $_.addtocws();
        } else {
          $k[$j++] = $_.chars;
          if ($_[$get($_.encfuncs, $_.state)]() === true) {
            break;
          }
          $_.addtocws();
        }
      } else {
        $k[$j++] = $a([$get($_.latchcws, $_.chars)]);
        $_.addtocws();
        if ($_.chars == $_.tl) {
          $_.state = $_.T;
          $_.submode = $_.A;
        }
        if ($_.chars == $_.nl) {
          $_.state = $_.N;
        }
        if ($_.chars == $_.bl || $_.chars == $_.bl6) {
          $_.state = $_.B;
        }
        if ($_.chars == $_.bs) {
          $_.i = $_.i + 1;
          $k[$j++] = $get($_.seq, $_.i);
          $_.encb();
          $_.addtocws();
        }
        if ($_.chars == $_.m05) {
          if ($_.i + 1 < $_.seq.length) {
            if ($get($_.seq, $_.i + 1) == $_.nl) {
              $_.i = $_.i + 1;
            }
          }
          $_.state = $_.N;
        }
        if ($_.chars == $_.m06) {
          if ($_.i + 1 < $_.seq.length) {
            if ($get($_.seq, $_.i + 1) == $_.tl) {
              $_.i = $_.i + 1;
            }
          }
          $_.state = $_.T;
          $_.submode = $_.M;
        }
      }
      $_.i = $_.i + 1;
    }
    $_.datcws = $geti($_.datcws, 0, $_.j);
  }
  $_.ccametrics = $a([$a([2, 5, 4, 39, 0, 19]), $a([2, 6, 4, 1, 0, 33]), $a([2, 7, 5, 32, 0, 12]), $a([2, 8, 5, 8, 0, 40]), $a([2, 9, 6, 14, 0, 46]), $a([2, 10, 6, 43, 0, 23]), $a([2, 12, 7, 20, 0, 52]), $a([3, 4, 4, 11, 43, 23]), $a([3, 5, 5, 1, 33, 13]), $a([3, 6, 6, 5, 37, 17]), $a([3, 7, 7, 15, 47, 27]), $a([3, 8, 7, 21, 1, 33]), $a([4, 3, 4, 40, 20, 52]), $a([4, 4, 5, 43, 23, 3]), $a([4, 5, 6, 46, 26, 6]), $a([4, 6, 7, 34, 14, 46]), $a([4, 7, 8, 29, 9, 41])]);
  $_.nonccametrics = $a([$a([1, 11, 7, 1, 0, 9]), $a([1, 14, 7, 8, 0, 8]), $a([1, 17, 7, 36, 0, 36]), $a([1, 20, 8, 19, 0, 19]), $a([1, 24, 8, 9, 0, 17]), $a([1, 28, 8, 25, 0, 33]), $a([2, 8, 8, 1, 0, 1]), $a([2, 11, 9, 1, 0, 9]), $a([2, 14, 9, 8, 0, 8]), $a([2, 17, 10, 36, 0, 36]), $a([2, 20, 11, 19, 0, 19]), $a([2, 23, 13, 9, 0, 17]), $a([2, 26, 15, 27, 0, 35]), $a([3, 6, 12, 1, 1, 1]), $a([3, 8, 14, 7, 7, 7]), $a([3, 10, 16, 15, 15, 15]), $a([3, 12, 18, 25, 25, 25]), $a([3, 15, 21, 37, 37, 37]), $a([3, 20, 26, 1, 17, 33]), $a([3, 26, 32, 1, 9, 17]), $a([3, 32, 38, 21, 29, 37]), $a([3, 38, 44, 15, 31, 47]), $a([3, 44, 50, 1, 25, 49]), $a([4, 4, 8, 47, 19, 43]), $a([4, 6, 12, 1, 1, 1]), $a([4, 8, 14, 7, 7, 7]), $a([4, 10, 16, 15, 15, 15]), $a([4, 12, 18, 25, 25, 25]), $a([4, 15, 21, 37, 37, 37]), $a([4, 20, 26, 1, 17, 33]), $a([4, 26, 32, 1, 9, 17]), $a([4, 32, 38, 21, 29, 37]), $a([4, 38, 44, 15, 31, 47]), $a([4, 44, 50, 1, 25, 49])]);
  $k[$j++] = "metrics";
  if ($_.cca) {
    $k[$j++] = $_.ccametrics;
  } else {
    $k[$j++] = $_.nonccametrics;
  }
  var _Fz = $k[--$j];
  $_[$k[--$j]] = _Fz;
  $_.urows = $_.rows;
  $_.ucols = $_.columns;
  $forall($_.metrics, function() {
    $_.m = $k[--$j];
    $_.c = $get($_.m, 0);
    $_.r = $get($_.m, 1);
    $_.k = $get($_.m, 2);
    $_.rapl = $get($_.m, 3);
    $_.rapc = $get($_.m, 4);
    $_.rapr = $get($_.m, 5);
    $_.ncws = $f($_.r * $_.c - $_.k);
    $_.okay = true;
    if ($_.datcws.length > $_.ncws) {
      $_.okay = false;
    }
    if ($_.urows != 0 && $_.urows != $_.r) {
      $_.okay = false;
    }
    if ($_.ucols != 0 && $_.ucols != $_.c) {
      $_.okay = false;
    }
    if ($_.okay) {
      return true;
    }
  });
  if (!$_.okay) {
    $k[$j++] = "bwipp.micropdf417noValidSymbol#19306";
    $k[$j++] = "Maximum length exceeded or invalid size";
    bwipp_raiseerror();
  }
  $_.m = $_.datcws.length;
  $_.n = $f($_.c * $_.r - $_.k);
  $_.cws = $a($_.c * $_.r + 1);
  $puti($_.cws, 0, $_.datcws);
  $k[$j++] = $_.cws;
  $k[$j++] = $_.m;
  $k[$j++] = Infinity;
  for (var _Gh = 0, _Gi = $f($_.n - $_.m); _Gh < _Gi; _Gh++) {
    $k[$j++] = 900;
  }
  var _Gj = $a();
  var _Gk = $k[--$j];
  $puti($k[--$j], _Gk, _Gj);
  $k[$j++] = $_.cws;
  $k[$j++] = $_.n;
  $k[$j++] = Infinity;
  for (var _Gp = 0, _Gq = $_.k; _Gp < _Gq; _Gp++) {
    $k[$j++] = 0;
  }
  $k[$j++] = 0;
  var _Gr = $a();
  var _Gs = $k[--$j];
  $puti($k[--$j], _Gs, _Gr);
  $k[$j++] = Infinity;
  $k[$j++] = 1;
  for (var _Gu = 0; _Gu < 928; _Gu++) {
    var _Gv = $k[$j - 1];
    $k[$j++] = _Gv * 3 % 929;
  }
  $_.rsalog = $a();
  $_.rslog = $a(929);
  for (var _Gy = 1; _Gy <= 928; _Gy += 1) {
    $put($_.rslog, $get($_.rsalog, _Gy), _Gy);
  }
  $_.rsprod = function() {
    var _H3 = $k[$j - 1];
    var _H4 = $k[$j - 2];
    if (_H3 != 0 && _H4 != 0) {
      var _H7 = $get($_.rslog, $k[--$j]);
      var _HC = $get($_.rsalog, $f(_H7 + $get($_.rslog, $k[--$j])) % 928);
      $k[$j++] = _HC;
    } else {
      $j -= 2;
      $k[$j++] = 0;
    }
  };
  $k[$j++] = Infinity;
  $k[$j++] = 1;
  for (var _HE = 0, _HF = $_.k; _HE < _HF; _HE++) {
    $k[$j++] = 0;
  }
  $_.coeffs = $a();
  for (var _HJ = 1, _HI = $_.k; _HJ <= _HI; _HJ += 1) {
    $_.i = _HJ;
    $put($_.coeffs, $_.i, $get($_.coeffs, $_.i - 1));
    for (var _HQ = $_.i - 1; _HQ >= 1; _HQ -= 1) {
      $_.j = _HQ;
      $k[$j++] = $_.coeffs;
      $k[$j++] = $_.j;
      $k[$j++] = $get($_.coeffs, $_.j - 1);
      $k[$j++] = $get($_.coeffs, $_.j);
      $k[$j++] = $get($_.rsalog, $_.i);
      $_.rsprod();
      var _Hc = $k[--$j];
      var _Hd = $k[--$j];
      var _He = $k[--$j];
      $put($k[--$j], _He, $f(_Hd + _Hc) % 929);
    }
    $k[$j++] = $_.coeffs;
    $k[$j++] = 0;
    $k[$j++] = $get($_.coeffs, 0);
    $k[$j++] = $get($_.rsalog, $_.i);
    $_.rsprod();
    var _Hm = $k[--$j];
    var _Hn = $k[--$j];
    $put($k[--$j], _Hn, _Hm);
  }
  $_.coeffs = $geti($_.coeffs, 0, $_.coeffs.length - 1);
  for (var _Ht = $_.coeffs.length - 1; _Ht >= 0; _Ht -= 2) {
    var _Hu = $_.coeffs;
    $put(_Hu, _Ht, 929 - $get(_Hu, _Ht));
  }
  for (var _Hy = 0, _Hx = $_.n - 1; _Hy <= _Hx; _Hy += 1) {
    $_.t = $f($get($_.cws, _Hy) + $get($_.cws, $_.n)) % 929;
    for (var _I6 = 0, _I5 = $_.k - 1; _I6 <= _I5; _I6 += 1) {
      $_.j = _I6;
      $put($_.cws, $f($_.n + $_.j), $f($get($_.cws, $f($_.n + $_.j) + 1) + (929 - $_.t * $get($_.coeffs, $f($_.k - $_.j) - 1) % 929)) % 929);
    }
  }
  for (var _IN = $_.n, _IM = $f($_.n + $_.k); _IN <= _IM; _IN += 1) {
    $put($_.cws, _IN, (929 - $get($_.cws, _IN)) % 929);
  }
  $_.cws = $geti($_.cws, 0, $_.cws.length - 1);
  var _IV = $get($_.options, "debugcws") !== void 0;
  if (_IV) {
    $k[$j++] = "bwipp.debugcws#19360";
    $k[$j++] = $_.cws;
    bwipp_raiseerror();
  }
  $_.clusters = $a([$a([120256, 125680, 128380, 120032, 125560, 128318, 108736, 119920, 108640, 86080, 108592, 86048, 110016, 120560, 125820, 109792, 120440, 125758, 88256, 109680, 88160, 89536, 110320, 120700, 89312, 110200, 120638, 89200, 110140, 89840, 110460, 89720, 110398, 89980, 128506, 119520, 125304, 128190, 107712, 119408, 125244, 107616, 119352, 84032, 107568, 119324, 84e3, 107544, 83984, 108256, 119672, 125374, 85184, 108144, 119612, 85088, 108088, 119582, 85040, 108060, 85728, 108408, 119742, 85616, 108348, 85560, 108318, 85880, 108478, 85820, 85790, 107200, 119152, 125116, 107104, 119096, 125086, 83008, 107056, 119068, 82976, 107032, 82960, 82952, 83648, 107376, 119228, 83552, 107320, 119198, 83504, 107292, 83480, 83468, 83824, 107452, 83768, 107422, 83740, 83900, 106848, 118968, 125022, 82496, 106800, 118940, 82464, 106776, 118926, 82448, 106764, 82440, 106758, 82784, 106936, 119006, 82736, 106908, 82712, 106894, 82700, 82694, 106974, 82830, 82240, 106672, 118876, 82208, 106648, 118862, 82192, 106636, 82184, 106630, 82180, 82352, 82328, 82316, 82080, 118830, 106572, 106566, 82050, 117472, 124280, 127678, 103616, 117360, 124220, 103520, 117304, 124190, 75840, 103472, 75808, 104160, 117624, 124350, 76992, 104048, 117564, 76896, 103992, 76848, 76824, 77536, 104312, 117694, 77424, 104252, 77368, 77340, 77688, 104382, 77628, 77758, 121536, 126320, 128700, 121440, 126264, 128670, 111680, 121392, 126236, 111648, 121368, 126222, 111632, 121356, 103104, 117104, 124092, 112320, 103008, 117048, 124062, 112224, 121656, 126366, 93248, 74784, 102936, 117006, 93216, 112152, 93200, 75456, 103280, 117180, 93888, 75360, 103224, 117150, 93792, 112440, 121758, 93744, 75288, 93720, 75632, 103356, 94064, 75576, 103326, 94008, 112542, 93980, 75708, 94140, 75678, 94110, 121184, 126136, 128606, 111168, 121136, 126108, 111136, 121112, 126094, 111120, 121100, 111112, 111108, 102752, 116920, 123998, 111456, 102704, 116892, 91712, 74272, 121244, 116878, 91680, 74256, 102668, 91664, 111372, 102662, 74244, 74592, 102840, 116958, 92e3, 74544, 102812, 91952, 111516, 102798, 91928, 74508, 74502, 74680, 102878, 92088, 74652, 92060, 74638, 92046, 92126, 110912, 121008, 126044, 110880, 120984, 126030, 110864, 120972, 110856, 120966, 110852, 110850, 74048, 102576, 116828, 90944, 74016, 102552, 116814, 90912, 111e3, 121038, 90896, 73992, 102534, 90888, 110982, 90884, 74160, 102620, 91056, 74136, 102606, 91032, 111054, 91020, 74118, 91014, 91100, 91086, 110752, 120920, 125998, 110736, 120908, 110728, 120902, 110724, 110722, 73888, 102488, 116782, 90528, 73872, 102476, 90512, 110796, 102470, 90504, 73860, 90500, 73858, 73944, 90584, 90572, 90566, 120876, 120870, 110658, 102444, 73800, 90312, 90308, 90306, 101056, 116080, 123580, 100960, 116024, 70720, 100912, 115996, 70688, 100888, 70672, 70664, 71360, 101232, 116156, 71264, 101176, 116126, 71216, 101148, 71192, 71180, 71536, 101308, 71480, 101278, 71452, 71612, 71582, 118112, 124600, 127838, 105024, 118064, 124572, 104992, 118040, 124558, 104976, 118028, 104968, 118022, 100704, 115896, 123486, 105312, 100656, 115868, 79424, 70176, 118172, 115854, 79392, 105240, 100620, 79376, 70152, 79368, 70496, 100792, 115934, 79712, 70448, 118238, 79664, 105372, 100750, 79640, 70412, 79628, 70584, 100830, 79800, 70556, 79772, 70542, 70622, 79838, 122176, 126640, 128860, 122144, 126616, 128846, 122128, 126604, 122120, 126598, 122116, 104768, 117936, 124508, 113472, 104736, 126684, 124494, 113440, 122264, 126670, 113424, 104712, 117894, 113416, 122246, 104706, 69952, 100528, 115804, 78656, 69920, 100504, 115790, 96064, 78624, 104856, 117966, 96032, 113560, 122318, 100486, 96016, 78600, 104838, 96008, 69890, 70064, 100572, 78768, 70040, 100558, 96176, 78744, 104910, 96152, 113614, 70022, 78726, 70108, 78812, 70094, 96220, 78798, 122016, 126552, 128814, 122e3, 126540, 121992, 126534, 121988, 121986, 104608, 117848, 124462, 113056, 104592, 126574, 113040, 122060, 117830, 113032, 104580, 113028, 104578, 113026, 69792, 100440, 115758, 78240, 69776, 100428, 95136, 78224, 104652, 100422, 95120, 113100, 69764, 95112, 78212, 69762, 78210, 69848, 100462, 78296, 69836, 95192, 78284, 69830, 95180, 78278, 69870, 95214, 121936, 126508, 121928, 126502, 121924, 121922, 104528, 117804, 112848, 104520, 117798, 112840, 121958, 112836, 104514, 112834, 69712, 100396, 78032, 69704, 100390, 94672, 78024, 104550, 94664, 112870, 69698, 94660, 78018, 94658, 78060, 94700, 94694, 126486, 121890, 117782, 104484, 104482, 69672, 77928, 94440, 69666, 77922, 99680, 68160, 99632, 68128, 99608, 115342, 68112, 99596, 68104, 99590, 68448, 99768, 115422, 68400, 99740, 68376, 99726, 68364, 68358, 68536, 99806, 68508, 68494, 68574, 101696, 116400, 123740, 101664, 116376, 101648, 116364, 101640, 116358, 101636, 67904, 99504, 115292, 72512, 67872, 116444, 115278, 72480, 101784, 116430, 72464, 67848, 99462, 72456, 101766, 67842, 68016, 99548, 72624, 67992, 99534, 72600, 101838, 72588, 67974, 68060, 72668, 68046, 72654, 118432, 124760, 127918, 118416, 124748, 118408, 124742, 118404, 118402, 101536, 116312, 105888, 101520, 116300, 105872, 118476, 116294, 105864, 101508, 105860, 101506, 105858, 67744, 99416, 72096, 67728, 116334, 80800, 72080, 101580, 99398, 80784, 105932, 67716, 80776, 72068, 67714, 72066, 67800, 99438, 72152, 67788, 80856, 72140, 67782, 80844, 72134, 67822, 72174, 80878, 126800, 128940, 126792, 128934, 126788, 126786, 118352, 124716, 122576, 126828, 124710, 122568, 126822, 122564, 118338, 122562, 101456, 116268, 105680, 101448, 116262, 114128, 105672, 118374, 114120, 122598, 101442, 114116, 105666, 114114, 67664, 99372, 71888, 67656, 99366, 80336, 71880, 101478, 97232, 80328, 105702, 67650, 97224, 114150, 71874, 97220, 67692, 71916, 67686, 80364, 71910, 97260, 80358, 97254, 126760, 128918, 126756, 126754, 118312, 124694, 122472, 126774, 122468, 118306, 122466, 101416, 116246, 105576, 101412, 113896, 105572, 101410, 113892, 105570, 113890, 67624, 99350, 71784, 101430, 80104, 71780, 67618, 96744, 80100, 71778, 96740, 80098, 96738, 71798, 96758, 126738, 122420, 122418, 105524, 113780, 113778, 71732, 79988, 96500, 96498, 66880, 66848, 98968, 66832, 66824, 66820, 66992, 66968, 66956, 66950, 67036, 67022, 1e5, 99984, 115532, 99976, 115526, 99972, 99970, 66720, 98904, 69024, 100056, 98892, 69008, 100044, 69e3, 100038, 68996, 66690, 68994, 66776, 98926, 69080, 100078, 69068, 66758, 69062, 66798, 69102, 116560, 116552, 116548, 116546, 99920, 102096, 116588, 115494, 102088, 116582, 102084, 99906, 102082, 66640, 68816, 66632, 98854, 73168, 68808, 66628, 73160, 68804, 66626, 73156, 68802, 66668, 68844, 66662, 73196, 68838, 73190, 124840, 124836, 124834, 116520, 118632, 124854, 118628, 116514, 118626, 99880, 115478, 101992, 116534, 106216, 101988, 99874, 106212, 101986, 106210, 66600, 98838, 68712, 99894, 72936, 68708, 66594, 81384, 72932, 68706, 81380, 72930, 66614, 68726, 72950, 81398, 128980, 128978, 124820, 126900, 124818, 126898, 116500, 118580, 116498, 122740, 118578, 122738, 99860, 101940, 99858, 106100, 101938, 114420]), $a([128352, 129720, 125504, 128304, 129692, 125472, 128280, 129678, 125456, 128268, 125448, 128262, 125444, 125792, 128440, 129758, 120384, 125744, 128412, 120352, 125720, 128398, 120336, 125708, 120328, 125702, 120324, 120672, 125880, 128478, 110144, 120624, 125852, 110112, 120600, 125838, 110096, 120588, 110088, 120582, 110084, 110432, 120760, 125918, 89664, 110384, 120732, 89632, 110360, 120718, 89616, 110348, 89608, 110342, 89952, 110520, 120798, 89904, 110492, 89880, 110478, 89868, 90040, 110558, 90012, 89998, 125248, 128176, 129628, 125216, 128152, 129614, 125200, 128140, 125192, 128134, 125188, 125186, 119616, 125360, 128220, 119584, 125336, 128206, 119568, 125324, 119560, 125318, 119556, 119554, 108352, 119728, 125404, 108320, 119704, 125390, 108304, 119692, 108296, 119686, 108292, 108290, 85824, 108464, 119772, 85792, 108440, 119758, 85776, 108428, 85768, 108422, 85764, 85936, 108508, 85912, 108494, 85900, 85894, 85980, 85966, 125088, 128088, 129582, 125072, 128076, 125064, 128070, 125060, 125058, 119200, 125144, 128110, 119184, 125132, 119176, 125126, 119172, 119170, 107424, 119256, 125166, 107408, 119244, 107400, 119238, 107396, 107394, 83872, 107480, 119278, 83856, 107468, 83848, 107462, 83844, 83842, 83928, 107502, 83916, 83910, 83950, 125008, 128044, 125e3, 128038, 124996, 124994, 118992, 125036, 118984, 125030, 118980, 118978, 106960, 119020, 106952, 119014, 106948, 106946, 82896, 106988, 82888, 106982, 82884, 82882, 82924, 82918, 124968, 128022, 124964, 124962, 118888, 124982, 118884, 118882, 106728, 118902, 106724, 106722, 82408, 106742, 82404, 82402, 124948, 124946, 118836, 118834, 106612, 106610, 124224, 127664, 129372, 124192, 127640, 129358, 124176, 127628, 124168, 127622, 124164, 124162, 117568, 124336, 127708, 117536, 124312, 127694, 117520, 124300, 117512, 124294, 117508, 117506, 104256, 117680, 124380, 104224, 117656, 124366, 104208, 117644, 104200, 117638, 104196, 104194, 77632, 104368, 117724, 77600, 104344, 117710, 77584, 104332, 77576, 104326, 77572, 77744, 104412, 77720, 104398, 77708, 77702, 77788, 77774, 128672, 129880, 93168, 128656, 129868, 92664, 128648, 129862, 92412, 128644, 128642, 124064, 127576, 129326, 126368, 124048, 129902, 126352, 128716, 127558, 126344, 124036, 126340, 124034, 126338, 117152, 124120, 127598, 121760, 117136, 124108, 121744, 126412, 124102, 121736, 117124, 121732, 117122, 121730, 103328, 117208, 124142, 112544, 103312, 117196, 112528, 121804, 117190, 112520, 103300, 112516, 103298, 112514, 75680, 103384, 117230, 94112, 75664, 103372, 94096, 112588, 103366, 94088, 75652, 94084, 75650, 75736, 103406, 94168, 75724, 94156, 75718, 94150, 75758, 128592, 129836, 91640, 128584, 129830, 91388, 128580, 91262, 128578, 123984, 127532, 126160, 123976, 127526, 126152, 128614, 126148, 123970, 126146, 116944, 124012, 121296, 116936, 124006, 121288, 126182, 121284, 116930, 121282, 102864, 116972, 111568, 102856, 116966, 111560, 121318, 111556, 102850, 111554, 74704, 102892, 92112, 74696, 102886, 92104, 111590, 92100, 74690, 92098, 74732, 92140, 74726, 92134, 128552, 129814, 90876, 128548, 90750, 128546, 123944, 127510, 126056, 128566, 126052, 123938, 126050, 116840, 123958, 121064, 116836, 121060, 116834, 121058, 102632, 116854, 111080, 121078, 111076, 102626, 111074, 74216, 102646, 91112, 74212, 91108, 74210, 91106, 74230, 91126, 128532, 90494, 128530, 123924, 126004, 123922, 126002, 116788, 120948, 116786, 120946, 102516, 110836, 102514, 110834, 73972, 90612, 73970, 90610, 128522, 123914, 125978, 116762, 120890, 102458, 110714, 123552, 127320, 129198, 123536, 127308, 123528, 127302, 123524, 123522, 116128, 123608, 127342, 116112, 123596, 116104, 123590, 116100, 116098, 101280, 116184, 123630, 101264, 116172, 101256, 116166, 101252, 101250, 71584, 101336, 116206, 71568, 101324, 71560, 101318, 71556, 71554, 71640, 101358, 71628, 71622, 71662, 127824, 129452, 79352, 127816, 129446, 79100, 127812, 78974, 127810, 123472, 127276, 124624, 123464, 127270, 124616, 127846, 124612, 123458, 124610, 115920, 123500, 118224, 115912, 123494, 118216, 124646, 118212, 115906, 118210, 100816, 115948, 105424, 100808, 115942, 105416, 118246, 105412, 100802, 105410, 70608, 100844, 79824, 70600, 100838, 79816, 105446, 79812, 70594, 79810, 70636, 79852, 70630, 79846, 129960, 95728, 113404, 129956, 95480, 113278, 129954, 95356, 95294, 127784, 129430, 78588, 128872, 129974, 95996, 78462, 128868, 127778, 95870, 128866, 123432, 127254, 124520, 123428, 126696, 128886, 123426, 126692, 124514, 126690, 115816, 123446, 117992, 115812, 122344, 117988, 115810, 122340, 117986, 122338, 100584, 115830, 104936, 100580, 113640, 104932, 100578, 113636, 104930, 113634, 70120, 100598, 78824, 70116, 96232, 78820, 70114, 96228, 78818, 96226, 70134, 78838, 129940, 94968, 113022, 129938, 94844, 94782, 127764, 78206, 128820, 127762, 95102, 128818, 123412, 124468, 123410, 126580, 124466, 126578, 115764, 117876, 115762, 122100, 117874, 122098, 100468, 104692, 100466, 113140, 104690, 113138, 69876, 78324, 69874, 95220, 78322, 95218, 129930, 94588, 94526, 127754, 128794, 123402, 124442, 126522, 115738, 117818, 121978, 100410, 104570, 112890, 69754, 78074, 94714, 94398, 123216, 127148, 123208, 127142, 123204, 123202, 115408, 123244, 115400, 123238, 115396, 115394, 99792, 115436, 99784, 115430, 99780, 99778, 68560, 99820, 68552, 99814, 68548, 68546, 68588, 68582, 127400, 129238, 72444, 127396, 72318, 127394, 123176, 127126, 123752, 123172, 123748, 123170, 123746, 115304, 123190, 116456, 115300, 116452, 115298, 116450, 99560, 115318, 101864, 99556, 101860, 99554, 101858, 68072, 99574, 72680, 68068, 72676, 68066, 72674, 68086, 72694, 129492, 80632, 105854, 129490, 80508, 80446, 127380, 72062, 127924, 127378, 80766, 127922, 123156, 123700, 123154, 124788, 123698, 124786, 115252, 116340, 115250, 118516, 116338, 118514, 99444, 101620, 99442, 105972, 101618, 105970, 67828, 72180, 67826, 80884, 72178, 80882, 97008, 114044, 96888, 113982, 96828, 96798, 129482, 80252, 130010, 97148, 80190, 97086, 127370, 127898, 128954, 123146, 123674, 124730, 126842, 115226, 116282, 118394, 122618, 99386, 101498, 105722, 114170, 67706, 71930, 80378, 96632, 113854, 96572, 96542, 80062, 96702, 96444, 96414, 96350, 123048, 123044, 123042, 115048, 123062, 115044, 115042, 99048, 115062, 99044, 99042, 67048, 99062, 67044, 67042, 67062, 127188, 68990, 127186, 123028, 123316, 123026, 123314, 114996, 115572, 114994, 115570, 98932, 100084, 98930, 100082, 66804, 69108, 66802, 69106, 129258, 73084, 73022, 127178, 127450, 123018, 123290, 123834, 114970, 115514, 116602, 98874, 99962, 102138, 66682, 68858, 73210, 81272, 106174, 81212, 81182, 72894, 81342, 97648, 114364, 97592, 114334, 97564, 97550, 81084, 97724, 81054, 97694, 97464, 114270, 97436, 97422, 80990, 97502, 97372, 97358, 97326, 114868, 114866, 98676, 98674, 66292, 66290, 123098, 114842, 115130, 98618, 99194, 66170, 67322, 69310, 73404, 73374, 81592, 106334, 81564, 81550, 73310, 81630, 97968, 114524, 97944, 114510, 97932, 97926, 81500, 98012, 81486, 97998, 97880, 114478, 97868, 97862, 81454, 97902, 97836, 97830, 69470, 73564, 73550, 81752, 106414, 81740, 81734, 73518, 81774, 81708, 81702]), $a([109536, 120312, 86976, 109040, 120060, 86496, 108792, 119934, 86256, 108668, 86136, 129744, 89056, 110072, 129736, 88560, 109820, 129732, 88312, 109694, 129730, 88188, 128464, 129772, 89592, 128456, 129766, 89340, 128452, 89214, 128450, 125904, 128492, 125896, 128486, 125892, 125890, 120784, 125932, 120776, 125926, 120772, 120770, 110544, 120812, 110536, 120806, 110532, 84928, 108016, 119548, 84448, 107768, 119422, 84208, 107644, 84088, 107582, 84028, 129640, 85488, 108284, 129636, 85240, 108158, 129634, 85116, 85054, 128232, 129654, 85756, 128228, 85630, 128226, 125416, 128246, 125412, 125410, 119784, 125430, 119780, 119778, 108520, 119798, 108516, 108514, 83424, 107256, 119166, 83184, 107132, 83064, 107070, 83004, 82974, 129588, 83704, 107390, 129586, 83580, 83518, 128116, 83838, 128114, 125172, 125170, 119284, 119282, 107508, 107506, 82672, 106876, 82552, 106814, 82492, 82462, 129562, 82812, 82750, 128058, 125050, 119034, 82296, 106686, 82236, 82206, 82366, 82108, 82078, 76736, 103920, 117500, 76256, 103672, 117374, 76016, 103548, 75896, 103486, 75836, 129384, 77296, 104188, 129380, 77048, 104062, 129378, 76924, 76862, 127720, 129398, 77564, 127716, 77438, 127714, 124392, 127734, 124388, 124386, 117736, 124406, 117732, 117730, 104424, 117750, 104420, 104418, 112096, 121592, 126334, 92608, 111856, 121468, 92384, 111736, 121406, 92272, 111676, 92216, 111646, 92188, 75232, 103160, 117118, 93664, 74992, 103036, 93424, 112252, 102974, 93304, 74812, 93244, 74782, 93214, 129332, 75512, 103294, 129908, 129330, 93944, 75388, 129906, 93820, 75326, 93758, 127604, 75646, 128756, 127602, 94078, 128754, 124148, 126452, 124146, 126450, 117236, 121844, 117234, 121842, 103412, 103410, 91584, 111344, 121212, 91360, 111224, 121150, 91248, 111164, 91192, 111134, 91164, 91150, 74480, 102780, 91888, 74360, 102718, 91768, 111422, 91708, 74270, 91678, 129306, 74620, 129850, 92028, 74558, 91966, 127546, 128634, 124026, 126202, 116986, 121338, 102906, 90848, 110968, 121022, 90736, 110908, 90680, 110878, 90652, 90638, 74104, 102590, 91e3, 74044, 90940, 74014, 90910, 74174, 91070, 90480, 110780, 90424, 110750, 90396, 90382, 73916, 90556, 73886, 90526, 90296, 110686, 90268, 90254, 73822, 90334, 90204, 90190, 71136, 101112, 116094, 70896, 100988, 70776, 100926, 70716, 70686, 129204, 71416, 101246, 129202, 71292, 71230, 127348, 71550, 127346, 123636, 123634, 116212, 116210, 101364, 101362, 79296, 105200, 118140, 79072, 105080, 118078, 78960, 105020, 78904, 104990, 78876, 78862, 70384, 100732, 79600, 70264, 100670, 79480, 105278, 79420, 70174, 79390, 129178, 70524, 129466, 79740, 70462, 79678, 127290, 127866, 123514, 124666, 115962, 118266, 100858, 113376, 122232, 126654, 95424, 113264, 122172, 95328, 113208, 122142, 95280, 113180, 95256, 113166, 95244, 78560, 104824, 117950, 95968, 78448, 104764, 95856, 113468, 104734, 95800, 78364, 95772, 78350, 95758, 70008, 100542, 78712, 69948, 96120, 78652, 69918, 96060, 78622, 96030, 70078, 78782, 96190, 94912, 113008, 122044, 94816, 112952, 122014, 94768, 112924, 94744, 112910, 94732, 94726, 78192, 104636, 95088, 78136, 104606, 95032, 113054, 95004, 78094, 94990, 69820, 78268, 69790, 95164, 78238, 95134, 94560, 112824, 121950, 94512, 112796, 94488, 112782, 94476, 94470, 78008, 104542, 94648, 77980, 94620, 77966, 94606, 69726, 78046, 94686, 94384, 112732, 94360, 112718, 94348, 94342, 77916, 94428, 77902, 94414, 94296, 112686, 94284, 94278, 77870, 94318, 94252, 94246, 68336, 99708, 68216, 99646, 68156, 68126, 68476, 68414, 127162, 123258, 115450, 99834, 72416, 101752, 116414, 72304, 101692, 72248, 101662, 72220, 72206, 67960, 99518, 72568, 67900, 72508, 67870, 72478, 68030, 72638, 80576, 105840, 118460, 80480, 105784, 118430, 80432, 105756, 80408, 105742, 80396, 80390, 72048, 101564, 80752, 71992, 101534, 80696, 71964, 80668, 71950, 80654, 67772, 72124, 67742, 80828, 72094, 80798, 114016, 122552, 126814, 96832, 113968, 122524, 96800, 113944, 122510, 96784, 113932, 96776, 113926, 96772, 80224, 105656, 118366, 97120, 80176, 105628, 97072, 114076, 105614, 97048, 80140, 97036, 80134, 97030, 71864, 101470, 80312, 71836, 97208, 80284, 71822, 97180, 80270, 97166, 67678, 71902, 80350, 97246, 96576, 113840, 122460, 96544, 113816, 122446, 96528, 113804, 96520, 113798, 96516, 96514, 80048, 105564, 96688, 80024, 105550, 96664, 113870, 96652, 80006, 96646, 71772, 80092, 71758, 96732, 80078, 96718, 96416, 113752, 122414, 96400, 113740, 96392, 113734, 96388, 96386, 79960, 105518, 96472, 79948, 96460, 79942, 96454, 71726, 79982, 96494, 96336, 113708, 96328, 113702, 96324, 96322, 79916, 96364, 79910, 96358, 96296, 113686, 96292, 96290, 79894, 96310, 66936, 99006, 66876, 66846, 67006, 68976, 100028, 68920, 99998, 68892, 68878, 66748, 69052, 66718, 69022, 73056, 102072, 116574, 73008, 102044, 72984, 102030, 72972, 72966, 68792, 99934, 73144, 68764, 73116, 68750, 73102, 66654, 68830, 73182, 81216, 106160, 118620, 81184, 106136, 118606, 81168, 106124, 81160, 106118, 81156, 81154, 72880, 101980, 81328, 72856, 101966, 81304, 106190, 81292, 72838, 81286, 68700, 72924, 68686, 81372, 72910, 81358, 114336, 122712, 126894, 114320, 122700, 114312, 122694, 114308, 114306, 81056, 106072, 118574, 97696, 81040, 106060, 97680, 114380, 106054, 97672, 81028, 97668, 81026, 97666, 72792, 101934, 81112, 72780, 97752, 81100, 72774, 97740, 81094, 97734, 68654, 72814, 81134, 97774, 114256, 122668, 114248, 122662, 114244, 114242, 80976, 106028, 97488, 80968, 106022, 97480, 114278, 97476, 80962, 97474, 72748, 81004, 72742, 97516, 80998, 97510, 114216, 122646, 114212, 114210, 80936, 106006, 97384, 80932, 97380, 80930, 97378, 72726, 80950, 97398, 114196, 114194, 80916, 97332, 80914, 97330, 66236, 66206, 67256, 99166, 67228, 67214, 66142, 67294, 69296, 100188, 69272, 100174, 69260, 69254, 67164, 69340, 67150, 69326, 73376, 102232, 116654, 73360, 102220, 73352, 102214, 73348, 73346, 69208, 100142, 73432, 102254, 73420, 69190, 73414, 67118, 69230, 73454, 106320, 118700, 106312, 118694, 106308, 106306, 73296, 102188, 81616, 106348, 102182, 81608, 73284, 81604, 73282, 81602, 69164, 73324, 69158, 81644, 73318, 81638, 122792, 126934, 122788, 122786, 106280, 118678, 114536, 106276, 114532, 106274, 114530, 73256, 102166, 81512, 73252, 98024, 81508, 73250, 98020, 81506, 98018, 69142, 73270, 81526, 98038, 122772, 122770, 106260, 114484, 106258, 114482, 73236, 81460, 73234, 97908, 81458, 97906, 122762, 106250, 114458, 73226, 81434, 97850, 66396, 66382, 67416, 99246, 67404, 67398, 66350, 67438, 69456, 100268, 69448, 100262, 69444, 69442, 67372, 69484, 67366, 69478, 102312, 116694, 102308, 102306, 69416, 100246, 73576, 102326, 73572, 69410, 73570, 67350, 69430, 73590, 118740, 118738, 102292, 106420, 102290, 106418, 69396, 73524, 69394, 81780, 73522, 81778, 118730, 102282, 106394, 69386, 73498, 81722, 66476, 66470, 67496, 99286, 67492, 67490, 66454, 67510, 100308, 100306, 67476, 69556, 67474, 69554, 116714])]);
  $_.raps = $a([$a([802, 930, 946, 818, 882, 890, 826, 954, 922, 986, 970, 906, 778, 794, 786, 914, 978, 982, 980, 916, 948, 932, 934, 942, 940, 936, 808, 812, 814, 806, 822, 950, 918, 790, 788, 820, 884, 868, 870, 878, 876, 872, 840, 856, 860, 862, 846, 844, 836, 838, 834, 866]), $a([718, 590, 622, 558, 550, 566, 534, 530, 538, 570, 562, 546, 610, 626, 634, 762, 754, 758, 630, 628, 612, 614, 582, 578, 706, 738, 742, 740, 748, 620, 556, 552, 616, 744, 712, 716, 708, 710, 646, 654, 652, 668, 664, 696, 688, 656, 720, 592, 600, 604, 732, 734])]);
  $_.cwtobits = function() {
    var _Ih = $get($_.clusters, $k[--$j]);
    $_.v = $get(_Ih, $k[--$j]);
    $k[$j++] = Infinity;
    for (var _Ik = 0; _Ik < 17; _Ik++) {
      $k[$j++] = 0;
    }
    var _In = $cvrs($s(17), $_.v, 2);
    for (var _Io = 0, _Ip = _In.length; _Io < _Ip; _Io++) {
      $k[$j++] = $get(_In, _Io) - 48;
    }
    var _Ir = $a();
    $k[$j++] = $geti(_Ir, _Ir.length - 17, 17);
  };
  $_.raptobits = function() {
    var _Iv = $get($_.raps, $k[--$j]);
    $_.v = $get(_Iv, $k[--$j]);
    $k[$j++] = Infinity;
    for (var _Iy = 0; _Iy < 10; _Iy++) {
      $k[$j++] = 0;
    }
    var _J1 = $cvrs($s(10), $_.v, 2);
    for (var _J2 = 0, _J3 = _J1.length; _J2 < _J3; _J2++) {
      $k[$j++] = $get(_J1, _J2) - 48;
    }
    var _J5 = $a();
    $k[$j++] = $geti(_J5, _J5.length - 10, 10);
  };
  $_.rwid = $get($a([38, 55, 82, 99]), $_.c - 1);
  if ($_.c == 3 && $_.cca) {
    $_.rwid = 72;
  }
  $_.pixs = $a($_.rwid * $_.r * $_.rowmult);
  for (var _JI = 0, _JH = $_.r - 1; _JI <= _JH; _JI += 1) {
    $_.i = _JI;
    $_.clst = ($f($_.i + $_.rapl) - 1) % 3;
    $k[$j++] = Infinity;
    if ($_.c == 1) {
      $k[$j++] = ($f($_.i + $_.rapl) - 1) % 52;
      $k[$j++] = 0;
      $_.raptobits();
      $aload($k[--$j]);
      $k[$j++] = $get($_.cws, $_.i);
      $k[$j++] = $_.clst;
      $_.cwtobits();
      $aload($k[--$j]);
      $k[$j++] = ($f($_.i + $_.rapr) - 1) % 52;
      $k[$j++] = 0;
      $_.raptobits();
      $aload($k[--$j]);
    }
    if ($_.c == 2) {
      $k[$j++] = ($f($_.i + $_.rapl) - 1) % 52;
      $k[$j++] = 0;
      $_.raptobits();
      $aload($k[--$j]);
      $k[$j++] = $get($_.cws, $_.i * 2);
      $k[$j++] = $_.clst;
      $_.cwtobits();
      $aload($k[--$j]);
      $k[$j++] = $get($_.cws, $_.i * 2 + 1);
      $k[$j++] = $_.clst;
      $_.cwtobits();
      $aload($k[--$j]);
      $k[$j++] = ($f($_.i + $_.rapr) - 1) % 52;
      $k[$j++] = 0;
      $_.raptobits();
      $aload($k[--$j]);
    }
    if ($_.c == 3) {
      if (!$_.cca) {
        $k[$j++] = ($f($_.i + $_.rapl) - 1) % 52;
        $k[$j++] = 0;
        $_.raptobits();
        $aload($k[--$j]);
      }
      $k[$j++] = $get($_.cws, $_.i * 3);
      $k[$j++] = $_.clst;
      $_.cwtobits();
      $aload($k[--$j]);
      $k[$j++] = ($f($_.i + $_.rapc) - 1) % 52;
      $k[$j++] = 1;
      $_.raptobits();
      $aload($k[--$j]);
      $k[$j++] = $get($_.cws, $_.i * 3 + 1);
      $k[$j++] = $_.clst;
      $_.cwtobits();
      $aload($k[--$j]);
      $k[$j++] = $get($_.cws, $_.i * 3 + 2);
      $k[$j++] = $_.clst;
      $_.cwtobits();
      $aload($k[--$j]);
      $k[$j++] = ($f($_.i + $_.rapr) - 1) % 52;
      $k[$j++] = 0;
      $_.raptobits();
      $aload($k[--$j]);
    }
    if ($_.c == 4) {
      $k[$j++] = ($f($_.i + $_.rapl) - 1) % 52;
      $k[$j++] = 0;
      $_.raptobits();
      $aload($k[--$j]);
      $k[$j++] = $get($_.cws, $_.i * 4);
      $k[$j++] = $_.clst;
      $_.cwtobits();
      $aload($k[--$j]);
      $k[$j++] = $get($_.cws, $_.i * 4 + 1);
      $k[$j++] = $_.clst;
      $_.cwtobits();
      $aload($k[--$j]);
      $k[$j++] = ($f($_.i + $_.rapc) - 1) % 52;
      $k[$j++] = 1;
      $_.raptobits();
      $aload($k[--$j]);
      $k[$j++] = $get($_.cws, $_.i * 4 + 2);
      $k[$j++] = $_.clst;
      $_.cwtobits();
      $aload($k[--$j]);
      $k[$j++] = $get($_.cws, $_.i * 4 + 3);
      $k[$j++] = $_.clst;
      $_.cwtobits();
      $aload($k[--$j]);
      $k[$j++] = ($f($_.i + $_.rapr) - 1) % 52;
      $k[$j++] = 0;
      $_.raptobits();
      $aload($k[--$j]);
    }
    $k[$j++] = 1;
    var _Ki = $a();
    $k[$j++] = _Ki;
    for (var _Kl = 0, _Kk = $_.rowmult - 1; _Kl <= _Kk; _Kl += 1) {
      var _Kq = $k[$j - 1];
      $puti($_.pixs, (_Kl + $_.i * $_.rowmult) * $_.rwid, _Kq);
    }
    $j--;
  }
  var _Kz = /* @__PURE__ */ new Map([
    ["ren", "renmatrix"],
    ["pixs", $_.pixs],
    ["pixx", $_.rwid],
    ["pixy", $_.r * $_.rowmult],
    ["height", $_.r * $_.rowmult / 72],
    ["width", $_.rwid / 72],
    ["borderleft", 1],
    ["borderright", 1],
    ["bordertop", 1],
    ["borderbottom", 1],
    ["opt", $_.options]
  ]);
  $k[$j++] = _Kz;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_datamatrix() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.columns = 0;
  $_.rows = 0;
  $_.format = "unset";
  $_.version = "unset";
  $_.parse = false;
  $_.parsefnc = false;
  $_.c40headerlength = -1;
  $_.raw = false;
  $_.dmre = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length == 0) {
    $k[$j++] = "bwipp.datamatrixEmptyData#19750";
    $k[$j++] = "The data must not be empty";
    bwipp_raiseerror();
  }
  if ($ne($_.version, "unset") && ($_.rows != 0 || $_.columns != 0)) {
    $k[$j++] = "bwipp.datamatrixVersionRowsCols#19754";
    $k[$j++] = "rows and columns must not be given if version is specified";
    bwipp_raiseerror();
  }
  if ($ne($_.version, "unset")) {
    $search($_.version, "x");
    if ($k[--$j]) {
      var _9 = $k[--$j];
      $k[$j - 1] = _9;
      var _B = $k[$j - 1];
      var _C = $k[$j - 2];
      $k[$j++] = _C;
      $k[$j++] = _B;
      $astore($a(2));
      $forall($k[--$j], function() {
        var _F = $k[$j - 1];
        $k[$j++] = true;
        if (_F.length == 0) {
          $k[$j - 1] = false;
        }
        var _G = $k[--$j];
        var _H = $k[--$j];
        $k[$j++] = _G;
        $forall(_H, function() {
          var _I = $k[--$j];
          if (_I < 48 || _I > 57) {
            $k[$j - 1] = false;
          }
        });
        if (!$k[--$j]) {
          $k[$j++] = "bwipp.datamatrixVersionBadRowOrColumn#19768";
          $k[$j++] = "version must be formatted as RxC";
          bwipp_raiseerror();
        }
      });
      $_.rows = $cvi($k[--$j]);
      $_.columns = $cvi($k[--$j]);
      $k[$j++] = "format";
      if ($_.rows == $_.columns) {
        $k[$j++] = "square";
      } else {
        $k[$j++] = "rectangle";
      }
      var _O = $k[--$j];
      $_[$k[--$j]] = _O;
    } else {
      $j--;
      $k[$j++] = "bwipp.datamatrixVersionFormat#19775";
      $k[$j++] = "version must be formatted as RxC";
      bwipp_raiseerror();
    }
  } else {
    if ($eq($_.format, "unset")) {
      $k[$j++] = "format";
      if ($_.dmre) {
        $k[$j++] = "rectangle";
      } else {
        $k[$j++] = "square";
      }
      var _S = $k[--$j];
      $_[$k[--$j]] = _S;
    }
  }
  if ($ne($_.format, "square") && $ne($_.format, "rectangle")) {
    $k[$j++] = "bwipp.datamatrixInvalidFormat#19784";
    $k[$j++] = "The format must be either square or rectangle";
    bwipp_raiseerror();
  }
  $_.metrics = $a([$a([10, 10, 1, 1, 5, 1, 0]), $a([12, 12, 1, 1, 7, 1, 0]), $a([14, 14, 1, 1, 10, 1, 0]), $a([16, 16, 1, 1, 12, 1, 0]), $a([18, 18, 1, 1, 14, 1, 0]), $a([20, 20, 1, 1, 18, 1, 0]), $a([22, 22, 1, 1, 20, 1, 0]), $a([24, 24, 1, 1, 24, 1, 0]), $a([26, 26, 1, 1, 28, 1, 0]), $a([32, 32, 2, 2, 36, 1, 0]), $a([36, 36, 2, 2, 42, 1, 0]), $a([40, 40, 2, 2, 48, 1, 0]), $a([44, 44, 2, 2, 56, 1, 0]), $a([48, 48, 2, 2, 68, 1, 0]), $a([52, 52, 2, 2, 84, 2, 0]), $a([64, 64, 4, 4, 112, 2, 0]), $a([72, 72, 4, 4, 144, 4, 0]), $a([80, 80, 4, 4, 192, 4, 0]), $a([88, 88, 4, 4, 224, 4, 0]), $a([96, 96, 4, 4, 272, 4, 0]), $a([104, 104, 4, 4, 336, 6, 0]), $a([120, 120, 6, 6, 408, 6, 0]), $a([132, 132, 6, 6, 496, 8, 0]), $a([144, 144, 6, 6, 620, 10, 0]), $a([8, 18, 1, 1, 7, 1, 0]), $a([8, 32, 1, 2, 11, 1, 0]), $a([8, 48, 1, 2, 15, 1, 1]), $a([8, 64, 1, 4, 18, 1, 1]), $a([8, 80, 1, 4, 22, 1, 1]), $a([8, 96, 1, 4, 28, 1, 1]), $a([8, 120, 1, 6, 32, 1, 1]), $a([8, 144, 1, 6, 36, 1, 1]), $a([12, 26, 1, 1, 14, 1, 0]), $a([12, 36, 1, 2, 18, 1, 0]), $a([12, 64, 1, 4, 27, 1, 1]), $a([12, 88, 1, 4, 36, 1, 1]), $a([16, 36, 1, 2, 24, 1, 0]), $a([16, 48, 1, 2, 28, 1, 0]), $a([16, 64, 1, 4, 36, 1, 1]), $a([20, 36, 1, 2, 28, 1, 1]), $a([20, 44, 1, 2, 34, 1, 1]), $a([20, 64, 1, 4, 42, 1, 1]), $a([22, 48, 1, 2, 38, 1, 1]), $a([24, 48, 1, 2, 41, 1, 1]), $a([24, 64, 1, 4, 46, 1, 1]), $a([26, 40, 1, 2, 38, 1, 1]), $a([26, 48, 1, 2, 42, 1, 1]), $a([26, 64, 1, 4, 50, 1, 1])]);
  $_.urows = $_.rows;
  $_.ucols = $_.columns;
  $_.fullcws = $a([]);
  var _1N = $_.metrics;
  for (var _1O = 0, _1P = _1N.length; _1O < _1P; _1O++) {
    $_.m = $get(_1N, _1O);
    $_.rows = $get($_.m, 0);
    $_.cols = $get($_.m, 1);
    $_.regh = $get($_.m, 2);
    $_.regv = $get($_.m, 3);
    $_.rscw = $get($_.m, 4);
    $_.rsbl = $get($_.m, 5);
    $_.doly = $get($_.m, 6);
    $_.mrows = $f($_.rows - 2 * $_.regh);
    $_.mcols = $f($_.cols - 2 * $_.regv);
    $_.ncws = $f(~~($_.mrows * $_.mcols / 8) - $_.rscw);
    $_.okay = true;
    if ($_.urows != 0 && $_.urows != $_.rows) {
      $_.okay = false;
    }
    if ($_.ucols != 0 && $_.ucols != $_.cols) {
      $_.okay = false;
    }
    if ($eq($_.format, "square") && $ne($_.rows, $_.cols)) {
      $_.okay = false;
    }
    if ($eq($_.format, "rectangle") && $eq($_.rows, $_.cols)) {
      $_.okay = false;
    }
    if (!$_.dmre && $_.doly == 1) {
      $_.okay = false;
    }
    if ($_.okay) {
      $k[$j++] = Infinity;
      $aload($_.fullcws);
      $k[$j++] = $_.ncws;
      $_.fullcws = $a();
    }
  }
  $k[$j++] = Infinity;
  for (var _24 = 0; _24 < 1558; _24++) {
    $k[$j++] = 1e4;
  }
  $_.numremcws = $a();
  var _26 = $_.fullcws;
  for (var _27 = 0, _28 = _26.length; _27 < _28; _27++) {
    $put($_.numremcws, $get(_26, _27) - 1, 1);
  }
  for (var _2B = 1556; _2B >= 0; _2B -= 1) {
    $_.i = _2B;
    if ($get($_.numremcws, $_.i) != 1) {
      $put($_.numremcws, $_.i, $get($_.numremcws, $_.i + 1) + 1);
    }
  }
  $_.fnc1 = -1;
  $_.prog = -2;
  $_.m05 = -3;
  $_.m06 = -4;
  $_.lC = -5;
  $_.lB = -6;
  $_.lX = -7;
  $_.lT = -8;
  $_.lE = -9;
  $_.unl = -10;
  $_.sapp = -11;
  $_.usft = -12;
  $_.sft1 = -13;
  $_.sft2 = -14;
  $_.sft3 = -15;
  $_.eci = -16;
  $_.pad = -17;
  $_.unlcw = 254;
  $k[$j++] = Infinity;
  for (var _2K = 0; _2K <= 128; _2K += 1) {
    $k[$j++] = _2K;
    $k[$j++] = _2K + 1;
  }
  $k[$j++] = $_.pad;
  $k[$j++] = 129;
  for (var _2M = 0; _2M <= 99; _2M += 1) {
    var _2O = $cvrs($s(2), _2M, 10);
    var _2Q = $strcpy($s(2), "00");
    $puti(_2Q, 2 - _2O.length, _2O);
    $k[$j++] = _2Q;
    $k[$j++] = _2M + 130;
  }
  var _2d = $a([$_.lC, $_.lB, $_.fnc1, $_.sapp, $_.prog, $_.usft, $_.m05, $_.m06, $_.lX, $_.lT, $_.lE, $_.eci]);
  $k[$j++] = 229;
  for (var _2e = 0, _2f = _2d.length; _2e < _2f; _2e++) {
    var _2i = $k[--$j] + 1;
    $k[$j++] = $get(_2d, _2e);
    $k[$j++] = _2i;
    $k[$j++] = _2i;
  }
  $j--;
  $_.Avals = $d();
  $k[$j++] = Infinity;
  var _2k = $_.Avals;
  for (var _2p = _2k.size, _2o = _2k.keys(), _2n = 0; _2n < _2p; _2n++) {
    var _2l = _2o.next().value;
    $k[$j++] = _2l;
    var _2q = Infinity;
    var _2r = _2k.get(_2l);
    $k[$j++] = _2q;
    $k[$j++] = _2r;
    var _2s = $a();
    $k[$j++] = _2s;
  }
  $_.Avals = $d();
  $k[$j++] = Infinity;
  $k[$j++] = $_.sft1;
  $k[$j++] = 0;
  $k[$j++] = $_.sft2;
  $k[$j++] = 1;
  $k[$j++] = $_.sft3;
  $k[$j++] = 2;
  $k[$j++] = 32;
  $k[$j++] = 3;
  for (var _2x = 48; _2x <= 57; _2x += 1) {
    $k[$j++] = _2x;
    $k[$j++] = _2x - 44;
  }
  for (var _2y = 65; _2y <= 90; _2y += 1) {
    $k[$j++] = _2y;
    $k[$j++] = _2y - 51;
  }
  $_.CNvals = $d();
  $k[$j++] = Infinity;
  for (var _30 = 0; _30 <= 31; _30 += 1) {
    $k[$j++] = _30;
    $k[$j++] = _30;
  }
  $_.C1vals = $d();
  $k[$j++] = Infinity;
  for (var _32 = 33; _32 <= 47; _32 += 1) {
    $k[$j++] = _32;
    $k[$j++] = _32 - 33;
  }
  for (var _33 = 58; _33 <= 64; _33 += 1) {
    $k[$j++] = _33;
    $k[$j++] = _33 - 43;
  }
  for (var _34 = 91; _34 <= 95; _34 += 1) {
    $k[$j++] = _34;
    $k[$j++] = _34 - 69;
  }
  $k[$j++] = $_.fnc1;
  $k[$j++] = 27;
  $k[$j++] = $_.usft;
  $k[$j++] = 30;
  $_.C2vals = $d();
  $k[$j++] = Infinity;
  for (var _38 = 96; _38 <= 127; _38 += 1) {
    $k[$j++] = _38;
    $k[$j++] = _38 - 96;
  }
  $_.C3vals = $d();
  $k[$j++] = Infinity;
  var _3A = $_.CNvals;
  for (var _3F = _3A.size, _3E = _3A.keys(), _3D = 0; _3D < _3F; _3D++) {
    var _3B = _3E.next().value;
    $k[$j++] = _3B;
    var _3G = Infinity;
    var _3H = _3A.get(_3B);
    $k[$j++] = _3G;
    $k[$j++] = _3H;
    var _3I = $a();
    $k[$j++] = _3I;
  }
  var _3J = $_.C1vals;
  for (var _3O = _3J.size, _3N = _3J.keys(), _3M = 0; _3M < _3O; _3M++) {
    var _3K = _3N.next().value;
    $k[$j++] = _3K;
    var _3P = Infinity;
    var _3Q = _3J.get(_3K);
    $k[$j++] = _3P;
    $k[$j++] = $get($_.CNvals, $_.sft1);
    $k[$j++] = _3Q;
    var _3U = $a();
    $k[$j++] = _3U;
  }
  var _3V = $_.C2vals;
  for (var _3a = _3V.size, _3Z = _3V.keys(), _3Y = 0; _3Y < _3a; _3Y++) {
    var _3W = _3Z.next().value;
    $k[$j++] = _3W;
    var _3b = Infinity;
    var _3c = _3V.get(_3W);
    $k[$j++] = _3b;
    $k[$j++] = $get($_.CNvals, $_.sft2);
    $k[$j++] = _3c;
    var _3g = $a();
    $k[$j++] = _3g;
  }
  var _3h = $_.C3vals;
  for (var _3m = _3h.size, _3l = _3h.keys(), _3k = 0; _3k < _3m; _3k++) {
    var _3i = _3l.next().value;
    $k[$j++] = _3i;
    var _3n = Infinity;
    var _3o = _3h.get(_3i);
    $k[$j++] = _3n;
    $k[$j++] = $get($_.CNvals, $_.sft3);
    $k[$j++] = _3o;
    var _3s = $a();
    $k[$j++] = _3s;
  }
  $_.Cvals = $d();
  $k[$j++] = Infinity;
  $k[$j++] = $_.sft1;
  $k[$j++] = 0;
  $k[$j++] = $_.sft2;
  $k[$j++] = 1;
  $k[$j++] = $_.sft3;
  $k[$j++] = 2;
  $k[$j++] = 32;
  $k[$j++] = 3;
  for (var _3x = 48; _3x <= 57; _3x += 1) {
    $k[$j++] = _3x;
    $k[$j++] = _3x - 44;
  }
  for (var _3y = 97; _3y <= 122; _3y += 1) {
    $k[$j++] = _3y;
    $k[$j++] = _3y - 83;
  }
  $_.TNvals = $d();
  $k[$j++] = Infinity;
  for (var _40 = 0; _40 <= 31; _40 += 1) {
    $k[$j++] = _40;
    $k[$j++] = _40;
  }
  $_.T1vals = $d();
  $k[$j++] = Infinity;
  for (var _42 = 33; _42 <= 47; _42 += 1) {
    $k[$j++] = _42;
    $k[$j++] = _42 - 33;
  }
  for (var _43 = 58; _43 <= 64; _43 += 1) {
    $k[$j++] = _43;
    $k[$j++] = _43 - 43;
  }
  for (var _44 = 91; _44 <= 95; _44 += 1) {
    $k[$j++] = _44;
    $k[$j++] = _44 - 69;
  }
  $k[$j++] = $_.fnc1;
  $k[$j++] = 27;
  $k[$j++] = $_.usft;
  $k[$j++] = 30;
  $_.T2vals = $d();
  $k[$j++] = Infinity;
  $k[$j++] = 96;
  $k[$j++] = 0;
  for (var _48 = 65; _48 <= 90; _48 += 1) {
    $k[$j++] = _48;
    $k[$j++] = _48 - 64;
  }
  for (var _49 = 123; _49 <= 127; _49 += 1) {
    $k[$j++] = _49;
    $k[$j++] = _49 - 96;
  }
  $_.T3vals = $d();
  $k[$j++] = Infinity;
  var _4B = $_.TNvals;
  for (var _4G = _4B.size, _4F = _4B.keys(), _4E = 0; _4E < _4G; _4E++) {
    var _4C = _4F.next().value;
    $k[$j++] = _4C;
    var _4H = Infinity;
    var _4I = _4B.get(_4C);
    $k[$j++] = _4H;
    $k[$j++] = _4I;
    var _4J = $a();
    $k[$j++] = _4J;
  }
  var _4K = $_.T1vals;
  for (var _4P = _4K.size, _4O = _4K.keys(), _4N = 0; _4N < _4P; _4N++) {
    var _4L = _4O.next().value;
    $k[$j++] = _4L;
    var _4Q = Infinity;
    var _4R = _4K.get(_4L);
    $k[$j++] = _4Q;
    $k[$j++] = $get($_.TNvals, $_.sft1);
    $k[$j++] = _4R;
    var _4V = $a();
    $k[$j++] = _4V;
  }
  var _4W = $_.T2vals;
  for (var _4b = _4W.size, _4a = _4W.keys(), _4Z = 0; _4Z < _4b; _4Z++) {
    var _4X = _4a.next().value;
    $k[$j++] = _4X;
    var _4c = Infinity;
    var _4d = _4W.get(_4X);
    $k[$j++] = _4c;
    $k[$j++] = $get($_.TNvals, $_.sft2);
    $k[$j++] = _4d;
    var _4h = $a();
    $k[$j++] = _4h;
  }
  var _4i = $_.T3vals;
  for (var _4n = _4i.size, _4m = _4i.keys(), _4l = 0; _4l < _4n; _4l++) {
    var _4j = _4m.next().value;
    $k[$j++] = _4j;
    var _4o = Infinity;
    var _4p = _4i.get(_4j);
    $k[$j++] = _4o;
    $k[$j++] = $get($_.TNvals, $_.sft3);
    $k[$j++] = _4p;
    var _4t = $a();
    $k[$j++] = _4t;
  }
  $_.Tvals = $d();
  for (var _4v = 128; _4v <= 255; _4v += 1) {
    $_.i = _4v;
    $k[$j++] = $_.Avals;
    $k[$j++] = $_.i;
    $k[$j++] = Infinity;
    $aload($get($_.Avals, $_.usft));
    $aload($get($_.Avals, $_.i - 128));
    var _54 = $a();
    var _55 = $k[--$j];
    $put($k[--$j], _55, _54);
    $k[$j++] = $_.Cvals;
    $k[$j++] = $_.i;
    $k[$j++] = Infinity;
    $aload($get($_.Cvals, $_.usft));
    $aload($get($_.Cvals, $_.i - 128));
    var _5F = $a();
    var _5G = $k[--$j];
    $put($k[--$j], _5G, _5F);
    $k[$j++] = $_.Tvals;
    $k[$j++] = $_.i;
    $k[$j++] = Infinity;
    $aload($get($_.Tvals, $_.usft));
    $aload($get($_.Tvals, $_.i - 128));
    var _5Q = $a();
    var _5R = $k[--$j];
    $put($k[--$j], _5R, _5Q);
  }
  $k[$j++] = Infinity;
  $k[$j++] = 13;
  $k[$j++] = 0;
  $k[$j++] = 42;
  $k[$j++] = 1;
  $k[$j++] = 62;
  $k[$j++] = 2;
  $k[$j++] = 32;
  $k[$j++] = 3;
  for (var _5T = 48; _5T <= 57; _5T += 1) {
    $k[$j++] = _5T;
    $k[$j++] = _5T - 44;
  }
  for (var _5U = 65; _5U <= 90; _5U += 1) {
    $k[$j++] = _5U;
    $k[$j++] = _5U - 51;
  }
  $_.Xvals = $d();
  $k[$j++] = Infinity;
  var _5W = $_.Xvals;
  for (var _5b = _5W.size, _5a = _5W.keys(), _5Z = 0; _5Z < _5b; _5Z++) {
    var _5X = _5a.next().value;
    $k[$j++] = _5X;
    var _5c = Infinity;
    var _5d = _5W.get(_5X);
    $k[$j++] = _5c;
    $k[$j++] = _5d;
    var _5e = $a();
    $k[$j++] = _5e;
  }
  $_.Xvals = $d();
  $k[$j++] = Infinity;
  for (var _5g = 64; _5g <= 94; _5g += 1) {
    $k[$j++] = _5g;
    $k[$j++] = _5g - 64;
  }
  $k[$j++] = $_.unl;
  $k[$j++] = 31;
  for (var _5i = 32; _5i <= 63; _5i += 1) {
    $k[$j++] = _5i;
    $k[$j++] = _5i;
  }
  $_.Evals = $d();
  $k[$j++] = Infinity;
  var _5k = $_.Evals;
  for (var _5p = _5k.size, _5o = _5k.keys(), _5n = 0; _5n < _5p; _5n++) {
    var _5l = _5o.next().value;
    $k[$j++] = _5l;
    var _5q = Infinity;
    var _5r = _5k.get(_5l);
    $k[$j++] = _5q;
    $k[$j++] = _5r;
    var _5s = $a();
    $k[$j++] = _5s;
  }
  $_.Evals = $d();
  $k[$j++] = Infinity;
  for (var _5u = 0; _5u <= 255; _5u += 1) {
    $k[$j++] = _5u;
    $k[$j++] = _5u;
  }
  $_.Bvals = $d();
  $k[$j++] = Infinity;
  var _5w = $_.Bvals;
  for (var _61 = _5w.size, _60 = _5w.keys(), _5z = 0; _5z < _61; _5z++) {
    var _5x = _60.next().value;
    $k[$j++] = _5x;
    var _62 = Infinity;
    var _63 = _5w.get(_5x);
    $k[$j++] = _62;
    $k[$j++] = _63;
    var _64 = $a();
    $k[$j++] = _64;
  }
  $_.Bvals = $d();
  $_.encvals = $a([$_.Avals, $_.Cvals, $_.Tvals, $_.Xvals, $_.Evals, $_.Bvals]);
  $_.A = 0;
  $_.C = 1;
  $_.T = 2;
  $_.X = 3;
  $_.E = 4;
  $_.B = 5;
  if ($_.raw) {
    $_.cws = $a($_.barcode.length);
    $_.i = 0;
    $_.j = 0;
    for (; ; ) {
      if ($_.i == $_.barcode.length) {
        break;
      }
      $_.cw = $cvi($geti($_.barcode, $_.i + 1, 3));
      $put($_.cws, $_.j, $_.cw);
      $_.i = $_.i + 4;
      $_.j = $_.j + 1;
    }
    $_.cws = $geti($_.cws, 0, $_.j);
  } else {
    var _6Y = /* @__PURE__ */ new Map([
      ["parse", $_.parse],
      ["parsefnc", $_.parsefnc],
      ["eci", true],
      ["FNC1", $_.fnc1],
      ["PROG", $_.prog]
    ]);
    $_.fncvals = _6Y;
    $k[$j++] = "msg";
    $k[$j++] = $_.barcode;
    $k[$j++] = $_.fncvals;
    bwipp_parseinput();
    var _6b = $k[--$j];
    $_[$k[--$j]] = _6b;
    $_.msglen = $_.msg.length;
    if ($_.msglen >= 9) {
      $aload($geti($_.msg, 0, 7));
      var _6h = $k[--$j];
      $k[$j - 1] = _6h == 29;
      var _6j = $k[--$j];
      var _6k = $k[--$j];
      var _6l = $k[--$j];
      var _6m = $k[--$j];
      var _6n = $k[--$j];
      var _6o = $k[--$j];
      if (_6j && _6k == 48 && _6l == 30 && _6m == 62 && _6n == 41 && _6o == 91) {
        $aload($geti($_.msg, $_.msglen - 2, 2));
        var _6s = $k[--$j];
        var _6t = $k[--$j];
        if (_6s == 4 && _6t == 30) {
          if ($get($_.msg, 5) == 53) {
            $k[$j++] = Infinity;
            $k[$j++] = $_.m05;
            $aload($geti($_.msg, 7, $_.msg.length - 9));
            $_.msg = $a();
          } else {
            if ($get($_.msg, 5) == 54) {
              $k[$j++] = Infinity;
              $k[$j++] = $_.m06;
              $aload($geti($_.msg, 7, $_.msg.length - 9));
              $_.msg = $a();
            }
          }
        }
      }
    }
    $_.msglen = $_.msg.length;
    $k[$j++] = Infinity;
    for (var _7A = 0, _7B = $_.msglen; _7A < _7B; _7A++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $_.numD = $a();
    $k[$j++] = Infinity;
    for (var _7E = 0, _7F = $_.msglen; _7E < _7F; _7E++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 9999;
    $_.nextXterm = $a();
    $k[$j++] = Infinity;
    for (var _7I = 0, _7J = $_.msglen; _7I < _7J; _7I++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 9999;
    $_.nextNonX = $a();
    $k[$j++] = Infinity;
    for (var _7M = 0, _7N = $_.msglen; _7M < _7N; _7M++) {
      $k[$j++] = false;
    }
    $k[$j++] = false;
    $_.isECI = $a();
    for (var _7Q = $_.msglen - 1; _7Q >= 0; _7Q -= 1) {
      $_.i = _7Q;
      $_.barchar = $get($_.msg, $_.i);
      if ($_.barchar >= 48 && $_.barchar <= 57) {
        $put($_.numD, $_.i, $get($_.numD, $_.i + 1) + 1);
      }
      if ($_.barchar == 13 || $_.barchar == 42 || $_.barchar == 62) {
        $put($_.nextXterm, $_.i, 0);
      } else {
        $put($_.nextXterm, $_.i, $get($_.nextXterm, $_.i + 1) + 1);
      }
      var _7n = $get($_.Xvals, $_.barchar) !== void 0;
      if (!_7n) {
        $put($_.nextNonX, $_.i, 0);
      } else {
        $put($_.nextNonX, $_.i, $get($_.nextNonX, $_.i + 1) + 1);
      }
      $put($_.isECI, $_.i, $_.barchar <= -1e6);
    }
    $k[$j++] = Infinity;
    var _7y = $_.nextXterm;
    for (var _7z = 0, _80 = _7y.length; _7z < _80; _7z++) {
      var _81 = $get(_7y, _7z);
      $k[$j++] = _81;
      if (_81 > 1e4) {
        $k[$j - 1] = 1e4;
      }
    }
    $_.nextXterm = $a();
    $k[$j++] = Infinity;
    var _83 = $_.nextNonX;
    for (var _84 = 0, _85 = _83.length; _84 < _85; _84++) {
      var _86 = $get(_83, _84);
      $k[$j++] = _86;
      if (_86 > 1e4) {
        $k[$j - 1] = 1e4;
      }
    }
    $_.nextNonX = $a();
    $_.isD = function() {
      $k[$j++] = $_.char >= 48 && $_.char <= 57;
    };
    $_.isC = function() {
      var _8C = $get($_.CNvals, $_.char) !== void 0;
      $k[$j++] = _8C;
    };
    $_.isT = function() {
      var _8F = $get($_.TNvals, $_.char) !== void 0;
      $k[$j++] = _8F;
    };
    $_.isX = function() {
      var _8I = $get($_.Xvals, $_.char) !== void 0;
      $k[$j++] = _8I;
    };
    $_.isE = function() {
      var _8L = $get($_.Evals, $_.char) !== void 0;
      $k[$j++] = _8L;
    };
    $_.isEA = function() {
      $k[$j++] = $_.char > 127;
    };
    $_.isFN = function() {
      $k[$j++] = $_.char < 0;
    };
    $_.XtermFirst = function() {
      var _8O = $k[--$j];
      $k[$j++] = $lt($get($_.nextXterm, _8O), $get($_.nextNonX, _8O));
    };
    $_.lookup = function() {
      $_.ac = 1;
      $_.cc = 2;
      $_.tc = 2;
      $_.xc = 2;
      $_.ec = 2;
      $_.bc = 2.25;
      if ($_.mode == $_.A) {
        $_.ac = 0;
        $_.cc = 1;
        $_.tc = 1;
        $_.xc = 1;
        $_.ec = 1;
        $_.bc = 1.25;
      }
      if ($_.mode == $_.C) {
        $_.cc = 0;
      }
      if ($_.mode == $_.T) {
        $_.tc = 0;
      }
      if ($_.mode == $_.X) {
        $_.xc = 0;
      }
      if ($_.mode == $_.E) {
        $_.ec = 0;
      }
      if ($_.mode == $_.B) {
        $_.bc = 0;
      }
      for (var _8f = 0; _8f < 1; _8f++) {
        if ($get($_.isECI, $_.i)) {
          $k[$j++] = $_.A;
          break;
        }
        if ($_.c40headerlength != -1 && $_.i < $_.c40headerlength) {
          $k[$j++] = $_.C;
          break;
        }
        $_.k = 0;
        for (; ; ) {
          if ($_.i + $_.k == $_.msglen) {
            var _8r = $a(["ac", "cc", "tc", "xc", "ec", "bc"]);
            for (var _8s = 0, _8t = _8r.length; _8s < _8t; _8s++) {
              var _8u = $get(_8r, _8s);
              $_[_8u] = $ceil($_[_8u]);
            }
            var _91 = $a([$_.cc, $_.tc, $_.xc, $_.ec, $_.bc]);
            $k[$j++] = true;
            for (var _92 = 0, _93 = _91.length; _92 < _93; _92++) {
              var _96 = $k[--$j];
              $k[$j++] = _96 && $_.ac <= $get(_91, _92);
            }
            if ($k[--$j]) {
              $k[$j++] = $_.A;
              break;
            }
            var _9E = $a([$_.ac, $_.cc, $_.tc, $_.xc, $_.ec]);
            $k[$j++] = true;
            for (var _9F = 0, _9G = _9E.length; _9F < _9G; _9F++) {
              var _9J = $k[--$j];
              $k[$j++] = _9J && $_.bc < $get(_9E, _9F);
            }
            if ($k[--$j]) {
              $k[$j++] = $_.B;
              break;
            }
            var _9R = $a([$_.ac, $_.cc, $_.tc, $_.xc, $_.bc]);
            $k[$j++] = true;
            for (var _9S = 0, _9T = _9R.length; _9S < _9T; _9S++) {
              var _9W = $k[--$j];
              $k[$j++] = _9W && $_.ec < $get(_9R, _9S);
            }
            if ($k[--$j]) {
              $k[$j++] = $_.E;
              break;
            }
            var _9e = $a([$_.ac, $_.cc, $_.xc, $_.ec, $_.bc]);
            $k[$j++] = true;
            for (var _9f = 0, _9g = _9e.length; _9f < _9g; _9f++) {
              var _9j = $k[--$j];
              $k[$j++] = _9j && $_.tc < $get(_9e, _9f);
            }
            if ($k[--$j]) {
              $k[$j++] = $_.T;
              break;
            }
            var _9r = $a([$_.ac, $_.cc, $_.tc, $_.ec, $_.bc]);
            $k[$j++] = true;
            for (var _9s = 0, _9t = _9r.length; _9s < _9t; _9s++) {
              var _9w = $k[--$j];
              $k[$j++] = _9w && $_.xc < $get(_9r, _9s);
            }
            if ($k[--$j]) {
              $k[$j++] = $_.X;
              break;
            }
            $k[$j++] = $_.C;
            break;
          }
          $_.char = $get($_.msg, $_.i + $_.k);
          $k[$j++] = "ac";
          $k[$j++] = $_.ac;
          $_.isD();
          if ($k[--$j]) {
            var _A6 = $k[--$j];
            $k[$j++] = $f(_A6 + 1 / 2);
          } else {
            $_.isEA();
            if ($k[--$j]) {
              var _A8 = $k[--$j];
              $k[$j++] = $ceil(_A8) + 2;
            } else {
              var _A9 = $k[--$j];
              $k[$j++] = $ceil(_A9) + 1;
            }
          }
          var _AA = $k[--$j];
          $_[$k[--$j]] = _AA;
          $k[$j++] = "cc";
          $k[$j++] = $_.cc;
          $_.isC();
          if ($k[--$j]) {
            var _AE = $k[--$j];
            $k[$j++] = $f(_AE + 0.6666667);
          } else {
            $_.isEA();
            if ($k[--$j]) {
              var _AG = $k[--$j];
              $k[$j++] = $f(_AG + 2.6666667);
            } else {
              var _AH = $k[--$j];
              $k[$j++] = $f(_AH + 1.3333334);
            }
          }
          var _AI = $k[--$j];
          $_[$k[--$j]] = _AI;
          $k[$j++] = "tc";
          $k[$j++] = $_.tc;
          $_.isT();
          if ($k[--$j]) {
            var _AM = $k[--$j];
            $k[$j++] = $f(_AM + 0.6666667);
          } else {
            $_.isEA();
            if ($k[--$j]) {
              var _AO = $k[--$j];
              $k[$j++] = $f(_AO + 2.6666667);
            } else {
              var _AP = $k[--$j];
              $k[$j++] = $f(_AP + 1.3333334);
            }
          }
          var _AQ = $k[--$j];
          $_[$k[--$j]] = _AQ;
          $k[$j++] = "xc";
          $k[$j++] = $_.xc;
          $_.isX();
          if ($k[--$j]) {
            var _AU = $k[--$j];
            $k[$j++] = $f(_AU + 0.6666667);
          } else {
            $_.isEA();
            if ($k[--$j]) {
              var _AW = $k[--$j];
              $k[$j++] = $f(_AW + 4.3333334);
            } else {
              var _AX = $k[--$j];
              $k[$j++] = $f(_AX + 3.3333334);
            }
          }
          var _AY = $k[--$j];
          $_[$k[--$j]] = _AY;
          $k[$j++] = "ec";
          $k[$j++] = $_.ec;
          $_.isE();
          if ($k[--$j]) {
            var _Ac = $k[--$j];
            $k[$j++] = $f(_Ac + 3 / 4);
          } else {
            $_.isEA();
            if ($k[--$j]) {
              var _Ae = $k[--$j];
              $k[$j++] = $f(_Ae + 17 / 4);
            } else {
              var _Af = $k[--$j];
              $k[$j++] = $f(_Af + 13 / 4);
            }
          }
          var _Ag = $k[--$j];
          $_[$k[--$j]] = _Ag;
          $k[$j++] = "bc";
          $k[$j++] = $_.bc;
          $_.isFN();
          if ($k[--$j]) {
            var _Ak = $k[--$j];
            $k[$j++] = _Ak + 4;
          } else {
            var _Al = $k[--$j];
            $k[$j++] = _Al + 1;
          }
          var _Am = $k[--$j];
          $_[$k[--$j]] = _Am;
          if ($_.k >= 4) {
            var _Au = $a([$_.cc, $_.tc, $_.xc, $_.ec, $_.bc]);
            $k[$j++] = true;
            for (var _Av = 0, _Aw = _Au.length; _Av < _Aw; _Av++) {
              var _Az = $k[--$j];
              $k[$j++] = _Az && $_.ac + 1 <= $get(_Au, _Av);
            }
            if ($k[--$j]) {
              $k[$j++] = $_.A;
              break;
            }
            if ($_.bc + 1 <= $_.ac) {
              $k[$j++] = $_.B;
              break;
            }
            var _B9 = $a([$_.cc, $_.tc, $_.xc, $_.ec]);
            $k[$j++] = true;
            for (var _BA = 0, _BB = _B9.length; _BA < _BB; _BA++) {
              var _BE = $k[--$j];
              $k[$j++] = _BE && $_.bc + 1 < $get(_B9, _BA);
            }
            if ($k[--$j]) {
              $k[$j++] = $_.B;
              break;
            }
            var _BM = $a([$_.ac, $_.cc, $_.tc, $_.xc, $_.bc]);
            $k[$j++] = true;
            for (var _BN = 0, _BO = _BM.length; _BN < _BO; _BN++) {
              var _BR = $k[--$j];
              $k[$j++] = _BR && $_.ec + 1 < $get(_BM, _BN);
            }
            if ($k[--$j]) {
              $k[$j++] = $_.E;
              break;
            }
            var _BZ = $a([$_.ac, $_.cc, $_.xc, $_.ec, $_.bc]);
            $k[$j++] = true;
            for (var _Ba = 0, _Bb = _BZ.length; _Ba < _Bb; _Ba++) {
              var _Be = $k[--$j];
              $k[$j++] = _Be && $_.tc + 1 < $get(_BZ, _Ba);
            }
            if ($k[--$j]) {
              $k[$j++] = $_.T;
              break;
            }
            var _Bm = $a([$_.ac, $_.cc, $_.tc, $_.ec, $_.bc]);
            $k[$j++] = true;
            for (var _Bn = 0, _Bo = _Bm.length; _Bn < _Bo; _Bn++) {
              var _Br = $k[--$j];
              $k[$j++] = _Br && $_.xc + 1 < $get(_Bm, _Bn);
            }
            if ($k[--$j]) {
              $k[$j++] = $_.X;
              break;
            }
            var _By = $a([$_.ac, $_.tc, $_.ec, $_.bc]);
            $k[$j++] = true;
            for (var _Bz = 0, _C0 = _By.length; _Bz < _C0; _Bz++) {
              var _C3 = $k[--$j];
              $k[$j++] = _C3 && $_.cc + 1 < $get(_By, _Bz);
            }
            if ($k[--$j]) {
              if ($_.cc < $_.xc) {
                $k[$j++] = $_.C;
                break;
              }
              if ($_.cc == $_.xc) {
                $k[$j++] = $_.i + $_.k + 1;
                $_.XtermFirst();
                if ($k[--$j]) {
                  $k[$j++] = $_.X;
                  break;
                } else {
                  $k[$j++] = $_.C;
                  break;
                }
              }
            }
          }
          $_.k = $_.k + 1;
        }
      }
    };
    $_.addtocws = function() {
      var _CG = $k[--$j];
      $puti($_.cws, $_.j, _CG);
      $_.j = _CG.length + $_.j;
    };
    $_.ECItocws = function() {
      var _CL = -$k[--$j] - 1e6;
      $k[$j++] = _CL;
      if (_CL <= 126) {
        var _CM = $k[--$j];
        $k[$j++] = _CM + 1;
        $astore($a(1));
      } else {
        var _CO = $k[$j - 1];
        if (_CO <= 16382) {
          var _CQ = $k[--$j] - 127;
          $k[$j++] = ~~(_CQ / 254) + 128;
          $k[$j++] = _CQ % 254 + 1;
          $astore($a(2));
        } else {
          var _CT = $k[--$j] - 16383;
          $k[$j++] = ~~(_CT / 64516) + 192;
          $k[$j++] = ~~(_CT / 254) % 254 + 1;
          $k[$j++] = _CT % 254 + 1;
          $astore($a(3));
        }
      }
    };
    $_.encA = function() {
      for (var _CV = 0; _CV < 1; _CV++) {
        if ($get($_.isECI, $_.i)) {
          $k[$j++] = $get($_.Avals, $_.eci);
          $_.addtocws();
          $k[$j++] = $get($_.msg, $_.i);
          $_.ECItocws();
          $_.addtocws();
          $_.i = $_.i + 1;
          break;
        }
        if ($get($_.numD, $_.i) >= 2) {
          var _Cj = $s(2);
          $put(_Cj, 0, $get($_.msg, $_.i));
          $put(_Cj, 1, $get($_.msg, $_.i + 1));
          $k[$j++] = $get($_.Avals, _Cj);
          $_.addtocws();
          $_.i = $_.i + 2;
          break;
        }
        $k[$j++] = "newmode";
        $_.lookup();
        var _Ct = $k[--$j];
        $_[$k[--$j]] = _Ct;
        if ($_.newmode != $_.mode) {
          $k[$j++] = $get($_.Avals, $get($a([-1, $_.lC, $_.lT, $_.lX, $_.lE, $_.lB]), $_.newmode));
          $_.addtocws();
          $_.mode = $_.newmode;
          break;
        }
        $k[$j++] = $get($_.Avals, $get($_.msg, $_.i));
        $_.addtocws();
        $_.i = $_.i + 1;
        break;
      }
    };
    $_.CTXvalstocws = function() {
      $_.in = $k[--$j];
      $k[$j++] = Infinity;
      for (var _DH = 0, _DG = $_.in.length - 1; _DH <= _DG; _DH += 3) {
        var _DJ = $geti($_.in, _DH, 3);
        $k[$j++] = 0;
        for (var _DK = 0, _DL = _DJ.length; _DK < _DL; _DK++) {
          var _DN = $k[--$j];
          $k[$j++] = $f(_DN + $get(_DJ, _DK)) * 40;
        }
        var _DP = ~~($k[--$j] / 40) + 1;
        $k[$j++] = ~~(_DP / 256);
        $k[$j++] = _DP % 256;
      }
      $astore($a($counttomark()));
      var _DS = $k[--$j];
      $k[$j - 1] = _DS;
    };
    $_.encCTX = function() {
      $_.p = 0;
      $_.ctxvals = $a(2500);
      $_.done = false;
      for (; ; ) {
        if ($_.i == $_.msglen) {
          break;
        }
        var _Dd = $get($get($_.encvals, $_.mode), $get($_.msg, $_.i)) !== void 0;
        if (!_Dd) {
          break;
        }
        if ($_.p % 3 == 0) {
          if ($_.p > 0) {
            $k[$j++] = "newmode";
            $_.lookup();
            var _Dg = $k[--$j];
            $_[$k[--$j]] = _Dg;
            if ($ne($_.newmode, $_.mode)) {
              $k[$j++] = $geti($_.ctxvals, 0, $_.p);
              $_.CTXvalstocws();
              $_.addtocws();
              $k[$j++] = $a([$_.unlcw]);
              $_.addtocws();
              if ($_.newmode != $_.A) {
                $k[$j++] = $get($_.Avals, $get($a([-1, $_.lC, $_.lT, $_.lX, $_.lE, $_.lB]), $_.newmode));
                $_.addtocws();
              }
              $_.mode = $_.newmode;
              $_.done = true;
              break;
            }
          }
          if ($_.msglen - $_.i <= 3) {
            $_.remcws = $get($_.numremcws, $_.j + ~~($_.p / 3) * 2);
            $k[$j++] = Infinity;
            var _EC = $geti($_.msg, $_.i, $_.msglen - $_.i);
            for (var _ED = 0, _EE = _EC.length; _ED < _EE; _ED++) {
              var _EF = $get(_EC, _ED);
              var _EJ = $get($get($_.encvals, $_.mode), _EF) !== void 0;
              $k[$j++] = _EF;
              if (_EJ) {
                $aload($get($get($_.encvals, $_.mode), $k[--$j]));
              } else {
                $k[$j - 1] = -1;
                $k[$j++] = -1;
                $k[$j++] = -1;
                $k[$j++] = -1;
              }
            }
            $_.remvals = $a();
            if ($_.remcws == 2 && $_.remvals.length == 3) {
              $k[$j++] = Infinity;
              $aload($geti($_.ctxvals, 0, $_.p));
              $aload($_.remvals);
              var _EW = $a();
              $k[$j++] = _EW;
              $_.CTXvalstocws();
              $_.addtocws();
              $_.mode = $_.A;
              $_.i = $_.msglen;
              $_.done = true;
              break;
            }
            if ($_.remcws == 2 && $_.remvals.length == 2 && $_.mode != $_.X) {
              $k[$j++] = Infinity;
              $aload($geti($_.ctxvals, 0, $_.p));
              $aload($_.remvals);
              $aload($get($get($_.encvals, $_.mode), $_.sft1));
              var _Em = $a();
              $k[$j++] = _Em;
              $_.CTXvalstocws();
              $_.addtocws();
              $_.mode = $_.A;
              $_.i = $_.msglen;
              $_.done = true;
              break;
            }
            if ($_.remcws == 2 && $_.remvals.length == 1) {
              $k[$j++] = $geti($_.ctxvals, 0, $_.p);
              $_.CTXvalstocws();
              $_.addtocws();
              $k[$j++] = $a([$_.unlcw]);
              $_.addtocws();
              $k[$j++] = $get($_.Avals, $get($_.msg, $_.i));
              $_.addtocws();
              $_.mode = $_.A;
              $_.i = $_.msglen;
              $_.done = true;
              break;
            }
            if ($_.remcws == 1 && $_.remvals.length == 1) {
              $k[$j++] = $geti($_.ctxvals, 0, $_.p);
              $_.CTXvalstocws();
              $_.addtocws();
              $k[$j++] = $get($_.Avals, $get($_.msg, $_.i));
              $_.addtocws();
              $_.mode = $_.A;
              $_.i = $_.msglen;
              $_.done = true;
              break;
            }
          }
        }
        var _FL = $get($get($_.encvals, $_.mode), $get($_.msg, $_.i));
        $puti($_.ctxvals, $_.p, _FL);
        $_.p = _FL.length + $_.p;
        $_.i = $_.i + 1;
      }
      if (!$_.done) {
        for (; ; ) {
          if ($_.p % 3 == 0) {
            break;
          }
          $_.i = $_.i - 1;
          $_.p = $_.p - $get($get($_.encvals, $_.mode), $get($_.msg, $_.i)).length;
        }
        $k[$j++] = Infinity;
        $aload($geti($_.ctxvals, 0, $_.p));
        var _Fe = $a();
        $k[$j++] = _Fe;
        $_.CTXvalstocws();
        $_.addtocws();
        $k[$j++] = $a([$_.unlcw]);
        $_.addtocws();
        $_.mode = $_.A;
        if ($_.i != $_.msglen && !$get($_.isECI, $_.i)) {
          if ($get($_.numD, $_.i) >= 2) {
            var _Fq = $s(2);
            $put(_Fq, 0, $get($_.msg, $_.i));
            $put(_Fq, 1, $get($_.msg, $_.i + 1));
            $k[$j++] = $get($_.Avals, _Fq);
            $_.addtocws();
            $_.i = $_.i + 2;
          } else {
            $k[$j++] = $get($_.Avals, $get($_.msg, $_.i));
            $_.addtocws();
            $_.i = $_.i + 1;
          }
        }
      }
    };
    $_.Evalstocws = function() {
      $_.in = $k[--$j];
      $_.inlen = $_.in.length;
      $_.outlen = ~~$ceil($_.in.length / 4 * 3);
      $k[$j++] = Infinity;
      $aload($_.in);
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $_.in = $a();
      $k[$j++] = Infinity;
      for (var _GD = 0, _GC = $_.inlen - 1; _GD <= _GC; _GD += 4) {
        var _GF = $geti($_.in, _GD, 4);
        $k[$j++] = 0;
        for (var _GG = 0, _GH = _GF.length; _GG < _GH; _GG++) {
          var _GJ = $k[--$j];
          $k[$j++] = $or(_GJ, $get(_GF, _GG)) << 6;
        }
        var _GL = $k[--$j] >>> 6;
        $k[$j++] = _GL >>> 16 & 255;
        $k[$j++] = _GL >>> 8 & 255;
        $k[$j++] = _GL & 255;
      }
      $astore($a($counttomark()));
      var _GO = $k[--$j];
      $k[$j - 1] = _GO;
      var _GS = $geti($k[--$j], 0, $_.outlen);
      $k[$j++] = _GS;
    };
    $_.encE = function() {
      $_.p = 0;
      $_.edifactvals = $a(2100);
      for (; ; ) {
        if ($_.i == $_.msglen) {
          break;
        }
        var _Ga = $get($_.Evals, $get($_.msg, $_.i)) !== void 0;
        if (!_Ga) {
          break;
        }
        if ($_.p % 4 == 0) {
          if ($_.msglen - $_.i <= 2) {
            $_.remcws = $get($_.numremcws, $_.j + ~~($_.p / 4) * 3);
            $k[$j++] = Infinity;
            var _Gm = $geti($_.msg, $_.i, $_.msglen - $_.i);
            for (var _Gn = 0, _Go = _Gm.length; _Gn < _Go; _Gn++) {
              $aload($get($_.Avals, $get(_Gm, _Gn)));
            }
            $_.remvals = $a();
            if (($_.remcws == 1 || $_.remcws == 2) && $_.remvals.length <= $_.remcws) {
              $k[$j++] = $geti($_.edifactvals, 0, $_.p);
              $_.Evalstocws();
              $_.addtocws();
              $k[$j++] = $_.remvals;
              $_.addtocws();
              $_.mode = $_.A;
              $_.i = $_.msglen;
              break;
            }
          }
          $_.lookup();
          if ($k[--$j] != $_.mode) {
            break;
          }
        }
        var _H9 = $get($_.Evals, $get($_.msg, $_.i));
        $puti($_.edifactvals, $_.p, _H9);
        $_.p = _H9.length + $_.p;
        $_.i = $_.i + 1;
      }
      if ($_.mode != $_.A) {
        $_.remcws = $get($_.numremcws, $_.j + ~~($_.p / 4) * 3 - 1) - 1;
        if ($_.p % 4 != 0 || $_.i != $_.msglen || $_.remcws >= 3) {
          var _HQ = $get($_.Evals, $_.unl);
          $puti($_.edifactvals, $_.p, _HQ);
          $_.p = _HQ.length + $_.p;
        }
        $k[$j++] = $geti($_.edifactvals, 0, $_.p);
        $_.Evalstocws();
        $_.addtocws();
        $_.mode = $_.A;
        if ($_.i != $_.msglen && !$get($_.isECI, $_.i)) {
          if ($get($_.numD, $_.i) >= 2) {
            var _Hg = $s(2);
            $put(_Hg, 0, $get($_.msg, $_.i));
            $put(_Hg, 1, $get($_.msg, $_.i + 1));
            $k[$j++] = $get($_.Avals, _Hg);
            $_.addtocws();
            $_.i = $_.i + 2;
          } else {
            $k[$j++] = $get($_.Avals, $get($_.msg, $_.i));
            $_.addtocws();
            $_.i = $_.i + 1;
          }
        }
      }
    };
    $_.encB = function() {
      $_.p = 0;
      $_.bvals = $a(1558);
      for (; ; ) {
        if ($_.i == $_.msglen) {
          break;
        }
        $_.lookup();
        if ($k[--$j] != $_.mode) {
          break;
        }
        $put($_.bvals, $_.p, $get($_.msg, $_.i));
        $_.p = $_.p + 1;
        $_.i = $_.i + 1;
      }
      $_.remcws = $get($_.numremcws, $_.j + $_.p) - 1;
      $k[$j++] = Infinity;
      if ($_.remcws == 0 && $_.i == $_.msglen) {
        $k[$j++] = 0;
      } else {
        if ($_.p < 250) {
          $k[$j++] = $_.p;
        } else {
          $k[$j++] = ~~($_.p / 250) + 249;
          $k[$j++] = $_.p % 250;
        }
      }
      $aload($geti($_.bvals, 0, $_.p));
      $_.bvals = $a();
      for (var _IP = 0, _IO = $_.bvals.length - 1; _IP <= _IO; _IP += 1) {
        $_.p = _IP;
        var _IV = $f(($_.j + $_.p + 1) * 149 % 255 + 1 + $get($_.bvals, $_.p));
        $k[$j++] = _IV;
        if (_IV >= 256) {
          var _IW = $k[--$j];
          $k[$j++] = _IW - 256;
        }
        $put($_.bvals, $_.p, $k[--$j]);
      }
      $k[$j++] = $_.bvals;
      $_.addtocws();
      $_.mode = $_.A;
    };
    $_.cws = $a(1558);
    $_.mode = $_.A;
    $_.i = 0;
    $_.j = 0;
    for (; ; ) {
      if ($_.i >= $_.msglen) {
        break;
      }
      if ($_[$get($a(["encA", "encCTX", "encCTX", "encCTX", "encE", "encB"]), $_.mode)]() === true) {
        break;
      }
    }
    $_.cws = $geti($_.cws, 0, $_.j);
  }
  $_.datlen = $_.cws.length;
  $_.remcws = $get($_.numremcws, $_.j - 1) - 1;
  if ($_.remcws > 0) {
    $k[$j++] = Infinity;
    $aload($_.cws);
    for (var _Iu = 0, _Iv = $_.remcws; _Iu < _Iv; _Iu++) {
      $k[$j++] = 129;
    }
    $_.cws = $a();
    for (var _J1 = $_.datlen + 1, _J0 = $f($_.datlen + $_.remcws) - 1; _J1 <= _J0; _J1 += 1) {
      $_.i = _J1;
      var _J3 = ($_.i + 1) * 149 % 253 + 1 + 129;
      $k[$j++] = _J3;
      if (_J3 > 254) {
        var _J4 = $k[--$j];
        $k[$j++] = _J4 - 254;
      }
      $put($_.cws, $_.i, $k[--$j]);
    }
  }
  var _J9 = $get($_.options, "debugcws") !== void 0;
  if (_J9) {
    $k[$j++] = "bwipp.debugcws#20411";
    $k[$j++] = $_.cws;
    bwipp_raiseerror();
  }
  var _JB = $_.metrics;
  for (var _JC = 0, _JD = _JB.length; _JC < _JD; _JC++) {
    $_.m = $get(_JB, _JC);
    $_.rows = $get($_.m, 0);
    $_.cols = $get($_.m, 1);
    $_.regh = $get($_.m, 2);
    $_.regv = $get($_.m, 3);
    $_.rscw = $get($_.m, 4);
    $_.rsbl = $get($_.m, 5);
    $_.doly = $get($_.m, 6);
    $_.mrows = $f($_.rows - 2 * $_.regh);
    $_.mcols = $f($_.cols - 2 * $_.regv);
    $_.rrows = ~~($_.mrows / $_.regh);
    $_.rcols = ~~($_.mcols / $_.regv);
    $_.ncws = $f(~~($_.mrows * $_.mcols / 8) - $_.rscw);
    $_.okay = true;
    if ($_.cws.length != $_.ncws) {
      $_.okay = false;
    }
    if ($_.urows != 0 && $_.urows != $_.rows) {
      $_.okay = false;
    }
    if ($_.ucols != 0 && $_.ucols != $_.cols) {
      $_.okay = false;
    }
    if ($eq($_.format, "square") && $ne($_.rows, $_.cols)) {
      $_.okay = false;
    }
    if ($eq($_.format, "rectangle") && $eq($_.rows, $_.cols)) {
      $_.okay = false;
    }
    if (!$_.dmre && $_.doly == 1) {
      $_.okay = false;
    }
    if ($_.okay) {
      break;
    }
  }
  if (!$_.okay) {
    $k[$j++] = "bwipp.datamatrixNoValidSymbol#20439";
    $k[$j++] = "Maximum length exceeded or invalid size";
    bwipp_raiseerror();
  }
  $_.cwbs = $a($_.rsbl);
  $_.ecbs = $a($_.rsbl);
  for (var _K2 = 0, _K1 = $_.rsbl - 1; _K2 <= _K1; _K2 += 1) {
    $_.i = _K2;
    if ($_.cws.length != 1558) {
      $_.cwbsize = ~~($_.cws.length / $_.rsbl);
    } else {
      if ($_.i <= 7) {
        $_.cwbsize = 156;
      } else {
        $_.cwbsize = 155;
      }
    }
    $_.cwb = $a($_.cwbsize);
    for (var _KB = 0, _KA = $_.cwbsize - 1; _KB <= _KA; _KB += 1) {
      $_.j = _KB;
      $put($_.cwb, $_.j, $get($_.cws, $f($_.j * $_.rsbl + $_.i)));
    }
    $put($_.cwbs, $_.i, $_.cwb);
    $k[$j++] = $_.ecbs;
    $k[$j++] = $_.i;
    $k[$j++] = Infinity;
    for (var _KQ = 0, _KR = ~~($_.rscw / $_.rsbl); _KQ < _KR; _KQ++) {
      $k[$j++] = 0;
    }
    var _KS = $a();
    var _KT = $k[--$j];
    $put($k[--$j], _KT, _KS);
  }
  $k[$j++] = Infinity;
  $k[$j++] = 1;
  for (var _KV = 0; _KV < 255; _KV++) {
    var _KW = $k[$j - 1];
    var _KX = _KW * 2;
    $k[$j++] = _KX;
    if (_KX >= 256) {
      var _KY = $k[--$j];
      $k[$j++] = _KY ^ 301;
    }
  }
  $_.rsalog = $a();
  $_.rslog = $a(256);
  for (var _Kb = 1; _Kb <= 255; _Kb += 1) {
    $put($_.rslog, $get($_.rsalog, _Kb), _Kb);
  }
  $_.rsprod = function() {
    var _Kg = $k[$j - 1];
    var _Kh = $k[$j - 2];
    if (_Kg != 0 && _Kh != 0) {
      var _Kk = $get($_.rslog, $k[--$j]);
      var _Kp = $get($_.rsalog, $f(_Kk + $get($_.rslog, $k[--$j])) % 255);
      $k[$j++] = _Kp;
    } else {
      $j -= 2;
      $k[$j++] = 0;
    }
  };
  $k[$j++] = Infinity;
  $k[$j++] = 1;
  for (var _Ks = 0, _Kt = ~~($_.rscw / $_.rsbl); _Ks < _Kt; _Ks++) {
    $k[$j++] = 0;
  }
  $_.coeffs = $a();
  for (var _Ky = 1, _Kx = ~~($_.rscw / $_.rsbl); _Ky <= _Kx; _Ky += 1) {
    $_.i = _Ky;
    $put($_.coeffs, $_.i, $get($_.coeffs, $_.i - 1));
    for (var _L5 = $_.i - 1; _L5 >= 1; _L5 -= 1) {
      $_.j = _L5;
      $k[$j++] = $_.coeffs;
      $k[$j++] = $_.j;
      $k[$j++] = $get($_.coeffs, $_.j - 1);
      $k[$j++] = $get($_.coeffs, $_.j);
      $k[$j++] = $get($_.rsalog, $_.i);
      $_.rsprod();
      var _LH = $k[--$j];
      var _LI = $k[--$j];
      var _LJ = $k[--$j];
      $put($k[--$j], _LJ, $xo(_LI, _LH));
    }
    $k[$j++] = $_.coeffs;
    $k[$j++] = 0;
    $k[$j++] = $get($_.coeffs, 0);
    $k[$j++] = $get($_.rsalog, $_.i);
    $_.rsprod();
    var _LR = $k[--$j];
    var _LS = $k[--$j];
    $put($k[--$j], _LS, _LR);
  }
  $_.coeffs = $geti($_.coeffs, 0, $_.coeffs.length - 1);
  for (var _LZ = 0, _LY = $_.cwbs.length - 1; _LZ <= _LY; _LZ += 1) {
    $_.i = _LZ;
    $_.cwb = $get($_.cwbs, $_.i);
    $_.ecb = $get($_.ecbs, $_.i);
    for (var _Li = 0, _Lh = $_.cwb.length - 1; _Li <= _Lh; _Li += 1) {
      $_.t = $xo($get($_.cwb, _Li), $get($_.ecb, 0));
      for (var _Lo = $_.ecb.length - 1; _Lo >= 0; _Lo -= 1) {
        $_.j = _Lo;
        $_.p = $_.ecb.length - $_.j - 1;
        $k[$j++] = $_.ecb;
        $k[$j++] = $_.p;
        $k[$j++] = $_.t;
        $k[$j++] = $get($_.coeffs, $_.j);
        $_.rsprod();
        var _Lx = $k[--$j];
        var _Ly = $k[--$j];
        $put($k[--$j], _Ly, _Lx);
        if ($_.j > 0) {
          $put($_.ecb, $_.p, $xo($get($_.ecb, $_.p + 1), $get($_.ecb, $_.p)));
        }
      }
    }
  }
  if ($_.ncws == 1558) {
    $k[$j++] = Infinity;
    $aload($geti($_.ecbs, 8, 2));
    $aload($geti($_.ecbs, 0, 8));
    $_.ecbs = $a();
  }
  $k[$j++] = Infinity;
  $aload($_.cws);
  for (var _MH = 0, _MI = $_.rscw; _MH < _MI; _MH++) {
    $k[$j++] = 0;
  }
  $_.cws = $a();
  for (var _MM = 0, _ML = $_.rscw - 1; _MM <= _ML; _MM += 1) {
    $_.i = _MM;
    $put($_.cws, $f($_.ncws + $_.i), $get($get($_.ecbs, $_.i % $_.rsbl), ~~($_.i / $_.rsbl)));
  }
  $_.module = function() {
    $r(4, -1);
    var _MY = $strcpy($s(8), "00000000");
    $k[$j++] = _MY;
    $k[$j++] = _MY;
    var _Mb = $cvrs($s(8), $k[$j - 3], 2);
    $puti($k[$j - 1], 8 - _Mb.length, _Mb);
    $k[$j - 3] = $k[$j - 2];
    $j -= 2;
    for (var _Md = 7; _Md >= 0; _Md -= 1) {
      var _Me = $k[--$j];
      $k[$j++] = $get(_Me, _Md) - 48;
      $k[$j++] = _Me;
    }
    $j--;
    $r(11, -3);
    $forall($k[--$j], function() {
      if ($k[--$j]() === true) {
        return true;
      }
      var _Mj = $k[$j - 2];
      if (_Mj < 0) {
        var _Mk = $k[--$j];
        var _Ml = $k[--$j];
        $k[$j++] = $f(_Ml + $_.mrows);
        $k[$j++] = $f(_Mk + (4 - ($_.mrows + 4) % 8));
      }
      var _Mo = $k[$j - 1];
      if (_Mo < 0) {
        var _Mq = $k[--$j];
        var _Mr = $k[--$j];
        $k[$j++] = $f(_Mr + (4 - ($_.mcols + 4) % 8));
        $k[$j++] = $f(_Mq + $_.mcols);
      }
      var _Mu = $k[$j - 2];
      if (_Mu >= $_.mrows) {
        var _Mw = $k[--$j];
        var _Mx = $k[--$j];
        $k[$j++] = $f(_Mx - $_.mrows);
        $k[$j++] = _Mw;
      }
      var _Mz = $k[--$j];
      var _N0 = $k[--$j];
      $k[$j++] = $_.mmat;
      $k[$j++] = $f(_Mz + _N0 * $_.mcols);
      $r(5, -1);
      var _N3 = $k[--$j];
      var _N4 = $k[--$j];
      $put($k[--$j], _N4, _N3);
    });
  };
  var _NM = $a([function() {
    var _N6 = $k[$j - 1];
    var _N7 = $k[$j - 2];
    $k[$j++] = _N7 - 2;
    $k[$j++] = _N6 - 2;
  }, function() {
    var _N8 = $k[$j - 1];
    var _N9 = $k[$j - 2];
    $k[$j++] = _N9 - 2;
    $k[$j++] = _N8 - 1;
  }, function() {
    var _NA = $k[$j - 1];
    var _NB = $k[$j - 2];
    $k[$j++] = _NB - 1;
    $k[$j++] = _NA - 2;
  }, function() {
    var _NC = $k[$j - 1];
    var _ND = $k[$j - 2];
    $k[$j++] = _ND - 1;
    $k[$j++] = _NC - 1;
  }, function() {
    var _NE = $k[$j - 1];
    var _NF = $k[$j - 2];
    $k[$j++] = _NF - 1;
    $k[$j++] = _NE;
  }, function() {
    var _NG = $k[$j - 1];
    var _NH = $k[$j - 2];
    $k[$j++] = _NH;
    $k[$j++] = _NG - 2;
  }, function() {
    var _NI = $k[$j - 1];
    var _NJ = $k[$j - 2];
    $k[$j++] = _NJ;
    $k[$j++] = _NI - 1;
  }, function() {
    var _NK = $k[$j - 1];
    var _NL = $k[$j - 2];
    $k[$j++] = _NL;
    $k[$j++] = _NK;
  }]);
  $_.dmn = _NM;
  var _NV = $a([function() {
    $k[$j++] = $_.mrows - 1;
    $k[$j++] = 0;
  }, function() {
    $k[$j++] = $_.mrows - 1;
    $k[$j++] = 1;
  }, function() {
    $k[$j++] = $_.mrows - 1;
    $k[$j++] = 2;
  }, function() {
    $k[$j++] = 0;
    $k[$j++] = $_.mcols - 2;
  }, function() {
    $k[$j++] = 0;
    $k[$j++] = $_.mcols - 1;
  }, function() {
    $k[$j++] = 1;
    $k[$j++] = $_.mcols - 1;
  }, function() {
    $k[$j++] = 2;
    $k[$j++] = $_.mcols - 1;
  }, function() {
    $k[$j++] = 3;
    $k[$j++] = $_.mcols - 1;
  }]);
  $_.dmc1 = _NV;
  var _Ne = $a([function() {
    $k[$j++] = $_.mrows - 3;
    $k[$j++] = 0;
  }, function() {
    $k[$j++] = $_.mrows - 2;
    $k[$j++] = 0;
  }, function() {
    $k[$j++] = $_.mrows - 1;
    $k[$j++] = 0;
  }, function() {
    $k[$j++] = 0;
    $k[$j++] = $_.mcols - 4;
  }, function() {
    $k[$j++] = 0;
    $k[$j++] = $_.mcols - 3;
  }, function() {
    $k[$j++] = 0;
    $k[$j++] = $_.mcols - 2;
  }, function() {
    $k[$j++] = 0;
    $k[$j++] = $_.mcols - 1;
  }, function() {
    $k[$j++] = 1;
    $k[$j++] = $_.mcols - 1;
  }]);
  $_.dmc2 = _Ne;
  var _Nn = $a([function() {
    $k[$j++] = $_.mrows - 3;
    $k[$j++] = 0;
  }, function() {
    $k[$j++] = $_.mrows - 2;
    $k[$j++] = 0;
  }, function() {
    $k[$j++] = $_.mrows - 1;
    $k[$j++] = 0;
  }, function() {
    $k[$j++] = 0;
    $k[$j++] = $_.mcols - 2;
  }, function() {
    $k[$j++] = 0;
    $k[$j++] = $_.mcols - 1;
  }, function() {
    $k[$j++] = 1;
    $k[$j++] = $_.mcols - 1;
  }, function() {
    $k[$j++] = 2;
    $k[$j++] = $_.mcols - 1;
  }, function() {
    $k[$j++] = 3;
    $k[$j++] = $_.mcols - 1;
  }]);
  $_.dmc3 = _Nn;
  var _Nx = $a([function() {
    $k[$j++] = $_.mrows - 1;
    $k[$j++] = 0;
  }, function() {
    $k[$j++] = $_.mrows - 1;
    $k[$j++] = $_.mcols - 1;
  }, function() {
    $k[$j++] = 0;
    $k[$j++] = $_.mcols - 3;
  }, function() {
    $k[$j++] = 0;
    $k[$j++] = $_.mcols - 2;
  }, function() {
    $k[$j++] = 0;
    $k[$j++] = $_.mcols - 1;
  }, function() {
    $k[$j++] = 1;
    $k[$j++] = $_.mcols - 3;
  }, function() {
    $k[$j++] = 1;
    $k[$j++] = $_.mcols - 2;
  }, function() {
    $k[$j++] = 1;
    $k[$j++] = $_.mcols - 1;
  }]);
  $_.dmc4 = _Nx;
  $k[$j++] = Infinity;
  for (var _O0 = 0, _O1 = $_.mrows * $_.mcols; _O0 < _O1; _O0++) {
    $k[$j++] = -1;
  }
  $_.mmat = $a();
  for (var _O4 = $_.cws.length - 1; _O4 >= 0; _O4 -= 1) {
    $k[$j++] = $get($_.cws, _O4);
  }
  $k[$j++] = 4;
  $k[$j++] = 0;
  for (; ; ) {
    var _O7 = $k[$j - 1];
    var _O8 = $k[$j - 2];
    if (_O7 == 0 && _O8 == $_.mrows) {
      $k[$j++] = $_.dmc1;
      $_.module();
    }
    var _OB = $k[$j - 1];
    var _OC = $k[$j - 2];
    if (_OB == 0 && _OC == $_.mrows - 2 && $_.mcols % 4 != 0) {
      $k[$j++] = $_.dmc2;
      $_.module();
    }
    var _OG = $k[$j - 1];
    var _OH = $k[$j - 2];
    if (_OG == 0 && _OH == $_.mrows - 2 && $_.mcols % 8 == 4) {
      $k[$j++] = $_.dmc3;
      $_.module();
    }
    var _OL = $k[$j - 1];
    var _OM = $k[$j - 2];
    if (_OL == 2 && _OM == $_.mrows + 4 && $_.mcols % 8 == 0) {
      $k[$j++] = $_.dmc4;
      $_.module();
    }
    for (; ; ) {
      var _OQ = $k[$j - 1];
      var _OR = $k[$j - 2];
      if (_OQ >= 0 && _OR < $_.mrows) {
        var _OT = $k[$j - 1];
        var _OU = $k[$j - 2];
        if ($get($_.mmat, $f(_OT + _OU * $_.mcols)) == -1) {
          $k[$j++] = $_.dmn;
          $_.module();
        }
      }
      var _OZ = $k[--$j];
      var _Oa = $k[--$j];
      $k[$j++] = _Oa - 2;
      $k[$j++] = _OZ + 2;
      if (!(_OZ + 2 < $_.mcols && _Oa - 2 >= 0)) {
        break;
      }
    }
    var _Oc = $k[--$j];
    var _Od = $k[--$j];
    $k[$j++] = _Od + 1;
    $k[$j++] = _Oc + 3;
    for (; ; ) {
      var _Oe = $k[$j - 1];
      var _Of = $k[$j - 2];
      if (_Oe < $_.mcols && _Of >= 0) {
        var _Oh = $k[$j - 1];
        var _Oi = $k[$j - 2];
        if ($get($_.mmat, $f(_Oh + _Oi * $_.mcols)) == -1) {
          $k[$j++] = $_.dmn;
          $_.module();
        }
      }
      var _On = $k[--$j];
      var _Oo = $k[--$j];
      $k[$j++] = _Oo + 2;
      $k[$j++] = _On - 2;
      if (!(_On - 2 >= 0 && _Oo + 2 < $_.mrows)) {
        break;
      }
    }
    var _Oq = $k[--$j];
    var _Or = $k[--$j];
    $k[$j++] = _Or + 3;
    $k[$j++] = _Oq + 1;
    if (!(_Oq + 1 < $_.mcols || _Or + 3 < $_.mrows)) {
      $j -= 2;
      break;
    }
  }
  if ($get($_.mmat, $_.mrows * $_.mcols - 1) == -1) {
    $puti($_.mmat, $_.mrows * ($_.mcols - 1) - 2, $a([1, 0]));
    $puti($_.mmat, $_.mrows * $_.mcols - 2, $a([0, 1]));
  }
  $_.pixs = $a($_.rows * $_.cols);
  $_.cwpos = 0;
  for (var _PB = 0, _PA = $_.rows - 1; _PB <= _PA; _PB += 1) {
    $_.i = _PB;
    if ($_.i % ($_.rrows + 2) == 0) {
      $k[$j++] = $_.pixs;
      $k[$j++] = $_.i * $_.cols;
      $k[$j++] = Infinity;
      for (var _PI = 0, _PJ = ~~($_.cols / 2); _PI < _PJ; _PI++) {
        $k[$j++] = 1;
        $k[$j++] = 0;
      }
      var _PK = $a();
      var _PL = $k[--$j];
      $puti($k[--$j], _PL, _PK);
    }
    if ($_.i % ($_.rrows + 2) == $_.rrows + 1) {
      $k[$j++] = $_.pixs;
      $k[$j++] = $_.i * $_.cols;
      $k[$j++] = Infinity;
      for (var _PU = 0, _PV = $_.cols; _PU < _PV; _PU++) {
        $k[$j++] = 1;
      }
      var _PW = $a();
      var _PX = $k[--$j];
      $puti($k[--$j], _PX, _PW);
    }
    if ($_.i % ($_.rrows + 2) != 0 && $_.i % ($_.rrows + 2) != $_.rrows + 1) {
      for (var _Pg = 0, _Pf = $_.cols - 1; _Pg <= _Pf; _Pg += 1) {
        $_.j = _Pg;
        if ($_.j % ($_.rcols + 2) == 0) {
          $put($_.pixs, $f($_.i * $_.cols + $_.j), 1);
        }
        if ($_.j % ($_.rcols + 2) == $_.rcols + 1) {
          $put($_.pixs, $f($_.i * $_.cols + $_.j), $_.i % 2);
        }
        if ($_.j % ($_.rcols + 2) != 0 && $_.j % ($_.rcols + 2) != $_.rcols + 1) {
          $put($_.pixs, $f($_.i * $_.cols + $_.j), $get($_.mmat, $_.cwpos));
          $_.cwpos = $_.cwpos + 1;
        }
      }
    }
  }
  var _QE = /* @__PURE__ */ new Map([
    ["ren", "renmatrix"],
    ["pixs", $_.pixs],
    ["pixx", $_.cols],
    ["pixy", $_.rows],
    ["height", $_.rows * 2 / 72],
    ["width", $_.cols * 2 / 72],
    ["borderleft", 1],
    ["borderright", 1],
    ["bordertop", 1],
    ["borderbottom", 1],
    ["opt", $_.options]
  ]);
  $k[$j++] = _QE;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_datamatrixrectangular() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $put($_.options, "dontdraw", true);
  $put($_.options, "format", "rectangle");
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_datamatrix();
  var _6 = $k[--$j];
  $_[$k[--$j]] = _6;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_datamatrixrectangularextension() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $put($_.options, "dontdraw", true);
  $put($_.options, "dmre", true);
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_datamatrix();
  var _6 = $k[--$j];
  $_[$k[--$j]] = _6;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_mailmark() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.type = "unset";
  $_.parse = false;
  $_.dontdraw = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  var _3 = /* @__PURE__ */ new Map([
    ["parse", $_.parse],
    ["parseonly", true],
    ["parsefnc", false]
  ]);
  $_.fncvals = _3;
  $k[$j++] = "barcode";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.fncvals;
  bwipp_parseinput();
  var _6 = $k[--$j];
  $_[$k[--$j]] = _6;
  $_.barlen = $_.barcode.length;
  delete $_.options["parse"];
  var _A = $_["type"];
  if ($ne(_A, "7") && ($ne(_A, "9") && $ne(_A, "29"))) {
    $k[$j++] = "bwipp.mailmarkBadType#20820";
    $k[$j++] = "Royal Mail Mailmark type must be 7, 9 or 29";
    bwipp_raiseerror();
  }
  var _B = /* @__PURE__ */ new Map([
    ["7", "24x24"],
    ["9", "32x32"],
    ["29", "16x48"]
  ]);
  $_.version = $get(_B, $_["type"]);
  var _E = /* @__PURE__ */ new Map([
    ["7", "square"],
    ["9", "square"],
    ["29", "rectangle"]
  ]);
  $_.format = $get(_E, $_["type"]);
  if ($_.barcode.length < 45) {
    $k[$j++] = "bwipp.mailmarkBadLength#20836";
    $k[$j++] = "Royal Mail Mailmark must contain at least 45 characters of Mailmark formatted data, including any required space padding";
    bwipp_raiseerror();
  }
  if ($ne($geti($_.barcode, 0, 4), "JGB ")) {
    $k[$j++] = "bwipp.mailmarkBadIndicator#20839";
    $k[$j++] = "Royal Mail Mailmark must begin with JGB<space> identifier";
    bwipp_raiseerror();
  }
  $put($_.options, "dontdraw", true);
  $put($_.options, "version", $_.version);
  $put($_.options, "format", $_.format);
  $put($_.options, "c40headerlength", 45);
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_datamatrix();
  var _S = $k[--$j];
  $_[$k[--$j]] = _S;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_qrcode() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.format = "unset";
  $_.version = "unset";
  $_.eclevel = "unset";
  $_.fixedeclevel = false;
  $_.parse = false;
  $_.parsefnc = false;
  $_.mask = -1;
  $_.suppresskanjimode = true;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length == 0) {
    $k[$j++] = "bwipp.qrcodeEmptyData#20904";
    $k[$j++] = "The data must not be empty";
    bwipp_raiseerror();
  }
  if ($ne($_.version, "unset")) {
    if ($eq($_.format, "unset")) {
      $k[$j++] = "full";
      if ($eq($geti($_.version, 0, 1), "M")) {
        $k[$j - 1] = "micro";
      }
      if ($eq($geti($_.version, 0, 1), "R")) {
        $k[$j - 1] = "rmqr";
      }
      $_.format = $k[--$j];
    }
  } else {
    if ($eq($_.format, "unset")) {
      $_.format = "full";
    }
  }
  if ($ne($_.format, "full") && ($ne($_.format, "micro") && $ne($_.format, "rmqr"))) {
    $k[$j++] = "bwipp.qrcodeInvalidFormat#20920";
    $k[$j++] = "The format must be either full, micro or rmqr";
    bwipp_raiseerror();
  }
  if ($eq($_.format, "rmqr") && $eq($_.version, "unset")) {
    $k[$j++] = "bwipp.qrcodeRMQRwithoutVersion#20924";
    $k[$j++] = "A version must be provided for RMQR";
    bwipp_raiseerror();
  }
  if ($eq($_.eclevel, "unset")) {
    $k[$j++] = "eclevel";
    if ($ne($_.format, "micro")) {
      $k[$j++] = "M";
    } else {
      $k[$j++] = "L";
    }
    var _I = $k[--$j];
    $_[$k[--$j]] = _I;
  }
  if ($ne($_.eclevel, "L") && ($ne($_.eclevel, "M") && ($ne($_.eclevel, "Q") && $ne($_.eclevel, "H")))) {
    $k[$j++] = "bwipp.qrcodeInvalidEClevel#20931";
    $k[$j++] = "Error correction level must be either L, M, Q, or H";
    bwipp_raiseerror();
  }
  if ($_.mask != -1 && $eq($_.format, "rmqr")) {
    $k[$j++] = "bwipp.qrcodeRMQRmask#20935";
    $k[$j++] = "A mask cannot be supplied for RMQR";
    bwipp_raiseerror();
  }
  if ($_.mask != -1) {
    var _U = $eq($_.format, "full") ? 8 : 4;
    if ($_.mask < 1 || $_.mask > _U) {
      $k[$j++] = "bwipp.qrcodeBadMask#20940";
      $k[$j++] = "An invalid mask was supplied";
      bwipp_raiseerror();
    }
  }
  $_.fn1 = -1;
  var _Y = /* @__PURE__ */ new Map([
    ["parse", $_.parse],
    ["parsefnc", $_.parsefnc],
    ["eci", true],
    ["FNC1", $_.fn1]
  ]);
  $_.fncvals = _Y;
  $k[$j++] = "msg";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.fncvals;
  bwipp_parseinput();
  var _b = $k[--$j];
  $_[$k[--$j]] = _b;
  $_.msglen = $_.msg.length;
  $_.fnc1first = false;
  if ($_.msglen > 0) {
    if ($get($_.msg, 0) == $_.fn1) {
      $_.fnc1first = true;
      $k[$j++] = Infinity;
      var _k = $geti($_.msg, 1, $_.msglen - 1);
      for (var _l = 0, _m = _k.length; _l < _m; _l++) {
        var _n = $get(_k, _l);
        $k[$j++] = _n;
        if (_n == 37) {
          var _o = $k[$j - 1];
          $k[$j++] = _o;
        }
      }
      $_.msg = $a();
      $_.msglen = $_.msg.length;
    }
  }
  var _r = $a(["v1to9", "v10to26", "v27to40", "vM1", "vM2", "vM3", "vM4", "vR7x43", "vR7x59", "vR7x77", "vR7x99", "vR7x139", "vR9x43", "vR9x59", "vR9x77", "vR9x99", "vR9x139", "vR11x27", "vR11x43", "vR11x59", "vR11x77", "vR11x99", "vR11x139", "vR13x27", "vR13x43", "vR13x59", "vR13x77", "vR13x99", "vR13x139", "vR15x43", "vR15x59", "vR15x77", "vR15x99", "vR15x139", "vR17x43", "vR17x59", "vR17x77", "vR17x99", "vR17x139"]);
  $k[$j++] = 0;
  for (var _s = 0, _t = _r.length; _s < _t; _s++) {
    var _v = $k[--$j];
    $_[$get(_r, _s)] = _v;
    $k[$j++] = _v + 1;
  }
  $j--;
  $_.N = 0;
  $_.A = 1;
  $_.B = 2;
  $_.K = 3;
  $_.E = 4;
  $k[$j++] = Infinity;
  $k[$j++] = Infinity;
  for (var _w = 48; _w <= 57; _w += 1) {
    $k[$j++] = _w;
  }
  var _x = $a();
  for (var _y = 0, _z = _x.length; _y < _z; _y++) {
    $k[$j++] = $get(_x, _y);
    $k[$j++] = -1;
  }
  $_.Nexcl = $d();
  $k[$j++] = Infinity;
  $k[$j++] = Infinity;
  $k[$j++] = 32;
  $k[$j++] = 36;
  $k[$j++] = 37;
  $k[$j++] = 42;
  $k[$j++] = 43;
  $k[$j++] = 45;
  $k[$j++] = 46;
  $k[$j++] = 47;
  $k[$j++] = 58;
  for (var _12 = 65; _12 <= 90; _12 += 1) {
    $k[$j++] = _12;
  }
  $k[$j++] = $_.fn1;
  var _14 = $a();
  for (var _15 = 0, _16 = _14.length; _15 < _16; _15++) {
    $k[$j++] = $get(_14, _15);
    $k[$j++] = -1;
  }
  $_.Aexcl = $d();
  $k[$j++] = Infinity;
  $k[$j++] = Infinity;
  for (var _19 = 129; _19 <= 159; _19 += 1) {
    $k[$j++] = _19;
  }
  for (var _1A = 224; _1A <= 235; _1A += 1) {
    $k[$j++] = _1A;
  }
  var _1B = $a();
  for (var _1C = 0, _1D = _1B.length; _1C < _1D; _1C++) {
    $k[$j++] = $get(_1B, _1C);
    $k[$j++] = -1;
  }
  $_.Kexcl = $d();
  $k[$j++] = Infinity;
  $k[$j++] = $a(["0001", "0010", "0100", "1000", "0111"]);
  $k[$j++] = $a(["0001", "0010", "0100", "1000", "0111"]);
  $k[$j++] = $a(["0001", "0010", "0100", "1000", "0111"]);
  $k[$j++] = $a(["", -1, -1, -1, -1]);
  $k[$j++] = $a(["0", "1", -1, -1, -1]);
  $k[$j++] = $a(["00", "01", "10", "11", -1]);
  $k[$j++] = $a(["000", "001", "010", "011", -1]);
  for (var _1N = 0; _1N < 32; _1N++) {
    $k[$j++] = $a(["001", "010", "011", "100", "111"]);
  }
  $_.mids = $a();
  $_.cclens = $a([$a([10, 9, 8, 8]), $a([12, 11, 16, 10]), $a([14, 13, 16, 12]), $a([3, -1, -1, -1]), $a([4, 3, -1, -1]), $a([5, 4, 4, 3]), $a([6, 5, 5, 4]), $a([4, 3, 3, 2]), $a([5, 5, 4, 3]), $a([6, 5, 5, 4]), $a([7, 6, 5, 5]), $a([7, 6, 6, 5]), $a([5, 5, 4, 3]), $a([6, 5, 5, 4]), $a([7, 6, 5, 5]), $a([7, 6, 6, 5]), $a([8, 7, 6, 6]), $a([4, 4, 3, 2]), $a([6, 5, 5, 4]), $a([7, 6, 5, 5]), $a([7, 6, 6, 5]), $a([8, 7, 6, 6]), $a([8, 7, 7, 6]), $a([5, 5, 4, 3]), $a([6, 6, 5, 5]), $a([7, 6, 6, 5]), $a([7, 7, 6, 6]), $a([8, 7, 7, 6]), $a([8, 8, 7, 7]), $a([7, 6, 6, 5]), $a([7, 7, 6, 5]), $a([8, 7, 7, 6]), $a([8, 7, 7, 6]), $a([9, 8, 7, 7]), $a([7, 6, 6, 5]), $a([8, 7, 6, 6]), $a([8, 7, 7, 6]), $a([8, 8, 7, 6]), $a([9, 8, 8, 7])]);
  $k[$j++] = Infinity;
  for (var _24 = 0; _24 < 3; _24++) {
    $k[$j++] = 4;
  }
  $k[$j++] = 3;
  $k[$j++] = 5;
  $k[$j++] = 7;
  $k[$j++] = 9;
  for (var _25 = 0; _25 < 32; _25++) {
    $k[$j++] = 3;
  }
  $_.termlens = $a();
  $_.padstrs = $a(["11101100", "00010001"]);
  $_.charmap = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
  $_.charvals = /* @__PURE__ */ new Map();
  for (var _28 = 0; _28 <= 44; _28 += 1) {
    $put($_.charvals, $get($_.charmap, _28), _28);
  }
  $_.tobin = function() {
    var _2E = $s($k[--$j]);
    $k[$j++] = _2E;
    for (var _2G = 0, _2F = _2E.length - 1; _2G <= _2F; _2G += 1) {
      var _2H = $k[$j - 1];
      $put(_2H, _2G, 48);
    }
    var _2I = $k[$j - 1];
    $k[$j++] = _2I;
    var _2J = $k[$j - 3];
    var _2K = $k[$j - 1];
    $k[$j - 3] = $k[$j - 2];
    $j -= 2;
    var _2M = $cvrs($s(_2K.length), _2J, 2);
    $puti(_2K, _2K.length - _2M.length, _2M);
  };
  $_.encA = function() {
    $_.in = $k[--$j];
    if ($_.fnc1first) {
      $k[$j++] = Infinity;
      $forall($_.in, function() {
        var _2Q = $k[$j - 1];
        if (_2Q == $_.fn1) {
          $k[$j - 1] = 37;
        }
      });
      $_.in = $a();
    }
    $_.out = $s(~~($_.in.length * 11 / 2) + 1);
    $_.k = 0;
    $_.m = 0;
    for (; ; ) {
      if ($_.k == $_.in.length) {
        break;
      }
      if ($_.k < $_.in.length - 1) {
        $k[$j++] = $f($get($_.charvals, $get($_.in, $_.k)) * 45 + $get($_.charvals, $get($_.in, $_.k + 1)));
        $k[$j++] = 11;
        $_.tobin();
        $_.k = $_.k + 2;
      } else {
        $k[$j++] = $get($_.charvals, $get($_.in, $_.k));
        $k[$j++] = 6;
        $_.tobin();
        $_.k = $_.k + 1;
      }
      var _2q = $k[--$j];
      $puti($_.out, $_.m, _2q);
      $_.m = _2q.length + $_.m;
    }
    $k[$j++] = $geti($_.out, 0, $_.m);
  };
  $_.encN = function() {
    $_.in = $k[--$j];
    $_.out = $s(~~($_.in.length * 10 / 3) + 1);
    $_.k = 0;
    $_.m = 0;
    for (; ; ) {
      if ($_.k == $_.in.length) {
        break;
      }
      if ($_.k < $_.in.length - 2) {
        var _36 = $geti($_.in, $_.k, 3);
        $k[$j++] = 0;
        for (var _37 = 0, _38 = _36.length; _37 < _38; _37++) {
          var _3A = $k[--$j];
          $k[$j++] = $f($get(_36, _37) + (_3A * 10 - 48));
        }
        $k[$j++] = 10;
        $_.tobin();
        $_.k = $_.k + 3;
      } else {
        if ($_.k == $_.in.length - 2) {
          var _3G = $geti($_.in, $_.k, 2);
          $k[$j++] = 0;
          for (var _3H = 0, _3I = _3G.length; _3H < _3I; _3H++) {
            var _3K = $k[--$j];
            $k[$j++] = $f($get(_3G, _3H) + (_3K * 10 - 48));
          }
          $k[$j++] = 7;
          $_.tobin();
          $_.k = $_.k + 2;
        } else {
          var _3O = $geti($_.in, $_.k, 1);
          $k[$j++] = 0;
          for (var _3P = 0, _3Q = _3O.length; _3P < _3Q; _3P++) {
            var _3S = $k[--$j];
            $k[$j++] = $f($get(_3O, _3P) + (_3S * 10 - 48));
          }
          $k[$j++] = 4;
          $_.tobin();
          $_.k = $_.k + 1;
        }
      }
      var _3U = $k[--$j];
      $puti($_.out, $_.m, _3U);
      $_.m = _3U.length + $_.m;
    }
    $k[$j++] = $geti($_.out, 0, $_.m);
  };
  $_.encB = function() {
    $_.in = $k[--$j];
    if ($_.fnc1first) {
      $k[$j++] = Infinity;
      $forall($_.in, function() {
        var _3e = $k[$j - 1];
        if (_3e == $_.fn1) {
          $k[$j - 1] = 29;
        }
      });
      $_.in = $a();
    }
    $_.out = $s($_.in.length * 8);
    for (var _3l = 0, _3k = $_.in.length - 1; _3l <= _3k; _3l += 1) {
      $_.k = _3l;
      $k[$j++] = $cvi($get($_.in, $_.k));
      $k[$j++] = 8;
      $_.tobin();
      $k[$j++] = $_.out;
      $k[$j++] = $_.k * 8;
      var _3r = $k[$j - 3];
      var _3s = $k[$j - 1];
      $puti($k[$j - 2], _3s, _3r);
      $j -= 3;
    }
    $k[$j++] = $_.out;
  };
  $_.encK = function() {
    $_.in = $k[--$j];
    $_.out = $s(~~($_.in.length / 2) * 13);
    $_.k = 0;
    $_.m = 0;
    for (; ; ) {
      if ($_.k == $_.in.length) {
        break;
      }
      var _46 = $f($get($_.in, $_.k) * 256 + $get($_.in, $_.k + 1));
      $k[$j++] = _46;
      if (_46 < 57408) {
        $k[$j++] = 33088;
      } else {
        $k[$j++] = 49472;
      }
      var _47 = $k[--$j];
      var _49 = $f($k[--$j] - _47);
      $k[$j++] = $f((_49 >>> 8) * 192 + (_49 & 255));
      $k[$j++] = 13;
      $_.tobin();
      var _4A = $k[--$j];
      $puti($_.out, $_.m, _4A);
      $_.m = _4A.length + $_.m;
      $_.k = $_.k + 2;
    }
    $k[$j++] = $_.out;
  };
  $_.encE = function() {
    var _4I = -$get($k[--$j], 0) - 1e6;
    $k[$j++] = _4I;
    if (_4I <= 127) {
      $k[$j++] = 8;
      $_.tobin();
    } else {
      var _4J = $k[$j - 1];
      if (_4J <= 16383) {
        var _4K = $k[--$j];
        $k[$j++] = _4K + 32768;
        $k[$j++] = 16;
        $_.tobin();
      } else {
        var _4L = $k[--$j];
        $k[$j++] = _4L + 12582912;
        $k[$j++] = 24;
        $_.tobin();
      }
    }
  };
  $_.encfuncs = $a(["encN", "encA", "encB", "encK", "encE"]);
  $_.addtobits = function() {
    var _4N = $k[--$j];
    $puti($_.bits, $_.j, _4N);
    $_.j = _4N.length + $_.j;
  };
  $k[$j++] = Infinity;
  for (var _4S = 0, _4T = $_.msglen; _4S < _4T; _4S++) {
    $k[$j++] = 0;
  }
  $k[$j++] = 0;
  $_.numNs = $a();
  $k[$j++] = Infinity;
  for (var _4W = 0, _4X = $_.msglen; _4W < _4X; _4W++) {
    $k[$j++] = 0;
  }
  $k[$j++] = 0;
  $_.numAs = $a();
  $k[$j++] = Infinity;
  for (var _4a = 0, _4b = $_.msglen; _4a < _4b; _4a++) {
    $k[$j++] = 0;
  }
  $k[$j++] = 0;
  $_.numAorNs = $a();
  $k[$j++] = Infinity;
  for (var _4e = 0, _4f = $_.msglen; _4e < _4f; _4e++) {
    $k[$j++] = 0;
  }
  $k[$j++] = 0;
  $_.numBs = $a();
  $k[$j++] = Infinity;
  for (var _4i = 0, _4j = $_.msglen; _4i < _4j; _4i++) {
    $k[$j++] = 0;
  }
  $k[$j++] = 0;
  $_.numKs = $a();
  $k[$j++] = Infinity;
  for (var _4m = 0, _4n = $_.msglen; _4m < _4n; _4m++) {
    $k[$j++] = 0;
  }
  $k[$j++] = 9999;
  $_.nextNs = $a();
  $k[$j++] = Infinity;
  for (var _4q = 0, _4r = $_.msglen; _4q < _4r; _4q++) {
    $k[$j++] = 0;
  }
  $k[$j++] = 9999;
  $_.nextBs = $a();
  $k[$j++] = Infinity;
  for (var _4u = 0, _4v = $_.msglen; _4u < _4v; _4u++) {
    $k[$j++] = 0;
  }
  $k[$j++] = 9999;
  $_.nextAs = $a();
  $k[$j++] = Infinity;
  for (var _4y = 0, _4z = $_.msglen; _4y < _4z; _4y++) {
    $k[$j++] = 0;
  }
  $k[$j++] = 9999;
  $_.nextKs = $a();
  $_.isECI = $a($_.msglen);
  for (var _54 = $_.msglen - 1; _54 >= 0; _54 -= 1) {
    $_.i = _54;
    $_.barchar = $get($_.msg, $_.i);
    var _5A = $get($_.Kexcl, $_.barchar) !== void 0;
    if (_5A && !$_.suppresskanjimode) {
      if ($_.i + 1 < $_.msglen) {
        $k[$j++] = $f($_.barchar * 256 + $get($_.msg, $_.i + 1));
      } else {
        $k[$j++] = 0;
      }
      var _5I = $k[--$j];
      var _5J = _5I & 255;
      if ((_5I >= 33088 && _5I <= 40956 || _5I >= 57408 && _5I <= 60351) && (_5J >= 64 && _5J <= 252 && _5J != 127)) {
        $put($_.nextKs, $_.i, 0);
        $put($_.numKs, $_.i, $get($_.numKs, $_.i + 2) + 1);
      } else {
        $put($_.nextKs, $_.i, $get($_.nextKs, $_.i + 1) + 1);
      }
    } else {
      $put($_.nextKs, $_.i, $get($_.nextKs, $_.i + 1) + 1);
    }
    var _5d = $get($_.Nexcl, $_.barchar) !== void 0;
    if (_5d) {
      $put($_.nextNs, $_.i, 0);
      $put($_.numNs, $_.i, $get($_.numNs, $_.i + 1) + 1);
      $put($_.numAorNs, $_.i, $get($_.numAorNs, $_.i + 1) + 1);
    } else {
      $put($_.nextNs, $_.i, $get($_.nextNs, $_.i + 1) + 1);
    }
    var _5x = $get($_.Aexcl, $_.barchar) !== void 0;
    if (_5x) {
      $put($_.nextAs, $_.i, 0);
      $put($_.numAs, $_.i, $get($_.numAs, $_.i + 1) + 1);
      $put($_.numAorNs, $_.i, $get($_.numAorNs, $_.i + 1) + 1);
    } else {
      $put($_.nextAs, $_.i, $get($_.nextAs, $_.i + 1) + 1);
    }
    $put($_.isECI, $_.i, $_.barchar <= -1e6);
  }
  for (var _6K = 0, _6J = $_.msglen - 1; _6K <= _6J; _6K += 1) {
    $_.i = _6K;
    if ($get($_.numKs, $_.i) > 0) {
      $put($_.numKs, $_.i + 1, 0);
      $put($_.nextKs, $_.i + 1, $get($_.nextKs, $_.i + 1) + 1);
    }
  }
  for (var _6W = $_.msglen - 1; _6W >= 0; _6W -= 1) {
    $_.i = _6W;
    if ($f($get($_.numNs, $_.i) + ($get($_.numAs, $_.i) + $get($_.numKs, $_.i))) == 0 && !$get($_.isECI, $_.i)) {
      $put($_.nextBs, $_.i, 0);
      $put($_.numBs, $_.i, $get($_.numBs, $_.i + 1) + 1);
    } else {
      $put($_.nextBs, $_.i, $get($_.nextBs, $_.i + 1) + 1);
    }
  }
  $_.KbeforeB = function() {
    var _6y = $get($k[--$j], $_.ver);
    $k[$j++] = $ge($_.numK, _6y) && $get($_.nextBs, $f($_.numK * 2 + $_.i)) == 0;
  };
  $_.KbeforeA = function() {
    var _76 = $get($k[--$j], $_.ver);
    $k[$j++] = $ge($_.numK, _76) && $get($_.nextAs, $f($_.numK * 2 + $_.i)) == 0;
  };
  $_.KbeforeN = function() {
    var _7E = $get($k[--$j], $_.ver);
    $k[$j++] = $ge($_.numK, _7E) && $get($_.nextNs, $f($_.numK * 2 + $_.i)) == 0;
  };
  $_.KbeforeE = function() {
    var _7M = $get($k[--$j], $_.ver);
    $k[$j++] = $ge($_.numK, _7M) && $f($_.numK * 2 + $_.i) == $_.msglen;
  };
  $_.AbeforeK = function() {
    var _7T = $get($k[--$j], $_.ver);
    $k[$j++] = $ge($_.numA, _7T) && $get($_.nextKs, $f($_.numA + $_.i)) == 0;
  };
  $_.AbeforeB = function() {
    var _7b = $get($k[--$j], $_.ver);
    $k[$j++] = $ge($_.numA, _7b) && $get($_.nextBs, $f($_.numA + $_.i)) == 0;
  };
  $_.AbeforeN = function() {
    var _7j = $get($k[--$j], $_.ver);
    $k[$j++] = $ge($_.numA, _7j) && $get($_.nextNs, $f($_.numA + $_.i)) == 0;
  };
  $_.AbeforeE = function() {
    var _7r = $get($k[--$j], $_.ver);
    $k[$j++] = $ge($_.numA, _7r) && $f($_.numA + $_.i) == $_.msglen;
  };
  $_.NbeforeK = function() {
    var _7y = $get($k[--$j], $_.ver);
    $k[$j++] = $ge($_.numN, _7y) && $get($_.nextKs, $f($_.numN + $_.i)) == 0;
  };
  $_.NbeforeB = function() {
    var _86 = $get($k[--$j], $_.ver);
    $k[$j++] = $ge($_.numN, _86) && $get($_.nextBs, $f($_.numN + $_.i)) == 0;
  };
  $_.NbeforeA = function() {
    var _8E = $get($k[--$j], $_.ver);
    $k[$j++] = $ge($_.numN, _8E) && $get($_.nextAs, $f($_.numN + $_.i)) == 0;
  };
  $_.NbeforeE = function() {
    var _8M = $get($k[--$j], $_.ver);
    $k[$j++] = $ge($_.numN, _8M) && $f($_.numN + $_.i) == $_.msglen;
  };
  $_.AorNbeforeB = function() {
    var _8T = $get($k[--$j], $_.ver);
    $k[$j++] = $ge($_.numAorN, _8T) && $get($_.nextBs, $f($_.numAorN + $_.i)) == 0;
  };
  $_.AorNbeforeE = function() {
    var _8b = $get($k[--$j], $_.ver);
    $k[$j++] = $ge($_.numAorN, _8b) && $f($_.numAorN + $_.i) == $_.msglen;
  };
  $_.nextNslt = function() {
    if ($get($_.nextNs, $_.i) >= $_.msglen) {
      $k[$j - 1] = true;
    } else {
      var _8r = $get($k[--$j], $_.ver);
      $k[$j++] = $lt($get($_.numNs, $f($get($_.nextNs, $_.i) + $_.i)), _8r);
    }
  };
  $k[$j++] = Infinity;
  $k[$j++] = "full";
  $k[$j++] = Infinity;
  for (var _8s = 0; _8s <= 9; _8s += 1) {
    $k[$j++] = $cvrs($s(2), _8s, 10);
    $k[$j++] = $_.v1to9;
  }
  for (var _8w = 10; _8w <= 26; _8w += 1) {
    $k[$j++] = $cvrs($s(2), _8w, 10);
    $k[$j++] = $_.v10to26;
  }
  for (var _90 = 27; _90 <= 40; _90 += 1) {
    $k[$j++] = $cvrs($s(2), _90, 10);
    $k[$j++] = $_.v27to40;
  }
  var _94 = $d();
  var _99 = /* @__PURE__ */ new Map([
    ["M1", $_.vM1],
    ["M2", $_.vM2],
    ["M3", $_.vM3],
    ["M4", $_.vM4]
  ]);
  var _9g = /* @__PURE__ */ new Map([
    ["R7x43", $_.vR7x43],
    ["R7x59", $_.vR7x59],
    ["R7x77", $_.vR7x77],
    ["R7x99", $_.vR7x99],
    ["R7x139", $_.vR7x139],
    ["R9x43", $_.vR9x43],
    ["R9x59", $_.vR9x59],
    ["R9x77", $_.vR9x77],
    ["R9x99", $_.vR9x99],
    ["R9x139", $_.vR9x139],
    ["R11x27", $_.vR11x27],
    ["R11x43", $_.vR11x43],
    ["R11x59", $_.vR11x59],
    ["R11x77", $_.vR11x77],
    ["R11x99", $_.vR11x99],
    ["R11x139", $_.vR11x139],
    ["R13x27", $_.vR13x27],
    ["R13x43", $_.vR13x43],
    ["R13x59", $_.vR13x59],
    ["R13x77", $_.vR13x77],
    ["R13x99", $_.vR13x99],
    ["R13x139", $_.vR13x139],
    ["R15x43", $_.vR15x43],
    ["R15x59", $_.vR15x59],
    ["R15x77", $_.vR15x77],
    ["R15x99", $_.vR15x99],
    ["R15x139", $_.vR15x139],
    ["R17x43", $_.vR17x43],
    ["R17x59", $_.vR17x59],
    ["R17x77", $_.vR17x77],
    ["R17x99", $_.vR17x99],
    ["R17x139", $_.vR17x139]
  ]);
  $k[$j++] = _94;
  $k[$j++] = "micro";
  $k[$j++] = _99;
  $k[$j++] = "rmqr";
  $k[$j++] = _9g;
  $_.versetmap = $d();
  $_.versetfull = $a([$_.v1to9, $_.v10to26, $_.v27to40]);
  $_.versetmicro = $a([$_.vM1, $_.vM2, $_.vM3, $_.vM4]);
  if ($ne($_.version, "unset")) {
    var _9v = $get($_.versetmap, $_.format);
    var _9w = $_.version;
    var _9x = $get(_9v, _9w) !== void 0;
    $k[$j++] = _9v;
    $k[$j++] = _9w;
    if (!_9x) {
      $j -= 2;
      if ($eq($_.format, "full")) {
        $k[$j++] = "bwipp.qrcodeInvalidFullVersion#21296";
        $k[$j++] = "Valid versions for QR Code symbols are 1 to 40";
        bwipp_raiseerror();
      } else {
        if ($eq($_.format, "micro")) {
          $k[$j++] = "bwipp.qrcodeInvalidMicroVersion#21299";
          $k[$j++] = "Valid versions for Micro QR Code symbols are M1 to M4";
          bwipp_raiseerror();
        } else {
          $k[$j++] = "bwipp.qrcodeInvalidRMQRversion#21301";
          $k[$j++] = "Invalid version for an RMQR symbol";
          bwipp_raiseerror();
        }
      }
    }
    var _A0 = $k[--$j];
    var _A2 = $get($k[--$j], _A0);
    var _A3 = Infinity;
    var _A4 = _A2;
    $k[$j++] = _A3;
    $k[$j++] = _A4;
    $_.verset = $a();
  } else {
    if ($eq($_.format, "full")) {
      $_.verset = $_.versetfull;
    }
    if ($eq($_.format, "micro")) {
      $_.verset = $_.versetmicro;
    }
  }
  $k[$j++] = Infinity;
  for (var _AA = 0; _AA < 39; _AA++) {
    $k[$j++] = -1;
  }
  $_.msgbits = $a();
  $_.e = 1e4;
  $_.mode0forceKB = $a([1, 1, 1, $_.e, $_.e, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]);
  $_.mode0forceA = $a([1, 1, 1, $_.e, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]);
  $_.mode0forceN = $a([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]);
  $_.mode0NbeforeB = $a([4, 4, 5, $_.e, $_.e, 2, 3, 2, 2, 3, 3, 3, 2, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]);
  $_.modeBKbeforeB = $a([9, 12, 13, $_.e, $_.e, 4, 6, 4, 5, 6, 6, 6, 5, 6, 6, 6, 7, 4, 6, 6, 6, 7, 7, 5, 6, 6, 7, 7, 7, 6, 6, 7, 7, 7, 6, 7, 7, 7, 8]);
  $_.modeBKbeforeA = $a([8, 10, 11, $_.e, $_.e, 4, 5, 4, 5, 5, 6, 6, 5, 5, 6, 6, 6, 4, 5, 6, 6, 6, 6, 5, 6, 6, 6, 6, 7, 6, 6, 6, 6, 7, 6, 6, 6, 7, 7]);
  $_.modeBKbeforeN = $a([8, 9, 11, $_.e, $_.e, 3, 5, 3, 4, 5, 5, 5, 4, 5, 5, 5, 6, 3, 5, 5, 5, 6, 6, 4, 5, 5, 6, 6, 6, 5, 5, 6, 6, 7, 5, 6, 6, 6, 7]);
  $_.modeBKbeforeE = $a([5, 5, 6, $_.e, $_.e, 2, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 2, 3, 3, 3, 4, 4, 3, 3, 3, 4, 4, 4, 3, 3, 4, 4, 4, 3, 4, 4, 4, 4]);
  $_.modeBAbeforeK = $a([11, 12, 14, $_.e, $_.e, 5, 7, 5, 6, 7, 8, 8, 6, 7, 8, 8, 8, 6, 7, 8, 8, 8, 8, 6, 8, 8, 8, 8, 9, 8, 8, 8, 8, 9, 8, 8, 8, 9, 9]);
  $_.modeBAbeforeB = $a([11, 15, 16, $_.e, $_.e, 6, 7, 6, 7, 7, 8, 8, 7, 7, 8, 8, 8, 6, 7, 8, 8, 8, 9, 7, 8, 8, 8, 9, 9, 8, 8, 9, 9, 9, 8, 8, 9, 9, 10]);
  $_.modeBAbeforeN = $a([12, 13, 15, $_.e, $_.e, 6, 8, 6, 7, 8, 8, 8, 7, 8, 8, 8, 9, 6, 8, 8, 8, 9, 9, 7, 8, 8, 9, 9, 10, 8, 9, 9, 9, 10, 8, 9, 9, 10, 10]);
  $_.modeBAbeforeE = $a([6, 7, 8, $_.e, $_.e, 3, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 5, 5, 4, 4, 4, 5, 5, 5, 4, 5, 5, 5, 5, 4, 5, 5, 5, 5]);
  $_.modeBNbeforeK = $a([6, 7, 8, $_.e, $_.e, 3, 4, 3, 4, 4, 5, 5, 4, 4, 5, 5, 5, 3, 4, 5, 5, 5, 5, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]);
  $_.modeBNbeforeB = $a([6, 8, 9, $_.e, $_.e, 3, 4, 3, 4, 4, 5, 5, 4, 4, 5, 5, 5, 3, 4, 5, 5, 5, 5, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6]);
  $_.modeBNbeforeA = $a([6, 7, 8, $_.e, $_.e, 3, 4, 3, 4, 4, 5, 5, 4, 4, 5, 5, 5, 4, 4, 5, 5, 5, 5, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 5, 5, 5, 5, 6]);
  $_.modeBNbeforeE = $a([3, 4, 4, $_.e, $_.e, 2, 3, 2, 2, 3, 3, 3, 2, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]);
  $_.modeANbeforeA = $a([13, 15, 17, $_.e, 5, 7, 9, 7, 8, 9, 9, 9, 8, 9, 9, 9, 11, 7, 9, 9, 9, 11, 11, 8, 9, 9, 10, 11, 11, 9, 10, 11, 11, 11, 9, 11, 11, 11, 11]);
  $_.modeANbeforeB = $a([13, 17, 18, $_.e, $_.e, 7, 9, 7, 8, 9, 9, 9, 8, 9, 9, 9, 10, 7, 9, 9, 9, 10, 11, 8, 9, 9, 9, 11, 11, 9, 9, 11, 11, 11, 9, 10, 11, 11, 11]);
  $_.modeANbeforeE = $a([7, 8, 9, $_.e, 3, 4, 5, 4, 5, 5, 5, 5, 5, 5, 5, 5, 6, 4, 5, 5, 5, 6, 6, 5, 5, 5, 5, 6, 6, 5, 5, 6, 6, 6, 5, 6, 6, 6, 6]);
  var _B3 = $_.verset;
  for (var _B4 = 0, _B5 = _B3.length; _B4 < _B5; _B4++) {
    $_.ver = $get(_B3, _B4);
    $_.mode = -1;
    $_.seq = $a([]);
    $_.i = 0;
    for (; ; ) {
      if ($_.i >= $_.msglen) {
        break;
      }
      $_.numK = $get($_.numKs, $_.i);
      $_.numB = $get($_.numBs, $_.i);
      $_.numA = $get($_.numAs, $_.i);
      $_.numN = $get($_.numNs, $_.i);
      $_.numAorN = $get($_.numAorNs, $_.i);
      $_.eci = $get($_.isECI, $_.i);
      if ($eq($_.ver, $_.vM1) && $_.numA >= 1) {
        $_.seq = -1;
        break;
      }
      if ($eq($_.ver, $_.vM1) && $_.numB >= 1) {
        $_.seq = -1;
        break;
      }
      if ($eq($_.ver, $_.vM1) && $_.numK >= 1) {
        $_.seq = -1;
        break;
      }
      if ($eq($_.ver, $_.vM1) && $_.eci) {
        $_.seq = -1;
        break;
      }
      if ($eq($_.ver, $_.vM2) && $_.numB >= 1) {
        $_.seq = -1;
        break;
      }
      if ($eq($_.ver, $_.vM2) && $_.numK >= 1) {
        $_.seq = -1;
        break;
      }
      if ($eq($_.ver, $_.vM2) && $_.eci) {
        $_.seq = -1;
        break;
      }
      if ($eq($_.ver, $_.vM3) && $_.eci) {
        $_.seq = -1;
        break;
      }
      if ($eq($_.ver, $_.vM4) && $_.eci) {
        $_.seq = -1;
        break;
      }
      for (; ; ) {
        if ($_.eci) {
          $k[$j++] = $_.E;
          break;
        }
        if ($_.mode == -1) {
          $k[$j++] = $_.mode0forceKB;
          $_.KbeforeA();
          if ($k[--$j]) {
            $k[$j++] = $_.K;
            break;
          }
          $k[$j++] = $_.mode0forceKB;
          $_.KbeforeN();
          if ($k[--$j]) {
            $k[$j++] = $_.K;
            break;
          }
          $k[$j++] = $_.modeBKbeforeE;
          $_.KbeforeB();
          if ($k[--$j]) {
            $k[$j++] = $_.K;
            break;
          }
          $k[$j++] = $_.mode0forceKB;
          $_.KbeforeE();
          if ($k[--$j]) {
            $k[$j++] = $_.K;
            break;
          }
          if ($_.numK >= 1) {
            $k[$j++] = $_.B;
            break;
          }
          $k[$j++] = $_.mode0NbeforeB;
          $_.NbeforeK();
          if ($k[--$j]) {
            $k[$j++] = $_.N;
            break;
          }
          $k[$j++] = $_.mode0NbeforeB;
          $_.NbeforeB();
          if ($k[--$j]) {
            $k[$j++] = $_.N;
            break;
          }
          $k[$j++] = $_.mode0forceKB;
          $_.NbeforeB();
          if ($k[--$j]) {
            $k[$j++] = $_.B;
            break;
          }
          $k[$j++] = $_.modeANbeforeE;
          $_.NbeforeA();
          if ($k[--$j]) {
            $k[$j++] = $_.N;
            break;
          }
          $k[$j++] = $_.mode0forceN;
          $_.NbeforeE();
          if ($k[--$j]) {
            $k[$j++] = $_.N;
            break;
          }
          $k[$j++] = $_.modeBAbeforeE;
          $_.AbeforeK();
          if ($k[--$j]) {
            $k[$j++] = $_.A;
            break;
          }
          $k[$j++] = $_.modeBAbeforeE;
          $_.AorNbeforeB();
          if ($k[--$j]) {
            $k[$j++] = $_.A;
            break;
          }
          $k[$j++] = $_.mode0forceA;
          $_.AorNbeforeE();
          if ($k[--$j]) {
            $k[$j++] = $_.A;
            break;
          }
          $k[$j++] = $_.B;
          break;
        }
        if ($_.mode == $_.B) {
          $k[$j++] = $_.modeBKbeforeB;
          $_.KbeforeB();
          if ($k[--$j]) {
            $k[$j++] = $_.K;
            break;
          }
          $k[$j++] = $_.modeBKbeforeA;
          $_.KbeforeA();
          if ($k[--$j]) {
            $k[$j++] = $_.K;
            break;
          }
          $k[$j++] = $_.modeBKbeforeN;
          $_.KbeforeN();
          if ($k[--$j]) {
            $k[$j++] = $_.K;
            break;
          }
          $k[$j++] = $_.modeBKbeforeE;
          $_.KbeforeE();
          if ($k[--$j]) {
            $k[$j++] = $_.K;
            break;
          }
          $k[$j++] = $_.modeBAbeforeK;
          $_.AbeforeK();
          if ($k[--$j]) {
            $k[$j++] = $_.A;
            break;
          }
          $k[$j++] = $_.modeBAbeforeB;
          $_.AbeforeB();
          if ($k[--$j]) {
            $k[$j++] = $_.A;
            break;
          }
          $k[$j++] = $_.modeBAbeforeN;
          $_.AbeforeN();
          if ($k[--$j]) {
            $k[$j++] = $_.A;
            break;
          }
          $k[$j++] = $_.modeBAbeforeE;
          $_.AbeforeE();
          if ($k[--$j]) {
            $k[$j++] = $_.A;
            break;
          }
          $k[$j++] = $_.modeBNbeforeK;
          $_.NbeforeK();
          if ($k[--$j]) {
            $k[$j++] = $_.N;
            break;
          }
          $k[$j++] = $_.modeBNbeforeB;
          $_.NbeforeB();
          if ($k[--$j]) {
            $k[$j++] = $_.N;
            break;
          }
          $k[$j++] = $_.modeBNbeforeA;
          $_.NbeforeA();
          if ($k[--$j]) {
            $k[$j++] = $_.N;
            break;
          }
          $k[$j++] = $_.modeBNbeforeE;
          $_.NbeforeE();
          if ($k[--$j]) {
            $k[$j++] = $_.N;
            break;
          }
          $k[$j++] = $_.modeBAbeforeE;
          $_.AorNbeforeE();
          var _DG = $k[--$j];
          if (_DG && $le($_.numAorN, $get($_.modeBAbeforeN, $_.ver))) {
            $k[$j++] = $_.modeBNbeforeA;
            $_.nextNslt();
            if ($k[--$j]) {
              $k[$j++] = $_.A;
              break;
            }
          }
          $k[$j++] = $_.B;
          break;
        }
        if ($_.mode == $_.A) {
          if ($_.numK >= 1) {
            $k[$j++] = $_.K;
            break;
          }
          if ($_.numB >= 1) {
            $k[$j++] = $_.B;
            break;
          }
          $k[$j++] = $_.modeANbeforeA;
          $_.NbeforeA();
          if ($k[--$j]) {
            $k[$j++] = $_.N;
            break;
          }
          $k[$j++] = $_.modeANbeforeB;
          $_.NbeforeB();
          if ($k[--$j]) {
            $k[$j++] = $_.N;
            break;
          }
          $k[$j++] = $_.modeANbeforeE;
          $_.NbeforeE();
          if ($k[--$j]) {
            $k[$j++] = $_.N;
            break;
          }
          if ($_.numA >= 1 || $_.numN >= 1) {
            $k[$j++] = $_.A;
            break;
          }
          $k[$j++] = $_.B;
          break;
        }
        if ($_.mode == $_.N) {
          if ($_.numK >= 1) {
            $k[$j++] = $_.K;
            break;
          }
          if ($_.numB >= 1) {
            $k[$j++] = $_.B;
            break;
          }
          if ($_.numA >= 1) {
            $k[$j++] = $_.A;
            break;
          }
          if ($_.numN >= 1) {
            $k[$j++] = $_.N;
            break;
          }
          $k[$j++] = $_.B;
          break;
        }
        if ($_.mode == $_.K) {
          if ($_.numB >= 1) {
            $k[$j++] = $_.B;
            break;
          }
          if ($_.numA >= 1) {
            $k[$j++] = $_.A;
            break;
          }
          if ($_.numN >= 1) {
            $k[$j++] = $_.N;
            break;
          }
          if ($_.numK >= 1) {
            $k[$j++] = $_.K;
            break;
          }
          $k[$j++] = $_.B;
          break;
        }
      }
      var _E0 = $k[$j - 1];
      if (_E0 == $_.K && $_.fnc1first) {
        $k[$j - 1] = $_.B;
      }
      var _E4 = $k[$j - 1];
      if (_E4 == $_.mode) {
        $j--;
        var _EA = $_.mode == $_.K ? 2 : 1;
        $_.dat = $geti($_.msg, $_.i, _EA);
        $k[$j++] = Infinity;
        $aload($_.seq);
        $k[$j++] = Infinity;
        var _ED = $k[--$j];
        var _EE = $k[--$j];
        $k[$j++] = _ED;
        $aload(_EE);
        $aload($_.dat);
        var _EG = $a();
        $k[$j++] = _EG;
        $_.seq = $a();
      } else {
        $_.mode = $k[--$j];
        if ($_.mode == $_.K) {
          $k[$j++] = $_.K;
          $k[$j++] = $geti($_.msg, $_.i, $_.numK * 2);
        }
        if ($_.mode == $_.B) {
          $k[$j++] = $_.B;
          $k[$j++] = $geti($_.msg, $_.i, $_.numB);
        }
        if ($_.mode == $_.A) {
          $k[$j++] = $_.A;
          $k[$j++] = $geti($_.msg, $_.i, $_.numA);
        }
        if ($_.mode == $_.N) {
          $k[$j++] = $_.N;
          $k[$j++] = $geti($_.msg, $_.i, $_.numN);
        }
        if ($_.mode == $_.E) {
          $_.mode = -1;
          $k[$j++] = $_.E;
          $k[$j++] = $geti($_.msg, $_.i, 1);
        }
        $_.dat = $k[--$j];
        $_.sw = $k[--$j];
        $k[$j++] = Infinity;
        $aload($_.seq);
        $k[$j++] = $_.sw;
        $k[$j++] = $_.dat;
        $_.seq = $a();
      }
      $_.i = $_.i + $_.dat.length;
    }
    for (; ; ) {
      if ($_.seq == -1) {
        break;
      }
      $_.bits = $s(23648);
      $_.j = 0;
      if ($_.fnc1first) {
        if ($lt($_.ver, $_.vR7x43)) {
          $k[$j++] = "0101";
        } else {
          $k[$j++] = "101";
        }
        $_.addtobits();
      }
      $_.abort = false;
      for (var _F6 = 0, _F5 = $_.seq.length - 1; _F6 <= _F5; _F6 += 2) {
        $_.i = _F6;
        $_.mode = $get($_.seq, $_.i);
        $k[$j++] = $get($get($_.mids, $_.ver), $_.mode);
        $_.addtobits();
        $_.chars = $get($_.seq, $_.i + 1);
        $k[$j++] = "charslen";
        $k[$j++] = $_.chars.length;
        if ($_.mode == $_.K) {
          var _FL = $k[--$j];
          $k[$j++] = ~~(_FL / 2);
        }
        var _FM = $k[--$j];
        $_[$k[--$j]] = _FM;
        if ($_.mode != $_.E) {
          $_.cclen = $get($get($_.cclens, $_.ver), $_.mode);
          if ($_.charslen >= ~~$pow(2, $_.cclen)) {
            $_.abort = true;
            break;
          }
          $k[$j++] = $_.charslen;
          $k[$j++] = $_.cclen;
          $_.tobin();
          $_.addtobits();
        }
        $k[$j++] = $_.chars;
        if ($_[$get($_.encfuncs, $_.mode)]() === true) {
          break;
        }
        $_.addtobits();
      }
      if ($_.abort) {
        break;
      }
      $_.bits = $geti($_.bits, 0, $_.j);
      $put($_.msgbits, $_.ver, $_.bits);
      break;
    }
  }
  $_.metrics = $a([$a(["micro", "M1", $_.vM1, 11, 11, 98, 99, 36, $a([2, 99, 99, 99]), $a([1, 0, -1, -1, -1, -1, -1, -1])]), $a(["micro", "M2", $_.vM2, 13, 13, 98, 99, 80, $a([5, 6, 99, 99]), $a([1, 0, 1, 0, -1, -1, -1, -1])]), $a(["micro", "M3", $_.vM3, 15, 15, 98, 99, 132, $a([6, 8, 99, 99]), $a([1, 0, 1, 0, -1, -1, -1, -1])]), $a(["micro", "M4", $_.vM4, 17, 17, 98, 99, 192, $a([8, 10, 14, 99]), $a([1, 0, 1, 0, 1, 0, -1, -1])]), $a(["full", "1", $_.v1to9, 21, 21, 98, 99, 208, $a([7, 10, 13, 17]), $a([1, 0, 1, 0, 1, 0, 1, 0])]), $a(["full", "2", $_.v1to9, 25, 25, 18, 99, 359, $a([10, 16, 22, 28]), $a([1, 0, 1, 0, 1, 0, 1, 0])]), $a(["full", "3", $_.v1to9, 29, 29, 22, 99, 567, $a([15, 26, 36, 44]), $a([1, 0, 1, 0, 2, 0, 2, 0])]), $a(["full", "4", $_.v1to9, 33, 33, 26, 99, 807, $a([20, 36, 52, 64]), $a([1, 0, 2, 0, 2, 0, 4, 0])]), $a(["full", "5", $_.v1to9, 37, 37, 30, 99, 1079, $a([26, 48, 72, 88]), $a([1, 0, 2, 0, 2, 2, 2, 2])]), $a(["full", "6", $_.v1to9, 41, 41, 34, 99, 1383, $a([36, 64, 96, 112]), $a([2, 0, 4, 0, 4, 0, 4, 0])]), $a(["full", "7", $_.v1to9, 45, 45, 22, 38, 1568, $a([40, 72, 108, 130]), $a([2, 0, 4, 0, 2, 4, 4, 1])]), $a(["full", "8", $_.v1to9, 49, 49, 24, 42, 1936, $a([48, 88, 132, 156]), $a([2, 0, 2, 2, 4, 2, 4, 2])]), $a(["full", "9", $_.v1to9, 53, 53, 26, 46, 2336, $a([60, 110, 160, 192]), $a([2, 0, 3, 2, 4, 4, 4, 4])]), $a(["full", "10", $_.v10to26, 57, 57, 28, 50, 2768, $a([72, 130, 192, 224]), $a([2, 2, 4, 1, 6, 2, 6, 2])]), $a(["full", "11", $_.v10to26, 61, 61, 30, 54, 3232, $a([80, 150, 224, 264]), $a([4, 0, 1, 4, 4, 4, 3, 8])]), $a(["full", "12", $_.v10to26, 65, 65, 32, 58, 3728, $a([96, 176, 260, 308]), $a([2, 2, 6, 2, 4, 6, 7, 4])]), $a(["full", "13", $_.v10to26, 69, 69, 34, 62, 4256, $a([104, 198, 288, 352]), $a([4, 0, 8, 1, 8, 4, 12, 4])]), $a(["full", "14", $_.v10to26, 73, 73, 26, 46, 4651, $a([120, 216, 320, 384]), $a([3, 1, 4, 5, 11, 5, 11, 5])]), $a(["full", "15", $_.v10to26, 77, 77, 26, 48, 5243, $a([132, 240, 360, 432]), $a([5, 1, 5, 5, 5, 7, 11, 7])]), $a(["full", "16", $_.v10to26, 81, 81, 26, 50, 5867, $a([144, 280, 408, 480]), $a([5, 1, 7, 3, 15, 2, 3, 13])]), $a(["full", "17", $_.v10to26, 85, 85, 30, 54, 6523, $a([168, 308, 448, 532]), $a([1, 5, 10, 1, 1, 15, 2, 17])]), $a(["full", "18", $_.v10to26, 89, 89, 30, 56, 7211, $a([180, 338, 504, 588]), $a([5, 1, 9, 4, 17, 1, 2, 19])]), $a(["full", "19", $_.v10to26, 93, 93, 30, 58, 7931, $a([196, 364, 546, 650]), $a([3, 4, 3, 11, 17, 4, 9, 16])]), $a(["full", "20", $_.v10to26, 97, 97, 34, 62, 8683, $a([224, 416, 600, 700]), $a([3, 5, 3, 13, 15, 5, 15, 10])]), $a(["full", "21", $_.v10to26, 101, 101, 28, 50, 9252, $a([224, 442, 644, 750]), $a([4, 4, 17, 0, 17, 6, 19, 6])]), $a(["full", "22", $_.v10to26, 105, 105, 26, 50, 10068, $a([252, 476, 690, 816]), $a([2, 7, 17, 0, 7, 16, 34, 0])]), $a(["full", "23", $_.v10to26, 109, 109, 30, 54, 10916, $a([270, 504, 750, 900]), $a([4, 5, 4, 14, 11, 14, 16, 14])]), $a(["full", "24", $_.v10to26, 113, 113, 28, 54, 11796, $a([300, 560, 810, 960]), $a([6, 4, 6, 14, 11, 16, 30, 2])]), $a(["full", "25", $_.v10to26, 117, 117, 32, 58, 12708, $a([312, 588, 870, 1050]), $a([8, 4, 8, 13, 7, 22, 22, 13])]), $a(["full", "26", $_.v10to26, 121, 121, 30, 58, 13652, $a([336, 644, 952, 1110]), $a([10, 2, 19, 4, 28, 6, 33, 4])]), $a(["full", "27", $_.v27to40, 125, 125, 34, 62, 14628, $a([360, 700, 1020, 1200]), $a([8, 4, 22, 3, 8, 26, 12, 28])]), $a(["full", "28", $_.v27to40, 129, 129, 26, 50, 15371, $a([390, 728, 1050, 1260]), $a([3, 10, 3, 23, 4, 31, 11, 31])]), $a(["full", "29", $_.v27to40, 133, 133, 30, 54, 16411, $a([420, 784, 1140, 1350]), $a([7, 7, 21, 7, 1, 37, 19, 26])]), $a(["full", "30", $_.v27to40, 137, 137, 26, 52, 17483, $a([450, 812, 1200, 1440]), $a([5, 10, 19, 10, 15, 25, 23, 25])]), $a(["full", "31", $_.v27to40, 141, 141, 30, 56, 18587, $a([480, 868, 1290, 1530]), $a([13, 3, 2, 29, 42, 1, 23, 28])]), $a(["full", "32", $_.v27to40, 145, 145, 34, 60, 19723, $a([510, 924, 1350, 1620]), $a([17, 0, 10, 23, 10, 35, 19, 35])]), $a(["full", "33", $_.v27to40, 149, 149, 30, 58, 20891, $a([540, 980, 1440, 1710]), $a([17, 1, 14, 21, 29, 19, 11, 46])]), $a(["full", "34", $_.v27to40, 153, 153, 34, 62, 22091, $a([570, 1036, 1530, 1800]), $a([13, 6, 14, 23, 44, 7, 59, 1])]), $a(["full", "35", $_.v27to40, 157, 157, 30, 54, 23008, $a([570, 1064, 1590, 1890]), $a([12, 7, 12, 26, 39, 14, 22, 41])]), $a(["full", "36", $_.v27to40, 161, 161, 24, 50, 24272, $a([600, 1120, 1680, 1980]), $a([6, 14, 6, 34, 46, 10, 2, 64])]), $a(["full", "37", $_.v27to40, 165, 165, 28, 54, 25568, $a([630, 1204, 1770, 2100]), $a([17, 4, 29, 14, 49, 10, 24, 46])]), $a(["full", "38", $_.v27to40, 169, 169, 32, 58, 26896, $a([660, 1260, 1860, 2220]), $a([4, 18, 13, 32, 48, 14, 42, 32])]), $a(["full", "39", $_.v27to40, 173, 173, 26, 54, 28256, $a([720, 1316, 1950, 2310]), $a([20, 4, 40, 7, 43, 22, 10, 67])]), $a(["full", "40", $_.v27to40, 177, 177, 30, 58, 29648, $a([750, 1372, 2040, 2430]), $a([19, 6, 18, 31, 34, 34, 20, 61])]), $a(["rmqr", "R7x43", $_.vR7x43, 7, 43, 22, 99, 104, $a([99, 7, 99, 10]), $a([-1, -1, 1, 0, -1, -1, 1, 0])]), $a(["rmqr", "R7x59", $_.vR7x59, 7, 59, 20, 40, 171, $a([99, 9, 99, 14]), $a([-1, -1, 1, 0, -1, -1, 1, 0])]), $a(["rmqr", "R7x77", $_.vR7x77, 7, 77, 26, 52, 261, $a([99, 12, 99, 22]), $a([-1, -1, 1, 0, -1, -1, 1, 0])]), $a(["rmqr", "R7x99", $_.vR7x99, 7, 99, 24, 50, 358, $a([99, 16, 99, 30]), $a([-1, -1, 1, 0, -1, -1, 1, 0])]), $a(["rmqr", "R7x139", $_.vR7x139, 7, 139, 28, 56, 545, $a([99, 24, 99, 44]), $a([-1, -1, 1, 0, -1, -1, 2, 0])]), $a(["rmqr", "R9x43", $_.vR9x43, 9, 43, 22, 99, 170, $a([99, 9, 99, 14]), $a([-1, -1, 1, 0, -1, -1, 1, 0])]), $a(["rmqr", "R9x59", $_.vR9x59, 9, 59, 20, 40, 267, $a([99, 12, 99, 22]), $a([-1, -1, 1, 0, -1, -1, 1, 0])]), $a(["rmqr", "R9x77", $_.vR9x77, 9, 77, 26, 52, 393, $a([99, 18, 99, 32]), $a([-1, -1, 1, 0, -1, -1, 1, 1])]), $a(["rmqr", "R9x99", $_.vR9x99, 9, 99, 24, 50, 532, $a([99, 24, 99, 44]), $a([-1, -1, 1, 0, -1, -1, 2, 0])]), $a(["rmqr", "R9x139", $_.vR9x139, 9, 139, 28, 56, 797, $a([99, 36, 99, 66]), $a([-1, -1, 1, 1, -1, -1, 3, 0])]), $a(["rmqr", "R11x27", $_.vR11x27, 11, 27, 98, 99, 122, $a([99, 8, 99, 10]), $a([-1, -1, 1, 0, -1, -1, 1, 0])]), $a(["rmqr", "R11x43", $_.vR11x43, 11, 43, 22, 99, 249, $a([99, 12, 99, 20]), $a([-1, -1, 1, 0, -1, -1, 1, 0])]), $a(["rmqr", "R11x59", $_.vR11x59, 11, 59, 20, 40, 376, $a([99, 16, 99, 32]), $a([-1, -1, 1, 0, -1, -1, 1, 1])]), $a(["rmqr", "R11x77", $_.vR11x77, 11, 77, 26, 52, 538, $a([99, 24, 99, 44]), $a([-1, -1, 1, 0, -1, -1, 1, 1])]), $a(["rmqr", "R11x99", $_.vR11x99, 11, 99, 24, 50, 719, $a([99, 32, 99, 60]), $a([-1, -1, 1, 1, -1, -1, 1, 1])]), $a(["rmqr", "R11x139", $_.vR11x139, 11, 139, 28, 56, 1062, $a([99, 48, 99, 90]), $a([-1, -1, 2, 0, -1, -1, 3, 0])]), $a(["rmqr", "R13x27", $_.vR13x27, 13, 27, 98, 99, 172, $a([99, 9, 99, 14]), $a([-1, -1, 1, 0, -1, -1, 1, 0])]), $a(["rmqr", "R13x43", $_.vR13x43, 13, 43, 22, 99, 329, $a([99, 14, 99, 28]), $a([-1, -1, 1, 0, -1, -1, 1, 0])]), $a(["rmqr", "R13x59", $_.vR13x59, 13, 59, 20, 40, 486, $a([99, 22, 99, 40]), $a([-1, -1, 1, 0, -1, -1, 2, 0])]), $a(["rmqr", "R13x77", $_.vR13x77, 13, 77, 26, 52, 684, $a([99, 32, 99, 56]), $a([-1, -1, 1, 1, -1, -1, 1, 1])]), $a(["rmqr", "R13x99", $_.vR13x99, 13, 99, 24, 50, 907, $a([99, 40, 99, 78]), $a([-1, -1, 1, 1, -1, -1, 1, 2])]), $a(["rmqr", "R13x139", $_.vR13x139, 13, 139, 28, 56, 1328, $a([99, 60, 99, 112]), $a([-1, -1, 2, 1, -1, -1, 2, 2])]), $a(["rmqr", "R15x43", $_.vR15x43, 15, 43, 22, 99, 409, $a([99, 18, 99, 36]), $a([-1, -1, 1, 0, -1, -1, 1, 1])]), $a(["rmqr", "R15x59", $_.vR15x59, 15, 59, 20, 40, 596, $a([99, 26, 99, 48]), $a([-1, -1, 1, 0, -1, -1, 2, 0])]), $a(["rmqr", "R15x77", $_.vR15x77, 15, 77, 26, 52, 830, $a([99, 36, 99, 72]), $a([-1, -1, 1, 1, -1, -1, 2, 1])]), $a(["rmqr", "R15x99", $_.vR15x99, 15, 99, 24, 50, 1095, $a([99, 48, 99, 88]), $a([-1, -1, 2, 0, -1, -1, 4, 0])]), $a(["rmqr", "R15x139", $_.vR15x139, 15, 139, 28, 56, 1594, $a([99, 72, 99, 130]), $a([-1, -1, 2, 1, -1, -1, 1, 4])]), $a(["rmqr", "R17x43", $_.vR17x43, 17, 43, 22, 99, 489, $a([99, 22, 99, 40]), $a([-1, -1, 1, 0, -1, -1, 1, 1])]), $a(["rmqr", "R17x59", $_.vR17x59, 17, 59, 20, 40, 706, $a([99, 32, 99, 60]), $a([-1, -1, 2, 0, -1, -1, 2, 0])]), $a(["rmqr", "R17x77", $_.vR17x77, 17, 77, 26, 52, 976, $a([99, 44, 99, 84]), $a([-1, -1, 2, 0, -1, -1, 1, 2])]), $a(["rmqr", "R17x99", $_.vR17x99, 17, 99, 24, 50, 1283, $a([99, 60, 99, 104]), $a([-1, -1, 2, 1, -1, -1, 4, 0])]), $a(["rmqr", "R17x139", $_.vR17x139, 17, 139, 28, 56, 1860, $a([99, 80, 99, 156]), $a([-1, -1, 4, 0, -1, -1, 2, 4])])]);
  $k[$j++] = "eclval";
  $search("LMQH", $_.eclevel);
  $j--;
  var _Ki = $k[--$j];
  $k[$j - 1] = _Ki.length;
  var _Kk = $k[--$j];
  $k[$j - 1] = _Kk;
  var _Km = $k[--$j];
  $_[$k[--$j]] = _Km;
  for (var _Kq = 0, _Kp = $_.metrics.length - 1; _Kq <= _Kp; _Kq += 1) {
    $_.i = _Kq;
    $_.m = $get($_.metrics, $_.i);
    $_.frmt = $get($_.m, 0);
    $_.vers = $get($_.m, 1);
    $_.vergrp = $get($_.m, 2);
    $_.verind = $_.i - 44;
    $_.rows = $get($_.m, 3);
    $_.cols = $get($_.m, 4);
    $_.asp2 = $get($_.m, 5);
    $_.asp3 = $get($_.m, 6);
    $_.nmod = $get($_.m, 7);
    $_.ncws = ~~($_.nmod / 8);
    $_.rbit = $_.nmod % 8;
    $_.lc4b = false;
    if ($eq($_.vers, "M1") || $eq($_.vers, "M3")) {
      $_.ncws = $_.ncws + 1;
      $_.rbit = 0;
      $_.lc4b = true;
    }
    $_.ecws = $get($get($_.m, 8), $_.eclval);
    $_.dcws = $f($_.ncws - $_.ecws);
    var _LO = $_.lc4b ? 4 : 0;
    $_.dmod = $f($_.dcws * 8 - _LO);
    $_.ecb1 = $get($get($_.m, 9), $_.eclval * 2);
    $_.ecb2 = $get($get($_.m, 9), $_.eclval * 2 + 1);
    $_.okay = true;
    if ($ne($_.format, $_.frmt)) {
      $_.okay = false;
    }
    if ($eq($_.frmt, "micro") && $_.fnc1first) {
      $_.okay = false;
    }
    if ($ne($_.version, "unset") && $ne($_.version, $_.vers)) {
      $_.okay = false;
    }
    if ($_.ecb1 == -1 || $_.ecb2 == -1) {
      $_.okay = false;
    }
    $_.verbits = $get($_.msgbits, $_.vergrp);
    if ($_.verbits == -1) {
      $_.okay = false;
    } else {
      if ($_.verbits.length > $_.dmod) {
        $_.okay = false;
      }
    }
    $_.term = $geti("000000000", 0, $get($_.termlens, $_.vergrp));
    if ($_.okay) {
      break;
    }
  }
  if (!$_.okay) {
    $k[$j++] = "bwipp.qrcodeNoValidSymbol#21607";
    $k[$j++] = "Maximum length exceeded or invalid content";
    bwipp_raiseerror();
  }
  $_.format = $_.frmt;
  $_.version = $_.vers;
  $_.msgbits = $_.verbits;
  if (!$_.fixedeclevel) {
    for (var _Lx = $_.eclval + 1; _Lx <= 3; _Lx += 1) {
      $_.eclval_ = _Lx;
      $_.ecws_ = $get($get($_.m, 8), $_.eclval_);
      $_.dcws_ = $f($_.ncws - $_.ecws_);
      var _M6 = $_.lc4b ? 4 : 0;
      $_.dmod_ = $f($_.dcws_ * 8 - _M6);
      $_.ecb1_ = $get($get($_.m, 9), $_.eclval_ * 2);
      $_.ecb2_ = $get($get($_.m, 9), $_.eclval_ * 2 + 1);
      $_.okay = true;
      if ($_.ecb1_ == -1 || $_.ecb2_ == -1) {
        $_.okay = false;
      }
      if ($_.msgbits.length > $_.dmod_) {
        $_.okay = false;
      }
      if ($_.okay) {
        $_.eclval = $_.eclval_;
        $_.dcws = $_.dcws_;
        $_.dmod = $_.dmod_;
        $_.ecb1 = $_.ecb1_;
        $_.ecb2 = $_.ecb2_;
      }
    }
  }
  $_.dcpb = ~~($_.dcws / $f($_.ecb1 + $_.ecb2));
  $_.ecpb = ~~($_.ncws / $f($_.ecb1 + $_.ecb2)) - $_.dcpb;
  var _MW = $_.term;
  var _MX = $_.dmod;
  var _MY = $_.msgbits;
  var _MZ = $_.term;
  var _Ma = _MZ.length;
  var _Mb = $f(_MX - _MY.length);
  if ($f(_MX - _MY.length) > _MZ.length) {
    var _ = _Ma;
    _Ma = _Mb;
    _Mb = _;
  }
  $_.term = $geti(_MW, 0, _Mb);
  var _Mf = $s($_.msgbits.length + $_.term.length);
  $puti(_Mf, 0, $_.msgbits);
  $puti(_Mf, $_.msgbits.length, $_.term);
  $_.msgbits = _Mf;
  $_.pad = $s($_.dmod);
  for (var _Mn = 0, _Mm = $_.pad.length - 1; _Mn <= _Mm; _Mn += 1) {
    $put($_.pad, _Mn, 48);
  }
  $puti($_.pad, 0, $_.msgbits);
  $_.padnum = 0;
  var _Mu = $_.lc4b ? 5 : 1;
  for (var _Mw = ~~($ceil($_.msgbits.length / 8) * 8), _Mv = $f($_.dmod - _Mu); _Mw <= _Mv; _Mw += 8) {
    $puti($_.pad, _Mw, $get($_.padstrs, $_.padnum));
    $_.padnum = ($_.padnum + 1) % 2;
  }
  $_.cws = $a($_.dcws);
  for (var _N6 = 0, _N5 = $_.cws.length - 1; _N6 <= _N5; _N6 += 1) {
    $_.c = _N6;
    $_.bpcw = 8;
    if ($_.lc4b && $_.c == $_.cws.length - 1) {
      $_.bpcw = 4;
    }
    $_.cwb = $geti($_.pad, $_.c * 8, $_.bpcw);
    $_.cw = 0;
    for (var _NG = 0, _NF = $_.bpcw - 1; _NG <= _NF; _NG += 1) {
      $_.i = _NG;
      $_.cw = $f($_.cw + ~~$pow(2, $_.bpcw - $_.i - 1) * ($get($_.cwb, $_.i) - 48));
    }
    $put($_.cws, $_.c, $_.cw);
  }
  if ($_.lc4b) {
    var _NR = $_.cws;
    var _NS = $_.cws;
    $put(_NR, _NS.length - 1, $get(_NR, _NS.length - 1) << 4);
  }
  var _NV = $get($_.options, "debugcws") !== void 0;
  if (_NV) {
    $k[$j++] = "bwipp.debugcws#21674";
    $k[$j++] = $_.cws;
    bwipp_raiseerror();
  }
  $k[$j++] = Infinity;
  $k[$j++] = 1;
  for (var _NX = 0; _NX < 255; _NX++) {
    var _NY = $k[$j - 1];
    var _NZ = _NY * 2;
    $k[$j++] = _NZ;
    if (_NZ >= 256) {
      var _Na = $k[--$j];
      $k[$j++] = _Na ^ 285;
    }
  }
  $_.rsalog = $a();
  $_.rslog = $a(256);
  for (var _Nd = 1; _Nd <= 255; _Nd += 1) {
    $put($_.rslog, $get($_.rsalog, _Nd), _Nd);
  }
  $_.rsprod = function() {
    var _Ni = $k[$j - 1];
    var _Nj = $k[$j - 2];
    if (_Ni != 0 && _Nj != 0) {
      var _Nm = $get($_.rslog, $k[--$j]);
      var _Nr = $get($_.rsalog, $f(_Nm + $get($_.rslog, $k[--$j])) % 255);
      $k[$j++] = _Nr;
    } else {
      $j -= 2;
      $k[$j++] = 0;
    }
  };
  $k[$j++] = Infinity;
  $k[$j++] = 1;
  for (var _Nt = 0, _Nu = $_.ecpb; _Nt < _Nu; _Nt++) {
    $k[$j++] = 0;
  }
  $_.coeffs = $a();
  for (var _Ny = 0, _Nx = $_.ecpb - 1; _Ny <= _Nx; _Ny += 1) {
    $_.i = _Ny;
    $put($_.coeffs, $_.i + 1, $get($_.coeffs, $_.i));
    for (var _O5 = $_.i; _O5 >= 1; _O5 -= 1) {
      $_.j = _O5;
      $k[$j++] = $_.coeffs;
      $k[$j++] = $_.j;
      $k[$j++] = $get($_.coeffs, $_.j - 1);
      $k[$j++] = $get($_.coeffs, $_.j);
      $k[$j++] = $get($_.rsalog, $_.i);
      $_.rsprod();
      var _OH = $k[--$j];
      var _OI = $k[--$j];
      var _OJ = $k[--$j];
      $put($k[--$j], _OJ, $xo(_OI, _OH));
    }
    $k[$j++] = $_.coeffs;
    $k[$j++] = 0;
    $k[$j++] = $get($_.coeffs, 0);
    $k[$j++] = $get($_.rsalog, $_.i);
    $_.rsprod();
    var _OR = $k[--$j];
    var _OS = $k[--$j];
    $put($k[--$j], _OS, _OR);
  }
  $_.coeffs = $geti($_.coeffs, 0, $_.coeffs.length - 1);
  $_.rscodes = function() {
    $_.rscws = $k[--$j];
    $_.rsnd = $_.rscws.length;
    $k[$j++] = Infinity;
    $aload($_.rscws);
    for (var _Ob = 0, _Oc = $_.ecpb; _Ob < _Oc; _Ob++) {
      $k[$j++] = 0;
    }
    $_.rscws = $a();
    for (var _Og = 0, _Of = $_.rsnd - 1; _Og <= _Of; _Og += 1) {
      $_.m = _Og;
      $_.k = $get($_.rscws, $_.m);
      for (var _Om = 0, _Ol = $_.ecpb - 1; _Om <= _Ol; _Om += 1) {
        $_.j = _Om;
        $k[$j++] = $_.rscws;
        $k[$j++] = $_.m + $_.j + 1;
        $k[$j++] = $get($_.coeffs, $_.ecpb - $_.j - 1);
        $k[$j++] = $_.k;
        $_.rsprod();
        var _Oz = $k[--$j];
        var _P0 = $k[--$j];
        $put($k[--$j], _P0, $xo(_Oz, $get($_.rscws, $_.m + $_.j + 1)));
      }
    }
    $k[$j++] = $geti($_.rscws, $_.rsnd, $_.ecpb);
  };
  $_.dcwsb = $a($f($_.ecb1 + $_.ecb2));
  $_.ecwsb = $a($f($_.ecb1 + $_.ecb2));
  for (var _PE = 0, _PD = $_.ecb1 - 1; _PE <= _PD; _PE += 1) {
    $_.i = _PE;
    $put($_.dcwsb, $_.i, $geti($_.cws, $_.i * $_.dcpb, $_.dcpb));
    $k[$j++] = $_.ecwsb;
    $k[$j++] = $_.i;
    $k[$j++] = $get($_.dcwsb, $_.i);
    $_.rscodes();
    var _PR = $k[--$j];
    var _PS = $k[--$j];
    $put($k[--$j], _PS, _PR);
  }
  for (var _PW = 0, _PV = $_.ecb2 - 1; _PW <= _PV; _PW += 1) {
    $_.i = _PW;
    $put($_.dcwsb, $f($_.ecb1 + $_.i), $geti($_.cws, $f($_.ecb1 * $_.dcpb + $_.i * ($_.dcpb + 1)), $_.dcpb + 1));
    $k[$j++] = $_.ecwsb;
    $k[$j++] = $f($_.ecb1 + $_.i);
    $k[$j++] = $get($_.dcwsb, $f($_.ecb1 + $_.i));
    $_.rscodes();
    var _Po = $k[--$j];
    var _Pp = $k[--$j];
    $put($k[--$j], _Pp, _Po);
  }
  $_.cws = $a($_.ncws);
  $_.cw = 0;
  for (var _Pv = 0, _Pu = $_.dcpb; _Pv <= _Pu; _Pv += 1) {
    $_.i = _Pv;
    for (var _Pz = 0, _Py = $f($_.ecb1 + $_.ecb2) - 1; _Pz <= _Py; _Pz += 1) {
      $_.j = _Pz;
      if ($_.i < $get($_.dcwsb, $_.j).length) {
        $put($_.cws, $_.cw, $get($get($_.dcwsb, $_.j), $_.i));
        $_.cw = $_.cw + 1;
      }
    }
  }
  for (var _QE = 0, _QD = $_.ecpb - 1; _QE <= _QD; _QE += 1) {
    $_.i = _QE;
    for (var _QI = 0, _QH = $f($_.ecb1 + $_.ecb2) - 1; _QI <= _QH; _QI += 1) {
      $_.j = _QI;
      $put($_.cws, $_.cw, $get($get($_.ecwsb, $_.j), $_.i));
      $_.cw = $_.cw + 1;
    }
  }
  if ($_.rbit > 0) {
    $_.pad = $a($_.cws.length + 1);
    $puti($_.pad, 0, $_.cws);
    $put($_.pad, $_.pad.length - 1, 0);
    $_.cws = $_.pad;
  }
  if ($_.lc4b) {
    var _Qa = $_.cws;
    var _Qb = $_.dcws;
    $put(_Qa, _Qb - 1, $get(_Qa, _Qb - 1) >>> 4);
    for (var _Qg = $_.dcws - 1, _Qf = $_.ncws - 2; _Qg <= _Qf; _Qg += 1) {
      $_.i = _Qg;
      $put($_.cws, $_.i, ($get($_.cws, $_.i) & 15) << 4);
      $put($_.cws, $_.i, $get($_.cws, $_.i + 1) >>> 4 & 15 | $get($_.cws, $_.i));
    }
    $put($_.cws, $_.ncws - 1, ($get($_.cws, $_.ncws - 1) & 15) << 4);
  }
  var _R0 = $get($_.options, "debugecc") !== void 0;
  if (_R0) {
    $k[$j++] = "bwipp.debugecc#21776";
    $k[$j++] = $_.cws;
    bwipp_raiseerror();
  }
  $k[$j++] = Infinity;
  for (var _R4 = 0, _R5 = $_.rows * $_.cols; _R4 < _R5; _R4++) {
    $k[$j++] = -1;
  }
  $_.pixs = $a();
  $_.qmv = function() {
    var _R8 = $k[--$j];
    var _R9 = $k[--$j];
    $k[$j++] = $f(_R9 + _R8 * $_.cols);
  };
  if ($eq($_.format, "full")) {
    for (var _RD = 8, _RC = $_.cols - 9; _RD <= _RC; _RD += 1) {
      $_.i = _RD;
      $k[$j++] = $_.pixs;
      $k[$j++] = $_.i;
      $k[$j++] = 6;
      $_.qmv();
      var _RH = $k[--$j];
      $put($k[--$j], _RH, ($_.i + 1) % 2);
      $k[$j++] = $_.pixs;
      $k[$j++] = 6;
      $k[$j++] = $_.i;
      $_.qmv();
      var _RM = $k[--$j];
      $put($k[--$j], _RM, ($_.i + 1) % 2);
    }
  }
  if ($eq($_.format, "micro")) {
    for (var _RR = 8, _RQ = $_.cols - 1; _RR <= _RQ; _RR += 1) {
      $_.i = _RR;
      $k[$j++] = $_.pixs;
      $k[$j++] = $_.i;
      $k[$j++] = 0;
      $_.qmv();
      var _RV = $k[--$j];
      $put($k[--$j], _RV, ($_.i + 1) % 2);
      $k[$j++] = $_.pixs;
      $k[$j++] = 0;
      $k[$j++] = $_.i;
      $_.qmv();
      var _Ra = $k[--$j];
      $put($k[--$j], _Ra, ($_.i + 1) % 2);
    }
  }
  if ($eq($_.format, "rmqr")) {
    for (var _Rf = 3, _Re = $_.cols - 4; _Rf <= _Re; _Rf += 1) {
      $_.i = _Rf;
      $k[$j++] = $_.pixs;
      $k[$j++] = $_.i;
      $k[$j++] = 0;
      $_.qmv();
      var _Rj = $k[--$j];
      $put($k[--$j], _Rj, ($_.i + 1) % 2);
      $k[$j++] = $_.pixs;
      $k[$j++] = $_.i;
      $k[$j++] = $_.rows - 1;
      $_.qmv();
      var _Rp = $k[--$j];
      $put($k[--$j], _Rp, ($_.i + 1) % 2);
    }
    for (var _Rt = 3, _Rs = $_.rows - 4; _Rt <= _Rs; _Rt += 1) {
      $_.i = _Rt;
      $k[$j++] = $_.pixs;
      $k[$j++] = 0;
      $k[$j++] = $_.i;
      $_.qmv();
      var _Rx = $k[--$j];
      $put($k[--$j], _Rx, ($_.i + 1) % 2);
      $k[$j++] = $_.pixs;
      $k[$j++] = $_.cols - 1;
      $k[$j++] = $_.i;
      $_.qmv();
      var _S3 = $k[--$j];
      $put($k[--$j], _S3, ($_.i + 1) % 2);
    }
    for (var _SA = $_.asp2 - 1, _SB = $f($_.asp3 - $_.asp2), _S9 = $_.cols - 13; _SB < 0 ? _SA >= _S9 : _SA <= _S9; _SA += _SB) {
      $_.i = _SA;
      for (var _SE = 3, _SD = $_.rows - 4; _SE <= _SD; _SE += 1) {
        $_.j = _SE;
        $k[$j++] = $_.pixs;
        $k[$j++] = $_.i;
        $k[$j++] = $_.j;
        $_.qmv();
        var _SJ = $k[--$j];
        $put($k[--$j], _SJ, ($_.j + 1) % 2);
      }
    }
  }
  $_.fpat = $a([$a([1, 1, 1, 1, 1, 1, 1, 0]), $a([1, 0, 0, 0, 0, 0, 1, 0]), $a([1, 0, 1, 1, 1, 0, 1, 0]), $a([1, 0, 1, 1, 1, 0, 1, 0]), $a([1, 0, 1, 1, 1, 0, 1, 0]), $a([1, 0, 0, 0, 0, 0, 1, 0]), $a([1, 1, 1, 1, 1, 1, 1, 0]), $a([0, 0, 0, 0, 0, 0, 0, 0])]);
  $_.fsubpat = $a([$a([1, 1, 1, 1, 1, 9, 9, 9]), $a([1, 0, 0, 0, 1, 9, 9, 9]), $a([1, 0, 1, 0, 1, 9, 9, 9]), $a([1, 0, 0, 0, 1, 9, 9, 9]), $a([1, 1, 1, 1, 1, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9])]);
  $_.fcorpat = $a([$a([1, 1, 1, 9, 9, 9, 9, 9]), $a([1, 0, 9, 9, 9, 9, 9, 9]), $a([1, 9, 9, 9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9])]);
  $_.fnullpat = $a([$a([9, 9, 9, 9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9, 9, 9, 9])]);
  var _TA = /* @__PURE__ */ new Map([
    ["full", $a([$_.fpat, $_.fpat, $_.fpat, $_.fnullpat])],
    ["micro", $a([$_.fpat, $_.fnullpat, $_.fnullpat, $_.fnullpat])],
    ["rmqr", $a([$_.fpat, $_.fcorpat, $_.fcorpat, $_.fsubpat])]
  ]);
  $_.fpatmap = _TA;
  $_.fpats = $get($_.fpatmap, $_.format);
  for (var _TF = 0; _TF <= 7; _TF += 1) {
    $_.y = _TF;
    for (var _TG = 0; _TG <= 7; _TG += 1) {
      $_.x = _TG;
      $_.fpb0 = $get($get($get($_.fpats, 0), $_.y), $_.x);
      $_.fpb1 = $get($get($get($_.fpats, 1), $_.y), $_.x);
      $_.fpb2 = $get($get($get($_.fpats, 2), $_.y), $_.x);
      $_.fpb3 = $get($get($get($_.fpats, 3), $_.y), $_.x);
      if ($_.fpb0 != 9 && $_.y < $_.rows) {
        $k[$j++] = $_.pixs;
        $k[$j++] = $_.x;
        $k[$j++] = $_.y;
        $_.qmv();
        var _Tm = $k[--$j];
        $put($k[--$j], _Tm, $_.fpb0);
      }
      if ($_.fpb1 != 9) {
        $k[$j++] = $_.pixs;
        $k[$j++] = $f($_.cols - $_.x) - 1;
        $k[$j++] = $_.y;
        $_.qmv();
        var _Tu = $k[--$j];
        $put($k[--$j], _Tu, $_.fpb1);
      }
      if ($_.fpb2 != 9) {
        $k[$j++] = $_.pixs;
        $k[$j++] = $_.x;
        $k[$j++] = $f($_.rows - $_.y) - 1;
        $_.qmv();
        var _U2 = $k[--$j];
        $put($k[--$j], _U2, $_.fpb2);
      }
      if ($_.fpb3 != 9) {
        $k[$j++] = $_.pixs;
        $k[$j++] = $f($_.cols - $_.x) - 1;
        $k[$j++] = $f($_.rows - $_.y) - 1;
        $_.qmv();
        var _UB = $k[--$j];
        $put($k[--$j], _UB, $_.fpb3);
      }
    }
  }
  $_.algnpatfull = $a([$a([1, 1, 1, 1, 1]), $a([1, 0, 0, 0, 1]), $a([1, 0, 1, 0, 1]), $a([1, 0, 0, 0, 1]), $a([1, 1, 1, 1, 1])]);
  $_.algnpatrmqr = $a([$a([1, 1, 1, 9, 9]), $a([1, 0, 1, 9, 9]), $a([1, 1, 1, 9, 9]), $a([9, 9, 9, 9, 9]), $a([9, 9, 9, 9, 9])]);
  $_.putalgnpat = function() {
    $_.py = $k[--$j];
    $_.px = $k[--$j];
    for (var _US = 0; _US <= 4; _US += 1) {
      $_.pb = _US;
      for (var _UT = 0; _UT <= 4; _UT += 1) {
        $_.pa = _UT;
        $_.algnb = $get($get($_.algnpat, $_.pb), $_.pa);
        if ($_.algnb != 9) {
          $k[$j++] = $_.pixs;
          $k[$j++] = $f($_.px + $_.pa);
          $k[$j++] = $f($_.py + $_.pb);
          $_.qmv();
          var _Ug = $k[--$j];
          $put($k[--$j], _Ug, $_.algnb);
        }
      }
    }
  };
  if ($eq($_.format, "full")) {
    $_.algnpat = $_.algnpatfull;
    for (var _Up = $_.asp2 - 2, _Uq = $f($_.asp3 - $_.asp2), _Uo = $_.cols - 13; _Uq < 0 ? _Up >= _Uo : _Up <= _Uo; _Up += _Uq) {
      $_.i = _Up;
      $k[$j++] = $_.i;
      $k[$j++] = 4;
      $_.putalgnpat();
      $k[$j++] = 4;
      $k[$j++] = $_.i;
      $_.putalgnpat();
    }
    for (var _Uy = $_.asp2 - 2, _Uz = $f($_.asp3 - $_.asp2), _Ux = $_.cols - 9; _Uz < 0 ? _Uy >= _Ux : _Uy <= _Ux; _Uy += _Uz) {
      $_.x = _Uy;
      for (var _V5 = $_.asp2 - 2, _V6 = $f($_.asp3 - $_.asp2), _V4 = $_.rows - 9; _V6 < 0 ? _V5 >= _V4 : _V5 <= _V4; _V5 += _V6) {
        $_.y = _V5;
        $k[$j++] = $_.x;
        $k[$j++] = $_.y;
        $_.putalgnpat();
      }
    }
  }
  if ($eq($_.format, "rmqr")) {
    $_.algnpat = $_.algnpatrmqr;
    for (var _VG = $_.asp2 - 2, _VH = $f($_.asp3 - $_.asp2), _VF = $_.cols - 13; _VH < 0 ? _VG >= _VF : _VG <= _VF; _VG += _VH) {
      $_.i = _VG;
      $k[$j++] = $_.i;
      $k[$j++] = 0;
      $_.putalgnpat();
      $k[$j++] = $_.i;
      $k[$j++] = $_.rows - 3;
      $_.putalgnpat();
    }
  }
  $_.formatmapmicro = $a([$a([$a([1, 8])]), $a([$a([2, 8])]), $a([$a([3, 8])]), $a([$a([4, 8])]), $a([$a([5, 8])]), $a([$a([6, 8])]), $a([$a([7, 8])]), $a([$a([8, 8])]), $a([$a([8, 7])]), $a([$a([8, 6])]), $a([$a([8, 5])]), $a([$a([8, 4])]), $a([$a([8, 3])]), $a([$a([8, 2])]), $a([$a([8, 1])])]);
  var _YK = /* @__PURE__ */ new Map([
    ["full", $a([$a([$a([0, 8]), $a([8, $_.cols - 1])]), $a([$a([1, 8]), $a([8, $_.cols - 2])]), $a([$a([2, 8]), $a([8, $_.cols - 3])]), $a([$a([3, 8]), $a([8, $_.cols - 4])]), $a([$a([4, 8]), $a([8, $_.cols - 5])]), $a([$a([5, 8]), $a([8, $_.cols - 6])]), $a([$a([7, 8]), $a([8, $_.cols - 7])]), $a([$a([8, 8]), $a([$_.cols - 8, 8])]), $a([$a([8, 7]), $a([$_.cols - 7, 8])]), $a([$a([8, 5]), $a([$_.cols - 6, 8])]), $a([$a([8, 4]), $a([$_.cols - 5, 8])]), $a([$a([8, 3]), $a([$_.cols - 4, 8])]), $a([$a([8, 2]), $a([$_.cols - 3, 8])]), $a([$a([8, 1]), $a([$_.cols - 2, 8])]), $a([$a([8, 0]), $a([$_.cols - 1, 8])])])],
    ["micro", $_.formatmapmicro],
    ["rmqr", $a([$a([$a([11, 3]), $a([$_.cols - 3, $_.rows - 6])]), $a([$a([11, 2]), $a([$_.cols - 4, $_.rows - 6])]), $a([$a([11, 1]), $a([$_.cols - 5, $_.rows - 6])]), $a([$a([10, 5]), $a([$_.cols - 6, $_.rows - 2])]), $a([$a([10, 4]), $a([$_.cols - 6, $_.rows - 3])]), $a([$a([10, 3]), $a([$_.cols - 6, $_.rows - 4])]), $a([$a([10, 2]), $a([$_.cols - 6, $_.rows - 5])]), $a([$a([10, 1]), $a([$_.cols - 6, $_.rows - 6])]), $a([$a([9, 5]), $a([$_.cols - 7, $_.rows - 2])]), $a([$a([9, 4]), $a([$_.cols - 7, $_.rows - 3])]), $a([$a([9, 3]), $a([$_.cols - 7, $_.rows - 4])]), $a([$a([9, 2]), $a([$_.cols - 7, $_.rows - 5])]), $a([$a([9, 1]), $a([$_.cols - 7, $_.rows - 6])]), $a([$a([8, 5]), $a([$_.cols - 8, $_.rows - 2])]), $a([$a([8, 4]), $a([$_.cols - 8, $_.rows - 3])]), $a([$a([8, 3]), $a([$_.cols - 8, $_.rows - 4])]), $a([$a([8, 2]), $a([$_.cols - 8, $_.rows - 5])]), $a([$a([8, 1]), $a([$_.cols - 8, $_.rows - 6])])])]
  ]);
  $_.formatmap = $get(_YK, $_.format);
  $forall($_.formatmap, function() {
    $forall($k[--$j], function() {
      $aload($k[--$j]);
      $_.qmv();
      $put($_.pixs, $k[--$j], 1);
    });
  });
  if ($eq($_.format, "full") && $_.cols >= 45) {
    $_.versionmap = $a([$a([$a([$_.cols - 9, 5]), $a([5, $_.cols - 9])]), $a([$a([$_.cols - 10, 5]), $a([5, $_.cols - 10])]), $a([$a([$_.cols - 11, 5]), $a([5, $_.cols - 11])]), $a([$a([$_.cols - 9, 4]), $a([4, $_.cols - 9])]), $a([$a([$_.cols - 10, 4]), $a([4, $_.cols - 10])]), $a([$a([$_.cols - 11, 4]), $a([4, $_.cols - 11])]), $a([$a([$_.cols - 9, 3]), $a([3, $_.cols - 9])]), $a([$a([$_.cols - 10, 3]), $a([3, $_.cols - 10])]), $a([$a([$_.cols - 11, 3]), $a([3, $_.cols - 11])]), $a([$a([$_.cols - 9, 2]), $a([2, $_.cols - 9])]), $a([$a([$_.cols - 10, 2]), $a([2, $_.cols - 10])]), $a([$a([$_.cols - 11, 2]), $a([2, $_.cols - 11])]), $a([$a([$_.cols - 9, 1]), $a([1, $_.cols - 9])]), $a([$a([$_.cols - 10, 1]), $a([1, $_.cols - 10])]), $a([$a([$_.cols - 11, 1]), $a([1, $_.cols - 11])]), $a([$a([$_.cols - 9, 0]), $a([0, $_.cols - 9])]), $a([$a([$_.cols - 10, 0]), $a([0, $_.cols - 10])]), $a([$a([$_.cols - 11, 0]), $a([0, $_.cols - 11])])]);
  } else {
    $_.versionmap = $a([]);
  }
  var _Zy = $_.versionmap;
  for (var _Zz = 0, _a0 = _Zy.length; _Zz < _a0; _Zz++) {
    $forall($get(_Zy, _Zz), function() {
      $aload($k[--$j]);
      $_.qmv();
      $put($_.pixs, $k[--$j], 0);
    });
  }
  if ($eq($_.format, "full")) {
    $k[$j++] = $_.pixs;
    $k[$j++] = 8;
    $k[$j++] = $_.rows - 8;
    $_.qmv();
    var _a8 = $k[--$j];
    $put($k[--$j], _a8, 0);
  }
  var _aS = $a([function() {
    var _aA = $k[--$j];
    var _aB = $k[--$j];
    $k[$j++] = $f(_aB + _aA) % 2;
  }, function() {
    var _aC = $k[--$j];
    $k[$j - 1] = _aC;
    var _aE = $k[--$j];
    $k[$j++] = _aE % 2;
  }, function() {
    $j--;
    var _aF = $k[--$j];
    $k[$j++] = _aF % 3;
  }, function() {
    var _aG = $k[--$j];
    var _aH = $k[--$j];
    $k[$j++] = $f(_aH + _aG) % 3;
  }, function() {
    var _aI = $k[--$j];
    var _aJ = $k[--$j];
    $k[$j++] = (~~(_aI / 2) + ~~(_aJ / 3)) % 2;
  }, function() {
    var _aK = $k[--$j];
    var _aM = $k[--$j] * _aK;
    $k[$j++] = $f(_aM % 2 + _aM % 3);
  }, function() {
    var _aN = $k[--$j];
    var _aP = $k[--$j] * _aN;
    $k[$j++] = $f(_aP % 2 + _aP % 3) % 2;
  }, function() {
    var _aQ = $k[--$j];
    var _aR = $k[--$j];
    $k[$j++] = $f(_aR * _aQ % 3 + (_aR + _aQ) % 2) % 2;
  }]);
  var _ad = $a([function() {
    var _aT = $k[--$j];
    $k[$j - 1] = _aT;
    var _aV = $k[--$j];
    $k[$j++] = _aV % 2;
  }, function() {
    var _aW = $k[--$j];
    var _aX = $k[--$j];
    $k[$j++] = (~~(_aW / 2) + ~~(_aX / 3)) % 2;
  }, function() {
    var _aY = $k[--$j];
    var _aa = $k[--$j] * _aY;
    $k[$j++] = $f(_aa % 2 + _aa % 3) % 2;
  }, function() {
    var _ab = $k[--$j];
    var _ac = $k[--$j];
    $k[$j++] = $f(_ac * _ab % 3 + (_ac + _ab) % 2) % 2;
  }]);
  var _ag = $a([function() {
    var _ae = $k[--$j];
    var _af = $k[--$j];
    $k[$j++] = (~~(_ae / 2) + ~~(_af / 3)) % 2;
  }]);
  var _ah = /* @__PURE__ */ new Map([
    ["full", _aS],
    ["micro", _ad],
    ["rmqr", _ag]
  ]);
  $_.maskfuncs = $get(_ah, $_.format);
  if ($_.mask != -1) {
    $_.maskfuncs = $a([$get($_.maskfuncs, $_.mask - 1)]);
    $_.bestmaskval = $_.mask - 1;
  }
  $_.masks = $a($_.maskfuncs.length);
  for (var _au = 0, _at = $_.masks.length - 1; _au <= _at; _au += 1) {
    $_.m = _au;
    $_.mask = $a($_.rows * $_.cols);
    for (var _b0 = 0, _az = $_.rows - 1; _b0 <= _az; _b0 += 1) {
      $_.j = _b0;
      for (var _b3 = 0, _b2 = $_.cols - 1; _b3 <= _b2; _b3 += 1) {
        $_.i = _b3;
        $k[$j++] = $_.i;
        $k[$j++] = $_.j;
        if ($get($_.maskfuncs, $_.m)() === true) {
          break;
        }
        var _b9 = $k[--$j];
        $k[$j++] = _b9 == 0;
        $k[$j++] = $_.pixs;
        $k[$j++] = $_.i;
        $k[$j++] = $_.j;
        $_.qmv();
        var _bD = $k[--$j];
        var _bF = $get($k[--$j], _bD);
        var _bG = $k[--$j];
        var _bH = _bG && _bF == -1 ? 1 : 0;
        $k[$j++] = _bH;
        $k[$j++] = $_.mask;
        $k[$j++] = $_.i;
        $k[$j++] = $_.j;
        $_.qmv();
        var _bL = $k[$j - 3];
        var _bM = $k[$j - 1];
        $put($k[$j - 2], _bM, _bL);
        $j -= 3;
      }
    }
    $put($_.masks, $_.m, $_.mask);
  }
  var _bT = $ne($_.format, "rmqr") ? 1 : 2;
  $_.posx = $f($_.cols - _bT);
  $_.posy = $_.rows - 1;
  $_.dir = -1;
  $_.col = 1;
  $_.num = 0;
  for (; ; ) {
    if ($_.posx < 0) {
      break;
    }
    $k[$j++] = $_.pixs;
    $k[$j++] = $_.posx;
    $k[$j++] = $_.posy;
    $_.qmv();
    var _bZ = $k[--$j];
    if ($get($k[--$j], _bZ) == -1) {
      var _be = $get($_.cws, ~~($_.num / 8));
      var _bg = -(7 - $_.num % 8);
      $k[$j++] = (_bg < 0 ? _be >>> -_bg : _be << _bg) & 1;
      $k[$j++] = $_.pixs;
      $k[$j++] = $_.posx;
      $k[$j++] = $_.posy;
      $_.qmv();
      var _bk = $k[$j - 3];
      var _bl = $k[$j - 1];
      $put($k[$j - 2], _bl, _bk);
      $j -= 3;
      $_.num = $_.num + 1;
    }
    if ($_.col == 1) {
      $_.col = 0;
      $_.posx = $_.posx - 1;
    } else {
      $_.col = 1;
      $_.posx = $_.posx + 1;
      $_.posy = $f($_.posy + $_.dir);
      if ($_.posy < 0 || $_.posy >= $_.rows) {
        $_.dir = $_.dir * -1;
        $_.posy = $f($_.posy + $_.dir);
        $_.posx = $_.posx - 2;
        if ($eq($_.format, "full") && $_.posx == 6) {
          $_.posx = $_.posx - 1;
        }
      }
    }
  }
  $_.evalfulln1n3 = function() {
    $_.scrle = $k[--$j];
    $k[$j++] = "scr1";
    $k[$j++] = 0;
    $forall($_.scrle, function() {
      var _c5 = $k[$j - 1];
      if (_c5 >= 5) {
        var _c6 = $k[--$j];
        var _c8 = $f($k[--$j] + _c6) - 2;
        $k[$j++] = _c8;
        $k[$j++] = _c8;
      }
      $j--;
    });
    var _c9 = $k[--$j];
    $_[$k[--$j]] = _c9;
    $_.scr3 = 0;
    for (var _cD = 3, _cC = $_.scrle.length - 3; _cD <= _cC; _cD += 2) {
      $_.j = _cD;
      if ($get($_.scrle, $_.j) % 3 == 0) {
        $_.fact = ~~($get($_.scrle, $_.j) / 3);
        var _cM = $geti($_.scrle, $_.j - 2, 5);
        for (var _cN = 0, _cO = _cM.length; _cN < _cO; _cN++) {
          $k[$j++] = $get(_cM, _cN) == $_.fact;
        }
        var _cR = $k[--$j];
        var _cS = $k[--$j];
        $k[$j - 1] = $an(_cS, _cR);
        var _cU = $k[--$j];
        var _cV = $k[--$j];
        if ($k[--$j] && (_cV && _cU)) {
          if ($_.j == 3 || $_.j + 4 >= $_.scrle.length) {
            $_.scr3 = $_.scr3 + 40;
          } else {
            if ($get($_.scrle, $_.j - 3) >= 4 || $get($_.scrle, $_.j + 3) >= 4) {
              $_.scr3 = $_.scr3 + 40;
            }
          }
        }
      }
    }
    $k[$j++] = $_.scr1;
    $k[$j++] = $_.scr3;
  };
  $_.evalfull = function() {
    $_.sym = $k[--$j];
    $_.n1 = 0;
    $_.n2 = 0;
    $_.n3 = 0;
    $_.rle = $a($_.cols + 1);
    $_.lastpairs = $a($_.cols);
    $_.thispairs = $a($_.cols);
    $_.colsadd1 = $_.cols + 1;
    for (var _cu = 0, _ct = $_.cols - 1; _cu <= _ct; _cu += 1) {
      $_.i = _cu;
      $k[$j++] = Infinity;
      var _cw = $_.cols;
      $k[$j++] = 0;
      $k[$j++] = 0;
      for (var _cy = $_.i, _cz = _cw, _cx = _cw * _cw - 1; _cz < 0 ? _cy >= _cx : _cy <= _cx; _cy += _cz) {
        var _d1 = $get($_.sym, _cy);
        var _d2 = $k[--$j];
        $k[$j++] = _d1;
        if ($eq(_d2, _d1)) {
          var _d3 = $k[--$j];
          var _d4 = $k[--$j];
          $k[$j++] = _d4 + 1;
          $k[$j++] = _d3;
        } else {
          var _d5 = $k[--$j];
          $k[$j++] = 1;
          $k[$j++] = _d5;
        }
      }
      $j--;
      var _d7 = $counttomark() + 2;
      $astore($geti($_.rle, 0, _d7 - 2));
      $_.evalfulln1n3();
      $_.n3 = $f($k[--$j] + $_.n3);
      $_.n1 = $f($k[--$j] + $_.n1);
      $j--;
      $_.symrow = $geti($_.sym, $_.i * $_.cols, $_.cols);
      $k[$j++] = Infinity;
      var _dI = $_.symrow;
      $k[$j++] = 0;
      $k[$j++] = 0;
      for (var _dJ = 0, _dK = _dI.length; _dJ < _dK; _dJ++) {
        var _dL = $get(_dI, _dJ);
        var _dM = $k[--$j];
        $k[$j++] = _dL;
        if ($eq(_dM, _dL)) {
          var _dN = $k[--$j];
          var _dO = $k[--$j];
          $k[$j++] = _dO + 1;
          $k[$j++] = _dN;
        } else {
          var _dP = $k[--$j];
          $k[$j++] = 1;
          $k[$j++] = _dP;
        }
      }
      $j--;
      var _dR = $counttomark() + 2;
      $astore($geti($_.rle, 0, _dR - 2));
      $_.evalfulln1n3();
      $_.n3 = $f($k[--$j] + $_.n3);
      $_.n1 = $f($k[--$j] + $_.n1);
      $j--;
      var _dX = $_.thispairs;
      $_.thispairs = $_.lastpairs;
      $_.lastpairs = _dX;
      var _db = $get($_.symrow, 0) == 1 ? 0 : 1;
      var _dc = $_.symrow;
      $k[$j++] = _db;
      for (var _dd = 0, _de = _dc.length; _dd < _de; _dd++) {
        var _df = $get(_dc, _dd);
        var _dg = $k[--$j];
        $k[$j++] = $f(_dg + _df);
        $k[$j++] = _df;
      }
      $j--;
      $astore($_.thispairs);
      $j--;
      if ($_.i > 0) {
        $k[$j++] = Infinity;
        $aload($_.lastpairs);
        $aload($_.thispairs);
        $k[$j++] = $_.n2;
        for (var _dn = 0, _do = $_.cols; _dn < _do; _dn++) {
          var _dp = $k[--$j];
          var _dq = $k[--$j];
          $k[$j++] = _dp;
          $k[$j++] = _dq;
          var _ds = $k[$j - 1 - $_.colsadd1];
          if (($f($k[--$j] + _ds) & 3) == 0) {
            var _du = $k[--$j];
            $k[$j++] = _du + 3;
          }
        }
        $_.n2 = $k[--$j];
        $cleartomark();
      }
    }
    $k[$j++] = "dark";
    $k[$j++] = 0;
    $forall($_.sym, function() {
      var _dx = $k[--$j];
      var _dy = $k[--$j];
      $k[$j++] = $f(_dy + _dx);
    });
    var _dz = $k[--$j];
    $_[$k[--$j]] = _dz;
    var _e2 = $_.cols;
    $_.n4 = ~~($abs($_.dark * 100 / (_e2 * _e2) - 50) / 5) * 10;
    $k[$j++] = $f($_.n1 + $_.n2 + $_.n3 + $_.n4);
  };
  $_.evalmicro = function() {
    $_.sym = $k[--$j];
    $_.dkrhs = 0;
    $_.dkbot = 0;
    for (var _eA = 1, _e9 = $_.cols - 1; _eA <= _e9; _eA += 1) {
      $_.i = _eA;
      $k[$j++] = "dkrhs";
      $k[$j++] = $_.dkrhs;
      $k[$j++] = $_.sym;
      $k[$j++] = $_.cols - 1;
      $k[$j++] = $_.i;
      $_.qmv();
      var _eF = $k[--$j];
      var _eH = $get($k[--$j], _eF);
      var _eI = $k[--$j];
      $_[$k[--$j]] = $f(_eI + _eH);
      $k[$j++] = "dkbot";
      $k[$j++] = $_.dkbot;
      $k[$j++] = $_.sym;
      $k[$j++] = $_.i;
      $k[$j++] = $_.cols - 1;
      $_.qmv();
      var _eO = $k[--$j];
      var _eQ = $get($k[--$j], _eO);
      var _eR = $k[--$j];
      $_[$k[--$j]] = $f(_eR + _eQ);
    }
    if ($_.dkrhs <= $_.dkbot) {
      $k[$j++] = -($_.dkrhs * 16 + $_.dkbot);
    } else {
      $k[$j++] = -($_.dkbot * 16 + $_.dkrhs);
    }
  };
  $_.bestscore = 999999999;
  for (var _eb = 0, _ea = $_.masks.length - 1; _eb <= _ea; _eb += 1) {
    $_.m = _eb;
    $_.masksym = $a($_.rows * $_.cols);
    for (var _ei = 0, _eh = $_.rows * $_.cols - 1; _ei <= _eh; _ei += 1) {
      $_.i = _ei;
      $put($_.masksym, $_.i, $xo($get($_.pixs, $_.i), $get($get($_.masks, $_.m), $_.i)));
    }
    if ($_.masks.length != 1) {
      if ($eq($_.format, "full")) {
        $k[$j++] = $_.masksym;
        $_.evalfull();
        $_.score = $k[--$j];
      } else {
        $k[$j++] = $_.masksym;
        $_.evalmicro();
        $_.score = $k[--$j];
      }
      if ($_.score < $_.bestscore) {
        $_.bestsym = $_.masksym;
        $_.bestmaskval = $_.m;
        $_.bestscore = $_.score;
      }
    } else {
      $_.bestsym = $_.masksym;
    }
  }
  $_.pixs = $_.bestsym;
  if ($eq($_.format, "full")) {
    $k[$j++] = $_.pixs;
    $k[$j++] = 8;
    $k[$j++] = $_.cols - 8;
    $_.qmv();
    var _f9 = $k[--$j];
    $put($k[--$j], _f9, 1);
  }
  $_.fmtvalsfull = $a([21522, 20773, 24188, 23371, 17913, 16590, 20375, 19104, 30660, 29427, 32170, 30877, 26159, 25368, 27713, 26998, 5769, 5054, 7399, 6608, 1890, 597, 3340, 2107, 13663, 12392, 16177, 14854, 9396, 8579, 11994, 11245]);
  $_.fmtvalsmicro = $a([17477, 16754, 20011, 19228, 21934, 20633, 24512, 23287, 26515, 25252, 28157, 26826, 30328, 29519, 31766, 31009, 1758, 1001, 3248, 2439, 5941, 4610, 7515, 6252, 9480, 8255, 12134, 10833, 13539, 12756, 16013, 15290]);
  $_.fmtvalsrmqr1 = $a([129714, 124311, 121821, 115960, 112748, 108361, 104707, 99878, 98062, 90155, 89697, 82244, 81360, 74485, 72895, 66458, 61898, 61167, 53413, 53120, 45844, 44081, 37499, 36190, 29814, 27475, 21785, 19004, 13992, 10637, 6087, 2274, 258919, 257090, 250376, 249133, 242105, 241308, 233686, 233459, 227035, 223742, 219060, 215185, 209925, 207648, 202090, 199247, 194591, 190266, 186736, 181845, 178881, 173540, 170926, 165003, 163235, 156294, 154828, 148457, 147325, 139352, 138770, 131383]);
  $_.fmtvalsrmqr2 = $a([133755, 136542, 142100, 144433, 149669, 153472, 158154, 161519, 167879, 168162, 175784, 176525, 183577, 184892, 191606, 193363, 196867, 204326, 204908, 212809, 213981, 220408, 221874, 228759, 230591, 236442, 239056, 244469, 247393, 252228, 255758, 260139, 942, 7307, 8897, 15844, 16752, 24149, 24607, 32570, 34322, 39223, 42877, 47192, 50380, 56297, 58787, 64134, 67798, 71667, 76217, 79516, 84488, 87341, 93031, 95298, 101738, 102991, 109573, 111392, 118708, 118929, 126683, 127486]);
  if ($eq($_.format, "full")) {
    $_.ecid = $get($a([1, 0, 3, 2]), $_.eclval);
    $_.fmtval = $get($_.fmtvalsfull, ($_.ecid << 3) + $_.bestmaskval);
    for (var _fQ = 0, _fP = $_.formatmap.length - 1; _fQ <= _fP; _fQ += 1) {
      $_.i = _fQ;
      $forall($get($_.formatmap, $_.i), function() {
        var _fV = $k[--$j];
        $k[$j++] = $_.pixs;
        $aload(_fV);
        $_.qmv();
        var _fW = $_.fmtval;
        var _fY = -(14 - $_.i);
        var _fZ = $k[--$j];
        $put($k[--$j], _fZ, (_fY < 0 ? _fW >>> -_fY : _fW << _fY) & 1);
      });
    }
  }
  if ($eq($_.format, "micro")) {
    $_.symid = $get($get($a([$a([0]), $a([1, 2]), $a([3, 4]), $a([5, 6, 7])]), ~~(($_.cols - 11) / 2)), $_.eclval);
    $_.fmtval = $get($_.fmtvalsmicro, ($_.symid << 2) + $_.bestmaskval);
    for (var _fr = 0, _fq = $_.formatmap.length - 1; _fr <= _fq; _fr += 1) {
      $_.i = _fr;
      $k[$j++] = $_.pixs;
      $aload($get($get($_.formatmap, $_.i), 0));
      $_.qmv();
      var _fx = $_.fmtval;
      var _fz = -(14 - $_.i);
      var _g0 = $k[--$j];
      $put($k[--$j], _g0, (_fz < 0 ? _fx >>> -_fz : _fx << _fz) & 1);
    }
  }
  if ($eq($_.format, "rmqr")) {
    $_.fmtvalu = ($get($a([-1, 0, -1, 1]), $_.eclval) << 5) + $_.verind;
    $_.fmtval1 = $get($_.fmtvalsrmqr1, $_.fmtvalu);
    $_.fmtval2 = $get($_.fmtvalsrmqr2, $_.fmtvalu);
    for (var _gF = 0, _gE = $_.formatmap.length - 1; _gF <= _gE; _gF += 1) {
      $_.i = _gF;
      $k[$j++] = $_.pixs;
      $aload($get($get($_.formatmap, $_.i), 0));
      $_.qmv();
      var _gL = $_.fmtval1;
      var _gN = -(17 - $_.i);
      var _gO = $k[--$j];
      $put($k[--$j], _gO, (_gN < 0 ? _gL >>> -_gN : _gL << _gN) & 1);
      $k[$j++] = $_.pixs;
      $aload($get($get($_.formatmap, $_.i), 1));
      $_.qmv();
      var _gV = $_.fmtval2;
      var _gX = -(17 - $_.i);
      var _gY = $k[--$j];
      $put($k[--$j], _gY, (_gX < 0 ? _gV >>> -_gX : _gV << _gX) & 1);
    }
  }
  $_.vervals = $a([31892, 34236, 39577, 42195, 48118, 51042, 55367, 58893, 63784, 68472, 70749, 76311, 79154, 84390, 87683, 92361, 96236, 102084, 102881, 110507, 110734, 117786, 119615, 126325, 127568, 133589, 136944, 141498, 145311, 150283, 152622, 158308, 161089, 167017]);
  if ($eq($_.format, "full") && $_.cols >= 45) {
    $_.verval = $get($_.vervals, ~~(($_.cols - 17) / 4) - 7);
    for (var _gj = 0, _gi = $_.versionmap.length - 1; _gj <= _gi; _gj += 1) {
      $_.i = _gj;
      $forall($get($_.versionmap, $_.i), function() {
        var _go = $k[--$j];
        $k[$j++] = $_.pixs;
        $forall(_go);
        $_.qmv();
        var _gp = $_.verval;
        var _gr = -(17 - $_.i);
        var _gs = $k[--$j];
        $put($k[--$j], _gs, (_gr < 0 ? _gp >>> -_gr : _gp << _gr) & 1);
      });
    }
  }
  $k[$j++] = Infinity;
  $k[$j++] = "ren";
  $k[$j++] = "renmatrix";
  $k[$j++] = "pixs";
  $k[$j++] = $_.pixs;
  $k[$j++] = "pixx";
  $k[$j++] = $_.cols;
  $k[$j++] = "pixy";
  $k[$j++] = $_.rows;
  $k[$j++] = "height";
  $k[$j++] = $_.rows * 2 / 72;
  $k[$j++] = "width";
  $k[$j++] = $_.cols * 2 / 72;
  $k[$j++] = "borderleft";
  if ($eq($_.format, "full")) {
    $k[$j++] = 4;
  } else {
    $k[$j++] = 2;
  }
  $k[$j++] = "borderright";
  if ($eq($_.format, "full")) {
    $k[$j++] = 4;
  } else {
    $k[$j++] = 2;
  }
  $k[$j++] = "bordertop";
  if ($eq($_.format, "full")) {
    $k[$j++] = 4;
  } else {
    $k[$j++] = 2;
  }
  $k[$j++] = "borderbottom";
  if ($eq($_.format, "full")) {
    $k[$j++] = 4;
  } else {
    $k[$j++] = 2;
  }
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  var _h4 = $d();
  $k[$j++] = _h4;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_swissqrcode() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.parse = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  var _3 = /* @__PURE__ */ new Map([
    ["parse", $_.parse],
    ["parseonly", true],
    ["parsefnc", false]
  ]);
  $_.fncvals = _3;
  $k[$j++] = "barcode";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.fncvals;
  bwipp_parseinput();
  var _6 = $k[--$j];
  $_[$k[--$j]] = _6;
  $_.barlen = $_.barcode.length;
  delete $_.options["parse"];
  if ($_.barcode.length > 997) {
    $k[$j++] = "bwipp.swissqrcodeBadLength#22347";
    $k[$j++] = "Swiss QR Code input must not exceed 997 digits";
    bwipp_raiseerror();
  }
  $put($_.options, "dontdraw", true);
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_qrcode();
  var _E = $k[--$j];
  $_[$k[--$j]] = _E;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    $$.save();
    var _K = $$.currpos();
    $$.translate(_K.x, _K.y);
    var _L = 72 / 25.4;
    $$.scale(_L, _L);
    $$.save();
    $$.newpath();
    $$.moveto(0, 0);
    $$.lineto(46, 0);
    $$.lineto(46, 46);
    $$.lineto(0, 46);
    $$.closepath();
    $$.moveto(19.5, 19.5);
    $$.lineto(19.5, 26.5);
    $$.lineto(26.5, 26.5);
    $$.lineto(26.5, 19.5);
    $$.closepath();
    $$.clip();
    $$.save();
    $$.moveto(0, 0);
    var _O = 46 / $get($_.args, "pixx") / 2;
    $$.scale(_O, _O);
    bwipp_renmatrix();
    $$.restore();
    $$.restore();
    $$.translate(19.5, 19.5);
    var _P = 7 / 83;
    $$.scale(_P, _P);
    $$.newpath();
    $$.moveto(6, 6);
    $$.lineto(6, 77);
    $$.lineto(77, 77);
    $$.lineto(77, 6);
    $$.closepath();
    $$.moveto(49, 18);
    $$.lineto(49, 34);
    $$.lineto(65, 34);
    $$.lineto(65, 49);
    $$.lineto(49, 49);
    $$.lineto(49, 65);
    $$.lineto(34, 65);
    $$.lineto(34, 49);
    $$.lineto(18, 49);
    $$.lineto(18, 34);
    $$.lineto(34, 34);
    $$.lineto(34, 18);
    $$.closepath();
    $$.setrgbcolor(0, 0, 0);
    $$.fill();
    $$.restore();
  }
  $_ = $__;
}
function bwipp_microqrcode() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $put($_.options, "dontdraw", true);
  $put($_.options, "format", "micro");
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_qrcode();
  var _6 = $k[--$j];
  $_[$k[--$j]] = _6;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_rectangularmicroqrcode() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $put($_.options, "dontdraw", true);
  $put($_.options, "format", "rmqr");
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_qrcode();
  var _6 = $k[--$j];
  $_[$k[--$j]] = _6;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_maxicode() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.mode = -1;
  $_.sam = -1;
  $_.parse = false;
  $_.parsefnc = false;
  $_.legacyencoder = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length == 0) {
    $k[$j++] = "bwipp.maxicodeEmptyData#22566";
    $k[$j++] = "The data must not be empty";
    bwipp_raiseerror();
  }
  if ($_.mode != -1 && ($_.mode < 2 || $_.mode > 6)) {
    $k[$j++] = "bwipp.maxicodeBadMode#22570";
    $k[$j++] = "Mode must be 2 to 6";
    bwipp_raiseerror();
  }
  if ($_.sam != -1) {
    $k[$j++] = true;
    for (var _7 = 0; _7 < 1; _7++) {
      var _8 = $_.sam;
      if (_8 < 12 || _8 > 88) {
        $k[$j - 1] = false;
        break;
      }
      var _A = $_.sam % 10;
      if (_A < 2 || _A > 8) {
        $k[$j - 1] = false;
        break;
      }
      if (~~($_.sam / 10) > $_.sam % 10) {
        $k[$j - 1] = false;
        break;
      }
    }
    if (!$k[--$j]) {
      $k[$j++] = "bwipp.maxicodeBadSAM#22581";
      $k[$j++] = 'SAM must be formatted as "NM" for Nth of M symbols, from 2 to 8 symbols';
      bwipp_raiseerror();
    }
  }
  $_.encoding = "new";
  if ($_.legacyencoder) {
    $_.encoding = "legacy";
  }
  var _H = /* @__PURE__ */ new Map([
    ["parse", $_.parse],
    ["parsefnc", $_.parsefnc],
    ["eci", true]
  ]);
  $_.fncvals = _H;
  $k[$j++] = "msg";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.fncvals;
  bwipp_parseinput();
  var _K = $k[--$j];
  $_[$k[--$j]] = _K;
  $_.msglen = $_.msg.length;
  if ($_.mode == 2 || $_.mode == 3) {
    $_.barcode = $s($_.msglen);
    $_.barlen = $_.msglen;
    for (var _U = 0, _T = $_.msglen - 1; _U <= _T; _U += 1) {
      $_.i = _U;
      if ($get($_.msg, $_.i) < 0) {
        $_.barlen = $_.i;
        break;
      }
      $put($_.barcode, $_.i, $get($_.msg, $_.i));
    }
    $_.difflen = $_.msglen - $_.barlen;
    $_.fid = "";
    if ($_.barlen >= 9) {
      var _h = $_.barcode;
      var _j = $get(_h, 7);
      var _k = $get(_h, 8);
      if ($eq($geti(_h, 0, 7), "[)>01") && (_j >= 48 && _j <= 57 && (_k >= 48 && _k <= 57))) {
        $_.fid = $geti($_.barcode, 0, 9);
        $_.barcode = $geti($_.barcode, 9, $_.barlen - 9);
      }
    }
    $search($_.barcode, "");
    if ($k[--$j]) {
      $_.pcode = $k[--$j];
      $j--;
      if ($_.mode == 2) {
        $k[$j++] = true;
        for (var _u = 0; _u < 1; _u++) {
          var _w = $_.pcode.length;
          if (_w > 9 || _w == 0) {
            $k[$j - 1] = false;
            break;
          }
          $forall($_.pcode, function() {
            var _y = $k[--$j];
            if (_y < 48 || _y > 57) {
              $k[$j - 1] = false;
              return true;
            }
          });
        }
        if (!$k[--$j]) {
          $j--;
          $k[$j++] = "bwipp.maxicodeBadMode2PostCode#22635";
          $k[$j++] = "A mode 2 postcode must not be empty or exceed 9 digits";
          bwipp_raiseerror();
        }
      } else {
        $k[$j++] = true;
        for (var _10 = 0; _10 < 1; _10++) {
          var _12 = $_.pcode.length;
          if (_12 > 6 || _12 == 0) {
            $k[$j - 1] = false;
            break;
          }
          $forall($_.pcode, function() {
            var _14 = $k[--$j];
            if (!(_14 == 32 || (_14 >= 34 && _14 <= 58 || _14 >= 65 && _14 <= 90))) {
              $k[$j - 1] = false;
              return true;
            }
          });
        }
        if (!$k[--$j]) {
          $j--;
          $k[$j++] = "bwipp.maxicodeBadMode3PostCode#22649";
          $k[$j++] = "A mode 3 postcode must not be empty or exceed 6 characters";
          bwipp_raiseerror();
        }
      }
    } else {
      $j--;
      $k[$j++] = "bwipp.maxicodeExpectedPostCode#22653";
      $k[$j++] = "Expected postcode followed by group separator character";
      bwipp_raiseerror();
    }
    $search($k[--$j], "");
    if ($k[--$j]) {
      $_.ccode = $k[--$j];
      $k[$j - 1] = true;
      for (var _19 = 0; _19 < 1; _19++) {
        if ($_.ccode.length != 3) {
          $k[$j - 1] = false;
          break;
        }
        $forall($_.ccode, function() {
          var _1C = $k[--$j];
          if (_1C < 48 || _1C > 57) {
            $k[$j - 1] = false;
            return true;
          }
        });
      }
      if (!$k[--$j]) {
        $j--;
        $k[$j++] = "bwipp.maxicodeBadCountryCode#22663";
        $k[$j++] = "Country code must be three digits";
        bwipp_raiseerror();
      }
    } else {
      $j--;
      $k[$j++] = "bwipp.maxicodeExpectedCountryCode#22666";
      $k[$j++] = "Expected country code followed by group separator character";
      bwipp_raiseerror();
    }
    $search($k[--$j], "");
    if ($k[--$j]) {
      $_.scode = $k[--$j];
      $k[$j - 1] = true;
      for (var _1H = 0; _1H < 1; _1H++) {
        if ($_.scode.length != 3) {
          $k[$j - 1] = false;
          break;
        }
        $forall($_.scode, function() {
          var _1K = $k[--$j];
          if (_1K < 48 || _1K > 57) {
            $k[$j - 1] = false;
            return true;
          }
        });
      }
      if (!$k[--$j]) {
        $j--;
        $k[$j++] = "bwipp.maxicodeBadServiceClass#22676";
        $k[$j++] = "Service class must be three digits";
        bwipp_raiseerror();
      }
    } else {
      $j--;
      $k[$j++] = "bwipp.maxicodeExpectedServiceClass#22679";
      $k[$j++] = "Expected service class followed by group separator character";
      bwipp_raiseerror();
    }
    $_.barcode = $k[--$j];
    var _1P = $s($_.barcode.length + $_.fid.length);
    $puti(_1P, 0, $_.fid);
    $puti(_1P, $_.fid.length, $_.barcode);
    $_.barcode = _1P;
    $_.barlen = $_.barcode.length;
    $k[$j++] = Infinity;
    var _1U = $_.barcode;
    for (var _1V = 0, _1W = _1U.length; _1V < _1W; _1V++) {
      $k[$j++] = $get(_1U, _1V);
    }
    $aload($geti($_.msg, $_.msglen - $_.difflen, $_.difflen));
    $_.msg = $a();
    $_.msglen = $_.msg.length;
  }
  $_.eci = -1;
  $_.pad = -2;
  $_.ns = -3;
  $_.la = -4;
  $_.lb = -5;
  $_.sa = -6;
  $_.sb = -7;
  $_.sc = -8;
  $_.sd = -9;
  $_.se = -10;
  $_.sa2 = -11;
  $_.sa3 = -12;
  $_.lkc = -13;
  $_.lkd = -14;
  $_.lke = -15;
  $_.pd2 = -16;
  $_.pd3 = -17;
  $_.charmaps = $a([$a([13, "`", 192, 224, 0]), $a(["A", "a", 193, 225, 1]), $a(["B", "b", 194, 226, 2]), $a(["C", "c", 195, 227, 3]), $a(["D", "d", 196, 228, 4]), $a(["E", "e", 197, 229, 5]), $a(["F", "f", 198, 230, 6]), $a(["G", "g", 199, 231, 7]), $a(["H", "h", 200, 232, 8]), $a(["I", "i", 201, 233, 9]), $a(["J", "j", 202, 234, 10]), $a(["K", "k", 203, 235, 11]), $a(["L", "l", 204, 236, 12]), $a(["M", "m", 205, 237, 13]), $a(["N", "n", 206, 238, 14]), $a(["O", "o", 207, 239, 15]), $a(["P", "p", 208, 240, 16]), $a(["Q", "q", 209, 241, 17]), $a(["R", "r", 210, 242, 18]), $a(["S", "s", 211, 243, 19]), $a(["T", "t", 212, 244, 20]), $a(["U", "u", 213, 245, 21]), $a(["V", "v", 214, 246, 22]), $a(["W", "w", 215, 247, 23]), $a(["X", "x", 216, 248, 24]), $a(["Y", "y", 217, 249, 25]), $a(["Z", "z", 218, 250, 26]), $a([$_.eci, $_.eci, $_.eci, $_.eci, $_.eci]), $a([28, 28, 28, 28, $_.pad]), $a([29, 29, 29, 29, $_.pd2]), $a([30, 30, 30, 30, 27]), $a([$_.ns, $_.ns, $_.ns, $_.ns, $_.ns]), $a([" ", "{", 219, 251, 28]), $a([$_.pad, $_.pad, 220, 252, 29]), $a(['"', "}", 221, 253, 30]), $a(["#", "~", 222, 254, 31]), $a(["$", 127, 223, 255, 159]), $a(["%", ";", 170, 161, 160]), $a(["&", "<", 172, 168, 162]), $a(["'", "=", 177, 171, 163]), $a([40, ">", 178, 175, 164]), $a([41, "?", 179, 176, 165]), $a(["*", "[", 181, 180, 166]), $a(["+", 92, 185, 183, 167]), $a([",", "]", 186, 184, 169]), $a(["-", "^", 188, 187, 173]), $a([".", "_", 189, 191, 174]), $a(["/", " ", 190, 138, 182]), $a(["0", ",", 128, 139, 149]), $a(["1", ".", 129, 140, 150]), $a(["2", "/", 130, 141, 151]), $a(["3", ":", 131, 142, 152]), $a(["4", "@", 132, 143, 153]), $a(["5", "!", 133, 144, 154]), $a(["6", "|", 134, 145, 155]), $a(["7", $_.pd2, 135, 146, 156]), $a(["8", $_.sa2, 136, 147, 157]), $a(["9", $_.sa3, 137, 148, 158]), $a([":", $_.pd3, $_.la, $_.la, $_.la]), $a([$_.sb, $_.sa, " ", " ", " "]), $a([$_.sc, $_.sc, $_.lkc, $_.sc, $_.sc]), $a([$_.sd, $_.sd, $_.sd, $_.lkd, $_.sd]), $a([$_.se, $_.se, $_.se, $_.se, $_.lke]), $a([$_.lb, $_.la, $_.lb, $_.lb, $_.lb])]);
  $_.charvals = $a([/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map()]);
  for (var _3S = 0, _3R = $_.charmaps.length - 1; _3S <= _3R; _3S += 1) {
    $_.i = _3S;
    $_.encs = $get($_.charmaps, $_.i);
    for (var _3W = 0; _3W <= 4; _3W += 1) {
      $_.j = _3W;
      var _3Z = $get($_.encs, $_.j);
      $k[$j++] = _3Z;
      if ($eq($type(_3Z), "stringtype")) {
        var _3c = $get($k[--$j], 0);
        $k[$j++] = _3c;
      }
      $put($get($_.charvals, $_.j), $k[--$j], $_.i);
    }
  }
  $_.seta = $get($_.charvals, 0);
  $_.setb = $get($_.charvals, 1);
  $_.setc = $get($_.charvals, 2);
  $_.setd = $get($_.charvals, 3);
  $_.sete = $get($_.charvals, 4);
  $k[$j++] = "maxlen";
  if ($_.mode == 5) {
    $k[$j++] = 77;
  } else {
    var _3v = $_.mode <= 3 ? 84 : 93;
    $k[$j++] = _3v;
  }
  var _3w = $k[--$j];
  $_[$k[--$j]] = _3w;
  if ($eq($_.encoding, "legacy")) {
    $k[$j++] = Infinity;
    for (var _40 = 0, _41 = $_.msglen + 1; _40 < _41; _40++) {
      $k[$j++] = 0;
    }
    $_.nseq = $a();
    for (var _44 = $_.msglen - 1; _44 >= 0; _44 -= 1) {
      $_.i = _44;
      var _47 = $get($_.msg, $_.i);
      if (_47 >= 48 && _47 <= 57) {
        $put($_.nseq, $_.i, $get($_.nseq, $_.i + 1) + 1);
      } else {
        $put($_.nseq, $_.i, 0);
      }
    }
    $_.nseq = $geti($_.nseq, 0, $_.msglen);
    $_.prefixinset = function() {
      $k[$j++] = 0;
      for (; ; ) {
        var _4I = $k[$j - 1];
        var _4J = $k[$j - 2];
        if (_4I >= _4J.length) {
          break;
        }
        var _4K = $k[$j - 1];
        var _4L = $k[$j - 2];
        var _4N = $k[$j - 3];
        var _4O = $get(_4N, $get(_4L, _4K)) !== void 0;
        if (_4O) {
          var _4P = $k[--$j];
          $k[$j++] = _4P + 1;
        } else {
          break;
        }
      }
      var _4Q = $k[--$j];
      $k[$j - 1] = _4Q;
      var _4S = $k[--$j];
      $k[$j - 1] = _4S;
    };
    $_.enc = function() {
      var _4U = $k[--$j];
      $put($_.out, $_.j, $get(_4U, $k[--$j]));
      $_.j = $_.j + 1;
    };
    $_.out = $a(144);
    $_.i = 0;
    $_.j = 0;
    $_.cset = "seta";
    for (; ; ) {
      if ($_.i == $_.msglen) {
        if ($ne($_.cset, "seta") && $ne($_.cset, "setb") && $_.out.length < $_.maxlen) {
          $k[$j++] = $_.la;
          $k[$j++] = $_[$_.cset];
          $_.enc();
          $_.cset = "seta";
        }
        break;
      }
      for (; ; ) {
        if ($get($_.msg, $_.i) <= -1e6) {
          $k[$j++] = $_.eci;
          $k[$j++] = $_[$_.cset];
          $_.enc();
          var _4t = -$get($_.msg, $_.i) - 1e6;
          $k[$j++] = _4t;
          if (_4t <= 31) {
            var _4u = $k[--$j];
            $k[$j++] = _4u & 63;
            $astore($a(1));
          } else {
            var _4w = $k[$j - 1];
            if (_4w <= 1023) {
              var _4x = $k[--$j];
              $k[$j++] = _4x >>> 6 & 31 | 32;
              $k[$j++] = _4x & 63;
              $astore($a(2));
            } else {
              var _4z = $k[$j - 1];
              if (_4z <= 32767) {
                var _50 = $k[--$j];
                $k[$j++] = _50 >>> 12 & 47 | 48;
                $k[$j++] = _50 >>> 6 & 63;
                $k[$j++] = _50 & 63;
                $astore($a(3));
              } else {
                var _52 = $k[--$j];
                $k[$j++] = _52 >>> 18 & 55 | 56;
                $k[$j++] = _52 >>> 12 & 63;
                $k[$j++] = _52 >>> 6 & 63;
                $k[$j++] = _52 & 63;
                $astore($a(4));
              }
            }
          }
          var _54 = $k[--$j];
          $puti($_.out, $_.j, _54);
          $_.j = _54.length + $_.j;
          $_.i = $_.i + 1;
          break;
        }
        if ($get($_.nseq, $_.i) >= 9) {
          var _5E = $geti($_.msg, $_.i, 9);
          $k[$j++] = 0;
          for (var _5F = 0, _5G = _5E.length; _5F < _5G; _5F++) {
            var _5I = $k[--$j];
            $k[$j++] = $f(_5I + ($get(_5E, _5F) - 48)) * 10;
          }
          var _5J = $k[--$j];
          $k[$j++] = ~~(_5J / 10);
          for (var _5K = 0; _5K < 4; _5K++) {
            var _5L = $k[--$j];
            $k[$j++] = _5L & 63;
            $k[$j++] = _5L >>> 6;
          }
          $k[$j++] = $get($_[$_.cset], $_.ns);
          for (var _5Q = 0; _5Q <= 10; _5Q += 2) {
            var _5R = $k[$j - 1 - _5Q];
            $k[$j++] = _5R;
          }
          $astore($a(6));
          $r(7, 1);
          for (var _5T = 0; _5T < 6; _5T++) {
            $j--;
          }
          $puti($_.out, $_.j, $k[--$j]);
          $_.i = $_.i + 9;
          $_.j = $_.j + 6;
          break;
        }
        $_.char1 = $get($_.msg, $_.i);
        $k[$j++] = "char2";
        if ($_.i + 1 < $_.msglen) {
          $k[$j++] = $get($_.msg, $_.i + 1);
        } else {
          $k[$j++] = -99;
        }
        var _5h = $k[--$j];
        $_[$k[--$j]] = _5h;
        $k[$j++] = "char3";
        if ($_.i + 2 < $_.msglen) {
          $k[$j++] = $get($_.msg, $_.i + 2);
        } else {
          $k[$j++] = -99;
        }
        var _5o = $k[--$j];
        $_[$k[--$j]] = _5o;
        var _5t = $get($_[$_.cset], $_.char1) !== void 0;
        if (_5t) {
          $k[$j++] = $_.char1;
          $k[$j++] = $_[$_.cset];
          $_.enc();
          $_.i = $_.i + 1;
          break;
        }
        var _61 = $get($_.setb, $_.char1) !== void 0;
        if ($eq($_.cset, "seta") && _61) {
          var _64 = $get($_.setb, $_.char2) !== void 0;
          if (_64) {
            $k[$j++] = $_.lb;
            $k[$j++] = $_.seta;
            $_.enc();
            $_.cset = "setb";
          } else {
            $k[$j++] = $_.sb;
            $k[$j++] = $_.seta;
            $_.enc();
            $k[$j++] = $_.char1;
            $k[$j++] = $_.setb;
            $_.enc();
            $_.i = $_.i + 1;
          }
          break;
        }
        var _6F = $get($_.seta, $_.char1) !== void 0;
        if ($eq($_.cset, "setb") && _6F) {
          var _6G = $_.seta;
          var _6H = $_.msg;
          var _6I = $_.i;
          var _6J = $_.msglen;
          var _6K = $_.i;
          var _6L = _6J - _6K;
          var _6M = 4;
          if (4 > _6J - _6K) {
            var _ = _6L;
            _6L = _6M;
            _6M = _;
          }
          $k[$j++] = "p";
          $k[$j++] = _6G;
          $k[$j++] = $geti(_6H, _6I, _6M);
          $_.prefixinset();
          var _6O = $k[--$j];
          $_[$k[--$j]] = _6O;
          if ($_.p == 1) {
            $k[$j++] = $_.sa;
            $k[$j++] = $_.setb;
            $_.enc();
            $k[$j++] = $_.char1;
            $k[$j++] = $_.seta;
            $_.enc();
            $_.i = $_.i + 1;
          }
          if ($_.p == 2) {
            $k[$j++] = $_.sa2;
            $k[$j++] = $_.setb;
            $_.enc();
            $k[$j++] = $_.char1;
            $k[$j++] = $_.seta;
            $_.enc();
            $k[$j++] = $_.char2;
            $k[$j++] = $_.seta;
            $_.enc();
            $_.i = $_.i + 2;
          }
          if ($_.p == 3) {
            $k[$j++] = $_.sa3;
            $k[$j++] = $_.setb;
            $_.enc();
            $k[$j++] = $_.char1;
            $k[$j++] = $_.seta;
            $_.enc();
            $k[$j++] = $_.char2;
            $k[$j++] = $_.seta;
            $_.enc();
            $k[$j++] = $_.char3;
            $k[$j++] = $_.seta;
            $_.enc();
            $_.i = $_.i + 3;
          }
          if ($_.p >= 4) {
            $k[$j++] = $_.la;
            $k[$j++] = $_.setb;
            $_.enc();
            $_.cset = "seta";
          }
          break;
        }
        var _6t = $get($_.seta, $_.char1) !== void 0;
        if (_6t) {
          $k[$j++] = $_.la;
          $k[$j++] = $_[$_.cset];
          $_.enc();
          $_.cset = "seta";
          break;
        }
        var _6z = $get($_.setb, $_.char1) !== void 0;
        if (_6z) {
          $k[$j++] = $_.lb;
          $k[$j++] = $_[$_.cset];
          $_.enc();
          $_.cset = "setb";
          break;
        }
        var _75 = $get($_.setc, $_.char1) !== void 0;
        if (_75) {
          $_.setx = "setc";
          $_.sx = $_.sc;
          $_.lkx = $_.lkc;
        }
        var _7A = $get($_.setd, $_.char1) !== void 0;
        if (_7A) {
          $_.setx = "setd";
          $_.sx = $_.sd;
          $_.lkx = $_.lkd;
        }
        var _7F = $get($_.sete, $_.char1) !== void 0;
        if (_7F) {
          $_.setx = "sete";
          $_.sx = $_.se;
          $_.lkx = $_.lke;
        }
        var _7J = $_[$_.setx];
        var _7K = $_.msg;
        var _7L = $_.i;
        var _7M = $_.msglen;
        var _7N = $_.i;
        var _7O = _7M - _7N;
        var _7P = 4;
        if (4 > _7M - _7N) {
          var _ = _7O;
          _7O = _7P;
          _7P = _;
        }
        $k[$j++] = "p";
        $k[$j++] = _7J;
        $k[$j++] = $geti(_7K, _7L, _7P);
        $_.prefixinset();
        var _7R = $k[--$j];
        $_[$k[--$j]] = _7R;
        if ($_.p == 1) {
          $k[$j++] = $_.sx;
          $k[$j++] = $_[$_.cset];
          $_.enc();
          $k[$j++] = $_.char1;
          $k[$j++] = $_[$_.setx];
          $_.enc();
          $_.i = $_.i + 1;
        }
        if ($_.p == 2) {
          $k[$j++] = $_.sx;
          $k[$j++] = $_[$_.cset];
          $_.enc();
          $k[$j++] = $_.char1;
          $k[$j++] = $_[$_.setx];
          $_.enc();
          $k[$j++] = $_.sx;
          $k[$j++] = $_[$_.cset];
          $_.enc();
          $k[$j++] = $_.char2;
          $k[$j++] = $_[$_.setx];
          $_.enc();
          $_.i = $_.i + 2;
        }
        if ($_.p == 3) {
          $k[$j++] = $_.sx;
          $k[$j++] = $_[$_.cset];
          $_.enc();
          $k[$j++] = $_.char1;
          $k[$j++] = $_[$_.setx];
          $_.enc();
          $k[$j++] = $_.sx;
          $k[$j++] = $_[$_.cset];
          $_.enc();
          $k[$j++] = $_.char2;
          $k[$j++] = $_[$_.setx];
          $_.enc();
          $k[$j++] = $_.sx;
          $k[$j++] = $_[$_.cset];
          $_.enc();
          $k[$j++] = $_.char3;
          $k[$j++] = $_[$_.setx];
          $_.enc();
          $_.i = $_.i + 3;
        }
        if ($_.p >= 4) {
          $k[$j++] = $_.sx;
          $k[$j++] = $_[$_.cset];
          $_.enc();
          $k[$j++] = $_.lkx;
          $k[$j++] = $_[$_.setx];
          $_.enc();
          $_.cset = $_.setx;
        }
        break;
      }
    }
    $_.encmsg = $geti($_.out, 0, $_.j);
    $_.padval = $get($_[$_.cset], $_.pad);
  }
  if ($eq($_.encoding, "new")) {
    $_.haveb = false;
    $_.havec = false;
    $_.haved = false;
    $_.havee = false;
    $_.havei = false;
    for (var _8R = 0, _8Q = $_.msglen - 1; _8R <= _8Q; _8R += 1) {
      $_.c = $get($_.msg, _8R);
      if ($_.c <= -1e6) {
        $_.havei = true;
      } else {
        if (($_.c < 28 || $_.c > 30) && $_.c != 32) {
          var _8a = $get($_.setb, $_.c) !== void 0;
          if (_8a) {
            $_.haveb = true;
          }
          var _8d = $get($_.setc, $_.c) !== void 0;
          if (_8d) {
            $_.havec = true;
          }
          var _8g = $get($_.setd, $_.c) !== void 0;
          if (_8g) {
            $_.haved = true;
          }
          var _8j = $get($_.sete, $_.c) !== void 0;
          if (_8j) {
            $_.havee = true;
          }
        }
      }
    }
    $k[$j++] = Infinity;
    $k[$j++] = 0;
    if ($_.haveb) {
      $k[$j++] = 1;
    }
    if ($_.havee) {
      $k[$j++] = 4;
    }
    if ($_.havec) {
      $k[$j++] = 2;
    }
    if ($_.haved) {
      $k[$j++] = 3;
    }
    $_.priority = $a();
    $_.priority_rest = $geti($_.priority, 1, $_.priority.length - 1);
    $_.latch_sequence = $a([$a([$a([]), $a([63]), $a([58]), $a([58]), $a([58])]), $a([$a([63]), $a([]), $a([63]), $a([63]), $a([63])]), $a([$a([60, 60]), $a([60, 60]), $a([]), $a([60, 60]), $a([60, 60])]), $a([$a([61, 61]), $a([61, 61]), $a([61, 61]), $a([]), $a([61, 61])]), $a([$a([62, 62]), $a([62, 62]), $a([62, 62]), $a([62, 62]), $a([])])]);
    $_.latch_length = $a([$a([0, 1, 1, 1, 1]), $a([1, 0, 1, 1, 1]), $a([2, 2, 0, 2, 2]), $a([2, 2, 2, 0, 2]), $a([2, 2, 2, 2, 0])]);
    $_.max_int = 2147483647;
    $k[$j++] = Infinity;
    for (var _9T = 0; _9T < 16; _9T++) {
      $k[$j++] = $a([0, 0, 0, 0, 0]);
    }
    $_.best_length = $a();
    $k[$j++] = Infinity;
    for (var _9W = 0; _9W < 16; _9W++) {
      $k[$j++] = $a([0, 0, 0, 0, 0]);
    }
    $_.best_origin = $a();
    $k[$j++] = Infinity;
    for (var _9a = 0, _9b = $_.msglen; _9a < _9b; _9a++) {
      $k[$j++] = Infinity;
      for (var _9c = 0; _9c < 5; _9c++) {
        $k[$j++] = 0;
      }
      var _9d = $a();
      $k[$j++] = _9d;
    }
    $_.prior_code_set = $a();
    $k[$j++] = Infinity;
    for (var _9g = 0, _9h = $_.msglen; _9g < _9h; _9g++) {
      $k[$j++] = Infinity;
      for (var _9i = 0; _9i < 5; _9i++) {
        $k[$j++] = 0;
      }
      var _9j = $a();
      $k[$j++] = _9j;
    }
    $_.path_op = $a();
    $_.out_eci = function() {
      var _9m = -$_.c - 1e6;
      $k[$j++] = _9m;
      if (_9m < 1024) {
        var _9o = $k[--$j] < 32 ? 2 : 3;
        $k[$j++] = _9o;
      } else {
        var _9q = $k[--$j] < 32768 ? 4 : 5;
        $k[$j++] = _9q;
      }
    };
    $_.enc_eci = function() {
      var _9s = -$_.c - 1e6;
      $k[$j++] = _9s;
      if (_9s >= 32) {
        var _9t = $k[$j - 1];
        if (_9t < 1024) {
          var _9u = $k[--$j];
          $k[$j++] = _9u >>> 6 | 32;
          $k[$j++] = _9u & 63;
        } else {
          var _9v = $k[$j - 1];
          if (_9v < 32768) {
            var _9w = $k[--$j];
            $k[$j++] = _9w >>> 12 | 48;
            $k[$j++] = _9w >>> 6 & 63;
            $k[$j++] = _9w & 63;
          } else {
            var _9x = $k[--$j];
            $k[$j++] = _9x >>> 18 | 56;
            $k[$j++] = _9x >>> 12 & 63;
            $k[$j++] = _9x >>> 6 & 63;
            $k[$j++] = _9x & 63;
          }
        }
      }
    };
    $_.enc_ns = function() {
      var _A0 = $geti($_.msg, $_.n, 9);
      $k[$j++] = 0;
      for (var _A1 = 0, _A2 = _A0.length; _A1 < _A2; _A1++) {
        var _A4 = $k[--$j];
        $k[$j++] = $f($get(_A0, _A1) - 48 + _A4 * 10);
      }
      var _A5 = $k[--$j];
      $k[$j++] = _A5 >>> 24;
      $k[$j++] = _A5 >>> 18 & 63;
      $k[$j++] = _A5 >>> 12 & 63;
      $k[$j++] = _A5 >>> 6 & 63;
      $k[$j++] = _A5 & 63;
    };
    $_.enc_sha2 = function() {
      $k[$j++] = $get($_.seta, $_.c);
      $k[$j++] = $get($_.seta, $get($_.msg, $_.n + 1));
    };
    $_.enc_sha3 = function() {
      $k[$j++] = $get($_.seta, $_.c);
      $k[$j++] = $get($_.seta, $get($_.msg, $_.n + 1));
      $k[$j++] = $get($_.seta, $get($_.msg, $_.n + 2));
    };
    $k[$j++] = Infinity;
    if ($_.havei) {
      var _AT = /* @__PURE__ */ new Map([
        ["can", function() {
          $k[$j++] = $_.c <= -1e6;
        }],
        ["intake", 1],
        ["output", function() {
          $_.out_eci();
        }],
        ["sets", 31],
        ["enc", function() {
          $k[$j++] = 27;
          $_.enc_eci();
        }]
      ]);
      $k[$j++] = _AT;
    }
    var _AV = /* @__PURE__ */ new Map([
      ["can", function() {
        $k[$j++] = $_.digits >= 9;
      }],
      ["intake", 9],
      ["output", function() {
        $k[$j++] = 6;
      }],
      ["sets", 31],
      ["enc", function() {
        $k[$j++] = 31;
        $_.enc_ns();
      }]
    ]);
    var _Ac = /* @__PURE__ */ new Map([
      ["can", function() {
        var _AY = $get($_.seta, $_.c) !== void 0;
        $k[$j++] = _AY;
      }],
      ["intake", 1],
      ["output", function() {
        $k[$j++] = 1;
      }],
      ["sets", 1],
      ["enc", function() {
        $k[$j++] = $get($_.seta, $_.c);
      }]
    ]);
    $k[$j++] = _AV;
    $k[$j++] = _Ac;
    if ($_.haveb) {
      var _Ak = /* @__PURE__ */ new Map([
        ["can", function() {
          var _Ag = $get($_.setb, $_.c) !== void 0;
          $k[$j++] = _Ag;
        }],
        ["intake", 1],
        ["output", function() {
          $k[$j++] = 1;
        }],
        ["sets", 2],
        ["enc", function() {
          $k[$j++] = $get($_.setb, $_.c);
        }]
      ]);
      $k[$j++] = _Ak;
    }
    if ($_.havec) {
      var _As = /* @__PURE__ */ new Map([
        ["can", function() {
          var _Ao = $get($_.setc, $_.c) !== void 0;
          $k[$j++] = _Ao;
        }],
        ["intake", 1],
        ["output", function() {
          $k[$j++] = 1;
        }],
        ["sets", 4],
        ["enc", function() {
          $k[$j++] = $get($_.setc, $_.c);
        }]
      ]);
      $k[$j++] = _As;
    }
    if ($_.haved) {
      var _B0 = /* @__PURE__ */ new Map([
        ["can", function() {
          var _Aw = $get($_.setd, $_.c) !== void 0;
          $k[$j++] = _Aw;
        }],
        ["intake", 1],
        ["output", function() {
          $k[$j++] = 1;
        }],
        ["sets", 8],
        ["enc", function() {
          $k[$j++] = $get($_.setd, $_.c);
        }]
      ]);
      $k[$j++] = _B0;
    }
    if ($_.havee) {
      var _B8 = /* @__PURE__ */ new Map([
        ["can", function() {
          var _B4 = $get($_.sete, $_.c) !== void 0;
          $k[$j++] = _B4;
        }],
        ["intake", 1],
        ["output", function() {
          $k[$j++] = 1;
        }],
        ["sets", 16],
        ["enc", function() {
          $k[$j++] = $get($_.sete, $_.c);
        }]
      ]);
      $k[$j++] = _B8;
    }
    var _BD = /* @__PURE__ */ new Map([
      ["can", function() {
        $k[$j++] = $_.num_a >= 1;
      }],
      ["intake", 1],
      ["output", function() {
        $k[$j++] = 2;
      }],
      ["sets", 2],
      ["enc", function() {
        $k[$j++] = 59;
        $k[$j++] = $get($_.seta, $_.c);
      }]
    ]);
    var _BF = /* @__PURE__ */ new Map([
      ["can", function() {
        $k[$j++] = $_.num_a >= 2;
      }],
      ["intake", 2],
      ["output", function() {
        $k[$j++] = 3;
      }],
      ["sets", 2],
      ["enc", function() {
        $k[$j++] = 56;
        $_.enc_sha2();
      }]
    ]);
    var _BH = /* @__PURE__ */ new Map([
      ["can", function() {
        $k[$j++] = $_.num_a >= 3;
      }],
      ["intake", 3],
      ["output", function() {
        $k[$j++] = 4;
      }],
      ["sets", 2],
      ["enc", function() {
        $k[$j++] = 57;
        $_.enc_sha3();
      }]
    ]);
    $k[$j++] = _BD;
    $k[$j++] = _BF;
    $k[$j++] = _BH;
    if ($_.haveb) {
      var _BP = /* @__PURE__ */ new Map([
        ["can", function() {
          var _BL = $get($_.setb, $_.c) !== void 0;
          $k[$j++] = _BL;
        }],
        ["intake", 1],
        ["output", function() {
          $k[$j++] = 2;
        }],
        ["sets", 1],
        ["enc", function() {
          $k[$j++] = 59;
          $k[$j++] = $get($_.setb, $_.c);
        }]
      ]);
      $k[$j++] = _BP;
    }
    if ($_.havec) {
      var _BX = /* @__PURE__ */ new Map([
        ["can", function() {
          var _BT = $get($_.setc, $_.c) !== void 0;
          $k[$j++] = _BT;
        }],
        ["intake", 1],
        ["output", function() {
          $k[$j++] = 2;
        }],
        ["sets", 27],
        ["enc", function() {
          $k[$j++] = 60;
          $k[$j++] = $get($_.setc, $_.c);
        }]
      ]);
      $k[$j++] = _BX;
    }
    if ($_.haved) {
      var _Bf = /* @__PURE__ */ new Map([
        ["can", function() {
          var _Bb = $get($_.setd, $_.c) !== void 0;
          $k[$j++] = _Bb;
        }],
        ["intake", 1],
        ["output", function() {
          $k[$j++] = 2;
        }],
        ["sets", 23],
        ["enc", function() {
          $k[$j++] = 61;
          $k[$j++] = $get($_.setd, $_.c);
        }]
      ]);
      $k[$j++] = _Bf;
    }
    if ($_.havee) {
      var _Bn = /* @__PURE__ */ new Map([
        ["can", function() {
          var _Bj = $get($_.sete, $_.c) !== void 0;
          $k[$j++] = _Bj;
        }],
        ["intake", 1],
        ["output", function() {
          $k[$j++] = 2;
        }],
        ["sets", 15],
        ["enc", function() {
          $k[$j++] = 62;
          $k[$j++] = $get($_.sete, $_.c);
        }]
      ]);
      $k[$j++] = _Bn;
    }
    $_.op_tab = $a();
    var _Bp = $_.op_tab;
    $k[$j++] = 0;
    for (var _Bq = 0, _Br = _Bp.length; _Bq < _Br; _Bq++) {
      var _Bt = $k[--$j];
      $put($get(_Bp, _Bq), "idx", _Bt);
      $k[$j++] = _Bt + 1;
    }
    $k[$j - 1] = Infinity;
    var _Bu = $a([1, 2, 4, 8, 16]);
    for (var _Bv = 0, _Bw = _Bu.length; _Bv < _Bw; _Bv++) {
      $_.n = $get(_Bu, _Bv);
      $k[$j++] = Infinity;
      var _By = $_.op_tab;
      for (var _Bz = 0, _C0 = _By.length; _Bz < _C0; _Bz++) {
        var _C1 = $get(_By, _Bz);
        $k[$j++] = _C1;
        if ($an($get(_C1, "sets"), $_.n) == 0) {
          $j--;
        }
      }
      var _C4 = $a();
      $k[$j++] = _C4;
    }
    $_.code_set_operations = $a();
    $_.get_best_length = function() {
      $_.latch_length_s = $get($_.latch_length, $_.state);
      $k[$j++] = $_.max_int;
      $forall($get($_.code_set_operations, $_.state), function() {
        $_.op = $k[--$j];
        if ($get($_.op, "can")() === true) {
          return true;
        }
        if ($k[--$j]) {
          $_.m = $f($_.n - $get($_.op, "intake")) & 15;
          $_.org = $get($get($_.best_origin, $_.m), $_.state);
          $k[$j++] = $f($get($get($_.best_length, $_.m), $_.org) + $get($_.latch_length_s, $_.org));
          if ($get($_.op, "output")() === true) {
            return true;
          }
          var _CZ = $k[--$j];
          var _Ca = $k[--$j];
          var _Cb = $k[$j - 1];
          $k[$j++] = $f(_Ca + _CZ);
          if (_Cb > $f(_Ca + _CZ)) {
            var _Cc = $k[--$j];
            var _Cd = $k[--$j];
            $put($_.path_op_0, $_.state, $get($_.op, "idx"));
            $put($_.prior_code_set_0, $_.state, $_.org);
            $k[$j++] = _Cc;
            $k[$j++] = _Cd;
          }
          $j--;
        }
      });
    };
    $_.get_best_origin = function() {
      $_.latch_length_s = $get($_.latch_length, $_.state);
      $_.orglen = $f($get($_.best_length_0, 0) + $get($_.latch_length_s, 0));
      var _Cs = $_.priority_rest;
      $k[$j++] = 0;
      for (var _Ct = 0, _Cu = _Cs.length; _Ct < _Cu; _Ct++) {
        $_.p = $get(_Cs, _Ct);
        var _D2 = $f($get($_.best_length_0, $_.p) + $get($_.latch_length_s, $_.p));
        $k[$j++] = _D2;
        if (_D2 < $_.orglen) {
          $_.orglen = $k[--$j];
          $k[$j - 1] = $_.p;
        } else {
          $j--;
        }
      }
    };
    $_.digits = 0;
    $_.num_a = 0;
    for (var _D8 = 0, _D7 = $_.msglen - 1; _D8 <= _D7; _D8 += 1) {
      $_.n = _D8;
      $_.c = $get($_.msg, $_.n);
      $k[$j++] = "digits";
      if ($_.c >= 48 && $_.c < 58) {
        $k[$j++] = $_.digits + 1;
      } else {
        $k[$j++] = 0;
      }
      var _DF = $k[--$j];
      $_[$k[--$j]] = _DF;
      var _DJ = $get($_.seta, $_.c) !== void 0;
      $k[$j++] = "num_a";
      if (_DJ) {
        $k[$j++] = $_.num_a + 1;
      } else {
        $k[$j++] = 0;
      }
      var _DL = $k[--$j];
      $_[$k[--$j]] = _DL;
      $_.path_op_0 = $get($_.path_op, $_.n);
      $_.prior_code_set_0 = $get($_.prior_code_set, $_.n);
      $_.best_length_0 = $get($_.best_length, $_.n & 15);
      $_.best_origin_0 = $get($_.best_origin, $_.n & 15);
      var _DZ = $_.priority;
      for (var _Da = 0, _Db = _DZ.length; _Da < _Db; _Da++) {
        $_.state = $get(_DZ, _Da);
        $k[$j++] = $_.best_length_0;
        $k[$j++] = $_.state;
        $_.get_best_length();
        var _Df = $k[--$j];
        var _Dg = $k[--$j];
        $put($k[--$j], _Dg, _Df);
      }
      var _Di = $_.priority;
      for (var _Dj = 0, _Dk = _Di.length; _Dj < _Dk; _Dj++) {
        $_.state = $get(_Di, _Dj);
        $k[$j++] = $_.best_origin_0;
        $k[$j++] = $_.state;
        $_.get_best_origin();
        var _Do = $k[--$j];
        var _Dp = $k[--$j];
        $put($k[--$j], _Dp, _Do);
      }
    }
    $_.n = $_.msglen;
    var _Dt = $_.priority;
    $k[$j++] = 0;
    $k[$j++] = $_.max_int;
    for (var _Du = 0, _Dv = _Dt.length; _Du < _Dv; _Du++) {
      var _Dw = $get(_Dt, _Du);
      var _Dy = $get($_.best_length_0, _Dw);
      var _Dz = $k[$j - 1];
      $k[$j++] = _Dw;
      $k[$j++] = _Dy;
      if ($lt(_Dy, _Dz)) {
        $r(4, 2);
      }
      $j -= 2;
    }
    $_.j = $k[--$j];
    $_.state = $k[--$j];
    $_.pad_code = $a([33, 33, 0, 0, 28]);
    $k[$j++] = "final_code_set";
    if ($get($_.pad_code, $_.state) == 0) {
      $k[$j++] = 0;
    } else {
      $k[$j++] = $_.state;
    }
    var _E7 = $k[--$j];
    $_[$k[--$j]] = _E7;
    if ($get($_.pad_code, $_.state) == 0 && $lt($_.j, $_.maxlen)) {
      var _EF = $a($_.j + 1);
      $put(_EF, $_.j, 58);
      $k[$j++] = _EF;
    } else {
      $k[$j++] = $a($_.j);
    }
    $_.padval = $get($_.pad_code, $_.final_code_set);
    $_.len = $_.j;
    for (; ; ) {
      if ($_.n <= 0) {
        break;
      }
      $_.pcs = $get($get($_.prior_code_set, $_.n - 1), $_.state);
      $_.op_idx = $get($get($_.path_op, $_.n - 1), $_.state);
      $_.op = $get($_.op_tab, $_.op_idx);
      $_.n = $f($_.n - $get($_.op, "intake"));
      $_.c = $get($_.msg, $_.n);
      $_.enc = $get($_.op, "enc");
      $k[$j++] = Infinity;
      if ($_.enc() === true) {
        break;
      }
      $_.output = $a();
      $_.latch = $get($get($_.latch_sequence, $_.state), $_.pcs);
      $_.len = $f($_.len - $_.latch.length - $_.output.length);
      var _Et = $k[--$j];
      var _Eu = $_.len;
      var _Ev = $_.latch;
      $puti(_Et, _Eu, _Ev);
      $puti(_Et, $f(_Eu + _Ev.length), $_.output);
      $_.state = $_.pcs;
      $k[$j++] = _Et;
    }
    $_.encmsg = $k[--$j];
  }
  $k[$j++] = "sami";
  if ($_.sam != -1) {
    $k[$j++] = $a([$get($_.seta, $_.pad), (~~($_.sam / 10) - 1) * 8 + ($_.sam % 10 - 1)]);
  } else {
    $k[$j++] = $a([]);
  }
  var _F7 = $k[--$j];
  $_[$k[--$j]] = _F7;
  $k[$j++] = Infinity;
  $aload($_.sami);
  $aload($_.encmsg);
  $_.encmsg = $a();
  if ($_.mode == 2 || $_.mode == 3) {
    if ($_.encmsg.length > 84) {
      $k[$j++] = "bwipp.maxicodeMode23TooLong#23176";
      $k[$j++] = "The secondary message is too long";
      bwipp_raiseerror();
    }
    var _FG = $strcpy($s(4), "0000");
    var _FJ = $cvrs($s(4), ~~$_.mode, 2);
    $puti(_FG, 4 - _FJ.length, _FJ);
    $_.mdb = _FG;
    var _FL = $strcpy($s(10), "0000000000");
    var _FO = $cvrs($s(10), $cvi($_.ccode), 2);
    $puti(_FL, 10 - _FO.length, _FO);
    $_.ccb = _FL;
    var _FQ = $strcpy($s(10), "0000000000");
    var _FT = $cvrs($s(10), $cvi($_.scode), 2);
    $puti(_FQ, 10 - _FT.length, _FT);
    $_.scb = _FQ;
    $_.pcb = $strcpy($s(36), "000000000000000000000000000000000000");
    if ($_.mode == 2) {
      if ($eq($_.ccode, "840") && $_.pcode.length == 5) {
        var _Fa = $strcpy($s(9), "     0000");
        $puti(_Fa, 0, $_.pcode);
        $_.pcode = _Fa;
      }
      var _Ff = $cvrs($s(6), $_.pcode.length, 2);
      $puti($_.pcb, 6 - _Ff.length, _Ff);
      var _Fj = $cvrs($s(30), $cvi($_.pcode), 2);
      $puti($_.pcb, 36 - _Fj.length, _Fj);
    } else {
      $k[$j++] = Infinity;
      var _Fl = $strcpy($s(6), "      ");
      $k[$j++] = _Fl;
      $k[$j++] = _Fl;
      $k[$j++] = 0;
      if ($_.pcode.length > 6) {
        $k[$j++] = $geti($_.pcode, 0, 6);
      } else {
        $k[$j++] = $_.pcode;
      }
      var _Fq = $k[--$j];
      var _Fr = $k[--$j];
      $puti($k[--$j], _Fr, _Fq);
      $forall($k[--$j], function() {
        var _Fw = $get($_.seta, $k[--$j]);
        $k[$j++] = _Fw;
      });
      $_.pccw = $a();
      for (var _Fy = 0; _Fy <= 5; _Fy += 1) {
        $_.i = _Fy;
        var _G4 = $cvrs($s(6), $get($_.pccw, $_.i), 2);
        $puti($_.pcb, 6 * $_.i + 6 - _G4.length, _G4);
      }
    }
    $_.scm = $s(60);
    $puti($_.scm, 2, $_.mdb);
    $puti($_.scm, 38, $geti($_.pcb, 0, 4));
    $puti($_.scm, 30, $geti($_.pcb, 4, 6));
    $puti($_.scm, 24, $geti($_.pcb, 10, 6));
    $puti($_.scm, 18, $geti($_.pcb, 16, 6));
    $puti($_.scm, 12, $geti($_.pcb, 22, 6));
    $puti($_.scm, 6, $geti($_.pcb, 28, 6));
    $puti($_.scm, 0, $geti($_.pcb, 34, 2));
    $puti($_.scm, 52, $geti($_.ccb, 0, 2));
    $puti($_.scm, 42, $geti($_.ccb, 2, 6));
    $puti($_.scm, 36, $geti($_.ccb, 8, 2));
    $puti($_.scm, 54, $geti($_.scb, 0, 6));
    $puti($_.scm, 48, $geti($_.scb, 6, 4));
    $_.pri = $a([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    for (var _Gk = 0; _Gk <= 59; _Gk += 1) {
      $_.i = _Gk;
      $_.ps = ~~($_.i / 6);
      $_.ep = ~~$pow(2, 5 - $_.i % 6) * ($get($_.scm, $_.i) - 48);
      $put($_.pri, $_.ps, $f($get($_.pri, $_.ps) + $_.ep));
    }
    $k[$j++] = Infinity;
    for (var _Gw = 0; _Gw < 84; _Gw++) {
      $k[$j++] = $_.padval;
    }
    $_.sec = $a();
    $puti($_.sec, 0, $_.encmsg);
  }
  if ($_.mode == 4 || $_.mode == 5 || $_.mode == 6 || $_.mode == -1) {
    if ($_.mode == -1) {
      var _H7 = $_.encmsg.length <= 77 ? 5 : 4;
      $_.mode = _H7;
    }
    $k[$j++] = Infinity;
    var _H9 = $_.mode == 5 ? 78 : 94;
    for (var _HA = 0, _HB = _H9; _HA < _HB; _HA++) {
      $k[$j++] = $_.padval;
    }
    $_.cws = $a();
    if ($_.encmsg.length > $_.cws.length - 1) {
      $k[$j++] = "bwipp.maxicodeMode56TooLong#23243";
      $k[$j++] = "The message is too long";
      bwipp_raiseerror();
    }
    $put($_.cws, 0, $_.mode);
    $puti($_.cws, 1, $_.encmsg);
    $_.pri = $geti($_.cws, 0, 10);
    $_.sec = $geti($_.cws, 10, $_.cws.length - 10);
  }
  $k[$j++] = Infinity;
  $k[$j++] = 1;
  for (var _HP = 0; _HP < 63; _HP++) {
    var _HQ = $k[$j - 1];
    var _HR = _HQ * 2;
    $k[$j++] = _HR;
    if (_HR >= 64) {
      var _HS = $k[--$j];
      $k[$j++] = _HS ^ 67;
    }
  }
  $_.rsalog = $a();
  $_.rslog = $a(64);
  for (var _HV = 1; _HV <= 63; _HV += 1) {
    $put($_.rslog, $get($_.rsalog, _HV), _HV);
  }
  $_.rsprod = function() {
    var _Ha = $k[$j - 1];
    var _Hb = $k[$j - 2];
    if (_Ha != 0 && _Hb != 0) {
      var _He = $get($_.rslog, $k[--$j]);
      var _Hj = $get($_.rsalog, $f(_He + $get($_.rslog, $k[--$j])) % 63);
      $k[$j++] = _Hj;
    } else {
      $j -= 2;
      $k[$j++] = 0;
    }
  };
  $_.rscodes = function() {
    $_.rsnum = $k[--$j];
    $_.cwb = $k[--$j];
    $k[$j++] = Infinity;
    $k[$j++] = 1;
    for (var _Hn = 0, _Ho = $_.rsnum; _Hn < _Ho; _Hn++) {
      $k[$j++] = 0;
    }
    $_.coeffs = $a();
    for (var _Hs = 1, _Hr = $_.rsnum; _Hs <= _Hr; _Hs += 1) {
      $_.i = _Hs;
      $put($_.coeffs, $_.i, $get($_.coeffs, $_.i - 1));
      for (var _Hz = $_.i - 1; _Hz >= 1; _Hz -= 1) {
        $_.j = _Hz;
        $k[$j++] = $_.coeffs;
        $k[$j++] = $_.j;
        $k[$j++] = $get($_.coeffs, $_.j - 1);
        $k[$j++] = $get($_.coeffs, $_.j);
        $k[$j++] = $get($_.rsalog, $_.i);
        $_.rsprod();
        var _IB = $k[--$j];
        var _IC = $k[--$j];
        var _ID = $k[--$j];
        $put($k[--$j], _ID, $xo(_IC, _IB));
      }
      $k[$j++] = $_.coeffs;
      $k[$j++] = 0;
      $k[$j++] = $get($_.coeffs, 0);
      $k[$j++] = $get($_.rsalog, $_.i);
      $_.rsprod();
      var _IL = $k[--$j];
      var _IM = $k[--$j];
      $put($k[--$j], _IM, _IL);
    }
    $_.coeffs = $geti($_.coeffs, 0, $_.coeffs.length - 1);
    $k[$j++] = Infinity;
    for (var _IS = 0, _IT = $_.rsnum; _IS < _IT; _IS++) {
      $k[$j++] = 0;
    }
    $_.ecb = $a();
    for (var _IX = 0, _IW = $_.cwb.length - 1; _IX <= _IW; _IX += 1) {
      $_.t = $xo($get($_.cwb, _IX), $get($_.ecb, 0));
      for (var _Id = $_.ecb.length - 1; _Id >= 0; _Id -= 1) {
        $_.i = _Id;
        $_.p = $_.ecb.length - $_.i - 1;
        $k[$j++] = $_.ecb;
        $k[$j++] = $_.p;
        $k[$j++] = $_.t;
        $k[$j++] = $get($_.coeffs, $_.i);
        $_.rsprod();
        var _Im = $k[--$j];
        var _In = $k[--$j];
        $put($k[--$j], _In, _Im);
        if ($_.i > 0) {
          $put($_.ecb, $_.p, $xo($get($_.ecb, $_.p + 1), $get($_.ecb, $_.p)));
        }
      }
    }
    $k[$j++] = $_.ecb;
  };
  $k[$j++] = Infinity;
  for (var _J1 = 0, _J0 = $_.sec.length - 1; _J1 <= _J0; _J1 += 2) {
    $k[$j++] = $get($_.sec, _J1);
  }
  $_.seco = $a();
  $k[$j++] = Infinity;
  for (var _J7 = 1, _J6 = $_.sec.length - 1; _J7 <= _J6; _J7 += 2) {
    $k[$j++] = $get($_.sec, _J7);
  }
  $_.sece = $a();
  var _JC = $_.sec.length == 84 ? 20 : 28;
  $_.scodes = _JC;
  $k[$j++] = "secochk";
  $k[$j++] = $_.seco;
  $k[$j++] = $_.scodes;
  $_.rscodes();
  var _JF = $k[--$j];
  $_[$k[--$j]] = _JF;
  $k[$j++] = "secechk";
  $k[$j++] = $_.sece;
  $k[$j++] = $_.scodes;
  $_.rscodes();
  var _JJ = $k[--$j];
  $_[$k[--$j]] = _JJ;
  $k[$j++] = Infinity;
  for (var _JN = 0, _JM = $_.scodes - 1; _JN <= _JM; _JN += 1) {
    $k[$j++] = $get($_.secochk, _JN);
    $k[$j++] = $get($_.secechk, _JN);
  }
  $_.secchk = $a();
  $k[$j++] = Infinity;
  $aload($_.pri);
  $k[$j++] = $_.pri;
  $k[$j++] = 10;
  $_.rscodes();
  $aload($k[--$j]);
  $aload($_.sec);
  $aload($_.secchk);
  $_.codewords = $a();
  var _Ja = $get($_.options, "debugcws") !== void 0;
  if (_Ja) {
    $k[$j++] = "bwipp.debugcws#23325";
    $k[$j++] = $_.codewords;
    bwipp_raiseerror();
  }
  $k[$j++] = Infinity;
  for (var _Jc = 0; _Jc < 864; _Jc++) {
    $k[$j++] = 0;
  }
  $_.mods = $a();
  for (var _Je = 0; _Je <= 143; _Je += 1) {
    $_.i = _Je;
    $k[$j++] = Infinity;
    var _Jj = $cvrs($s(6), $get($_.codewords, $_.i), 2);
    for (var _Jk = 0, _Jl = _Jj.length; _Jk < _Jl; _Jk++) {
      $k[$j++] = $get(_Jj, _Jk) - 48;
    }
    $_.cw = $a();
    $puti($_.mods, 6 * $_.i + (6 - $_.cw.length), $_.cw);
  }
  $_.modmap = $a([469, 529, 286, 316, 347, 346, 673, 672, 703, 702, 647, 676, 283, 282, 313, 312, 370, 610, 618, 379, 378, 409, 408, 439, 705, 704, 559, 589, 588, 619, 458, 518, 640, 701, 675, 674, 285, 284, 315, 314, 310, 340, 531, 289, 288, 319, 349, 348, 456, 486, 517, 516, 471, 470, 369, 368, 399, 398, 429, 428, 549, 548, 579, 578, 609, 608, 649, 648, 679, 678, 709, 708, 639, 638, 669, 668, 699, 698, 279, 278, 309, 308, 339, 338, 381, 380, 411, 410, 441, 440, 561, 560, 591, 590, 621, 620, 547, 546, 577, 576, 607, 606, 367, 366, 397, 396, 427, 426, 291, 290, 321, 320, 351, 350, 651, 650, 681, 680, 711, 710, 1, 0, 31, 30, 61, 60, 3, 2, 33, 32, 63, 62, 5, 4, 35, 34, 65, 64, 7, 6, 37, 36, 67, 66, 9, 8, 39, 38, 69, 68, 11, 10, 41, 40, 71, 70, 13, 12, 43, 42, 73, 72, 15, 14, 45, 44, 75, 74, 17, 16, 47, 46, 77, 76, 19, 18, 49, 48, 79, 78, 21, 20, 51, 50, 81, 80, 23, 22, 53, 52, 83, 82, 25, 24, 55, 54, 85, 84, 27, 26, 57, 56, 87, 86, 117, 116, 147, 146, 177, 176, 115, 114, 145, 144, 175, 174, 113, 112, 143, 142, 173, 172, 111, 110, 141, 140, 171, 170, 109, 108, 139, 138, 169, 168, 107, 106, 137, 136, 167, 166, 105, 104, 135, 134, 165, 164, 103, 102, 133, 132, 163, 162, 101, 100, 131, 130, 161, 160, 99, 98, 129, 128, 159, 158, 97, 96, 127, 126, 157, 156, 95, 94, 125, 124, 155, 154, 93, 92, 123, 122, 153, 152, 91, 90, 121, 120, 151, 150, 181, 180, 211, 210, 241, 240, 183, 182, 213, 212, 243, 242, 185, 184, 215, 214, 245, 244, 187, 186, 217, 216, 247, 246, 189, 188, 219, 218, 249, 248, 191, 190, 221, 220, 251, 250, 193, 192, 223, 222, 253, 252, 195, 194, 225, 224, 255, 254, 197, 196, 227, 226, 257, 256, 199, 198, 229, 228, 259, 258, 201, 200, 231, 230, 261, 260, 203, 202, 233, 232, 263, 262, 205, 204, 235, 234, 265, 264, 207, 206, 237, 236, 267, 266, 297, 296, 327, 326, 357, 356, 295, 294, 325, 324, 355, 354, 293, 292, 323, 322, 353, 352, 277, 276, 307, 306, 337, 336, 275, 274, 305, 304, 335, 334, 273, 272, 303, 302, 333, 332, 271, 270, 301, 300, 331, 330, 361, 360, 391, 390, 421, 420, 363, 362, 393, 392, 423, 422, 365, 364, 395, 394, 425, 424, 383, 382, 413, 412, 443, 442, 385, 384, 415, 414, 445, 444, 387, 386, 417, 416, 447, 446, 477, 476, 507, 506, 537, 536, 475, 474, 505, 504, 535, 534, 473, 472, 503, 502, 533, 532, 455, 454, 485, 484, 515, 514, 453, 452, 483, 482, 513, 512, 451, 450, 481, 480, 511, 510, 541, 540, 571, 570, 601, 600, 543, 542, 573, 572, 603, 602, 545, 544, 575, 574, 605, 604, 563, 562, 593, 592, 623, 622, 565, 564, 595, 594, 625, 624, 567, 566, 597, 596, 627, 626, 657, 656, 687, 686, 717, 716, 655, 654, 685, 684, 715, 714, 653, 652, 683, 682, 713, 712, 637, 636, 667, 666, 697, 696, 635, 634, 665, 664, 695, 694, 633, 632, 663, 662, 693, 692, 631, 630, 661, 660, 691, 690, 721, 720, 751, 750, 781, 780, 723, 722, 753, 752, 783, 782, 725, 724, 755, 754, 785, 784, 727, 726, 757, 756, 787, 786, 729, 728, 759, 758, 789, 788, 731, 730, 761, 760, 791, 790, 733, 732, 763, 762, 793, 792, 735, 734, 765, 764, 795, 794, 737, 736, 767, 766, 797, 796, 739, 738, 769, 768, 799, 798, 741, 740, 771, 770, 801, 800, 743, 742, 773, 772, 803, 802, 745, 744, 775, 774, 805, 804, 747, 746, 777, 776, 807, 806, 837, 836, 867, 866, 897, 896, 835, 834, 865, 864, 895, 894, 833, 832, 863, 862, 893, 892, 831, 830, 861, 860, 891, 890, 829, 828, 859, 858, 889, 888, 827, 826, 857, 856, 887, 886, 825, 824, 855, 854, 885, 884, 823, 822, 853, 852, 883, 882, 821, 820, 851, 850, 881, 880, 819, 818, 849, 848, 879, 878, 817, 816, 847, 846, 877, 876, 815, 814, 845, 844, 875, 874, 813, 812, 843, 842, 873, 872, 811, 810, 841, 840, 871, 870, 901, 900, 931, 930, 961, 960, 903, 902, 933, 932, 963, 962, 905, 904, 935, 934, 965, 964, 907, 906, 937, 936, 967, 966, 909, 908, 939, 938, 969, 968, 911, 910, 941, 940, 971, 970, 913, 912, 943, 942, 973, 972, 915, 914, 945, 944, 975, 974, 917, 916, 947, 946, 977, 976, 919, 918, 949, 948, 979, 978, 921, 920, 951, 950, 981, 980, 923, 922, 953, 952, 983, 982, 925, 924, 955, 954, 985, 984, 927, 926, 957, 956, 987, 986, 58, 89, 88, 118, 149, 148, 178, 209, 208, 238, 269, 268, 298, 329, 328, 358, 389, 388, 418, 449, 448, 478, 509, 508, 538, 569, 568, 598, 629, 628, 658, 689, 688, 718, 749, 748, 778, 809, 808, 838, 869, 868, 898, 929, 928, 958, 989, 988]);
  $_.pixs = $a(864);
  $_.j = 0;
  for (var _Jx = 0, _Jw = $_.mods.length - 1; _Jx <= _Jw; _Jx += 1) {
    $_.i = _Jx;
    if ($get($_.mods, $_.i) == 1) {
      $put($_.pixs, $_.j, $get($_.modmap, $_.i));
      $_.j = $_.j + 1;
    }
  }
  $k[$j++] = Infinity;
  $aload($geti($_.pixs, 0, $_.j));
  $k[$j++] = 28;
  $k[$j++] = 29;
  $k[$j++] = 280;
  $k[$j++] = 281;
  $k[$j++] = 311;
  $k[$j++] = 457;
  $k[$j++] = 488;
  $k[$j++] = 500;
  $k[$j++] = 530;
  $k[$j++] = 670;
  $k[$j++] = 700;
  $k[$j++] = 677;
  $k[$j++] = 707;
  $_.pixs = $a();
  var _KD = /* @__PURE__ */ new Map([
    ["ren", "renmaximatrix"],
    ["pixs", $_.pixs],
    ["borderleft", 1],
    ["borderright", 1],
    ["bordertop", 1],
    ["borderbottom", 1],
    ["opt", $_.options]
  ]);
  $k[$j++] = _KD;
  if (!$_.dontdraw) {
    bwipp_renmaximatrix();
  }
  $_ = $__;
}
function bwipp_azteccode() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.format = "full";
  $_.readerinit = false;
  $_.layers = -1;
  $_.eclevel = 23;
  $_.ecaddchars = 3;
  $_.raw = false;
  $_.parse = false;
  $_.parsefnc = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length == 0) {
    $k[$j++] = "bwipp.aztecEmptyData#23462";
    $k[$j++] = "The data must not be empty";
    bwipp_raiseerror();
  }
  if ($_.eclevel < 5 || $_.eclevel > 95) {
    $k[$j++] = "bwipp.aztecInvalidEClevel#23466";
    $k[$j++] = "The EC percentage must be from 5 to 95";
    bwipp_raiseerror();
  }
  if ($_.ecaddchars < 3) {
    $k[$j++] = "bwipp.aztecInvalidECaddChars#23470";
    $k[$j++] = "The number of additional EC codewords must be 3 or more";
    bwipp_raiseerror();
  }
  if ($ne($_.format, "full") && ($ne($_.format, "compact") && $ne($_.format, "rune"))) {
    $k[$j++] = "bwipp.aztecInvalidFormat#23474";
    $k[$j++] = "The format must be either full, compact or rune";
    bwipp_raiseerror();
  }
  if ($eq($_.format, "full")) {
    if ($_.readerinit && ($_.layers < 1 || $_.layers > 22)) {
      $k[$j++] = "bwipp.aztecFullInitInvalidLayers#23479";
      $k[$j++] = "Full-range symbols for reader programming must specify from 1 to 22 layers";
      bwipp_raiseerror();
    }
    if ($_.layers != -1 && ($_.layers < 1 || $_.layers > 32)) {
      $k[$j++] = "bwipp.aztecFullInvalidLayers#23482";
      $k[$j++] = "Layers for full-range symbols must be from 1 to 32";
      bwipp_raiseerror();
    }
  }
  if ($eq($_.format, "compact")) {
    if ($_.readerinit) {
      if ($_.layers != -1 && $_.layers != 1) {
        $k[$j++] = "bwipp.aztecCompactInitInvalidLayers#23489";
        $k[$j++] = "Compact symbols for reader programming must have 1 layer";
        bwipp_raiseerror();
      }
      $_.layers = 1;
    }
    if ($_.layers != -1 && ($_.layers < 1 || $_.layers > 4)) {
      $k[$j++] = "bwipp.aztecCompactInvalidLayers#23494";
      $k[$j++] = "Layers for compact symbols must be from 1 to 4";
      bwipp_raiseerror();
    }
  }
  if ($eq($_.format, "rune")) {
    if ($_.layers != -1) {
      $k[$j++] = "bwipp.aztecRuneInvalidLayers#23500";
      $k[$j++] = "It is not valid to specify layers for runes";
      bwipp_raiseerror();
    }
    if ($_.readerinit) {
      $k[$j++] = "bwipp.aztecRuneReaderInit#23503";
      $k[$j++] = "Reader initialisation is not compactible with Aztec Runes";
      bwipp_raiseerror();
    }
    if ($_.barcode.length == 0) {
      $k[$j++] = "bwipp.aztecRuneNotNumeric#23506";
      $k[$j++] = "Aztec runes must be numeric";
      bwipp_raiseerror();
    }
    $forall($_.barcode, function() {
      var _S = $k[--$j];
      if (_S < 48 || _S > 57) {
        $k[$j++] = "bwipp.aztecRuneNotNumeric#23510";
        $k[$j++] = "Aztec runes must be numeric";
        bwipp_raiseerror();
      }
    });
    var _U = $cvi($_.barcode);
    if (_U < 0 || _U > 255) {
      $k[$j++] = "bwipp.aztecRuneInvalid#23514";
      $k[$j++] = "Aztec runes must be 0 to 255";
      bwipp_raiseerror();
    }
  }
  $_.fn1 = -1;
  var _Y = /* @__PURE__ */ new Map([
    ["parse", $_.parse],
    ["parsefnc", $_.parsefnc],
    ["eci", true],
    ["FNC1", $_.fn1]
  ]);
  $_.fncvals = _Y;
  $k[$j++] = "msg";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.fncvals;
  bwipp_parseinput();
  var _b = $k[--$j];
  $_[$k[--$j]] = _b;
  $_.msglen = $_.msg.length;
  $_.U = 0;
  $_.L = 1;
  $_.M = 2;
  $_.P = 3;
  $_.D = 4;
  $_.B = 5;
  $_.lu = -2;
  $_.ll = -3;
  $_.lm = -4;
  $_.lp = -5;
  $_.ld = -6;
  $_.su = -7;
  $_.sp = -8;
  $_.sb = -9;
  $_.fl = -10;
  $_.p2 = -11;
  $_.p3 = -12;
  $_.p4 = -13;
  $_.p5 = -14;
  $_.charmaps = $a([$a([$_.sp, $_.sp, $_.sp, $_.fl, $_.sp]), $a([32, 32, 32, 13, 32]), $a(["A", "a", 1, $_.p2, "0"]), $a(["B", "b", 2, $_.p3, "1"]), $a(["C", "c", 3, $_.p4, "2"]), $a(["D", "d", 4, $_.p5, "3"]), $a(["E", "e", 5, "!", "4"]), $a(["F", "f", 6, '"', "5"]), $a(["G", "g", 7, "#", "6"]), $a(["H", "h", 8, "$", "7"]), $a(["I", "i", 9, "%", "8"]), $a(["J", "j", 10, "&", "9"]), $a(["K", "k", 11, "'", ","]), $a(["L", "l", 12, 40, "."]), $a(["M", "m", 13, 41, $_.lu]), $a(["N", "n", 27, "*", $_.su]), $a(["O", "o", 28, "+", -99]), $a(["P", "p", 29, ",", -99]), $a(["Q", "q", 30, "-", -99]), $a(["R", "r", 31, ".", -99]), $a(["S", "s", "@", "/", -99]), $a(["T", "t", 92, ":", -99]), $a(["U", "u", "^", ";", -99]), $a(["V", "v", "_", "<", -99]), $a(["W", "w", "`", "=", -99]), $a(["X", "x", "|", ">", -99]), $a(["Y", "y", "~", "?", -99]), $a(["Z", "z", 127, "[", -99]), $a([$_.ll, $_.su, $_.ll, "]", -99]), $a([$_.lm, $_.lm, $_.lu, "{", -99]), $a([$_.ld, $_.ld, $_.lp, "}", -99]), $a([$_.sb, $_.sb, $_.sb, $_.lu, -99])]);
  $_.charvals = $a([/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map()]);
  for (var _1c = 0, _1b = $_.charmaps.length - 1; _1c <= _1b; _1c += 1) {
    $_.i = _1c;
    $_.encs = $get($_.charmaps, $_.i);
    for (var _1g = 0; _1g <= 4; _1g += 1) {
      $_.j = _1g;
      var _1j = $get($_.encs, $_.j);
      $k[$j++] = _1j;
      if ($eq($type(_1j), "stringtype")) {
        var _1m = $get($k[--$j], 0);
        $k[$j++] = _1m;
      }
      $put($get($_.charvals, $_.j), $k[--$j], $_.i);
    }
  }
  var _1w = /* @__PURE__ */ new Map([
    ["\r\n", $_.p2],
    [". ", $_.p3],
    [", ", $_.p4],
    [": ", $_.p5]
  ]);
  $_.pcomp = _1w;
  $_.e = 1e6;
  $_.latlen = $a([$a([0, 5, 5, 10, 5, 10]), $a([9, 0, 5, 10, 5, 10]), $a([5, 5, 0, 5, 10, 10]), $a([5, 10, 10, 0, 10, 15]), $a([4, 9, 9, 14, 0, 14]), $a([0, 0, 0, 0, 0, 0])]);
  $_.latseq = $a([$a([$a([]), $a([$_.ll]), $a([$_.lm]), $a([$_.lm, $_.lp]), $a([$_.ld]), $a([$_.sb])]), $a([$a([$_.ld, $_.lu]), $a([]), $a([$_.lm]), $a([$_.lm, $_.lp]), $a([$_.ld]), $a([$_.sb])]), $a([$a([$_.lu]), $a([$_.ll]), $a([]), $a([$_.lp]), $a([$_.lu, $_.ld]), $a([$_.sb])]), $a([$a([$_.lu]), $a([$_.lu, $_.ll]), $a([$_.lu, $_.lm]), $a([]), $a([$_.lu, $_.ld]), $a([$_.lu, $_.sb])]), $a([$a([$_.lu]), $a([$_.lu, $_.ll]), $a([$_.lu, $_.lm]), $a([$_.lu, $_.lm, $_.lp]), $a([]), $a([$_.lu, $_.sb])]), $a([$a([$_.lu]), $a([$_.ll]), $a([$_.lm]), $a([]), $a([]), $a([])])]);
  $_.shftlen = $a([$a([$_.e, $_.e, $_.e, 5, $_.e]), $a([5, $_.e, $_.e, 5, $_.e]), $a([$_.e, $_.e, $_.e, 5, $_.e]), $a([$_.e, $_.e, $_.e, $_.e, $_.e]), $a([4, $_.e, $_.e, 4, $_.e])]);
  $_.msgbits = "";
  if ($ne($_.format, "rune") && $_.raw) {
    $_.msgbits = $_.barcode;
  }
  if ($ne($_.format, "rune") && !$_.raw) {
    $_.charsize = function() {
      var _3v = $k[$j - 1];
      if (_3v >= 0) {
        $j--;
        var _3y = $get($a([5, 5, 5, 5, 4, 8]), $k[--$j]);
        $k[$j++] = _3y;
      } else {
        var _3z = $k[--$j];
        $k[$j - 1] = _3z;
        var _41 = $k[$j - 1];
        if (_41 == $_.fn1) {
          $k[$j - 1] = 8;
        } else {
          var _44 = -$k[--$j] - 1e6;
          $k[$j++] = _44;
          if (_44 == 0) {
            $k[$j - 1] = 1;
          }
          var _45 = $k[--$j];
          $k[$j++] = (~~($log(_45) / $log(10)) + 1) * 4 + 8;
        }
      }
    };
    $_.curlen = $a([0, $_.e, $_.e, $_.e, $_.e, $_.e]);
    $_.curseq = $a([$a([]), $a([]), $a([]), $a([]), $a([]), $a([])]);
    $_.backto = $_.U;
    $_.lastchar = "";
    $forall($_.msg, function() {
      $_.char = $k[--$j];
      for (; ; ) {
        $_.imp = false;
        var _4S = $a([$_.U, $_.L, $_.M, $_.P, $_.D, $_.B]);
        for (var _4T = 0, _4U = _4S.length; _4T < _4U; _4T++) {
          $_.x = $get(_4S, _4T);
          var _4c = $a([$_.U, $_.L, $_.M, $_.P, $_.D, $_.B]);
          for (var _4d = 0, _4e = _4c.length; _4d < _4e; _4d++) {
            $_.y = $get(_4c, _4d);
            if ($_.x != $_.B || $_.y == $_.backto) {
              $_.cost = $f($get($_.curlen, $_.x) + $get($get($_.latlen, $_.x), $_.y));
              if ($_.cost < $get($_.curlen, $_.y)) {
                $put($_.curlen, $_.y, $_.cost);
                $k[$j++] = $_.curseq;
                $k[$j++] = $_.y;
                $k[$j++] = Infinity;
                $aload($get($_.curseq, $_.x));
                $aload($get($get($_.latseq, $_.x), $_.y));
                var _59 = $a();
                var _5A = $k[--$j];
                $put($k[--$j], _5A, _59);
                if ($_.y == $_.B) {
                  $k[$j++] = "backto";
                  if ($_.x == $_.P || $_.x == $_.D) {
                    $k[$j++] = $_.U;
                  } else {
                    $k[$j++] = $_.x;
                  }
                  var _5K = $k[--$j];
                  $_[$k[--$j]] = _5K;
                }
                $_.imp = true;
              }
            }
          }
        }
        if (!$_.imp) {
          break;
        }
      }
      $_.nxtlen = $a([$_.e, $_.e, $_.e, $_.e, $_.e, $_.e]);
      $_.nxtseq = $a(6);
      var _5b = $a([$_.U, $_.L, $_.M, $_.P, $_.D, $_.B]);
      for (var _5c = 0, _5d = _5b.length; _5c < _5d; _5c++) {
        $_.x = $get(_5b, _5c);
        for (; ; ) {
          if ($_.char >= 0) {
            if ($_.x != $_.B) {
              var _5m = $get($get($_.charvals, $_.x), $_.char) !== void 0;
              if (!_5m) {
                break;
              }
            }
          } else {
            if ($_.x != $_.P) {
              break;
            }
          }
          $k[$j++] = "cost";
          $k[$j++] = $get($_.curlen, $_.x);
          $k[$j++] = $_.x;
          $k[$j++] = $_.char;
          $_.charsize();
          var _5u = $k[--$j];
          var _5v = $k[--$j];
          $_[$k[--$j]] = $f(_5v + _5u);
          if ($_.cost < $get($_.nxtlen, $_.x)) {
            $put($_.nxtlen, $_.x, $_.cost);
            $k[$j++] = $_.nxtseq;
            $k[$j++] = $_.x;
            $k[$j++] = Infinity;
            $aload($get($_.curseq, $_.x));
            $k[$j++] = $_.char;
            var _6A = $a();
            var _6B = $k[--$j];
            $put($k[--$j], _6B, _6A);
          }
          if ($_.x == $_.B) {
            break;
          }
          var _6K = $a([$_.U, $_.L, $_.M, $_.P, $_.D]);
          for (var _6L = 0, _6M = _6K.length; _6L < _6M; _6L++) {
            $_.y = $get(_6K, _6L);
            if ($ne($_.x, $_.y)) {
              $k[$j++] = "cost";
              $k[$j++] = $f($get($_.curlen, $_.y) + $get($get($_.shftlen, $_.y), $_.x));
              $k[$j++] = $_.x;
              $k[$j++] = $_.char;
              $_.charsize();
              var _6a = $k[--$j];
              var _6b = $k[--$j];
              $_[$k[--$j]] = $f(_6b + _6a);
              if ($_.cost < $get($_.nxtlen, $_.y)) {
                $put($_.nxtlen, $_.y, $_.cost);
                $k[$j++] = $_.nxtseq;
                $k[$j++] = $_.y;
                $k[$j++] = Infinity;
                $aload($get($_.curseq, $_.y));
                var _6r = $_.x == $_.U ? $_.su : $_.sp;
                $k[$j++] = _6r;
                $k[$j++] = $_.char;
                var _6t = $a();
                var _6u = $k[--$j];
                $put($k[--$j], _6u, _6t);
              }
            }
          }
          break;
        }
      }
      if ($_.lastchar.length != 0 && $_.char >= 0) {
        var _6y = $s(2);
        $put(_6y, 0, $_.lastchar);
        $put(_6y, 1, $_.char);
        $_.pchars = _6y;
        var _73 = $get($_.pcomp, $_.pchars) !== void 0;
        if (_73) {
          var _79 = $a([$_.U, $_.L, $_.M, $_.P, $_.D]);
          for (var _7A = 0, _7B = _79.length; _7A < _7B; _7A++) {
            $_.i = $get(_79, _7A);
            $_.inP = true;
            if ($_.i == $_.M) {
              if ($_.lastchar == 13) {
                $_.inP = false;
              }
            } else {
              if ($_.i == $_.D) {
                if ($_.lastchar == 44 || $_.lastchar == 46) {
                  $_.inP = false;
                }
              }
            }
            if ($_.inP && $lt($get($_.curlen, $_.i), $get($_.nxtlen, $_.i))) {
              $_.curseqi = $get($_.curseq, $_.i);
              $_.lastld = false;
              $_.lastsp = false;
              $_.lastidx = -1;
              for (var _7V = $_.curseqi.length - 1; _7V >= 0; _7V -= 1) {
                $_.idx = _7V;
                $_.ch = $get($_.curseqi, $_.idx);
                if ($_.lastidx == -1) {
                  if ($eq($_.ch, $_.lastchar)) {
                    $_.lastidx = $_.idx;
                    if ($_.idx > 0) {
                      if ($get($_.curseqi, $_.idx - 1) == $_.sp) {
                        $_.lastsp = true;
                      }
                    }
                  }
                } else {
                  if ($_.ch == $_.sb) {
                    $_.lastidx = -1;
                    break;
                  }
                  if ($_.ch < 0 && $_.ch >= $_.ld) {
                    if ($_.i == $_.P) {
                      if ($_.ch == $_.ld) {
                        $_.lastld = true;
                      }
                    } else {
                      if ($_.ch != $_.lp) {
                        $_.inP = $_.lastsp;
                      }
                    }
                    break;
                  }
                }
              }
              if ($_.inP && $_.lastidx >= 0) {
                $put($_.nxtlen, $_.i, $get($_.curlen, $_.i));
                if ($_.lastidx < $_.curseqi.length - 1) {
                  if ($_.i == $_.P) {
                    if ($_.lastld) {
                      $put($_.nxtlen, $_.i, $get($_.nxtlen, $_.i) + 1);
                    }
                    $k[$j++] = $_.nxtseq;
                    $k[$j++] = $_.i;
                    $k[$j++] = Infinity;
                    $aload($_.curseqi);
                    $r($_.curseqi.length - $_.lastidx, -1);
                    $k[$j - 1] = $get($_.pcomp, $_.pchars);
                    var _8J = $a();
                    var _8K = $k[--$j];
                    $put($k[--$j], _8K, _8J);
                  } else {
                    $k[$j++] = $_.nxtseq;
                    $k[$j++] = $_.i;
                    $k[$j++] = Infinity;
                    $aload($_.curseqi);
                    var _8P = $a();
                    var _8Q = $k[--$j];
                    $put($k[--$j], _8Q, _8P);
                    $put($get($_.nxtseq, $_.i), $_.lastidx, $get($_.pcomp, $_.pchars));
                  }
                } else {
                  $k[$j++] = $_.nxtseq;
                  $k[$j++] = $_.i;
                  $k[$j++] = Infinity;
                  $aload($_.curseqi);
                  $k[$j - 1] = $get($_.pcomp, $_.pchars);
                  var _8f = $a();
                  var _8g = $k[--$j];
                  $put($k[--$j], _8g, _8f);
                }
              }
            }
          }
        }
      }
      if ($ne($get($_.nxtseq, $_.B), null)) {
        $_.numbytes = 0;
        $forall($get($_.nxtseq, $_.B), function() {
          if ($k[--$j] == $_.sb) {
            $k[$j++] = 0;
          } else {
            $k[$j++] = $_.numbytes + 1;
          }
          $_.numbytes = $k[--$j];
        });
        if ($_.numbytes == 32) {
          $put($_.nxtlen, $_.B, $get($_.nxtlen, $_.B) + 11);
        }
      }
      $_.curlen = $_.nxtlen;
      $_.curseq = $_.nxtseq;
      $k[$j++] = "lastchar";
      if ($_.char >= 0) {
        $k[$j++] = $_.char;
      } else {
        $k[$j++] = "";
      }
      var _92 = $k[--$j];
      $_[$k[--$j]] = _92;
    });
    $_.minseq = $_.e;
    var _9B = $a([$_.U, $_.L, $_.M, $_.P, $_.D, $_.B]);
    for (var _9C = 0, _9D = _9B.length; _9C < _9D; _9C++) {
      $_.i = $get(_9B, _9C);
      if ($get($_.curlen, $_.i) < $_.minseq) {
        $_.minseq = $get($_.curlen, $_.i);
        $_.seq = $get($_.curseq, $_.i);
      }
    }
    $_.tobin = function() {
      var _9Q = $s($k[--$j]);
      $k[$j++] = _9Q;
      for (var _9S = 0, _9R = _9Q.length - 1; _9S <= _9R; _9S += 1) {
        var _9T = $k[$j - 1];
        $put(_9T, _9S, 48);
      }
      var _9U = $k[$j - 1];
      $k[$j++] = _9U;
      var _9V = $k[$j - 3];
      var _9W = $k[$j - 1];
      $k[$j - 3] = $k[$j - 2];
      $j -= 2;
      var _9Y = $cvrs($s(_9W.length), _9V, 2);
      $puti(_9W, _9W.length - _9Y.length, _9Y);
    };
    $_.encu = function() {
      var _9d = $get($get($_.charvals, $_.U), $k[--$j]);
      $k[$j++] = _9d;
      $k[$j++] = 5;
      $_.tobin();
    };
    $_.encl = function() {
      var _9i = $get($get($_.charvals, $_.L), $k[--$j]);
      $k[$j++] = _9i;
      $k[$j++] = 5;
      $_.tobin();
    };
    $_.encm = function() {
      var _9n = $get($get($_.charvals, $_.M), $k[--$j]);
      $k[$j++] = _9n;
      $k[$j++] = 5;
      $_.tobin();
    };
    $_.encd = function() {
      var _9s = $get($get($_.charvals, $_.D), $k[--$j]);
      $k[$j++] = _9s;
      $k[$j++] = 4;
      $_.tobin();
    };
    $_.encp = function() {
      var _9t = $k[$j - 1];
      if (_9t == $_.fn1) {
        $k[$j - 1] = "00000000";
      } else {
        var _9v = $k[$j - 1];
        if (_9v <= -1e6) {
          var _9x = -$k[--$j] - 1e6;
          $k[$j++] = _9x;
          $k[$j++] = _9x;
          if (_9x == 0) {
            $k[$j - 1] = 1;
          }
          var _9z = ~~($log($k[--$j]) / $log(10));
          var _A0 = $s((_9z + 1) * 4 + 8);
          $puti(_A0, 0, "00000");
          $k[$j++] = _9z;
          $k[$j++] = _A0;
          $k[$j++] = _A0;
          $k[$j++] = _9z + 1;
          $k[$j++] = 3;
          $_.tobin();
          var _A1 = $k[--$j];
          $puti($k[--$j], 5, _A1);
          $r(3, 1);
          $k[$j++] = -1;
          $k[$j++] = 0;
          if ($j < 3) throw "--stack-underflow--";
          $j -= 3;
          for (var _A6 = $k[$j], _A7 = $k[$j + 1], _A5 = $k[$j + 2]; _A7 < 0 ? _A6 >= _A5 : _A6 <= _A5; _A6 += _A7) {
            var _A8 = $k[--$j];
            var _A9 = $k[$j - 1];
            $k[$j++] = ~~(_A8 / 10);
            $k[$j++] = _A9;
            $k[$j++] = _A6 * 4 + 8;
            $k[$j++] = _A8 % 10 + 2;
            $k[$j++] = 4;
            $_.tobin();
            var _AA = $k[--$j];
            var _AB = $k[--$j];
            $puti($k[--$j], _AB, _AA);
          }
          $j--;
        } else {
          var _AH = $get($get($_.charvals, $_.P), $k[--$j]);
          $k[$j++] = _AH;
          $k[$j++] = 5;
          $_.tobin();
        }
      }
    };
    $_.encfuncs = $a(["encu", "encl", "encm", "encp", "encd"]);
    $_.addtomsgbits = function() {
      $_.v = $k[--$j];
      $puti($_.msgbits, $_.j, $_.v);
      $_.j = $_.j + $_.v.length;
    };
    $_.state = $_.U;
    $_.msgbits = $s($_.minseq);
    $_.i = 0;
    $_.j = 0;
    for (; ; ) {
      if ($_.i >= $_.seq.length) {
        break;
      }
      if ($_.state != $_.B) {
        $_.char = $get($_.seq, $_.i);
        $k[$j++] = $_.char;
        if ($_[$get($_.encfuncs, $_.state)]() === true) {
          break;
        }
        $_.addtomsgbits();
        $_.i = $_.i + 1;
        if ($_.char == $_.su || $_.char == $_.sp) {
          $k[$j++] = $get($_.seq, $_.i);
          if ($_.char == $_.su) {
            $_.encu();
          } else {
            $_.encp();
          }
          $_.addtomsgbits();
          $_.i = $_.i + 1;
        }
        if ($_.char == $_.lu) {
          $_.state = $_.U;
        }
        if ($_.char == $_.ll) {
          $_.state = $_.L;
        }
        if ($_.char == $_.lm) {
          $_.state = $_.M;
        }
        if ($_.char == $_.lp) {
          $_.state = $_.P;
        }
        if ($_.char == $_.ld) {
          $_.state = $_.D;
        }
        if ($_.char == $_.sb) {
          $_.state = $_.B;
        }
      } else {
        $_.numbytes = 0;
        for (; ; ) {
          if ($_.i + $_.numbytes >= $_.seq.length) {
            break;
          }
          if ($get($_.seq, $_.i + $_.numbytes) < 0) {
            break;
          }
          $_.numbytes = $_.numbytes + 1;
        }
        if ($_.numbytes <= 31) {
          $k[$j++] = $_.numbytes;
          $k[$j++] = 5;
          $_.tobin();
          $_.addtomsgbits();
        } else {
          $k[$j++] = 0;
          $k[$j++] = 5;
          $_.tobin();
          $_.addtomsgbits();
          $k[$j++] = $_.numbytes - 31;
          $k[$j++] = 11;
          $_.tobin();
          $_.addtomsgbits();
        }
        for (var _BJ = 0, _BK = $_.numbytes; _BJ < _BK; _BJ++) {
          $k[$j++] = $get($_.seq, $_.i);
          $k[$j++] = 8;
          $_.tobin();
          $_.addtomsgbits();
          $_.i = $_.i + 1;
        }
        if ($_.i < $_.seq.length) {
          $_.char = $get($_.seq, $_.i);
          $_.i = $_.i + 1;
          if ($_.char == $_.lu) {
            $_.state = $_.U;
          }
          if ($_.char == $_.ll) {
            $_.state = $_.L;
          }
          if ($_.char == $_.lm) {
            $_.state = $_.M;
          }
        }
      }
    }
    $_.msgbits = $geti($_.msgbits, 0, $_.j);
  }
  $_.metrics = $a([$a(["rune", 0, 0, 0, 6]), $a(["compact", 1, 1, 17, 6]), $a(["full", 1, 1, 21, 6]), $a(["compact", 2, 0, 40, 6]), $a(["full", 2, 1, 48, 6]), $a(["compact", 3, 0, 51, 8]), $a(["full", 3, 1, 60, 8]), $a(["compact", 4, 0, 76, 8]), $a(["full", 4, 1, 88, 8]), $a(["full", 5, 1, 120, 8]), $a(["full", 6, 1, 156, 8]), $a(["full", 7, 1, 196, 8]), $a(["full", 8, 1, 240, 8]), $a(["full", 9, 1, 230, 10]), $a(["full", 10, 1, 272, 10]), $a(["full", 11, 1, 316, 10]), $a(["full", 12, 1, 364, 10]), $a(["full", 13, 1, 416, 10]), $a(["full", 14, 1, 470, 10]), $a(["full", 15, 1, 528, 10]), $a(["full", 16, 1, 588, 10]), $a(["full", 17, 1, 652, 10]), $a(["full", 18, 1, 720, 10]), $a(["full", 19, 1, 790, 10]), $a(["full", 20, 1, 864, 10]), $a(["full", 21, 1, 940, 10]), $a(["full", 22, 1, 1020, 10]), $a(["full", 23, 0, 920, 12]), $a(["full", 24, 0, 992, 12]), $a(["full", 25, 0, 1066, 12]), $a(["full", 26, 0, 1144, 12]), $a(["full", 27, 0, 1224, 12]), $a(["full", 28, 0, 1306, 12]), $a(["full", 29, 0, 1392, 12]), $a(["full", 30, 0, 1480, 12]), $a(["full", 31, 0, 1570, 12]), $a(["full", 32, 0, 1664, 12])]);
  var _CK = $_.metrics;
  for (var _CL = 0, _CM = _CK.length; _CL < _CM; _CL++) {
    $_.m = $get(_CK, _CL);
    $_.frmt = $get($_.m, 0);
    $_.mlyr = $get($_.m, 1);
    $_.icap = $get($_.m, 2);
    $_.ncws = $get($_.m, 3);
    $_.bpcw = $get($_.m, 4);
    $_.numecw = ~~$ceil($f($_.ncws * $_.eclevel / 100 + $_.ecaddchars));
    if ($_.msgbits.length == 0) {
      $_.numecw = 0;
    }
    $_.numdcw = $f($_.ncws - $_.numecw);
    $_.okay = true;
    if ($ne($_.format, $_.frmt)) {
      $_.okay = false;
    }
    if ($_.readerinit && $_.icap != 1) {
      $_.okay = false;
    }
    if ($_.layers != -1 && $_.layers != $_.mlyr) {
      $_.okay = false;
    }
    if (~~$ceil($_.msgbits.length / $_.bpcw) > $_.numdcw) {
      $_.okay = false;
    }
    if ($_.okay) {
      break;
    }
  }
  if (!$_.okay) {
    $k[$j++] = "bwipp.aztecNoValidSymbol#23967";
    $k[$j++] = "Maximum length exceeded";
    bwipp_raiseerror();
  }
  $_.layers = $_.mlyr;
  $_.allzero = function() {
    var _Cr = $k[--$j];
    $k[$j++] = $eq(_Cr, $geti("000000000000", 0, _Cr.length));
  };
  $_.allones = function() {
    var _Ct = $k[--$j];
    $k[$j++] = $eq(_Ct, $geti("111111111111", 0, _Ct.length));
  };
  $_.cws = $a($_.ncws);
  $_.m = 0;
  $_.c = 0;
  for (; ; ) {
    if ($_.msgbits.length <= $_.m) {
      break;
    }
    if ($_.msgbits.length - $_.m >= $_.bpcw) {
      $_.cwb = $geti($_.msgbits, $_.m, $_.bpcw - 1);
      $_.cwf = $geti($_.msgbits, $f($_.m + $_.bpcw) - 1, 1);
      $k[$j++] = $_.cwb;
      $_.allzero();
      if ($k[--$j]) {
        $_.cwf = "1";
        $_.m = $_.m - 1;
      }
      $k[$j++] = $_.cwb;
      $_.allones();
      if ($k[--$j]) {
        $_.cwf = "0";
        $_.m = $_.m - 1;
      }
      var _DG = $s(12);
      $puti(_DG, 0, $_.cwb);
      $puti(_DG, $_.bpcw - 1, $_.cwf);
      $_.cwb = $geti(_DG, 0, $_.bpcw);
    } else {
      $_.cwb = $geti($_.msgbits, $_.m, $_.msgbits.length - $_.m);
      var _DS = $strcpy($s(12), "111111111111");
      $puti(_DS, 0, $_.cwb);
      $_.cwb = $geti(_DS, 0, $_.bpcw);
      $k[$j++] = $_.cwb;
      $_.allones();
      if ($k[--$j]) {
        $puti($_.cwb, $_.cwb.length - 1, "0");
      }
    }
    $_.cw = 0;
    for (var _Dc = 0, _Db = $_.bpcw - 1; _Dc <= _Db; _Dc += 1) {
      $_.i = _Dc;
      $_.cw = $f($_.cw + ~~$pow(2, $f($_.bpcw - $_.i) - 1) * ($get($_.cwb, $_.i) - 48));
    }
    $put($_.cws, $_.c, $_.cw);
    $_.m = $f($_.m + $_.bpcw);
    $_.c = $_.c + 1;
  }
  $_.cws = $geti($_.cws, 0, $_.c);
  var _Dt = $get($_.options, "debugcws") !== void 0;
  if (_Dt) {
    $k[$j++] = "bwipp.debugcws#24006";
    $k[$j++] = $_.cws;
    bwipp_raiseerror();
  }
  $_.rscodes = function() {
    $_.rspm = $k[--$j];
    $_.rsgf = $k[--$j];
    $_.rsnc = $k[--$j];
    $_.rscws = $k[--$j];
    $k[$j++] = Infinity;
    $k[$j++] = 1;
    for (var _E0 = 0, _E1 = $_.rsgf - 1; _E0 < _E1; _E0++) {
      var _E2 = $k[$j - 1];
      var _E3 = _E2 * 2;
      $k[$j++] = _E3;
      if (_E3 >= $_.rsgf) {
        var _E6 = $k[--$j];
        $k[$j++] = $xo(_E6, $_.rspm);
      }
    }
    $_.rsalog = $a();
    $_.rslog = $a($_.rsgf);
    for (var _EC = 1, _EB = $_.rsgf - 1; _EC <= _EB; _EC += 1) {
      $put($_.rslog, $get($_.rsalog, _EC), _EC);
    }
    $_.rsprod = function() {
      var _EG = $k[$j - 1];
      var _EH = $k[$j - 2];
      if (_EG != 0 && _EH != 0) {
        var _EK = $get($_.rslog, $k[--$j]);
        var _EQ = $get($_.rsalog, $f(_EK + $get($_.rslog, $k[--$j])) % ($_.rsgf - 1));
        $k[$j++] = _EQ;
      } else {
        $j -= 2;
        $k[$j++] = 0;
      }
    };
    $k[$j++] = Infinity;
    $k[$j++] = 1;
    for (var _ES = 0, _ET = $_.rsnc; _ES < _ET; _ES++) {
      $k[$j++] = 0;
    }
    $_.coeffs = $a();
    for (var _EX = 1, _EW = $_.rsnc; _EX <= _EW; _EX += 1) {
      $_.i = _EX;
      $put($_.coeffs, $_.i, $get($_.coeffs, $_.i - 1));
      for (var _Ee = $_.i - 1; _Ee >= 1; _Ee -= 1) {
        $_.j = _Ee;
        $k[$j++] = $_.coeffs;
        $k[$j++] = $_.j;
        $k[$j++] = $get($_.coeffs, $_.j - 1);
        $k[$j++] = $get($_.coeffs, $_.j);
        $k[$j++] = $get($_.rsalog, $_.i);
        $_.rsprod();
        var _Eq = $k[--$j];
        var _Er = $k[--$j];
        var _Es = $k[--$j];
        $put($k[--$j], _Es, $xo(_Er, _Eq));
      }
      $k[$j++] = $_.coeffs;
      $k[$j++] = 0;
      $k[$j++] = $get($_.coeffs, 0);
      $k[$j++] = $get($_.rsalog, $_.i);
      $_.rsprod();
      var _F0 = $k[--$j];
      var _F1 = $k[--$j];
      $put($k[--$j], _F1, _F0);
    }
    $_.nd = $_.rscws.length;
    $k[$j++] = Infinity;
    $aload($_.rscws);
    for (var _F6 = 0, _F7 = $_.rsnc; _F6 < _F7; _F6++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $_.rscws = $a();
    for (var _FB = 0, _FA = $_.nd - 1; _FB <= _FA; _FB += 1) {
      $_.k = $xo($get($_.rscws, _FB), $get($_.rscws, $_.nd));
      for (var _FJ = 0, _FI = $_.rsnc - 1; _FJ <= _FI; _FJ += 1) {
        $_.j = _FJ;
        $k[$j++] = $_.rscws;
        $k[$j++] = $_.nd + $_.j;
        $k[$j++] = $get($_.rscws, $_.nd + $_.j + 1);
        $k[$j++] = $_.k;
        $k[$j++] = $get($_.coeffs, $f($_.rsnc - $_.j) - 1);
        $_.rsprod();
        var _FW = $k[--$j];
        var _FX = $k[--$j];
        var _FY = $k[--$j];
        $put($k[--$j], _FY, $xo(_FX, _FW));
      }
    }
    $k[$j++] = $geti($_.rscws, 0, $_.rscws.length - 1);
  };
  if ($eq($_.format, "full")) {
    $_.mode = ($_.layers - 1 << 11) + ($_.cws.length - 1);
    if ($_.readerinit) {
      $_.mode = $_.mode | 1024;
    }
    $_.mode = $a([($_.mode & 61440) >>> 12, ($_.mode & 3840) >>> 8, ($_.mode & 240) >>> 4, $_.mode & 15]);
    $k[$j++] = "mode";
    $k[$j++] = $_.mode;
    $k[$j++] = 6;
    $k[$j++] = 16;
    $k[$j++] = 19;
    $_.rscodes();
    var _Fo = $k[--$j];
    $_[$k[--$j]] = _Fo;
  }
  if ($eq($_.format, "compact")) {
    $_.mode = ($_.layers - 1 << 6) + ($_.cws.length - 1);
    if ($_.readerinit) {
      $_.mode = $_.mode | 32;
    }
    $_.mode = $a([($_.mode & 240) >>> 4, $_.mode & 15]);
    $k[$j++] = "mode";
    $k[$j++] = $_.mode;
    $k[$j++] = 5;
    $k[$j++] = 16;
    $k[$j++] = 19;
    $_.rscodes();
    var _Fz = $k[--$j];
    $_[$k[--$j]] = _Fz;
  }
  if ($eq($_.format, "rune")) {
    $_.mode = $cvi($_.barcode);
    $_.mode = $a([($_.mode & 240) >>> 4, $_.mode & 15]);
    $k[$j++] = "mode";
    $k[$j++] = $_.mode;
    $k[$j++] = 5;
    $k[$j++] = 16;
    $k[$j++] = 19;
    $_.rscodes();
    var _G7 = $k[--$j];
    $_[$k[--$j]] = _G7;
    $k[$j++] = Infinity;
    var _G9 = $_.mode;
    for (var _GA = 0, _GB = _G9.length; _GA < _GB; _GA++) {
      $k[$j++] = $get(_G9, _GA) ^ 10;
    }
    $_.mode = $a();
  }
  $_.modebits = $s($_.mode.length * 4);
  for (var _GI = 0, _GH = $_.modebits.length - 1; _GI <= _GH; _GI += 1) {
    $puti($_.modebits, _GI, "0");
  }
  for (var _GM = 0, _GL = $_.mode.length - 1; _GM <= _GL; _GM += 1) {
    $_.i = _GM;
    var _GS = $cvrs($s(4), $get($_.mode, $_.i), 2);
    $puti($_.modebits, 4 - _GS.length + 4 * $_.i, _GS);
  }
  $_.rsparams = $a([$a([]), $a([]), $a([]), $a([]), $a([]), $a([]), $a([64, 67]), $a([]), $a([256, 301]), $a([]), $a([1024, 1033]), $a([]), $a([4096, 4201])]);
  $k[$j++] = "cws";
  $k[$j++] = $_.cws;
  $k[$j++] = $f($_.ncws - $_.cws.length);
  $aload($get($_.rsparams, $_.bpcw));
  $_.rscodes();
  var _Gp = $k[--$j];
  $_[$k[--$j]] = _Gp;
  if ($eq($_.format, "full")) {
    $_.databits = $s($f($_.layers * $_.layers * 16 + $_.layers * 112));
  } else {
    $_.databits = $s($f($_.layers * $_.layers * 16 + $_.layers * 88));
  }
  for (var _H2 = 0, _H1 = $_.databits.length - 1; _H2 <= _H1; _H2 += 1) {
    $puti($_.databits, _H2, "0");
  }
  for (var _H6 = 0, _H5 = $_.ncws - 1; _H6 <= _H5; _H6 += 1) {
    $_.i = _H6;
    var _HD = $cvrs($s($_.bpcw), $get($_.cws, $_.i), 2);
    $puti($_.databits, $f($_.bpcw - _HD.length + $_.bpcw * $_.i + ($_.databits.length - $_.ncws * $_.bpcw)), _HD);
  }
  $_.cmv = function() {
    var _HL = $k[--$j];
    var _HM = $k[--$j];
    $k[$j++] = $f(_HM - _HL * $_.size + $_.mid);
  };
  $_.lmv = function() {
    $_.lbit = $k[--$j];
    $_.llyr = $k[--$j];
    $_.lwid = $f($_.fw + $_.llyr * 4);
    $_.ldir = ~~(~~($_.lbit / 2) / $_.lwid);
    if ($_.ldir == 0) {
      $k[$j++] = $f(-~~(($_.lwid - 1) / 2) + 1 + ~~($_.lbit / 2) % $_.lwid);
      $k[$j++] = $f(~~(($_.fw - 1) / 2) + $_.llyr * 2 + $_.lbit % 2);
      $_.cmv();
    }
    if ($_.ldir == 1) {
      $k[$j++] = $f(~~($_.fw / 2) + $_.llyr * 2 + $_.lbit % 2);
      $k[$j++] = $f(~~(($_.lwid - 1) / 2) - 1 - ~~($_.lbit / 2) % $_.lwid);
      $_.cmv();
    }
    if ($_.ldir == 2) {
      $k[$j++] = -$f(-~~($_.lwid / 2) + 1 + ~~($_.lbit / 2) % $_.lwid);
      $k[$j++] = -$f(~~($_.fw / 2) + $_.llyr * 2 + $_.lbit % 2);
      $_.cmv();
    }
    if ($_.ldir == 3) {
      $k[$j++] = -$f(~~(($_.fw - 1) / 2) + $_.llyr * 2 + $_.lbit % 2);
      $k[$j++] = -$f(~~($_.lwid / 2) - 1 - ~~($_.lbit / 2) % $_.lwid);
      $_.cmv();
    }
  };
  if ($eq($_.format, "full")) {
    $_.fw = 12;
  } else {
    $_.fw = 9;
  }
  $_.size = $f($_.fw + $_.layers * 4) + 2;
  $k[$j++] = Infinity;
  for (var _I1 = 0, _I2 = $_.size * $_.size; _I1 < _I2; _I1++) {
    $k[$j++] = -1;
  }
  $_.pixs = $a();
  $_.mid = $f(~~(($_.size - 1) / 2) * $_.size + ~~(($_.size - 1) / 2));
  $_.i = 0;
  for (var _I9 = 1, _I8 = $_.layers; _I9 <= _I8; _I9 += 1) {
    $_.layer = _I9;
    for (var _ID = 0, _IC = ($_.fw + $_.layer * 4) * 8 - 1; _ID <= _IC; _ID += 1) {
      $_.pos = _ID;
      $k[$j++] = $_.pixs;
      $k[$j++] = $_.layer;
      $k[$j++] = $_.pos;
      $_.lmv();
      var _IL = $k[--$j];
      $put($k[--$j], _IL, $get($_.databits, $_.databits.length - $_.i - 1) - 48);
      $_.i = $_.i + 1;
    }
  }
  if ($eq($_.format, "full")) {
    $_.fw = 13;
    $_.size = $f($_.fw + $_.layers * 4 + 2 + ~~(($_.layers + 10.5) / 7.5 - 1) * 2);
    $_.mid = ~~($_.size * $_.size / 2);
    $k[$j++] = Infinity;
    for (var _IW = 0, _IX = $_.size * $_.size; _IW < _IX; _IW++) {
      $k[$j++] = -2;
    }
    $_.npixs = $a();
    for (var _Ib = 0, _Ia = ~~($_.size / 2); _Ib <= _Ia; _Ib += 16) {
      $_.i = _Ib;
      for (var _Ie = 0, _Id = $_.size - 1; _Ie <= _Id; _Ie += 1) {
        $_.j = _Ie;
        $k[$j++] = $_.npixs;
        $k[$j++] = -~~($_.size / 2) + $_.j;
        $k[$j++] = $_.i;
        $_.cmv();
        var _In = $k[--$j];
        $puti($k[--$j], _In, $a([(~~($_.size / 2) + $_.j + $_.i + 1) % 2]));
        $k[$j++] = $_.npixs;
        $k[$j++] = -~~($_.size / 2) + $_.j;
        $k[$j++] = -$_.i;
        $_.cmv();
        var _Ix = $k[--$j];
        $puti($k[--$j], _Ix, $a([(~~($_.size / 2) + $_.j + $_.i + 1) % 2]));
        $k[$j++] = $_.npixs;
        $k[$j++] = $_.i;
        $k[$j++] = -~~($_.size / 2) + $_.j;
        $_.cmv();
        var _J7 = $k[--$j];
        $puti($k[--$j], _J7, $a([(~~($_.size / 2) + $_.j + $_.i + 1) % 2]));
        $k[$j++] = $_.npixs;
        $k[$j++] = -$_.i;
        $k[$j++] = -~~($_.size / 2) + $_.j;
        $_.cmv();
        var _JH = $k[--$j];
        $puti($k[--$j], _JH, $a([(~~($_.size / 2) + $_.j + $_.i + 1) % 2]));
      }
    }
    $_.j = 0;
    for (var _JL = 0, _JK = $_.npixs.length - 1; _JL <= _JK; _JL += 1) {
      $_.i = _JL;
      if ($get($_.npixs, $_.i) == -2) {
        $put($_.npixs, $_.i, $get($_.pixs, $_.j));
        $_.j = $_.j + 1;
      }
    }
    $_.pixs = $_.npixs;
  }
  $_.fw = ~~($_.fw / 2);
  for (var _Ja = -$_.fw, _JZ = $_.fw; _Ja <= _JZ; _Ja += 1) {
    $_.i = _Ja;
    for (var _Je = -$_.fw, _Jd = $_.fw; _Je <= _Jd; _Je += 1) {
      $_.j = _Je;
      $k[$j++] = $_.pixs;
      $k[$j++] = $_.i;
      $k[$j++] = $_.j;
      $_.cmv();
      if ($abs($_.i) > $abs($_.j)) {
        $k[$j++] = $abs($_.i);
      } else {
        $k[$j++] = $abs($_.j);
      }
      var _Jm = $k[--$j];
      var _Jn = $k[--$j];
      $put($k[--$j], _Jn, (_Jm + 1) % 2);
    }
  }
  var _KP = $a([$a([-($_.fw + 1), $_.fw, 1]), $a([-($_.fw + 1), $_.fw + 1, 1]), $a([-$_.fw, $_.fw + 1, 1]), $a([$_.fw + 1, $_.fw + 1, 1]), $a([$_.fw + 1, $_.fw, 1]), $a([$_.fw + 1, -$_.fw, 1]), $a([$_.fw, $_.fw + 1, 0]), $a([$_.fw + 1, -($_.fw + 1), 0]), $a([$_.fw, -($_.fw + 1), 0]), $a([-$_.fw, -($_.fw + 1), 0]), $a([-($_.fw + 1), -($_.fw + 1), 0]), $a([-($_.fw + 1), -$_.fw, 0])]);
  for (var _KQ = 0, _KR = _KP.length; _KQ < _KR; _KQ++) {
    $k[$j++] = $_.pixs;
    $aload($get(_KP, _KQ));
    $r(3, 1);
    $_.cmv();
    var _KU = $k[--$j];
    var _KV = $k[--$j];
    $put($k[--$j], _KU, _KV);
  }
  $_.modemapfull = $a([$a([-5, 7]), $a([-4, 7]), $a([-3, 7]), $a([-2, 7]), $a([-1, 7]), $a([1, 7]), $a([2, 7]), $a([3, 7]), $a([4, 7]), $a([5, 7]), $a([7, 5]), $a([7, 4]), $a([7, 3]), $a([7, 2]), $a([7, 1]), $a([7, -1]), $a([7, -2]), $a([7, -3]), $a([7, -4]), $a([7, -5]), $a([5, -7]), $a([4, -7]), $a([3, -7]), $a([2, -7]), $a([1, -7]), $a([-1, -7]), $a([-2, -7]), $a([-3, -7]), $a([-4, -7]), $a([-5, -7]), $a([-7, -5]), $a([-7, -4]), $a([-7, -3]), $a([-7, -2]), $a([-7, -1]), $a([-7, 1]), $a([-7, 2]), $a([-7, 3]), $a([-7, 4]), $a([-7, 5])]);
  $_.modemapcompact = $a([$a([-3, 5]), $a([-2, 5]), $a([-1, 5]), $a([0, 5]), $a([1, 5]), $a([2, 5]), $a([3, 5]), $a([5, 3]), $a([5, 2]), $a([5, 1]), $a([5, 0]), $a([5, -1]), $a([5, -2]), $a([5, -3]), $a([3, -5]), $a([2, -5]), $a([1, -5]), $a([0, -5]), $a([-1, -5]), $a([-2, -5]), $a([-3, -5]), $a([-5, -3]), $a([-5, -2]), $a([-5, -1]), $a([-5, 0]), $a([-5, 1]), $a([-5, 2]), $a([-5, 3])]);
  $k[$j++] = "modemap";
  if ($eq($_.format, "full")) {
    $k[$j++] = $_.modemapfull;
  } else {
    $k[$j++] = $_.modemapcompact;
  }
  var _Lj = $k[--$j];
  $_[$k[--$j]] = _Lj;
  for (var _Ln = 0, _Lm = $_.modemap.length - 1; _Ln <= _Lm; _Ln += 1) {
    $k[$j++] = _Ln;
    $k[$j++] = $_.pixs;
    $aload($get($_.modemap, _Ln));
    $_.cmv();
    var _Ls = $k[--$j];
    var _Lt = $k[--$j];
    $put(_Lt, _Ls, $get($_.modebits, $k[--$j]) - 48);
  }
  var _M2 = /* @__PURE__ */ new Map([
    ["ren", "renmatrix"],
    ["pixs", $_.pixs],
    ["pixx", $_.size],
    ["pixy", $_.size],
    ["height", $_.size * 2 / 72],
    ["width", $_.size * 2 / 72],
    ["opt", $_.options]
  ]);
  $k[$j++] = _M2;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_azteccodecompact() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $put($_.options, "dontdraw", true);
  $put($_.options, "format", "compact");
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_azteccode();
  var _6 = $k[--$j];
  $_[$k[--$j]] = _6;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_aztecrune() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $put($_.options, "dontdraw", true);
  $put($_.options, "format", "rune");
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_azteccode();
  var _6 = $k[--$j];
  $_[$k[--$j]] = _6;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_codeone() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.version = "unset";
  $_.parse = false;
  $_.parsefnc = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  var _2 = $a(["unset", "T-16", "T-32", "T-48", "S-10", "S-20", "S-30", "A", "B", "C", "D", "E", "F", "G", "H"]);
  $k[$j++] = false;
  for (var _3 = 0, _4 = _2.length; _3 < _4; _3++) {
    var _7 = $k[--$j];
    $k[$j++] = _7 || $eq($get(_2, _3), $_.version);
  }
  if (!$k[--$j]) {
    $k[$j++] = "bwipp.codeoneBadVersion#24394";
    $k[$j++] = "version must be A to H, T-16, T-32, T-48, S-10, S-20 or S-30";
    bwipp_raiseerror();
  }
  $_.stype = $eq($geti($_.version, 0, 1), "S");
  $_.ttype = $eq($geti($_.version, 0, 1), "T");
  $_.stypevals = $a(["1", "1010", "1100100", "1111101000", "10011100010000", "11000011010100000", "11110100001001000000", "100110001001011010000000", "101111101011110000100000000", "111011100110101100101000000000", "1001010100000010111110010000000000", "1011101001000011101101110100000000000", "1110100011010100101001010001000000000000", "10010001100001001110011100101010000000000000", "10110101111001100010000011110100100000000000000", "11100011010111111010100100110001101000000000000000", "100011100001101111001001101111110000010000000000000000", "101100011010001010111100001011101100010100000000000000000"]);
  $_.stypemetrics = $a([$a(["S-10", 8, 11, 10, 4, 4, 1, 99, 99, 99]), $a(["S-20", 8, 21, 20, 8, 8, 1, 99, 99, 99]), $a(["S-30", 8, 31, 30, 12, 12, 1, 99, 99, 99])]);
  $_.nonstypemetrics = $a([$a(["A", 16, 18, 16, 10, 10, 1, 4, 99, 6]), $a(["B", 22, 22, 20, 19, 16, 1, 4, 99, 8]), $a(["C", 28, 32, 28, 44, 26, 1, 4, 22, 11]), $a(["D", 40, 42, 36, 91, 44, 1, 4, 16, 16]), $a(["E", 52, 54, 48, 182, 70, 1, 4, 22, 22]), $a(["F", 70, 76, 68, 370, 140, 2, 4, 22, 31]), $a(["G", 104, 98, 88, 732, 280, 4, 6, 21, 47]), $a(["H", 148, 134, 120, 1480, 560, 8, 6, 20, 69]), $a(["T-16", 16, 17, 16, 10, 10, 1, 99, 99, 99]), $a(["T-32", 16, 33, 32, 24, 16, 1, 99, 99, 99]), $a(["T-48", 16, 49, 48, 38, 22, 1, 99, 99, 99])]);
  $_.fnc1 = -1;
  $_.fnc3 = -2;
  $_.lC = -5;
  $_.lB = -6;
  $_.lX = -7;
  $_.lT = -8;
  $_.lD = -9;
  $_.unl = -10;
  $_.fnc2 = -11;
  $_.fnc4 = -12;
  $_.sft1 = -13;
  $_.sft2 = -14;
  $_.sft3 = -15;
  $_.eci = -16;
  $_.pad = -17;
  $_.fnc1lD = -18;
  $_.unlcw = 255;
  $k[$j++] = Infinity;
  for (var _U = 0; _U <= 128; _U += 1) {
    $k[$j++] = _U;
    $k[$j++] = _U + 1;
  }
  $k[$j++] = $_.pad;
  $k[$j++] = 129;
  for (var _W = 0; _W <= 99; _W += 1) {
    var _Y = $cvrs($s(2), _W, 10);
    var _a = $strcpy($s(2), "00");
    $puti(_a, 2 - _Y.length, _Y);
    $k[$j++] = _a;
    $k[$j++] = _W + 130;
  }
  var _i = $a([$_.lC, $_.lB, $_.fnc1, $_.fnc2, $_.fnc3, $_.fnc4, $_.fnc1lD]);
  $k[$j++] = 229;
  for (var _j = 0, _k = _i.length; _j < _k; _j++) {
    var _n = $k[--$j] + 1;
    $k[$j++] = $get(_i, _j);
    $k[$j++] = _n;
    $k[$j++] = _n;
  }
  $k[$j - 1] = $_.lX;
  $k[$j++] = 238;
  $k[$j++] = $_.lT;
  $k[$j++] = 239;
  $_.Avals = $d();
  $k[$j++] = Infinity;
  var _r = $_.Avals;
  for (var _w = _r.size, _v = _r.keys(), _u = 0; _u < _w; _u++) {
    var _s = _v.next().value;
    $k[$j++] = _s;
    var _x = Infinity;
    var _y = _r.get(_s);
    $k[$j++] = _x;
    $k[$j++] = _y;
    var _z = $a();
    $k[$j++] = _z;
  }
  $_.Avals = $d();
  $k[$j++] = Infinity;
  $k[$j++] = $_.sft1;
  $k[$j++] = 0;
  $k[$j++] = $_.sft2;
  $k[$j++] = 1;
  $k[$j++] = $_.sft3;
  $k[$j++] = 2;
  $k[$j++] = 32;
  $k[$j++] = 3;
  for (var _14 = 48; _14 <= 57; _14 += 1) {
    $k[$j++] = _14;
    $k[$j++] = _14 - 44;
  }
  for (var _15 = 65; _15 <= 90; _15 += 1) {
    $k[$j++] = _15;
    $k[$j++] = _15 - 51;
  }
  $_.CNvals = $d();
  $k[$j++] = Infinity;
  for (var _17 = 0; _17 <= 31; _17 += 1) {
    $k[$j++] = _17;
    $k[$j++] = _17;
  }
  $_.C1vals = $d();
  $k[$j++] = Infinity;
  for (var _19 = 33; _19 <= 47; _19 += 1) {
    $k[$j++] = _19;
    $k[$j++] = _19 - 33;
  }
  for (var _1A = 58; _1A <= 64; _1A += 1) {
    $k[$j++] = _1A;
    $k[$j++] = _1A - 43;
  }
  for (var _1B = 91; _1B <= 95; _1B += 1) {
    $k[$j++] = _1B;
    $k[$j++] = _1B - 69;
  }
  $k[$j++] = $_.fnc1;
  $k[$j++] = 27;
  $k[$j++] = $_.fnc2;
  $k[$j++] = 28;
  $k[$j++] = $_.fnc3;
  $k[$j++] = 29;
  $k[$j++] = $_.fnc4;
  $k[$j++] = 30;
  $k[$j++] = $_.pad;
  $k[$j++] = 31;
  $_.C2vals = $d();
  $k[$j++] = Infinity;
  for (var _1I = 96; _1I <= 127; _1I += 1) {
    $k[$j++] = _1I;
    $k[$j++] = _1I - 96;
  }
  $_.C3vals = $d();
  $k[$j++] = Infinity;
  var _1K = $_.CNvals;
  for (var _1P = _1K.size, _1O = _1K.keys(), _1N = 0; _1N < _1P; _1N++) {
    var _1L = _1O.next().value;
    $k[$j++] = _1L;
    var _1Q = Infinity;
    var _1R = _1K.get(_1L);
    $k[$j++] = _1Q;
    $k[$j++] = _1R;
    var _1S = $a();
    $k[$j++] = _1S;
  }
  var _1T = $_.C1vals;
  for (var _1Y = _1T.size, _1X = _1T.keys(), _1W = 0; _1W < _1Y; _1W++) {
    var _1U = _1X.next().value;
    $k[$j++] = _1U;
    var _1Z = Infinity;
    var _1a = _1T.get(_1U);
    $k[$j++] = _1Z;
    $k[$j++] = $get($_.CNvals, $_.sft1);
    $k[$j++] = _1a;
    var _1e = $a();
    $k[$j++] = _1e;
  }
  var _1f = $_.C2vals;
  for (var _1k = _1f.size, _1j = _1f.keys(), _1i = 0; _1i < _1k; _1i++) {
    var _1g = _1j.next().value;
    $k[$j++] = _1g;
    var _1l = Infinity;
    var _1m = _1f.get(_1g);
    $k[$j++] = _1l;
    $k[$j++] = $get($_.CNvals, $_.sft2);
    $k[$j++] = _1m;
    var _1q = $a();
    $k[$j++] = _1q;
  }
  var _1r = $_.C3vals;
  for (var _1w = _1r.size, _1v = _1r.keys(), _1u = 0; _1u < _1w; _1u++) {
    var _1s = _1v.next().value;
    $k[$j++] = _1s;
    var _1x = Infinity;
    var _1y = _1r.get(_1s);
    $k[$j++] = _1x;
    $k[$j++] = $get($_.CNvals, $_.sft3);
    $k[$j++] = _1y;
    var _22 = $a();
    $k[$j++] = _22;
  }
  $_.Cvals = $d();
  $k[$j++] = Infinity;
  $k[$j++] = $_.sft1;
  $k[$j++] = 0;
  $k[$j++] = $_.sft2;
  $k[$j++] = 1;
  $k[$j++] = $_.sft3;
  $k[$j++] = 2;
  $k[$j++] = 32;
  $k[$j++] = 3;
  for (var _27 = 48; _27 <= 57; _27 += 1) {
    $k[$j++] = _27;
    $k[$j++] = _27 - 44;
  }
  for (var _28 = 97; _28 <= 122; _28 += 1) {
    $k[$j++] = _28;
    $k[$j++] = _28 - 83;
  }
  $_.TNvals = $d();
  $k[$j++] = Infinity;
  for (var _2A = 0; _2A <= 31; _2A += 1) {
    $k[$j++] = _2A;
    $k[$j++] = _2A;
  }
  $_.T1vals = $d();
  $k[$j++] = Infinity;
  for (var _2C = 33; _2C <= 47; _2C += 1) {
    $k[$j++] = _2C;
    $k[$j++] = _2C - 33;
  }
  for (var _2D = 58; _2D <= 64; _2D += 1) {
    $k[$j++] = _2D;
    $k[$j++] = _2D - 43;
  }
  for (var _2E = 91; _2E <= 95; _2E += 1) {
    $k[$j++] = _2E;
    $k[$j++] = _2E - 69;
  }
  $k[$j++] = $_.fnc1;
  $k[$j++] = 27;
  $k[$j++] = $_.fnc2;
  $k[$j++] = 28;
  $k[$j++] = $_.fnc3;
  $k[$j++] = 29;
  $k[$j++] = $_.fnc4;
  $k[$j++] = 30;
  $k[$j++] = $_.pad;
  $k[$j++] = 31;
  $_.T2vals = $d();
  $k[$j++] = Infinity;
  $k[$j++] = 96;
  $k[$j++] = 0;
  for (var _2L = 65; _2L <= 90; _2L += 1) {
    $k[$j++] = _2L;
    $k[$j++] = _2L - 64;
  }
  for (var _2M = 123; _2M <= 127; _2M += 1) {
    $k[$j++] = _2M;
    $k[$j++] = _2M - 96;
  }
  $_.T3vals = $d();
  $k[$j++] = Infinity;
  var _2O = $_.TNvals;
  for (var _2T = _2O.size, _2S = _2O.keys(), _2R = 0; _2R < _2T; _2R++) {
    var _2P = _2S.next().value;
    $k[$j++] = _2P;
    var _2U = Infinity;
    var _2V = _2O.get(_2P);
    $k[$j++] = _2U;
    $k[$j++] = _2V;
    var _2W = $a();
    $k[$j++] = _2W;
  }
  var _2X = $_.T1vals;
  for (var _2c = _2X.size, _2b = _2X.keys(), _2a = 0; _2a < _2c; _2a++) {
    var _2Y = _2b.next().value;
    $k[$j++] = _2Y;
    var _2d = Infinity;
    var _2e = _2X.get(_2Y);
    $k[$j++] = _2d;
    $k[$j++] = $get($_.TNvals, $_.sft1);
    $k[$j++] = _2e;
    var _2i = $a();
    $k[$j++] = _2i;
  }
  var _2j = $_.T2vals;
  for (var _2o = _2j.size, _2n = _2j.keys(), _2m = 0; _2m < _2o; _2m++) {
    var _2k = _2n.next().value;
    $k[$j++] = _2k;
    var _2p = Infinity;
    var _2q = _2j.get(_2k);
    $k[$j++] = _2p;
    $k[$j++] = $get($_.TNvals, $_.sft2);
    $k[$j++] = _2q;
    var _2u = $a();
    $k[$j++] = _2u;
  }
  var _2v = $_.T3vals;
  for (var _30 = _2v.size, _2z = _2v.keys(), _2y = 0; _2y < _30; _2y++) {
    var _2w = _2z.next().value;
    $k[$j++] = _2w;
    var _31 = Infinity;
    var _32 = _2v.get(_2w);
    $k[$j++] = _31;
    $k[$j++] = $get($_.TNvals, $_.sft3);
    $k[$j++] = _32;
    var _36 = $a();
    $k[$j++] = _36;
  }
  $_.Tvals = $d();
  for (var _38 = 128; _38 <= 255; _38 += 1) {
    $_.i = _38;
    $k[$j++] = $_.Avals;
    $k[$j++] = $_.i;
    $k[$j++] = Infinity;
    $aload($get($_.Avals, $_.fnc4));
    $aload($get($_.Avals, $_.i - 128));
    var _3H = $a();
    var _3I = $k[--$j];
    $put($k[--$j], _3I, _3H);
    $k[$j++] = $_.Cvals;
    $k[$j++] = $_.i;
    $k[$j++] = Infinity;
    $aload($get($_.Cvals, $_.fnc4));
    $aload($get($_.Cvals, $_.i - 128));
    var _3S = $a();
    var _3T = $k[--$j];
    $put($k[--$j], _3T, _3S);
    $k[$j++] = $_.Tvals;
    $k[$j++] = $_.i;
    $k[$j++] = Infinity;
    $aload($get($_.Tvals, $_.fnc4));
    $aload($get($_.Tvals, $_.i - 128));
    var _3d = $a();
    var _3e = $k[--$j];
    $put($k[--$j], _3e, _3d);
  }
  $k[$j++] = Infinity;
  $k[$j++] = 13;
  $k[$j++] = 0;
  $k[$j++] = 42;
  $k[$j++] = 1;
  $k[$j++] = 62;
  $k[$j++] = 2;
  $k[$j++] = 32;
  $k[$j++] = 3;
  for (var _3g = 48; _3g <= 57; _3g += 1) {
    $k[$j++] = _3g;
    $k[$j++] = _3g - 44;
  }
  for (var _3h = 65; _3h <= 90; _3h += 1) {
    $k[$j++] = _3h;
    $k[$j++] = _3h - 51;
  }
  $_.Xvals = $d();
  $k[$j++] = Infinity;
  var _3j = $_.Xvals;
  for (var _3o = _3j.size, _3n = _3j.keys(), _3m = 0; _3m < _3o; _3m++) {
    var _3k = _3n.next().value;
    $k[$j++] = _3k;
    var _3p = Infinity;
    var _3q = _3j.get(_3k);
    $k[$j++] = _3p;
    $k[$j++] = _3q;
    var _3r = $a();
    $k[$j++] = _3r;
  }
  $_.Xvals = $d();
  $k[$j++] = Infinity;
  for (var _3t = 0; _3t <= 255; _3t += 1) {
    $k[$j++] = _3t;
    $k[$j++] = _3t;
  }
  $_.Bvals = $d();
  $k[$j++] = Infinity;
  var _3v = $_.Bvals;
  for (var _40 = _3v.size, _3z = _3v.keys(), _3y = 0; _3y < _40; _3y++) {
    var _3w = _3z.next().value;
    $k[$j++] = _3w;
    var _41 = Infinity;
    var _42 = _3v.get(_3w);
    $k[$j++] = _41;
    $k[$j++] = _42;
    var _43 = $a();
    $k[$j++] = _43;
  }
  $_.Bvals = $d();
  $_.encvals = $a([$_.Avals, $_.Cvals, $_.Tvals, $_.Xvals, -1, $_.Bvals]);
  $_.A = 0;
  $_.C = 1;
  $_.T = 2;
  $_.X = 3;
  $_.D = 4;
  $_.B = 5;
  if ($_.stype) {
    $forall($_.barcode, function() {
      var _4E = $k[--$j];
      if (_4E < 48 || _4E > 57) {
        $k[$j++] = "bwipp.codeoneStypeNonDigit#24564";
        $k[$j++] = "S-Type symbols can only contain digits";
        bwipp_raiseerror();
      }
    });
    $_.barlen = $_.barcode.length;
    if ($_.barlen > 18) {
      $k[$j++] = "bwipp.codeoneStypeTooLong#24570";
      $k[$j++] = "Maximum length exceeded";
      bwipp_raiseerror();
    }
    $_.normalize = function() {
      $_.base = $k[--$j];
      $_.num = $k[--$j];
      for (var _4K = $_.num.length - 1; _4K >= 1; _4K -= 1) {
        $_.i = _4K;
        var _4L = $_.num;
        var _4M = $_.i;
        $put(_4L, _4M - 1, $f($get(_4L, _4M - 1) + ~~($get($_.num, $_.i) / $_.base)));
        $put($_.num, $_.i, $get($_.num, $_.i) % $_.base);
      }
      for (; ; ) {
        if ($lt($get($_.num, 0), $_.base)) {
          break;
        }
        $k[$j++] = Infinity;
        $k[$j++] = 0;
        $aload($_.num);
        $_.num = $a();
        $put($_.num, 0, $f($get($_.num, 0) + ~~($get($_.num, 1) / $_.base)));
        $put($_.num, 1, $get($_.num, 1) % $_.base);
      }
      $k[$j++] = Infinity;
      $_.i = true;
      var _4n = $_.num;
      for (var _4o = 0, _4p = _4n.length; _4o < _4p; _4o++) {
        var _4q = $get(_4n, _4o);
        $k[$j++] = _4q;
        if (_4q == 0 && $_.i) {
          $j--;
        } else {
          $_.i = false;
        }
      }
      $_.num = $a();
      if ($_.num.length == 0) {
        $_.num = $a([0]);
      }
      $k[$j++] = $_.num;
    };
    $_.bigadd = function() {
      var _4w = $k[--$j];
      var _4x = $k[--$j];
      $_.offset = $abs(_4w.length - _4x.length);
      if (_4w.length < _4x.length) {
        var _ = _4w;
        _4w = _4x;
        _4x = _;
      }
      $_.a = _4w;
      $_.b = _4x;
      for (var _50 = 0, _4z = $_.b.length - 1; _50 <= _4z; _50 += 1) {
        var _51 = $_.a;
        var _52 = $_.offset;
        $put(_51, _50 + _52, $f($get(_51, _50 + _52) + $get($_.b, _50)));
      }
      $k[$j++] = $_.a;
    };
    $_.barlen = $_.barcode.length;
    $_.v = $a([1]);
    for (var _5B = 0, _5A = $_.barlen - 1; _5B <= _5A; _5B += 1) {
      $_.i = _5B;
      $k[$j++] = Infinity;
      $forall($get($_.stypevals, $_.i), function() {
        var _5F = $k[--$j];
        $k[$j++] = (_5F - 48) * ($get($_.barcode, $_.barlen - $_.i - 1) - 48);
      });
      var _5K = $a();
      $k[$j++] = _5K;
      $k[$j++] = $_.v;
      $_.bigadd();
      $_.v = $k[--$j];
    }
    $k[$j++] = "v";
    $k[$j++] = $_.v;
    $k[$j++] = 2;
    $_.normalize();
    var _5O = $k[--$j];
    $_[$k[--$j]] = _5O;
    $k[$j++] = Infinity;
    for (var _5R = 0, _5S = (5 - $_.v.length % 5) % 5; _5R < _5S; _5R++) {
      $k[$j++] = 0;
    }
    $aload($_.v);
    $_.v = $a();
    $_.cws = $a(~~($_.v.length / 5));
    for (var _5Z = 0, _5Y = $_.cws.length - 1; _5Z <= _5Y; _5Z += 1) {
      $_.i = _5Z;
      var _5c = $geti($_.v, $_.i * 5, 5);
      $k[$j++] = 0;
      for (var _5d = 0, _5e = _5c.length; _5d < _5e; _5d++) {
        var _5g = $k[--$j];
        $k[$j++] = $f(_5g + $get(_5c, _5d)) * 2;
      }
      $put($_.cws, $_.i, ~~($k[--$j] / 2));
    }
    $_.metrics = $_.stypemetrics;
  } else {
    var _5p = /* @__PURE__ */ new Map([
      ["parse", $_.parse],
      ["parsefnc", $_.parsefnc],
      ["eci", true],
      ["FNC1", $_.fnc1],
      ["FNC3", $_.fnc3]
    ]);
    $_.fncvals = _5p;
    $k[$j++] = "msg";
    $k[$j++] = $_.barcode;
    $k[$j++] = $_.fncvals;
    bwipp_parseinput();
    var _5s = $k[--$j];
    $_[$k[--$j]] = _5s;
    $_.msglen = $_.msg.length;
    $_.eciesc = 92;
    var _5v = $_.msg;
    $k[$j++] = "numecis";
    $k[$j++] = 0;
    for (var _5w = 0, _5x = _5v.length; _5w < _5x; _5w++) {
      if ($get(_5v, _5w) <= -1e6) {
        var _5z = $k[--$j];
        $k[$j++] = _5z + 1;
      }
    }
    var _60 = $k[--$j];
    $_[$k[--$j]] = _60;
    if ($_.numecis > 0) {
      $_.msgtmp = $a($f($_.msg.length * 2 + $_.numecis * 6) + 2);
      $put($_.msgtmp, 0, $_.pad);
      $put($_.msgtmp, 1, $_.eciesc);
      $_.j = 2;
      for (var _6C = 0, _6B = $_.msg.length - 1; _6C <= _6B; _6C += 1) {
        var _6E = $get($_.msg, _6C);
        $k[$j++] = _6E;
        if (_6E <= -1e6) {
          var _6I = $geti($cvrs($s(7), -$k[--$j], 10), 1, 6);
          for (var _6J = 0, _6K = _6I.length; _6J < _6K; _6J++) {
            $k[$j++] = $get(_6I, _6J);
          }
          $astore($a(6));
          $puti($_.msgtmp, $_.j + 1, $k[--$j]);
          $put($_.msgtmp, $_.j, $_.eciesc);
          $_.j = $_.j + 7;
        } else {
          var _6U = $k[$j - 1];
          if (_6U != $_.eciesc) {
            $put($_.msgtmp, $_.j, $k[--$j]);
            $_.j = $_.j + 1;
          } else {
            $j--;
            $put($_.msgtmp, $_.j, $_.eciesc);
            $put($_.msgtmp, $_.j + 1, $_.eciesc);
            $_.j = $_.j + 2;
          }
        }
      }
      $_.msg = $geti($_.msgtmp, 0, $_.j);
      $_.msglen = $_.msg.length;
    }
    $_.metrics = $_.nonstypemetrics;
    $_.fullcws = $a([]);
    var _6n = $_.metrics;
    for (var _6o = 0, _6p = _6n.length; _6o < _6p; _6o++) {
      $_.m = $get(_6n, _6o);
      $_.vers = $get($_.m, 0);
      $_.dcws = $get($_.m, 4);
      $_.okay = true;
      if ($eq($_.version, "unset")) {
        if ($_.vers.length != 1) {
          $_.okay = false;
        }
      } else {
        if ($ne($_.version, $_.vers)) {
          $_.okay = false;
        }
      }
      if ($_.okay) {
        $k[$j++] = Infinity;
        $aload($_.fullcws);
        $k[$j++] = $_.dcws;
        $_.fullcws = $a();
      }
    }
    $k[$j++] = Infinity;
    for (var _73 = 0; _73 < 1480; _73++) {
      $k[$j++] = 1e4;
    }
    $_.numremcws = $a();
    var _75 = $_.fullcws;
    for (var _76 = 0, _77 = _75.length; _76 < _77; _76++) {
      $put($_.numremcws, $get(_75, _76) - 1, 1);
    }
    for (var _7A = 1478; _7A >= 0; _7A -= 1) {
      $_.i = _7A;
      if ($get($_.numremcws, $_.i) != 1) {
        $put($_.numremcws, $_.i, $get($_.numremcws, $_.i + 1) + 1);
      }
    }
    $k[$j++] = Infinity;
    for (var _7K = 0, _7L = $_.msglen; _7K < _7L; _7K++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $_.numD = $a();
    $k[$j++] = Infinity;
    for (var _7O = 0, _7P = $_.msglen; _7O < _7P; _7O++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 9999;
    $_.nextXterm = $a();
    $k[$j++] = Infinity;
    for (var _7S = 0, _7T = $_.msglen; _7S < _7T; _7S++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 9999;
    $_.nextNonX = $a();
    for (var _7W = $_.msglen - 1; _7W >= 0; _7W -= 1) {
      $_.i = _7W;
      $_.barchar = $get($_.msg, $_.i);
      if ($_.barchar >= 48 && $_.barchar <= 57) {
        $put($_.numD, $_.i, $get($_.numD, $_.i + 1) + 1);
      }
      if ($_.barchar == 13 || $_.barchar == 42 || $_.barchar == 62) {
        $put($_.nextXterm, $_.i, 0);
      } else {
        $put($_.nextXterm, $_.i, $get($_.nextXterm, $_.i + 1) + 1);
      }
      var _7t = $get($_.Xvals, $_.barchar) !== void 0;
      if (!_7t) {
        $put($_.nextNonX, $_.i, 0);
      } else {
        $put($_.nextNonX, $_.i, $get($_.nextNonX, $_.i + 1) + 1);
      }
    }
    $k[$j++] = Infinity;
    var _81 = $_.nextXterm;
    for (var _82 = 0, _83 = _81.length; _82 < _83; _82++) {
      var _84 = $get(_81, _82);
      $k[$j++] = _84;
      if (_84 > 1e4) {
        $k[$j - 1] = 1e4;
      }
    }
    $_.nextXterm = $a();
    $k[$j++] = Infinity;
    var _86 = $_.nextNonX;
    for (var _87 = 0, _88 = _86.length; _87 < _88; _87++) {
      var _89 = $get(_86, _87);
      $k[$j++] = _89;
      if (_89 > 1e4) {
        $k[$j - 1] = 1e4;
      }
    }
    $_.nextNonX = $a();
    $_.isD = function() {
      $k[$j++] = $_.char >= 48 && $_.char <= 57;
    };
    $_.isC = function() {
      var _8F = $get($_.CNvals, $_.char) !== void 0;
      $k[$j++] = _8F;
    };
    $_.isT = function() {
      var _8I = $get($_.TNvals, $_.char) !== void 0;
      $k[$j++] = _8I;
    };
    $_.isX = function() {
      var _8L = $get($_.Xvals, $_.char) !== void 0;
      $k[$j++] = _8L;
    };
    $_.isEA = function() {
      $k[$j++] = $_.char > 127;
    };
    $_.isFN = function() {
      $k[$j++] = $_.char < 0;
    };
    $_.XtermFirst = function() {
      var _8O = $k[--$j];
      $k[$j++] = $lt($get($_.nextXterm, _8O), $get($_.nextNonX, _8O));
    };
    $_.lookup = function() {
      $_.ac = 1;
      $_.cc = 2;
      $_.tc = 2;
      $_.xc = 2;
      $_.bc = 3;
      if ($_.mode == $_.A) {
        $_.ac = 0;
        $_.cc = 1;
        $_.tc = 1;
        $_.xc = 1;
        $_.bc = 2;
      }
      if ($_.mode == $_.C) {
        $_.cc = 0;
      }
      if ($_.mode == $_.T) {
        $_.tc = 0;
      }
      if ($_.mode == $_.X) {
        $_.xc = 0;
      }
      if ($_.mode == $_.B) {
        $_.bc = 0;
      }
      for (var _8d = 0; _8d < 1; _8d++) {
        $_.k = 0;
        for (; ; ) {
          if ($_.i + $_.k == $_.msglen) {
            var _8l = $a([$_.ac, $_.cc, $_.tc, $_.xc]);
            $k[$j++] = true;
            for (var _8m = 0, _8n = _8l.length; _8m < _8n; _8m++) {
              var _8q = $k[--$j];
              $k[$j++] = _8q && $_.bc <= $ceil($get(_8l, _8m));
            }
            if ($k[--$j]) {
              $k[$j++] = $_.B;
              break;
            }
            var _8x = $a([$_.cc, $_.tc, $_.xc, $_.bc]);
            $k[$j++] = true;
            for (var _8y = 0, _8z = _8x.length; _8y < _8z; _8y++) {
              var _92 = $k[--$j];
              $k[$j++] = _92 && $_.ac <= $ceil($get(_8x, _8y));
            }
            if ($k[--$j]) {
              $k[$j++] = $_.A;
              break;
            }
            var _97 = $a([$_.tc, $_.xc]);
            $k[$j++] = true;
            for (var _98 = 0, _99 = _97.length; _98 < _99; _98++) {
              var _9C = $k[--$j];
              $k[$j++] = _9C && $ceil($_.cc) <= $ceil($get(_97, _98));
            }
            if ($k[--$j]) {
              $k[$j++] = $_.C;
              break;
            }
            var _9G = $a([$_.xc]);
            $k[$j++] = true;
            for (var _9H = 0, _9I = _9G.length; _9H < _9I; _9H++) {
              var _9L = $k[--$j];
              $k[$j++] = _9L && $ceil($_.tc) <= $ceil($get(_9G, _9H));
            }
            if ($k[--$j]) {
              $k[$j++] = $_.T;
              break;
            }
            $k[$j++] = $_.X;
            break;
          }
          $_.char = $get($_.msg, $_.i + $_.k);
          $k[$j++] = "ac";
          $k[$j++] = $_.ac;
          $_.isD();
          if ($k[--$j]) {
            var _9V = $k[--$j];
            $k[$j++] = $f(_9V + 1 / 2);
          } else {
            $_.isEA();
            if ($k[--$j]) {
              var _9X = $k[--$j];
              $k[$j++] = $ceil(_9X) + 2;
            } else {
              var _9Y = $k[--$j];
              $k[$j++] = $ceil(_9Y) + 1;
            }
          }
          var _9Z = $k[--$j];
          $_[$k[--$j]] = _9Z;
          $k[$j++] = "cc";
          $k[$j++] = $_.cc;
          $_.isC();
          if ($k[--$j]) {
            var _9d = $k[--$j];
            $k[$j++] = $f(_9d + 0.6666667);
          } else {
            $_.isEA();
            if ($k[--$j]) {
              var _9f = $k[--$j];
              $k[$j++] = $f(_9f + 2.6666667);
            } else {
              var _9g = $k[--$j];
              $k[$j++] = $f(_9g + 1.3333334);
            }
          }
          var _9h = $k[--$j];
          $_[$k[--$j]] = _9h;
          $k[$j++] = "tc";
          $k[$j++] = $_.tc;
          $_.isT();
          if ($k[--$j]) {
            var _9l = $k[--$j];
            $k[$j++] = $f(_9l + 0.6666667);
          } else {
            $_.isEA();
            if ($k[--$j]) {
              var _9n = $k[--$j];
              $k[$j++] = $f(_9n + 2.6666667);
            } else {
              var _9o = $k[--$j];
              $k[$j++] = $f(_9o + 1.3333334);
            }
          }
          var _9p = $k[--$j];
          $_[$k[--$j]] = _9p;
          $k[$j++] = "xc";
          $k[$j++] = $_.xc;
          $_.isX();
          if ($k[--$j]) {
            var _9t = $k[--$j];
            $k[$j++] = $f(_9t + 0.6666667);
          } else {
            $_.isEA();
            if ($k[--$j]) {
              var _9v = $k[--$j];
              $k[$j++] = $f(_9v + 4.3333334);
            } else {
              var _9w = $k[--$j];
              $k[$j++] = $f(_9w + 3.3333334);
            }
          }
          var _9x = $k[--$j];
          $_[$k[--$j]] = _9x;
          $k[$j++] = "bc";
          $k[$j++] = $_.bc;
          $_.isFN();
          if ($k[--$j]) {
            var _A1 = $k[--$j];
            $k[$j++] = _A1 + 3;
          } else {
            var _A2 = $k[--$j];
            $k[$j++] = _A2 + 1;
          }
          var _A3 = $k[--$j];
          $_[$k[--$j]] = _A3;
          if ($_.k >= 3) {
            var _AA = $a([$_.ac, $_.cc, $_.tc, $_.xc]);
            $k[$j++] = true;
            for (var _AB = 0, _AC = _AA.length; _AB < _AC; _AB++) {
              var _AF = $k[--$j];
              $k[$j++] = _AF && $_.bc + 1 <= $ceil($get(_AA, _AB));
            }
            if ($k[--$j]) {
              $k[$j++] = $_.B;
              break;
            }
            var _AM = $a([$_.cc, $_.tc, $_.xc, $_.bc]);
            $k[$j++] = true;
            for (var _AN = 0, _AO = _AM.length; _AN < _AO; _AN++) {
              var _AR = $k[--$j];
              $k[$j++] = _AR && $_.ac + 1 <= $ceil($get(_AM, _AN));
            }
            if ($k[--$j]) {
              $k[$j++] = $_.A;
              break;
            }
            var _AY = $a([$_.ac, $_.cc, $_.xc, $_.bc]);
            $k[$j++] = true;
            for (var _AZ = 0, _Aa = _AY.length; _AZ < _Aa; _AZ++) {
              var _Ad = $k[--$j];
              $k[$j++] = _Ad && $ceil($_.tc) + 1 <= $ceil($get(_AY, _AZ));
            }
            if ($k[--$j]) {
              $k[$j++] = $_.T;
              break;
            }
            var _Ai = $a([$_.ac, $_.tc]);
            $k[$j++] = true;
            for (var _Aj = 0, _Ak = _Ai.length; _Aj < _Ak; _Aj++) {
              var _An = $k[--$j];
              $k[$j++] = _An && $ceil($_.cc) + 1 <= $ceil($get(_Ai, _Aj));
            }
            if ($k[--$j]) {
              if ($ceil($_.cc) < $ceil($_.xc)) {
                $k[$j++] = $_.C;
                break;
              }
              if ($_.cc == $_.xc) {
                $k[$j++] = $_.i + $_.k + 1;
                $_.XtermFirst();
                if ($k[--$j]) {
                  $k[$j++] = $_.X;
                  break;
                } else {
                  $k[$j++] = $_.C;
                  break;
                }
              }
            }
            var _B3 = $a([$_.ac, $_.cc, $_.tc, $_.bc]);
            $k[$j++] = true;
            for (var _B4 = 0, _B5 = _B3.length; _B4 < _B5; _B4++) {
              var _B8 = $k[--$j];
              $k[$j++] = _B8 && $ceil($_.xc) + 1 <= $ceil($get(_B3, _B4));
            }
            if ($k[--$j]) {
              $k[$j++] = $_.X;
              break;
            }
          }
          $_.k = $_.k + 1;
        }
      }
    };
    $_.addtocws = function() {
      var _BC = $k[$j - 1];
      if (_BC.length + $_.j > 1480) {
        $j--;
        $k[$j++] = "bwipp.codeoneTooLong#24766";
        $k[$j++] = "Maximum length exceeded";
        bwipp_raiseerror();
      }
      var _BE = $k[--$j];
      $puti($_.cws, $_.j, _BE);
      $_.j = _BE.length + $_.j;
    };
    $_.tobin = function() {
      var _BJ = $s($k[--$j]);
      $k[$j++] = _BJ;
      for (var _BL = 0, _BK = _BJ.length - 1; _BL <= _BK; _BL += 1) {
        var _BM = $k[$j - 1];
        $put(_BM, _BL, 48);
      }
      var _BN = $k[$j - 1];
      $k[$j++] = _BN;
      var _BO = $k[$j - 3];
      var _BP = $k[$j - 1];
      $k[$j - 3] = $k[$j - 2];
      $j -= 2;
      var _BR = $cvrs($s(_BP.length), _BO, 2);
      $puti(_BP, _BP.length - _BR.length, _BR);
      $k[$j++] = Infinity;
      var _BS = $k[--$j];
      var _BT = $k[--$j];
      $k[$j++] = _BS;
      $forall(_BT, function() {
        var _BU = $k[--$j];
        $k[$j++] = _BU - 48;
      });
      var _BV = $a();
      $k[$j++] = _BV;
    };
    $_.encA = function() {
      for (var _BW = 0; _BW < 1; _BW++) {
        if ($get($_.numD, $_.i) >= 21) {
          $_.Dbits = $a([1, 1, 1, 1]);
          $_.mode = $_.D;
          break;
        }
        var _Be = $get($_.numD, $_.i);
        if (_Be >= 13 && $f(_Be + $_.i) == $_.msglen) {
          $_.Dbits = $a([1, 1, 1, 1]);
          $_.mode = $_.D;
          break;
        }
        if ($get($_.numD, $_.i) >= 2) {
          var _Bm = $s(2);
          $put(_Bm, 0, $get($_.msg, $_.i));
          $put(_Bm, 1, $get($_.msg, $_.i + 1));
          $k[$j++] = $get($_.Avals, _Bm);
          $_.addtocws();
          $_.i = $_.i + 2;
          break;
        }
        if ($get($_.msg, $_.i) == $_.fnc1) {
          if ($get($_.numD, $_.i + 1) >= 15) {
            $k[$j++] = $get($_.Avals, $_.fnc1lD);
            $_.addtocws();
            $_.i = $_.i + 1;
            $_.Dbits = $a([]);
            $_.mode = $_.D;
            break;
          }
          var _CB = $get($_.numD, $_.i + 1);
          if (_CB >= 7 && $f(_CB + $_.i) + 1 == $_.msglen) {
            $k[$j++] = $get($_.Avals, $_.fnc1lD);
            $_.addtocws();
            $_.i = $_.i + 1;
            $_.Dbits = $a([]);
            $_.mode = $_.D;
            break;
          }
        }
        $k[$j++] = "newmode";
        $_.lookup();
        var _CK = $k[--$j];
        $_[$k[--$j]] = _CK;
        if ($_.newmode != $_.mode) {
          $k[$j++] = $get($_.Avals, $get($a([-1, $_.lC, $_.lT, $_.lX, $_.lD, $_.lB]), $_.newmode));
          $_.addtocws();
          $_.mode = $_.newmode;
          break;
        }
        $k[$j++] = $get($_.Avals, $get($_.msg, $_.i));
        $_.addtocws();
        $_.i = $_.i + 1;
        break;
      }
    };
    $_.CTXvalstocws = function() {
      $_.in = $k[--$j];
      $k[$j++] = Infinity;
      for (var _Ci = 0, _Ch = $_.in.length - 1; _Ci <= _Ch; _Ci += 3) {
        var _Ck = $geti($_.in, _Ci, 3);
        $k[$j++] = 0;
        for (var _Cl = 0, _Cm = _Ck.length; _Cl < _Cm; _Cl++) {
          var _Co = $k[--$j];
          $k[$j++] = $f(_Co + $get(_Ck, _Cl)) * 40;
        }
        var _Cq = ~~($k[--$j] / 40) + 1;
        $k[$j++] = ~~(_Cq / 256);
        $k[$j++] = _Cq % 256;
      }
      $astore($a($counttomark()));
      var _Ct = $k[--$j];
      $k[$j - 1] = _Ct;
    };
    $_.encCTX = function() {
      $_.p = 0;
      $_.ctxvals = $a(2220);
      for (; ; ) {
        if ($_.i == $_.msglen) {
          break;
        }
        if ($_.p % 3 == 0) {
          if ($get($_.numD, $_.i) >= 12) {
            $k[$j++] = $geti($_.ctxvals, 0, $_.p);
            $_.CTXvalstocws();
            $_.addtocws();
            $k[$j++] = $a([$_.unlcw]);
            $_.addtocws();
            $_.mode = $_.A;
            break;
          }
          var _DA = $get($_.numD, $_.i);
          if (_DA >= 8 && $f(_DA + $_.i) == $_.msglen) {
            $k[$j++] = $geti($_.ctxvals, 0, $_.p);
            $_.CTXvalstocws();
            $_.addtocws();
            $k[$j++] = $a([$_.unlcw]);
            $_.addtocws();
            $_.mode = $_.A;
            break;
          }
          if ($_.mode == $_.X) {
            var _DP = $get($_.Xvals, $get($_.msg, $_.i)) !== void 0;
            if (!_DP) {
              $k[$j++] = $geti($_.ctxvals, 0, $_.p);
              $_.CTXvalstocws();
              $_.addtocws();
              if ($get($_.numremcws, $_.j) != 1 || $get($_.msg, $_.i) > 127) {
                $k[$j++] = $a([$_.unlcw]);
                $_.addtocws();
              }
              $_.mode = $_.A;
              break;
            }
            if ($_.i + 1 < $_.msglen) {
              var _Di = $get($_.Xvals, $get($_.msg, $_.i + 1)) !== void 0;
              if (!_Di) {
                break;
              }
              if ($_.i + 2 < $_.msglen) {
                var _Dp = $get($_.Xvals, $get($_.msg, $_.i + 2)) !== void 0;
                if (!_Dp) {
                  break;
                }
              }
            }
          } else {
            $_.lookup();
            if ($k[--$j] != $_.mode) {
              $k[$j++] = $geti($_.ctxvals, 0, $_.p);
              $_.CTXvalstocws();
              $_.addtocws();
              $k[$j++] = $a([$_.unlcw]);
              $_.addtocws();
              $_.mode = $_.A;
              break;
            }
          }
          if ($_.msglen - $_.i <= 3) {
            $_.remcws = $get($_.numremcws, $_.j + ~~($_.p / 3) * 2);
            $k[$j++] = Infinity;
            var _E8 = $geti($_.msg, $_.i, $_.msglen - $_.i);
            for (var _E9 = 0, _EA = _E8.length; _E9 < _EA; _E9++) {
              var _EB = $get(_E8, _E9);
              var _EF = $get($get($_.encvals, $_.mode), _EB) !== void 0;
              $k[$j++] = _EB;
              if (_EF) {
                $aload($get($get($_.encvals, $_.mode), $k[--$j]));
              } else {
                $k[$j - 1] = -1;
                $k[$j++] = -1;
                $k[$j++] = -1;
                $k[$j++] = -1;
              }
            }
            $_.remvals = $a();
            if ($_.remcws == 2 && $_.remvals.length == 3) {
              $k[$j++] = Infinity;
              $aload($geti($_.ctxvals, 0, $_.p));
              $aload($_.remvals);
              var _ES = $a();
              $k[$j++] = _ES;
              $_.CTXvalstocws();
              $_.addtocws();
              $_.mode = $_.A;
              $_.i = $_.msglen;
              break;
            }
            if ($_.remcws == 2 && $_.remvals.length == 2 && $_.mode != $_.X) {
              $k[$j++] = Infinity;
              $aload($geti($_.ctxvals, 0, $_.p));
              $aload($_.remvals);
              $aload($get($get($_.encvals, $_.mode), $_.sft1));
              var _Ei = $a();
              $k[$j++] = _Ei;
              $_.CTXvalstocws();
              $_.addtocws();
              $_.mode = $_.A;
              $_.i = $_.msglen;
              break;
            }
            if ($_.remcws == 2 && $_.remvals.length == 1) {
              $k[$j++] = $geti($_.ctxvals, 0, $_.p);
              $_.CTXvalstocws();
              $_.addtocws();
              $k[$j++] = $a([$_.unlcw]);
              $_.addtocws();
              $k[$j++] = $get($_.Avals, $get($_.msg, $_.i));
              $_.addtocws();
              $_.mode = $_.A;
              $_.i = $_.msglen;
              break;
            }
            if ($_.remcws == 1 && $_.remvals.length == 1) {
              $k[$j++] = $geti($_.ctxvals, 0, $_.p);
              $_.CTXvalstocws();
              $_.addtocws();
              $k[$j++] = $get($_.Avals, $get($_.msg, $_.i));
              $_.addtocws();
              $_.mode = $_.A;
              $_.i = $_.msglen;
              break;
            }
          }
        }
        var _FH = $get($get($_.encvals, $_.mode), $get($_.msg, $_.i));
        $puti($_.ctxvals, $_.p, _FH);
        $_.p = _FH.length + $_.p;
        $_.i = $_.i + 1;
      }
      if ($_.mode != $_.A) {
        for (; ; ) {
          if ($_.p % 3 == 0) {
            break;
          }
          $_.i = $_.i - 1;
          $_.p = $_.p - $get($get($_.encvals, $_.mode), $get($_.msg, $_.i)).length;
        }
        $k[$j++] = Infinity;
        $aload($geti($_.ctxvals, 0, $_.p));
        var _Fb = $a();
        $k[$j++] = _Fb;
        $_.CTXvalstocws();
        $_.addtocws();
        $k[$j++] = $a([$_.unlcw]);
        $_.addtocws();
        $_.mode = $_.A;
        if ($_.i != $_.msglen) {
          if ($get($_.numD, $_.i) >= 2) {
            var _Fk = $s(2);
            $put(_Fk, 0, $get($_.msg, $_.i));
            $put(_Fk, 1, $get($_.msg, $_.i + 1));
            $k[$j++] = $get($_.Avals, _Fk);
            $_.addtocws();
            $_.i = $_.i + 2;
          } else {
            $k[$j++] = $get($_.Avals, $get($_.msg, $_.i));
            $_.addtocws();
            $_.i = $_.i + 1;
          }
        }
      }
    };
    $_.encD = function() {
      for (; ; ) {
        if ($get($_.numD, $_.i) < 3) {
          $_.Drem = (8 - $_.Dbits.length % 8) % 8;
          $_.remcws = $get($_.numremcws, $_.j + ~~($_.Dbits.length / 8));
          if (($get($_.numremcws, $_.j + ~~($_.Dbits.length / 8) - 1) - 1 == 0 && $_.Drem == 0 || $_.remcws == 1 && $_.Drem != 0) && $_.i == $_.msglen) {
            if ($_.Drem == 4 || $_.Drem == 6) {
              $k[$j++] = Infinity;
              $aload($_.Dbits);
              $k[$j++] = 1;
              $k[$j++] = 1;
              $k[$j++] = 1;
              $k[$j++] = 1;
              $_.Dbits = $a();
            }
            if ($_.Drem == 2 || $_.Drem == 6) {
              $k[$j++] = Infinity;
              $aload($_.Dbits);
              $k[$j++] = 0;
              $k[$j++] = 1;
              $_.Dbits = $a();
            }
            break;
          }
          if (($_.i == $_.msglen - 1 && $get($_.numD, $_.i) == 1 || $_.i == $_.msglen - 2 && $get($_.numD, $_.i) == 2) && $_.remcws == 1 && $_.Drem == 0) {
            break;
          }
          if (!($_.i == $_.msglen - 1 && $get($_.numD, $_.i) == 1 && $_.remcws == 1 && ($_.Drem == 4 || $_.Drem == 6))) {
            $k[$j++] = Infinity;
            $aload($_.Dbits);
            $k[$j++] = 1;
            $k[$j++] = 1;
            $k[$j++] = 1;
            $k[$j++] = 1;
            $k[$j++] = 1;
            $k[$j++] = 1;
            $_.Dbits = $a();
            $_.Drem = (8 - $_.Dbits.length % 8) % 8;
          }
          if ($_.Drem == 4 || $_.Drem == 6) {
            if ($get($_.numD, $_.i) >= 1) {
              $k[$j++] = Infinity;
              $aload($_.Dbits);
              $k[$j++] = $get($_.msg, $_.i) - 48 + 1;
              $k[$j++] = 4;
              $_.tobin();
              $aload($k[--$j]);
              $_.Dbits = $a();
              $_.i = $_.i + 1;
            } else {
              $k[$j++] = Infinity;
              $aload($_.Dbits);
              $k[$j++] = 1;
              $k[$j++] = 1;
              $k[$j++] = 1;
              $k[$j++] = 1;
              $_.Dbits = $a();
            }
            $_.Drem = $_.Drem - 4;
          }
          if ($_.Drem == 2) {
            $k[$j++] = Infinity;
            $aload($_.Dbits);
            $k[$j++] = 0;
            $k[$j++] = 1;
            $_.Dbits = $a();
            $_.Drem = 0;
          }
          break;
        }
        $k[$j++] = Infinity;
        $aload($_.Dbits);
        var _H7 = $geti($_.msg, $_.i, 3);
        $k[$j++] = 0;
        for (var _H8 = 0, _H9 = _H7.length; _H8 < _H9; _H8++) {
          var _HB = $k[--$j];
          $k[$j++] = $f(_HB + ($get(_H7, _H8) - 48)) * 10;
        }
        var _HC = $k[--$j];
        $k[$j++] = ~~(_HC / 10) + 1;
        $k[$j++] = 10;
        $_.tobin();
        $aload($k[--$j]);
        $_.Dbits = $a();
        $_.i = $_.i + 3;
      }
      $k[$j++] = Infinity;
      for (var _HI = 0, _HH = $_.Dbits.length - 1; _HI <= _HH; _HI += 8) {
        var _HK = $geti($_.Dbits, _HI, 8);
        $k[$j++] = 0;
        for (var _HL = 0, _HM = _HK.length; _HL < _HM; _HL++) {
          var _HO = $k[--$j];
          $k[$j++] = $f(_HO + $get(_HK, _HL)) * 2;
        }
        var _HP = $k[--$j];
        $k[$j++] = ~~(_HP / 2);
      }
      $astore($a($counttomark()));
      var _HS = $k[--$j];
      $k[$j - 1] = _HS;
      $_.addtocws();
      $_.mode = $_.A;
    };
    $_.encB = function() {
      $_.p = 0;
      $_.bvals = $a(1480);
      for (; ; ) {
        if ($_.i == $_.msglen) {
          break;
        }
        if ($get($_.msg, $_.i) < 0) {
          break;
        }
        $_.lookup();
        if ($k[--$j] != $_.mode) {
          break;
        }
        $put($_.bvals, $_.p, $get($_.msg, $_.i));
        $_.p = $_.p + 1;
        $_.i = $_.i + 1;
      }
      $_.remcws = $get($_.numremcws, $_.j + $_.p) - 1;
      $k[$j++] = Infinity;
      if ($_.remcws == 0 && $_.i == $_.msglen) {
        $k[$j++] = 0;
      } else {
        if ($_.p < 250) {
          $k[$j++] = $_.p;
        } else {
          $k[$j++] = ~~($_.p / 250) + 249;
          $k[$j++] = $_.p % 250;
        }
      }
      $aload($geti($_.bvals, 0, $_.p));
      $_.bvals = $a();
      $k[$j++] = $_.bvals;
      $_.addtocws();
      $_.mode = $_.A;
    };
    $_.cws = $a(1480);
    $_.mode = $_.A;
    $_.i = 0;
    $_.j = 0;
    for (; ; ) {
      if ($_.i >= $_.msglen) {
        break;
      }
      if ($_[$get($a(["encA", "encCTX", "encCTX", "encCTX", "encD", "encB"]), $_.mode)]() === true) {
        break;
      }
    }
    $_.cws = $geti($_.cws, 0, $_.j);
  }
  var _IC = $_.metrics;
  for (var _ID = 0, _IE = _IC.length; _ID < _IE; _ID++) {
    $_.m = $get(_IC, _ID);
    $_.vers = $get($_.m, 0);
    $_.rows = $get($_.m, 1);
    $_.cols = $get($_.m, 2);
    $_.dcol = $get($_.m, 3);
    $_.dcws = $get($_.m, 4);
    $_.rscw = $get($_.m, 5);
    $_.rsbl = $get($_.m, 6);
    $_.riso = $get($_.m, 7);
    $_.risi = $get($_.m, 8);
    $_.risl = $get($_.m, 9);
    $_.dcpb = ~~($_.dcws / $_.rsbl);
    $_.ecpb = ~~($_.rscw / $_.rsbl);
    $_.okay = true;
    if ($ne($_.version, "unset") && $ne($_.version, $_.vers)) {
      $_.okay = false;
    }
    if ($_.cws.length > $_.dcws) {
      $_.okay = false;
    }
    if ($_.okay) {
      break;
    }
  }
  if (!$_.okay) {
    $k[$j++] = "bwipp.codeoneNoValidSymbol#25082";
    $k[$j++] = "Maximum length exceeded";
    bwipp_raiseerror();
  }
  if (!$_.stype) {
    $k[$j++] = Infinity;
    $aload($_.cws);
    for (var _Ip = 0, _Iq = $f($_.dcws - $_.cws.length); _Ip < _Iq; _Ip++) {
      $k[$j++] = 129;
    }
    $_.cws = $a();
  } else {
    $k[$j++] = Infinity;
    for (var _Iu = 0, _Iv = $f($_.dcws - $_.cws.length); _Iu < _Iv; _Iu++) {
      $k[$j++] = 0;
    }
    $aload($_.cws);
    $_.cws = $a();
  }
  var _Iz = $get($_.options, "debugcws") !== void 0;
  if (_Iz) {
    $k[$j++] = "bwipp.debugcws#25092";
    $k[$j++] = $_.cws;
    bwipp_raiseerror();
  }
  $_.cwbs = $a($_.rsbl);
  $_.ecbs = $a($_.rsbl);
  for (var _J7 = 0, _J6 = $_.rsbl - 1; _J7 <= _J6; _J7 += 1) {
    $_.i = _J7;
    $_.cwb = $a($_.dcpb);
    for (var _JC = 0, _JB = $_.dcpb - 1; _JC <= _JB; _JC += 1) {
      $_.j = _JC;
      $put($_.cwb, $_.j, $get($_.cws, $f($_.j * $_.rsbl + $_.i)));
    }
    $put($_.cwbs, $_.i, $_.cwb);
  }
  var _JO = $_.stype ? 32 : 256;
  $_.gf = _JO;
  $_["gf-1"] = $_.gf - 1;
  var _JR = $_.stype ? 37 : 301;
  $_.pm = _JR;
  $k[$j++] = Infinity;
  $k[$j++] = 1;
  for (var _JT = 0, _JU = $_["gf-1"]; _JT < _JU; _JT++) {
    var _JV = $k[$j - 1];
    var _JW = _JV * 2;
    $k[$j++] = _JW;
    if (_JW >= $_.gf) {
      var _JZ = $k[--$j];
      $k[$j++] = _JZ ^ $_.pm;
    }
  }
  $_.rsalog = $a();
  $_.rslog = $a($_.gf);
  for (var _Jf = 1, _Je = $_["gf-1"]; _Jf <= _Je; _Jf += 1) {
    $put($_.rslog, $get($_.rsalog, _Jf), _Jf);
  }
  $_.rsprod = function() {
    var _Jj = $k[$j - 1];
    var _Jk = $k[$j - 2];
    if (_Jj != 0 && _Jk != 0) {
      var _Jn = $get($_.rslog, $k[--$j]);
      var _Jt = $get($_.rsalog, $f(_Jn + $get($_.rslog, $k[--$j])) % $_["gf-1"]);
      $k[$j++] = _Jt;
    } else {
      $j -= 2;
      $k[$j++] = 0;
    }
  };
  $k[$j++] = Infinity;
  $k[$j++] = 1;
  for (var _Jv = 0, _Jw = $_.ecpb; _Jv < _Jw; _Jv++) {
    $k[$j++] = 0;
  }
  $_.coeffs = $a();
  for (var _K0 = 0, _Jz = $_.ecpb - 1; _K0 <= _Jz; _K0 += 1) {
    $_.i = _K0;
    $put($_.coeffs, $_.i + 1, $get($_.coeffs, $_.i));
    for (var _K7 = $_.i; _K7 >= 1; _K7 -= 1) {
      $_.j = _K7;
      $k[$j++] = $_.coeffs;
      $k[$j++] = $_.j;
      $k[$j++] = $get($_.coeffs, $_.j - 1);
      $k[$j++] = $get($_.coeffs, $_.j);
      $k[$j++] = $get($_.rsalog, $_.i);
      $_.rsprod();
      var _KJ = $k[--$j];
      var _KK = $k[--$j];
      var _KL = $k[--$j];
      $put($k[--$j], _KL, $xo(_KK, _KJ));
    }
    $k[$j++] = $_.coeffs;
    $k[$j++] = 0;
    $k[$j++] = $get($_.coeffs, 0);
    $k[$j++] = $get($_.rsalog, $_.i);
    $_.rsprod();
    var _KT = $k[--$j];
    var _KU = $k[--$j];
    $put($k[--$j], _KU, _KT);
  }
  $_.coeffs = $geti($_.coeffs, 0, $_.coeffs.length - 1);
  for (var _Kb = 0, _Ka = $_.cwbs.length - 1; _Kb <= _Ka; _Kb += 1) {
    $_.i = _Kb;
    $k[$j++] = Infinity;
    $aload($get($_.cwbs, $_.i));
    for (var _Kg = 0, _Kh = $_.ecpb; _Kg < _Kh; _Kg++) {
      $k[$j++] = 0;
    }
    $_.rscws = $a();
    for (var _Kl = 0, _Kk = $_.dcpb - 1; _Kl <= _Kk; _Kl += 1) {
      $_.m = _Kl;
      $_.k = $get($_.rscws, $_.m);
      for (var _Kr = 0, _Kq = $_.ecpb - 1; _Kr <= _Kq; _Kr += 1) {
        $_.j = _Kr;
        $k[$j++] = $_.rscws;
        $k[$j++] = $_.m + $_.j + 1;
        $k[$j++] = $get($_.coeffs, $_.ecpb - $_.j - 1);
        $k[$j++] = $_.k;
        $_.rsprod();
        var _L4 = $k[--$j];
        var _L5 = $k[--$j];
        $put($k[--$j], _L5, $xo(_L4, $get($_.rscws, $_.m + $_.j + 1)));
      }
    }
    $put($_.ecbs, $_.i, $geti($_.rscws, $_.dcpb, $_.ecpb));
  }
  $k[$j++] = Infinity;
  $aload($_.cws);
  for (var _LF = 0, _LG = $_.rscw; _LF < _LG; _LF++) {
    $k[$j++] = 0;
  }
  $_.cws = $a();
  for (var _LK = 0, _LJ = $_.rscw - 1; _LK <= _LJ; _LK += 1) {
    $_.i = _LK;
    $put($_.cws, $f($_.dcws + $_.i), $get($get($_.ecbs, $_.i % $_.rsbl), ~~($_.i / $_.rsbl)));
  }
  var _LY = $_.stype ? 5 : 8;
  $_.mmat = $a($f($_.dcws + $_.rscw) * _LY);
  $_.r = 0;
  $_.c = 0;
  var _Lb = $_.stype ? 2 : 1;
  for (var _Le = 0, _Lf = _Lb, _Ld = $_.cws.length - 1; _Lf < 0 ? _Le >= _Ld : _Le <= _Ld; _Le += _Lf) {
    $_.i = _Le;
    if (!$_.stype) {
      var _Li = $strcpy($s(8), "00000000");
      var _Ln = $cvrs($s(8), $get($_.cws, $_.i), 2);
      $puti(_Li, 8 - _Ln.length, _Ln);
      var _Lo = Infinity;
      var _Lp = _Li;
      $k[$j++] = _Lo;
      $forall(_Lp, function() {
        var _Lq = $k[--$j];
        $k[$j++] = _Lq - 48;
      });
      var _Lr = $a();
      $_.top = $geti(_Lr, 0, 4);
      $_.bot = $geti(_Lr, 4, 4);
    } else {
      var _Lv = $strcpy($s(5), "00000");
      var _M0 = $cvrs($s(5), $get($_.cws, $_.i), 2);
      $puti(_Lv, 5 - _M0.length, _M0);
      var _M1 = Infinity;
      var _M2 = _Lv;
      $k[$j++] = _M1;
      $forall(_M2, function() {
        var _M3 = $k[--$j];
        $k[$j++] = _M3 - 48;
      });
      $_.c1 = $a();
      var _M6 = $strcpy($s(5), "00000");
      var _MB = $cvrs($s(5), $get($_.cws, $_.i + 1), 2);
      $puti(_M6, 5 - _MB.length, _MB);
      var _MC = Infinity;
      var _MD = _M6;
      $k[$j++] = _MC;
      $forall(_MD, function() {
        var _ME = $k[--$j];
        $k[$j++] = _ME - 48;
      });
      $_.c2 = $a();
      $k[$j++] = Infinity;
      $aload($geti($_.c1, 0, 3));
      $aload($geti($_.c2, 0, 2));
      $_.top = $a();
      $k[$j++] = Infinity;
      $aload($geti($_.c1, 3, 2));
      $aload($geti($_.c2, 2, 3));
      $_.bot = $a();
    }
    $puti($_.mmat, $f($_.r * $_.dcol + $_.c), $_.top);
    $puti($_.mmat, $f(($_.r + 1) * $_.dcol + $_.c), $_.bot);
    $_.c = $_.c + $_.top.length;
    if ($_.c == $_.dcol) {
      $_.c = 0;
      $_.r = $_.r + 2;
    }
  }
  $_.mmv = function() {
    var _Mg = $k[--$j];
    var _Mh = $k[--$j];
    $k[$j++] = $f(_Mh + _Mg * $_.cols);
  };
  $k[$j++] = Infinity;
  for (var _Mk = 0, _Ml = $_.rows * $_.cols; _Mk < _Ml; _Mk++) {
    $k[$j++] = -1;
  }
  $_.pixs = $a();
  var _NH = $a([function() {
    for (var _Mo = 0, _Mp = $_.cols; _Mo < _Mp; _Mo++) {
      $k[$j++] = 0;
    }
  }, function() {
    for (var _Mr = 0, _Ms = $_.cols; _Mr < _Ms; _Mr++) {
      $k[$j++] = 1;
    }
  }, function() {
    $k[$j++] = 0;
    for (var _Mu = 0, _Mv = $_.cols - 2; _Mu < _Mv; _Mu++) {
      $k[$j++] = 1;
    }
    $k[$j++] = 0;
  }, function() {
    $k[$j++] = 0;
    $k[$j++] = 1;
    for (var _Mx = 0, _My = $_.cols - 4; _Mx < _My; _Mx++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 1;
    $k[$j++] = 0;
  }, function() {
    for (var _N0 = 0, _N1 = ~~(($_.cols - 1) / 2); _N0 < _N1; _N0++) {
      $k[$j++] = -1;
    }
    $k[$j++] = 1;
    for (var _N3 = 0, _N4 = ~~(($_.cols - 1) / 2); _N3 < _N4; _N3++) {
      $k[$j++] = -1;
    }
  }, function() {
    for (var _N6 = 0, _N7 = ~~(($_.cols - 1) / 2); _N6 < _N7; _N6++) {
      $k[$j++] = -1;
    }
    $k[$j++] = 0;
    for (var _N9 = 0, _NA = ~~(($_.cols - 1) / 2); _N9 < _NA; _N9++) {
      $k[$j++] = -1;
    }
  }, function() {
    $k[$j++] = 1;
    for (var _NC = 0, _ND = $_.cols - 2; _NC < _ND; _NC++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 1;
  }, function() {
    $k[$j++] = 1;
    $k[$j++] = 0;
    for (var _NF = 0, _NG = $_.cols - 4; _NF < _NG; _NF++) {
      $k[$j++] = 1;
    }
    $k[$j++] = 0;
    $k[$j++] = 1;
  }]);
  $_.artifact = _NH;
  var _NI = /* @__PURE__ */ new Map([
    ["A", "121343"],
    ["B", "12134343"],
    ["C", "12121343"],
    ["D", "1213434343"],
    ["E", "1212134343"],
    ["F", "1212121343"],
    ["G", "121213434343"],
    ["H", "121212134343"],
    ["S", "56661278"],
    ["T", "5666666666127878"]
  ]);
  $_.cpatmap = _NI;
  $_.cpat = $get($_.cpatmap, $geti($_.vers, 0, 1));
  $k[$j++] = $_.pixs;
  $k[$j++] = 0;
  $k[$j++] = ~~($f($_.rows - $_.cpat.length) / 2);
  $_.mmv();
  $k[$j++] = Infinity;
  $forall($_.cpat, function() {
    if ($get($_.artifact, $k[--$j] - 49)() === true) {
      return true;
    }
  });
  var _NV = $a();
  var _NW = $k[--$j];
  $puti($k[--$j], _NW, _NV);
  for (var _Na = 0, _NZ = $_.risl - 1; _Na <= _NZ; _Na += 1) {
    $_.i = _Na;
    for (var _Nf = $_.riso, _Ng = $_.risi, _Ne = $_.cols - 1; _Ng < 0 ? _Nf >= _Ne : _Nf <= _Ne; _Nf += _Ng) {
      $_.j = _Nf;
      var _Ni = $_.i % 12 == 0 ? 1 : 0;
      var _Nj = $a([1, _Ni]);
      $k[$j++] = _Nj;
      $k[$j++] = _Nj;
      $k[$j++] = $_.pixs;
      $k[$j++] = $_.j;
      $k[$j++] = $_.i;
      $_.mmv();
      var _Nn = $k[$j - 3];
      var _No = $k[$j - 1];
      $puti($k[$j - 2], _No, _Nn);
      $j -= 3;
      if ($_.i != $_.risl - 1) {
        $k[$j++] = $_.pixs;
        $k[$j++] = $f($_.cols - $_.j) - 2;
        $k[$j++] = $f($_.rows - $_.i) - 1;
        $_.mmv();
        var _Nx = $k[$j - 3];
        var _Ny = $k[$j - 1];
        $puti($k[$j - 2], _Ny, _Nx);
        $j -= 3;
      } else {
        $j--;
      }
    }
  }
  var _Od = /* @__PURE__ */ new Map([
    ["A", $a([$a([12, 5])])],
    ["B", $a([$a([16, 7])])],
    ["C", $a([$a([26, 12])])],
    ["D", $a([])],
    ["E", $a([$a([26, 23])])],
    ["F", $a([$a([26, 32]), $a([70, 32]), $a([26, 34]), $a([70, 34])])],
    ["G", $a([$a([27, 48]), $a([69, 48])])],
    ["H", $a([$a([26, 70]), $a([66, 70]), $a([106, 70]), $a([26, 72]), $a([66, 72]), $a([106, 72])])],
    ["S-10", $a([])],
    ["S-20", $a([$a([10, 4])])],
    ["S-30", $a([$a([15, 4]), $a([15, 6])])],
    ["T-16", $a([$a([8, 10])])],
    ["T-32", $a([$a([16, 10]), $a([16, 12])])],
    ["T-48", $a([$a([24, 10]), $a([24, 12]), $a([24, 14])])]
  ]);
  $_.blackdotmap = _Od;
  $forall($get($_.blackdotmap, $_.vers), function() {
    var _Oj = $k[--$j];
    $k[$j++] = $_.pixs;
    $aload(_Oj);
    $_.mmv();
    var _Ok = $k[--$j];
    $put($k[--$j], _Ok, 1);
  });
  $_.j = 0;
  for (var _Oo = 0, _On = $_.pixs.length - 1; _Oo <= _On; _Oo += 1) {
    $_.i = _Oo;
    if ($get($_.pixs, $_.i) == -1) {
      $put($_.pixs, $_.i, $get($_.mmat, $_.j));
      $_.j = $_.j + 1;
    }
  }
  $k[$j++] = Infinity;
  $k[$j++] = "ren";
  $k[$j++] = "renmatrix";
  $k[$j++] = "pixs";
  $k[$j++] = $_.pixs;
  $k[$j++] = "pixx";
  $k[$j++] = $_.cols;
  $k[$j++] = "pixy";
  $k[$j++] = $_.rows;
  $k[$j++] = "height";
  $k[$j++] = $_.rows / 72 * 2;
  $k[$j++] = "width";
  $k[$j++] = $_.cols / 72 * 2;
  if ($_.stype || $_.ttype) {
    $k[$j++] = "borderleft";
    $k[$j++] = 1;
    $k[$j++] = "borderright";
    $k[$j++] = 1;
    $k[$j++] = "bordertop";
    $k[$j++] = 0;
    $k[$j++] = "borderbottom";
    $k[$j++] = 1;
  }
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  var _P6 = $d();
  $k[$j++] = _P6;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_hanxin() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.version = "unset";
  $_.eclevel = "L2";
  $_.parse = false;
  $_.parsefnc = false;
  $_.mask = -1;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length == 0) {
    $k[$j++] = "bwipp.hanxinEmptyData#25328";
    $k[$j++] = "The data must not be empty";
    bwipp_raiseerror();
  }
  if ($ne($_.version, "unset")) {
    var _5 = $_.version.length;
    var _6 = _5 >= 1 && _5 <= 2;
    $k[$j++] = _6;
    if (_6) {
      $j--;
      var _7 = $_.version;
      $k[$j++] = true;
      for (var _8 = 0, _9 = _7.length; _8 < _9; _8++) {
        var _A = $get(_7, _8);
        if (_A < 48 || _A > 57) {
          $k[$j - 1] = false;
        }
      }
      var _B = $k[$j - 1];
      if (_B) {
        $j--;
        var _D = $cvi($_.version);
        $k[$j++] = _D >= 1 && _D <= 84;
      }
    }
    if (!$k[--$j]) {
      $k[$j++] = "bwipp.hanxinInvalidVersion#25339";
      $k[$j++] = "Valid versions are 1 to 84";
      bwipp_raiseerror();
    }
  }
  var _G = $_.eclevel.length == 2;
  $k[$j++] = _G;
  if (_G) {
    $j--;
    var _J = $eq($geti($_.eclevel, 0, 1), "L");
    $k[$j++] = _J;
    if (_J) {
      $j--;
      var _M = $get($_.eclevel, 1) - 48;
      $k[$j++] = _M >= 1 && _M <= 4;
    }
  }
  if (!$k[--$j]) {
    $k[$j++] = "bwipp.hanxinInvalidErrorCorrectionLevel#25349";
    $k[$j++] = "Valid error correction levels are L1 to L4";
    bwipp_raiseerror();
  }
  if ($_.mask != -1) {
    if ($_.mask < 1 || $_.mask > 4) {
      $k[$j++] = "bwipp.hanxinInvalidErrorCorrectionLevel#25354";
      $k[$j++] = "The valid masks are 1 to 4";
      bwipp_raiseerror();
    }
  }
  var _T = /* @__PURE__ */ new Map([
    ["parse", $_.parse],
    ["parsefnc", $_.parsefnc]
  ]);
  $_.fncvals = _T;
  $k[$j++] = "msg";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.fncvals;
  bwipp_parseinput();
  var _W = $k[--$j];
  $_[$k[--$j]] = _W;
  $_.msglen = $_.msg.length;
  $_.tobin = function() {
    var _a = $s($k[--$j]);
    $k[$j++] = _a;
    for (var _c = 0, _b = _a.length - 1; _c <= _b; _c += 1) {
      var _d = $k[$j - 1];
      $put(_d, _c, 48);
    }
    var _e = $k[$j - 1];
    $k[$j++] = _e;
    var _f = $k[$j - 3];
    var _g = $k[$j - 1];
    $k[$j - 3] = $k[$j - 2];
    $j -= 2;
    var _i = $cvrs($s(_g.length), _f, 2);
    $puti(_g, _g.length - _i.length, _i);
  };
  $_.bits = $s(4 + 13 + $_.msglen * 8);
  $puti($_.bits, 0, "0011");
  $k[$j++] = $_.bits;
  $k[$j++] = 4;
  $k[$j++] = $_.msglen;
  $k[$j++] = 13;
  $_.tobin();
  var _o = $k[--$j];
  var _p = $k[--$j];
  $puti($k[--$j], _p, _o);
  for (var _t = 0, _s = $_.msglen - 1; _t <= _s; _t += 1) {
    $_.i = _t;
    $k[$j++] = $_.bits;
    $k[$j++] = 17 + $_.i * 8;
    $k[$j++] = $get($_.msg, $_.i);
    $k[$j++] = 8;
    $_.tobin();
    var _z = $k[--$j];
    var _10 = $k[--$j];
    $puti($k[--$j], _10, _z);
  }
  $_.metrics = $a([$a(["1", 23, -1, 0, 205, $a([1, 21, 4]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 17, 8]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 13, 12]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 9, 16]), $a([0, -1, -1]), $a([0, -1, -1])]), $a(["2", 25, -1, 0, 301, $a([1, 31, 6]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 25, 12]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 19, 18]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 15, 22]), $a([0, -1, -1]), $a([0, -1, -1])]), $a(["3", 27, -1, 0, 405, $a([1, 42, 8]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 34, 16]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 26, 24]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 20, 30]), $a([0, -1, -1]), $a([0, -1, -1])]), $a(["4", 29, 14, 1, 439, $a([1, 46, 8]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 38, 16]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 30, 24]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 22, 32]), $a([0, -1, -1]), $a([0, -1, -1])]), $a(["5", 31, 16, 1, 555, $a([1, 57, 12]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 49, 20]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 37, 32]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 14, 20]), $a([1, 13, 22]), $a([0, -1, -1])]), $a(["6", 33, 16, 1, 675, $a([1, 70, 14]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 58, 26]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 24, 20]), $a([1, 22, 18]), $a([0, -1, -1]), $a([1, 16, 24]), $a([1, 18, 26]), $a([0, -1, -1])]), $a(["7", 35, 17, 1, 805, $a([1, 84, 16]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 70, 30]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 26, 22]), $a([1, 28, 24]), $a([0, -1, -1]), $a([2, 14, 20]), $a([1, 12, 20]), $a([0, -1, -1])]), $a(["8", 37, 18, 1, 943, $a([1, 99, 18]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 40, 18]), $a([1, 41, 18]), $a([0, -1, -1]), $a([1, 31, 26]), $a([1, 32, 28]), $a([0, -1, -1]), $a([2, 16, 24]), $a([1, 15, 22]), $a([0, -1, -1])]), $a(["9", 39, 19, 1, 1089, $a([1, 114, 22]), $a([0, -1, -1]), $a([0, -1, -1]), $a([2, 48, 20]), $a([0, -1, -1]), $a([0, -1, -1]), $a([2, 24, 20]), $a([1, 26, 22]), $a([0, -1, -1]), $a([2, 18, 28]), $a([1, 18, 26]), $a([0, -1, -1])]), $a(["10", 41, 20, 1, 1243, $a([1, 131, 24]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 52, 22]), $a([1, 57, 24]), $a([0, -1, -1]), $a([2, 27, 24]), $a([1, 29, 24]), $a([0, -1, -1]), $a([2, 21, 32]), $a([1, 19, 30]), $a([0, -1, -1])]), $a(["11", 43, 14, 2, 1289, $a([1, 135, 26]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 56, 24]), $a([1, 57, 24]), $a([0, -1, -1]), $a([2, 28, 24]), $a([1, 31, 26]), $a([0, -1, -1]), $a([2, 22, 32]), $a([1, 21, 32]), $a([0, -1, -1])]), $a(["12", 45, 15, 2, 1455, $a([1, 153, 28]), $a([0, -1, -1]), $a([0, -1, -1]), $a([1, 62, 26]), $a([1, 65, 28]), $a([0, -1, -1]), $a([2, 32, 28]), $a([1, 33, 28]), $a([0, -1, -1]), $a([3, 17, 26]), $a([1, 22, 30]), $a([0, -1, -1])]), $a(["13", 47, 16, 2, 1629, $a([1, 86, 16]), $a([1, 85, 16]), $a([0, -1, -1]), $a([1, 71, 30]), $a([1, 72, 30]), $a([0, -1, -1]), $a([2, 37, 32]), $a([1, 35, 30]), $a([0, -1, -1]), $a([3, 20, 30]), $a([1, 21, 32]), $a([0, -1, -1])]), $a(["14", 49, 16, 2, 1805, $a([1, 94, 18]), $a([1, 95, 18]), $a([0, -1, -1]), $a([2, 51, 22]), $a([1, 55, 24]), $a([0, -1, -1]), $a([3, 30, 26]), $a([1, 31, 26]), $a([0, -1, -1]), $a([4, 18, 28]), $a([1, 17, 24]), $a([0, -1, -1])]), $a(["15", 51, 17, 2, 1995, $a([1, 104, 20]), $a([1, 105, 20]), $a([0, -1, -1]), $a([2, 57, 24]), $a([1, 61, 26]), $a([0, -1, -1]), $a([3, 33, 28]), $a([1, 36, 30]), $a([0, -1, -1]), $a([4, 20, 30]), $a([1, 19, 30]), $a([0, -1, -1])]), $a(["16", 53, 17, 2, 2187, $a([1, 115, 22]), $a([1, 114, 22]), $a([0, -1, -1]), $a([2, 65, 28]), $a([1, 61, 26]), $a([0, -1, -1]), $a([3, 38, 32]), $a([1, 33, 30]), $a([0, -1, -1]), $a([5, 19, 28]), $a([1, 14, 24]), $a([0, -1, -1])]), $a(["17", 55, 18, 2, 2393, $a([1, 126, 24]), $a([1, 125, 24]), $a([0, -1, -1]), $a([2, 70, 30]), $a([1, 69, 30]), $a([0, -1, -1]), $a([4, 33, 28]), $a([1, 29, 26]), $a([0, -1, -1]), $a([5, 20, 30]), $a([1, 19, 30]), $a([0, -1, -1])]), $a(["18", 57, 19, 2, 2607, $a([1, 136, 26]), $a([1, 137, 26]), $a([0, -1, -1]), $a([3, 56, 24]), $a([1, 59, 26]), $a([0, -1, -1]), $a([5, 35, 30]), $a([0, -1, -1]), $a([0, -1, -1]), $a([6, 18, 28]), $a([1, 21, 28]), $a([0, -1, -1])]), $a(["19", 59, 20, 2, 2829, $a([1, 148, 28]), $a([1, 149, 28]), $a([0, -1, -1]), $a([3, 61, 26]), $a([1, 64, 28]), $a([0, -1, -1]), $a([7, 24, 20]), $a([1, 23, 22]), $a([0, -1, -1]), $a([6, 20, 30]), $a([1, 21, 32]), $a([0, -1, -1])]), $a(["20", 61, 20, 2, 3053, $a([3, 107, 20]), $a([0, -1, -1]), $a([0, -1, -1]), $a([3, 65, 28]), $a([1, 72, 30]), $a([0, -1, -1]), $a([7, 26, 22]), $a([1, 23, 22]), $a([0, -1, -1]), $a([7, 19, 28]), $a([1, 20, 32]), $a([0, -1, -1])]), $a(["21", 63, 21, 2, 3291, $a([3, 115, 22]), $a([0, -1, -1]), $a([0, -1, -1]), $a([4, 56, 24]), $a([1, 63, 28]), $a([0, -1, -1]), $a([7, 28, 24]), $a([1, 25, 22]), $a([0, -1, -1]), $a([8, 18, 28]), $a([1, 21, 22]), $a([0, -1, -1])]), $a(["22", 65, 16, 3, 3383, $a([2, 116, 22]), $a([1, 122, 24]), $a([0, -1, -1]), $a([4, 56, 24]), $a([1, 72, 30]), $a([0, -1, -1]), $a([7, 28, 24]), $a([1, 32, 26]), $a([0, -1, -1]), $a([8, 18, 28]), $a([1, 24, 30]), $a([0, -1, -1])]), $a(["23", 67, 17, 3, 3631, $a([3, 127, 24]), $a([0, -1, -1]), $a([0, -1, -1]), $a([5, 51, 22]), $a([1, 62, 26]), $a([0, -1, -1]), $a([7, 30, 26]), $a([1, 35, 26]), $a([0, -1, -1]), $a([8, 20, 30]), $a([1, 21, 32]), $a([0, -1, -1])]), $a(["24", 69, 17, 3, 3887, $a([2, 135, 26]), $a([1, 137, 26]), $a([0, -1, -1]), $a([5, 56, 24]), $a([1, 59, 26]), $a([0, -1, -1]), $a([7, 33, 28]), $a([1, 30, 28]), $a([0, -1, -1]), $a([11, 16, 24]), $a([1, 19, 26]), $a([0, -1, -1])]), $a(["25", 71, 18, 3, 4151, $a([3, 105, 20]), $a([1, 121, 22]), $a([0, -1, -1]), $a([5, 61, 26]), $a([1, 57, 26]), $a([0, -1, -1]), $a([9, 28, 24]), $a([1, 28, 22]), $a([0, -1, -1]), $a([10, 19, 28]), $a([1, 18, 30]), $a([0, -1, -1])]), $a(["26", 73, 18, 3, 4423, $a([2, 157, 30]), $a([1, 150, 28]), $a([0, -1, -1]), $a([5, 65, 28]), $a([1, 61, 26]), $a([0, -1, -1]), $a([8, 33, 28]), $a([1, 34, 30]), $a([0, -1, -1]), $a([10, 19, 28]), $a([2, 15, 26]), $a([0, -1, -1])]), $a(["27", 75, 19, 3, 4703, $a([3, 126, 24]), $a([1, 115, 22]), $a([0, -1, -1]), $a([7, 51, 22]), $a([1, 54, 22]), $a([0, -1, -1]), $a([8, 35, 30]), $a([1, 37, 30]), $a([0, -1, -1]), $a([15, 15, 22]), $a([1, 10, 22]), $a([0, -1, -1])]), $a(["28", 77, 19, 3, 4991, $a([4, 105, 20]), $a([1, 103, 20]), $a([0, -1, -1]), $a([7, 56, 24]), $a([1, 45, 18]), $a([0, -1, -1]), $a([10, 31, 26]), $a([1, 27, 26]), $a([0, -1, -1]), $a([10, 17, 26]), $a([3, 20, 28]), $a([1, 21, 28])]), $a(["29", 79, 20, 3, 5287, $a([3, 139, 26]), $a([1, 137, 28]), $a([0, -1, -1]), $a([6, 66, 28]), $a([1, 66, 30]), $a([0, -1, -1]), $a([9, 36, 30]), $a([1, 34, 32]), $a([0, -1, -1]), $a([13, 19, 28]), $a([1, 17, 32]), $a([0, -1, -1])]), $a(["30", 81, 20, 3, 5591, $a([6, 84, 16]), $a([1, 82, 16]), $a([0, -1, -1]), $a([6, 70, 30]), $a([1, 68, 30]), $a([0, -1, -1]), $a([7, 35, 30]), $a([3, 33, 28]), $a([1, 32, 28]), $a([13, 20, 30]), $a([1, 20, 28]), $a([0, -1, -1])]), $a(["31", 83, 21, 3, 5903, $a([5, 105, 20]), $a([1, 94, 18]), $a([0, -1, -1]), $a([6, 74, 32]), $a([1, 71, 30]), $a([0, -1, -1]), $a([11, 33, 28]), $a([1, 34, 32]), $a([0, -1, -1]), $a([13, 19, 28]), $a([3, 16, 26]), $a([0, -1, -1])]), $a(["32", 85, 17, 4, 6033, $a([4, 127, 24]), $a([1, 126, 24]), $a([0, -1, -1]), $a([7, 66, 28]), $a([1, 66, 30]), $a([0, -1, -1]), $a([12, 30, 24]), $a([1, 24, 28]), $a([1, 24, 30]), $a([15, 19, 28]), $a([1, 17, 32]), $a([0, -1, -1])]), $a(["33", 87, 17, 4, 6353, $a([7, 84, 16]), $a([1, 78, 16]), $a([0, -1, -1]), $a([7, 70, 30]), $a([1, 66, 28]), $a([0, -1, -1]), $a([12, 33, 28]), $a([1, 32, 30]), $a([0, -1, -1]), $a([14, 21, 32]), $a([1, 24, 28]), $a([0, -1, -1])]), $a(["34", 89, 18, 4, 6689, $a([5, 117, 22]), $a([1, 117, 24]), $a([0, -1, -1]), $a([8, 66, 28]), $a([1, 58, 26]), $a([0, -1, -1]), $a([11, 38, 32]), $a([1, 34, 32]), $a([0, -1, -1]), $a([15, 20, 30]), $a([2, 17, 26]), $a([0, -1, -1])]), $a(["35", 91, 18, 4, 7025, $a([4, 148, 28]), $a([1, 146, 28]), $a([0, -1, -1]), $a([8, 68, 30]), $a([1, 70, 24]), $a([0, -1, -1]), $a([10, 36, 32]), $a([3, 38, 28]), $a([0, -1, -1]), $a([16, 19, 28]), $a([3, 16, 26]), $a([0, -1, -1])]), $a(["36", 93, 19, 4, 7377, $a([4, 126, 24]), $a([2, 135, 26]), $a([0, -1, -1]), $a([8, 70, 28]), $a([2, 43, 26]), $a([0, -1, -1]), $a([13, 32, 28]), $a([2, 41, 30]), $a([0, -1, -1]), $a([17, 19, 28]), $a([3, 15, 26]), $a([0, -1, -1])]), $a(["37", 95, 19, 4, 7729, $a([5, 136, 26]), $a([1, 132, 24]), $a([0, -1, -1]), $a([5, 67, 30]), $a([4, 68, 28]), $a([1, 69, 28]), $a([14, 35, 30]), $a([1, 32, 24]), $a([0, -1, -1]), $a([18, 18, 26]), $a([3, 16, 28]), $a([1, 14, 28])]), $a(["38", 97, 19, 4, 8089, $a([3, 142, 26]), $a([3, 141, 28]), $a([0, -1, -1]), $a([8, 70, 30]), $a([1, 73, 32]), $a([1, 74, 32]), $a([12, 34, 30]), $a([3, 34, 26]), $a([1, 35, 28]), $a([18, 21, 32]), $a([1, 27, 30]), $a([0, -1, -1])]), $a(["39", 99, 20, 4, 8465, $a([5, 116, 22]), $a([2, 103, 20]), $a([1, 102, 20]), $a([9, 74, 32]), $a([1, 74, 30]), $a([0, -1, -1]), $a([14, 34, 28]), $a([2, 32, 32]), $a([1, 32, 30]), $a([19, 21, 32]), $a([1, 25, 26]), $a([0, -1, -1])]), $a(["40", 101, 20, 4, 8841, $a([7, 116, 22]), $a([1, 117, 22]), $a([0, -1, -1]), $a([11, 65, 28]), $a([1, 58, 24]), $a([0, -1, -1]), $a([15, 38, 32]), $a([1, 27, 28]), $a([0, -1, -1]), $a([20, 20, 30]), $a([1, 20, 32]), $a([1, 21, 32])]), $a(["41", 103, 17, 5, 9009, $a([6, 136, 26]), $a([1, 130, 24]), $a([0, -1, -1]), $a([11, 66, 28]), $a([1, 62, 30]), $a([0, -1, -1]), $a([14, 34, 28]), $a([3, 34, 32]), $a([1, 30, 30]), $a([18, 20, 30]), $a([3, 20, 28]), $a([2, 15, 26])]), $a(["42", 105, 17, 5, 9401, $a([5, 105, 20]), $a([2, 115, 22]), $a([2, 116, 22]), $a([10, 75, 32]), $a([1, 73, 32]), $a([0, -1, -1]), $a([16, 38, 32]), $a([1, 27, 28]), $a([0, -1, -1]), $a([22, 19, 28]), $a([2, 16, 30]), $a([1, 19, 30])]), $a(["43", 107, 18, 5, 9799, $a([6, 147, 28]), $a([1, 146, 28]), $a([0, -1, -1]), $a([11, 66, 28]), $a([2, 65, 30]), $a([0, -1, -1]), $a([18, 33, 28]), $a([2, 33, 30]), $a([0, -1, -1]), $a([22, 21, 32]), $a([1, 28, 30]), $a([0, -1, -1])]), $a(["44", 109, 18, 5, 10207, $a([6, 116, 22]), $a([3, 125, 24]), $a([0, -1, -1]), $a([11, 75, 32]), $a([1, 68, 30]), $a([0, -1, -1]), $a([13, 35, 28]), $a([6, 34, 32]), $a([1, 30, 30]), $a([23, 21, 32]), $a([1, 26, 30]), $a([0, -1, -1])]), $a(["45", 111, 18, 5, 10623, $a([7, 105, 20]), $a([4, 95, 18]), $a([0, -1, -1]), $a([12, 67, 28]), $a([1, 63, 30]), $a([1, 62, 32]), $a([21, 31, 26]), $a([2, 33, 32]), $a([0, -1, -1]), $a([23, 21, 32]), $a([2, 24, 30]), $a([0, -1, -1])]), $a(["46", 113, 19, 5, 11045, $a([10, 116, 22]), $a([0, -1, -1]), $a([0, -1, -1]), $a([12, 74, 32]), $a([1, 78, 30]), $a([0, -1, -1]), $a([18, 37, 32]), $a([1, 39, 30]), $a([1, 41, 28]), $a([25, 21, 32]), $a([1, 27, 28]), $a([0, -1, -1])]), $a(["47", 115, 19, 5, 11477, $a([5, 126, 24]), $a([4, 115, 22]), $a([1, 114, 22]), $a([12, 67, 28]), $a([2, 66, 32]), $a([1, 68, 30]), $a([21, 35, 30]), $a([1, 39, 30]), $a([0, -1, -1]), $a([26, 21, 32]), $a([1, 28, 28]), $a([0, -1, -1])]), $a(["48", 117, 19, 5, 11917, $a([9, 126, 24]), $a([1, 117, 22]), $a([0, -1, -1]), $a([13, 75, 32]), $a([1, 68, 30]), $a([0, -1, -1]), $a([20, 35, 30]), $a([3, 35, 28]), $a([0, -1, -1]), $a([27, 21, 32]), $a([1, 28, 30]), $a([0, -1, -1])]), $a(["49", 119, 17, 6, 12111, $a([9, 126, 24]), $a([1, 137, 26]), $a([0, -1, -1]), $a([13, 71, 30]), $a([2, 68, 32]), $a([0, -1, -1]), $a([20, 37, 32]), $a([1, 39, 28]), $a([1, 38, 28]), $a([24, 20, 32]), $a([5, 25, 28]), $a([0, -1, -1])]), $a(["50", 121, 17, 6, 12559, $a([8, 147, 28]), $a([1, 141, 28]), $a([0, -1, -1]), $a([10, 73, 32]), $a([4, 74, 30]), $a([1, 73, 30]), $a([16, 36, 32]), $a([6, 39, 30]), $a([1, 37, 30]), $a([27, 21, 32]), $a([3, 20, 26]), $a([0, -1, -1])]), $a(["51", 123, 18, 6, 13025, $a([9, 137, 26]), $a([1, 135, 26]), $a([0, -1, -1]), $a([12, 70, 30]), $a([4, 75, 32]), $a([0, -1, -1]), $a([24, 35, 30]), $a([1, 40, 28]), $a([0, -1, -1]), $a([23, 20, 32]), $a([8, 24, 30]), $a([0, -1, -1])]), $a(["52", 125, 18, 6, 13489, $a([14, 95, 18]), $a([1, 86, 18]), $a([0, -1, -1]), $a([13, 73, 32]), $a([3, 77, 30]), $a([0, -1, -1]), $a([24, 35, 30]), $a([2, 35, 28]), $a([0, -1, -1]), $a([26, 21, 32]), $a([5, 21, 30]), $a([1, 23, 30])]), $a(["53", 127, 18, 6, 13961, $a([9, 147, 28]), $a([1, 142, 28]), $a([0, -1, -1]), $a([10, 73, 30]), $a([6, 70, 32]), $a([1, 71, 32]), $a([25, 35, 30]), $a([2, 34, 26]), $a([0, -1, -1]), $a([29, 21, 32]), $a([4, 22, 30]), $a([0, -1, -1])]), $a(["54", 129, 18, 6, 14441, $a([11, 126, 24]), $a([1, 131, 24]), $a([0, -1, -1]), $a([16, 74, 32]), $a([1, 79, 30]), $a([0, -1, -1]), $a([25, 38, 32]), $a([1, 25, 30]), $a([0, -1, -1]), $a([33, 21, 32]), $a([1, 28, 28]), $a([0, -1, -1])]), $a(["55", 131, 19, 6, 14939, $a([14, 105, 20]), $a([1, 99, 18]), $a([0, -1, -1]), $a([19, 65, 28]), $a([1, 72, 28]), $a([0, -1, -1]), $a([24, 37, 32]), $a([2, 40, 30]), $a([1, 41, 30]), $a([31, 21, 32]), $a([4, 24, 32]), $a([0, -1, -1])]), $a(["56", 133, 19, 6, 15435, $a([10, 147, 28]), $a([1, 151, 28]), $a([0, -1, -1]), $a([15, 71, 30]), $a([3, 71, 32]), $a([1, 73, 32]), $a([24, 37, 32]), $a([3, 38, 30]), $a([1, 39, 30]), $a([36, 19, 30]), $a([3, 29, 26]), $a([0, -1, -1])]), $a(["57", 135, 19, 6, 15939, $a([15, 105, 20]), $a([1, 99, 18]), $a([0, -1, -1]), $a([19, 70, 30]), $a([1, 64, 28]), $a([0, -1, -1]), $a([27, 38, 32]), $a([2, 25, 26]), $a([0, -1, -1]), $a([38, 20, 30]), $a([2, 18, 28]), $a([0, -1, -1])]), $a(["58", 137, 17, 7, 16171, $a([14, 105, 20]), $a([1, 113, 22]), $a([1, 114, 22]), $a([17, 67, 30]), $a([3, 92, 32]), $a([0, -1, -1]), $a([30, 35, 30]), $a([1, 41, 30]), $a([0, -1, -1]), $a([36, 21, 32]), $a([1, 26, 30]), $a([1, 27, 30])]), $a(["59", 139, 17, 7, 16691, $a([11, 146, 28]), $a([1, 146, 26]), $a([0, -1, -1]), $a([20, 70, 30]), $a([1, 60, 26]), $a([0, -1, -1]), $a([29, 38, 32]), $a([1, 24, 32]), $a([0, -1, -1]), $a([40, 20, 30]), $a([2, 17, 26]), $a([0, -1, -1])]), $a(["60", 141, 18, 7, 17215, $a([3, 137, 26]), $a([1, 136, 26]), $a([10, 126, 24]), $a([22, 65, 28]), $a([1, 75, 30]), $a([0, -1, -1]), $a([30, 37, 32]), $a([1, 51, 30]), $a([0, -1, -1]), $a([42, 20, 30]), $a([1, 21, 30]), $a([0, -1, -1])]), $a(["61", 143, 18, 7, 17751, $a([12, 126, 24]), $a([2, 118, 22]), $a([1, 116, 22]), $a([19, 74, 32]), $a([1, 74, 30]), $a([1, 72, 28]), $a([30, 38, 32]), $a([2, 29, 30]), $a([0, -1, -1]), $a([39, 20, 32]), $a([2, 37, 26]), $a([1, 38, 26])]), $a(["62", 145, 18, 7, 18295, $a([12, 126, 24]), $a([3, 136, 26]), $a([0, -1, -1]), $a([21, 70, 30]), $a([2, 65, 28]), $a([0, -1, -1]), $a([34, 35, 30]), $a([1, 44, 32]), $a([0, -1, -1]), $a([42, 20, 30]), $a([2, 19, 28]), $a([2, 18, 28])]), $a(["63", 147, 18, 7, 18847, $a([12, 126, 24]), $a([3, 117, 22]), $a([1, 116, 22]), $a([25, 61, 26]), $a([2, 62, 28]), $a([0, -1, -1]), $a([34, 35, 30]), $a([1, 40, 32]), $a([1, 41, 32]), $a([45, 20, 30]), $a([1, 20, 32]), $a([1, 21, 32])]), $a(["64", 149, 19, 7, 19403, $a([15, 105, 20]), $a([2, 115, 22]), $a([2, 116, 22]), $a([25, 65, 28]), $a([1, 72, 28]), $a([0, -1, -1]), $a([18, 35, 30]), $a([17, 37, 32]), $a([1, 50, 32]), $a([42, 20, 30]), $a([6, 19, 28]), $a([1, 15, 28])]), $a(["65", 151, 19, 7, 19971, $a([19, 105, 20]), $a([1, 101, 20]), $a([0, -1, -1]), $a([33, 51, 22]), $a([1, 65, 22]), $a([0, -1, -1]), $a([40, 33, 28]), $a([1, 28, 28]), $a([0, -1, -1]), $a([49, 20, 30]), $a([1, 18, 28]), $a([0, -1, -1])]), $a(["66", 153, 17, 8, 20229, $a([18, 105, 20]), $a([2, 117, 22]), $a([0, -1, -1]), $a([26, 65, 28]), $a([1, 80, 30]), $a([0, -1, -1]), $a([35, 35, 30]), $a([3, 35, 28]), $a([1, 36, 28]), $a([52, 18, 28]), $a([2, 38, 30]), $a([0, -1, -1])]), $a(["67", 155, 17, 8, 20805, $a([26, 84, 16]), $a([0, -1, -1]), $a([0, -1, -1]), $a([26, 70, 30]), $a([0, -1, -1]), $a([0, -1, -1]), $a([45, 31, 26]), $a([1, 9, 26]), $a([0, -1, -1]), $a([52, 20, 30]), $a([0, -1, -1]), $a([0, -1, -1])]), $a(["68", 157, 17, 8, 21389, $a([16, 126, 24]), $a([1, 114, 22]), $a([1, 115, 22]), $a([23, 70, 30]), $a([3, 65, 28]), $a([1, 66, 28]), $a([40, 35, 30]), $a([1, 43, 30]), $a([0, -1, -1]), $a([46, 20, 30]), $a([7, 19, 28]), $a([1, 16, 28])]), $a(["69", 159, 18, 8, 21993, $a([19, 116, 22]), $a([1, 105, 22]), $a([0, -1, -1]), $a([20, 70, 30]), $a([7, 66, 28]), $a([1, 63, 28]), $a([40, 35, 30]), $a([1, 42, 32]), $a([1, 43, 32]), $a([54, 20, 30]), $a([1, 19, 30]), $a([0, -1, -1])]), $a(["70", 161, 18, 8, 22593, $a([17, 126, 24]), $a([2, 115, 22]), $a([0, -1, -1]), $a([24, 70, 30]), $a([4, 74, 32]), $a([0, -1, -1]), $a([48, 31, 26]), $a([2, 18, 26]), $a([0, -1, -1]), $a([54, 19, 28]), $a([6, 15, 26]), $a([1, 14, 26])]), $a(["71", 163, 18, 8, 23201, $a([29, 84, 16]), $a([0, -1, -1]), $a([0, -1, -1]), $a([29, 70, 30]), $a([0, -1, -1]), $a([0, -1, -1]), $a([6, 34, 30]), $a([3, 36, 30]), $a([38, 33, 28]), $a([58, 20, 30]), $a([0, -1, -1]), $a([0, -1, -1])]), $a(["72", 165, 18, 8, 23817, $a([16, 147, 28]), $a([1, 149, 28]), $a([0, -1, -1]), $a([31, 66, 28]), $a([1, 37, 26]), $a([0, -1, -1]), $a([48, 33, 28]), $a([1, 23, 26]), $a([0, -1, -1]), $a([53, 20, 30]), $a([6, 19, 28]), $a([1, 17, 28])]), $a(["73", 167, 19, 8, 24453, $a([20, 115, 22]), $a([2, 134, 24]), $a([0, -1, -1]), $a([29, 66, 28]), $a([2, 56, 26]), $a([2, 57, 26]), $a([45, 36, 30]), $a([2, 15, 28]), $a([0, -1, -1]), $a([59, 20, 30]), $a([2, 21, 32]), $a([0, -1, -1])]), $a(["74", 169, 19, 8, 25085, $a([17, 147, 28]), $a([1, 134, 26]), $a([0, -1, -1]), $a([26, 70, 30]), $a([5, 75, 32]), $a([0, -1, -1]), $a([47, 35, 30]), $a([1, 48, 32]), $a([0, -1, -1]), $a([64, 18, 28]), $a([2, 33, 30]), $a([1, 35, 30])]), $a(["75", 171, 17, 9, 25373, $a([22, 115, 22]), $a([1, 133, 24]), $a([0, -1, -1]), $a([33, 65, 28]), $a([1, 74, 28]), $a([0, -1, -1]), $a([43, 36, 30]), $a([5, 27, 28]), $a([1, 30, 28]), $a([57, 20, 30]), $a([5, 21, 32]), $a([1, 24, 32])]), $a(["76", 173, 17, 9, 26021, $a([18, 136, 26]), $a([2, 142, 26]), $a([0, -1, -1]), $a([33, 66, 28]), $a([2, 49, 26]), $a([0, -1, -1]), $a([48, 35, 30]), $a([2, 38, 28]), $a([0, -1, -1]), $a([64, 20, 30]), $a([1, 20, 32]), $a([0, -1, -1])]), $a(["77", 175, 17, 9, 26677, $a([19, 126, 24]), $a([2, 135, 26]), $a([1, 136, 26]), $a([32, 66, 28]), $a([2, 55, 26]), $a([2, 56, 26]), $a([49, 36, 30]), $a([2, 18, 32]), $a([0, -1, -1]), $a([65, 18, 28]), $a([5, 27, 30]), $a([1, 29, 30])]), $a(["78", 177, 18, 9, 27335, $a([20, 137, 26]), $a([1, 130, 26]), $a([0, -1, -1]), $a([30, 75, 32]), $a([2, 71, 32]), $a([0, -1, -1]), $a([46, 35, 30]), $a([6, 39, 32]), $a([0, -1, -1]), $a([3, 12, 30]), $a([70, 19, 28]), $a([0, -1, -1])]), $a(["79", 179, 18, 9, 28007, $a([20, 147, 28]), $a([0, -1, -1]), $a([0, -1, -1]), $a([35, 70, 30]), $a([0, -1, -1]), $a([0, -1, -1]), $a([49, 35, 30]), $a([5, 35, 28]), $a([0, -1, -1]), $a([70, 20, 30]), $a([0, -1, -1]), $a([0, -1, -1])]), $a(["80", 181, 18, 9, 28687, $a([21, 136, 26]), $a([1, 155, 28]), $a([0, -1, -1]), $a([34, 70, 30]), $a([1, 64, 28]), $a([1, 65, 28]), $a([54, 35, 30]), $a([1, 45, 30]), $a([0, -1, -1]), $a([68, 20, 30]), $a([3, 18, 28]), $a([1, 19, 28])]), $a(["81", 183, 18, 9, 29375, $a([19, 126, 24]), $a([5, 115, 22]), $a([1, 114, 22]), $a([33, 70, 30]), $a([3, 65, 28]), $a([1, 64, 28]), $a([52, 35, 30]), $a([3, 41, 32]), $a([1, 40, 32]), $a([67, 20, 30]), $a([5, 21, 32]), $a([1, 24, 32])]), $a(["82", 185, 18, 9, 30071, $a([2, 150, 28]), $a([21, 136, 26]), $a([0, -1, -1]), $a([32, 70, 30]), $a([6, 65, 28]), $a([0, -1, -1]), $a([52, 38, 32]), $a([2, 27, 32]), $a([0, -1, -1]), $a([73, 20, 30]), $a([2, 22, 32]), $a([0, -1, -1])]), $a(["83", 187, 17, 10, 30387, $a([21, 126, 24]), $a([4, 136, 26]), $a([0, -1, -1]), $a([30, 74, 32]), $a([6, 73, 30]), $a([0, -1, -1]), $a([54, 35, 30]), $a([4, 40, 32]), $a([0, -1, -1]), $a([75, 20, 30]), $a([1, 20, 28]), $a([0, -1, -1])]), $a(["84", 189, 17, 10, 31091, $a([30, 105, 20]), $a([1, 114, 22]), $a([0, -1, -1]), $a([3, 45, 22]), $a([55, 47, 20]), $a([0, -1, -1]), $a([2, 26, 26]), $a([62, 33, 28]), $a([0, -1, -1]), $a([79, 18, 28]), $a([4, 33, 30]), $a([0, -1, -1])])]);
  $_.eclval = $get($_.eclevel, 1) - 49;
  var _Ii = $_.metrics;
  for (var _Ij = 0, _Ik = _Ii.length; _Ij < _Ik; _Ij++) {
    $_.m = $get(_Ii, _Ij);
    $_.vers = $get($_.m, 0);
    $_.size = $get($_.m, 1);
    $_.alnk = $get($_.m, 2);
    $_.alnn = $get($_.m, 3);
    $_.alnr = $f($_.size - $_.alnk * $_.alnn);
    $_.nmod = $get($_.m, 4);
    $_.ncws = ~~($_.nmod / 8);
    $_.rbit = $_.nmod % 8;
    $_.ecbs = $geti($_.m, 5 + $_.eclval * 3, 3);
    var _J4 = $_.ecbs;
    $k[$j++] = "ecws";
    $k[$j++] = 0;
    for (var _J5 = 0, _J6 = _J4.length; _J5 < _J6; _J5++) {
      var _J7 = $get(_J4, _J5);
      var _JA = $k[--$j];
      $k[$j++] = $f(_JA + $get(_J7, 0) * $get(_J7, 2));
    }
    var _JB = $k[--$j];
    $_[$k[--$j]] = _JB;
    $_.dcws = $f($_.ncws - $_.ecws);
    $_.dmod = $_.dcws * 8;
    $_.okay = true;
    if ($ne($_.version, "unset") && $ne($_.version, $_.vers)) {
      $_.okay = false;
    }
    if ($_.bits.length > $_.dmod) {
      $_.okay = false;
    }
    if ($_.okay) {
      break;
    }
  }
  if (!$_.okay) {
    $k[$j++] = "bwipp.hanxinNoValidSymbol#25749";
    $k[$j++] = "Maximum length exceeded or invalid content";
    bwipp_raiseerror();
  }
  $_.version = $_.vers;
  $_.msgbits = $_.bits;
  $_.e1nb = $get($get($_.ecbs, 0), 0);
  $_.e2nb = $get($get($_.ecbs, 1), 0);
  $_.e3nb = $get($get($_.ecbs, 2), 0);
  $_.e1dcws = $get($get($_.ecbs, 0), 1);
  $_.e2dcws = $get($get($_.ecbs, 1), 1);
  $_.e3dcws = $get($get($_.ecbs, 2), 1);
  $_.e1ecws = $get($get($_.ecbs, 0), 2);
  $_.e2ecws = $get($get($_.ecbs, 1), 2);
  $_.e3ecws = $get($get($_.ecbs, 2), 2);
  $_.pad = $s($_.dmod);
  for (var _Ju = 0, _Jt = $_.pad.length - 1; _Ju <= _Jt; _Ju += 1) {
    $put($_.pad, _Ju, 48);
  }
  $puti($_.pad, 0, $_.msgbits);
  $_.cws = $a($_.dcws);
  for (var _K2 = 0, _K1 = $_.cws.length - 1; _K2 <= _K1; _K2 += 1) {
    $_.c = _K2;
    $_.cwb = $geti($_.pad, $_.c * 8, 8);
    $_.cw = 0;
    for (var _K6 = 0; _K6 <= 7; _K6 += 1) {
      $_.i = _K6;
      $_.cw = $f($_.cw + ~~$pow(2, 8 - $_.i - 1) * ($get($_.cwb, $_.i) - 48));
    }
    $put($_.cws, $_.c, $_.cw);
  }
  $_.rscodes = function() {
    $_.rspm = $k[--$j];
    $_.rsgf = $k[--$j];
    $_.rsnc = $k[--$j];
    $_.rscws = $k[--$j];
    $k[$j++] = Infinity;
    $k[$j++] = 1;
    for (var _KK = 0, _KL = $_.rsgf - 1; _KK < _KL; _KK++) {
      var _KM = $k[$j - 1];
      var _KN = _KM * 2;
      $k[$j++] = _KN;
      if (_KN >= $_.rsgf) {
        var _KQ = $k[--$j];
        $k[$j++] = $xo(_KQ, $_.rspm);
      }
    }
    $_.rsalog = $a();
    $_.rslog = $a($_.rsgf);
    for (var _KW = 1, _KV = $_.rsgf - 1; _KW <= _KV; _KW += 1) {
      $put($_.rslog, $get($_.rsalog, _KW), _KW);
    }
    $_.rsprod = function() {
      var _Ka = $k[$j - 1];
      var _Kb = $k[$j - 2];
      if (_Ka != 0 && _Kb != 0) {
        var _Ke = $get($_.rslog, $k[--$j]);
        var _Kk = $get($_.rsalog, $f(_Ke + $get($_.rslog, $k[--$j])) % ($_.rsgf - 1));
        $k[$j++] = _Kk;
      } else {
        $j -= 2;
        $k[$j++] = 0;
      }
    };
    $k[$j++] = Infinity;
    $k[$j++] = 1;
    for (var _Km = 0, _Kn = $_.rsnc; _Km < _Kn; _Km++) {
      $k[$j++] = 0;
    }
    $_.coeffs = $a();
    for (var _Kr = 1, _Kq = $_.rsnc; _Kr <= _Kq; _Kr += 1) {
      $_.i = _Kr;
      $put($_.coeffs, $_.i, $get($_.coeffs, $_.i - 1));
      for (var _Ky = $_.i - 1; _Ky >= 1; _Ky -= 1) {
        $_.j = _Ky;
        $k[$j++] = $_.coeffs;
        $k[$j++] = $_.j;
        $k[$j++] = $get($_.coeffs, $_.j - 1);
        $k[$j++] = $get($_.coeffs, $_.j);
        $k[$j++] = $get($_.rsalog, $_.i);
        $_.rsprod();
        var _LA = $k[--$j];
        var _LB = $k[--$j];
        var _LC = $k[--$j];
        $put($k[--$j], _LC, $xo(_LB, _LA));
      }
      $k[$j++] = $_.coeffs;
      $k[$j++] = 0;
      $k[$j++] = $get($_.coeffs, 0);
      $k[$j++] = $get($_.rsalog, $_.i);
      $_.rsprod();
      var _LK = $k[--$j];
      var _LL = $k[--$j];
      $put($k[--$j], _LL, _LK);
    }
    $_.nd = $_.rscws.length;
    $k[$j++] = Infinity;
    $aload($_.rscws);
    for (var _LQ = 0, _LR = $_.rsnc; _LQ < _LR; _LQ++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $_.rscws = $a();
    for (var _LV = 0, _LU = $_.nd - 1; _LV <= _LU; _LV += 1) {
      $_.k = $xo($get($_.rscws, _LV), $get($_.rscws, $_.nd));
      for (var _Ld = 0, _Lc = $_.rsnc - 1; _Ld <= _Lc; _Ld += 1) {
        $_.j = _Ld;
        $k[$j++] = $_.rscws;
        $k[$j++] = $_.nd + $_.j;
        $k[$j++] = $get($_.rscws, $_.nd + $_.j + 1);
        $k[$j++] = $_.k;
        $k[$j++] = $get($_.coeffs, $f($_.rsnc - $_.j) - 1);
        $_.rsprod();
        var _Lq = $k[--$j];
        var _Lr = $k[--$j];
        var _Ls = $k[--$j];
        $put($k[--$j], _Ls, $xo(_Lr, _Lq));
      }
    }
    $k[$j++] = $geti($_.rscws, 0, $_.rscws.length - 1);
  };
  $_.dcwsb = $a($f($_.e1nb + $_.e2nb + $_.e3nb));
  $_.ecwsb = $a($_.dcwsb.length);
  $_.in = 0;
  $_.out = 0;
  for (var _M4 = 0, _M5 = $_.e1nb; _M4 < _M5; _M4++) {
    $k[$j++] = $geti($_.cws, $_.in, $_.e1dcws);
    $k[$j++] = $_.e1ecws;
    $k[$j++] = 256;
    $k[$j++] = 355;
    $_.rscodes();
    var _MB = $k[--$j];
    $put($_.dcwsb, $_.out, $geti(_MB, 0, $_.e1dcws));
    $put($_.ecwsb, $_.out, $geti(_MB, $_.e1dcws, $_.e1ecws));
    $_.in = $f($_.in + $_.e1dcws);
    $_.out = $_.out + 1;
  }
  for (var _MP = 0, _MQ = $_.e2nb; _MP < _MQ; _MP++) {
    $k[$j++] = $geti($_.cws, $_.in, $_.e2dcws);
    $k[$j++] = $_.e2ecws;
    $k[$j++] = 256;
    $k[$j++] = 355;
    $_.rscodes();
    var _MW = $k[--$j];
    $put($_.dcwsb, $_.out, $geti(_MW, 0, $_.e2dcws));
    $put($_.ecwsb, $_.out, $geti(_MW, $_.e2dcws, $_.e2ecws));
    $_.in = $f($_.in + $_.e2dcws);
    $_.out = $_.out + 1;
  }
  for (var _Mk = 0, _Ml = $_.e3nb; _Mk < _Ml; _Mk++) {
    $k[$j++] = $geti($_.cws, $_.in, $_.e3dcws);
    $k[$j++] = $_.e3ecws;
    $k[$j++] = 256;
    $k[$j++] = 355;
    $_.rscodes();
    var _Mr = $k[--$j];
    $put($_.dcwsb, $_.out, $geti(_Mr, 0, $_.e3dcws));
    $put($_.ecwsb, $_.out, $geti(_Mr, $_.e3dcws, $_.e3ecws));
    $_.in = $f($_.in + $_.e3dcws);
    $_.out = $_.out + 1;
  }
  $_.cws = $a($_.ncws);
  $_.cw = 0;
  for (var _N8 = 0, _N7 = $_.dcwsb.length - 1; _N8 <= _N7; _N8 += 1) {
    $_.i = _N8;
    var _NB = $get($_.dcwsb, $_.i);
    $puti($_.cws, $_.cw, _NB);
    $_.cw = _NB.length + $_.cw;
    var _NH = $get($_.ecwsb, $_.i);
    $puti($_.cws, $_.cw, _NH);
    $_.cw = _NH.length + $_.cw;
  }
  $k[$j++] = Infinity;
  var _NL = $_.ncws;
  var _NM = 12;
  var _NN = _NL - 1;
  if (_NL - 1 > 12) {
    var _ = _NM;
    _NM = _NN;
    _NN = _;
  }
  for (var _NP = 0, _NO = _NN; _NP <= _NO; _NP += 1) {
    for (var _NS = _NP, _NR = $_.ncws - 1; _NS <= _NR; _NS += 13) {
      $k[$j++] = _NS;
      if (_NS < $_.ncws) {
        var _NW = $get($_.cws, $k[--$j]);
        $k[$j++] = _NW;
      } else {
        $j--;
      }
    }
  }
  $_.cws = $a();
  if ($_.rbit > 0) {
    $_.pad = $a($_.cws.length + 1);
    $puti($_.pad, 0, $_.cws);
    $put($_.pad, $_.pad.length - 1, 0);
    $_.cws = $_.pad;
  }
  var _Nh = $get($_.options, "debugcws") !== void 0;
  if (_Nh) {
    $k[$j++] = "bwipp.debugcws#25872";
    $k[$j++] = $_.cws;
    bwipp_raiseerror();
  }
  $k[$j++] = Infinity;
  for (var _Nl = 0, _Nm = $_.size * $_.size; _Nl < _Nm; _Nl++) {
    $k[$j++] = -1;
  }
  $_.pixs = $a();
  $_.qmv = function() {
    var _Np = $k[--$j];
    var _Nq = $k[--$j];
    $k[$j++] = $f(_Nq + _Np * $_.size);
  };
  if ($_.alnn != 0) {
    $_.trmv = function() {
      var _Nt = $k[--$j];
      var _Nv = $k[--$j];
      $k[$j++] = $f(_Nt * $_.size + $_.size - 1 - _Nv);
    };
    $_.aplot = function() {
      var _Nw = $k[$j - 2];
      var _Nx = $k[$j - 3];
      var _Ny = $k[$j - 1];
      $j -= 3;
      $k[$j++] = _Ny;
      $k[$j++] = _Nx;
      $k[$j++] = _Nw;
      $k[$j++] = _Ny;
      $k[$j++] = _Nw;
      $k[$j++] = _Nx;
      $_.trmv();
      var _O0 = $k[--$j];
      $k[$j++] = $_.pixs;
      $k[$j++] = _O0;
      var _O1 = $k[$j - 3];
      var _O2 = $k[$j - 1];
      $put($k[$j - 2], _O2, _O1);
      $j -= 3;
      $_.trmv();
      var _O5 = $k[--$j];
      $k[$j++] = $_.pixs;
      $k[$j++] = _O5;
      var _O6 = $k[$j - 3];
      var _O7 = $k[$j - 1];
      $put($k[$j - 2], _O7, _O6);
      $j -= 3;
    };
    $_.i = 0;
    $_.stag = 0;
    for (; ; ) {
      if ($_.i >= $_.size) {
        break;
      }
      for (var _OD = 0, _OC = $_.size - 1; _OD <= _OC; _OD += 1) {
        $_.j = _OD;
        if ($f($_.j + $_.alnr) < $_.size) {
          $k[$j++] = (~~($_.j / $_.alnk) + $_.stag) % 2 == 0 && !($_.i == 0 && $_.j < $_.alnk) || $_.j % $_.alnk == 0;
        } else {
          $k[$j++] = $f($_.alnn + $_.stag) % 2 == 0;
        }
        if ($k[--$j]) {
          $k[$j++] = $_.j;
          $k[$j++] = $_.i;
          $k[$j++] = 1;
          $_.aplot();
          var _OU = $_.j;
          var _OV = $_.i;
          $k[$j++] = _OU + 1;
          $k[$j++] = _OV + 1;
          if (_OV + 1 < $_.size && _OU + 1 < $_.size) {
            $k[$j++] = 0;
            $_.aplot();
          } else {
            $j -= 2;
          }
        }
      }
      if ($f($_.i + $_.alnr) == $_.size) {
        $_.i = $f($_.i + $_.alnr) - 1;
      } else {
        $_.i = $f($_.i + $_.alnk);
      }
      $_.stag = 1 - $_.stag;
    }
    for (var _Ok = $_.alnk, _Ol = $_.alnk, _Oj = $_.size - 2; _Ol < 0 ? _Ok >= _Oj : _Ok <= _Oj; _Ok += _Ol) {
      $_.i = _Ok;
      if (~~($_.i / $_.alnk) % 2 != 0) {
        $k[$j++] = $_.pixs;
        $k[$j++] = 0;
        $k[$j++] = $_.i - 1;
        $_.trmv();
        var _Oq = $k[--$j];
        $put($k[--$j], _Oq, 0);
        $k[$j++] = $_.pixs;
        $k[$j++] = 0;
        $k[$j++] = $_.i + 1;
        $_.trmv();
        var _Ou = $k[--$j];
        $put($k[--$j], _Ou, 0);
        $k[$j++] = $_.pixs;
        $k[$j++] = 1;
        $k[$j++] = $_.i - 1;
        $_.trmv();
        var _Oy = $k[--$j];
        $put($k[--$j], _Oy, 0);
        $k[$j++] = $_.pixs;
        $k[$j++] = 1;
        $k[$j++] = $_.i;
        $_.trmv();
        var _P2 = $k[--$j];
        $put($k[--$j], _P2, 0);
        $k[$j++] = $_.pixs;
        $k[$j++] = 1;
        $k[$j++] = $_.i + 1;
        $_.trmv();
        var _P6 = $k[--$j];
        $put($k[--$j], _P6, 0);
        $k[$j++] = $_.pixs;
        $k[$j++] = $_.i - 1;
        $k[$j++] = 0;
        $_.trmv();
        var _PA = $k[--$j];
        $put($k[--$j], _PA, 0);
        $k[$j++] = $_.pixs;
        $k[$j++] = $_.i + 1;
        $k[$j++] = 0;
        $_.trmv();
        var _PE = $k[--$j];
        $put($k[--$j], _PE, 0);
        $k[$j++] = $_.pixs;
        $k[$j++] = $_.i - 1;
        $k[$j++] = 1;
        $_.trmv();
        var _PI = $k[--$j];
        $put($k[--$j], _PI, 0);
        $k[$j++] = $_.pixs;
        $k[$j++] = $_.i;
        $k[$j++] = 1;
        $_.trmv();
        var _PM = $k[--$j];
        $put($k[--$j], _PM, 0);
        $k[$j++] = $_.pixs;
        $k[$j++] = $_.i + 1;
        $k[$j++] = 1;
        $_.trmv();
        var _PQ = $k[--$j];
        $put($k[--$j], _PQ, 0);
      }
      $k[$j++] = $_.pixs;
      $k[$j++] = $_.size - 1;
      $k[$j++] = $_.i - 1;
      $_.trmv();
      var _PV = $k[--$j];
      if ($get($k[--$j], _PV) != 1) {
        $k[$j++] = $_.pixs;
        $k[$j++] = $_.size - 1;
        $k[$j++] = $_.i - 1;
        $_.trmv();
        var _Pb = $k[--$j];
        $put($k[--$j], _Pb, 0);
        $k[$j++] = $_.pixs;
        $k[$j++] = $_.size - 2;
        $k[$j++] = $_.i - 1;
        $_.trmv();
        var _Pg = $k[--$j];
        $put($k[--$j], _Pg, 0);
        $k[$j++] = $_.pixs;
        $k[$j++] = $_.size - 2;
        $k[$j++] = $_.i;
        $_.trmv();
        var _Pl = $k[--$j];
        $put($k[--$j], _Pl, 0);
        $k[$j++] = $_.pixs;
        $k[$j++] = $_.size - 2;
        $k[$j++] = $_.i + 1;
        $_.trmv();
        var _Pq = $k[--$j];
        $put($k[--$j], _Pq, 0);
        $k[$j++] = $_.pixs;
        $k[$j++] = $_.size - 1;
        $k[$j++] = $_.i + 1;
        $_.trmv();
        var _Pv = $k[--$j];
        $put($k[--$j], _Pv, 0);
        $k[$j++] = $_.pixs;
        $k[$j++] = $_.i - 1;
        $k[$j++] = $_.size - 1;
        $_.trmv();
        var _Q0 = $k[--$j];
        $put($k[--$j], _Q0, 0);
        $k[$j++] = $_.pixs;
        $k[$j++] = $_.i - 1;
        $k[$j++] = $_.size - 2;
        $_.trmv();
        var _Q5 = $k[--$j];
        $put($k[--$j], _Q5, 0);
        $k[$j++] = $_.pixs;
        $k[$j++] = $_.i;
        $k[$j++] = $_.size - 2;
        $_.trmv();
        var _QA = $k[--$j];
        $put($k[--$j], _QA, 0);
        $k[$j++] = $_.pixs;
        $k[$j++] = $_.i + 1;
        $k[$j++] = $_.size - 2;
        $_.trmv();
        var _QF = $k[--$j];
        $put($k[--$j], _QF, 0);
        $k[$j++] = $_.pixs;
        $k[$j++] = $_.i + 1;
        $k[$j++] = $_.size - 1;
        $_.trmv();
        var _QK = $k[--$j];
        $put($k[--$j], _QK, 0);
      }
    }
  }
  $_.fpat = $a([$a([1, 1, 1, 1, 1, 1, 1, 0]), $a([1, 0, 0, 0, 0, 0, 0, 0]), $a([1, 0, 1, 1, 1, 1, 1, 0]), $a([1, 0, 1, 0, 0, 0, 0, 0]), $a([1, 0, 1, 0, 1, 1, 1, 0]), $a([1, 0, 1, 0, 1, 1, 1, 0]), $a([1, 0, 1, 0, 1, 1, 1, 0]), $a([0, 0, 0, 0, 0, 0, 0, 0])]);
  $_.fpat2 = $a([$a([1, 1, 1, 0, 1, 0, 1, 0]), $a([1, 1, 1, 0, 1, 0, 1, 0]), $a([1, 1, 1, 0, 1, 0, 1, 0]), $a([0, 0, 0, 0, 1, 0, 1, 0]), $a([1, 1, 1, 1, 1, 0, 1, 0]), $a([0, 0, 0, 0, 0, 0, 1, 0]), $a([1, 1, 1, 1, 1, 1, 1, 0]), $a([0, 0, 0, 0, 0, 0, 0, 0])]);
  for (var _Qh = 0, _Qg = $_.fpat.length - 1; _Qh <= _Qg; _Qh += 1) {
    $_.y = _Qh;
    for (var _Ql = 0, _Qk = $get($_.fpat, 0).length - 1; _Ql <= _Qk; _Ql += 1) {
      $_.x = _Ql;
      $_.fpb = $get($get($_.fpat, $_.y), $_.x);
      $_.fpb2 = $get($get($_.fpat2, $_.y), $_.x);
      $k[$j++] = $_.pixs;
      $k[$j++] = $_.x;
      $k[$j++] = $_.y;
      $_.qmv();
      var _R0 = $k[--$j];
      $put($k[--$j], _R0, $_.fpb);
      $k[$j++] = $_.pixs;
      $k[$j++] = $f($_.size - $_.x) - 1;
      $k[$j++] = $_.y;
      $_.qmv();
      var _R7 = $k[--$j];
      $put($k[--$j], _R7, $_.fpb);
      $k[$j++] = $_.pixs;
      $k[$j++] = $f($_.size - $_.x) - 1;
      $k[$j++] = $f($_.size - $_.y) - 1;
      $_.qmv();
      var _RF = $k[--$j];
      $put($k[--$j], _RF, $_.fpb);
      $k[$j++] = $_.pixs;
      $k[$j++] = $_.x;
      $k[$j++] = $f($_.size - $_.y) - 1;
      $_.qmv();
      var _RM = $k[--$j];
      $put($k[--$j], _RM, $_.fpb2);
    }
  }
  $_.functionmap = $a([$a([$a([0, 8]), $a([$_.size - 1, $_.size - 9])]), $a([$a([1, 8]), $a([$_.size - 2, $_.size - 9])]), $a([$a([2, 8]), $a([$_.size - 3, $_.size - 9])]), $a([$a([3, 8]), $a([$_.size - 4, $_.size - 9])]), $a([$a([4, 8]), $a([$_.size - 5, $_.size - 9])]), $a([$a([5, 8]), $a([$_.size - 6, $_.size - 9])]), $a([$a([6, 8]), $a([$_.size - 7, $_.size - 9])]), $a([$a([7, 8]), $a([$_.size - 8, $_.size - 9])]), $a([$a([8, 8]), $a([$_.size - 9, $_.size - 9])]), $a([$a([8, 7]), $a([$_.size - 9, $_.size - 8])]), $a([$a([8, 6]), $a([$_.size - 9, $_.size - 7])]), $a([$a([8, 5]), $a([$_.size - 9, $_.size - 6])]), $a([$a([8, 4]), $a([$_.size - 9, $_.size - 5])]), $a([$a([8, 3]), $a([$_.size - 9, $_.size - 4])]), $a([$a([8, 2]), $a([$_.size - 9, $_.size - 3])]), $a([$a([8, 1]), $a([$_.size - 9, $_.size - 2])]), $a([$a([8, 0]), $a([$_.size - 9, $_.size - 1])]), $a([$a([$_.size - 9, 0]), $a([8, $_.size - 1])]), $a([$a([$_.size - 9, 1]), $a([8, $_.size - 2])]), $a([$a([$_.size - 9, 2]), $a([8, $_.size - 3])]), $a([$a([$_.size - 9, 3]), $a([8, $_.size - 4])]), $a([$a([$_.size - 9, 4]), $a([8, $_.size - 5])]), $a([$a([$_.size - 9, 5]), $a([8, $_.size - 6])]), $a([$a([$_.size - 9, 6]), $a([8, $_.size - 7])]), $a([$a([$_.size - 9, 7]), $a([8, $_.size - 8])]), $a([$a([$_.size - 9, 8]), $a([8, $_.size - 9])]), $a([$a([$_.size - 8, 8]), $a([7, $_.size - 9])]), $a([$a([$_.size - 7, 8]), $a([6, $_.size - 9])]), $a([$a([$_.size - 6, 8]), $a([5, $_.size - 9])]), $a([$a([$_.size - 5, 8]), $a([4, $_.size - 9])]), $a([$a([$_.size - 4, 8]), $a([3, $_.size - 9])]), $a([$a([$_.size - 3, 8]), $a([2, $_.size - 9])]), $a([$a([$_.size - 2, 8]), $a([1, $_.size - 9])]), $a([$a([$_.size - 1, 8]), $a([0, $_.size - 9])])]);
  var _U9 = $_.functionmap;
  for (var _UA = 0, _UB = _U9.length; _UA < _UB; _UA++) {
    $forall($get(_U9, _UA), function() {
      $aload($k[--$j]);
      $_.qmv();
      $put($_.pixs, $k[--$j], 0);
    });
  }
  var _UM = $a([function() {
    $j -= 2;
    $k[$j++] = 1;
  }, function() {
    var _UG = $k[--$j];
    var _UH = $k[--$j];
    $k[$j++] = $f(_UH + _UG) % 2;
  }, function() {
    var _UI = $k[--$j];
    var _UJ = $k[--$j];
    $k[$j++] = $f((_UI + _UJ) % 3 + _UJ % 3) % 2;
  }, function() {
    var _UK = $k[--$j];
    var _UL = $k[--$j];
    $k[$j++] = $f(_UL % _UK + (_UK % _UL + (_UK % 3 + _UL % 3))) % 2;
  }]);
  $_.maskfuncs = _UM;
  if ($_.mask != -1) {
    $_.maskfuncs = $a([$get($_.maskfuncs, $_.mask - 1)]);
    $_.bestmaskval = $_.mask - 1;
  }
  $_.masks = $a($_.maskfuncs.length);
  for (var _UX = 0, _UW = $_.masks.length - 1; _UX <= _UW; _UX += 1) {
    $_.m = _UX;
    $_.mask = $a($_.size * $_.size);
    for (var _Ud = 0, _Uc = $_.size - 1; _Ud <= _Uc; _Ud += 1) {
      $_.j = _Ud;
      for (var _Ug = 0, _Uf = $_.size - 1; _Ug <= _Uf; _Ug += 1) {
        $_.i = _Ug;
        $k[$j++] = $_.i + 1;
        $k[$j++] = $_.j + 1;
        if ($get($_.maskfuncs, $_.m)() === true) {
          break;
        }
        var _Um = $k[--$j];
        $k[$j++] = _Um == 0;
        $k[$j++] = $_.pixs;
        $k[$j++] = $_.i;
        $k[$j++] = $_.j;
        $_.qmv();
        var _Uq = $k[--$j];
        var _Us = $get($k[--$j], _Uq);
        var _Ut = $k[--$j];
        var _Uu = _Ut && _Us == -1 ? 1 : 0;
        $k[$j++] = _Uu;
        $k[$j++] = $_.mask;
        $k[$j++] = $_.i;
        $k[$j++] = $_.j;
        $_.qmv();
        var _Uy = $k[$j - 3];
        var _Uz = $k[$j - 1];
        $put($k[$j - 2], _Uz, _Uy);
        $j -= 3;
      }
    }
    $put($_.masks, $_.m, $_.mask);
  }
  $_.posx = 0;
  $_.posy = 0;
  $_.num = 0;
  for (; ; ) {
    if ($_.posy == $_.size) {
      break;
    }
    $k[$j++] = $_.pixs;
    $k[$j++] = $_.posx;
    $k[$j++] = $_.posy;
    $_.qmv();
    var _V9 = $k[--$j];
    if ($get($k[--$j], _V9) == -1) {
      var _VE = $get($_.cws, ~~($_.num / 8));
      var _VG = -(7 - $_.num % 8);
      $k[$j++] = (_VG < 0 ? _VE >>> -_VG : _VE << _VG) & 1;
      $k[$j++] = $_.pixs;
      $k[$j++] = $_.posx;
      $k[$j++] = $_.posy;
      $_.qmv();
      var _VK = $k[$j - 3];
      var _VL = $k[$j - 1];
      $put($k[$j - 2], _VL, _VK);
      $j -= 3;
      $_.num = $_.num + 1;
    }
    $_.posx = $_.posx + 1;
    if ($_.posx == $_.size) {
      $_.posx = 0;
      $_.posy = $_.posy + 1;
    }
  }
  $_.evalfulln1n3 = function() {
    $_.scrle = $k[--$j];
    $k[$j++] = "scr1";
    $k[$j++] = 0;
    $forall($_.scrle, function() {
      var _VU = $k[$j - 1];
      if (_VU >= 3) {
        var _VV = $k[--$j];
        var _VX = $f($k[--$j] + _VV * 4);
        $k[$j++] = _VX;
        $k[$j++] = _VX;
      }
      $j--;
    });
    var _VY = $k[--$j];
    $_[$k[--$j]] = _VY;
    $_.scr3 = 0;
    for (var _Vc = 5, _Vb = $_.scrle.length - 1; _Vc <= _Vb; _Vc += 2) {
      $_.j = _Vc;
      if ($get($_.scrle, $_.j) % 3 == 0) {
        $_.fact = ~~($get($_.scrle, $_.j) / 3);
        var _Vl = $geti($_.scrle, $_.j - 4, 4);
        for (var _Vm = 0, _Vn = _Vl.length; _Vm < _Vn; _Vm++) {
          $k[$j++] = $get(_Vl, _Vm) == $_.fact;
        }
        var _Vq = $k[--$j];
        var _Vr = $k[--$j];
        var _Vs = $k[--$j];
        if ($k[--$j] && (_Vs && (_Vr && _Vq))) {
          if ($_.j == 5 || $_.j + 2 >= $_.scrle.length) {
            $_.scr3 = $_.scr3 + 50;
          } else {
            if ($get($_.scrle, $_.j - 5) >= 3 || $get($_.scrle, $_.j + 1) >= 3) {
              $_.scr3 = $_.scr3 + 50;
            }
          }
        }
      }
    }
    for (var _W7 = 1, _W6 = $_.scrle.length - 5; _W7 <= _W6; _W7 += 2) {
      $_.j = _W7;
      if ($get($_.scrle, $_.j) % 3 == 0) {
        $_.fact = ~~($get($_.scrle, $_.j) / 3);
        var _WG = $geti($_.scrle, $_.j + 1, 4);
        for (var _WH = 0, _WI = _WG.length; _WH < _WI; _WH++) {
          $k[$j++] = $get(_WG, _WH) == $_.fact;
        }
        var _WL = $k[--$j];
        var _WM = $k[--$j];
        var _WN = $k[--$j];
        if ($k[--$j] && (_WN && (_WM && _WL))) {
          if ($_.j == 1 || $_.j + 6 >= $_.scrle.length) {
            $_.scr3 = $_.scr3 + 50;
          } else {
            if ($get($_.scrle, $_.j - 1) >= 3 || $get($_.scrle, $_.j + 5) >= 3) {
              $_.scr3 = $_.scr3 + 50;
            }
          }
        }
      }
    }
    $k[$j++] = $_.scr1;
    $k[$j++] = $_.scr3;
  };
  $_.evalfull = function() {
    $_.sym = $k[--$j];
    $_.n1 = 0;
    $_.n3 = 0;
    $_.rle = $a($_.size + 1);
    $_.lastpairs = $a($_.size);
    $_.thispairs = $a($_.size);
    $_.sizeadd1 = $_.size + 1;
    for (var _Wm = 0, _Wl = $_.size - 1; _Wm <= _Wl; _Wm += 1) {
      $_.i = _Wm;
      $k[$j++] = Infinity;
      var _Wo = $_.size;
      $k[$j++] = 0;
      $k[$j++] = 0;
      for (var _Wq = $_.i, _Wr = _Wo, _Wp = _Wo * _Wo - 1; _Wr < 0 ? _Wq >= _Wp : _Wq <= _Wp; _Wq += _Wr) {
        var _Wt = $get($_.sym, _Wq);
        var _Wu = $k[--$j];
        $k[$j++] = _Wt;
        if ($eq(_Wu, _Wt)) {
          var _Wv = $k[--$j];
          var _Ww = $k[--$j];
          $k[$j++] = _Ww + 1;
          $k[$j++] = _Wv;
        } else {
          var _Wx = $k[--$j];
          $k[$j++] = 1;
          $k[$j++] = _Wx;
        }
      }
      $j--;
      var _Wz = $counttomark() + 2;
      $astore($geti($_.rle, 0, _Wz - 2));
      $_.evalfulln1n3();
      $_.n3 = $f($k[--$j] + $_.n3);
      $_.n1 = $f($k[--$j] + $_.n1);
      $j--;
      $_.symrow = $geti($_.sym, $_.i * $_.size, $_.size);
      $k[$j++] = Infinity;
      var _XA = $_.symrow;
      $k[$j++] = 0;
      $k[$j++] = 0;
      for (var _XB = 0, _XC = _XA.length; _XB < _XC; _XB++) {
        var _XD = $get(_XA, _XB);
        var _XE = $k[--$j];
        $k[$j++] = _XD;
        if ($eq(_XE, _XD)) {
          var _XF = $k[--$j];
          var _XG = $k[--$j];
          $k[$j++] = _XG + 1;
          $k[$j++] = _XF;
        } else {
          var _XH = $k[--$j];
          $k[$j++] = 1;
          $k[$j++] = _XH;
        }
      }
      $j--;
      var _XJ = $counttomark() + 2;
      $astore($geti($_.rle, 0, _XJ - 2));
      $_.evalfulln1n3();
      $_.n3 = $f($k[--$j] + $_.n3);
      $_.n1 = $f($k[--$j] + $_.n1);
      $j--;
    }
    $k[$j++] = $f($_.n1 + $_.n3);
  };
  $_.bestscore = 999999999;
  for (var _XT = 0, _XS = $_.masks.length - 1; _XT <= _XS; _XT += 1) {
    $_.m = _XT;
    $_.masksym = $a($_.size * $_.size);
    for (var _Xa = 0, _XZ = $_.size * $_.size - 1; _Xa <= _XZ; _Xa += 1) {
      $_.i = _Xa;
      $put($_.masksym, $_.i, $xo($get($_.pixs, $_.i), $get($get($_.masks, $_.m), $_.i)));
    }
    if ($_.masks.length != 1) {
      $k[$j++] = $_.masksym;
      $_.evalfull();
      $_.score = $k[--$j];
      if ($_.score < $_.bestscore) {
        $_.bestsym = $_.masksym;
        $_.bestmaskval = $_.m;
        $_.bestscore = $_.score;
      }
    } else {
      $_.bestsym = $_.masksym;
    }
  }
  $_.pixs = $_.bestsym;
  $_.funval = ((~~(($_.size - 21) / 2) + 20) * 4 + $_.eclval) * 4 + $_.bestmaskval;
  $k[$j++] = $a([($_.funval & 3840) >>> 8, ($_.funval & 240) >>> 4, $_.funval & 15]);
  $k[$j++] = 4;
  $k[$j++] = 16;
  $k[$j++] = 19;
  $_.rscodes();
  $_.funvals = $k[--$j];
  $k[$j++] = Infinity;
  $forall($_.funvals, function() {
    $k[$j++] = 4;
    $_.tobin();
    $forall($k[--$j], function() {
      var _Y5 = $k[--$j];
      $k[$j++] = _Y5 - 48;
    });
  });
  $k[$j++] = 0;
  $k[$j++] = 1;
  $k[$j++] = 0;
  $k[$j++] = 1;
  $k[$j++] = 0;
  $k[$j++] = 1;
  $_.funbits = $a();
  for (var _Y9 = 0, _Y8 = $_.functionmap.length - 1; _Y9 <= _Y8; _Y9 += 1) {
    $_.i = _Y9;
    $forall($get($_.functionmap, $_.i), function() {
      var _YE = $k[--$j];
      $k[$j++] = $_.pixs;
      $aload(_YE);
      $_.qmv();
      var _YI = $k[--$j];
      $put($k[--$j], _YI, $get($_.funbits, $_.i));
    });
  }
  var _YQ = /* @__PURE__ */ new Map([
    ["ren", "renmatrix"],
    ["pixs", $_.pixs],
    ["pixx", $_.size],
    ["pixy", $_.size],
    ["height", $_.size * 2 / 72],
    ["width", $_.size * 2 / 72],
    ["borderleft", 3],
    ["borderright", 3],
    ["bordertop", 3],
    ["borderbottom", 3],
    ["opt", $_.options]
  ]);
  $k[$j++] = _YQ;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_dotcode() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.rows = -1;
  $_.columns = -1;
  $_.ratio = -1;
  $_.parse = false;
  $_.parsefnc = false;
  $_.raw = false;
  $_.fast = false;
  $_.mask = -1;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.rows != -1) {
    if ($_.rows < 5) {
      $k[$j++] = "bwipp.dotcodeBadRows#26228";
      $k[$j++] = "There must be at least 5 rows";
      bwipp_raiseerror();
    }
  }
  if ($_.columns != -1) {
    if ($_.columns < 5) {
      $k[$j++] = "bwipp.dotcodeBadColumns#26234";
      $k[$j++] = "There must be at least 5 columns";
      bwipp_raiseerror();
    }
  }
  if ($_.rows != -1 && $_.columns != -1 && ($_.rows + $_.columns) % 2 != 1) {
    $k[$j++] = "bwipp.dotcodeRowsColumnsBadParity#26239";
    $k[$j++] = "Sum of rows and columns must be odd";
    bwipp_raiseerror();
  }
  if ($_.ratio == -1 && $_.rows == -1 && $_.columns == -1) {
    $_.ratio = 3 / 2;
  }
  if ($_.ratio != -1) {
    if ($_.ratio <= 0) {
      $k[$j++] = "bwipp.dotcodeRatio#26248";
      $k[$j++] = "The ratio must be greater than 0";
      bwipp_raiseerror();
    }
  }
  if ($_.mask != -1) {
    if ($_.mask < 0 || $_.mask > 3) {
      $k[$j++] = "bwipp.dotcodeBadMask#26254";
      $k[$j++] = "Valid mask values are 0 to 3";
      bwipp_raiseerror();
    }
  }
  $_.laa = -1;
  $_.lab = -2;
  $_.lac = -3;
  $_.bin = -4;
  $_.sfa = -5;
  $_.sfb = -6;
  $_.sb2 = -7;
  $_.sb3 = -8;
  $_.sb4 = -9;
  $_.sb5 = -10;
  $_.sb6 = -11;
  $_.sfc = -12;
  $_.sc2 = -13;
  $_.sc3 = -14;
  $_.sc4 = -15;
  $_.sc5 = -16;
  $_.sc6 = -17;
  $_.sc7 = -18;
  $_.bsa = -19;
  $_.bsb = -20;
  $_.tma = -21;
  $_.tmb = -22;
  $_.tmc = -23;
  $_.tms = -24;
  $_.fn1 = -25;
  $_.fn2 = -26;
  $_.fn3 = -27;
  $_.crl = -28;
  $_.aim = -29;
  $_.m05 = -30;
  $_.m06 = -31;
  $_.m12 = -32;
  $_.mac = -33;
  var _N = /* @__PURE__ */ new Map([
    ["parse", $_.parse],
    ["parsefnc", $_.parsefnc],
    ["eci", true],
    ["FNC1", $_.fn1],
    ["FNC3", $_.fn3]
  ]);
  $_.fncvals = _N;
  $k[$j++] = "msg";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.fncvals;
  bwipp_parseinput();
  var _Q = $k[--$j];
  $_[$k[--$j]] = _Q;
  $_.msglen = $_.msg.length;
  var _T = $_.msg;
  $k[$j++] = "numecis";
  $k[$j++] = 0;
  for (var _U = 0, _V = _T.length; _U < _V; _U++) {
    if ($get(_T, _U) <= -1e6) {
      var _X = $k[--$j];
      $k[$j++] = _X + 1;
    }
  }
  var _Y = $k[--$j];
  $_[$k[--$j]] = _Y;
  $_.msgtmp = $a($f($_.msg.length + $_.numecis * 6));
  $_.j = 0;
  for (var _f = 0, _e = $_.msg.length - 1; _f <= _e; _f += 1) {
    var _h = $get($_.msg, _f);
    $k[$j++] = _h;
    if (_h <= -1e6) {
      var _l = $geti($cvrs($s(7), -$k[--$j], 10), 1, 6);
      for (var _m = 0, _n = _l.length; _m < _n; _m++) {
        $k[$j++] = $get(_l, _m);
      }
      $astore($a(6));
      $puti($_.msgtmp, $_.j + 1, $k[--$j]);
      $put($_.msgtmp, $_.j, $_.fn2);
      $_.j = $_.j + 7;
    } else {
      $put($_.msgtmp, $_.j, $k[--$j]);
      $_.j = $_.j + 1;
    }
  }
  $_.msg = $_.msgtmp;
  $_.msglen = $_.msg.length;
  $_.charmaps = $a([$a([32, 32, "00"]), $a(["!", "!", "01"]), $a(['"', '"', "02"]), $a(["#", "#", "03"]), $a(["$", "$", "04"]), $a(["%", "%", "05"]), $a(["&", "&", "06"]), $a(["'", "'", "07"]), $a([40, 40, "08"]), $a([41, 41, "09"]), $a(["*", "*", "10"]), $a(["+", "+", "11"]), $a([",", ",", "12"]), $a(["-", "-", "13"]), $a([".", ".", "14"]), $a(["/", "/", "15"]), $a(["0", "0", "16"]), $a(["1", "1", "17"]), $a(["2", "2", "18"]), $a(["3", "3", "19"]), $a(["4", "4", "20"]), $a(["5", "5", "21"]), $a(["6", "6", "22"]), $a(["7", "7", "23"]), $a(["8", "8", "24"]), $a(["9", "9", "25"]), $a([":", ":", "26"]), $a([";", ";", "27"]), $a(["<", "<", "28"]), $a(["=", "=", "29"]), $a([">", ">", "30"]), $a(["?", "?", "31"]), $a(["@", "@", "32"]), $a(["A", "A", "33"]), $a(["B", "B", "34"]), $a(["C", "C", "35"]), $a(["D", "D", "36"]), $a(["E", "E", "37"]), $a(["F", "F", "38"]), $a(["G", "G", "39"]), $a(["H", "H", "40"]), $a(["I", "I", "41"]), $a(["J", "J", "42"]), $a(["K", "K", "43"]), $a(["L", "L", "44"]), $a(["M", "M", "45"]), $a(["N", "N", "46"]), $a(["O", "O", "47"]), $a(["P", "P", "48"]), $a(["Q", "Q", "49"]), $a(["R", "R", "50"]), $a(["S", "S", "51"]), $a(["T", "T", "52"]), $a(["U", "U", "53"]), $a(["V", "V", "54"]), $a(["W", "W", "55"]), $a(["X", "X", "56"]), $a(["Y", "Y", "57"]), $a(["Z", "Z", "58"]), $a(["[", "[", "59"]), $a([92, 92, "60"]), $a(["]", "]", "61"]), $a(["^", "^", "62"]), $a(["_", "_", "63"]), $a([0, "`", "64"]), $a([1, "a", "65"]), $a([2, "b", "66"]), $a([3, "c", "67"]), $a([4, "d", "68"]), $a([5, "e", "69"]), $a([6, "f", "70"]), $a([7, "g", "71"]), $a([8, "h", "72"]), $a([9, "i", "73"]), $a([10, "j", "74"]), $a([11, "k", "75"]), $a([12, "l", "76"]), $a([13, "m", "77"]), $a([14, "n", "78"]), $a([15, "o", "79"]), $a([16, "p", "80"]), $a([17, "q", "81"]), $a([18, "r", "82"]), $a([19, "s", "83"]), $a([20, "t", "84"]), $a([21, "u", "85"]), $a([22, "v", "86"]), $a([23, "w", "87"]), $a([24, "x", "88"]), $a([25, "y", "89"]), $a([26, "z", "90"]), $a([27, "{", "91"]), $a([28, "|", "92"]), $a([29, "}", "93"]), $a([30, "~", "94"]), $a([31, 127, "95"]), $a([$_.sfb, $_.crl, "96"]), $a([$_.sb2, 9, "97"]), $a([$_.sb3, 28, "98"]), $a([$_.sb4, 29, "99"]), $a([$_.sb5, 30, $_.aim]), $a([$_.sb6, $_.sfa, $_.laa]), $a([$_.lab, $_.laa, $_.sfb]), $a([$_.sc2, $_.sc2, $_.sb2]), $a([$_.sc3, $_.sc3, $_.sb3]), $a([$_.sc4, $_.sc4, $_.sb4]), $a([$_.lac, $_.lac, $_.lab]), $a([$_.fn1, $_.fn1, $_.fn1]), $a([$_.fn2, $_.fn2, $_.fn2]), $a([$_.fn3, $_.fn3, $_.fn3]), $a([$_.bsa, $_.bsa, $_.bsa]), $a([$_.bsb, $_.bsb, $_.bsb]), $a([$_.bin, $_.bin, $_.bin])]);
  $_.charvals = $a([/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map()]);
  for (var _3d = 0, _3c = $_.charmaps.length - 1; _3d <= _3c; _3d += 1) {
    $_.i = _3d;
    $_.encs = $get($_.charmaps, $_.i);
    for (var _3h = 0; _3h <= 2; _3h += 1) {
      $_.j = _3h;
      var _3k = $get($_.encs, $_.j);
      $k[$j++] = _3k;
      if ($eq($type(_3k), "stringtype")) {
        var _3n = $get($k[--$j], 0);
        $k[$j++] = _3n;
      }
      $put($get($_.charvals, $_.j), $k[--$j], $_.i);
    }
  }
  $_.Avals = $get($_.charvals, 0);
  $_.Bvals = $get($_.charvals, 1);
  $put($_.Bvals, $_.m05, 97);
  $put($_.Bvals, $_.m06, 98);
  $put($_.Bvals, $_.m12, 99);
  $put($_.Bvals, $_.mac, 100);
  $_.Cvals = $get($_.charvals, 2);
  $k[$j++] = Infinity;
  var _4H = $a([$_.sc2, $_.sc3, $_.sc4, $_.sc5, $_.sc6, $_.sc7, $_.tma, $_.tmb, $_.tmc, $_.tms]);
  $k[$j++] = 102;
  for (var _4I = 0, _4J = _4H.length; _4I < _4J; _4I++) {
    var _4M = $k[--$j] + 1;
    $k[$j++] = $get(_4H, _4I);
    $k[$j++] = _4M;
    $k[$j++] = _4M;
  }
  $j--;
  $_.BINvals = $d();
  $_.A = 0;
  $_.B = 1;
  $_.C = 2;
  $_.BIN = 3;
  $k[$j++] = Infinity;
  for (var _4Q = 0, _4R = $_.msglen + 1; _4Q < _4R; _4Q++) {
    $k[$j++] = 0;
  }
  $_.nDigits = $a();
  $k[$j++] = Infinity;
  for (var _4U = 0, _4V = $_.msglen + 1; _4U < _4V; _4U++) {
    $k[$j++] = false;
  }
  $_.SeventeenTen = $a();
  $k[$j++] = Infinity;
  for (var _4Y = 0, _4Z = $_.msglen + 1; _4Y < _4Z; _4Y++) {
    $k[$j++] = false;
  }
  $_.ECI = $a();
  $k[$j++] = Infinity;
  for (var _4c = 0, _4d = $_.msglen + 1; _4c < _4d; _4c++) {
    $k[$j++] = false;
  }
  $_.DatumA = $a();
  $k[$j++] = Infinity;
  for (var _4g = 0, _4h = $_.msglen + 1; _4g < _4h; _4g++) {
    $k[$j++] = false;
  }
  $_.DatumB = $a();
  $k[$j++] = Infinity;
  for (var _4k = 0, _4l = $_.msglen + 1; _4k < _4l; _4k++) {
    $k[$j++] = false;
  }
  $_.DatumC = $a();
  $k[$j++] = Infinity;
  for (var _4o = 0, _4p = $_.msglen + 8; _4o < _4p; _4o++) {
    $k[$j++] = false;
  }
  $_.Binary = $a();
  $k[$j++] = Infinity;
  for (var _4s = 0, _4t = $_.msglen + 1; _4s < _4t; _4s++) {
    $k[$j++] = 0;
  }
  $_.AheadC = $a();
  $k[$j++] = Infinity;
  for (var _4w = 0, _4x = $_.msglen + 1; _4w < _4x; _4w++) {
    $k[$j++] = 0;
  }
  $_.TryC = $a();
  $k[$j++] = Infinity;
  for (var _50 = 0, _51 = $_.msglen + 1; _50 < _51; _50++) {
    $k[$j++] = 0;
  }
  $_.AheadA = $a();
  $k[$j++] = Infinity;
  for (var _54 = 0, _55 = $_.msglen + 1; _54 < _55; _54++) {
    $k[$j++] = 0;
  }
  $_.AheadB = $a();
  $k[$j++] = Infinity;
  for (var _58 = 0, _59 = $_.msglen + 1; _58 < _59; _58++) {
    $k[$j++] = 0;
  }
  $_.UntilEndSeg = $a();
  for (var _5C = $_.msglen - 1; _5C >= 0; _5C -= 1) {
    $_.i = _5C;
    $_.barchar = $get($_.msg, $_.i);
    if ($_.barchar >= 48 && $_.barchar <= 57) {
      $put($_.nDigits, $_.i, $get($_.nDigits, $_.i + 1) + 1);
    }
    var _5P = $get($_.Avals, $_.barchar) !== void 0;
    if (_5P) {
      $put($_.DatumA, $_.i, true);
    }
    var _5U = $get($_.Bvals, $_.barchar) !== void 0;
    if (_5U) {
      $put($_.DatumB, $_.i, true);
    }
    $_.CRLF = false;
    if ($_.barchar == 13 && $_.i < $_.msglen - 1) {
      if ($get($_.msg, $_.i + 1) == 10) {
        $_.CRLF = true;
      }
    }
    if ($_.CRLF) {
      $put($_.DatumB, $_.i, true);
    }
    if ($get($_.nDigits, $_.i) >= 2) {
      $put($_.DatumC, $_.i, true);
    }
    if ($_.barchar < 0) {
      $put($_.DatumC, $_.i, true);
    }
    if ($_.barchar >= 128) {
      $put($_.Binary, $_.i, true);
    }
    if ($get($_.nDigits, $_.i) >= 10) {
      $k[$j++] = Infinity;
      $aload($geti($_.msg, $_.i, 10));
      for (var _5x = 0; _5x < 1; _5x++) {
        if ($k[--$j] != 48) {
          $k[$j++] = false;
          break;
        }
        if ($k[--$j] != 49) {
          $k[$j++] = false;
          break;
        }
        $j -= 6;
        if ($k[--$j] != 55) {
          $k[$j++] = false;
          break;
        }
        if ($k[--$j] != 49) {
          $k[$j++] = false;
          break;
        }
        $k[$j++] = true;
      }
      $k[$j++] = $_.SeventeenTen;
      $k[$j++] = $_.i;
      var _64 = $k[$j - 3];
      var _65 = $k[$j - 1];
      $put($k[$j - 2], _65, _64);
      $j -= 3;
      $cleartomark();
    }
    if ($get($_.nDigits, $_.i + 1) >= 6 && $get($_.msg, $_.i) == $_.fn2) {
      $put($_.ECI, $_.i, true);
    }
    if ($_.barchar < 0 && $_.barchar != $_.fn3) {
      $put($_.AheadC, $_.i, $get($_.AheadC, $_.i + 1) + 1);
    } else {
      if ($get($_.nDigits, $_.i) <= 1) {
        $put($_.AheadC, $_.i, 0);
      } else {
        $put($_.AheadC, $_.i, $get($_.AheadC, $_.i + 2) + 1);
      }
    }
    if ($get($_.nDigits, $_.i) > 0 && $gt($get($_.AheadC, $_.i), $get($_.AheadC, $_.i + 1))) {
      $put($_.TryC, $_.i, $get($_.AheadC, $_.i));
    }
    if ($get($_.DatumA, $_.i) && $get($_.TryC, $_.i) < 2 && $_.barchar != $_.fn3) {
      $put($_.AheadA, $_.i, $get($_.AheadA, $_.i + 1) + 1);
    }
    if ($get($_.DatumB, $_.i) && $get($_.TryC, $_.i) < 2 && $_.barchar != $_.fn3) {
      $k[$j++] = $_.AheadB;
      $k[$j++] = $_.i;
      $k[$j++] = $_.AheadB;
      $k[$j++] = $_.i + 1;
      if ($_.CRLF) {
        var _7C = $k[--$j];
        $k[$j++] = _7C + 1;
      }
      var _7D = $k[--$j];
      var _7F = $get($k[--$j], _7D);
      var _7G = $k[--$j];
      $put($k[--$j], _7G, _7F + 1);
    }
    if ($_.barchar != $_.fn3) {
      $put($_.UntilEndSeg, $_.i, $get($_.UntilEndSeg, $_.i + 1) + 1);
    }
  }
  $_.addtocws = function() {
    var _7P = $k[--$j];
    $puti($_.cws, $_.j, _7P);
    $_.j = _7P.length + $_.j;
  };
  $_.base259to103 = function() {
    $_.in = $k[--$j];
    $_.inlen = $_.in.length;
    $k[$j++] = Infinity;
    for (var _7W = 0, _7X = 5 - $_.inlen; _7W < _7X; _7W++) {
      $k[$j++] = 0;
    }
    $aload($_.in);
    $_.in = $a();
    $_.out = $a(6);
    $k[$j++] = Infinity;
    $aload($geti($_.in, 0, 2));
    $_.msbs = $a();
    $k[$j++] = Infinity;
    $aload($_.msbs);
    var _7f = $k[--$j];
    var _7g = $k[--$j];
    $k[$j++] = $f(_7f + _7g * 259);
    for (var _7h = 0; _7h < 2; _7h++) {
      var _7i = $k[--$j];
      $k[$j++] = _7i % 103;
      $k[$j++] = ~~(_7i / 103);
    }
    $_.mscs = $a();
    $k[$j++] = Infinity;
    $aload($geti($_.in, 2, 3));
    $_.lsbs = $a();
    $k[$j++] = Infinity;
    $aload($_.lsbs);
    var _7o = $k[--$j];
    var _7p = $k[--$j];
    var _7q = $k[--$j];
    $k[$j++] = $f(_7o + _7p * 259 + _7q * 67081);
    for (var _7r = 0; _7r < 3; _7r++) {
      var _7s = $k[--$j];
      $k[$j++] = _7s % 103;
      $k[$j++] = ~~(_7s / 103);
    }
    $_.lscs = $a();
    var _7v = $get($_.lscs, 0);
    var _7x = $get($_.mscs, 0);
    $put($_.out, 5, $f(_7v + _7x * 42) % 103);
    var _80 = $get($_.lscs, 1);
    var _82 = $get($_.mscs, 0);
    var _84 = $get($_.mscs, 1);
    $put($_.out, 4, $f(~~((_7v + _7x * 42) / 103) + _80 + _82 * 68 + _84 * 42) % 103);
    var _87 = $get($_.lscs, 2);
    var _89 = $get($_.mscs, 0);
    var _8B = $get($_.mscs, 1);
    var _8D = $get($_.mscs, 2);
    $put($_.out, 3, $f(~~((~~((_7v + _7x * 42) / 103) + _80 + _82 * 68 + _84 * 42) / 103) + _87 + _89 * 92 + _8B * 68 + _8D * 42) % 103);
    var _8G = $get($_.lscs, 3);
    var _8I = $get($_.mscs, 0);
    var _8K = $get($_.mscs, 1);
    var _8M = $get($_.mscs, 2);
    $put($_.out, 2, $f(~~((~~((~~((_7v + _7x * 42) / 103) + _80 + _82 * 68 + _84 * 42) / 103) + _87 + _89 * 92 + _8B * 68 + _8D * 42) / 103) + _8G + _8I * 15 + _8K * 92 + _8M * 68) % 103);
    var _8P = $get($_.mscs, 1);
    var _8R = $get($_.mscs, 2);
    $put($_.out, 1, $f(~~((~~((~~((~~((_7v + _7x * 42) / 103) + _80 + _82 * 68 + _84 * 42) / 103) + _87 + _89 * 92 + _8B * 68 + _8D * 42) / 103) + _8G + _8I * 15 + _8K * 92 + _8M * 68) / 103) + _8P * 15 + _8R * 92) % 103);
    $put($_.out, 0, $f(~~((~~((~~((~~((~~((_7v + _7x * 42) / 103) + _80 + _82 * 68 + _84 * 42) / 103) + _87 + _89 * 92 + _8B * 68 + _8D * 42) / 103) + _8G + _8I * 15 + _8K * 92 + _8M * 68) / 103) + _8P * 15 + _8R * 92) / 103) + $get($_.mscs, 2) * 15) % 103);
    $k[$j++] = $geti($_.out, 6 - $_.inlen - 1, $_.inlen + 1);
  };
  $_.finaliseBIN = function() {
    if ($_.bpos != 0) {
      $k[$j++] = $geti($_.bvals, 0, $_.bpos);
      $_.base259to103();
      $aload($k[--$j]);
      $_.bpos = 0;
    }
  };
  $_.addtobin = function() {
    $put($_.bvals, $_.bpos, $k[--$j]);
    $_.bpos = $_.bpos + 1;
    if ($_.bpos == 5) {
      $_.finaliseBIN();
    }
  };
  $_.ECIabc = function() {
    var _8m = $geti($_.msg, $_.i + 1, 6);
    $k[$j++] = 0;
    for (var _8n = 0, _8o = _8m.length; _8n < _8o; _8n++) {
      var _8q = $k[--$j];
      $k[$j++] = $f(_8q + ($get(_8m, _8n) - 48)) * 10;
    }
    var _8s = ~~($k[--$j] / 10);
    $k[$j++] = _8s;
    if (_8s >= 40) {
      var _8u = $k[--$j] - 40;
      var _8v = _8u % 12769;
      $k[$j++] = ~~(_8u / 12769) + 40;
      $k[$j++] = ~~(_8v / 113);
      $k[$j++] = _8v % 113;
    }
  };
  $_.ECIbin = function() {
    $k[$j++] = Infinity;
    var _8y = $geti($_.msg, $_.i + 1, 6);
    $k[$j++] = 0;
    for (var _8z = 0, _90 = _8y.length; _8z < _90; _8z++) {
      var _92 = $k[--$j];
      $k[$j++] = $f(_92 + ($get(_8y, _8z) - 48)) * 10;
    }
    var _94 = ~~($k[--$j] / 10);
    $k[$j++] = _94;
    if (_94 >= 65536) {
      var _95 = $k[--$j];
      var _96 = _95 % 65536;
      $k[$j++] = 258;
      $k[$j++] = ~~(_95 / 65536);
      $k[$j++] = ~~(_96 / 256);
      $k[$j++] = _96 % 256;
    } else {
      var _97 = $k[$j - 1];
      if (_97 >= 256) {
        var _98 = $k[--$j];
        $k[$j++] = 257;
        $k[$j++] = ~~(_98 / 256);
        $k[$j++] = _98 % 256;
      } else {
        var _99 = $k[--$j];
        $k[$j++] = 256;
        $k[$j++] = _99;
      }
    }
    var _9A = $a();
    for (var _9B = 0, _9C = _9A.length; _9B < _9C; _9B++) {
      $k[$j++] = $get(_9A, _9B);
      $_.addtobin();
    }
  };
  $_.encC = function() {
    for (var _9E = 0; _9E < 1; _9E++) {
      if ($_.i == $_.segstart) {
        for (var _9H = 0; _9H < 1; _9H++) {
          if ($_.i > $_.segend - 7) {
            $k[$j++] = 0;
            break;
          }
          if ($get($_.msg, $_.segstart) != 91) {
            $k[$j++] = 0;
            break;
          }
          if ($get($_.msg, $_.segstart + 1) != 41) {
            $k[$j++] = 0;
            break;
          }
          if ($get($_.msg, $_.segstart + 2) != 62) {
            $k[$j++] = 0;
            break;
          }
          if ($get($_.msg, $_.segstart + 3) != 30) {
            $k[$j++] = 0;
            break;
          }
          var _9Y = $get($_.msg, $_.segstart + 4);
          if (_9Y < 48 || _9Y > 57) {
            $k[$j++] = 0;
            break;
          }
          var _9b = $get($_.msg, $_.segstart + 5);
          if (_9b < 48 || _9b > 57) {
            $k[$j++] = 0;
            break;
          }
          if ($get($_.msg, $_.segend - 1) != 4) {
            $k[$j++] = 0;
            break;
          }
          var _9l = $f(($get($_.msg, $_.segstart + 4) - 48) * 10 + ($get($_.msg, $_.segstart + 5) - 48));
          $k[$j++] = _9l;
          if (_9l != 5 && (_9l != 6 && _9l != 12)) {
            $k[$j - 1] = $_.mac;
            break;
          }
          if ($get($_.msg, $_.segstart + 6) != 29) {
            $k[$j - 1] = 0;
            break;
          }
          if ($get($_.msg, $_.segend - 2) != 30) {
            $k[$j - 1] = 0;
            break;
          }
          var _9t = $k[$j - 1];
          if (_9t == 5) {
            $k[$j - 1] = $_.m05;
            break;
          }
          if ($k[--$j] == 6) {
            $k[$j++] = $_.m06;
            break;
          }
          $k[$j++] = $_.m12;
          break;
        }
        $_.inmac = $k[--$j];
        if ($_.inmac != 0) {
          $k[$j++] = $a([$get($_.Cvals, $_.lab)]);
          $_.addtocws();
          $_.mode = $_.B;
          $k[$j++] = $a([$get($_.Bvals, $_.inmac)]);
          $_.addtocws();
          if ($_.inmac == $_.mac) {
            $k[$j++] = $a([$get($_.Bvals, $get($_.msg, $_.segstart + 4))]);
            $_.addtocws();
            $k[$j++] = $a([$get($_.Bvals, $get($_.msg, $_.segstart + 5))]);
            $_.addtocws();
            $_.i = $_.i + 6;
          } else {
            $_.i = $_.i + 7;
          }
          break;
        }
      }
      if ($_.i == $_.segstart) {
        if ($get($_.nDigits, $_.i) >= 2) {
          $k[$j++] = $a([$get($_.Cvals, $_.fn1)]);
          $_.addtocws();
        }
        if ($get($_.msg, $_.i) == $_.fn1 && $get($_.nDigits, $_.i + 1) >= 2) {
          $_.i = $_.i + 1;
        }
      }
      if ($get($_.SeventeenTen, $_.i)) {
        $k[$j++] = $a([$get($_.Cvals, $_.aim), $f(($get($_.msg, $_.i + 2) - 48) * 10 + ($get($_.msg, $_.i + 3) - 48)), $f(($get($_.msg, $_.i + 4) - 48) * 10 + ($get($_.msg, $_.i + 5) - 48)), $f(($get($_.msg, $_.i + 6) - 48) * 10 + ($get($_.msg, $_.i + 7) - 48))]);
        $_.addtocws();
        $_.i = $_.i + 10;
        break;
      }
      if ($get($_.DatumC, $_.i)) {
        var _BB = $get($_.msg, $_.i);
        if (_BB == $_.fn1 || (_BB == $_.fn2 || _BB == $_.fn3)) {
          $k[$j++] = $a([$get($_.Cvals, $get($_.msg, $_.i))]);
          $_.addtocws();
          if ($get($_.ECI, $_.i)) {
            $k[$j++] = Infinity;
            $_.ECIabc();
            var _BO = $a();
            $k[$j++] = _BO;
            $_.addtocws();
            $_.i = $_.i + 7;
            break;
          }
          if ($get($_.msg, $_.i) == $_.fn3 && $_.segstart != $_.i) {
            $_.i = $_.i + 1;
            $_.inmac = 0;
            $_.segstart = $_.i;
            $_.segend = $f($_.i + $get($_.UntilEndSeg, $_.i));
            break;
          }
          $_.i = $_.i + 1;
          break;
        }
        $k[$j++] = $a([$f(($get($_.msg, $_.i) - 48) * 10 + ($get($_.msg, $_.i + 1) - 48))]);
        $_.addtocws();
        $_.i = $_.i + 2;
        break;
      }
      if ($get($_.Binary, $_.i)) {
        if ($get($_.nDigits, $_.i + 1) > 0) {
          if ($get($_.msg, $_.i) < 160) {
            $k[$j++] = $a([$get($_.Cvals, $_.bsa), $get($_.Avals, $get($_.msg, $_.i) - 128)]);
            $_.addtocws();
          } else {
            $k[$j++] = $a([$get($_.Cvals, $_.bsb), $get($_.Bvals, $get($_.msg, $_.i) - 128)]);
            $_.addtocws();
          }
          $_.i = $_.i + 1;
          break;
        }
        $k[$j++] = $a([$get($_.Cvals, $_.bin)]);
        $_.addtocws();
        $_.mode = $_.BIN;
        break;
      }
      $_.m = $get($_.AheadA, $_.i);
      $_.n = $get($_.AheadB, $_.i);
      if ($gt($_.m, $_.n)) {
        $k[$j++] = $a([$get($_.Cvals, $_.laa)]);
        $_.addtocws();
        $_.mode = $_.A;
        break;
      }
      if ($_.i == $_.segstart) {
        var _CZ = $get($_.msg, $_.i);
        if (_CZ == 9 || (_CZ == 28 || (_CZ == 29 || _CZ == 30))) {
          $k[$j++] = $a([$get($_.Cvals, $_.laa)]);
          $_.addtocws();
          $_.mode = $_.A;
          break;
        }
      }
      if ($_.n > 4) {
        $k[$j++] = $a([$get($_.Cvals, $_.lab)]);
        $_.addtocws();
        $_.mode = $_.B;
        break;
      }
      $k[$j++] = $a([$get($_.Cvals, $get($a([$_.sfb, $_.sb2, $_.sb3, $_.sb4]), $_.n - 1))]);
      $_.addtocws();
      for (var _Cw = 0, _Cx = $_.n; _Cw < _Cx; _Cw++) {
        if ($get($_.msg, $_.i) == 13) {
          $k[$j++] = $a([$get($_.Bvals, $_.crl)]);
          $_.addtocws();
          $_.i = $_.i + 2;
        } else {
          $k[$j++] = $a([$get($_.Bvals, $get($_.msg, $_.i))]);
          $_.addtocws();
          $_.i = $_.i + 1;
        }
      }
      break;
    }
  };
  $_.encB = function() {
    for (var _DD = 0; _DD < 1; _DD++) {
      $_.n = $get($_.TryC, $_.i);
      if ($_.n >= 2) {
        if ($_.n > 4) {
          $k[$j++] = $a([$get($_.Bvals, $_.lac)]);
          $_.addtocws();
          $_.mode = $_.C;
          break;
        }
        $k[$j++] = $a([$get($_.Bvals, $get($a([$_.sfc, $_.sc2, $_.sc3, $_.sc4]), $_.n - 1))]);
        $_.addtocws();
        for (var _DZ = 0, _Da = $_.n; _DZ < _Da; _DZ++) {
          if ($get($_.msg, $_.i) < 0) {
            $k[$j++] = $a([$get($_.Cvals, $get($_.msg, $_.i))]);
            $_.addtocws();
            $_.i = $_.i + 1;
          } else {
            $k[$j++] = $a([$f(($get($_.msg, $_.i) - 48) * 10 + ($get($_.msg, $_.i + 1) - 48))]);
            $_.addtocws();
            $_.i = $_.i + 2;
          }
        }
        break;
      }
      if ($get($_.DatumB, $_.i)) {
        var _Dy = $get($_.msg, $_.i);
        if (_Dy == $_.fn1 || (_Dy == $_.fn2 || _Dy == $_.fn3)) {
          $k[$j++] = $a([$get($_.Bvals, $get($_.msg, $_.i))]);
          $_.addtocws();
          if ($get($_.ECI, $_.i)) {
            $k[$j++] = Infinity;
            $_.ECIabc();
            var _EB = $a();
            $k[$j++] = _EB;
            $_.addtocws();
            $_.i = $_.i + 7;
            break;
          }
          if ($get($_.msg, $_.i) == $_.fn3 && $_.i != $_.segstart) {
            $_.i = $_.i + 1;
            $_.mode = $_.C;
            $_.inmac = 0;
            $_.segstart = $_.i;
            $_.segend = $f($_.i + $get($_.UntilEndSeg, $_.i));
            break;
          }
          $_.i = $_.i + 1;
          break;
        }
        if ($get($_.msg, $_.i) == 13 && $_.i < $_.msglen - 1) {
          if ($get($_.msg, $_.i + 1) == 10) {
            $k[$j++] = $a([$get($_.Bvals, $_.crl)]);
            $_.addtocws();
            $_.i = $_.i + 2;
            break;
          }
        }
        $k[$j++] = $a([$get($_.Bvals, $get($_.msg, $_.i))]);
        $_.addtocws();
        $_.i = $_.i + 1;
        break;
      }
      if ($get($_.Binary, $_.i)) {
        if ($get($_.DatumB, $_.i + 1)) {
          if ($get($_.msg, $_.i) < 160) {
            $k[$j++] = $a([$get($_.Bvals, $_.bsa), $get($_.Avals, $get($_.msg, $_.i) - 128)]);
            $_.addtocws();
          } else {
            $k[$j++] = $a([$get($_.Bvals, $_.bsb), $get($_.Bvals, $get($_.msg, $_.i) - 128)]);
            $_.addtocws();
          }
          $_.i = $_.i + 1;
          break;
        }
        $k[$j++] = $a([$get($_.Bvals, $_.bin)]);
        $_.addtocws();
        $_.mode = $_.BIN;
        break;
      }
      if ($get($_.AheadA, $_.i) == 1) {
        $k[$j++] = $a([$get($_.Bvals, $_.sfa), $get($_.Avals, $get($_.msg, $_.i))]);
        $_.addtocws();
        $_.i = $_.i + 1;
        break;
      }
      $k[$j++] = $a([$get($_.Bvals, $_.laa)]);
      $_.addtocws();
      $_.mode = $_.A;
      break;
    }
  };
  $_.encA = function() {
    for (var _Fa = 0; _Fa < 1; _Fa++) {
      $_.n = $get($_.TryC, $_.i);
      if ($_.n >= 2) {
        if ($_.n > 4) {
          $k[$j++] = $a([$get($_.Avals, $_.lac)]);
          $_.addtocws();
          $_.mode = $_.C;
          break;
        }
        $k[$j++] = $a([$get($_.Avals, $get($a([$_.sfc, $_.sc2, $_.sc3, $_.sc4]), $_.n - 1))]);
        $_.addtocws();
        for (var _Fw = 0, _Fx = $_.n; _Fw < _Fx; _Fw++) {
          if ($get($_.msg, $_.i) < 0) {
            $k[$j++] = $a([$get($_.Cvals, $get($_.msg, $_.i))]);
            $_.addtocws();
            $_.i = $_.i + 1;
          } else {
            $k[$j++] = $a([$f(($get($_.msg, $_.i) - 48) * 10 + ($get($_.msg, $_.i + 1) - 48))]);
            $_.addtocws();
            $_.i = $_.i + 2;
          }
        }
        break;
      }
      if ($get($_.DatumA, $_.i)) {
        var _GL = $get($_.msg, $_.i);
        if (_GL == $_.fn1 || (_GL == $_.fn2 || _GL == $_.fn3)) {
          $k[$j++] = $a([$get($_.Avals, $get($_.msg, $_.i))]);
          $_.addtocws();
          if ($get($_.ECI, $_.i)) {
            $k[$j++] = Infinity;
            $_.ECIabc();
            var _GY = $a();
            $k[$j++] = _GY;
            $_.addtocws();
            $_.i = $_.i + 7;
            break;
          }
          if ($get($_.msg, $_.i) == $_.fn3 && $_.i != $_.segstart) {
            $_.i = $_.i + 1;
            $_.mode = $_.C;
            $_.inmac = 0;
            $_.segstart = $_.i;
            $_.segend = $f($_.i + $get($_.UntilEndSeg, $_.i));
            break;
          }
          $_.i = $_.i + 1;
          break;
        }
        $k[$j++] = $a([$get($_.Avals, $get($_.msg, $_.i))]);
        $_.addtocws();
        $_.i = $_.i + 1;
        break;
      }
      if ($get($_.Binary, $_.i)) {
        if ($get($_.DatumA, $_.i + 1)) {
          if ($get($_.msg, $_.i) < 160) {
            $k[$j++] = $a([$get($_.Avals, $_.bsa), $get($_.Avals, $get($_.msg, $_.i) - 128)]);
            $_.addtocws();
          } else {
            $k[$j++] = $a([$get($_.Avals, $_.bsb), $get($_.Bvals, $get($_.msg, $_.i) - 128)]);
            $_.addtocws();
          }
          $_.i = $_.i + 1;
          break;
        }
        $k[$j++] = $a([$get($_.Avals, $_.bin)]);
        $_.addtocws();
        $_.mode = $_.BIN;
        break;
      }
      $_.n = $get($_.AheadB, $_.i);
      if ($_.n > 6) {
        $k[$j++] = $a([$get($_.Avals, $_.lab)]);
        $_.addtocws();
        $_.mode = $_.B;
        break;
      }
      $k[$j++] = $a([$get($_.Avals, $get($a([$_.sfb, $_.sb2, $_.sb3, $_.sb4, $_.sb5, $_.sb6]), $_.n - 1))]);
      $_.addtocws();
      for (var _Ho = 0, _Hp = $_.n; _Ho < _Hp; _Ho++) {
        if ($get($_.msg, $_.i) == 13) {
          $k[$j++] = $a([$get($_.Bvals, $_.crl)]);
          $_.addtocws();
          $_.i = $_.i + 2;
        } else {
          $k[$j++] = $a([$get($_.Bvals, $get($_.msg, $_.i))]);
          $_.addtocws();
          $_.i = $_.i + 1;
        }
      }
      break;
    }
  };
  $_.encBIN = function() {
    for (var _I5 = 0; _I5 < 1; _I5++) {
      $_.n = $get($_.TryC, $_.i);
      if ($_.n >= 2) {
        $k[$j++] = Infinity;
        $_.finaliseBIN();
        var _IA = $a();
        $k[$j++] = _IA;
        $_.addtocws();
        if ($_.n > 7) {
          $k[$j++] = $a([$get($_.BINvals, $_.tmc)]);
          $_.addtocws();
          $_.mode = $_.C;
          break;
        }
        $k[$j++] = $a([$get($_.BINvals, $get($a([$_.sc2, $_.sc3, $_.sc4, $_.sc5, $_.sc6, $_.sc7]), $_.n - 2))]);
        $_.addtocws();
        for (var _IU = 0, _IV = $_.n; _IU < _IV; _IU++) {
          if ($get($_.msg, $_.i) < 0) {
            $k[$j++] = $a([$get($_.Cvals, $get($_.msg, $_.i))]);
            $_.addtocws();
            $_.i = $_.i + 1;
          } else {
            $k[$j++] = $a([$f(($get($_.msg, $_.i) - 48) * 10 + ($get($_.msg, $_.i + 1) - 48))]);
            $_.addtocws();
            $_.i = $_.i + 2;
          }
        }
        break;
      }
      if ($get($_.ECI, $_.i) && $get($_.Binary, $_.i + 7)) {
        $k[$j++] = Infinity;
        $_.ECIbin();
        var _Iu = $a();
        $k[$j++] = _Iu;
        $_.addtocws();
        $_.i = $_.i + 7;
        if ($_.i == $_.msglen) {
          $k[$j++] = Infinity;
          $_.finaliseBIN();
          var _Iy = $a();
          $k[$j++] = _Iy;
          $_.addtocws();
        }
        break;
      }
      if ($get($_.msg, $_.i) >= 0) {
        if ($get($_.Binary, $_.i) || $get($_.Binary, $_.i + 1) || $get($_.Binary, $_.i + 2) || $get($_.Binary, $_.i + 3) || $get($_.ECI, $_.i + 1) && $get($_.Binary, $_.i + 8)) {
          $k[$j++] = Infinity;
          $k[$j++] = $get($_.msg, $_.i);
          $_.addtobin();
          var _JN = $a();
          $k[$j++] = _JN;
          $_.addtocws();
          $_.i = $_.i + 1;
          if ($_.i == $_.msglen) {
            $k[$j++] = Infinity;
            $_.finaliseBIN();
            var _JR = $a();
            $k[$j++] = _JR;
            $_.addtocws();
          }
          break;
        }
      }
      $k[$j++] = Infinity;
      $_.finaliseBIN();
      var _JS = $a();
      $k[$j++] = _JS;
      $_.addtocws();
      if ($_.i != $_.msglen - 1) {
        if ($get($_.msg, $_.i) == $_.fn3 && $_.i != $_.segstart) {
          $k[$j++] = $a([$get($_.BINvals, $_.tms)]);
          $_.addtocws();
          $_.i = $_.i + 1;
          $_.mode = $_.C;
          $_.inmac = 0;
          $_.segstart = $_.i;
          $_.segend = $f($_.i + $get($_.UntilEndSeg, $_.i));
          break;
        }
        if ($gt($get($_.AheadA, $_.i), $get($_.AheadB, $_.i))) {
          $k[$j++] = $a([$get($_.BINvals, $_.tma)]);
          $_.addtocws();
          $_.mode = $_.A;
        } else {
          $k[$j++] = $a([$get($_.BINvals, $_.tmb)]);
          $_.addtocws();
          $_.mode = $_.B;
        }
        break;
      }
      break;
    }
  };
  $_.cws = $a($_.msglen * 2 + 1);
  $_.mode = $_.C;
  $_.bvals = $a(5);
  $_.bpos = 0;
  $_.inmac = 0;
  $_.segstart = 0;
  $_.segend = $get($_.UntilEndSeg, 0);
  $_.i = 0;
  $_.j = 0;
  for (; ; ) {
    if ($_.i >= $_.msglen) {
      break;
    }
    if ($_.inmac != 0) {
      if ($_.inmac != $_.mac && $_.i == $_.segend - 2) {
        $_.i = $_.i + 2;
        if ($_.i >= $_.msglen) {
          break;
        }
      }
      if ($_.inmac == $_.mac && $_.i == $_.segend - 1) {
        $_.i = $_.i + 1;
        if ($_.i >= $_.msglen) {
          break;
        }
      }
    }
    if ($_[$get($a(["encA", "encB", "encC", "encBIN"]), $_.mode)]() === true) {
      break;
    }
  }
  $_.cws = $geti($_.cws, 0, $_.j);
  $_.nd = $_.cws.length;
  $_.minarea = (($_.nd + 3 + ~~($_.nd / 2)) * 9 + 2) * 2;
  if ($_.ratio != -1) {
    $_.hgt = $sqrt($_.minarea / $_.ratio);
    $_.wid = $sqrt($_.minarea * $_.ratio);
    $_.h = ~~$_.hgt;
    $_.w = ~~$_.wid;
    if (($_.h + $_.w) % 2 == 1) {
      if ($_.h * $_.w < $_.minarea) {
        $_.h = $_.h + 1;
        $_.w = $_.w + 1;
      }
    } else {
      if ($_.hgt * $_.w < $_.wid * $_.h) {
        $_.w = $_.w + 1;
        if ($_.h * $_.w < $_.minarea) {
          $_.w = $_.w - 1;
          $_.h = $_.h + 1;
          if ($_.h * $_.w < $_.minarea) {
            $_.w = $_.w + 2;
          }
        }
      } else {
        $_.h = $_.h + 1;
        if ($_.h * $_.w < $_.minarea) {
          $_.h = $_.h - 1;
          $_.w = $_.w + 1;
          if ($_.h * $_.w < $_.minarea) {
            $_.h = $_.h + 2;
          }
        }
      }
    }
    $_.rows = $_.h;
    $_.columns = $_.w;
  } else {
    if ($_.columns == -1) {
      var _LH = ~~(($_.minarea + $_.rows - 1) / $_.rows);
      $k[$j++] = "columns";
      $k[$j++] = _LH;
      if ((_LH + $_.rows) % 2 == 0) {
        var _LJ = $k[--$j];
        $k[$j++] = _LJ + 1;
      }
      var _LK = $k[--$j];
      $_[$k[--$j]] = _LK;
    }
    if ($_.rows == -1) {
      var _LQ = ~~(($_.minarea + $_.columns - 1) / $_.columns);
      $k[$j++] = "rows";
      $k[$j++] = _LQ;
      if ((_LQ + $_.columns) % 2 == 0) {
        var _LS = $k[--$j];
        $k[$j++] = _LS + 1;
      }
      var _LT = $k[--$j];
      $_[$k[--$j]] = _LT;
    }
  }
  $_.ndots = ~~($_.rows * $_.columns / 2);
  for (; ; ) {
    var _LY = $_.nd + 1;
    if ((_LY + (~~(_LY / 2) + 3)) * 9 + 2 > $_.ndots) {
      break;
    }
    $_.nd = $_.nd + 1;
  }
  $_.nc = ~~($_.nd / 2) + 3;
  $_.nw = $_.nd + $_.nc;
  $_.rembits = $_.ndots - ($_.nw * 9 + 2);
  if ($_.nd > $_.cws.length) {
    $k[$j++] = Infinity;
    $aload($_.cws);
    var _Ll = $_.mode == $_.BIN ? 109 : 106;
    $k[$j++] = _Ll;
    for (var _Lo = 0, _Lp = $_.nd - $_.cws.length - 1; _Lo < _Lp; _Lo++) {
      $k[$j++] = 106;
    }
    $_.cws = $a();
  }
  var _Ls = $get($_.options, "debugcws") !== void 0;
  if (_Ls) {
    $k[$j++] = "bwipp.debugcws#26927";
    $k[$j++] = $_.cws;
    bwipp_raiseerror();
  }
  if ($_.nw * 9 > $_.ndots - 2) {
    $k[$j++] = "bwipp.dotcodeTooLong#26931";
    $k[$j++] = "Maximum length exceeded";
    bwipp_raiseerror();
  }
  $_.encs = $a(["101010101", "010101011", "010101101", "010110101", "011010101", "101010110", "101011010", "101101010", "110101010", "010101110", "010110110", "010111010", "011010110", "011011010", "011101010", "100101011", "100101101", "100110101", "101001011", "101001101", "101010011", "101011001", "101100101", "101101001", "110010101", "110100101", "110101001", "001010111", "001011011", "001011101", "001101011", "001101101", "001110101", "010010111", "010011011", "010011101", "010100111", "010110011", "010111001", "011001011", "011001101", "011010011", "011011001", "011100101", "011101001", "100101110", "100110110", "100111010", "101001110", "101011100", "101100110", "101101100", "101110010", "101110100", "110010110", "110011010", "110100110", "110101100", "110110010", "110110100", "111001010", "111010010", "111010100", "001011110", "001101110", "001110110", "001111010", "010011110", "010111100", "011001110", "011011100", "011100110", "011101100", "011110010", "011110100", "100010111", "100011011", "100011101", "100100111", "100110011", "100111001", "101000111", "101100011", "101110001", "110001011", "110001101", "110010011", "110011001", "110100011", "110110001", "111000101", "111001001", "111010001", "000101111", "000110111", "000111011", "000111101", "001001111", "001100111", "001110011", "001111001", "010001111", "011000111", "011100011", "011110001", "100011110", "100111100", "101111000", "110001110", "110011100", "110111000", "111000110", "111001100"]);
  if ($_.rows % 2 == 0) {
    $_.sixedges = $a([$a([$_.columns - 1, $_.rows - 2]), $a([0, $_.rows - 2]), $a([$_.columns - 2, $_.rows - 1]), $a([1, $_.rows - 1]), $a([$_.columns - 1, 0]), $a([0, 0])]);
  } else {
    $_.sixedges = $a([$a([$_.columns - 2, 0]), $a([$_.columns - 2, $_.rows - 1]), $a([$_.columns - 1, 1]), $a([$_.columns - 1, $_.rows - 2]), $a([0, 0]), $a([0, $_.rows - 1])]);
  }
  $_.dmv = function() {
    var _MS = $k[--$j];
    var _MT = $k[--$j];
    $k[$j++] = $f(_MT + _MS * $_.columns);
  };
  $_.outline = $a($_.rows * $_.columns);
  for (var _MZ = 0, _MY = $_.rows - 1; _MZ <= _MY; _MZ += 1) {
    $_.y = _MZ;
    for (var _Mc = 0, _Mb = $_.columns - 1; _Mc <= _Mb; _Mc += 1) {
      $_.x = _Mc;
      $k[$j++] = $_.outline;
      $k[$j++] = $_.x;
      $k[$j++] = $_.y;
      $_.dmv();
      var _Mi = $k[--$j];
      $put($k[--$j], _Mi, ($_.x + $_.y) % 2 - 1);
    }
  }
  var _Mk = $_.sixedges;
  for (var _Ml = 0, _Mm = _Mk.length; _Ml < _Mm; _Ml++) {
    $k[$j++] = $_.outline;
    $aload($get(_Mk, _Ml));
    $_.dmv();
    var _Mp = $k[--$j];
    $put($k[--$j], _Mp, 1);
  }
  $_.clearcol = function() {
    $_.x = $k[--$j];
    $k[$j++] = true;
    for (var _Mv = $_.x & 1, _Mu = $_.rows - 1; _Mv <= _Mu; _Mv += 2) {
      $k[$j++] = $_.x;
      $k[$j++] = _Mv;
      $_.dmv();
      if ($get($_.sym, $k[--$j]) == 1) {
        $k[$j - 1] = false;
        break;
      }
    }
  };
  $_.clearrow = function() {
    $_.y = $k[--$j];
    $k[$j++] = true;
    for (var _N4 = $_.y & 1, _N3 = $_.columns - 1; _N4 <= _N3; _N4 += 2) {
      $k[$j++] = _N4;
      $k[$j++] = $_.y;
      $_.dmv();
      if ($get($_.sym, $k[--$j]) == 1) {
        $k[$j - 1] = false;
        break;
      }
    }
  };
  $_.evalsymbol = function() {
    $_.sym = $k[--$j];
    $_.worst = 9999999;
    var _NE = $a([$a(["x", 0]), $a(["x", 1]), $a(["y", 0]), $a(["y", 1])]);
    for (var _NF = 0, _NG = _NE.length; _NF < _NG; _NF++) {
      $aload($get(_NE, _NF));
      $_.fl = $k[--$j];
      $_.dir = $k[--$j];
      $_.sum = 0;
      $_.first = -1;
      $_.last = -1;
      var _NL = $eq($_.dir, "x") ? $_.columns : $_.rows;
      for (var _NN = 0, _NM = _NL - 1; _NN <= _NM; _NN += 1) {
        $_[$_.dir] = _NN;
        var _NP = $_.sym;
        var _NR = $_[$_.dir];
        var _NT = $eq($_.dir, "x") ? $_.rows : $_.columns;
        var _NW = (_NT - 1) * $_.fl;
        if ($eq($_.dir, "y")) {
          var _ = _NW;
          _NW = _NR;
          _NR = _;
        }
        $k[$j++] = _NP;
        $k[$j++] = _NR;
        $k[$j++] = _NW;
        $_.dmv();
        var _NX = $k[--$j];
        if ($get($k[--$j], _NX) == 1) {
          if ($_.first == -1) {
            $_.first = $_[$_.dir];
          }
          $_.last = $_[$_.dir];
          $_.sum = $_.sum + 1;
        }
      }
      var _Nk = $eq($_.dir, "x") ? $_.rows : $_.columns;
      var _Nl = $f($_.sum + $_.last - $_.first) * _Nk;
      $k[$j++] = _Nl;
      if (_Nl < $_.worst) {
        $_.worst = $k[--$j];
      } else {
        $j--;
      }
    }
    $_.pen = 0;
    if ($_.rows % 2 == 1 || $_.rows <= 12) {
      $_.sum = 0;
      $_.p = 0;
      for (var _Ns = 1, _Nr = $_.columns - 2; _Ns <= _Nr; _Ns += 1) {
        $k[$j++] = _Ns;
        $_.clearcol();
        if ($k[--$j]) {
          $_.sum = $_.sum + 1;
          $k[$j++] = "p";
          if ($_.sum == 1) {
            $k[$j++] = $_.rows;
          } else {
            $k[$j++] = $_.p * $_.rows;
          }
          var _Nz = $k[--$j];
          $_[$k[--$j]] = _Nz;
        } else {
          $_.sum = 0;
          $_.pen = $_.pen + $_.p;
          $_.p = 0;
        }
      }
      $_.pen = $_.pen + $_.p;
    }
    if ($_.rows % 2 == 0 || $_.columns <= 12) {
      $_.sum = 0;
      $_.p = 0;
      for (var _O9 = 1, _O8 = $_.rows - 2; _O9 <= _O8; _O9 += 1) {
        $k[$j++] = _O9;
        $_.clearrow();
        if ($k[--$j]) {
          $_.sum = $_.sum + 1;
          $k[$j++] = "p";
          if ($_.sum == 1) {
            $k[$j++] = $_.columns;
          } else {
            $k[$j++] = $_.p * $_.columns;
          }
          var _OG = $k[--$j];
          $_[$k[--$j]] = _OG;
        } else {
          $_.sum = 0;
          $_.pen = $_.pen + $_.p;
          $_.p = 0;
        }
      }
      $_.pen = $_.pen + $_.p;
    }
    $k[$j++] = Infinity;
    for (var _ON = 0, _OO = ($_.columns + 4) * 2; _ON < _OO; _ON++) {
      $k[$j++] = 0;
    }
    for (var _OS = 0, _OT = $_.columns, _OR = $_.sym.length - 1; _OT < 0 ? _OS >= _OR : _OS <= _OR; _OS += _OT) {
      $k[$j++] = 0;
      $k[$j++] = 0;
      $aload($geti($_.sym, _OS, $_.columns));
      $k[$j++] = 0;
      $k[$j++] = 0;
    }
    for (var _OY = 0, _OZ = ($_.columns + 4) * 2; _OY < _OZ; _OY++) {
      $k[$j++] = 0;
    }
    $_.symp = $a();
    $_.columns = $_.columns + 4;
    $_.rows = $_.rows + 4;
    $_.sum = 0;
    for (var _Of = 2, _Oe = $_.rows - 3; _Of <= _Oe; _Of += 1) {
      $_.y = _Of;
      for (var _Oj = ($_.y & 1) + 2, _Oi = $_.columns - 3; _Oj <= _Oi; _Oj += 2) {
        $_.x = _Oj;
        for (var _Ok = 0; _Ok < 1; _Ok++) {
          $k[$j++] = $_.symp;
          $k[$j++] = $_.x - 1;
          $k[$j++] = $_.y - 1;
          $_.dmv();
          var _Oo = $k[--$j];
          if ($get($k[--$j], _Oo) == 1) {
            break;
          }
          $k[$j++] = $_.symp;
          $k[$j++] = $_.x + 1;
          $k[$j++] = $_.y - 1;
          $_.dmv();
          var _Ou = $k[--$j];
          if ($get($k[--$j], _Ou) == 1) {
            break;
          }
          $k[$j++] = $_.symp;
          $k[$j++] = $_.x - 1;
          $k[$j++] = $_.y + 1;
          $_.dmv();
          var _P0 = $k[--$j];
          if ($get($k[--$j], _P0) == 1) {
            break;
          }
          $k[$j++] = $_.symp;
          $k[$j++] = $_.x + 1;
          $k[$j++] = $_.y + 1;
          $_.dmv();
          var _P6 = $k[--$j];
          if ($get($k[--$j], _P6) == 1) {
            break;
          }
          $k[$j++] = $_.symp;
          $k[$j++] = $_.x;
          $k[$j++] = $_.y;
          $_.dmv();
          var _PC = $k[--$j];
          if ($get($k[--$j], _PC) == 0) {
            $_.sum = $_.sum + 1;
            break;
          }
          $k[$j++] = $_.symp;
          $k[$j++] = $_.x - 2;
          $k[$j++] = $_.y;
          $_.dmv();
          var _PJ = $k[--$j];
          if ($get($k[--$j], _PJ) == 1) {
            break;
          }
          $k[$j++] = $_.symp;
          $k[$j++] = $_.x;
          $k[$j++] = $_.y - 2;
          $_.dmv();
          var _PP = $k[--$j];
          if ($get($k[--$j], _PP) == 1) {
            break;
          }
          $k[$j++] = $_.symp;
          $k[$j++] = $_.x + 2;
          $k[$j++] = $_.y;
          $_.dmv();
          var _PV = $k[--$j];
          if ($get($k[--$j], _PV) == 1) {
            break;
          }
          $k[$j++] = $_.symp;
          $k[$j++] = $_.x;
          $k[$j++] = $_.y + 2;
          $_.dmv();
          var _Pb = $k[--$j];
          if ($get($k[--$j], _Pb) == 1) {
            break;
          }
          $_.sum = $_.sum + 1;
        }
      }
    }
    $_.columns = $_.columns - 4;
    $_.rows = $_.rows - 4;
    if ($_.worst == 0) {
      $k[$j++] = -99999;
    } else {
      $k[$j++] = $f($_.worst - $_.sum * $_.sum - $_.pen);
    }
  };
  $k[$j++] = Infinity;
  $k[$j++] = 1;
  for (var _Pm = 0; _Pm < 112; _Pm++) {
    var _Pn = $k[$j - 1];
    $k[$j++] = _Pn * 3 % 113;
  }
  $_.rsalog = $a();
  $_.step = ~~($_.nw / 112) + 1;
  $_.offset = function() {
    var _Ps = $k[--$j];
    $k[$j++] = $f(_Ps * $_.step + $_.start);
  };
  $_.bestscore = -99999999;
  $k[$j++] = "masks";
  if ($_.mask != -1) {
    $k[$j++] = $a([$_.mask]);
  } else {
    if ($_.fast) {
      $k[$j++] = $a([3, 2, 1, 0]);
    } else {
      $k[$j++] = $a([0, 1, 2, 3]);
    }
  }
  var _Q0 = $k[--$j];
  $_[$k[--$j]] = _Q0;
  $_.litmasks = $a(4);
  $forall($_.masks, function() {
    $_.mask = $k[--$j];
    $k[$j++] = Infinity;
    var _Q9 = $_.cws;
    $k[$j++] = $_.mask;
    $k[$j++] = $get($a([0, 3, 7, 17]), $_.mask);
    $k[$j++] = 0;
    for (var _QA = 0, _QB = _Q9.length; _QA < _QB; _QA++) {
      var _QD = $k[--$j];
      var _QE = $k[--$j];
      $k[$j++] = $f($get(_Q9, _QA) + _QD) % 113;
      $k[$j++] = _QE;
      $k[$j++] = $f(_QD + _QE);
    }
    $j -= 2;
    for (var _QG = 0, _QH = $_.nc; _QG < _QH; _QG++) {
      $k[$j++] = 0;
    }
    $_.rscws = $a();
    for (var _QL = 0, _QK = $_.step - 1; _QL <= _QK; _QL += 1) {
      $_.start = _QL;
      $_.ND = ~~(($_.nd + 1 - $_.start + $_.step - 1) / $_.step);
      $_.NW = ~~(($_.nw + 1 - $_.start + $_.step - 1) / $_.step);
      $_.NC = $_.NW - $_.ND;
      $k[$j++] = Infinity;
      $k[$j++] = 1;
      for (var _QX = 0, _QY = $_.NC; _QX < _QY; _QX++) {
        $k[$j++] = 0;
      }
      $_.coeffs = $a();
      for (var _Qc = 1, _Qb = $_.NC; _Qc <= _Qb; _Qc += 1) {
        $_.i = _Qc;
        for (var _Qe = $_.NC; _Qe >= 1; _Qe -= 1) {
          $_.j = _Qe;
          $put($_.coeffs, $_.j, $f($get($_.coeffs, $_.j) + 113 - $get($_.rsalog, $_.i) * $get($_.coeffs, $_.j - 1) % 113) % 113);
        }
      }
      for (var _Qs = 0, _Qr = $_.ND - 1; _Qs <= _Qr; _Qs += 1) {
        $k[$j++] = "t";
        $k[$j++] = $_.rscws;
        $k[$j++] = _Qs;
        $_.offset();
        var _Qu = $k[--$j];
        var _Qw = $get($k[--$j], _Qu);
        $k[$j++] = _Qw;
        $k[$j++] = $_.rscws;
        $k[$j++] = $_.ND;
        $_.offset();
        var _Qz = $k[--$j];
        var _R1 = $get($k[--$j], _Qz);
        var _R2 = $k[--$j];
        $_[$k[--$j]] = $f(_R2 + _R1) % 113;
        for (var _R6 = 0, _R5 = $_.NC - 2; _R6 <= _R5; _R6 += 1) {
          $_.j = _R6;
          $k[$j++] = $_.rscws;
          $k[$j++] = $_.ND + $_.j;
          $_.offset();
          $k[$j++] = $_.rscws;
          $k[$j++] = $_.ND + $_.j + 1;
          $_.offset();
          var _RD = $k[--$j];
          var _RF = $get($k[--$j], _RD);
          var _RK = $k[--$j];
          $put($k[--$j], _RK, $f(_RF + 113 - $_.t * $get($_.coeffs, $_.j + 1) % 113) % 113);
        }
        $k[$j++] = $_.rscws;
        $k[$j++] = $_.ND + $_.NC - 1;
        $_.offset();
        var _RT = $k[--$j];
        $put($k[--$j], _RT, (113 - $_.t * $get($_.coeffs, $_.NC) % 113) % 113);
      }
      for (var _RY = $_.ND, _RX = $_.NW - 1; _RY <= _RX; _RY += 1) {
        $k[$j++] = _RY;
        $k[$j++] = $_.rscws;
        $k[$j++] = _RY;
        $_.offset();
        $k[$j++] = 113;
        $k[$j++] = $_.rscws;
        $r(5, -1);
        $_.offset();
        var _Rb = $k[--$j];
        var _Rd = $get($k[--$j], _Rb);
        var _Re = $k[--$j];
        var _Rf = $k[--$j];
        $put($k[--$j], _Rf, $f(_Re - _Rd) % 113);
      }
    }
    $_.bits = $s($_.ndots);
    $puti($_.bits, 0, $get($a(["00", "01", "10", "11"]), $_.mask));
    for (var _Rp = 1, _Ro = $_.nw; _Rp <= _Ro; _Rp += 1) {
      $_.i = _Rp;
      $puti($_.bits, ($_.i - 1) * 9 + 2, $get($_.encs, $get($_.rscws, $_.i)));
    }
    if ($_.rembits > 0) {
      $puti($_.bits, $_.nw * 9 + 2, $geti("11111111111111111", 0, $_.rembits));
    }
    var _S2 = $_.outline;
    $_.pixs = $arrcpy($a(_S2.length), _S2);
    $_.posx = 0;
    $k[$j++] = "posy";
    if ($_.rows % 2 == 0) {
      $k[$j++] = 0;
    } else {
      $k[$j++] = $_.rows - 1;
    }
    var _S7 = $k[--$j];
    $_[$k[--$j]] = _S7;
    var _SB = $geti($_.bits, 0, $_.bits.length - 6);
    for (var _SC = 0, _SD = _SB.length; _SC < _SD; _SC++) {
      $k[$j++] = $get(_SB, _SC);
      for (; ; ) {
        $k[$j++] = $_.pixs;
        $k[$j++] = $_.posx;
        $k[$j++] = $_.posy;
        $_.dmv();
        var _SI = $k[--$j];
        if ($get($k[--$j], _SI) == -1) {
          break;
        }
        if ($_.rows % 2 == 0) {
          $_.posy = $_.posy + 1;
          if ($_.posy == $_.rows) {
            $_.posy = 0;
            $_.posx = $_.posx + 1;
          }
        } else {
          $_.posx = $_.posx + 1;
          if ($_.posx == $_.columns) {
            $_.posx = 0;
            $_.posy = $_.posy - 1;
          }
        }
      }
      $k[$j++] = $_.pixs;
      $k[$j++] = $_.posx;
      $k[$j++] = $_.posy;
      $_.dmv();
      var _SX = $k[$j - 3];
      var _SY = $k[$j - 1];
      $put($k[$j - 2], _SY, _SX - 48);
      $j -= 3;
    }
    for (var _Sa = 0; _Sa <= 5; _Sa += 1) {
      $_.i = _Sa;
      $k[$j++] = $_.pixs;
      $aload($get($_.sixedges, $_.i));
      $_.dmv();
      var _Sj = $k[--$j];
      $put($k[--$j], _Sj, $get($_.bits, $_.bits.length - 6 + $_.i) - 48);
    }
    $k[$j++] = "score";
    $k[$j++] = $_.pixs;
    $_.evalsymbol();
    var _Sm = $k[--$j];
    $_[$k[--$j]] = _Sm;
    if ($_.score > $_.bestscore) {
      $_.bestsym = $_.pixs;
      $_.bestscore = $_.score;
      if ($_.fast && $_.bestscore > ~~($_.rows * $_.columns / 2)) {
        return true;
      }
    }
    var _Sw = $_.pixs;
    $_.litmask = $arrcpy($a(_Sw.length), _Sw);
    for (var _Sz = 0; _Sz <= 5; _Sz += 1) {
      $_.i = _Sz;
      $k[$j++] = $_.litmask;
      $aload($get($_.sixedges, $_.i));
      $_.dmv();
      var _T4 = $k[--$j];
      $put($k[--$j], _T4, 1);
    }
    $put($_.litmasks, $_.mask, $_.litmask);
    if ($_.fast) {
      $k[$j++] = "score";
      $k[$j++] = $_.litmask;
      $_.evalsymbol();
      var _TB = $k[--$j];
      $_[$k[--$j]] = _TB;
      if ($gt($_.score, $_.bestscore)) {
        $_.bestsym = $_.litmask;
        $_.bestscore = $_.score;
        if ($_.bestscore > ~~($_.rows * $_.columns / 2)) {
          return true;
        }
      }
    }
  });
  $_.pixs = $_.bestsym;
  if (!$_.fast && $_.bestscore <= ~~($_.rows * $_.columns / 2)) {
    $_.bestscore = -99999999;
    $forall($_.masks, function() {
      $_.litmask = $get($_.litmasks, $k[--$j]);
      $k[$j++] = "score";
      $k[$j++] = $_.litmask;
      $_.evalsymbol();
      var _TU = $k[--$j];
      $_[$k[--$j]] = _TU;
      if ($_.score > $_.bestscore) {
        $_.bestsym = $_.litmask;
        $_.bestscore = $_.score;
      }
    });
    $_.pixs = $_.bestsym;
  }
  var _Th = /* @__PURE__ */ new Map([
    ["ren", "renmatrix"],
    ["dotty", true],
    ["pixs", $_.pixs],
    ["pixx", $_.columns],
    ["pixy", $_.rows],
    ["height", $_.rows * 2 / 72],
    ["width", $_.columns * 2 / 72],
    ["borderleft", 3],
    ["borderright", 3],
    ["bordertop", 3],
    ["borderbottom", 3],
    ["opt", $_.options]
  ]);
  $k[$j++] = _Th;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_ultracode() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.eclevel = "EC2";
  $_.parse = false;
  $_.parsefnc = false;
  $_.start = 257;
  $_.link1 = 0;
  $_.raw = false;
  $_.rev = 2;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  var _2 = $_.rev;
  if (_2 != 1 && _2 != 2) {
    $k[$j++] = "bwipp.ultracodeInvalidRevision#27328";
    $k[$j++] = "Valid revisions are 1 and 2";
    bwipp_raiseerror();
  }
  var _4 = $_.eclevel.length == 3;
  $k[$j++] = _4;
  if (_4) {
    $j--;
    var _7 = $eq($geti($_.eclevel, 0, 2), "EC");
    $k[$j++] = _7;
    if (_7) {
      $j--;
      var _A = $get($_.eclevel, 2) - 48;
      var _C = $_.rev == 2 ? 1 : 0;
      $k[$j++] = _A >= _C && _A <= 5;
    }
  }
  if (!$k[--$j]) {
    $k[$j++] = "bwipp.ultracodeInvalidErrorCorrectionLevel#27337";
    $k[$j++] = "Valid error correction levels are EC1 to EC5, and EC0 for legacy revision 1";
    bwipp_raiseerror();
  }
  if ($_.raw) {
    $_.dcws = $a($_.barcode.length);
    $_.i = 0;
    $_.j = 0;
    for (; ; ) {
      if ($_.i == $_.barcode.length) {
        break;
      }
      $_.cw = $cvi($geti($_.barcode, $_.i + 1, 3));
      $put($_.dcws, $_.j, $_.cw);
      $_.i = $_.i + 4;
      $_.j = $_.j + 1;
    }
    $_.dcws = $geti($_.dcws, 0, $_.j);
  } else {
    $_.fn1 = -1;
    $_.fn3 = -2;
    var _Y = /* @__PURE__ */ new Map([
      ["parse", $_.parse],
      ["parsefnc", $_.parsefnc],
      ["FNC1", $_.fn1],
      ["FNC3", $_.fn3]
    ]);
    $_.fncvals = _Y;
    $k[$j++] = "msg";
    $k[$j++] = $_.barcode;
    $k[$j++] = $_.fncvals;
    bwipp_parseinput();
    var _b = $k[--$j];
    $_[$k[--$j]] = _b;
    $_.msglen = $_.msg.length;
    $_.scr = $a([]);
    $_.scp = $a([]);
    $k[$j++] = Infinity;
    $aload($_.scr);
    $aload($_.scp);
    $forall($_.msg, function() {
      var _j = $k[$j - 1];
      if (_j == $_.fn1) {
        $k[$j - 1] = 268;
      }
      var _l = $k[$j - 1];
      if (_l == $_.fn3) {
        $k[$j - 1] = 269;
      }
    });
    $_.dcws = $a();
  }
  var _p = $get($_.options, "debugcws") !== void 0;
  if (_p) {
    $k[$j++] = "bwipp.debugcws#27381";
    $k[$j++] = $_.dcws;
    bwipp_raiseerror();
  }
  $_.mcc = $_.dcws.length + 3;
  $_.eclval = $get($_.eclevel, 2) - 48;
  if ($_.eclval != 0) {
    $k[$j++] = "qcc";
    $k[$j++] = $get($a([0, 1, 2, 4, 6, 8]), $_.eclval);
    $k[$j++] = ~~($_.mcc / 25);
    if ($_.mcc % 25 != 0) {
      var _10 = $k[--$j];
      $k[$j++] = _10 + 1;
    }
    var _11 = $k[--$j];
    var _12 = $k[--$j];
    $_[$k[--$j]] = _12 * _11 + 5;
  } else {
    $_.qcc = 3;
  }
  $_.acc = $_.qcc - 3 + 78 * $_.link1;
  $_.tcc = $_.mcc + $_.qcc;
  $_.metrics = $a([$a([2, 7, 37, 5]), $a([3, 36, 84, 13]), $a([4, 85, 161, 22]), $a([5, 142, 282, 29])]);
  var _1E = $_.metrics;
  for (var _1F = 0, _1G = _1E.length; _1F < _1G; _1F++) {
    $_.m = $get(_1E, _1F);
    $_.rows = $get($_.m, 0);
    $_.minc = $get($_.m, 1);
    $_.maxc = $get($_.m, 2);
    $_.mcol = $get($_.m, 3);
    $_.okay = true;
    if ($_.tcc < $_.minc || $_.tcc > $_.maxc) {
      $_.okay = false;
    }
    if ($_.okay) {
      break;
    }
  }
  if (!$_.okay) {
    $k[$j++] = "bwipp.ultracodeNoValidSymbol#27417";
    $k[$j++] = "Maximum length exceeded or invalid content";
    bwipp_raiseerror();
  }
  for (var _1X = $_.mcol; _1X <= 61; _1X += 1) {
    $_.columns = _1X;
    $k[$j++] = $_.columns;
    if ($_.columns >= 15) {
      var _1a = $k[--$j];
      $k[$j++] = _1a - 1;
    }
    if ($_.columns >= 31) {
      var _1c = $k[--$j];
      $k[$j++] = _1c - 1;
    }
    if ($_.columns >= 47) {
      var _1e = $k[--$j];
      $k[$j++] = _1e - 1;
    }
    var _1i = $f($k[--$j] * $_.rows - 3 - $_.tcc);
    $k[$j++] = _1i;
    if (_1i >= 0) {
      $_.pads = $k[--$j];
      break;
    }
    $j--;
  }
  $_.dcc = $f($_.columns - $_.mcol);
  $k[$j++] = Infinity;
  $k[$j++] = $_.start;
  $k[$j++] = $_.mcc;
  $k[$j++] = $_.acc;
  $aload($_.dcws);
  for (var _1r = 0, _1s = $_.qcc; _1r < _1s; _1r++) {
    $k[$j++] = 0;
  }
  $k[$j++] = 0;
  $_.rsseq = $a();
  $k[$j++] = Infinity;
  $k[$j++] = 1;
  for (var _1u = 0; _1u < 282; _1u++) {
    var _1v = $k[$j - 1];
    $k[$j++] = _1v * 3 % 283;
  }
  $_.rsalog = $a();
  $_.rslog = $a(283);
  for (var _1y = 1; _1y <= 282; _1y += 1) {
    $put($_.rslog, $get($_.rsalog, _1y), _1y);
  }
  $_.rsprod = function() {
    var _23 = $k[$j - 1];
    var _24 = $k[$j - 2];
    if (_23 != 0 && _24 != 0) {
      var _27 = $get($_.rslog, $k[--$j]);
      var _2C = $get($_.rsalog, $f(_27 + $get($_.rslog, $k[--$j])) % 282);
      $k[$j++] = _2C;
    } else {
      $j -= 2;
      $k[$j++] = 0;
    }
  };
  $_.n = $_.mcc;
  $_.k = $_.qcc;
  $k[$j++] = Infinity;
  $k[$j++] = 1;
  for (var _2G = 0, _2H = $_.k; _2G < _2H; _2G++) {
    $k[$j++] = 0;
  }
  $_.coeffs = $a();
  for (var _2L = 1, _2K = $_.k; _2L <= _2K; _2L += 1) {
    $_.i = _2L;
    $put($_.coeffs, $_.i, $get($_.coeffs, $_.i - 1));
    for (var _2S = $_.i - 1; _2S >= 1; _2S -= 1) {
      $_.j = _2S;
      $k[$j++] = $_.coeffs;
      $k[$j++] = $_.j;
      $k[$j++] = $get($_.coeffs, $_.j - 1);
      $k[$j++] = $get($_.coeffs, $_.j);
      $k[$j++] = $get($_.rsalog, $_.i);
      $_.rsprod();
      var _2e = $k[--$j];
      var _2f = $k[--$j];
      var _2g = $k[--$j];
      $put($k[--$j], _2g, $f(_2f + _2e) % 283);
    }
    $k[$j++] = $_.coeffs;
    $k[$j++] = 0;
    $k[$j++] = $get($_.coeffs, 0);
    $k[$j++] = $get($_.rsalog, $_.i);
    $_.rsprod();
    var _2o = $k[--$j];
    var _2p = $k[--$j];
    $put($k[--$j], _2p, _2o);
  }
  $_.coeffs = $geti($_.coeffs, 0, $_.coeffs.length - 1);
  for (var _2v = $_.coeffs.length - 1; _2v >= 0; _2v -= 2) {
    var _2w = $_.coeffs;
    $put(_2w, _2v, 283 - $get(_2w, _2v));
  }
  for (var _30 = 0, _2z = $_.n - 1; _30 <= _2z; _30 += 1) {
    $_.t = $f($get($_.rsseq, _30) + $get($_.rsseq, $_.n)) % 283;
    for (var _38 = 0, _37 = $_.k - 1; _38 <= _37; _38 += 1) {
      $_.j = _38;
      $put($_.rsseq, $_.n + $_.j, $f($get($_.rsseq, $_.n + $_.j + 1) + (283 - $_.t * $get($_.coeffs, $_.k - $_.j - 1) % 283)) % 283);
    }
  }
  for (var _3P = $_.n, _3O = $_.n + $_.k; _3P <= _3O; _3P += 1) {
    $put($_.rsseq, _3P, (283 - $get($_.rsseq, _3P)) % 283);
  }
  $_.ecws = $geti($_.rsseq, $_.n, $_.k);
  var _3Y = $get($_.options, "debugecc") !== void 0;
  if (_3Y) {
    $k[$j++] = "bwipp.debugecc#27487";
    $k[$j++] = $_.ecws;
    bwipp_raiseerror();
  }
  $_.tiles = $a([13135, 13136, 13153, 13156, 13163, 13165, 13513, 13515, 13516, 13531, 13535, 13536, 13561, 13563, 13565, 13613, 13615, 13616, 13631, 13635, 13636, 13651, 13653, 13656, 15135, 15136, 15153, 15163, 15165, 15313, 15315, 15316, 15351, 15353, 15356, 15361, 15363, 15365, 15613, 15615, 15616, 15631, 15635, 15636, 15651, 15653, 15656, 16135, 16136, 16153, 16156, 16165, 16313, 16315, 16316, 16351, 16353, 16356, 16361, 16363, 16365, 16513, 16515, 16516, 16531, 16535, 16536, 16561, 16563, 16565, 31315, 31316, 31351, 31356, 31361, 31365, 31513, 31515, 31516, 31531, 31535, 31536, 31561, 31563, 31565, 31613, 31615, 31631, 31635, 31636, 31651, 31653, 31656, 35131, 35135, 35136, 35151, 35153, 35156, 35161, 35163, 35165, 35315, 35316, 35351, 35356, 35361, 35365, 35613, 35615, 35616, 35631, 35635, 35636, 35651, 35653, 35656, 36131, 36135, 36136, 36151, 36153, 36156, 36163, 36165, 36315, 36316, 36351, 36356, 36361, 36365, 36513, 36515, 36516, 36531, 36535, 36536, 36561, 36563, 36565, 51313, 51315, 51316, 51351, 51353, 51356, 51361, 51363, 51365, 51513, 51516, 51531, 51536, 51561, 51563, 51613, 51615, 51616, 51631, 51635, 51636, 51651, 51653, 51656, 53131, 53135, 53136, 53151, 53153, 53156, 53161, 53163, 53165, 53513, 53516, 53531, 53536, 53561, 53563, 53613, 53615, 53616, 53631, 53635, 53636, 53651, 53653, 53656, 56131, 56135, 56136, 56151, 56153, 56156, 56161, 56163, 56165, 56313, 56315, 56316, 56351, 56353, 56356, 56361, 56363, 56365, 56513, 56516, 56531, 56536, 56561, 56563, 61313, 61315, 61316, 61351, 61353, 61356, 61361, 61363, 61365, 61513, 61515, 61516, 61531, 61535, 61536, 61561, 61563, 61565, 61615, 61631, 61635, 61651, 61653, 63131, 63135, 63136, 63151, 63153, 63156, 63161, 63163, 63165, 63513, 63515, 63516, 63531, 63535, 63536, 63561, 63563, 63565, 63613, 63615, 63631, 63635, 63651, 63653, 65131, 65135, 65136, 65151, 65153, 65156, 65161, 65163, 65165, 65313, 65315, 65316, 65351, 65353, 65356, 65361, 65363, 65365, 65613, 65615, 65631, 65635, 65651, 65653, 56565, 51515]);
  $_.dccurev1 = $a([51363, 51563, 51653, 53153, 53163, 53513, 53563, 53613, 53653, 56153, 56163, 56313, 56353, 56363, 56513, 56563, 51316, 51356, 51536, 51616, 53156, 53516, 53536, 53616, 53636, 53656, 56136, 56156, 56316, 56356, 56516, 56536]);
  $_.dcclrev1 = $a([61351, 61361, 61531, 61561, 61631, 61651, 63131, 63151, 63161, 63531, 63561, 63631, 65131, 65161, 65351, 65631, 31351, 31361, 31531, 31561, 31631, 31651, 35131, 35151, 35161, 35361, 35631, 35651, 36131, 36151, 36351, 36531]);
  $_.dccurev2 = $a([15316, 16316, 13516, 16516, 13616, 15616, 13136, 15136, 16136, 13536, 16536, 13636, 13156, 16156, 15356, 13656, 15313, 16313, 13513, 16513, 13613, 15613, 13153, 15153, 16153, 16353, 13653, 15653, 13163, 15163, 15363, 13563]);
  $_.dcclrev2 = $a([36315, 36515, 35615, 35135, 36135, 31535, 36535, 31635, 35635, 35165, 36165, 31365, 35365, 36365, 31565, 36565, 61315, 65315, 63515, 61615, 65135, 61535, 63535, 61635, 63635, 65635, 63165, 65165, 61365, 65365, 61565, 63565]);
  $k[$j++] = "dccu";
  if ($_.rev == 1) {
    $k[$j++] = $_.dccurev1;
  } else {
    $k[$j++] = $_.dccurev2;
  }
  var _3j = $k[--$j];
  $_[$k[--$j]] = _3j;
  $k[$j++] = "dccl";
  if ($_.rev == 1) {
    $k[$j++] = $_.dcclrev1;
  } else {
    $k[$j++] = $_.dcclrev2;
  }
  var _3o = $k[--$j];
  $_[$k[--$j]] = _3o;
  $_.rows = $_.rows * 6 + 1;
  $_.columns = $_.columns + 6;
  $k[$j++] = Infinity;
  for (var _3u = 0, _3v = $_.rows * $_.columns; _3u < _3v; _3u++) {
    $k[$j++] = -1;
  }
  $_.pixs = $a();
  $_.qmv = function() {
    var _3y = $k[--$j];
    var _3z = $k[--$j];
    $k[$j++] = $f(_3z + _3y * $_.columns);
  };
  for (var _42 = 0, _41 = $_.columns - 1; _42 <= _41; _42 += 1) {
    $_.i = _42;
    for (var _45 = 0, _44 = $_.rows - 1; _45 <= _44; _45 += 6) {
      $_.j = _45;
      if ($_.i >= 5) {
        $k[$j++] = $_.pixs;
        $k[$j++] = $_.i;
        $k[$j++] = $_.j;
        $_.qmv();
        var _4B = $k[--$j];
        $put($k[--$j], _4B, $_.i % 2 * 9);
      }
    }
    $k[$j++] = $_.pixs;
    $k[$j++] = $_.i;
    $k[$j++] = 0;
    $_.qmv();
    var _4F = $k[--$j];
    $put($k[--$j], _4F, 9);
    $k[$j++] = $_.pixs;
    $k[$j++] = $_.i;
    $k[$j++] = $_.rows - 1;
    $_.qmv();
    var _4K = $k[--$j];
    $put($k[--$j], _4K, 9);
  }
  for (var _4O = 1, _4N = $_.rows - 2; _4O <= _4N; _4O += 1) {
    $_.i = _4O;
    for (var _4R = 3, _4Q = $_.columns - 1; _4R <= _4Q; _4R += 16) {
      $_.j = _4R;
      $k[$j++] = $_.pixs;
      $k[$j++] = $_.j;
      $k[$j++] = $_.i;
      $_.qmv();
      var _4W = $k[--$j];
      $put($k[--$j], _4W, (1 - $_.i % 2) * 9);
    }
    $k[$j++] = $_.pixs;
    $k[$j++] = 0;
    $k[$j++] = $_.i;
    $_.qmv();
    var _4a = $k[--$j];
    $put($k[--$j], _4a, 9);
    $k[$j++] = $_.pixs;
    $k[$j++] = 1;
    $k[$j++] = $_.i;
    $_.qmv();
    var _4f = $k[--$j];
    $put($k[--$j], _4f, (1 - $_.i % 2) * 9);
    $k[$j++] = $_.pixs;
    $k[$j++] = 2;
    $k[$j++] = $_.i;
    $_.qmv();
    var _4j = $k[--$j];
    $put($k[--$j], _4j, 0);
    $k[$j++] = $_.pixs;
    $k[$j++] = 3;
    $k[$j++] = $_.i;
    $_.qmv();
    var _4n = $k[--$j];
    $put($k[--$j], _4n, 9);
    $k[$j++] = $_.pixs;
    $k[$j++] = 4;
    $k[$j++] = $_.i;
    $_.qmv();
    var _4r = $k[--$j];
    $put($k[--$j], _4r, 0);
    $k[$j++] = $_.pixs;
    $k[$j++] = $_.columns - 1;
    $k[$j++] = $_.i;
    $_.qmv();
    var _4w = $k[--$j];
    $put($k[--$j], _4w, 9);
  }
  $_.i = ~~($_.rows / 2) - 5;
  $k[$j++] = Infinity;
  var _53 = $cvrs($s(5), $get($_.dccu, $_.dcc), 10);
  for (var _54 = 0, _55 = _53.length; _54 < _55; _54++) {
    $k[$j++] = $get(_53, _54) - 48;
  }
  var _5B = $cvrs($s(5), $get($_.dccl, $_.dcc), 10);
  $k[$j++] = 0;
  for (var _5C = 0, _5D = _5B.length; _5C < _5D; _5C++) {
    $k[$j++] = $get(_5B, _5C) - 48;
  }
  var _5F = $a();
  for (var _5G = 0, _5H = _5F.length; _5G < _5H; _5G++) {
    $k[$j++] = $get(_5F, _5G);
    $k[$j++] = $_.pixs;
    $k[$j++] = 2;
    $k[$j++] = $_.i;
    $_.qmv();
    var _5L = $k[$j - 3];
    var _5M = $k[$j - 1];
    $put($k[$j - 2], _5M, _5L);
    $j -= 3;
    $_.i = $_.i + 1;
  }
  $k[$j++] = Infinity;
  $k[$j++] = $_.start;
  $k[$j++] = $_.mcc;
  $aload($_.ecws);
  $k[$j++] = $_.tcc;
  $k[$j++] = 283;
  $k[$j++] = $_.acc;
  $aload($_.dcws);
  for (var _5W = 0, _5X = $_.pads; _5W < _5X; _5W++) {
    $k[$j++] = 284;
  }
  $k[$j++] = $_.qcc;
  $_.tileseq = $a();
  $_.x = 5;
  $_.y = 1;
  var _5a = $_.tileseq;
  for (var _5b = 0, _5c = _5a.length; _5b < _5c; _5b++) {
    var _5h = $cvrs($s(5), $get($_.tiles, $get(_5a, _5b)), 10);
    for (var _5i = 0, _5j = _5h.length; _5i < _5j; _5i++) {
      $k[$j++] = $get(_5h, _5i);
      $k[$j++] = $_.pixs;
      $k[$j++] = $_.x;
      $k[$j++] = $_.y;
      $_.qmv();
      var _5o = $k[$j - 3];
      var _5p = $k[$j - 1];
      $put($k[$j - 2], _5p, _5o - 48);
      $j -= 3;
      $_.y = $_.y + 1;
    }
    if ($_.y != $_.rows - 1) {
      $_.y = $_.y + 1;
    } else {
      $_.x = $_.x + 1;
      $_.y = 1;
      $k[$j++] = $_.pixs;
      $k[$j++] = $_.x;
      $k[$j++] = $_.y;
      $_.qmv();
      var _5z = $k[--$j];
      if ($get($k[--$j], _5z) != -1) {
        $_.x = $_.x + 1;
      }
    }
  }
  var _63 = /* @__PURE__ */ new Map([
    [0, "FFFFFF"],
    [9, "000000"],
    [1, "00FFFF"],
    [3, "FF00FF"],
    [5, "FFFF00"],
    [6, "00FF00"]
  ]);
  $_.colormap = _63;
  var _6C = /* @__PURE__ */ new Map([
    ["ren", "renmatrix"],
    ["pixs", $_.pixs],
    ["pixx", $_.columns],
    ["pixy", $_.rows],
    ["height", $_.rows / 72 * 2],
    ["width", $_.columns / 72 * 2],
    ["colormap", $_.colormap],
    ["borderleft", 1],
    ["borderright", 1],
    ["bordertop", 1],
    ["borderbottom", 1],
    ["opt", $_.options]
  ]);
  $k[$j++] = _6C;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_jabcode() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.rows = -1;
  $_.columns = -1;
  $_.slave = false;
  $_.colors = 16;
  $_.eclevel = 6;
  $_.raw = false;
  $_.parse = false;
  $_.parsefnc = false;
  $_.mask = -1;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $_.databpm = ~~$round($log($_.colors) / $log(2));
  var _3 = $_.colors;
  $k[$j++] = "metabpm";
  $k[$j++] = _3;
  if (_3 > 8) {
    $k[$j - 1] = 8;
  }
  var _4 = $k[--$j];
  $_[$k[--$j]] = ~~$round($log(_4) / $log(2));
  $_.fn1 = -1;
  var _9 = /* @__PURE__ */ new Map([
    ["parse", $_.parse],
    ["parsefnc", $_.parsefnc],
    ["FNC1", $_.fn1]
  ]);
  $_.fncvals = _9;
  $k[$j++] = "msg";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.fncvals;
  bwipp_parseinput();
  var _C = $k[--$j];
  $_[$k[--$j]] = _C;
  $_.msglen = $_.msg.length;
  $_.addtobits = function() {
    var _F = $k[--$j];
    $puti($_.bits, $_.j, _F);
    $_.j = _F.length + $_.j;
  };
  $_.tofixedbits = function() {
    var _K = $strcpy($s(13), "0000000000000");
    $k[$j++] = _K;
    $k[$j++] = _K;
    $r(4, -1);
    var _N = $cvrs($s(13), $k[--$j], 2);
    var _O = $k[--$j];
    var _P = $k[--$j];
    var _Q = $k[--$j];
    $puti(_O, $f(_Q - _N.length), _N);
    $k[$j++] = $geti(_P, 0, _Q);
  };
  var _T = $_.msglen <= 15 ? 4 : 17;
  $_.bits = $s(7 + _T + $_.msglen * 8 + 12);
  $_.j = 0;
  $k[$j++] = 31;
  $k[$j++] = 5;
  $_.tofixedbits();
  $_.addtobits();
  $k[$j++] = "00";
  $_.addtobits();
  if ($_.msglen <= 15) {
    $k[$j++] = $_.msglen;
    $k[$j++] = 4;
    $_.tofixedbits();
    $_.addtobits();
  } else {
    $k[$j++] = "0000";
    $_.addtobits();
    $k[$j++] = $_.msglen - 16;
    $k[$j++] = 13;
    $_.tofixedbits();
    $_.addtobits();
  }
  for (var _b = 0, _a = $_.msglen - 1; _b <= _a; _b += 1) {
    $k[$j++] = $get($_.msg, _b);
    $k[$j++] = 8;
    $_.tofixedbits();
    $_.addtobits();
  }
  $k[$j++] = 28;
  $k[$j++] = 5;
  $_.tofixedbits();
  $_.addtobits();
  $k[$j++] = 31;
  $k[$j++] = 5;
  $_.tofixedbits();
  $_.addtobits();
  $k[$j++] = "11";
  $_.addtobits();
  $_.diffside = 21;
  $_.sameshape = false;
  $_.sameecc = false;
  $_.hasslaves = false;
  $_.metrics = function() {
    $_.mc = $k[--$j];
    $_.mr = $k[--$j];
    var _g = $_.mc;
    var _h = $_.mr;
    var _i = $_.mc;
    var _j = $_.mr;
    var _k = $_.colors;
    var _l = 64;
    if (64 > _k) {
      var _2 = _k;
      _k = _l;
      _l = _2;
    }
    var _n = $_.slave ? 7 : 17;
    $k[$j++] = _g * _h;
    $k[$j++] = ((~~((_i - 25) / 16) + 2) * (~~((_j - 25) / 16) + 2) - 4) * 7;
    $k[$j++] = _l * 2;
    $k[$j++] = _n * 4;
    if (!$_.slave) {
      var _r = $eq($_.mr, $_.mc) ? 0 : 1;
      $_.metass = _r;
      var _s = $_.mr;
      var _t = $_.mc;
      if ($lt(_s, _t)) {
        var _2 = _t;
        _t = _s;
        _s = _2;
      }
      $_.metavf = $get($a([0, 1, 2, 2, 3, 3, 3, 3]), ~~((_s - 21) / 16));
      $k[$j++] = "metavlen";
      if ($_.metass == 0) {
        $k[$j++] = $a([2, 2, 3, 4]);
      } else {
        $k[$j++] = $a([4, 6, 8, 10]);
      }
      var _11 = $get($k[--$j], $_.metavf);
      $_[$k[--$j]] = _11;
      $_.metaelen = $_.metavf * 2 + 10;
      $k[$j++] = $f(7 + $_.metavlen + $_.metaelen);
      if ($_.hasslaves) {
        var _17 = $k[--$j];
        $k[$j++] = _17 + 4;
      }
      var _1A = ~~$ceil($k[--$j] * 2 / $_.metabpm);
      $_.nummetabits = _1A * $_.metabpm + 6;
      $k[$j++] = _1A + 6;
    } else {
      $k[$j++] = 3;
      if (!$_.sameshape) {
        var _1D = $k[--$j];
        $k[$j++] = _1D + 5;
      }
      if ($_.hasslaves) {
        var _1F = $k[--$j];
        $k[$j++] = _1F + 3;
      }
      if (!$_.sameecc) {
        var _1H = $_.mr;
        var _1I = $_.mc;
        if ($lt(_1H, _1I)) {
          var _2 = _1I;
          _1I = _1H;
          _1H = _2;
        }
        var _1L = $k[--$j];
        $k[$j++] = $f(_1L + $get($a([10, 12, 14, 14, 16, 16, 16, 16]), ~~((_1H - 21) / 16)));
      }
      var _1O = ~~$ceil($k[--$j] * 2 / $_.metabpm);
      $_.nummetabits = _1O * $_.metabpm;
      $k[$j++] = _1O;
    }
    var _1Q = $k[--$j];
    $_.nummetamodules = _1Q;
    var _1R = $k[--$j];
    var _1S = $k[--$j];
    var _1T = $k[--$j];
    $_.numdatamodules = $f($k[--$j] - (_1T + (_1S + (_1R + _1Q))));
    $_.numdatabits = $_.numdatamodules * $_.databpm;
  };
  $_.coderate = $get($a([0.67, 0.63, 0.57, 0.55, 0.5, 0.43, 0.34, 0.25, 0.2, 0.17, 0.14]), $_.eclevel);
  $_.grosslen = ~~$ceil($_.bits.length / $_.coderate);
  $_.snapsize = function() {
    var _1d = ~~$ceil($k[--$j]) - 18;
    $k[$j++] = _1d;
    if (_1d < 0) {
      $k[$j - 1] = 0;
    }
    var _1e = $k[--$j];
    $k[$j++] = ~~(_1e / 4) * 4 + 21;
  };
  if ($_.rows == -1 && $_.columns == -1) {
    $k[$j++] = "size";
    $k[$j++] = $sqrt($_.grosslen);
    $_.snapsize();
    var _1i = $k[--$j];
    $_[$k[--$j]] = _1i;
    for (; ; ) {
      $k[$j++] = $_.size;
      $k[$j++] = $_.size;
      $_.metrics();
      if ($_.grosslen <= $_.numdatabits) {
        break;
      }
      $_.size = $_.size + 4;
    }
    $_.rows = $_.size;
    $_.columns = $_.size;
  } else {
    if ($_.columns == -1 && $_.rows != -1) {
      $k[$j++] = "columns";
      $k[$j++] = $_.grosslen / $_.rows;
      $_.snapsize();
      var _1v = $k[--$j];
      $_[$k[--$j]] = _1v;
      for (; ; ) {
        $k[$j++] = $_.rows;
        $k[$j++] = $_.columns;
        $_.metrics();
        if ($_.grosslen <= $_.numdatabits) {
          break;
        }
        $_.columns = $_.columns + 4;
      }
    }
    if ($_.rows == -1 && $_.columns != -1) {
      $k[$j++] = "rows";
      $k[$j++] = $_.grosslen / $_.columns;
      $_.snapsize();
      var _26 = $k[--$j];
      $_[$k[--$j]] = _26;
      for (; ; ) {
        $k[$j++] = $_.rows;
        $k[$j++] = $_.columns;
        $_.metrics();
        if ($_.grosslen <= $_.numdatabits) {
          break;
        }
        $_.rows = $_.rows + 4;
      }
    }
    if ($_.rows != -1 && $_.columns != -1) {
      $k[$j++] = $_.rows;
      $k[$j++] = $_.columns;
      $_.metrics();
    }
  }
  $_.C = $_.numdatabits;
  $_.cols = $_.columns;
  if ($_.rows > 145 || $_.cols > 145) {
    $k[$j++] = "bwipp.jabcodeNoValidSymbol#27844";
    $k[$j++] = "Maximum length exceeded or invalid content";
    bwipp_raiseerror();
  }
  $_.min = $_.C;
  for (var _2M = 3; _2M <= 8; _2M += 1) {
    $_.i = _2M;
    for (var _2O = $_.i + 1; _2O <= 9; _2O += 1) {
      $_.j = _2O;
      $_.dist = ~~($_.C / $_.j) * $_.j - ~~($_.C / $_.j) * $_.i - $_.bits.length;
      if ($_.dist < $_.min && $_.dist >= 0) {
        $_.datawc = $_.i;
        $_.datawr = $_.j;
        $_.min = $_.dist;
      }
    }
  }
  $_.tmpbits = $s(~~($_.C / $_.datawr) * $_.datawr - ~~($_.C / $_.datawr) * $_.datawc);
  $puti($_.tmpbits, 0, $_.bits);
  for (var _2o = $_.bits.length, _2n = $_.tmpbits.length - 1; _2o <= _2n; _2o += 1) {
    var _2q = $get($_.tmpbits, _2o - 1);
    $k[$j++] = _2o;
    $k[$j++] = _2q;
    if (_2q % 2 == 0) {
      var _2r = $k[--$j];
      $k[$j++] = _2r + 1;
    } else {
      var _2s = $k[--$j];
      $k[$j++] = _2s - 1;
    }
    $k[$j++] = $_.tmpbits;
    var _2u = $k[$j - 2];
    var _2v = $k[$j - 3];
    $put($k[$j - 1], _2v, _2u);
    $j -= 3;
  }
  $_.bits = $_.tmpbits;
  $_.m0 = 22609 + 1;
  $_.m1 = 62509 - 65536;
  $_.m2 = 19605;
  $_.m3 = 32557;
  $_.lcg64_temper = function() {
    $_.p00 = $_.m0 * $_.s0;
    $_.p01 = $_.m0 * $_.s1;
    $_.p02 = $_.m0 * $_.s2;
    $_.p03 = $_.m0 * $_.s3;
    $_.p10 = $_.m1 * $_.s0;
    $_.p11 = $_.m1 * $_.s1;
    $_.p12 = $_.m1 * $_.s2;
    $_.p13 = $_.m1 * $_.s3;
    $_.p20 = $_.m2 * $_.s0;
    $_.p21 = $_.m2 * $_.s1;
    $_.p22 = $_.m2 * $_.s2;
    $_.p23 = $_.m2 * $_.s3;
    $_.p30 = $_.m3 * $_.s0;
    $_.p31 = $_.m3 * $_.s1;
    $_.p32 = $_.m3 * $_.s2;
    $_.p33 = $_.m3 * $_.s3;
    $_.s3 = $_.p33 % 65536 + 1;
    $_.s2 = $_.p32 % 65536 + ~~($_.p33 / 65536) + $_.p23 % 65536;
    $_.s1 = $_.p31 % 65536 + ~~($_.p32 / 65536) + ($_.p22 % 65536 + ~~($_.p23 / 65536)) + $_.p13 % 65536;
    $_.s0 = $_.p30 % 65536 + ~~($_.p31 / 65536) + ($_.p21 % 65536 + ~~($_.p22 / 65536)) + ($_.p12 % 65536 + ~~($_.p13 / 65536)) + $_.p03 % 65536;
    $_.s3 = $_.s3 + 65536;
    $_.s2 = $_.s2 + 65535;
    $_.s1 = $_.s1 + 65535;
    $_.s0 = $_.s0 + 65535;
    $_.s2 = ~~($_.s3 / 65536) + $_.s2;
    $_.s3 = $_.s3 % 65536;
    $_.s1 = ~~($_.s2 / 65536) + $_.s1;
    $_.s2 = $_.s2 % 65536;
    $_.s0 = ~~($_.s1 / 65536) + $_.s0;
    $_.s1 = $_.s1 % 65536;
    $_.s0 = $_.s0 % 65536;
    var _40 = (($_.s0 - 32768) * 65536 + $_.s1 ^ 2147483648) & 4294967295;
    var _41 = _40 ^ _40 >>> 11;
    var _42 = _41 ^ _41 << 7 & -1658038656;
    var _43 = (_42 ^ _42 << 15 & -272236544) & 4294967295;
    $k[$j++] = _43 ^ _43 >>> 18;
  };
  $_.createMatrixA = function() {
    $k[$j++] = "nb_pcb";
    if ($_.wr < 4) {
      $k[$j++] = ~~($_.Pg_sub_block / 2);
    } else {
      $k[$j++] = ~~($_.Pg_sub_block / $_.wr) * $_.wc;
    }
    var _49 = $k[--$j];
    $_[$k[--$j]] = _49;
    $_.offset = ~~$ceil($_.Pg_sub_block / 32);
    $_.effwidth = $_.offset * 32;
    $_.matrixA = $a($_.offset * $_.nb_pcb);
    for (var _4J = 0, _4I = $_.offset * $_.nb_pcb - 1; _4J <= _4I; _4J += 1) {
      $put($_.matrixA, _4J, 0);
    }
    $_.permutation = $a($_.Pg_sub_block);
    for (var _4P = 0, _4O = $_.Pg_sub_block - 1; _4P <= _4O; _4P += 1) {
      $put($_.permutation, _4P, _4P);
    }
    for (var _4U = 0, _4T = ~~($_.Pg_sub_block / $_.wr) - 1; _4U <= _4T; _4U += 1) {
      $_.i = _4U;
      for (var _4X = 0, _4W = $_.wr - 1; _4X <= _4W; _4X += 1) {
        $_.j = _4X;
        var _4Y = $_.matrixA;
        var _4Z = $_.i;
        var _4a = $_.effwidth;
        var _4b = $_.wr;
        var _4c = $_.j;
        var _4i = 31 - $f($_.i * ($_.effwidth + $_.wr) + $_.j) % 32;
        $put(_4Y, ~~($f(_4Z * (_4a + _4b) + _4c) / 32), $get(_4Y, ~~($f(_4Z * (_4a + _4b) + _4c) / 32)) | (_4i < 0 ? 1 >>> -_4i : 1 << _4i));
      }
    }
    $_.s0 = 0;
    $_.s1 = 0;
    $_.s2 = 11;
    $_.s3 = 64569;
    for (var _4l = 1, _4k = $_.wc - 1; _4l <= _4k; _4l += 1) {
      $_.i = _4l;
      $_.off_index = ~~($_.Pg_sub_block / $_.wr) * $_.i;
      for (var _4r = 0, _4q = $_.Pg_sub_block - 1; _4r <= _4q; _4r += 1) {
        $_.j = _4r;
        $_.lcg64_temper();
        var _4s = $k[$j - 1];
        if (_4s < 0) {
          var _4t = $k[--$j];
          $k[$j++] = (_4t ^ 2147483648) + 2147483648;
        }
        $_.pos = ~~($k[--$j] / 4294967296 * ($_.Pg_sub_block - $_.j));
        for (var _50 = 0, _4z = ~~($_.Pg_sub_block / $_.wr) - 1; _50 <= _4z; _50 += 1) {
          $_.k = _50;
          var _51 = $_.matrixA;
          var _52 = $_.off_index;
          var _53 = $_.k;
          var _54 = $_.offset;
          var _55 = $_.j;
          var _5D = $get($_.matrixA, ~~($get($_.permutation, $_.pos) / 32) + $_.k * $_.offset);
          var _5H = -(31 - $get($_.permutation, $_.pos) % 32);
          var _5J = 31 - $_.j % 32;
          $put(_51, (_52 + _53) * _54 + ~~(_55 / 32), $get(_51, (_52 + _53) * _54 + ~~(_55 / 32)) | (_5J < 0 ? ((_5H < 0 ? _5D >>> -_5H : _5D << _5H) & 1) >>> -_5J : ((_5H < 0 ? _5D >>> -_5H : _5D << _5H) & 1) << _5J));
        }
        var _5M = $_.permutation;
        var _5N = $_.Pg_sub_block;
        var _5O = $_.j;
        $put(_5M, _5N - 1 - _5O, $get($_.permutation, $_.pos));
        $put($_.permutation, $_.pos, $get(_5M, _5N - 1 - _5O));
      }
    }
  };
  $_.createMetadataMatrixA = function() {
    $_.nb_pcb = ~~($_.Pg_sub_block / 2);
    $_.offset = ~~$ceil($_.Pg_sub_block / 32);
    $_.matrixA = $a($_.offset * $_.nb_pcb);
    for (var _5b = 0, _5a = $_.offset * $_.nb_pcb - 1; _5b <= _5a; _5b += 1) {
      $put($_.matrixA, _5b, 0);
    }
    $_.permutation = $a($_.Pg_sub_block);
    for (var _5h = 0, _5g = $_.Pg_sub_block - 1; _5h <= _5g; _5h += 1) {
      $put($_.permutation, _5h, _5h);
    }
    $_.s0 = 0;
    $_.s1 = 0;
    $_.s2 = 0;
    $_.s3 = 38545;
    $_.nb_once = ~~(~~($_.nb_pcb / $_.wc * $_.Pg_sub_block + 3) / $_.nb_pcb);
    for (var _5p = 0, _5o = $_.nb_pcb - 1; _5p <= _5o; _5p += 1) {
      $_.i = _5p;
      for (var _5s = 0, _5r = $_.nb_once - 1; _5s <= _5r; _5s += 1) {
        $_.j = _5s;
        $_.lcg64_temper();
        var _5t = $k[$j - 1];
        if (_5t < 0) {
          var _5u = $k[--$j];
          $k[$j++] = (_5u ^ 2147483648) + 2147483648;
        }
        $_.pos = ~~($k[--$j] / 4294967296 * ($_.Pg_sub_block - $_.j));
        var _5y = $_.matrixA;
        var _5z = $_.i;
        var _60 = $_.offset;
        var _63 = $get($_.permutation, $_.pos);
        var _68 = 31 - $get($_.permutation, $_.pos) % 32;
        $put(_5y, _5z * _60 + ~~(_63 / 32), $get(_5y, _5z * _60 + ~~(_63 / 32)) | (_68 < 0 ? 1 >>> -_68 : 1 << _68));
        var _6B = $_.permutation;
        var _6C = $_.Pg_sub_block;
        var _6D = $_.j;
        $put(_6B, _6C - 1 - _6D, $get($_.permutation, $_.pos));
        $put($_.permutation, $_.pos, $get(_6B, _6C - 1 - _6D));
      }
    }
  };
  $_.GaussJordan = function() {
    $k[$j++] = "nb_pcb";
    if ($_.wr < 4) {
      $k[$j++] = ~~($_.Pg_sub_block / 2);
    } else {
      $k[$j++] = ~~($_.Pg_sub_block / $_.wr) * $_.wc;
    }
    var _6N = $k[--$j];
    $_[$k[--$j]] = _6N;
    $_.offset = ~~$ceil($_.Pg_sub_block / 32);
    var _6Q = $_.matrixA;
    $_.matrixH = $arrcpy($a(_6Q.length), _6Q);
    $k[$j++] = Infinity;
    for (var _6U = 0, _6V = $_.Pg_sub_block; _6U < _6V; _6U++) {
      $k[$j++] = 0;
    }
    $_.column_arrangement = $a();
    $k[$j++] = Infinity;
    for (var _6Y = 0, _6Z = $_.Pg_sub_block; _6Y < _6Z; _6Y++) {
      $k[$j++] = false;
    }
    $_.processed_column = $a();
    $k[$j++] = Infinity;
    for (var _6c = 0, _6d = $_.nb_pcb; _6c < _6d; _6c++) {
      $k[$j++] = 0;
    }
    $_.zero_lines_nb = $a();
    $k[$j++] = Infinity;
    for (var _6g = 0, _6h = $_.Pg_sub_block * 2; _6g < _6h; _6g++) {
      $k[$j++] = 0;
    }
    $_.swap_col = $a();
    $_.zero_lines = 0;
    $_.loop0 = 0;
    for (var _6l = 0, _6k = $_.nb_pcb - 1; _6l <= _6k; _6l += 1) {
      $_.i = _6l;
      $_.pivot_column = $_.Pg_sub_block + 1;
      for (var _6p = 0, _6o = $_.Pg_sub_block - 1; _6p <= _6o; _6p += 1) {
        $_.j = _6p;
        var _6u = $get($_.matrixH, ~~(($_.offset * 32 * $_.i + $_.j) / 32));
        var _6y = -(31 - ($_.offset * 32 * $_.i + $_.j) % 32);
        if (((_6y < 0 ? _6u >>> -_6y : _6u << _6y) & 1) == 1) {
          $_.pivot_column = $_.j;
          break;
        }
      }
      if ($_.pivot_column < $_.Pg_sub_block) {
        $put($_.processed_column, $_.pivot_column, true);
        $put($_.column_arrangement, $_.pivot_column, $_.i);
        if ($_.pivot_column >= $_.nb_pcb) {
          $put($_.swap_col, $_.loop0 * 2, $_.pivot_column);
          $_.loop0 = $_.loop0 + 1;
        }
        $_.off_index = ~~($_.pivot_column / 32);
        $_.off_index1 = $_.pivot_column % 32;
        for (var _7H = 0, _7G = $_.nb_pcb - 1; _7H <= _7G; _7H += 1) {
          $_.j = _7H;
          if ($_.i != $_.j) {
            var _7O = $get($_.matrixH, $_.off_index + $_.j * $_.offset);
            var _7Q = -(31 - $_.off_index1);
            if (((_7Q < 0 ? _7O >>> -_7Q : _7O << _7Q) & 1) == 1) {
              for (var _7T = 0, _7S = $_.offset - 1; _7T <= _7S; _7T += 1) {
                $_.k = _7T;
                var _7U = $_.matrixH;
                var _7V = $_.offset;
                var _7W = $_.j;
                var _7X = $_.k;
                $put(_7U, _7V * _7W + _7X, $xo($get(_7U, _7V * _7W + _7X), $get($_.matrixH, $_.offset * $_.i + $_.k)));
              }
            }
          }
        }
      } else {
        $put($_.zero_lines_nb, $_.zero_lines, $_.i);
        $_.zero_lines = $_.zero_lines + 1;
      }
    }
    $_.matrix_rank = $_.nb_pcb - $_.zero_lines;
    $_.loop2 = 0;
    for (var _7n = $_.matrix_rank, _7m = $_.nb_pcb - 1; _7n <= _7m; _7n += 1) {
      $_.i = _7n;
      if ($get($_.column_arrangement, $_.i) > 0) {
        for (var _7t = 0, _7s = $_.nb_pcb - 1; _7t <= _7s; _7t += 1) {
          $_.j = _7t;
          if (!$get($_.processed_column, $_.j)) {
            $put($_.column_arrangement, $_.j, $get($_.column_arrangement, $_.i));
            $put($_.column_arrangement, $_.i, 0);
            $put($_.processed_column, $_.j, true);
            $put($_.processed_column, $_.i, false);
            $put($_.swap_col, $_.loop0 * 2, $_.i);
            $put($_.swap_col, $_.loop0 * 2 + 1, $_.j);
            $put($_.column_arrangement, $_.i, $_.j);
            $_.loop0 = $_.loop0 + 1;
            $_.loop2 = $_.loop2 + 1;
            break;
          }
        }
      }
    }
    $_.loop1 = 0;
    for (var _8L = 0, _8K = $_.nb_pcb - 1; _8L <= _8K; _8L += 1) {
      $_.kl = _8L;
      if (!$get($_.processed_column, $_.kl) && $_.loop1 < $_.loop0 - $_.loop2) {
        $put($_.column_arrangement, $_.kl, $get($_.column_arrangement, $get($_.swap_col, $_.loop1 * 2)));
        $put($_.processed_column, $_.kl, true);
        $put($_.swap_col, $_.loop1 * 2 + 1, $_.kl);
        $_.loop1 = $_.loop1 + 1;
      }
    }
    $_.loop1 = 0;
    for (var _8h = 0, _8g = $_.nb_pcb - 1; _8h <= _8g; _8h += 1) {
      $_.kl = _8h;
      if (!$get($_.processed_column, $_.kl)) {
        $put($_.column_arrangement, $_.kl, $get($_.zero_lines_nb, $_.loop1));
        $_.loop1 = $_.loop1 + 1;
      }
    }
    for (var _8t = 0, _8s = $_.nb_pcb - 1; _8t <= _8s; _8t += 1) {
      $_.i = _8t;
      for (var _8w = 0, _8v = $_.offset - 1; _8w <= _8v; _8w += 1) {
        $_.j = _8w;
        $put($_.matrixA, $_.i * $_.offset + $_.j, $get($_.matrixH, $f($get($_.column_arrangement, $_.i) * $_.offset + $_.j)));
      }
    }
    $_.tmp = 0;
    for (var _9A = 0, _99 = $_.loop0 - 1; _9A <= _99; _9A += 1) {
      $_.i = _9A;
      for (var _9D = 0, _9C = $_.nb_pcb - 1; _9D <= _9C; _9D += 1) {
        $_.j = _9D;
        var _9K = $get($_.matrixA, ~~($get($_.swap_col, $_.i * 2) / 32) + $_.j * $_.offset);
        var _9O = -(31 - $get($_.swap_col, $_.i * 2) % 32);
        $_.tmp = (-((_9O < 0 ? _9K >>> -_9O : _9K << _9O) & 1) ^ $_.tmp) & 1 ^ $_.tmp;
        var _9R = $_.matrixA;
        var _9U = $get($_.swap_col, $_.i * 2);
        var _9V = $_.j;
        var _9W = $_.offset;
        var _9e = $get($_.matrixA, ~~($get($_.swap_col, $_.i * 2 + 1) / 32) + $_.j * $_.offset);
        var _9i = -(31 - $get($_.swap_col, $_.i * 2 + 1) % 32);
        var _9t = 31 - $get($_.swap_col, $_.i * 2) % 32;
        $put(_9R, ~~(_9U / 32) + _9V * _9W, $get(_9R, ~~(_9U / 32) + _9V * _9W) ^ (-((_9i < 0 ? _9e >>> -_9i : _9e << _9i) & 1) ^ $get($_.matrixA, ~~($get($_.swap_col, $_.i * 2) / 32) + $_.j * $_.offset)) & (_9t < 0 ? 1 >>> -_9t : 1 << _9t));
        var _9u = $_.matrixA;
        var _9x = $get($_.swap_col, $_.i * 2 + 1);
        var _9y = $_.j;
        var _9z = $_.offset;
        var _AC = 31 - $get($_.swap_col, $_.i * 2 + 1) % 32;
        $put(_9u, ~~(_9x / 32) + _9y * _9z, $get(_9u, ~~(_9x / 32) + _9y * _9z) ^ (-($_.tmp & 1) ^ $get($_.matrixA, ~~($get($_.swap_col, $_.i * 2 + 1) / 32) + $_.j * $_.offset)) & (_AC < 0 ? 1 >>> -_AC : 1 << _AC));
      }
    }
  };
  $_.createGeneratorMatrix = function() {
    $_.pn = $_.Pg_sub_block - $_.matrix_rank;
    $_.offset = ~~$ceil($_.pn / 32);
    $_.effwidth = $_.offset * 32;
    $_.offset_cap = ~~$ceil($_.Pg_sub_block / 32);
    $_.G = $a($_.offset * $_.Pg_sub_block);
    for (var _AO = 0, _AN = $_.offset * $_.Pg_sub_block - 1; _AO <= _AN; _AO += 1) {
      $put($_.G, _AO, 0);
    }
    for (var _AS = 0, _AR = $_.pn - 1; _AS <= _AR; _AS += 1) {
      $_.i = _AS;
      var _AT = $_.G;
      var _AU = $_.Pg_sub_block;
      var _AV = $_.pn;
      var _AW = $_.i;
      var _AX = $_.offset;
      var _AY = $_.i;
      var _Ab = 31 - $_.i % 32;
      $put(_AT, (_AU - _AV + _AW) * _AX + ~~(_AY / 32), $get(_AT, (_AU - _AV + _AW) * _AX + ~~(_AY / 32)) | (_Ab < 0 ? 1 >>> -_Ab : 1 << _Ab));
    }
    $_.matrix_index = $_.Pg_sub_block - $_.pn;
    $_.loop0 = 0;
    for (var _Ai = 0, _Ah = ($_.Pg_sub_block - $_.pn) * $_.effwidth - 1; _Ai <= _Ah; _Ai += 1) {
      $_.i = _Ai;
      if ($_.matrix_index >= $_.Pg_sub_block) {
        $_.loop0 = $_.loop0 + 1;
        $_.matrix_index = $_.Pg_sub_block - $_.pn;
      }
      if ($_.i % $_.effwidth < $_.pn) {
        var _Ar = $_.G;
        var _As = $_.i;
        var _Ay = $get($_.matrixA, ~~($_.matrix_index / 32) + $_.offset_cap * $_.loop0);
        var _B0 = -(31 - $_.matrix_index % 32);
        var _B5 = 31 - $_.i % 32;
        $put(_Ar, ~~(_As / 32), $get(_Ar, ~~(_As / 32)) ^ (-((_B0 < 0 ? _Ay >>> -_B0 : _Ay << _B0) & 1) ^ $get($_.G, ~~($_.i / 32))) & (_B5 < 0 ? 1 >>> -_B5 : 1 << _B5));
        $_.matrix_index = $_.matrix_index + 1;
      }
    }
  };
  $_.ldpc = function() {
    $_.wr = $k[--$j];
    $_.wc = $k[--$j];
    $k[$j++] = Infinity;
    var _B9 = $k[--$j];
    var _BA = $k[--$j];
    $k[$j++] = _B9;
    $forall(_BA, function() {
      var _BB = $k[--$j];
      $k[$j++] = _BB - 48;
    });
    $_.data = $a();
    $_.Pn = $_.data.length;
    if ($_.wr != -1) {
      $_.Pg = ~~($ceil($ceil($_.Pn * $_.wr / $f($_.wr - $_.wc)) / $_.wr) * $_.wr);
      $_.nb_sub_blocks = ~~($_.Pg / 2700) + 1;
      $_.Pg_sub_block = ~~(~~($_.Pg / $_.nb_sub_blocks) / $_.wr) * $_.wr;
      $_.Pn_sub_block = ~~($_.Pg_sub_block * $f($_.wr - $_.wc) / $_.wr);
      $_.nb_sub_blocks = ~~($_.Pg / $_.Pg_sub_block);
      $k[$j++] = "encoding_iterations";
      $k[$j++] = ~~($_.Pg / $_.Pg_sub_block);
      if ($_.Pn_sub_block * $_.nb_sub_blocks < $_.Pn) {
        var _Bb = $k[--$j];
        $k[$j++] = _Bb - 1;
      }
      var _Bc = $k[--$j];
      $_[$k[--$j]] = _Bc;
      $_.createMatrixA();
    } else {
      $_.Pg = $_.Pn * 2;
      $_.nb_sub_blocks = 1;
      $_.Pg_sub_block = $_.Pg;
      $_.Pn_sub_block = $_.Pn;
      $_.encoding_iterations = 1;
      $_.createMetadataMatrixA();
    }
    $_.GaussJordan();
    $_.createGeneratorMatrix();
    $_.ecc_encoded_data = $a($_.Pg);
    $_.offset = ~~$ceil(($_.Pg_sub_block - $_.matrix_rank) / 32);
    for (var _Bn = 0, _Bm = $_.encoding_iterations - 1; _Bn <= _Bm; _Bn += 1) {
      $_.iter = _Bn;
      for (var _Bq = 0, _Bp = $_.Pg_sub_block - 1; _Bq <= _Bp; _Bq += 1) {
        $_.i = _Bq;
        $_.temp = 0;
        $_.loop0 = 0;
        $_.offset_index = $_.offset * $_.i;
        for (var _By = $_.iter * $_.Pn_sub_block, _Bx = ($_.iter + 1) * $_.Pn_sub_block - 1; _By <= _Bx; _By += 1) {
          var _C4 = $get($_.G, $_.offset_index + ~~($_.loop0 / 32));
          var _C6 = -(31 - $_.loop0 % 32);
          $_.temp = $get($_.data, _By) & ((_C6 < 0 ? _C4 >>> -_C6 : _C4 << _C6) & 1) ^ $_.temp;
          $_.loop0 = $_.loop0 + 1;
        }
        $put($_.ecc_encoded_data, $_.i + $_.iter * $_.Pg_sub_block, $_.temp);
      }
    }
    if ($_.encoding_iterations != $_.nb_sub_blocks) {
      $_.start = $_.encoding_iterations * $_.Pn_sub_block;
      $_.last_index = $_.encoding_iterations * $_.Pg_sub_block;
      $_.Pg_sub_block = $_.Pg - $_.encoding_iterations * $_.Pg_sub_block;
      $_.Pn_sub_block = ~~($_.Pg_sub_block * $f($_.wr - $_.wc) / $_.wr);
      $_.createMatrixA();
      $_.GaussJordan();
      $_.createGeneratorMatrix();
      $_.offset = ~~$ceil(($_.Pg_sub_block - $_.matrix_rank) / 32);
      for (var _CV = 0, _CU = $_.Pg_sub_block - 1; _CV <= _CU; _CV += 1) {
        $_.i = _CV;
        $_.temp = 0;
        $_.loop0 = 0;
        $_.offset_index = $_.offset * $_.i;
        for (var _Cb = $_.start, _Ca = $_.Pn - 1; _Cb <= _Ca; _Cb += 1) {
          var _Ch = $get($_.G, $_.offset_index + ~~($_.loop0 / 32));
          var _Cj = -(31 - $_.loop0 % 32);
          $_.temp = $get($_.data, _Cb) & ((_Cj < 0 ? _Ch >>> -_Cj : _Ch << _Cj) & 1) ^ $_.temp;
          $_.loop0 = $_.loop0 + 1;
        }
        $put($_.ecc_encoded_data, $_.i + $_.last_index, $_.temp);
      }
    }
    $_.out = $s($_.Pg);
    for (var _Cu = 0, _Ct = $_.Pg - 1; _Cu <= _Ct; _Cu += 1) {
      $put($_.out, _Cu, $get($_.ecc_encoded_data, _Cu) + 48);
    }
    $k[$j++] = $_.out;
  };
  $k[$j++] = "bits";
  $k[$j++] = $_.bits;
  $k[$j++] = $_.datawc;
  $k[$j++] = $_.datawr;
  $_.ldpc();
  var _D2 = $k[--$j];
  $_[$k[--$j]] = _D2;
  $_.s0 = 0;
  $_.s1 = 0;
  $_.s2 = 3;
  $_.s3 = 30151;
  for (var _D5 = $_.bits.length - 1; _D5 >= 1; _D5 -= 1) {
    $_.l = _D5;
    $_.lcg64_temper();
    var _D6 = $k[$j - 1];
    if (_D6 < 0) {
      var _D7 = $k[--$j];
      $k[$j++] = (_D7 ^ 2147483648) + 2147483648;
    }
    $_.r = ~~($k[--$j] / 4294967296 * ($_.l + 1));
    $put($_.bits, $_.l, $get($_.bits, $_.r));
    $put($_.bits, $_.r, $get($_.bits, $_.l));
  }
  $_.tmpbits = $s($_.C);
  $puti($_.tmpbits, 0, $_.bits);
  $_.j = $_.bits.length;
  for (var _DR = 0, _DS = ~~(($f($_.C - $_.j) + 1) / 2); _DR < _DS; _DR++) {
    $put($_.tmpbits, $_.j, 48);
    if ($_.j + 1 < $_.C) {
      $put($_.tmpbits, $_.j + 1, 49);
    }
    $_.j = $_.j + 2;
  }
  $_.bits = $_.tmpbits;
  if ($_.colors == 4) {
    $_.bi = 0;
    $_.gi = 1;
    $_.mi = 2;
    $_.yi = 3;
    $_.ki = 4;
    $_.wi = 5;
    $k[$j++] = Infinity;
    $k[$j++] = $_.bi;
    $k[$j++] = "0000FF";
    $k[$j++] = $_.gi;
    $k[$j++] = "00FF00";
    $k[$j++] = $_.mi;
    $k[$j++] = "FF00FF";
    $k[$j++] = $_.yi;
    $k[$j++] = "FFFF00";
    $k[$j++] = $_.ki;
    $k[$j++] = "000000";
    $k[$j++] = $_.wi;
    $k[$j++] = "FFFFFF";
    $_.palette = $d();
    $_.metacolorindex = $a([$_.bi, $_.gi, $_.mi, $_.yi]);
    $_.palettelayout = $a([$_.bi, $_.gi, $_.mi, $_.yi]);
  } else {
    var _Dz = /* @__PURE__ */ new Map([
      [8, $a([2, 2, 2])],
      [16, $a([4, 2, 2])],
      [32, $a([4, 4, 2])],
      [64, $a([4, 4, 4])],
      [128, $a([8, 4, 4])],
      [256, $a([8, 8, 4])]
    ]);
    $_.rgbres = $get(_Dz, $_.colors);
    $k[$j++] = "rvals";
    $k[$j++] = $get($_.rgbres, 0);
    $k[$j++] = Infinity;
    var _E4 = $k[--$j];
    var _E6 = $k[--$j] - 1;
    $k[$j++] = _E4;
    $k[$j++] = _E6;
    for (var _E8 = 0, _E7 = _E6; _E8 <= _E7; _E8 += 1) {
      var _E9 = $k[--$j];
      $k[$j++] = ~~$round(_E8 * (255 / _E9));
      $k[$j++] = _E9;
    }
    $j--;
    var _EA = $a();
    $_[$k[--$j]] = _EA;
    $k[$j++] = "gvals";
    $k[$j++] = $get($_.rgbres, 1);
    $k[$j++] = Infinity;
    var _EE = $k[--$j];
    var _EG = $k[--$j] - 1;
    $k[$j++] = _EE;
    $k[$j++] = _EG;
    for (var _EI = 0, _EH = _EG; _EI <= _EH; _EI += 1) {
      var _EJ = $k[--$j];
      $k[$j++] = ~~$round(_EI * (255 / _EJ));
      $k[$j++] = _EJ;
    }
    $j--;
    var _EK = $a();
    $_[$k[--$j]] = _EK;
    $k[$j++] = "bvals";
    $k[$j++] = $get($_.rgbres, 2);
    $k[$j++] = Infinity;
    var _EO = $k[--$j];
    var _EQ = $k[--$j] - 1;
    $k[$j++] = _EO;
    $k[$j++] = _EQ;
    for (var _ES = 0, _ER = _EQ; _ES <= _ER; _ES += 1) {
      var _ET = $k[--$j];
      $k[$j++] = ~~$round(_ES * (255 / _ET));
      $k[$j++] = _ET;
    }
    $j--;
    var _EU = $a();
    $_[$k[--$j]] = _EU;
    $_.colors;
    $_.palette = /* @__PURE__ */ new Map();
    var _EX = $_.colors;
    var _EY = 64;
    if (64 > _EX) {
      var _ = _EX;
      _EX = _EY;
      _EY = _;
    }
    $_.palettelayout = $a(_EY);
    $_.i = 0;
    $_.j = 8;
    $forall($_.rvals, function() {
      $_.r = $k[--$j];
      $forall($_.gvals, function() {
        $_.g = $k[--$j];
        $forall($_.bvals, function() {
          $_.b = $k[--$j];
          var _Ek = $strcpy($s(6), "000000");
          var _Em = $cvrs($s(6), $_.r << 16 | $_.g << 8 | $_.b, 16);
          $puti(_Ek, 6 - _Em.length, _Em);
          $k[$j++] = _Ek;
          $k[$j++] = false;
          if ($eq(_Ek, "000000")) {
            $_.ki = $_.i;
            $k[$j - 1] = true;
          }
          var _Ep = $k[$j - 2];
          if ($eq(_Ep, "0000FF")) {
            $_.bi = $_.i;
            $k[$j - 1] = true;
          }
          var _Es = $k[$j - 2];
          if ($eq(_Es, "00FF00")) {
            $_.gi = $_.i;
            $k[$j - 1] = true;
          }
          var _Ev = $k[$j - 2];
          if ($eq(_Ev, "00FFFF")) {
            $_.ci = $_.i;
            $k[$j - 1] = true;
          }
          var _Ey = $k[$j - 2];
          if ($eq(_Ey, "FF0000")) {
            $_.ri = $_.i;
            $k[$j - 1] = true;
          }
          var _F1 = $k[$j - 2];
          if ($eq(_F1, "FF00FF")) {
            $_.mi = $_.i;
            $k[$j - 1] = true;
          }
          var _F4 = $k[$j - 2];
          if ($eq(_F4, "FFFF00")) {
            $_.yi = $_.i;
            $k[$j - 1] = true;
          }
          var _F7 = $k[$j - 2];
          if ($eq(_F7, "FFFFFF")) {
            $_.wi = $_.i;
            $k[$j - 1] = true;
          }
          if (!$k[--$j]) {
            if ($_.colors <= 64 || ($_.colors == 128 && ($_.r == 0 || $_.r == 73 || $_.r == 182 || $_.r == 255) || $_.colors == 256 && ($_.r == 0 || $_.r == 73 || $_.r == 182 || $_.r == 255) && ($_.g == 0 || $_.g == 73 || $_.g == 182 || $_.g == 255))) {
              $put($_.palettelayout, $_.j, $_.i);
              $_.j = $_.j + 1;
            }
          }
          $put($_.palette, $_.i, $k[--$j]);
          $_.i = $_.i + 1;
        });
      });
    });
    $puti($_.palettelayout, 0, $a([$_.ki, $_.bi, $_.gi, $_.ci, $_.ri, $_.mi, $_.yi, $_.wi]));
    $_.metacolorindex = $a([$_.ki, $_.bi, $_.gi, $_.ci, $_.ri, $_.mi, $_.yi, $_.wi]);
  }
  $k[$j++] = Infinity;
  for (var _Fs = 0, _Ft = $_.rows * $_.cols; _Fs < _Ft; _Fs++) {
    $k[$j++] = -1;
  }
  $_.pixs = $a();
  $_.jmv = function() {
    var _Fw = $k[--$j];
    var _Fx = $k[--$j];
    $k[$j++] = $f(_Fx + _Fw * $_.cols);
  };
  if (!$_.slave) {
    $_.fpat = $a([$a([1, 1, 1, 0, 0]), $a([1, 2, 2, 0, 0]), $a([1, 2, 1, 2, 1]), $a([0, 0, 2, 2, 1]), $a([0, 0, 1, 1, 1])]);
    $_.fmap = $a([$a([-1, $_.bi, $_.yi]), $a([-1, $_.yi, $_.bi]), $a([-1, $_.gi, $_.mi]), $a([-1, $_.mi, $_.gi])]);
  } else {
    $_.fpat = $a([$a([0, 0, 0, 0, 0]), $a([0, 2, 2, 0, 0]), $a([0, 2, 1, 2, 0]), $a([0, 0, 2, 2, 0]), $a([0, 0, 0, 0, 0])]);
    $_.fmap = $a([$a([-1, $_.ki, $_.wi]), $a([-1, $_.ki, $_.wi]), $a([-1, $_.ki, $_.wi]), $a([-1, $_.ki, $_.wi])]);
  }
  for (var _Gb = 0; _Gb <= 4; _Gb += 1) {
    $_.y = _Gb;
    for (var _Gc = 0; _Gc <= 4; _Gc += 1) {
      $_.x = _Gc;
      $_.fpb = $get($get($_.fpat, $_.y), $_.x);
      $k[$j++] = $_.pixs;
      $k[$j++] = $_.x + 1;
      $k[$j++] = $_.y + 1;
      $_.jmv();
      var _Gp = $k[--$j];
      $put($k[--$j], _Gp, $get($get($_.fmap, 0), $_.fpb));
      $k[$j++] = $_.pixs;
      $k[$j++] = $_.x + 1;
      $k[$j++] = $f($_.rows - $_.y) - 2;
      $_.jmv();
      var _Gz = $k[--$j];
      $put($k[--$j], _Gz, $get($get($_.fmap, 1), $_.fpb));
      $k[$j++] = $_.pixs;
      $k[$j++] = $f($_.x + $_.cols) - 6;
      $k[$j++] = $_.y + 1;
      $_.jmv();
      var _H9 = $k[--$j];
      $put($k[--$j], _H9, $get($get($_.fmap, 2), $_.fpb));
      $k[$j++] = $_.pixs;
      $k[$j++] = $f($_.x + $_.cols) - 6;
      $k[$j++] = $f($_.rows - $_.y) - 2;
      $_.jmv();
      var _HK = $k[--$j];
      $put($k[--$j], _HK, $get($get($_.fmap, 3), $_.fpb));
    }
  }
  $_.algnpat0 = $a([$a([$_.ki, $_.ki, -1]), $a([$_.ki, $_.wi, $_.ki]), $a([-1, $_.ki, $_.ki])]);
  $_.algnpat1 = $a([$a([-1, $_.ki, $_.ki]), $a([$_.ki, $_.wi, $_.ki]), $a([$_.ki, $_.ki, -1])]);
  $_.num = ~~$round($_.cols / 16) - 1;
  $_.algnrpos = $a([3, 17]);
  if ($_.num > 0) {
    $k[$j++] = Infinity;
    for (var _Hn = 0, _Hm = $_.num; _Hn <= _Hm; _Hn += 1) {
      $k[$j++] = ~~(_Hn * (($_.cols - 7) / $_.num)) + 3;
    }
    $_.algnrpos = $a();
  }
  $_.num = ~~$round($_.rows / 16) - 1;
  $_.algncpos = $a([3, 17]);
  if ($_.num > 0) {
    $k[$j++] = Infinity;
    for (var _Hw = 0, _Hv = $_.num; _Hw <= _Hv; _Hw += 1) {
      $k[$j++] = ~~(_Hw * (($_.rows - 7) / $_.num)) + 3;
    }
    $_.algncpos = $a();
  }
  $_.putalgnpat = function() {
    $_.pp = $k[--$j];
    $_.py = $k[--$j];
    $_.px = $k[--$j];
    for (var _I3 = 0; _I3 <= 2; _I3 += 1) {
      $_.pb = _I3;
      for (var _I4 = 0; _I4 <= 2; _I4 += 1) {
        $_.pa = _I4;
        $k[$j++] = $_.pixs;
        $k[$j++] = $f($_.px + $_.pa);
        $k[$j++] = $f($_.py + $_.pb);
        $_.jmv();
        var _IF = $k[--$j];
        $put($k[--$j], _IF, $get($get($_.pp, $_.pb), $_.pa));
      }
    }
  };
  for (var _IJ = 0, _II = $_.algncpos.length - 1; _IJ <= _II; _IJ += 1) {
    $_.j = _IJ;
    $_.y = $get($_.algncpos, $_.j);
    for (var _IP = 0, _IO = $_.algnrpos.length - 1; _IP <= _IO; _IP += 1) {
      $_.i = _IP;
      $_.x = $get($_.algnrpos, $_.i);
      $k[$j++] = $_.pixs;
      $k[$j++] = $_.x;
      $k[$j++] = $_.y;
      $_.jmv();
      var _IW = $k[--$j];
      if ($get($k[--$j], _IW) == -1) {
        $k[$j++] = $_.x - 1;
        $k[$j++] = $_.y - 1;
        if (($_.i + $_.j) % 2 == 0) {
          $k[$j++] = $_.algnpat0;
        } else {
          $k[$j++] = $_.algnpat1;
        }
        $_.putalgnpat();
      }
    }
  }
  if (!$_.slave) {
    var _JO = $a([$a([6, 1]), $a([6, 2]), $a([6, 3]), $a([6, 4]), $a([6, 5]), $a([6, 6]), $a([5, 6]), $a([4, 6]), $a([3, 6]), $a([2, 6]), $a([1, 6]), $a([7, 1]), $a([7, 2]), $a([7, 3]), $a([7, 4]), $a([7, 5]), $a([7, 6]), $a([7, 7]), $a([6, 7]), $a([5, 7]), $a([4, 7]), $a([3, 7]), $a([2, 7]), $a([1, 7]), $a([8, 1]), $a([8, 2]), $a([8, 3]), $a([8, 4]), $a([8, 5]), $a([8, 6]), $a([8, 7]), $a([8, 8]), $a([7, 8]), $a([6, 8]), $a([5, 8]), $a([4, 8]), $a([3, 8]), $a([2, 8]), $a([1, 8]), $a([9, 1]), $a([9, 2]), $a([9, 3]), $a([9, 4]), $a([9, 5])]);
    for (var _JP = 0, _JQ = _JO.length; _JP < _JQ; _JP++) {
      $aload($get(_JO, _JP));
      $_.y = $k[--$j];
      $_.x = $k[--$j];
      $k[$j++] = $a([$_.x, $_.y]);
      $k[$j++] = $a([-$_.x, $_.y]);
      $k[$j++] = $a([-$_.x, -$_.y]);
      $k[$j++] = $a([$_.x, -$_.y]);
    }
    $astore($a(176));
    $_.metadatamap = $k[--$j];
    $_.palettemap1 = $a([$a([4, 1]), $a([4, 2]), $a([5, 1]), $a([5, 2]), $a([2, 4]), $a([2, 5]), $a([1, 4]), $a([1, 5]), $a([-2, 1]), $a([-2, 2]), $a([-1, 1]), $a([-1, 2]), $a([-4, 4]), $a([-4, 5]), $a([-5, 4]), $a([-5, 5])]);
    $_.palettemap2 = $a([$a([-4, -5]), $a([-4, -4]), $a([-5, -5]), $a([-5, -4]), $a([-2, -2]), $a([-2, -1]), $a([-1, -2]), $a([-1, -1]), $a([2, -5]), $a([2, -4]), $a([1, -5]), $a([1, -4]), $a([4, -2]), $a([4, -1]), $a([5, -2]), $a([5, -1])]);
  } else {
    $k[$j++] = Infinity;
    for (var _KG = 1; _KG <= 19; _KG += 1) {
      $_.i = _KG;
      $k[$j++] = $a([0, $_.i]);
      $k[$j++] = $a([1, $_.i]);
    }
    for (var _KL = 5; _KL <= 12; _KL += 1) {
      $_.i = _KL;
      $k[$j++] = $a([2, $_.i]);
      $k[$j++] = $a([3, $_.i]);
    }
    $_.metadatamap = $a();
    $k[$j++] = Infinity;
    for (var _KR = 5; _KR <= 12; _KR += 1) {
      var _KS = Infinity;
      var _KT = _KR;
      $k[$j++] = _KS;
      $k[$j++] = 4;
      $k[$j++] = _KT;
      var _KU = $a();
      $k[$j++] = _KU;
    }
    for (var _KV = 12; _KV >= 5; _KV -= 1) {
      var _KW = Infinity;
      var _KX = _KV;
      $k[$j++] = _KW;
      $k[$j++] = 5;
      $k[$j++] = _KX;
      var _KY = $a();
      $k[$j++] = _KY;
    }
    for (var _KZ = 5; _KZ <= 12; _KZ += 1) {
      var _Ka = Infinity;
      var _Kb = _KZ;
      $k[$j++] = _Ka;
      $k[$j++] = 6;
      $k[$j++] = _Kb;
      var _Kc = $a();
      $k[$j++] = _Kc;
    }
    for (var _Kd = 12; _Kd >= 5; _Kd -= 1) {
      var _Ke = Infinity;
      var _Kf = _Kd;
      $k[$j++] = _Ke;
      $k[$j++] = 7;
      $k[$j++] = _Kf;
      var _Kg = $a();
      $k[$j++] = _Kg;
    }
    $_.palettemap1 = $a();
    $k[$j++] = Infinity;
    var _Ki = $_.palettemap1;
    for (var _Kj = 0, _Kk = _Ki.length; _Kj < _Kk; _Kj++) {
      var _Km = Infinity;
      var _Kn = $get(_Ki, _Kj);
      $k[$j++] = _Km;
      $aload(_Kn);
      var _Ko = $k[--$j];
      var _Kp = $k[--$j];
      $k[$j++] = -_Kp;
      $k[$j++] = -_Ko;
      var _Kq = $a();
      $k[$j++] = _Kq;
    }
    $_.palettemap2 = $a();
  }
  var _Ks = $_.metadatamap;
  for (var _Kt = 0, _Ku = _Ks.length; _Kt < _Ku; _Kt++) {
    var _Kv = $get(_Ks, _Kt);
    var _Kw = $get(_Kv, 0);
    $k[$j++] = _Kv;
    $k[$j++] = _Kw;
    if (_Kw < 0) {
      var _Ky = $k[--$j];
      var _Kz = $k[$j - 1];
      $put(_Kz, 0, $f(_Ky + $_.cols) - 1);
    } else {
      $j--;
    }
    var _L0 = $k[$j - 1];
    var _L1 = $get(_L0, 1);
    $k[$j++] = _L1;
    if (_L1 < 0) {
      var _L3 = $k[--$j];
      var _L4 = $k[$j - 1];
      $put(_L4, 1, $f(_L3 + $_.rows) - 1);
    } else {
      $j--;
    }
    $j--;
  }
  var _L5 = $_.palettemap1;
  for (var _L6 = 0, _L7 = _L5.length; _L6 < _L7; _L6++) {
    var _L8 = $get(_L5, _L6);
    var _L9 = $get(_L8, 0);
    $k[$j++] = _L8;
    $k[$j++] = _L9;
    if (_L9 < 0) {
      var _LB = $k[--$j];
      var _LC = $k[$j - 1];
      $put(_LC, 0, $f(_LB + $_.cols) - 1);
    } else {
      $j--;
    }
    var _LD = $k[$j - 1];
    var _LE = $get(_LD, 1);
    $k[$j++] = _LE;
    if (_LE < 0) {
      var _LG = $k[--$j];
      var _LH = $k[$j - 1];
      $put(_LH, 1, $f(_LG + $_.rows) - 1);
    } else {
      $j--;
    }
    $j--;
  }
  var _LI = $_.palettemap2;
  for (var _LJ = 0, _LK = _LI.length; _LJ < _LK; _LJ++) {
    var _LL = $get(_LI, _LJ);
    var _LM = $get(_LL, 0);
    $k[$j++] = _LL;
    $k[$j++] = _LM;
    if (_LM < 0) {
      var _LO = $k[--$j];
      var _LP = $k[$j - 1];
      $put(_LP, 0, $f(_LO + $_.cols) - 1);
    } else {
      $j--;
    }
    var _LQ = $k[$j - 1];
    var _LR = $get(_LQ, 1);
    $k[$j++] = _LR;
    if (_LR < 0) {
      var _LT = $k[--$j];
      var _LU = $k[$j - 1];
      $put(_LU, 1, $f(_LT + $_.rows) - 1);
    } else {
      $j--;
    }
    $j--;
  }
  for (var _LX = 0, _LW = $_.nummetamodules - 1; _LX <= _LW; _LX += 1) {
    $k[$j++] = $_.pixs;
    $aload($get($_.metadatamap, _LX));
    $_.jmv();
    var _Lb = $k[--$j];
    $put($k[--$j], _Lb, 0);
  }
  if (!$_.slave) {
    var _Le = $_.colors;
    var _Lf = 16;
    if (16 > _Le) {
      var _ = _Le;
      _Le = _Lf;
      _Lf = _;
    }
    for (var _Lh = 0, _Lg = _Lf - 1; _Lh <= _Lg; _Lh += 1) {
      $_.i = _Lh;
      var _Lk = $get($_.palettelayout, $_.i);
      $k[$j++] = _Lk;
      $k[$j++] = $_.pixs;
      $k[$j++] = _Lk;
      $aload($get($_.palettemap1, $_.i));
      $_.jmv();
      var _Lp = $k[--$j];
      var _Lq = $k[--$j];
      $put($k[--$j], _Lp, _Lq);
      var _Lt = $k[--$j];
      $k[$j++] = $_.pixs;
      $k[$j++] = _Lt;
      $aload($get($_.palettemap2, $_.i));
      $_.jmv();
      var _Lx = $k[--$j];
      var _Ly = $k[--$j];
      $put($k[--$j], _Lx, _Ly);
    }
    $_.i = 16;
  } else {
    $_.i = 0;
  }
  $_.j = $_.nummetamodules;
  for (var _M4 = $_.i, _M3 = $_.palettelayout.length - 1; _M4 <= _M3; _M4 += 2) {
    $_.i = _M4;
    var _M7 = $get($_.palettelayout, $_.i);
    $k[$j++] = _M7;
    $k[$j++] = $_.pixs;
    $k[$j++] = _M7;
    $aload($get($_.metadatamap, $_.j));
    $_.jmv();
    var _MC = $k[--$j];
    var _MD = $k[--$j];
    $put($k[--$j], _MC, _MD);
    var _MG = $k[--$j];
    $k[$j++] = $_.pixs;
    $k[$j++] = _MG;
    $aload($get($_.metadatamap, $_.j + 2));
    $_.jmv();
    var _MK = $k[--$j];
    var _ML = $k[--$j];
    $put($k[--$j], _MK, _ML);
    var _MP = $get($_.palettelayout, $_.i + 1);
    $k[$j++] = _MP;
    $k[$j++] = $_.pixs;
    $k[$j++] = _MP;
    $aload($get($_.metadatamap, $_.j + 1));
    $_.jmv();
    var _MU = $k[--$j];
    var _MV = $k[--$j];
    $put($k[--$j], _MU, _MV);
    var _MY = $k[--$j];
    $k[$j++] = $_.pixs;
    $k[$j++] = _MY;
    $aload($get($_.metadatamap, $_.j + 3));
    $_.jmv();
    var _Mc = $k[--$j];
    var _Md = $k[--$j];
    $put($k[--$j], _Mc, _Md);
    $_.j = $_.j + 4;
  }
  var _N5 = $a([function() {
    var _Mg = $k[--$j];
    var _Mh = $k[--$j];
    $k[$j++] = $f(_Mh + _Mg) % $_.colors;
  }, function() {
    $j--;
    var _Mk = $k[--$j];
    $k[$j++] = _Mk % $_.colors;
  }, function() {
    var _Ml = $k[--$j];
    $k[$j - 1] = _Ml;
    var _Mo = $k[--$j];
    $k[$j++] = _Mo % $_.colors;
  }, function() {
    var _Mp = $k[--$j];
    var _Mq = $k[--$j];
    $k[$j++] = (~~(_Mp / 3) + ~~(_Mq / 2)) % $_.colors;
  }, function() {
    var _Ms = $k[--$j];
    var _Mt = $k[--$j];
    $k[$j++] = (~~(_Ms / 2) + ~~(_Mt / 3)) % $_.colors;
  }, function() {
    var _Mv = $k[--$j];
    var _Mx = $f($k[--$j] + _Mv);
    $k[$j++] = (~~(_Mx / 2) + ~~(_Mx / 3)) % $_.colors;
  }, function() {
    var _Mz = $k[--$j];
    var _N0 = $k[--$j];
    $k[$j++] = $f(_Mz * (_N0 * _N0) % 7 + (_Mz + _N0 * _N0) * 2 % 19) % $_.colors;
  }, function() {
    var _N2 = $k[--$j];
    var _N3 = $k[--$j];
    $k[$j++] = $f(_N3 * (_N2 * _N2) % 5 + (_N2 * _N2 + _N3 * 2) % 13) % $_.colors;
  }]);
  $_.maskfuncs = _N5;
  if ($_.mask != -1) {
    $_.maskfuncs = $a([$get($_.maskfuncs, $_.mask)]);
    $_.bestmaskval = $_.mask;
  }
  $_.masks = $a($_.maskfuncs.length);
  for (var _NG = 0, _NF = $_.masks.length - 1; _NG <= _NF; _NG += 1) {
    $_.m = _NG;
    $_.mask = $a($_.rows * $_.cols);
    for (var _NM = 0, _NL = $_.rows - 1; _NM <= _NL; _NM += 1) {
      $_.j = _NM;
      for (var _NP = 0, _NO = $_.cols - 1; _NP <= _NO; _NP += 1) {
        $_.i = _NP;
        $k[$j++] = $_.pixs;
        $k[$j++] = $_.i;
        $k[$j++] = $_.j;
        $_.jmv();
        var _NT = $k[--$j];
        if ($get($k[--$j], _NT) == -1) {
          $k[$j++] = $_.i;
          $k[$j++] = $_.j;
          if ($get($_.maskfuncs, $_.m)() === true) {
            break;
          }
        } else {
          $k[$j++] = 0;
        }
        $k[$j++] = $_.mask;
        $k[$j++] = $_.i;
        $k[$j++] = $_.j;
        $_.jmv();
        var _Ne = $k[$j - 3];
        var _Nf = $k[$j - 1];
        $put($k[$j - 2], _Nf, _Ne);
        $j -= 3;
      }
    }
    $put($_.masks, $_.m, $_.mask);
  }
  $_.posx = 0;
  $_.posy = 0;
  $_.i = 0;
  for (; ; ) {
    if ($_.posx == $_.cols) {
      break;
    }
    $k[$j++] = $_.pixs;
    $k[$j++] = $_.posx;
    $k[$j++] = $_.posy;
    $_.jmv();
    var _Np = $k[--$j];
    if ($get($k[--$j], _Np) == -1) {
      var _Nv = $geti($_.bits, $_.i, $_.databpm);
      $k[$j++] = 0;
      for (var _Nw = 0, _Nx = _Nv.length; _Nw < _Nx; _Nw++) {
        var _Nz = $k[--$j];
        $k[$j++] = $f(_Nz + ($get(_Nv, _Nw) - 48)) * 2;
      }
      var _O0 = $k[--$j];
      $k[$j++] = ~~(_O0 / 2);
      $k[$j++] = $_.pixs;
      $k[$j++] = $_.posx;
      $k[$j++] = $_.posy;
      $_.jmv();
      var _O4 = $k[$j - 3];
      var _O5 = $k[$j - 1];
      $put($k[$j - 2], _O5, _O4);
      $j -= 3;
      $_.i = $_.i + $_.databpm;
    }
    $_.posy = $_.posy + 1;
    if ($_.posy == $_.rows) {
      $_.posy = 0;
      $_.posx = $_.posx + 1;
    }
  }
  $_.evalrle = function() {
    $_.scrle = $k[--$j];
    $_.scr1 = 0;
    $_.scr3 = 0;
    for (var _OG = 0, _OF = $_.scrle.length - 2; _OG <= _OF; _OG += 2) {
      $_.j = _OG;
      if ($get($_.scrle, $_.j + 1) != -1) {
        var _OM = $get($_.scrle, $_.j);
        $k[$j++] = _OM;
        if (_OM >= 5) {
          $_.scr1 = $f($k[--$j] - 2 + $_.scr1);
        } else {
          $j--;
        }
        if ($_.j >= 4 && $_.j <= $_.scrle.length - 5) {
          var _OU = $geti($_.scrle, $_.j - 4, 10);
          $k[$j++] = _OU;
          for (var _OV = 0, _OW = _OU.length; _OV < _OW; _OV++) {
            $k[$j++] = $get(_OU, _OV) == 1;
          }
          $j--;
          for (var _OY = 0; _OY < 4; _OY++) {
            var _OZ = $k[--$j];
            $k[$j - 1] = _OZ;
            var _Ob = $k[--$j];
            var _Oc = $k[--$j];
            $k[$j++] = $an(_Oc, _Ob);
          }
          if ($k[--$j]) {
            $k[$j++] = Infinity;
            var _Oe = $k[--$j];
            var _Of = $k[--$j];
            $k[$j++] = _Oe;
            $aload(_Of);
            var _Og = $k[$j - 1];
            var _Oi = $k[$j - 3];
            var _Ok = $k[$j - 5];
            var _Om = $k[$j - 7];
            var _Oo = $k[$j - 9];
            if ($eq(_Oo, _Ok) && $eq(_Oo, _Og) && $eq(_Om, _Oi)) {
              var _Op = $k[--$j];
              var _Oq = $k[--$j];
              var _Or = $k[--$j];
              $_.c4 = _Or;
              $_.c5 = _Op;
              $k[$j++] = _Or;
              $k[$j++] = _Oq;
              if ($_.c4 == $_.bi && $_.c5 == $_.yi || ($_.c4 == $_.yi && $_.c5 == $_.bi || ($_.c4 == $_.gi && $_.c5 == $_.mi || $_.c4 == $_.mi && $_.c5 == $_.gi))) {
                $_.scr3 = $_.scr3 + 100;
              }
            }
            $cleartomark();
          } else {
            $j--;
          }
        }
      }
    }
    $k[$j++] = $_.scr1;
    $k[$j++] = $_.scr3;
  };
  $_.evalmask = function() {
    $_.sym = $k[--$j];
    $_.n1 = 0;
    $_.n2 = 0;
    $_.n3 = 0;
    var _PC = $_.rows;
    var _PD = $_.cols;
    if (_PC < _PD) {
      var _2 = _PD;
      _PD = _PC;
      _PC = _2;
    }
    $_.rle = $a(_PC * 2 + 2);
    $_.lastpairs = $a($_.cols);
    $_.thispairs = $a($_.cols);
    for (var _PL = 0, _PK = $_.cols - 1; _PL <= _PK; _PL += 1) {
      $_.i = _PL;
      $k[$j++] = Infinity;
      $k[$j++] = 0;
      $k[$j++] = -1;
      for (var _PR = $_.i, _PS = $_.cols, _PQ = $_.rows * $_.cols - 1; _PS < 0 ? _PR >= _PQ : _PR <= _PQ; _PR += _PS) {
        var _PU = $get($_.sym, _PR);
        var _PV = $k[$j - 1];
        $k[$j++] = _PU;
        if ($eq(_PV, _PU)) {
          $j--;
          var _PW = $k[--$j];
          var _PX = $k[--$j];
          $k[$j++] = _PX + 1;
          $k[$j++] = _PW;
        } else {
          var _PY = $k[--$j];
          $k[$j++] = 1;
          $k[$j++] = _PY;
        }
      }
      var _Pa = $counttomark() + 2;
      $astore($geti($_.rle, 0, _Pa - 2));
      $_.evalrle();
      $_.n3 = $f($k[--$j] + $_.n3);
      $_.n1 = $f($k[--$j] + $_.n1);
      $j--;
    }
    for (var _Pi = 0, _Ph = $_.rows - 1; _Pi <= _Ph; _Pi += 1) {
      $_.i = _Pi;
      $_.symrow = $geti($_.sym, $_.i * $_.cols, $_.cols);
      $k[$j++] = Infinity;
      var _Po = $_.symrow;
      $k[$j++] = 0;
      $k[$j++] = -1;
      for (var _Pp = 0, _Pq = _Po.length; _Pp < _Pq; _Pp++) {
        var _Pr = $get(_Po, _Pp);
        var _Ps = $k[$j - 1];
        $k[$j++] = _Pr;
        if ($eq(_Ps, _Pr)) {
          $j--;
          var _Pt = $k[--$j];
          var _Pu = $k[--$j];
          $k[$j++] = _Pu + 1;
          $k[$j++] = _Pt;
        } else {
          var _Pv = $k[--$j];
          $k[$j++] = 1;
          $k[$j++] = _Pv;
        }
      }
      var _Px = $counttomark() + 2;
      $astore($geti($_.rle, 0, _Px - 2));
      $_.evalrle();
      $_.n3 = $f($k[--$j] + $_.n3);
      $_.n1 = $f($k[--$j] + $_.n1);
      $j--;
      var _Q3 = $_.thispairs;
      $_.thispairs = $_.lastpairs;
      $_.lastpairs = _Q3;
      var _Q5 = $_.symrow;
      $k[$j++] = -1;
      for (var _Q6 = 0, _Q7 = _Q5.length; _Q6 < _Q7; _Q6++) {
        var _Q8 = $get(_Q5, _Q6);
        var _Q9 = $k[--$j];
        $k[$j++] = _Q8;
        $k[$j++] = _Q9;
        if ($ne(_Q8, _Q9)) {
          $j--;
          var _QA = $k[--$j];
          $k[$j++] = -1;
          $k[$j++] = _QA;
        }
      }
      $j--;
      $astore($_.thispairs);
      $j--;
      if ($_.i > 0) {
        $k[$j++] = Infinity;
        $aload($_.lastpairs);
        $aload($_.thispairs);
        $k[$j++] = $_.n2;
        for (var _QH = 0, _QI = $_.cols; _QH < _QI; _QH++) {
          var _QJ = $k[--$j];
          var _QK = $k[--$j];
          $k[$j++] = _QJ;
          $k[$j++] = _QK;
          if (_QK != -1) {
            var _QM = $k[$j - 1 - ($_.cols + 1)];
            if ($eq($k[--$j], _QM)) {
              var _QO = $k[--$j];
              $k[$j++] = _QO + 3;
            }
          } else {
            $j--;
          }
        }
        $_.n2 = $k[--$j];
        $cleartomark();
      }
    }
    $k[$j++] = $f($_.n1 + $_.n2 + $_.n3);
  };
  $_.bestscore = 999999999;
  for (var _QV = 0, _QU = $_.masks.length - 1; _QV <= _QU; _QV += 1) {
    $_.m = _QV;
    $_.masksym = $a($_.rows * $_.cols);
    for (var _Qc = 0, _Qb = $_.rows * $_.cols - 1; _Qc <= _Qb; _Qc += 1) {
      $_.i = _Qc;
      $put($_.masksym, $_.i, $xo($get($_.pixs, $_.i), $get($get($_.masks, $_.m), $_.i)));
    }
    if ($_.masks.length != 1) {
      $k[$j++] = $_.masksym;
      $_.evalmask();
      $_.score = $k[--$j];
      if ($_.score < $_.bestscore) {
        $_.bestsym = $_.masksym;
        $_.bestmaskval = $_.m;
        $_.bestscore = $_.score;
      }
    } else {
      $_.bestsym = $_.masksym;
    }
  }
  $_.pixs = $_.bestsym;
  $_.metamask = $_.bestmaskval;
  $_.addtometapart = function() {
    var _Qy = $k[--$j];
    $puti($_.metapart, $_.p, _Qy);
    $_.p = _Qy.length + $_.p;
  };
  $_.addtometabits = function() {
    var _R2 = $k[--$j];
    $puti($_.metabits, $_.q, _R2);
    $_.q = _R2.length + $_.q;
  };
  $_.metapart = $s(40);
  $_.metabits = $s($_.nummetabits);
  $_.p = 0;
  $_.q = 0;
  if (!$_.slave) {
    $k[$j++] = ~~$round($log($_.colors) / $log(2)) - 1;
    $k[$j++] = 3;
    $_.tofixedbits();
    $_.addtometapart();
    $k[$j++] = $geti($_.metapart, 0, $_.p);
    $k[$j++] = 2;
    $k[$j++] = -1;
    $_.ldpc();
    $_.addtometabits();
    $_.p = 0;
    $k[$j++] = $_.metass;
    $k[$j++] = 1;
    $_.tofixedbits();
    $_.addtometapart();
    $k[$j++] = $_.metavf;
    $k[$j++] = 2;
    $_.tofixedbits();
    $_.addtometapart();
    $k[$j++] = $_.metamask;
    $k[$j++] = 3;
    $_.tofixedbits();
    $_.addtometapart();
    if ($_.hasslaves) {
      $k[$j++] = "1";
    } else {
      $k[$j++] = "0";
    }
    $_.addtometapart();
    $k[$j++] = $geti($_.metapart, 0, $_.p);
    $k[$j++] = 2;
    $k[$j++] = -1;
    $_.ldpc();
    $_.addtometabits();
    $_.p = 0;
    if ($_.metass == 0) {
      $k[$j++] = $f(~~(($_.cols - 17) / 4) - $get($a([0, 4, 8, 16]), $_.metavf)) - 1;
      $k[$j++] = $_.metavlen;
      $_.tofixedbits();
      $_.addtometapart();
    } else {
      $k[$j++] = ~~(($_.cols - 17) / 4) - 1;
      $k[$j++] = ~~($_.metavlen / 2);
      $_.tofixedbits();
      $_.addtometapart();
      $k[$j++] = ~~(($_.rows - 17) / 4) - 1;
      $k[$j++] = ~~($_.metavlen / 2);
      $_.tofixedbits();
      $_.addtometapart();
    }
    $k[$j++] = $_.datawc - 3;
    $k[$j++] = ~~($_.metaelen / 2);
    $_.tofixedbits();
    $_.addtometapart();
    $k[$j++] = $_.datawr - 4;
    $k[$j++] = ~~($_.metaelen / 2);
    $_.tofixedbits();
    $_.addtometapart();
    if ($_.hasslaves) {
      $k[$j++] = 0;
      $k[$j++] = 4;
      $_.tofixedbits();
      $_.addtometapart();
    }
    $k[$j++] = $geti($_.metapart, 0, $_.p);
    $k[$j++] = 2;
    $k[$j++] = -1;
    $_.ldpc();
    $_.addtometabits();
    $_.p = 0;
  } else {
    var _Re = $_.sameshape ? 0 : 1;
    $k[$j++] = _Re;
    $k[$j++] = 1;
    $_.tofixedbits();
    $_.addtometapart();
    var _Rg = $_.sameecc ? 0 : 1;
    $k[$j++] = _Rg;
    $k[$j++] = 1;
    $_.tofixedbits();
    $_.addtometapart();
    var _Ri = $_.hasslaves ? 1 : 0;
    $k[$j++] = _Ri;
    $k[$j++] = 1;
    $_.tofixedbits();
    $_.addtometapart();
    $k[$j++] = $geti($_.metapart, 0, $_.p);
    $k[$j++] = 2;
    $k[$j++] = -1;
    $_.ldpc();
    $_.addtometabits();
    $_.p = 0;
    if (!$_.sameshape) {
      $k[$j++] = ~~(($_.diffside - 17) / 4) - 1;
      $k[$j++] = 5;
      $_.tofixedbits();
      $_.addtometapart();
    }
    if ($_.hasslaves) {
      $k[$j++] = 0;
      $k[$j++] = 3;
      $_.tofixedbits();
      $_.addtometapart();
    }
    $k[$j++] = $geti($_.metapart, 0, $_.p);
    $k[$j++] = 2;
    $k[$j++] = -1;
    $_.ldpc();
    $_.addtometabits();
    $_.p = 0;
    if (!$_.sameecc) {
      $k[$j++] = $_.datawc - 3;
      $k[$j++] = ~~($_.metaelen / 2);
      $_.tofixedbits();
      $_.addtometapart();
      $k[$j++] = $_.datawr - 4;
      $k[$j++] = ~~($_.metaelen / 2);
      $_.tofixedbits();
      $_.addtometapart();
    }
    $k[$j++] = $geti($_.metapart, 0, $_.p);
    $k[$j++] = 2;
    $k[$j++] = -1;
    $_.ldpc();
    $_.addtometabits();
    $_.p = 0;
  }
  for (var _S3 = $_.q, _S2 = $_.nummetabits - 1; _S3 <= _S2; _S3 += 1) {
    $put($_.metabits, _S3, 48);
  }
  $_.i = 0;
  $_.j = 0;
  if (!$_.slave) {
    var _S8 = $geti($_.metabits, $_.i, 6);
    for (var _S9 = 0, _SA = _S8.length; _S9 < _SA; _S9++) {
      $k[$j++] = $get(_S8, _S9);
      if ($_.colors == 4) {
        $k[$j++] = $a([$_.bi, $_.yi]);
      } else {
        $k[$j++] = $a([$_.ki, $_.wi]);
      }
      var _SJ = $k[--$j];
      var _SL = $get(_SJ, $k[--$j] - 48);
      $k[$j++] = _SL;
      $k[$j++] = $_.pixs;
      $aload($get($_.metadatamap, $_.j));
      $_.jmv();
      var _SQ = $k[$j - 3];
      var _SR = $k[$j - 1];
      $put($k[$j - 2], _SR, _SQ);
      $j -= 3;
      $_.j = $_.j + 1;
    }
    $_.i = $_.i + 6;
  }
  for (var _SY = 0, _SZ = ~~($f($_.nummetabits - $_.i) / $_.metabpm); _SY < _SZ; _SY++) {
    var _Sd = $geti($_.metabits, $_.i, $_.metabpm);
    $k[$j++] = 0;
    for (var _Se = 0, _Sf = _Sd.length; _Se < _Sf; _Se++) {
      var _Sh = $k[--$j];
      $k[$j++] = $f(_Sh + ($get(_Sd, _Se) - 48)) * 2;
    }
    var _Sk = $get($_.metacolorindex, ~~($k[--$j] / 2));
    $k[$j++] = _Sk;
    $k[$j++] = $_.pixs;
    $aload($get($_.metadatamap, $_.j));
    $_.jmv();
    var _Sp = $k[$j - 3];
    var _Sq = $k[$j - 1];
    $put($k[$j - 2], _Sq, _Sp);
    $j -= 3;
    $_.i = $f($_.i + $_.metabpm);
    $_.j = $_.j + 1;
  }
  var _T2 = /* @__PURE__ */ new Map([
    ["ren", "renmatrix"],
    ["pixs", $_.pixs],
    ["pixx", $_.cols],
    ["pixy", $_.rows],
    ["colormap", $_.palette],
    ["height", $_.rows * 2 / 72],
    ["width", $_.cols * 2 / 72],
    ["borderleft", 0],
    ["borderright", 0],
    ["bordertop", 0],
    ["borderbottom", 0],
    ["opt", $_.options]
  ]);
  $k[$j++] = _T2;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_gs1_cc() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.parse = false;
  $_.dontlint = false;
  $_.lintreqs = false;
  $_.dontdraw = false;
  $_.ccversion = "a";
  $_.cccolumns = -1;
  $_.lintype = "";
  $_.linwidth = -1;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($ne($_.ccversion, "a") && $ne($_.ccversion, "b") && $ne($_.ccversion, "c")) {
    $k[$j++] = "bwipp.gs1ccBadCCversion#28834";
    $k[$j++] = "ccversion must be a, b or c";
    bwipp_raiseerror();
  }
  if ($_.cccolumns > 30) {
    $k[$j++] = "bwipp.gs1ccColumnsTooBig#28838";
    $k[$j++] = "The maximum number of composite component columns is 30";
    bwipp_raiseerror();
  }
  var _6 = /* @__PURE__ */ new Map([
    ["ean13", 4],
    ["upca", 4],
    ["ean8", 3],
    ["upce", 2],
    ["gs1-128", 4],
    ["databaromni", 4],
    ["databarstacked", 2],
    ["databarstackedomni", 2],
    ["databartruncated", 4],
    ["databarlimited", 3],
    ["databarexpanded", 4],
    ["databarexpandedstacked", 4]
  ]);
  $_.lintypecccolumns = _6;
  if ($_.lintype.length != 0) {
    var _B = $get($_.lintypecccolumns, $_.lintype) !== void 0;
    if (!_B) {
      $k[$j++] = "bwipp.gs1ccBadLinType#28860";
      $k[$j++] = "The lintype is not recognised";
      bwipp_raiseerror();
    }
  }
  if ($_.cccolumns == -1) {
    if ($eq($_.lintype, "gs1-128") && $eq($_.ccversion, "c")) {
      if ($_.linwidth < 0) {
        $k[$j++] = "bwipp.gs1ccMissingLinWidth#28868";
        $k[$j++] = "linwidth must be set for a GS1-128 with a CC-C composite component";
        bwipp_raiseerror();
      }
      if ($_.linwidth < 68) {
        $k[$j++] = "bwipp.gs1ccMinimumLinWidth#28871";
        $k[$j++] = "Minimum linwidth for a GS1-128 with a CC-C composite component is 68";
        bwipp_raiseerror();
      }
      if ($_.linwidth == 68) {
        $k[$j++] = 1;
      } else {
        $k[$j++] = ~~(($_.linwidth - 52) / 17);
      }
    } else {
      if ($_.lintype.length != 0) {
        $k[$j++] = $get($_.lintypecccolumns, $_.lintype);
      } else {
        $k[$j++] = 2;
      }
    }
    $_.cccolumns = $k[--$j];
  }
  $k[$j++] = $_.barcode;
  $k[$j++] = "ai";
  bwipp_gs1process();
  $_.fncs = $k[--$j];
  $_.vals = $k[--$j];
  $_.ais = $k[--$j];
  $_.isupper = function() {
    var _S = $k[--$j];
    $k[$j++] = _S >= 65 && _S <= 90;
  };
  $_.isnum0 = function() {
    var _T = $k[--$j];
    $k[$j++] = _T >= 48 && _T <= 57;
  };
  $_.isnum1 = function() {
    var _U = $k[--$j];
    $k[$j++] = _U >= 49 && _U <= 57;
  };
  for (; ; ) {
    if ($_.ais.length >= 1) {
      if ($eq($get($_.ais, 0), "10") || $eq($get($_.ais, 0), "11") || $eq($get($_.ais, 0), "17")) {
        $k[$j++] = -1;
        $k[$j++] = "10";
        break;
      }
    }
    if ($_.ais.length >= 1) {
      if ($eq($get($_.ais, 0), "90")) {
        $_.v = $get($_.vals, 0);
        if ($_.v.length >= 1) {
          $k[$j++] = $get($_.v, 0);
          $_.isupper();
          if ($k[--$j]) {
            $k[$j++] = 0;
            $k[$j++] = "11";
            break;
          }
        }
        if ($_.v.length >= 2) {
          $k[$j++] = $get($_.v, 0);
          $_.isnum1();
          $k[$j++] = $get($_.v, 1);
          $_.isupper();
          var _q = $k[--$j];
          if ($k[--$j] && _q) {
            $k[$j++] = 1;
            $k[$j++] = "11";
            break;
          }
        }
        if ($_.v.length >= 3) {
          $k[$j++] = $get($_.v, 0);
          $_.isnum1();
          $k[$j++] = $get($_.v, 1);
          $_.isnum0();
          var _x = $k[--$j];
          var _y = $k[--$j];
          $k[$j++] = $an(_y, _x);
          $k[$j++] = $get($_.v, 2);
          $_.isupper();
          var _11 = $k[--$j];
          if ($k[--$j] && _11) {
            $k[$j++] = 2;
            $k[$j++] = "11";
            break;
          }
        }
        if ($_.v.length >= 4) {
          $k[$j++] = $get($_.v, 0);
          $_.isnum1();
          $k[$j++] = $get($_.v, 1);
          $_.isnum0();
          var _18 = $k[--$j];
          var _19 = $k[--$j];
          $k[$j++] = $an(_19, _18);
          $k[$j++] = $get($_.v, 2);
          $_.isnum0();
          var _1C = $k[--$j];
          var _1D = $k[--$j];
          $k[$j++] = $an(_1D, _1C);
          $k[$j++] = $get($_.v, 3);
          $_.isupper();
          var _1G = $k[--$j];
          if ($k[--$j] && _1G) {
            $k[$j++] = 3;
            $k[$j++] = "11";
            break;
          }
        }
      }
    }
    $k[$j++] = -1;
    $k[$j++] = "0";
    break;
  }
  $_.method = $k[--$j];
  $_.npre = $k[--$j];
  $_.tobin = function() {
    var _1L = $s($k[--$j]);
    $k[$j++] = _1L;
    for (var _1N = 0, _1M = _1L.length - 1; _1N <= _1M; _1N += 1) {
      var _1O = $k[$j - 1];
      $put(_1O, _1N, 48);
    }
    var _1P = $k[$j - 1];
    $k[$j++] = _1P;
    var _1Q = $k[$j - 3];
    var _1R = $k[$j - 1];
    $k[$j - 3] = $k[$j - 2];
    $j -= 2;
    var _1T = $cvrs($s(_1R.length), _1Q, 2);
    $puti(_1R, _1R.length - _1T.length, _1T);
  };
  $_.fnc1 = -1;
  $_.lnumeric = -2;
  $_.lalphanumeric = -3;
  $_.liso646 = -4;
  $k[$j++] = Infinity;
  for (var _1U = 65; _1U <= 90; _1U += 1) {
    $k[$j++] = _1U;
    $k[$j++] = _1U - 65;
    $k[$j++] = 5;
    $_.tobin();
  }
  for (var _1V = 48; _1V <= 57; _1V += 1) {
    $k[$j++] = _1V;
    $k[$j++] = _1V + 4;
    $k[$j++] = 6;
    $_.tobin();
  }
  $k[$j++] = $_.fnc1;
  $k[$j++] = "11111";
  $_.alpha = $d();
  $k[$j++] = Infinity;
  for (var _1Y = 0; _1Y <= 119; _1Y += 1) {
    var _1a = $strcpy($s(2), "00");
    var _1c = $cvrs($s(2), _1Y, 11);
    $puti(_1a, 2 - _1c.length, _1c);
    $k[$j++] = _1Y;
    $k[$j++] = _1a;
    if ($get(_1a, 0) == 65) {
      var _1e = $k[$j - 1];
      $put(_1e, 0, 94);
    }
    var _1f = $k[$j - 1];
    if ($get(_1f, 1) == 65) {
      var _1h = $k[$j - 1];
      $put(_1h, 1, 94);
    }
    var _1i = $k[--$j];
    var _1l = $strcpy($s(7), "0000000");
    var _1n = $cvrs($s(7), $k[--$j] + 8, 2);
    $puti(_1l, 7 - _1n.length, _1n);
    $k[$j++] = _1i;
    $k[$j++] = _1l;
  }
  $k[$j++] = $_.lalphanumeric;
  $k[$j++] = "0000";
  $_.numeric = $d();
  $k[$j++] = Infinity;
  for (var _1q = 48; _1q <= 57; _1q += 1) {
    $k[$j++] = _1q;
    $k[$j++] = _1q - 43;
    $k[$j++] = 5;
    $_.tobin();
  }
  $k[$j++] = $_.fnc1;
  $k[$j++] = "01111";
  for (var _1s = 65; _1s <= 90; _1s += 1) {
    $k[$j++] = _1s;
    $k[$j++] = _1s - 33;
    $k[$j++] = 6;
    $_.tobin();
  }
  $k[$j++] = 42;
  $k[$j++] = "111010";
  for (var _1t = 44; _1t <= 47; _1t += 1) {
    $k[$j++] = _1t;
    $k[$j++] = _1t + 15;
    $k[$j++] = 6;
    $_.tobin();
  }
  $k[$j++] = $_.lnumeric;
  $k[$j++] = "000";
  $k[$j++] = $_.liso646;
  $k[$j++] = "00100";
  $_.alphanumeric = $d();
  $k[$j++] = Infinity;
  for (var _1x = 48; _1x <= 57; _1x += 1) {
    $k[$j++] = _1x;
    $k[$j++] = _1x - 43;
    $k[$j++] = 5;
    $_.tobin();
  }
  $k[$j++] = $_.fnc1;
  $k[$j++] = "01111";
  for (var _1z = 65; _1z <= 90; _1z += 1) {
    $k[$j++] = _1z;
    $k[$j++] = _1z - 1;
    $k[$j++] = 7;
    $_.tobin();
  }
  for (var _20 = 97; _20 <= 122; _20 += 1) {
    $k[$j++] = _20;
    $k[$j++] = _20 - 7;
    $k[$j++] = 7;
    $_.tobin();
  }
  $k[$j++] = 33;
  $k[$j++] = "11101000";
  $k[$j++] = 34;
  $k[$j++] = "11101001";
  for (var _21 = 37; _21 <= 47; _21 += 1) {
    $k[$j++] = _21;
    $k[$j++] = _21 + 197;
    $k[$j++] = 8;
    $_.tobin();
  }
  for (var _22 = 58; _22 <= 63; _22 += 1) {
    $k[$j++] = _22;
    $k[$j++] = _22 + 187;
    $k[$j++] = 8;
    $_.tobin();
  }
  $k[$j++] = 95;
  $k[$j++] = "11111011";
  $k[$j++] = 32;
  $k[$j++] = "11111100";
  $k[$j++] = $_.lnumeric;
  $k[$j++] = "000";
  $k[$j++] = $_.lalphanumeric;
  $k[$j++] = "00100";
  $_.iso646 = $d();
  if ($eq($_.method, "10")) {
    if ($eq($get($_.ais, 0), "11") || $eq($get($_.ais, 0), "17")) {
      var _2D = $get($_.vals, 0);
      var _2I = $strcpy($s(16), "0000000000000000");
      var _2K = $cvrs($s(16), $cvi($geti(_2D, 0, 2)) * 384 + (($cvi($geti(_2D, 2, 2)) - 1) * 32 + $cvi($geti(_2D, 4, 2))), 2);
      $puti(_2I, 16 - _2K.length, _2K);
      $k[$j++] = _2I;
      $k[$j++] = Infinity;
      $k[$j++] = 1;
      $k[$j++] = 0;
      $r(4, -1);
      $forall($k[--$j], function() {
        var _2M = $k[--$j];
        $k[$j++] = _2M - 48;
      });
      var _2P = $eq($get($_.ais, 0), "11") ? 0 : 1;
      $k[$j++] = _2P;
      $_.cdf = $a();
      $_.ais = $geti($_.ais, 1, $_.ais.length - 1);
      $_.vals = $geti($_.vals, 1, $_.vals.length - 1);
      $_.fncs = $geti($_.fncs, 1, $_.fncs.length - 1);
    } else {
      $_.cdf = $a([1, 0, 1, 1]);
    }
    if ($_.ais.length != 0) {
      if ($eq($get($_.ais, 0), "10")) {
        $k[$j++] = Infinity;
        $forall($get($_.vals, 0));
        $_.gpf = $a();
        if ($_.ais.length > 1) {
          $k[$j++] = Infinity;
          $aload($_.gpf);
          $k[$j++] = $_.fnc1;
          $_.gpf = $a();
        }
        $_.ais = $geti($_.ais, 1, $_.ais.length - 1);
        $_.vals = $geti($_.vals, 1, $_.vals.length - 1);
        $_.fncs = $geti($_.fncs, 1, $_.fncs.length - 1);
      } else {
        $_.gpf = $a([$_.fnc1]);
      }
    } else {
      $k[$j++] = Infinity;
      $aload($_.cdf);
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 1;
      $k[$j++] = 1;
      $k[$j++] = 1;
      $k[$j++] = 1;
      $_.cdf = $a();
      $_.gpf = $a([]);
    }
    $_.mode = "numeric";
  }
  if ($eq($_.method, "11")) {
    $_.cdf = $a([1, 1]);
    $_.ai90 = $get($_.vals, 0);
    if ($_.npre + 1 != $_.ai90.length) {
      $k[$j++] = $geti($_.ai90, $_.npre + 1, $f($_.ai90.length - $_.npre) - 1);
    } else {
      $k[$j++] = "";
    }
    $_.ai90rem = $k[--$j];
    $k[$j++] = "nalpha";
    $k[$j++] = 0;
    $forall($_.ai90rem, function() {
      var _3C = $k[--$j];
      if (_3C >= 65 && _3C <= 90) {
        var _3D = $k[--$j];
        $k[$j++] = _3D + 1;
      }
    });
    var _3E = $k[--$j];
    $_[$k[--$j]] = _3E;
    $k[$j++] = "nnums";
    $k[$j++] = 0;
    $forall($_.ai90rem, function() {
      var _3H = $k[--$j];
      if (_3H >= 48 && _3H <= 57) {
        var _3I = $k[--$j];
        $k[$j++] = _3I + 1;
      }
    });
    var _3J = $k[--$j];
    $_[$k[--$j]] = _3J;
    $k[$j++] = "mode";
    if ($gt($_.nalpha, $_.nnums)) {
      $k[$j++] = "alpha";
    } else {
      if ($_.nalpha == 0) {
        $k[$j++] = "numeric";
      } else {
        $k[$j++] = "alphanumeric";
      }
    }
    var _3O = $k[--$j];
    $_[$k[--$j]] = _3O;
    if ($f($_.nalpha + $_.nnums) != $_.ai90rem.length) {
      $_.mode = "alphanumeric";
    }
    $k[$j++] = Infinity;
    $aload($_.cdf);
    if ($eq($_.mode, "alphanumeric")) {
      $k[$j++] = 0;
    }
    if ($eq($_.mode, "numeric")) {
      $k[$j++] = 1;
      $k[$j++] = 0;
    }
    if ($eq($_.mode, "alpha")) {
      $k[$j++] = 1;
      $k[$j++] = 1;
    }
    $_.cdf = $a();
    $k[$j++] = "ais1";
    if ($_.ais.length > 1) {
      $k[$j++] = $get($_.ais, 1);
    } else {
      $k[$j++] = -1;
    }
    var _3b = $k[--$j];
    $_[$k[--$j]] = _3b;
    $k[$j++] = "vals1";
    if ($_.vals.length > 1) {
      $k[$j++] = $get($_.vals, 1);
    } else {
      $k[$j++] = -1;
    }
    var _3g = $k[--$j];
    $_[$k[--$j]] = _3g;
    if ($eq($_.ais1, "21") || $eq($_.ais1, "8004")) {
      $k[$j++] = Infinity;
      $aload($_.cdf);
      if ($eq($_.ais1, "21")) {
        $k[$j++] = 1;
        $k[$j++] = 0;
      } else {
        $k[$j++] = 1;
        $k[$j++] = 1;
      }
      $_.cdf = $a();
    } else {
      $k[$j++] = Infinity;
      $aload($_.cdf);
      $k[$j++] = 0;
      $_.cdf = $a();
    }
    $k[$j++] = "nval";
    if ($_.npre != 0) {
      $k[$j++] = $cvi($geti($_.ai90, 0, $_.npre));
    } else {
      $k[$j++] = 0;
    }
    var _3t = $k[--$j];
    $_[$k[--$j]] = _3t;
    $search("BDHIJKLNPQRSTVXZ", $geti($_.ai90, $_.npre, 1));
    if ($k[--$j]) {
      var _3z = $k[--$j];
      $k[$j - 1] = _3z.length;
      var _41 = $k[--$j];
      $k[$j - 1] = _41;
      $_.aval = $k[--$j];
    } else {
      $j--;
      $_.aval = -1;
    }
    if ($_.nval < 31 && $_.aval != -1) {
      var _47 = $strcpy($s(5), "00000");
      var _4A = $cvrs($s(5), $_.nval, 2);
      $puti(_47, 5 - _4A.length, _4A);
      var _4B = Infinity;
      var _4C = _47;
      $k[$j++] = _4B;
      $forall(_4C, function() {
        var _4D = $k[--$j];
        $k[$j++] = _4D - 48;
      });
      $_.nbits = $a();
      var _4G = $strcpy($s(4), "0000");
      var _4J = $cvrs($s(4), $_.aval, 2);
      $puti(_4G, 4 - _4J.length, _4J);
      var _4K = Infinity;
      var _4L = _4G;
      $k[$j++] = _4K;
      $forall(_4L, function() {
        var _4M = $k[--$j];
        $k[$j++] = _4M - 48;
      });
      $_.abits = $a();
      $k[$j++] = Infinity;
      $aload($_.cdf);
      $aload($_.nbits);
      $aload($_.abits);
      $_.cdf = $a();
    } else {
      var _4T = $strcpy($s(10), "0000000000");
      var _4W = $cvrs($s(10), $_.nval, 2);
      $puti(_4T, 10 - _4W.length, _4W);
      var _4X = Infinity;
      var _4Y = _4T;
      $k[$j++] = _4X;
      $forall(_4Y, function() {
        var _4Z = $k[--$j];
        $k[$j++] = _4Z - 48;
      });
      $_.nbits = $a();
      var _4c = $strcpy($s(5), "00000");
      var _4h = $cvrs($s(5), $get($_.ai90, $_.npre) - 65, 2);
      $puti(_4c, 5 - _4h.length, _4h);
      var _4i = Infinity;
      var _4j = _4c;
      $k[$j++] = _4i;
      $forall(_4j, function() {
        var _4k = $k[--$j];
        $k[$j++] = _4k - 48;
      });
      $_.abits = $a();
      $k[$j++] = Infinity;
      $aload($_.cdf);
      $k[$j++] = 1;
      $k[$j++] = 1;
      $k[$j++] = 1;
      $k[$j++] = 1;
      $k[$j++] = 1;
      $aload($_.nbits);
      $aload($_.abits);
      $_.cdf = $a();
    }
    if ($ne($_.mode, "alpha")) {
      $k[$j++] = Infinity;
      $forall($_.ai90rem);
      if ($_.ais.length > 1) {
        $k[$j++] = $_.fnc1;
      }
      $_.gpf = $a();
    } else {
      $k[$j++] = Infinity;
      $forall($_.ai90rem);
      if ($_.ais.length > 1) {
        $k[$j++] = $_.fnc1;
      }
      $_.in = $a();
      $_.out = $a($_.in.length * 6);
      $_.j = 0;
      for (var _53 = 0, _52 = $_.in.length - 1; _53 <= _52; _53 += 1) {
        var _57 = $get($_.alpha, $get($_.in, _53));
        $k[$j++] = _57;
        var _58 = Infinity;
        var _59 = _57;
        $k[$j++] = _58;
        $forall(_59, function() {
          var _5A = $k[--$j];
          $k[$j++] = _5A - 48;
        });
        $puti($_.out, $_.j, $a());
        $_.j = $k[--$j].length + $_.j;
      }
      $k[$j++] = Infinity;
      $aload($_.cdf);
      $aload($geti($_.out, 0, $_.j));
      $_.cdf = $a();
      $_.gpf = $a([]);
      if ($_.ais.length > 1) {
        $_.mode = "numeric";
      }
    }
    $_.ais = $geti($_.ais, 1, $_.ais.length - 1);
    $_.vals = $geti($_.vals, 1, $_.vals.length - 1);
    $_.fncs = $geti($_.fncs, 1, $_.fncs.length - 1);
    if ($_.ais.length != 0) {
      if ($eq($_.ais1, "21") || $eq($_.ais1, "8004")) {
        $k[$j++] = Infinity;
        $aload($_.gpf);
        $forall($_.vals1);
        $_.gpf = $a();
        $_.ais = $geti($_.ais, 1, $_.ais.length - 1);
        $_.vals = $geti($_.vals, 1, $_.vals.length - 1);
        $_.fncs = $geti($_.fncs, 1, $_.fncs.length - 1);
        if ($_.ais.length != 0) {
          $k[$j++] = Infinity;
          $aload($_.gpf);
          $k[$j++] = $_.fnc1;
          $_.gpf = $a();
        }
      }
    }
  }
  if ($eq($_.method, "0")) {
    $_.cdf = $a([0]);
    $_.gpf = $a([]);
    $_.mode = "numeric";
  }
  for (var _5u = 0, _5t = $_.ais.length - 1; _5u <= _5t; _5u += 1) {
    $_.i = _5u;
    $_.ai = $get($_.ais, $_.i);
    $_.val = $get($_.vals, $_.i);
    var _64 = $a($_.gpf.length + $_.ai.length + $_.val.length);
    $puti(_64, 0, $_.gpf);
    $k[$j++] = _64;
    $k[$j++] = _64;
    $k[$j++] = $_.gpf.length;
    var _68 = Infinity;
    var _69 = $_.ai;
    $k[$j++] = _68;
    $forall(_69);
    var _6A = $a();
    var _6B = $k[--$j];
    $puti($k[--$j], _6B, _6A);
    var _6D = $k[$j - 1];
    $k[$j++] = _6D;
    $k[$j++] = $_.gpf.length + $_.ai.length;
    var _6H = Infinity;
    var _6I = $_.val;
    $k[$j++] = _6H;
    $forall(_6I);
    var _6J = $a();
    var _6K = $k[--$j];
    $puti($k[--$j], _6K, _6J);
    $_.gpf = $k[--$j];
    if ($_.i != $_.ais.length - 1 && $get($_.fncs, $_.i)) {
      var _6T = $a($_.gpf.length + 1);
      $puti(_6T, 0, $_.gpf);
      $put(_6T, $_.gpf.length, $_.fnc1);
      $_.gpf = _6T;
    }
  }
  var _6f = /* @__PURE__ */ new Map([
    ["a", $a([$a([167, 138, 118, 108, 88, 78, 59]), $a([167, 138, 118, 98, 78]), $a([197, 167, 138, 108, 78])])],
    ["b", $a([$a([336, 296, 256, 208, 160, 104, 56]), $a([768, 648, 536, 416, 304, 208, 152, 112, 72, 32]), $a([1184, 1016, 840, 672, 496, 352, 264, 208, 152, 96, 56])])]
  ]);
  $_.bitcapsmaps = _6f;
  $_.rembits = function() {
    $_.used = $k[--$j];
    if ($ne($_.ccversion, "c")) {
      $_.bitcaps = $get($get($_.bitcapsmaps, $_.ccversion), $_.cccolumns - 2);
      $k[$j++] = -1;
      $forall($_.bitcaps, function() {
        var _6p = $k[$j - 1];
        if ($ge(_6p, $_.used)) {
          var _6r = $k[--$j];
          var _6s = $k[--$j];
          $k[$j++] = _6r;
          $k[$j++] = _6s;
        }
        $j--;
      });
      var _6t = $k[$j - 1];
      if (_6t != -1) {
        var _6v = $k[--$j];
        $k[$j++] = $f(_6v - $_.used);
      }
    } else {
      var _6w = /* @__PURE__ */ new Map([
        ["c", -1]
      ]);
      $get(_6w, $_.ccversion);
      var _70 = ~~$ceil($_.used / 8);
      $_.m = ~~(_70 / 6) * 5 + _70 % 6;
      if ($_.m <= 40) {
        $k[$j++] = 8;
      }
      if ($_.m >= 41 && $_.m <= 160) {
        $k[$j++] = 16;
      }
      if ($_.m >= 161 && $_.m <= 320) {
        $k[$j++] = 32;
      }
      if ($_.m >= 321 && $_.m <= 833) {
        $k[$j++] = 64;
      }
      if ($_.m >= 834) {
        $k[$j++] = 32;
      }
      $_.eccws = $k[--$j];
      $_.m = $f($_.m + $_.eccws) + 3;
      if ($_.cccolumns > 30) {
        $_.cccolumns = 30;
      }
      for (; ; ) {
        if (~~$ceil($_.m / $_.cccolumns) <= 30 || $_.cccolumns >= 30) {
          break;
        }
        $_.cccolumns = $_.cccolumns + 1;
      }
      $_.r = ~~$ceil($_.m / $_.cccolumns);
      if ($_.r < 3) {
        $_.r = 3;
      }
      var _7N = $f($_.cccolumns * $_.r - $_.eccws) - 3;
      $_.tgt = $f(~~(_7N / 5) * 6 + _7N % 5) * 8;
      if ($_.used <= 8304) {
        $k[$j++] = $f($_.tgt - $_.used);
      } else {
        $k[$j++] = -1;
      }
    }
    var _7R = $k[$j - 1];
    if (_7R == -1) {
      $j--;
      if ($eq($_.ccversion, "a")) {
        $_.ccversion = "b";
      } else {
        if ($eq($_.ccversion, "b") && $eq($_.lintype, "gs1-128")) {
          $_.ccversion = "c";
          $_.cccolumns = ~~(($_.linwidth - 52) / 17);
        } else {
          $_.ccversion = -1;
        }
      }
      $k[$j++] = $_.used;
      $_.rembits();
    }
  };
  $_.encode = function() {
    var _7X = $k[$j - 1];
    if ($ne(_7X, "raw")) {
      var _7Y = $k[--$j];
      var _7a = $get(_7Y, $k[--$j]);
      $k[$j++] = _7a;
    } else {
      $j--;
    }
    $k[$j++] = Infinity;
    var _7b = $k[--$j];
    var _7c = $k[--$j];
    $k[$j++] = _7b;
    $forall(_7c, function() {
      var _7d = $k[--$j];
      $k[$j++] = _7d - 48;
    });
    var _7e = $a();
    $puti($_.gpfenc, $_.j, _7e);
    $_.j = _7e.length + $_.j;
  };
  $k[$j++] = Infinity;
  for (var _7j = 0, _7k = $_.gpf.length; _7j < _7k; _7j++) {
    $k[$j++] = 0;
  }
  $k[$j++] = 0;
  $k[$j++] = -1;
  $_.numericruns = $a();
  $k[$j++] = Infinity;
  for (var _7n = 0, _7o = $_.gpf.length; _7n < _7o; _7n++) {
    $k[$j++] = 0;
  }
  $k[$j++] = 0;
  $_.alphanumericruns = $a();
  $k[$j++] = Infinity;
  for (var _7r = 0, _7s = $_.gpf.length; _7r < _7s; _7r++) {
    $k[$j++] = 0;
  }
  $k[$j++] = 9999;
  $_.nextiso646only = $a();
  for (var _7v = $_.gpf.length - 1; _7v >= 0; _7v -= 1) {
    $_.i = _7v;
    var _80 = $strcpy($s(2), "00");
    var _83 = $get($_.gpf, $_.i);
    $k[$j++] = $get($_.gpf, $_.i);
    $k[$j++] = _80;
    $k[$j++] = _80;
    $k[$j++] = 0;
    $k[$j++] = _83;
    if (_83 == $_.fnc1) {
      $k[$j - 1] = 94;
    }
    var _85 = $k[--$j];
    var _86 = $k[--$j];
    $put($k[--$j], _86, _85);
    if ($_.i < $_.gpf.length - 1) {
      var _8A = $k[$j - 1];
      var _8D = $get($_.gpf, $_.i + 1);
      $k[$j++] = _8A;
      $k[$j++] = 1;
      $k[$j++] = _8D;
      if (_8D == $_.fnc1) {
        $k[$j - 1] = 94;
      }
      var _8F = $k[--$j];
      var _8G = $k[--$j];
      $put($k[--$j], _8G, _8F);
    }
    var _8K = $get($_.numeric, $k[--$j]) !== void 0;
    if (_8K) {
      $put($_.numericruns, $_.i, $get($_.numericruns, $_.i + 2) + 2);
    } else {
      $put($_.numericruns, $_.i, 0);
    }
    var _8S = $k[$j - 1];
    var _8U = $get($_.alphanumeric, _8S) !== void 0;
    if (_8U) {
      $put($_.alphanumericruns, $_.i, $get($_.alphanumericruns, $_.i + 1) + 1);
    } else {
      $put($_.alphanumericruns, $_.i, 0);
    }
    var _8c = $k[--$j];
    var _8e = $get($_.iso646, _8c) !== void 0;
    var _8g = $get($_.alphanumeric, _8c) !== void 0;
    if (_8e && !_8g) {
      $put($_.nextiso646only, $_.i, 0);
    } else {
      $put($_.nextiso646only, $_.i, $get($_.nextiso646only, $_.i + 1) + 1);
    }
  }
  $_.gpfenc = $a(8304);
  $_.i = 0;
  $_.j = 0;
  for (; ; ) {
    if ($_.i == $_.gpf.length) {
      break;
    }
    for (; ; ) {
      if ($eq($_.mode, "numeric")) {
        if ($_.i <= $_.gpf.length - 2) {
          var _8u = $s(2);
          var _8x = $get($_.gpf, $_.i);
          $k[$j++] = _8u;
          $k[$j++] = _8u;
          $k[$j++] = 0;
          $k[$j++] = _8x;
          if (_8x == $_.fnc1) {
            $k[$j - 1] = 94;
          }
          var _8z = $k[--$j];
          var _90 = $k[--$j];
          $put($k[--$j], _90, _8z);
          var _92 = $k[$j - 1];
          var _95 = $get($_.gpf, $_.i + 1);
          $k[$j++] = _92;
          $k[$j++] = 1;
          $k[$j++] = _95;
          if (_95 == $_.fnc1) {
            $k[$j - 1] = 94;
          }
          var _97 = $k[--$j];
          var _98 = $k[--$j];
          $put($k[--$j], _98, _97);
          var _9A = $k[$j - 1];
          var _9C = $get($_.numeric, _9A) !== void 0;
          if (_9C) {
            $k[$j++] = $_.numeric;
            $_.encode();
            $_.i = $_.i + 2;
            break;
          }
          $k[$j - 1] = $_.lalphanumeric;
          $k[$j++] = $_.numeric;
          $_.encode();
          $_.mode = "alphanumeric";
          break;
        } else {
          var _9J = $get($_.gpf, $_.i);
          if (_9J < 48 || _9J > 57) {
            $k[$j++] = $_.lalphanumeric;
            $k[$j++] = $_.numeric;
            $_.encode();
            $_.mode = "alphanumeric";
            break;
          }
          $k[$j++] = "rem";
          $k[$j++] = $_.cdf.length + $_.j;
          $_.rembits();
          var _9O = $k[--$j];
          $_[$k[--$j]] = _9O;
          if ($_.rem >= 4 && $_.rem <= 6) {
            var _9V = $geti($strcpy($s(6), "000000"), 0, $_.rem);
            var _9a = $cvrs($s(4), $get($_.gpf, $_.i) - 47, 2);
            $puti(_9V, 4 - _9a.length, _9a);
            $k[$j++] = _9V;
            $k[$j++] = "raw";
            $_.encode();
            $_.i = $_.i + 1;
            break;
          } else {
            var _9c = $s(2);
            $put(_9c, 0, $get($_.gpf, $_.i));
            $put(_9c, 1, 94);
            $k[$j++] = _9c;
            $k[$j++] = $_.numeric;
            $_.encode();
            $_.i = $_.i + 1;
            break;
          }
        }
      }
      if ($eq($_.mode, "alphanumeric")) {
        if ($get($_.gpf, $_.i) == $_.fnc1) {
          $k[$j++] = $_.fnc1;
          $k[$j++] = $_.alphanumeric;
          $_.encode();
          $_.mode = "numeric";
          $_.i = $_.i + 1;
          break;
        }
        var _9s = $get($_.gpf, $_.i);
        var _9u = $get($_.iso646, _9s) !== void 0;
        var _9w = $get($_.alphanumeric, _9s) !== void 0;
        if (_9u && !_9w) {
          $k[$j++] = $_.liso646;
          $k[$j++] = $_.alphanumeric;
          $_.encode();
          $_.mode = "iso646";
          break;
        }
        if ($get($_.numericruns, $_.i) >= 6) {
          $k[$j++] = $_.lnumeric;
          $k[$j++] = $_.alphanumeric;
          $_.encode();
          $_.mode = "numeric";
          break;
        }
        var _A6 = $get($_.numericruns, $_.i);
        if (_A6 >= 4 && $f(_A6 + $_.i) == $_.gpf.length) {
          $k[$j++] = $_.lnumeric;
          $k[$j++] = $_.alphanumeric;
          $_.encode();
          $_.mode = "numeric";
          break;
        }
        $k[$j++] = $get($_.gpf, $_.i);
        $k[$j++] = $_.alphanumeric;
        $_.encode();
        $_.i = $_.i + 1;
        break;
      }
      if ($eq($_.mode, "iso646")) {
        if ($get($_.gpf, $_.i) == $_.fnc1) {
          $k[$j++] = $_.fnc1;
          $k[$j++] = $_.iso646;
          $_.encode();
          $_.mode = "numeric";
          $_.i = $_.i + 1;
          break;
        }
        if ($get($_.numericruns, $_.i) >= 4 && $get($_.nextiso646only, $_.i) >= 10) {
          $k[$j++] = $_.lnumeric;
          $k[$j++] = $_.iso646;
          $_.encode();
          $_.mode = "numeric";
          break;
        }
        if ($get($_.alphanumericruns, $_.i) >= 5 && $get($_.nextiso646only, $_.i) >= 10) {
          $k[$j++] = $_.lalphanumeric;
          $k[$j++] = $_.iso646;
          $_.encode();
          $_.mode = "alphanumeric";
          break;
        }
        $k[$j++] = $get($_.gpf, $_.i);
        $k[$j++] = $_.iso646;
        $_.encode();
        $_.i = $_.i + 1;
        break;
      }
    }
  }
  $_.gpf = $geti($_.gpfenc, 0, $_.j);
  $k[$j++] = "pad";
  $k[$j++] = $_.cdf.length + $_.gpf.length;
  $_.rembits();
  var _Ap = $a($k[--$j]);
  $_[$k[--$j]] = _Ap;
  if ($_.pad.length > 0) {
    for (var _Au = 0, _At = $_.pad.length - 1; _Au <= _At; _Au += 5) {
      $_.i = _Au;
      var _Av = $_.pad;
      var _Aw = $_.i;
      var _Ax = $a([0, 0, 1, 0, 0]);
      var _Ay = $_.pad;
      var _Az = $_.i;
      var _B0 = 5;
      var _B1 = _Ay.length - _Az;
      if (_Ay.length - _Az > 5) {
        var _ = _B0;
        _B0 = _B1;
        _B1 = _;
      }
      $puti(_Av, _Aw, $geti(_Ax, 0, _B1));
    }
    if ($eq($_.mode, "numeric")) {
      $k[$j++] = Infinity;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $aload($_.pad);
      $_.pad = $geti($a(), 0, $_.pad.length);
    }
    if ($eq($_.mode, "alpha")) {
      $k[$j++] = Infinity;
      $k[$j++] = 1;
      $k[$j++] = 1;
      $k[$j++] = 1;
      $k[$j++] = 1;
      $k[$j++] = 1;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $aload($_.pad);
      $_.pad = $geti($a(), 0, $_.pad.length);
    }
  }
  $k[$j++] = Infinity;
  $aload($_.cdf);
  $aload($_.gpf);
  $aload($_.pad);
  $_.bits = $a();
  $k[$j++] = Infinity;
  $k[$j++] = $a([0, 0, 0, 0, 0, 0, 1]);
  for (var _BI = 0; _BI < 68; _BI++) {
    $k[$j++] = $a(7);
  }
  $_.pwr928 = $a();
  for (var _BL = 1; _BL <= 68; _BL += 1) {
    $_.j = _BL;
    $_.v = 0;
    for (var _BM = 6; _BM >= 1; _BM -= 1) {
      $_.i = _BM;
      $_.v = $f($get($get($_.pwr928, $_.j - 1), $_.i) * 2 + ~~($_.v / 928));
      $put($get($_.pwr928, $_.j), $_.i, $_.v % 928);
    }
    $put($get($_.pwr928, $_.j), 0, $f($get($get($_.pwr928, $_.j - 1), 0) * 2 + ~~($_.v / 928)));
  }
  if ($_.ccversion == "a") {
    $k[$j++] = Infinity;
    for (var _Bi = 0; _Bi < 28; _Bi++) {
      $k[$j++] = 0;
    }
    $_.cws = $a();
    $_.b = 0;
    $_.c = 0;
    for (; ; ) {
      if ($_.b == $_.bits.length) {
        break;
      }
      var _Bm = $_.bits;
      var _Bn = $_.b;
      var _Bo = $_.bits;
      var _Bp = $_.b;
      var _Bq = _Bo.length - _Bp;
      var _Br = 69;
      if (69 > _Bo.length - _Bp) {
        var _ = _Bq;
        _Bq = _Br;
        _Br = _;
      }
      $_.bs = $geti(_Bm, _Bn, _Br);
      $_.bsl = $_.bs.length;
      $_.cs = $geti($_.cws, $_.c, ~~($_.bsl / 10) + 1);
      $_.csl = $_.cs.length;
      for (var _C1 = 0, _C0 = $_.bsl - 1; _C1 <= _C0; _C1 += 1) {
        $_.i = _C1;
        for (var _C4 = 0, _C3 = $_.csl - 1; _C4 <= _C3; _C4 += 1) {
          $_.j = _C4;
          var _C5 = $_.cs;
          var _C6 = $_.j;
          $put(_C5, _C6, $f($get(_C5, _C6) + $get($get($_.pwr928, $_.i), $_.j + 7 - $_.csl) * $get($_.bs, $_.bsl - $_.i - 1)));
        }
      }
      for (var _CJ = $_.csl - 1; _CJ >= 1; _CJ -= 1) {
        $_.i = _CJ;
        var _CK = $_.cs;
        var _CL = $_.i;
        $put(_CK, _CL - 1, $f($get(_CK, _CL - 1) + ~~($get($_.cs, $_.i) / 928)));
        var _CQ = $_.cs;
        var _CR = $_.i;
        $put(_CQ, _CR, $get(_CQ, _CR) % 928);
      }
      $_.b = $_.b + $_.bsl;
      $_.c = $_.c + $_.csl;
    }
    $_.cws = $geti($_.cws, 0, $_.c);
    $_.barcode = $s($_.cws.length * 4);
    for (var _Ce = 0, _Cd = $_.cws.length - 1; _Ce <= _Cd; _Ce += 1) {
      $_.i = _Ce;
      var _Cg = $strcpy($s(4), "^000");
      var _Cl = $cvrs($s(4), $get($_.cws, $_.i), 10);
      $puti(_Cg, 4 - _Cl.length, _Cl);
      $puti($_.barcode, $_.i * 4, _Cg);
    }
    delete $_.options["parse"];
    $put($_.options, "dontdraw", true);
    $put($_.options, "cca", true);
    $put($_.options, "columns", $_.cccolumns);
    $k[$j++] = "args";
    $k[$j++] = $_.barcode;
    $k[$j++] = $_.options;
    bwipp_micropdf417();
    var _Cv = $k[--$j];
    $_[$k[--$j]] = _Cv;
  }
  if ($_.ccversion == "b") {
    $_.barcode = $s(~~($_.bits.length / 8));
    for (var _D2 = 0, _D1 = $_.barcode.length - 1; _D2 <= _D1; _D2 += 1) {
      $_.i = _D2;
      var _D5 = $geti($_.bits, $_.i * 8, 8);
      $k[$j++] = 0;
      for (var _D6 = 0, _D7 = _D5.length; _D6 < _D7; _D6++) {
        var _D9 = $k[--$j];
        $k[$j++] = $f(_D9 + $get(_D5, _D6)) * 2;
      }
      $put($_.barcode, $_.i, ~~($k[--$j] / 2));
    }
    delete $_.options["parse"];
    $put($_.options, "dontdraw", true);
    $put($_.options, "ccb", true);
    $put($_.options, "columns", $_.cccolumns);
    $k[$j++] = "args";
    $k[$j++] = $_.barcode;
    $k[$j++] = $_.options;
    bwipp_micropdf417();
    var _DK = $k[--$j];
    $_[$k[--$j]] = _DK;
  }
  if ($_.ccversion == "c") {
    $_.barcode = $s(~~($_.bits.length / 8));
    for (var _DR = 0, _DQ = $_.barcode.length - 1; _DR <= _DQ; _DR += 1) {
      $_.i = _DR;
      var _DU = $geti($_.bits, $_.i * 8, 8);
      $k[$j++] = 0;
      for (var _DV = 0, _DW = _DU.length; _DV < _DW; _DV++) {
        var _DY = $k[--$j];
        $k[$j++] = $f(_DY + $get(_DU, _DV)) * 2;
      }
      $put($_.barcode, $_.i, ~~($k[--$j] / 2));
    }
    delete $_.options["parse"];
    $put($_.options, "dontdraw", true);
    $put($_.options, "ccc", true);
    $put($_.options, "columns", $_.cccolumns);
    $put($_.options, "eclevel", ~~($log($_.eccws) / $log(2)) - 1);
    $k[$j++] = "args";
    $k[$j++] = $_.barcode;
    $k[$j++] = $_.options;
    bwipp_pdf417();
    var _Dl = $k[--$j];
    $_[$k[--$j]] = _Dl;
  }
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_ean13composite() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.usematrix = false;
  $_.parse = false;
  $_.dontlint = false;
  $_.lintreqs = true;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.dontdraw) {
    $_.usematrix = true;
  }
  $search($_.barcode, "|");
  if ($k[--$j]) {
    $_.linear = $k[--$j];
    $j--;
    $_.comp = $k[--$j];
  } else {
    $j--;
    $k[$j++] = "bwipp.missingCompositeComponent#29501";
    $k[$j++] = "A Composite Component must be provided following a pipe character";
    bwipp_raiseerror();
  }
  $put($_.options, "lintype", "ean13");
  $put($_.options, "inkspreadv", 0);
  $put($_.options, "dontdraw", true);
  $put($_.options, "dontlint", true);
  var _C = $s($_.comp.length + 18);
  $puti(_C, 0, "(01)00000000000000");
  $puti(_C, 18, $_.comp);
  $k[$j++] = _C;
  $k[$j++] = "ai";
  bwipp_gs1process();
  $j -= 3;
  $k[$j++] = $_.linear;
  $k[$j++] = $_.options;
  bwipp_ean13();
  if (!$_.usematrix) {
    $$.save();
    bwipp_renlinear();
    var _H = $$.currpos();
    $$.rmoveto(-3, 78);
    $k[$j++] = _H.x;
    $k[$j++] = _H.y;
    $k[$j++] = $_.comp;
    $k[$j++] = $_.options;
    bwipp_gs1_cc();
    bwipp_renmatrix();
    var _K = $k[--$j];
    $$.moveto($k[--$j] - 1, _K + 72);
    $k[$j++] = Infinity;
    $k[$j++] = Infinity;
    $k[$j++] = 0;
    $k[$j++] = 1;
    for (var _M = 0; _M < 93; _M++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 1;
    $k[$j++] = 0;
    $k[$j++] = 1;
    $k[$j++] = 0;
    for (var _N = 0; _N < 93; _N++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $k[$j++] = 1;
    $k[$j++] = 0;
    $k[$j++] = 1;
    for (var _O = 0; _O < 93; _O++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 1;
    $k[$j++] = 0;
    var _P = $a();
    $k[$j++] = "ren";
    $k[$j++] = "renmatrix";
    $k[$j++] = "pixs";
    $k[$j++] = _P;
    $k[$j++] = "pixx";
    $k[$j++] = 97;
    $k[$j++] = "pixy";
    $k[$j++] = 3;
    $k[$j++] = "height";
    $k[$j++] = 6 / 72;
    $k[$j++] = "width";
    $k[$j++] = 97 / 72;
    $k[$j++] = "opt";
    $k[$j++] = $_.options;
    var _R = $d();
    $k[$j++] = _R;
    bwipp_renmatrix();
    $$.restore();
  } else {
    $_.linsym = $k[--$j];
    $_.sbs = $get($_.linsym, "sbs");
    $_.bhs = $get($_.linsym, "bhs");
    $_.bbs = $get($_.linsym, "bbs");
    $k[$j++] = "linwidth";
    $k[$j++] = 0;
    $forall($_.sbs, function() {
      var _a = $k[--$j];
      var _b = $k[--$j];
      $k[$j++] = $f(_b + $cvi(_a));
    });
    var _c = $k[--$j];
    $_[$k[--$j]] = _c;
    $k[$j++] = "compsym";
    $k[$j++] = $_.comp;
    $k[$j++] = $_.options;
    bwipp_gs1_cc();
    var _g = $k[--$j];
    $_[$k[--$j]] = _g;
    $_.ccpixs = $get($_.compsym, "pixs");
    $_.ccpixx = $get($_.compsym, "pixx");
    $k[$j++] = Infinity;
    for (var _n = 0, _o = $_.ccpixx - 97; _n < _o; _n++) {
      $k[$j++] = 0;
    }
    $_.linpad = $a();
    $_.diff = $f($_.linwidth + $_.linpad.length + 1 - $_.ccpixx);
    if ($_.diff > 0) {
      $k[$j++] = Infinity;
      for (var _v = 0, _w = $_.diff; _v < _w; _v++) {
        $k[$j++] = 0;
      }
      $_.ccrpad = $a();
      $_.pixx = $f($_.ccpixx + $_.diff);
    } else {
      $_.ccrpad = $a(0);
      $_.pixx = $_.ccpixx;
    }
    $k[$j++] = Infinity;
    for (var _15 = 0, _16 = $_.ccpixx, _14 = $_.ccpixs.length - 1; _16 < 0 ? _15 >= _14 : _15 <= _14; _15 += _16) {
      $_.i = _15;
      $aload($geti($_.ccpixs, $_.i, $_.ccpixx));
      $aload($_.ccrpad);
    }
    for (var _1C = 0; _1C < 2; _1C++) {
      $aload($_.linpad);
      $k[$j++] = 0;
      $k[$j++] = 1;
      for (var _1E = 0; _1E < 93; _1E++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 1;
      $k[$j++] = 0;
      $aload($_.ccrpad);
    }
    for (var _1G = 0; _1G < 2; _1G++) {
      $aload($_.linpad);
      $k[$j++] = 1;
      $k[$j++] = 0;
      for (var _1I = 0; _1I < 93; _1I++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 0;
      $k[$j++] = 1;
      $aload($_.ccrpad);
    }
    for (var _1K = 0; _1K < 2; _1K++) {
      $aload($_.linpad);
      $k[$j++] = 0;
      $k[$j++] = 1;
      for (var _1M = 0; _1M < 93; _1M++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 1;
      $k[$j++] = 0;
      $aload($_.ccrpad);
    }
    for (var _1O = 71; _1O >= 0; _1O -= 1) {
      $_.y = _1O;
      $aload($_.linpad);
      $k[$j++] = 0;
      for (var _1S = 0, _1R = $_.sbs.length - 1; _1S <= _1R; _1S += 1) {
        $_.i = _1S;
        if ($_.i % 2 == 0) {
          var _1X = $get($_.bbs, ~~($_.i / 2)) * 72;
          if (_1X > $_.y || $f(_1X + $get($_.bhs, ~~($_.i / 2)) * 72) < $_.y) {
            for (var _1g = 0, _1h = $cvi($get($_.sbs, $_.i)); _1g < _1h; _1g++) {
              $k[$j++] = 0;
            }
          } else {
            for (var _1l = 0, _1m = $cvi($get($_.sbs, $_.i)); _1l < _1m; _1l++) {
              $k[$j++] = 1;
            }
          }
        } else {
          for (var _1q = 0, _1r = $cvi($get($_.sbs, $_.i)); _1q < _1r; _1q++) {
            $k[$j++] = 0;
          }
        }
      }
      if ($_.diff < 0) {
        $k[$j++] = 0;
      }
    }
    $_.pixs = $a();
    $_.pixy = ~~($_.pixs.length / $_.pixx);
    var _22 = /* @__PURE__ */ new Map([
      ["ren", "renmatrix"],
      ["pixs", $_.pixs],
      ["pixx", $_.pixx],
      ["pixy", $_.pixy],
      ["height", $_.pixy / 72],
      ["width", $_.pixx / 72],
      ["opt", $_.options]
    ]);
    $k[$j++] = _22;
    if (!$_.dontdraw) {
      $$.save();
      bwipp_renmatrix();
      $$.restore();
    }
  }
  $_ = $__;
}
function bwipp_ean8composite() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.usematrix = false;
  $_.parse = false;
  $_.dontlint = false;
  $_.lintreqs = true;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.dontdraw) {
    $_.usematrix = true;
  }
  $search($_.barcode, "|");
  if ($k[--$j]) {
    $_.linear = $k[--$j];
    $j--;
    $_.comp = $k[--$j];
  } else {
    $j--;
    $k[$j++] = "bwipp.missingCompositeComponent#29664";
    $k[$j++] = "A Composite Component must be provided following a pipe character";
    bwipp_raiseerror();
  }
  $put($_.options, "lintype", "ean8");
  $put($_.options, "inkspreadv", 0);
  $put($_.options, "dontdraw", true);
  $put($_.options, "dontlint", true);
  var _C = $s($_.comp.length + 18);
  $puti(_C, 0, "(01)00000000000000");
  $puti(_C, 18, $_.comp);
  $k[$j++] = _C;
  $k[$j++] = "ai";
  bwipp_gs1process();
  $j -= 3;
  $k[$j++] = $_.linear;
  $k[$j++] = $_.options;
  bwipp_ean8();
  if (!$_.usematrix) {
    $$.save();
    bwipp_renlinear();
    var _H = $$.currpos();
    $k[$j++] = _H.x;
    $k[$j++] = _H.y;
    $k[$j++] = $_.comp;
    $k[$j++] = $_.options;
    bwipp_gs1_cc();
    var _K = $k[--$j];
    $$.rmoveto(70 - $get(_K, "pixx"), 78);
    $k[$j++] = _K;
    bwipp_renmatrix();
    var _M = $k[--$j];
    $$.moveto($k[--$j] - 1, _M + 72);
    $k[$j++] = Infinity;
    $k[$j++] = Infinity;
    $k[$j++] = 0;
    $k[$j++] = 1;
    for (var _O = 0; _O < 65; _O++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 1;
    $k[$j++] = 0;
    $k[$j++] = 1;
    $k[$j++] = 0;
    for (var _P = 0; _P < 65; _P++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $k[$j++] = 1;
    $k[$j++] = 0;
    $k[$j++] = 1;
    for (var _Q = 0; _Q < 65; _Q++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 1;
    $k[$j++] = 0;
    var _R = $a();
    $k[$j++] = "ren";
    $k[$j++] = "renmatrix";
    $k[$j++] = "pixs";
    $k[$j++] = _R;
    $k[$j++] = "pixx";
    $k[$j++] = 69;
    $k[$j++] = "pixy";
    $k[$j++] = 3;
    $k[$j++] = "height";
    $k[$j++] = 6 / 72;
    $k[$j++] = "width";
    $k[$j++] = 69 / 72;
    $k[$j++] = "opt";
    $k[$j++] = $_.options;
    var _T = $d();
    $k[$j++] = _T;
    bwipp_renmatrix();
    $$.restore();
  } else {
    $_.linsym = $k[--$j];
    $_.sbs = $get($_.linsym, "sbs");
    $_.bhs = $get($_.linsym, "bhs");
    $_.bbs = $get($_.linsym, "bbs");
    $k[$j++] = "linwidth";
    $k[$j++] = 0;
    $forall($_.sbs, function() {
      var _c = $k[--$j];
      var _d = $k[--$j];
      $k[$j++] = $f(_d + $cvi(_c));
    });
    var _e = $k[--$j];
    $_[$k[--$j]] = _e;
    var _g = $_.comp;
    $k[$j++] = "compsym";
    $k[$j++] = _g;
    $k[$j++] = $_.options;
    bwipp_gs1_cc();
    var _i = $k[--$j];
    $_[$k[--$j]] = _i;
    $_.ccpixs = $get($_.compsym, "pixs");
    $_.ccpixx = $get($_.compsym, "pixx");
    $k[$j++] = Infinity;
    for (var _p = 0, _q = $_.ccpixx - 69; _p < _q; _p++) {
      $k[$j++] = 0;
    }
    $_.linpad = $a();
    $_.diff = $f($_.linwidth + $_.linpad.length + 1 - $_.ccpixx);
    if ($_.diff > 0) {
      $k[$j++] = Infinity;
      for (var _x = 0, _y = $_.diff; _x < _y; _x++) {
        $k[$j++] = 0;
      }
      $_.ccrpad = $a();
      $_.pixx = $f($_.ccpixx + $_.diff);
    } else {
      $_.ccrpad = $a(0);
      $_.pixx = $_.ccpixx;
    }
    $k[$j++] = Infinity;
    for (var _17 = 0, _18 = $_.ccpixx, _16 = $_.ccpixs.length - 1; _18 < 0 ? _17 >= _16 : _17 <= _16; _17 += _18) {
      $_.i = _17;
      $aload($geti($_.ccpixs, $_.i, $_.ccpixx));
      $aload($_.ccrpad);
    }
    for (var _1E = 0; _1E < 2; _1E++) {
      $aload($_.linpad);
      $k[$j++] = 0;
      $k[$j++] = 1;
      for (var _1G = 0; _1G < 65; _1G++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 1;
      $k[$j++] = 0;
      $aload($_.ccrpad);
    }
    for (var _1I = 0; _1I < 2; _1I++) {
      $aload($_.linpad);
      $k[$j++] = 1;
      $k[$j++] = 0;
      for (var _1K = 0; _1K < 65; _1K++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 0;
      $k[$j++] = 1;
      $aload($_.ccrpad);
    }
    for (var _1M = 0; _1M < 2; _1M++) {
      $aload($_.linpad);
      $k[$j++] = 0;
      $k[$j++] = 1;
      for (var _1O = 0; _1O < 65; _1O++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 1;
      $k[$j++] = 0;
      $aload($_.ccrpad);
    }
    for (var _1Q = 71; _1Q >= 0; _1Q -= 1) {
      $_.y = _1Q;
      $aload($_.linpad);
      $k[$j++] = 0;
      for (var _1U = 0, _1T = $_.sbs.length - 1; _1U <= _1T; _1U += 1) {
        $_.i = _1U;
        if ($_.i % 2 == 0) {
          var _1Z = $get($_.bbs, ~~($_.i / 2)) * 72;
          if (_1Z > $_.y || $f(_1Z + $get($_.bhs, ~~($_.i / 2)) * 72) < $_.y) {
            for (var _1i = 0, _1j = $cvi($get($_.sbs, $_.i)); _1i < _1j; _1i++) {
              $k[$j++] = 0;
            }
          } else {
            for (var _1n = 0, _1o = $cvi($get($_.sbs, $_.i)); _1n < _1o; _1n++) {
              $k[$j++] = 1;
            }
          }
        } else {
          for (var _1s = 0, _1t = $cvi($get($_.sbs, $_.i)); _1s < _1t; _1s++) {
            $k[$j++] = 0;
          }
        }
      }
      if ($_.diff < 0) {
        $k[$j++] = 0;
      }
    }
    $_.pixs = $a();
    $_.pixy = ~~($_.pixs.length / $_.pixx);
    var _24 = /* @__PURE__ */ new Map([
      ["ren", "renmatrix"],
      ["pixs", $_.pixs],
      ["pixx", $_.pixx],
      ["pixy", $_.pixy],
      ["height", $_.pixy / 72],
      ["width", $_.pixx / 72],
      ["opt", $_.options]
    ]);
    $k[$j++] = _24;
    if (!$_.dontdraw) {
      $$.save();
      bwipp_renmatrix();
      $$.restore();
    }
  }
  $_ = $__;
}
function bwipp_upcacomposite() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.usematrix = false;
  $_.parse = false;
  $_.dontlint = false;
  $_.lintreqs = true;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.dontdraw) {
    $_.usematrix = true;
  }
  $search($_.barcode, "|");
  if ($k[--$j]) {
    $_.linear = $k[--$j];
    $j--;
    $_.comp = $k[--$j];
  } else {
    $j--;
    $k[$j++] = "bwipp.missingCompositeComponent#29830";
    $k[$j++] = "A Composite Component must be provided following a pipe character";
    bwipp_raiseerror();
  }
  $put($_.options, "lintype", "ean13");
  $put($_.options, "inkspreadv", 0);
  $put($_.options, "dontdraw", true);
  $put($_.options, "dontlint", true);
  var _C = $s($_.comp.length + 18);
  $puti(_C, 0, "(01)00000000000000");
  $puti(_C, 18, $_.comp);
  $k[$j++] = _C;
  $k[$j++] = "ai";
  bwipp_gs1process();
  $j -= 3;
  $k[$j++] = $_.linear;
  $k[$j++] = $_.options;
  bwipp_upca();
  if (!$_.usematrix) {
    $$.save();
    bwipp_renlinear();
    var _H = $$.currpos();
    $$.rmoveto(-3, 78);
    $k[$j++] = _H.x;
    $k[$j++] = _H.y;
    $k[$j++] = $_.comp;
    $k[$j++] = $_.options;
    bwipp_gs1_cc();
    bwipp_renmatrix();
    var _K = $k[--$j];
    $$.moveto($k[--$j] - 1, _K + 72);
    $k[$j++] = Infinity;
    $k[$j++] = Infinity;
    $k[$j++] = 0;
    $k[$j++] = 1;
    for (var _M = 0; _M < 93; _M++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 1;
    $k[$j++] = 0;
    $k[$j++] = 1;
    $k[$j++] = 0;
    for (var _N = 0; _N < 93; _N++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $k[$j++] = 1;
    $k[$j++] = 0;
    $k[$j++] = 1;
    for (var _O = 0; _O < 93; _O++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 1;
    $k[$j++] = 0;
    var _P = $a();
    $k[$j++] = "ren";
    $k[$j++] = "renmatrix";
    $k[$j++] = "pixs";
    $k[$j++] = _P;
    $k[$j++] = "pixx";
    $k[$j++] = 97;
    $k[$j++] = "pixy";
    $k[$j++] = 3;
    $k[$j++] = "height";
    $k[$j++] = 6 / 72;
    $k[$j++] = "width";
    $k[$j++] = 97 / 72;
    $k[$j++] = "opt";
    $k[$j++] = $_.options;
    var _R = $d();
    $k[$j++] = _R;
    bwipp_renmatrix();
    $$.restore();
  } else {
    $_.linsym = $k[--$j];
    $_.sbs = $get($_.linsym, "sbs");
    $_.bhs = $get($_.linsym, "bhs");
    $_.bbs = $get($_.linsym, "bbs");
    $k[$j++] = "linwidth";
    $k[$j++] = 0;
    $forall($_.sbs, function() {
      var _a = $k[--$j];
      var _b = $k[--$j];
      $k[$j++] = $f(_b + $cvi(_a));
    });
    var _c = $k[--$j];
    $_[$k[--$j]] = _c;
    $k[$j++] = "compsym";
    $k[$j++] = $_.comp;
    $k[$j++] = $_.options;
    bwipp_gs1_cc();
    var _g = $k[--$j];
    $_[$k[--$j]] = _g;
    $_.ccpixs = $get($_.compsym, "pixs");
    $_.ccpixx = $get($_.compsym, "pixx");
    $k[$j++] = Infinity;
    for (var _n = 0, _o = $_.ccpixx - 97; _n < _o; _n++) {
      $k[$j++] = 0;
    }
    $_.linpad = $a();
    $_.diff = $f($_.linwidth + $_.linpad.length + 1 - $_.ccpixx);
    if ($_.diff > 0) {
      $k[$j++] = Infinity;
      for (var _v = 0, _w = $_.diff; _v < _w; _v++) {
        $k[$j++] = 0;
      }
      $_.ccrpad = $a();
      $_.pixx = $f($_.ccpixx + $_.diff);
    } else {
      $_.ccrpad = $a(0);
      $_.pixx = $_.ccpixx;
    }
    $k[$j++] = Infinity;
    for (var _15 = 0, _16 = $_.ccpixx, _14 = $_.ccpixs.length - 1; _16 < 0 ? _15 >= _14 : _15 <= _14; _15 += _16) {
      $_.i = _15;
      $aload($geti($_.ccpixs, $_.i, $_.ccpixx));
      $aload($_.ccrpad);
    }
    for (var _1C = 0; _1C < 2; _1C++) {
      $aload($_.linpad);
      $k[$j++] = 0;
      $k[$j++] = 1;
      for (var _1E = 0; _1E < 93; _1E++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 1;
      $k[$j++] = 0;
      $aload($_.ccrpad);
    }
    for (var _1G = 0; _1G < 2; _1G++) {
      $aload($_.linpad);
      $k[$j++] = 1;
      $k[$j++] = 0;
      for (var _1I = 0; _1I < 93; _1I++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 0;
      $k[$j++] = 1;
      $aload($_.ccrpad);
    }
    for (var _1K = 0; _1K < 2; _1K++) {
      $aload($_.linpad);
      $k[$j++] = 0;
      $k[$j++] = 1;
      for (var _1M = 0; _1M < 93; _1M++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 1;
      $k[$j++] = 0;
      $aload($_.ccrpad);
    }
    for (var _1O = 71; _1O >= 0; _1O -= 1) {
      $_.y = _1O;
      $aload($_.linpad);
      $k[$j++] = 0;
      for (var _1S = 0, _1R = $_.sbs.length - 1; _1S <= _1R; _1S += 1) {
        $_.i = _1S;
        if ($_.i % 2 == 0) {
          var _1X = $get($_.bbs, ~~($_.i / 2)) * 72;
          if (_1X > $_.y || $f(_1X + $get($_.bhs, ~~($_.i / 2)) * 72) < $_.y) {
            for (var _1g = 0, _1h = $cvi($get($_.sbs, $_.i)); _1g < _1h; _1g++) {
              $k[$j++] = 0;
            }
          } else {
            for (var _1l = 0, _1m = $cvi($get($_.sbs, $_.i)); _1l < _1m; _1l++) {
              $k[$j++] = 1;
            }
          }
        } else {
          for (var _1q = 0, _1r = $cvi($get($_.sbs, $_.i)); _1q < _1r; _1q++) {
            $k[$j++] = 0;
          }
        }
      }
      if ($_.diff < 0) {
        $k[$j++] = 0;
      }
    }
    $_.pixs = $a();
    $_.pixy = ~~($_.pixs.length / $_.pixx);
    var _22 = /* @__PURE__ */ new Map([
      ["ren", "renmatrix"],
      ["pixs", $_.pixs],
      ["pixx", $_.pixx],
      ["pixy", $_.pixy],
      ["height", $_.pixy / 72],
      ["width", $_.pixx / 72],
      ["opt", $_.options]
    ]);
    $k[$j++] = _22;
    if (!$_.dontdraw) {
      $$.save();
      bwipp_renmatrix();
      $$.restore();
    }
  }
  $_ = $__;
}
function bwipp_upcecomposite() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.usematrix = false;
  $_.parse = false;
  $_.dontlint = false;
  $_.lintreqs = true;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.dontdraw) {
    $_.usematrix = true;
  }
  $search($_.barcode, "|");
  if ($k[--$j]) {
    $_.linear = $k[--$j];
    $j--;
    $_.comp = $k[--$j];
  } else {
    $j--;
    $k[$j++] = "bwipp.missingCompositeComponent#29993";
    $k[$j++] = "A Composite Component must be provided following a pipe character";
    bwipp_raiseerror();
  }
  $put($_.options, "lintype", "upce");
  $put($_.options, "inkspreadv", 0);
  $put($_.options, "dontdraw", true);
  $put($_.options, "dontlint", true);
  var _C = $s($_.comp.length + 18);
  $puti(_C, 0, "(01)00000000000000");
  $puti(_C, 18, $_.comp);
  $k[$j++] = _C;
  $k[$j++] = "ai";
  bwipp_gs1process();
  $j -= 3;
  $k[$j++] = $_.linear;
  $k[$j++] = $_.options;
  bwipp_upce();
  if (!$_.usematrix) {
    $$.save();
    bwipp_renlinear();
    var _H = $$.currpos();
    $$.rmoveto(-3, 78);
    $k[$j++] = _H.x;
    $k[$j++] = _H.y;
    $k[$j++] = $_.comp;
    $k[$j++] = $_.options;
    bwipp_gs1_cc();
    bwipp_renmatrix();
    var _K = $k[--$j];
    $$.moveto($k[--$j] - 1, _K + 72);
    $k[$j++] = Infinity;
    $k[$j++] = Infinity;
    $k[$j++] = 0;
    $k[$j++] = 1;
    for (var _M = 0; _M < 49; _M++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 1;
    $k[$j++] = 0;
    $k[$j++] = 1;
    $k[$j++] = 0;
    for (var _N = 0; _N < 49; _N++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $k[$j++] = 1;
    $k[$j++] = 0;
    $k[$j++] = 1;
    for (var _O = 0; _O < 49; _O++) {
      $k[$j++] = 0;
    }
    $k[$j++] = 1;
    $k[$j++] = 0;
    var _P = $a();
    $k[$j++] = "ren";
    $k[$j++] = "renmatrix";
    $k[$j++] = "pixs";
    $k[$j++] = _P;
    $k[$j++] = "pixx";
    $k[$j++] = 53;
    $k[$j++] = "pixy";
    $k[$j++] = 3;
    $k[$j++] = "height";
    $k[$j++] = 6 / 72;
    $k[$j++] = "width";
    $k[$j++] = 53 / 72;
    $k[$j++] = "opt";
    $k[$j++] = $_.options;
    var _R = $d();
    $k[$j++] = _R;
    bwipp_renmatrix();
    $$.restore();
  } else {
    $_.linsym = $k[--$j];
    $_.sbs = $get($_.linsym, "sbs");
    $_.bhs = $get($_.linsym, "bhs");
    $_.bbs = $get($_.linsym, "bbs");
    $k[$j++] = "linwidth";
    $k[$j++] = 0;
    $forall($_.sbs, function() {
      var _a = $k[--$j];
      var _b = $k[--$j];
      $k[$j++] = $f(_b + $cvi(_a));
    });
    var _c = $k[--$j];
    $_[$k[--$j]] = _c;
    $k[$j++] = "compsym";
    $k[$j++] = $_.comp;
    $k[$j++] = $_.options;
    bwipp_gs1_cc();
    var _g = $k[--$j];
    $_[$k[--$j]] = _g;
    $_.ccpixs = $get($_.compsym, "pixs");
    $_.ccpixx = $get($_.compsym, "pixx");
    $k[$j++] = Infinity;
    for (var _n = 0, _o = $_.ccpixx - 53; _n < _o; _n++) {
      $k[$j++] = 0;
    }
    $_.linpad = $a();
    $_.diff = $f($_.linwidth + $_.linpad.length + 1 - $_.ccpixx);
    if ($_.diff > 0) {
      $k[$j++] = Infinity;
      for (var _v = 0, _w = $_.diff; _v < _w; _v++) {
        $k[$j++] = 0;
      }
      $_.ccrpad = $a();
      $_.pixx = $f($_.ccpixx + $_.diff);
    } else {
      $_.ccrpad = $a(0);
      $_.pixx = $_.ccpixx;
    }
    $k[$j++] = Infinity;
    for (var _15 = 0, _16 = $_.ccpixx, _14 = $_.ccpixs.length - 1; _16 < 0 ? _15 >= _14 : _15 <= _14; _15 += _16) {
      $_.i = _15;
      $aload($geti($_.ccpixs, $_.i, $_.ccpixx));
      $aload($_.ccrpad);
    }
    for (var _1C = 0; _1C < 2; _1C++) {
      $aload($_.linpad);
      $k[$j++] = 0;
      $k[$j++] = 1;
      for (var _1E = 0; _1E < 49; _1E++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 1;
      $k[$j++] = 0;
      $aload($_.ccrpad);
    }
    for (var _1G = 0; _1G < 2; _1G++) {
      $aload($_.linpad);
      $k[$j++] = 1;
      $k[$j++] = 0;
      for (var _1I = 0; _1I < 49; _1I++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 0;
      $k[$j++] = 1;
      $aload($_.ccrpad);
    }
    for (var _1K = 0; _1K < 2; _1K++) {
      $aload($_.linpad);
      $k[$j++] = 0;
      $k[$j++] = 1;
      for (var _1M = 0; _1M < 49; _1M++) {
        $k[$j++] = 0;
      }
      $k[$j++] = 1;
      $k[$j++] = 0;
      $aload($_.ccrpad);
    }
    for (var _1O = 71; _1O >= 0; _1O -= 1) {
      $_.y = _1O;
      $aload($_.linpad);
      $k[$j++] = 0;
      for (var _1S = 0, _1R = $_.sbs.length - 1; _1S <= _1R; _1S += 1) {
        $_.i = _1S;
        if ($_.i % 2 == 0) {
          var _1X = $get($_.bbs, ~~($_.i / 2)) * 72;
          if (_1X > $_.y || $f(_1X + $get($_.bhs, ~~($_.i / 2)) * 72) < $_.y) {
            for (var _1g = 0, _1h = $cvi($get($_.sbs, $_.i)); _1g < _1h; _1g++) {
              $k[$j++] = 0;
            }
          } else {
            for (var _1l = 0, _1m = $cvi($get($_.sbs, $_.i)); _1l < _1m; _1l++) {
              $k[$j++] = 1;
            }
          }
        } else {
          for (var _1q = 0, _1r = $cvi($get($_.sbs, $_.i)); _1q < _1r; _1q++) {
            $k[$j++] = 0;
          }
        }
      }
      if ($_.diff < 0) {
        $k[$j++] = 0;
      }
    }
    $_.pixs = $a();
    $_.pixy = ~~($_.pixs.length / $_.pixx);
    var _22 = /* @__PURE__ */ new Map([
      ["ren", "renmatrix"],
      ["pixs", $_.pixs],
      ["pixx", $_.pixx],
      ["pixy", $_.pixy],
      ["height", $_.pixy / 72],
      ["width", $_.pixx / 72],
      ["opt", $_.options]
    ]);
    $k[$j++] = _22;
    if (!$_.dontdraw) {
      $$.save();
      bwipp_renmatrix();
      $$.restore();
    }
  }
  $_ = $__;
}
function bwipp_databaromnicomposite() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.usematrix = false;
  $_.parse = false;
  $_.dontlint = false;
  $_.lintreqs = true;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.dontdraw) {
    $_.usematrix = true;
  }
  $search($_.barcode, "|");
  if ($k[--$j]) {
    $_.linear = $k[--$j];
    $j--;
    $_.comp = $k[--$j];
  } else {
    $j--;
    $k[$j++] = "bwipp.missingCompositeComponent#30156";
    $k[$j++] = "A Composite Component must be provided following a pipe character";
    bwipp_raiseerror();
  }
  if (!$_.usematrix) {
    $$.save();
  }
  $put($_.options, "lintype", "databaromni");
  $put($_.options, "linkage", true);
  $put($_.options, "inkspreadv", 0);
  $put($_.options, "dontdraw", true);
  $put($_.options, "dontlint", true);
  var _F = $s($_.linear.length + $_.comp.length);
  $puti(_F, 0, $_.linear);
  $puti(_F, $_.linear.length, $_.comp);
  $k[$j++] = _F;
  $k[$j++] = "ai";
  bwipp_gs1process();
  $j -= 3;
  $k[$j++] = $_.linear;
  $k[$j++] = $_.options;
  bwipp_databaromni();
  var _L = $k[--$j];
  $_.linsbs = $get(_L, "sbs");
  $_.linheight = $get($get(_L, "bhs"), 0) * 72;
  $k[$j++] = _L;
  if (!$_.usematrix) {
    bwipp_renlinear();
  } else {
    $j--;
  }
  $_.sepfinder = function() {
    $_.fp = $k[--$j];
    for (var _U = $_.fp, _T = $_.fp + 12; _U <= _T; _U += 1) {
      $_.i = _U;
      if ($get($_.bot, $_.i) == 0) {
        if ($get($_.bot, $_.i - 1) == 1) {
          $k[$j++] = 1;
        } else {
          var _e = $get($_.sep, $_.i - 1) == 0 ? 1 : 0;
          $k[$j++] = _e;
        }
      } else {
        $k[$j++] = 0;
      }
      $put($_.sep, $_.i, $k[--$j]);
    }
    $_.f3 = $a([1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1]);
    $k[$j++] = true;
    for (var _j = 0; _j <= 12; _j += 1) {
      var _p = $k[--$j];
      $k[$j++] = _p && $eq($get($_.bot, $f(_j + $_.fp)), $get($_.f3, _j));
    }
    if ($k[--$j]) {
      $puti($_.sep, $_.fp, $a([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]));
    }
  };
  $k[$j++] = Infinity;
  $k[$j++] = 0;
  $forall($_.linsbs, function() {
    var _v = $k[--$j];
    var _w = $k[$j - 1];
    var _x = _w == 1 ? 0 : 1;
    for (var _y = 0, _z = _v; _y < _z; _y++) {
      $k[$j++] = _x;
    }
  });
  $astore($a($counttomark() - 1));
  $_.bot = $k[--$j];
  $j -= 2;
  $k[$j++] = Infinity;
  $forall($_.bot, function() {
    var _14 = $k[--$j];
    $k[$j++] = 1 - _14;
  });
  $_.sep = $a();
  $puti($_.sep, 0, $a([0, 0, 0]));
  $puti($_.sep, $_.sep.length - 4, $a([0, 0, 0, 0]));
  $k[$j++] = 18;
  $_.sepfinder();
  $k[$j++] = 64;
  $_.sepfinder();
  if (!$_.usematrix) {
    var _1C = $$.currpos();
    $$.rmoveto(-5, $_.linheight + 1);
    $k[$j++] = _1C.x;
    $k[$j++] = _1C.y;
    $k[$j++] = $_.comp;
    $k[$j++] = $_.options;
    bwipp_gs1_cc();
    bwipp_renmatrix();
    var _1H = $k[--$j];
    $$.moveto($k[--$j], $f(_1H + $_.linheight));
    var _1N = /* @__PURE__ */ new Map([
      ["ren", "renmatrix"],
      ["pixs", $_.sep],
      ["pixx", $_.sep.length],
      ["pixy", 1],
      ["height", 1 / 72],
      ["width", $_.sep.length / 72],
      ["opt", $_.options]
    ]);
    $k[$j++] = _1N;
    bwipp_renmatrix();
    $$.restore();
  } else {
    $k[$j++] = "compsym";
    $k[$j++] = $_.comp;
    $k[$j++] = $_.options;
    bwipp_gs1_cc();
    var _1Q = $k[--$j];
    $_[$k[--$j]] = _1Q;
    $_.ccpixs = $get($_.compsym, "pixs");
    $_.ccpixx = $get($_.compsym, "pixx");
    $k[$j++] = Infinity;
    $k[$j++] = 0;
    $forall($_.linsbs, function() {
      var _1X = $k[--$j];
      var _1Y = $k[$j - 1];
      var _1Z = _1Y == 0 ? 1 : 0;
      for (var _1a = 0, _1b = $cvi(_1X); _1a < _1b; _1a++) {
        $k[$j++] = _1Z;
      }
    });
    $_.linpixs = $a();
    $k[$j++] = Infinity;
    $k[$j++] = 0;
    $aload($_.sep);
    $_.sep = $a();
    $_.linheight = ~~$_.linheight;
    $k[$j++] = Infinity;
    for (var _1j = 0, _1k = $_.ccpixx, _1i = $_.ccpixs.length - 1; _1k < 0 ? _1j >= _1i : _1j <= _1i; _1j += _1k) {
      $_.i = _1j;
      $aload($geti($_.ccpixs, $_.i, $_.ccpixx));
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $k[$j++] = 0;
    $k[$j++] = 0;
    $k[$j++] = 0;
    $aload($_.sep);
    for (var _1r = 0, _1s = $_.linheight; _1r < _1s; _1r++) {
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $aload($_.linpixs);
    }
    $_.pixs = $a();
    $_.pixx = $_.ccpixx + 1;
    $_.pixy = ~~($_.pixs.length / $_.pixx);
    var _24 = /* @__PURE__ */ new Map([
      ["ren", "renmatrix"],
      ["pixs", $_.pixs],
      ["pixx", $_.pixx],
      ["pixy", $_.pixy],
      ["height", $_.pixy / 72],
      ["width", $_.pixx / 72],
      ["opt", $_.options]
    ]);
    $k[$j++] = _24;
    if (!$_.dontdraw) {
      $$.save();
      bwipp_renmatrix();
      $$.restore();
    }
  }
  $_ = $__;
}
function bwipp_databarstackedcomposite() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.usematrix = false;
  $_.parse = false;
  $_.dontlint = false;
  $_.lintreqs = true;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.dontdraw) {
    $_.usematrix = true;
  }
  $search($_.barcode, "|");
  if ($k[--$j]) {
    $_.linear = $k[--$j];
    $j--;
    $_.comp = $k[--$j];
  } else {
    $j--;
    $k[$j++] = "bwipp.missingCompositeComponent#30317";
    $k[$j++] = "A Composite Component must be provided following a pipe character";
    bwipp_raiseerror();
  }
  if (!$_.usematrix) {
    $$.save();
  }
  $put($_.options, "lintype", "databarstacked");
  $put($_.options, "linkage", true);
  $put($_.options, "inkspreadv", 0);
  $put($_.options, "dontdraw", true);
  $put($_.options, "dontlint", true);
  var _F = $s($_.linear.length + $_.comp.length);
  $puti(_F, 0, $_.linear);
  $puti(_F, $_.linear.length, $_.comp);
  $k[$j++] = _F;
  $k[$j++] = "ai";
  bwipp_gs1process();
  $j -= 3;
  $k[$j++] = $_.linear;
  $k[$j++] = $_.options;
  bwipp_databarstacked();
  var _L = $k[--$j];
  $_.bot = $geti($get(_L, "pixs"), 0, $get(_L, "pixx"));
  $_.linheight = $get(_L, "pixy");
  $k[$j++] = _L;
  if (!$_.usematrix) {
    bwipp_renmatrix();
  } else {
    $_.linpixs = $get($k[--$j], "pixs");
  }
  $_.sepfinder = function() {
    $_.fp = $k[--$j];
    for (var _X = $_.fp, _W = $_.fp + 12; _X <= _W; _X += 1) {
      $_.i = _X;
      if ($get($_.bot, $_.i) == 0) {
        if ($get($_.bot, $_.i - 1) == 1) {
          $k[$j++] = 1;
        } else {
          var _h = $get($_.sep, $_.i - 1) == 0 ? 1 : 0;
          $k[$j++] = _h;
        }
      } else {
        $k[$j++] = 0;
      }
      $put($_.sep, $_.i, $k[--$j]);
    }
    $_.f3 = $a([1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1]);
    $k[$j++] = true;
    for (var _m = 0; _m <= 12; _m += 1) {
      var _s = $k[--$j];
      $k[$j++] = _s && $eq($get($_.bot, $f(_m + $_.fp)), $get($_.f3, _m));
    }
    if ($k[--$j]) {
      $puti($_.sep, $_.fp, $a([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]));
    }
  };
  $k[$j++] = Infinity;
  var _x = $_.bot;
  for (var _y = 0, _z = _x.length; _y < _z; _y++) {
    $k[$j++] = 1 - $get(_x, _y);
  }
  $_.sep = $a();
  $puti($_.sep, 0, $a([0, 0, 0, 0]));
  $puti($_.sep, $_.sep.length - 4, $a([0, 0, 0, 0]));
  $k[$j++] = 18;
  $_.sepfinder();
  if (!$_.usematrix) {
    var _18 = $$.currpos();
    $$.rmoveto(1, $_.linheight + 1);
    $k[$j++] = _18.x;
    $k[$j++] = _18.y;
    $k[$j++] = $_.comp;
    $k[$j++] = $_.options;
    bwipp_gs1_cc();
    bwipp_renmatrix();
    var _1D = $k[--$j];
    $$.moveto($k[--$j], $f(_1D + $_.linheight));
    var _1J = /* @__PURE__ */ new Map([
      ["ren", "renmatrix"],
      ["pixs", $_.sep],
      ["pixx", $_.sep.length],
      ["pixy", 1],
      ["height", 1 / 72],
      ["width", $_.sep.length / 72],
      ["opt", $_.options]
    ]);
    $k[$j++] = _1J;
    bwipp_renmatrix();
    $$.restore();
  } else {
    $k[$j++] = "compsym";
    $k[$j++] = $_.comp;
    $k[$j++] = $_.options;
    bwipp_gs1_cc();
    var _1M = $k[--$j];
    $_[$k[--$j]] = _1M;
    $_.ccpixs = $get($_.compsym, "pixs");
    $_.ccpixx = $get($_.compsym, "pixx");
    $_.linwidth = $_.sep.length;
    $k[$j++] = Infinity;
    for (var _1W = 0, _1X = $_.ccpixx, _1V = $_.ccpixs.length - 1; _1X < 0 ? _1W >= _1V : _1W <= _1V; _1W += _1X) {
      $_.i = _1W;
      $k[$j++] = 0;
      $aload($geti($_.ccpixs, $_.i, $_.ccpixx));
    }
    $aload($_.sep);
    $k[$j++] = 0;
    $k[$j++] = 0;
    $k[$j++] = 0;
    $k[$j++] = 0;
    $k[$j++] = 0;
    $k[$j++] = 0;
    for (var _1g = 0, _1h = $_.linwidth, _1f = $_.linpixs.length - 1; _1h < 0 ? _1g >= _1f : _1g <= _1f; _1g += _1h) {
      $_.i = _1g;
      $aload($geti($_.linpixs, $_.i, $_.linwidth));
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
    }
    $_.pixs = $a();
    $_.pixx = $_.ccpixx + 1;
    $_.pixy = ~~($_.pixs.length / $_.pixx);
    var _1w = /* @__PURE__ */ new Map([
      ["ren", "renmatrix"],
      ["pixs", $_.pixs],
      ["pixx", $_.pixx],
      ["pixy", $_.pixy],
      ["height", $_.pixy / 72],
      ["width", $_.pixx / 72],
      ["opt", $_.options]
    ]);
    $k[$j++] = _1w;
    if (!$_.dontdraw) {
      $$.save();
      bwipp_renmatrix();
      $$.restore();
    }
  }
  $_ = $__;
}
function bwipp_databarstackedomnicomposite() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.usematrix = false;
  $_.parse = false;
  $_.dontlint = false;
  $_.lintreqs = true;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.dontdraw) {
    $_.usematrix = true;
  }
  $search($_.barcode, "|");
  if ($k[--$j]) {
    $_.linear = $k[--$j];
    $j--;
    $_.comp = $k[--$j];
  } else {
    $j--;
    $k[$j++] = "bwipp.missingCompositeComponent#30474";
    $k[$j++] = "A Composite Component must be provided following a pipe character";
    bwipp_raiseerror();
  }
  if (!$_.usematrix) {
    $$.save();
  }
  $put($_.options, "lintype", "databarstackedomni");
  $put($_.options, "linkage", true);
  $put($_.options, "inkspreadv", 0);
  $put($_.options, "dontdraw", true);
  $put($_.options, "dontlint", true);
  var _F = $s($_.linear.length + $_.comp.length);
  $puti(_F, 0, $_.linear);
  $puti(_F, $_.linear.length, $_.comp);
  $k[$j++] = _F;
  $k[$j++] = "ai";
  bwipp_gs1process();
  $j -= 3;
  $k[$j++] = $_.linear;
  $k[$j++] = $_.options;
  bwipp_databarstackedomni();
  var _L = $k[--$j];
  $_.bot = $geti($get(_L, "pixs"), 0, $get(_L, "pixx"));
  $_.linheight = $get(_L, "pixy");
  $k[$j++] = _L;
  if (!$_.usematrix) {
    bwipp_renmatrix();
  } else {
    $_.linpixs = $get($k[--$j], "pixs");
  }
  $_.sepfinder = function() {
    $_.fp = $k[--$j];
    for (var _X = $_.fp, _W = $_.fp + 12; _X <= _W; _X += 1) {
      $_.i = _X;
      if ($get($_.bot, $_.i) == 0) {
        if ($get($_.bot, $_.i - 1) == 1) {
          $k[$j++] = 1;
        } else {
          var _h = $get($_.sep, $_.i - 1) == 0 ? 1 : 0;
          $k[$j++] = _h;
        }
      } else {
        $k[$j++] = 0;
      }
      $put($_.sep, $_.i, $k[--$j]);
    }
    $_.f3 = $a([1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1]);
    $k[$j++] = true;
    for (var _m = 0; _m <= 12; _m += 1) {
      var _s = $k[--$j];
      $k[$j++] = _s && $eq($get($_.bot, $f(_m + $_.fp)), $get($_.f3, _m));
    }
    if ($k[--$j]) {
      $puti($_.sep, $_.fp, $a([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]));
    }
  };
  $k[$j++] = Infinity;
  var _x = $_.bot;
  for (var _y = 0, _z = _x.length; _y < _z; _y++) {
    $k[$j++] = 1 - $get(_x, _y);
  }
  $_.sep = $a();
  $puti($_.sep, 0, $a([0, 0, 0, 0]));
  $puti($_.sep, $_.sep.length - 4, $a([0, 0, 0, 0]));
  $k[$j++] = 18;
  $_.sepfinder();
  if (!$_.usematrix) {
    var _18 = $$.currpos();
    $$.rmoveto(1, $_.linheight + 1);
    $k[$j++] = _18.x;
    $k[$j++] = _18.y;
    $k[$j++] = $_.comp;
    $k[$j++] = $_.options;
    bwipp_gs1_cc();
    bwipp_renmatrix();
    var _1D = $k[--$j];
    $$.moveto($k[--$j], $f(_1D + $_.linheight));
    var _1J = /* @__PURE__ */ new Map([
      ["ren", "renmatrix"],
      ["pixs", $_.sep],
      ["pixx", $_.sep.length],
      ["pixy", 1],
      ["height", 1 / 72],
      ["width", $_.sep.length / 72],
      ["opt", $_.options]
    ]);
    $k[$j++] = _1J;
    bwipp_renmatrix();
    $$.restore();
  } else {
    $k[$j++] = "compsym";
    $k[$j++] = $_.comp;
    $k[$j++] = $_.options;
    bwipp_gs1_cc();
    var _1M = $k[--$j];
    $_[$k[--$j]] = _1M;
    $_.ccpixs = $get($_.compsym, "pixs");
    $_.ccpixx = $get($_.compsym, "pixx");
    $_.linwidth = $_.sep.length;
    $k[$j++] = Infinity;
    for (var _1W = 0, _1X = $_.ccpixx, _1V = $_.ccpixs.length - 1; _1X < 0 ? _1W >= _1V : _1W <= _1V; _1W += _1X) {
      $_.i = _1W;
      $k[$j++] = 0;
      $aload($geti($_.ccpixs, $_.i, $_.ccpixx));
    }
    $aload($_.sep);
    $k[$j++] = 0;
    $k[$j++] = 0;
    $k[$j++] = 0;
    $k[$j++] = 0;
    $k[$j++] = 0;
    $k[$j++] = 0;
    for (var _1g = 0, _1h = $_.linwidth, _1f = $_.linpixs.length - 1; _1h < 0 ? _1g >= _1f : _1g <= _1f; _1g += _1h) {
      $_.i = _1g;
      $aload($geti($_.linpixs, $_.i, $_.linwidth));
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
    }
    $_.pixs = $a();
    $_.pixx = $_.ccpixx + 1;
    $_.pixy = ~~($_.pixs.length / $_.pixx);
    var _1w = /* @__PURE__ */ new Map([
      ["ren", "renmatrix"],
      ["pixs", $_.pixs],
      ["pixx", $_.pixx],
      ["pixy", $_.pixy],
      ["height", $_.pixy / 72],
      ["width", $_.pixx / 72],
      ["opt", $_.options]
    ]);
    $k[$j++] = _1w;
    if (!$_.dontdraw) {
      $$.save();
      bwipp_renmatrix();
      $$.restore();
    }
  }
  $_ = $__;
}
function bwipp_databartruncatedcomposite() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.usematrix = false;
  $_.parse = false;
  $_.dontlint = false;
  $_.lintreqs = true;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.dontdraw) {
    $_.usematrix = true;
  }
  $search($_.barcode, "|");
  if ($k[--$j]) {
    $_.linear = $k[--$j];
    $j--;
    $_.comp = $k[--$j];
  } else {
    $j--;
    $k[$j++] = "bwipp.missingCompositeComponent#30632";
    $k[$j++] = "A Composite Component must be provided following a pipe character";
    bwipp_raiseerror();
  }
  if (!$_.usematrix) {
    $$.save();
  }
  $put($_.options, "lintype", "databartruncated");
  $put($_.options, "linkage", true);
  $put($_.options, "inkspreadv", 0);
  $put($_.options, "dontdraw", true);
  $put($_.options, "dontlint", true);
  var _F = $s($_.linear.length + $_.comp.length);
  $puti(_F, 0, $_.linear);
  $puti(_F, $_.linear.length, $_.comp);
  $k[$j++] = _F;
  $k[$j++] = "ai";
  bwipp_gs1process();
  $j -= 3;
  $k[$j++] = $_.linear;
  $k[$j++] = $_.options;
  bwipp_databartruncated();
  var _L = $k[--$j];
  $_.linsbs = $get(_L, "sbs");
  $_.linheight = $get($get(_L, "bhs"), 0) * 72;
  $k[$j++] = _L;
  if (!$_.usematrix) {
    bwipp_renlinear();
  } else {
    $j--;
  }
  $_.sepfinder = function() {
    $_.fp = $k[--$j];
    for (var _U = $_.fp, _T = $_.fp + 12; _U <= _T; _U += 1) {
      $_.i = _U;
      if ($get($_.bot, $_.i) == 0) {
        if ($get($_.bot, $_.i - 1) == 1) {
          $k[$j++] = 1;
        } else {
          var _e = $get($_.sep, $_.i - 1) == 0 ? 1 : 0;
          $k[$j++] = _e;
        }
      } else {
        $k[$j++] = 0;
      }
      $put($_.sep, $_.i, $k[--$j]);
    }
    $_.f3 = $a([1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1]);
    $k[$j++] = true;
    for (var _j = 0; _j <= 12; _j += 1) {
      var _p = $k[--$j];
      $k[$j++] = _p && $eq($get($_.bot, $f(_j + $_.fp)), $get($_.f3, _j));
    }
    if ($k[--$j]) {
      $puti($_.sep, $_.fp, $a([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]));
    }
  };
  $k[$j++] = Infinity;
  $k[$j++] = 0;
  $forall($_.linsbs, function() {
    var _v = $k[--$j];
    var _w = $k[$j - 1];
    var _x = _w == 1 ? 0 : 1;
    for (var _y = 0, _z = _v; _y < _z; _y++) {
      $k[$j++] = _x;
    }
  });
  $astore($a($counttomark() - 1));
  $_.bot = $k[--$j];
  $j -= 2;
  $k[$j++] = Infinity;
  $forall($_.bot, function() {
    var _14 = $k[--$j];
    $k[$j++] = 1 - _14;
  });
  $_.sep = $a();
  $puti($_.sep, 0, $a([0, 0, 0]));
  $puti($_.sep, $_.sep.length - 4, $a([0, 0, 0, 0]));
  $k[$j++] = 18;
  $_.sepfinder();
  $k[$j++] = 64;
  $_.sepfinder();
  if (!$_.usematrix) {
    var _1C = $$.currpos();
    $$.rmoveto(-5, $_.linheight + 1);
    $k[$j++] = _1C.x;
    $k[$j++] = _1C.y;
    $k[$j++] = $_.comp;
    $k[$j++] = $_.options;
    bwipp_gs1_cc();
    bwipp_renmatrix();
    var _1H = $k[--$j];
    $$.moveto($k[--$j], $f(_1H + $_.linheight));
    var _1N = /* @__PURE__ */ new Map([
      ["ren", "renmatrix"],
      ["pixs", $_.sep],
      ["pixx", $_.sep.length],
      ["pixy", 1],
      ["height", 1 / 72],
      ["width", $_.sep.length / 72],
      ["opt", $_.options]
    ]);
    $k[$j++] = _1N;
    bwipp_renmatrix();
    $$.restore();
  } else {
    $k[$j++] = "compsym";
    $k[$j++] = $_.comp;
    $k[$j++] = $_.options;
    bwipp_gs1_cc();
    var _1Q = $k[--$j];
    $_[$k[--$j]] = _1Q;
    $_.ccpixs = $get($_.compsym, "pixs");
    $_.ccpixx = $get($_.compsym, "pixx");
    $k[$j++] = Infinity;
    $k[$j++] = 0;
    $forall($_.linsbs, function() {
      var _1X = $k[--$j];
      var _1Y = $k[$j - 1];
      var _1Z = _1Y == 0 ? 1 : 0;
      for (var _1a = 0, _1b = $cvi(_1X); _1a < _1b; _1a++) {
        $k[$j++] = _1Z;
      }
    });
    $_.linpixs = $a();
    $k[$j++] = Infinity;
    $k[$j++] = 0;
    $aload($_.sep);
    $_.sep = $a();
    $_.linheight = ~~$_.linheight;
    $k[$j++] = Infinity;
    for (var _1j = 0, _1k = $_.ccpixx, _1i = $_.ccpixs.length - 1; _1k < 0 ? _1j >= _1i : _1j <= _1i; _1j += _1k) {
      $_.i = _1j;
      $aload($geti($_.ccpixs, $_.i, $_.ccpixx));
      $k[$j++] = 0;
    }
    $k[$j++] = 0;
    $k[$j++] = 0;
    $k[$j++] = 0;
    $k[$j++] = 0;
    $aload($_.sep);
    for (var _1r = 0, _1s = $_.linheight; _1r < _1s; _1r++) {
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $aload($_.linpixs);
    }
    $_.pixs = $a();
    $_.pixx = $_.ccpixx + 1;
    $_.pixy = ~~($_.pixs.length / $_.pixx);
    var _24 = /* @__PURE__ */ new Map([
      ["ren", "renmatrix"],
      ["pixs", $_.pixs],
      ["pixx", $_.pixx],
      ["pixy", $_.pixy],
      ["height", $_.pixy / 72],
      ["width", $_.pixx / 72],
      ["opt", $_.options]
    ]);
    $k[$j++] = _24;
    if (!$_.dontdraw) {
      $$.save();
      bwipp_renmatrix();
      $$.restore();
    }
  }
  $_ = $__;
}
function bwipp_databarlimitedcomposite() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.usematrix = false;
  $_.parse = false;
  $_.dontlint = false;
  $_.lintreqs = true;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.dontdraw) {
    $_.usematrix = true;
  }
  $search($_.barcode, "|");
  if ($k[--$j]) {
    $_.linear = $k[--$j];
    $j--;
    $_.comp = $k[--$j];
  } else {
    $j--;
    $k[$j++] = "bwipp.missingCompositeComponent#30794";
    $k[$j++] = "A Composite Component must be provided following a pipe character";
    bwipp_raiseerror();
  }
  if (!$_.usematrix) {
    $$.save();
  }
  $put($_.options, "lintype", "databarlimited");
  $put($_.options, "linkage", true);
  $put($_.options, "inkspreadv", 0);
  $put($_.options, "dontdraw", true);
  $put($_.options, "dontlint", true);
  var _F = $s($_.linear.length + $_.comp.length);
  $puti(_F, 0, $_.linear);
  $puti(_F, $_.linear.length, $_.comp);
  $k[$j++] = _F;
  $k[$j++] = "ai";
  bwipp_gs1process();
  $j -= 3;
  $k[$j++] = $_.linear;
  $k[$j++] = $_.options;
  bwipp_databarlimited();
  var _L = $k[--$j];
  $_.linsbs = $get(_L, "sbs");
  $_.linheight = $get($get(_L, "bhs"), 0) * 72;
  $k[$j++] = _L;
  if (!$_.usematrix) {
    bwipp_renlinear();
  } else {
    $j--;
  }
  $k[$j++] = Infinity;
  $k[$j++] = 1;
  $forall($_.linsbs, function() {
    var _R = $k[--$j];
    var _S = $k[$j - 1];
    var _T = _S == 0 ? 1 : 0;
    for (var _U = 0, _V = _R; _U < _V; _U++) {
      $k[$j++] = _T;
    }
  });
  $astore($a($counttomark() - 1));
  $_.sep = $k[--$j];
  $j -= 2;
  $puti($_.sep, 0, $a([0, 0, 0]));
  var _c = $_.sep;
  $puti($_.sep, _c.length - 9, $a([0, 0, 0, 0, 0, 0, 0, 0, 0]));
  if (!$_.usematrix) {
    var _f = $$.currpos();
    var _g = $_.comp;
    $k[$j++] = _f.x;
    $k[$j++] = _f.y;
    $k[$j++] = _g;
    $k[$j++] = $_.options;
    bwipp_gs1_cc();
    var _i = $k[--$j];
    $$.rmoveto(72 - $get(_i, "pixx"), $_.linheight + 1);
    $k[$j++] = _i;
    bwipp_renmatrix();
    var _m = $k[--$j];
    $$.moveto($k[--$j], $f(_m + $_.linheight));
    var _r = $_.options;
    var _s = /* @__PURE__ */ new Map([
      ["ren", "renmatrix"],
      ["pixs", $_.sep],
      ["pixx", $_.sep.length],
      ["pixy", 1],
      ["height", 1 / 72],
      ["width", $_.sep.length / 72],
      ["opt", _r]
    ]);
    $k[$j++] = _s;
    bwipp_renmatrix();
    $$.restore();
  } else {
    $k[$j++] = "compsym";
    $k[$j++] = $_.comp;
    $k[$j++] = $_.options;
    bwipp_gs1_cc();
    var _v = $k[--$j];
    $_[$k[--$j]] = _v;
    $_.ccpixs = $get($_.compsym, "pixs");
    $_.ccpixx = $get($_.compsym, "pixx");
    $k[$j++] = Infinity;
    $k[$j++] = 0;
    $forall($_.linsbs, function() {
      var _12 = $k[--$j];
      var _13 = $k[$j - 1];
      var _14 = _13 == 0 ? 1 : 0;
      for (var _15 = 0, _16 = $cvi(_12); _15 < _16; _15++) {
        $k[$j++] = _14;
      }
    });
    $_.linpixs = $a();
    $k[$j++] = Infinity;
    $k[$j++] = 0;
    $aload($_.sep);
    $_.sep = $a();
    $_.linheight = ~~$_.linheight;
    if ($_.ccpixx == 72) {
      $k[$j++] = Infinity;
      for (var _1F = 0, _1G = $_.ccpixx, _1E = $_.ccpixs.length - 1; _1G < 0 ? _1F >= _1E : _1F <= _1E; _1F += _1G) {
        $_.i = _1F;
        $k[$j++] = 0;
        $aload($geti($_.ccpixs, $_.i, $_.ccpixx));
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
      }
      $aload($_.sep);
      for (var _1N = 0, _1O = $_.linheight; _1N < _1O; _1N++) {
        $aload($_.linpixs);
      }
      $_.pixs = $a();
      $_.pixx = $_.linpixs.length;
    } else {
      $k[$j++] = Infinity;
      for (var _1V = 0, _1W = $_.ccpixx, _1U = $_.ccpixs.length - 1; _1W < 0 ? _1V >= _1U : _1V <= _1U; _1V += _1W) {
        $_.i = _1V;
        $aload($geti($_.ccpixs, $_.i, $_.ccpixx));
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
      }
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $aload($_.sep);
      for (var _1d = 0, _1e = $_.linheight; _1d < _1e; _1d++) {
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $k[$j++] = 0;
        $aload($_.linpixs);
      }
      $_.pixs = $a();
      $_.pixx = $_.ccpixx + 6;
    }
    $_.pixy = ~~($_.pixs.length / $_.pixx);
    var _1q = /* @__PURE__ */ new Map([
      ["ren", "renmatrix"],
      ["pixs", $_.pixs],
      ["pixx", $_.pixx],
      ["pixy", $_.pixy],
      ["height", $_.pixy / 72],
      ["width", $_.pixx / 72],
      ["opt", $_.options]
    ]);
    $k[$j++] = _1q;
    if (!$_.dontdraw) {
      $$.save();
      bwipp_renmatrix();
      $$.restore();
    }
  }
  $_ = $__;
}
function bwipp_databarexpandedcomposite() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.usematrix = false;
  $_.parse = false;
  $_.dontlint = false;
  $_.lintreqs = true;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.dontdraw) {
    $_.usematrix = true;
  }
  $search($_.barcode, "|");
  if ($k[--$j]) {
    $_.linear = $k[--$j];
    $j--;
    $_.comp = $k[--$j];
  } else {
    $j--;
    $k[$j++] = "bwipp.missingCompositeComponent#30946";
    $k[$j++] = "A Composite Component must be provided following a pipe character";
    bwipp_raiseerror();
  }
  if (!$_.usematrix) {
    $$.save();
  }
  $put($_.options, "lintype", "databarexpanded");
  $put($_.options, "linkage", true);
  $put($_.options, "inkspreadv", 0);
  $put($_.options, "dontdraw", true);
  $put($_.options, "dontlint", true);
  var _F = $s($_.linear.length + $_.comp.length);
  $puti(_F, 0, $_.linear);
  $puti(_F, $_.linear.length, $_.comp);
  $k[$j++] = _F;
  $k[$j++] = "ai";
  bwipp_gs1process();
  $j -= 3;
  $k[$j++] = $_.linear;
  $k[$j++] = $_.options;
  bwipp_databarexpanded();
  var _L = $k[--$j];
  $_.linsbs = $get(_L, "sbs");
  $_.linheight = $get($get(_L, "bhs"), 0) * 72;
  $k[$j++] = _L;
  if (!$_.usematrix) {
    bwipp_renlinear();
  } else {
    $j--;
  }
  $_.sepfinder = function() {
    $_.fp = $k[--$j];
    for (var _U = $_.fp, _T = $_.fp + 12; _U <= _T; _U += 1) {
      $_.i = _U;
      if ($get($_.bot, $_.i) == 0) {
        if ($get($_.bot, $_.i - 1) == 1) {
          $k[$j++] = 1;
        } else {
          var _e = $get($_.sep, $_.i - 1) == 0 ? 1 : 0;
          $k[$j++] = _e;
        }
      } else {
        $k[$j++] = 0;
      }
      $put($_.sep, $_.i, $k[--$j]);
    }
  };
  $k[$j++] = Infinity;
  $k[$j++] = 0;
  $forall($_.linsbs, function() {
    var _j = $k[--$j];
    var _k = $k[$j - 1];
    var _l = _k == 1 ? 0 : 1;
    for (var _m = 0, _n = _j; _m < _n; _m++) {
      $k[$j++] = _l;
    }
  });
  $astore($a($counttomark() - 1));
  $_.bot = $k[--$j];
  $j -= 2;
  $k[$j++] = Infinity;
  $forall($_.bot, function() {
    var _s = $k[--$j];
    $k[$j++] = 1 - _s;
  });
  $_.sep = $a();
  $puti($_.sep, 0, $a([0, 0, 0]));
  $puti($_.sep, $_.sep.length - 4, $a([0, 0, 0, 0]));
  $k[$j++] = Infinity;
  for (var _11 = 18, _10 = $_.bot.length - 13; _11 <= _10; _11 += 98) {
    $k[$j++] = _11;
  }
  for (var _14 = 69, _13 = $_.bot.length - 13; _14 <= _13; _14 += 98) {
    $k[$j++] = _14;
  }
  var _15 = $a();
  for (var _16 = 0, _17 = _15.length; _16 < _17; _16++) {
    $k[$j++] = $get(_15, _16);
    $_.sepfinder();
  }
  if (!$_.usematrix) {
    var _1A = $$.currpos();
    $$.rmoveto(1, $_.linheight + 1);
    $k[$j++] = _1A.x;
    $k[$j++] = _1A.y;
    $k[$j++] = $_.comp;
    $k[$j++] = $_.options;
    bwipp_gs1_cc();
    bwipp_renmatrix();
    var _1F = $k[--$j];
    $$.moveto($k[--$j], $f(_1F + $_.linheight));
    var _1L = /* @__PURE__ */ new Map([
      ["ren", "renmatrix"],
      ["pixs", $_.sep],
      ["pixx", $_.sep.length],
      ["pixy", 1],
      ["height", 1 / 72],
      ["width", $_.sep.length / 72],
      ["opt", $_.options]
    ]);
    $k[$j++] = _1L;
    bwipp_renmatrix();
    $$.restore();
  } else {
    $k[$j++] = "compsym";
    $k[$j++] = $_.comp;
    $k[$j++] = $_.options;
    bwipp_gs1_cc();
    var _1O = $k[--$j];
    $_[$k[--$j]] = _1O;
    $_.ccpixs = $get($_.compsym, "pixs");
    $_.ccpixx = $get($_.compsym, "pixx");
    $k[$j++] = Infinity;
    $k[$j++] = 0;
    $forall($_.linsbs, function() {
      var _1V = $k[--$j];
      var _1W = $k[$j - 1];
      var _1X = _1W == 0 ? 1 : 0;
      for (var _1Y = 0, _1Z = $cvi(_1V); _1Y < _1Z; _1Y++) {
        $k[$j++] = _1X;
      }
    });
    $_.linpixs = $a();
    $k[$j++] = Infinity;
    $k[$j++] = 0;
    $aload($_.sep);
    $_.sep = $a();
    $_.linheight = ~~$_.linheight;
    $_.diff = $f($_.linpixs.length - $_.ccpixx);
    $k[$j++] = Infinity;
    for (var _1h = 0, _1i = $_.diff - 2; _1h < _1i; _1h++) {
      $k[$j++] = 0;
    }
    $_.ccrpad = $a();
    $k[$j++] = Infinity;
    for (var _1n = 0, _1o = $_.ccpixx, _1m = $_.ccpixs.length - 1; _1o < 0 ? _1n >= _1m : _1n <= _1m; _1n += _1o) {
      $_.i = _1n;
      $k[$j++] = 0;
      $k[$j++] = 0;
      $aload($geti($_.ccpixs, $_.i, $_.ccpixx));
      $aload($_.ccrpad);
    }
    $aload($_.sep);
    for (var _1w = 0, _1x = $_.linheight; _1w < _1x; _1w++) {
      $aload($_.linpixs);
    }
    $_.pixs = $a();
    $_.pixx = $_.linpixs.length;
    $_.pixy = ~~($_.pixs.length / $_.pixx);
    var _29 = /* @__PURE__ */ new Map([
      ["ren", "renmatrix"],
      ["pixs", $_.pixs],
      ["pixx", $_.pixx],
      ["pixy", $_.pixy],
      ["height", $_.pixy / 72],
      ["width", $_.pixx / 72],
      ["opt", $_.options]
    ]);
    $k[$j++] = _29;
    if (!$_.dontdraw) {
      $$.save();
      bwipp_renmatrix();
      $$.restore();
    }
  }
  $_ = $__;
}
function bwipp_databarexpandedstackedcomposite() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.usematrix = false;
  $_.parse = false;
  $_.dontlint = false;
  $_.lintreqs = true;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.dontdraw) {
    $_.usematrix = true;
  }
  $search($_.barcode, "|");
  if ($k[--$j]) {
    $_.linear = $k[--$j];
    $j--;
    $_.comp = $k[--$j];
  } else {
    $j--;
    $k[$j++] = "bwipp.missingCompositeComponent#31106";
    $k[$j++] = "A Composite Component must be provided following a pipe character";
    bwipp_raiseerror();
  }
  if (!$_.usematrix) {
    $$.save();
  }
  $put($_.options, "lintype", "databarexpandedstacked");
  $put($_.options, "linkage", true);
  $put($_.options, "inkspreadv", 0);
  $put($_.options, "dontdraw", true);
  $put($_.options, "dontlint", true);
  var _F = $s($_.linear.length + $_.comp.length);
  $puti(_F, 0, $_.linear);
  $puti(_F, $_.linear.length, $_.comp);
  $k[$j++] = _F;
  $k[$j++] = "ai";
  bwipp_gs1process();
  $j -= 3;
  $k[$j++] = $_.linear;
  $k[$j++] = $_.options;
  bwipp_databarexpandedstacked();
  var _L = $k[--$j];
  $_.bot = $geti($get(_L, "pixs"), 0, $get(_L, "pixx"));
  $_.linheight = $get(_L, "pixy");
  $k[$j++] = _L;
  if (!$_.usematrix) {
    bwipp_renmatrix();
  } else {
    $_.linpixs = $get($k[--$j], "pixs");
  }
  $_.sepfinder = function() {
    $_.fp = $k[--$j];
    for (var _X = $_.fp, _W = $_.fp + 12; _X <= _W; _X += 1) {
      $_.i = _X;
      if ($get($_.bot, $_.i) == 0) {
        if ($get($_.bot, $_.i - 1) == 1) {
          $k[$j++] = 1;
        } else {
          var _h = $get($_.sep, $_.i - 1) == 0 ? 1 : 0;
          $k[$j++] = _h;
        }
      } else {
        $k[$j++] = 0;
      }
      $put($_.sep, $_.i, $k[--$j]);
    }
  };
  $k[$j++] = Infinity;
  var _l = $_.bot;
  for (var _m = 0, _n = _l.length; _m < _n; _m++) {
    $k[$j++] = 1 - $get(_l, _m);
  }
  $_.sep = $a();
  $puti($_.sep, 0, $a([0, 0, 0, 0]));
  $puti($_.sep, $_.sep.length - 4, $a([0, 0, 0, 0]));
  $k[$j++] = Infinity;
  for (var _x = 19, _w = $_.bot.length - 13; _x <= _w; _x += 98) {
    $k[$j++] = _x;
  }
  for (var _10 = 70, _z = $_.bot.length - 13; _10 <= _z; _10 += 98) {
    $k[$j++] = _10;
  }
  var _11 = $a();
  for (var _12 = 0, _13 = _11.length; _12 < _13; _12++) {
    $k[$j++] = $get(_11, _12);
    $_.sepfinder();
  }
  if (!$_.usematrix) {
    var _16 = $$.currpos();
    var _19 = $get($_.bot, 0) == 0 ? 2 : 0;
    $$.rmoveto(_19, $_.linheight + 1);
    $k[$j++] = _16.x;
    $k[$j++] = _16.y;
    $k[$j++] = $_.comp;
    $k[$j++] = $_.options;
    bwipp_gs1_cc();
    bwipp_renmatrix();
    var _1E = $k[--$j];
    $$.moveto($k[--$j], $f(_1E + $_.linheight));
    var _1K = /* @__PURE__ */ new Map([
      ["ren", "renmatrix"],
      ["pixs", $_.sep],
      ["pixx", $_.sep.length],
      ["pixy", 1],
      ["height", 1 / 72],
      ["width", $_.sep.length / 72],
      ["opt", $_.options]
    ]);
    $k[$j++] = _1K;
    bwipp_renmatrix();
    $$.restore();
  } else {
    $k[$j++] = "compsym";
    $k[$j++] = $_.comp;
    $k[$j++] = $_.options;
    bwipp_gs1_cc();
    var _1N = $k[--$j];
    $_[$k[--$j]] = _1N;
    $_.ccpixs = $get($_.compsym, "pixs");
    $_.ccpixx = $get($_.compsym, "pixx");
    $_.pixx = $_.sep.length;
    $k[$j++] = Infinity;
    for (var _1W = 0, _1X = ~~(($f($_.pixx - $_.ccpixx) + 1) / 2); _1W < _1X; _1W++) {
      $k[$j++] = 0;
    }
    $_.cclpad = $a();
    $k[$j++] = Infinity;
    for (var _1b = 0, _1c = ~~($f($_.pixx - $_.ccpixx) / 2); _1b < _1c; _1b++) {
      $k[$j++] = 0;
    }
    $_.ccrpad = $a();
    $k[$j++] = Infinity;
    for (var _1h = 0, _1i = $_.ccpixx, _1g = $_.ccpixs.length - 1; _1i < 0 ? _1h >= _1g : _1h <= _1g; _1h += _1i) {
      $_.i = _1h;
      $aload($_.cclpad);
      $aload($geti($_.ccpixs, $_.i, $_.ccpixx));
      $aload($_.ccrpad);
    }
    $aload($_.sep);
    $aload($_.linpixs);
    $_.pixs = $a();
    $_.pixy = ~~($_.pixs.length / $_.pixx);
    var _20 = /* @__PURE__ */ new Map([
      ["ren", "renmatrix"],
      ["pixs", $_.pixs],
      ["pixx", $_.pixx],
      ["pixy", $_.pixy],
      ["height", $_.pixy / 72],
      ["width", $_.pixx / 72],
      ["opt", $_.options]
    ]);
    $k[$j++] = _20;
    if (!$_.dontdraw) {
      $$.save();
      bwipp_renmatrix();
      $$.restore();
    }
  }
  $_ = $__;
}
function bwipp_gs1_128composite() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.usematrix = false;
  $_.parse = false;
  $_.dontlint = false;
  $_.lintreqs = true;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.dontdraw) {
    $_.usematrix = true;
  }
  $search($_.barcode, "|");
  if ($k[--$j]) {
    $_.linear = $k[--$j];
    $j--;
    $_.comp = $k[--$j];
  } else {
    $j--;
    $k[$j++] = "bwipp.missingCompositeComponent#31259";
    $k[$j++] = "A Composite Component must be provided following a pipe character";
    bwipp_raiseerror();
  }
  if (!$_.usematrix) {
    $$.save();
  }
  $put($_.options, "inkspreadv", 0);
  $put($_.options, "dontdraw", true);
  $put($_.options, "dontlint", true);
  var _D = $s($_.linear.length + $_.comp.length);
  $puti(_D, 0, $_.linear);
  $puti(_D, $_.linear.length, $_.comp);
  $k[$j++] = _D;
  $k[$j++] = "ai";
  bwipp_gs1process();
  $j -= 3;
  $put($_.options, "linkagea", true);
  $k[$j++] = $_.linear;
  $k[$j++] = Infinity;
  $forall($_.options);
  var _K = $d();
  $k[$j++] = _K;
  bwipp_gs1_128();
  var _M = $get($k[--$j], "sbs");
  $k[$j++] = 0;
  $forall(_M, function() {
    var _N = $k[--$j];
    var _O = $k[--$j];
    $k[$j++] = $f(_O + _N);
  });
  $_.linwidth = $k[--$j];
  $put($_.options, "lintype", "gs1-128");
  $put($_.options, "linwidth", $_.linwidth);
  $k[$j++] = $_.comp;
  $k[$j++] = Infinity;
  $forall($_.options);
  var _V = $d();
  $k[$j++] = _V;
  bwipp_gs1_cc();
  $_.compsym = $k[--$j];
  if ($get($_.compsym, "pixx") == 99) {
    $k[$j++] = "a";
  } else {
    $k[$j++] = "c";
  }
  $_.linktype = $k[--$j];
  $put($_.compsym, "borderbottom", 0);
  if ($eq($_.linktype, "a")) {
    $put($_.options, "linkagea", true);
    $put($_.options, "linkagec", false);
  } else {
    $put($_.options, "linkagea", false);
    $put($_.options, "linkagec", true);
  }
  var _g = $_.linear;
  $k[$j++] = _g;
  $k[$j++] = Infinity;
  $forall($_.options);
  var _i = $d();
  $k[$j++] = _i;
  bwipp_gs1_128();
  var _j = $k[--$j];
  $_.linsbs = $get(_j, "sbs");
  $_.linheight = $get($get(_j, "bhs"), 0) * 72;
  $k[$j++] = _j;
  if (!$_.usematrix) {
    bwipp_renlinear();
  } else {
    $j--;
  }
  $k[$j++] = Infinity;
  $k[$j++] = 1;
  $forall($_.linsbs, function() {
    var _p = $k[--$j];
    var _q = $k[$j - 1];
    var _r = _q == 0 ? 1 : 0;
    for (var _s = 0, _t = _p; _s < _t; _s++) {
      $k[$j++] = _r;
    }
  });
  $astore($a($counttomark() - 1));
  $_.sep = $k[--$j];
  $j -= 2;
  if ($eq($_.linktype, "a")) {
    $_.s = ~~(($_.linwidth - 2) / 11);
    $_.p = ~~(($_.s - 9) / 2);
    $k[$j++] = "x";
    $k[$j++] = ($_.s - $_.p - 1) * 11 + 10;
    if ($_.p == 0) {
      var _13 = $k[--$j];
      $k[$j++] = _13 + 2;
    }
    var _14 = $k[--$j];
    $_[$k[--$j]] = _14 - 99;
  } else {
    $_.x = -7;
  }
  if (!$_.usematrix) {
    var _17 = $$.currpos();
    $$.rmoveto($_.x, $_.linheight + 1);
    $k[$j++] = _17.x;
    $k[$j++] = _17.y;
    $k[$j++] = $_.compsym;
    bwipp_renmatrix();
    var _1C = $k[--$j];
    $$.moveto($k[--$j], $f(_1C + $_.linheight));
    var _1I = /* @__PURE__ */ new Map([
      ["ren", "renmatrix"],
      ["pixs", $_.sep],
      ["pixx", $_.sep.length],
      ["pixy", 1],
      ["height", 1 / 72],
      ["width", $_.sep.length / 72],
      ["opt", $_.options]
    ]);
    $k[$j++] = _1I;
    bwipp_renmatrix();
    $$.restore();
  } else {
    $_.ccpixs = $get($_.compsym, "pixs");
    $_.ccpixx = $get($_.compsym, "pixx");
    $k[$j++] = Infinity;
    $forall($_.linsbs, function() {
      var _1O = $k[--$j];
      var _1P = $k[$j - 1];
      var _1Q = _1P == 1 ? 0 : 1;
      for (var _1R = 0, _1S = _1O; _1R < _1S; _1R++) {
        $k[$j++] = _1Q;
      }
    });
    $_.linpixs = $a();
    if ($_.x > 0) {
      $k[$j++] = Infinity;
      for (var _1W = 0, _1X = $_.x; _1W < _1X; _1W++) {
        $k[$j++] = 0;
      }
      $_.cclpad = $a();
      $_.linlpad = $a(0);
    } else {
      $_.cclpad = $a(0);
      $k[$j++] = Infinity;
      for (var _1c = 0, _1d = -$_.x; _1c < _1d; _1c++) {
        $k[$j++] = 0;
      }
      $_.linlpad = $a();
    }
    $_.diff = $f($_.linwidth - ($_.ccpixx + $_.x));
    if ($_.diff > 0) {
      $k[$j++] = Infinity;
      for (var _1k = 0, _1l = $_.diff; _1k < _1l; _1k++) {
        $k[$j++] = 0;
      }
      $_.ccrpad = $a();
      $_.linrpad = $a(0);
    } else {
      $_.ccrpad = $a(0);
      $k[$j++] = Infinity;
      for (var _1q = 0, _1r = -$_.diff; _1q < _1r; _1q++) {
        $k[$j++] = 0;
      }
      $_.linrpad = $a();
    }
    $_.linheight = ~~$_.linheight;
    $k[$j++] = Infinity;
    for (var _1x = 0, _1y = $_.ccpixx, _1w = $_.ccpixs.length - 1; _1y < 0 ? _1x >= _1w : _1x <= _1w; _1x += _1y) {
      $_.i = _1x;
      $aload($_.cclpad);
      $aload($geti($_.ccpixs, $_.i, $_.ccpixx));
      $aload($_.ccrpad);
    }
    $aload($_.linlpad);
    $aload($_.sep);
    $aload($_.linrpad);
    for (var _29 = 0, _2A = $_.linheight; _29 < _2A; _29++) {
      $aload($_.linlpad);
      $aload($_.linpixs);
      $aload($_.linrpad);
    }
    $_.pixs = $a();
    $_.pixx = $f($_.cclpad.length + $_.ccpixx + $_.ccrpad.length);
    $_.pixy = ~~($_.pixs.length / $_.pixx);
    var _2Q = /* @__PURE__ */ new Map([
      ["ren", "renmatrix"],
      ["pixs", $_.pixs],
      ["pixx", $_.pixx],
      ["pixy", $_.pixy],
      ["height", $_.pixy / 72],
      ["width", $_.pixx / 72],
      ["opt", $_.options]
    ]);
    $k[$j++] = _2Q;
    if (!$_.dontdraw) {
      $$.save();
      bwipp_renmatrix();
      $$.restore();
    }
  }
  $_ = $__;
}
function bwipp_gs1datamatrix() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.parse = false;
  $_.dontlint = false;
  $_.lintreqs = true;
  $_.gssep = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $k[$j++] = $_.barcode;
  $k[$j++] = "ai";
  bwipp_gs1process();
  $_.fncs = $k[--$j];
  $_.vals = $k[--$j];
  $_.ais = $k[--$j];
  $_.fnc1 = -1;
  $_.dmtx = $a([$_.fnc1]);
  for (var _A = 0, _9 = $_.ais.length - 1; _A <= _9; _A += 1) {
    $_.i = _A;
    $_.ai = $get($_.ais, $_.i);
    $_.val = $get($_.vals, $_.i);
    var _K = $a($_.dmtx.length + $_.ai.length + $_.val.length);
    $puti(_K, 0, $_.dmtx);
    $k[$j++] = _K;
    $k[$j++] = _K;
    $k[$j++] = $_.dmtx.length;
    var _O = Infinity;
    var _P = $_.ai;
    $k[$j++] = _O;
    $forall(_P);
    var _Q = $a();
    var _R = $k[--$j];
    $puti($k[--$j], _R, _Q);
    var _T = $k[$j - 1];
    $k[$j++] = _T;
    $k[$j++] = $_.dmtx.length + $_.ai.length;
    var _X = Infinity;
    var _Y = $_.val;
    $k[$j++] = _X;
    $forall(_Y);
    var _Z = $a();
    var _a = $k[--$j];
    $puti($k[--$j], _a, _Z);
    $_.dmtx = $k[--$j];
    if ($_.i != $_.ais.length - 1 && $get($_.fncs, $_.i)) {
      var _j = $a($_.dmtx.length + 1);
      $puti(_j, 0, $_.dmtx);
      $k[$j++] = _j;
      $k[$j++] = _j;
      $k[$j++] = $_.dmtx.length;
      if ($_.gssep) {
        $k[$j++] = 29;
      } else {
        $k[$j++] = $_.fnc1;
      }
      var _o = $k[--$j];
      var _p = $k[--$j];
      $put($k[--$j], _p, _o);
      $_.dmtx = $k[--$j];
    }
  }
  $_.barcode = $s(($_.dmtx.length + 1) * 5);
  $_.i = 0;
  $_.j = 0;
  for (; ; ) {
    if ($_.i == $_.dmtx.length) {
      break;
    }
    var _y = $get($_.dmtx, $_.i);
    $k[$j++] = _y;
    if (_y == $_.fnc1) {
      $j--;
      $puti($_.barcode, $_.j, "^FNC1");
      $_.j = $_.j + 4;
    } else {
      $put($_.barcode, $_.j, $k[--$j]);
    }
    $_.i = $_.i + 1;
    $_.j = $_.j + 1;
  }
  $_.barcode = $geti($_.barcode, 0, $_.j);
  delete $_.options["parse"];
  $put($_.options, "dontdraw", true);
  $put($_.options, "parsefnc", true);
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_datamatrix();
  var _1G = $k[--$j];
  $_[$k[--$j]] = _1G;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_gs1datamatrixrectangular() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.parse = false;
  $_.dontlint = false;
  $_.lintreqs = true;
  $_.dontdraw = false;
  $_.gssep = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $k[$j++] = $_.barcode;
  $k[$j++] = "ai";
  bwipp_gs1process();
  $_.fncs = $k[--$j];
  $_.vals = $k[--$j];
  $_.ais = $k[--$j];
  $_.fnc1 = -1;
  $_.dmtx = $a([$_.fnc1]);
  for (var _A = 0, _9 = $_.ais.length - 1; _A <= _9; _A += 1) {
    $_.i = _A;
    $_.ai = $get($_.ais, $_.i);
    $_.val = $get($_.vals, $_.i);
    var _K = $a($_.dmtx.length + $_.ai.length + $_.val.length);
    $puti(_K, 0, $_.dmtx);
    $k[$j++] = _K;
    $k[$j++] = _K;
    $k[$j++] = $_.dmtx.length;
    var _O = Infinity;
    var _P = $_.ai;
    $k[$j++] = _O;
    $forall(_P);
    var _Q = $a();
    var _R = $k[--$j];
    $puti($k[--$j], _R, _Q);
    var _T = $k[$j - 1];
    $k[$j++] = _T;
    $k[$j++] = $_.dmtx.length + $_.ai.length;
    var _X = Infinity;
    var _Y = $_.val;
    $k[$j++] = _X;
    $forall(_Y);
    var _Z = $a();
    var _a = $k[--$j];
    $puti($k[--$j], _a, _Z);
    $_.dmtx = $k[--$j];
    if ($_.i != $_.ais.length - 1 && $get($_.fncs, $_.i)) {
      var _j = $a($_.dmtx.length + 1);
      $puti(_j, 0, $_.dmtx);
      $k[$j++] = _j;
      $k[$j++] = _j;
      $k[$j++] = $_.dmtx.length;
      if ($_.gssep) {
        $k[$j++] = 29;
      } else {
        $k[$j++] = $_.fnc1;
      }
      var _o = $k[--$j];
      var _p = $k[--$j];
      $put($k[--$j], _p, _o);
      $_.dmtx = $k[--$j];
    }
  }
  $_.barcode = $s(($_.dmtx.length + 1) * 5);
  $_.i = 0;
  $_.j = 0;
  for (; ; ) {
    if ($_.i == $_.dmtx.length) {
      break;
    }
    var _y = $get($_.dmtx, $_.i);
    $k[$j++] = _y;
    if (_y == $_.fnc1) {
      $j--;
      $puti($_.barcode, $_.j, "^FNC1");
      $_.j = $_.j + 4;
    } else {
      $put($_.barcode, $_.j, $k[--$j]);
    }
    $_.i = $_.i + 1;
    $_.j = $_.j + 1;
  }
  $_.barcode = $geti($_.barcode, 0, $_.j);
  delete $_.options["parse"];
  $put($_.options, "dontdraw", true);
  $put($_.options, "parsefnc", true);
  $put($_.options, "format", "rectangle");
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_datamatrix();
  var _1H = $k[--$j];
  $_[$k[--$j]] = _1H;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_gs1dldatamatrix() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.parse = false;
  $_.dontlint = false;
  $_.lintreqs = true;
  $_.dontdraw = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  var _3 = /* @__PURE__ */ new Map([
    ["parse", $_.parse],
    ["parseonly", true],
    ["parsefnc", false]
  ]);
  $_.fncvals = _3;
  $k[$j++] = "barcode";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.fncvals;
  bwipp_parseinput();
  var _6 = $k[--$j];
  $_[$k[--$j]] = _6;
  $k[$j++] = $_.barcode;
  $k[$j++] = "dl";
  bwipp_gs1process();
  $j--;
  $_.val = $get($k[--$j], 0);
  $_.key = $get($k[--$j], 0);
  $_.hri = $s($_.key.length + $_.val.length + 2);
  $put($_.hri, 0, 40);
  $puti($_.hri, 1, $_.key);
  $put($_.hri, $_.key.length + 1, 41);
  $puti($_.hri, $_.key.length + 2, $_.val);
  delete $_.options["parse"];
  $put($_.options, "dontdraw", true);
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_datamatrix();
  var _S = $k[--$j];
  $_[$k[--$j]] = _S;
  $put($_.args, "opt", $_.options);
  $put($_.args, "alttext", $_.hri);
  $put($_.args, "textyoffset", -1);
  $put($_.args, "textfont", "OCR-B");
  $put($_.args, "textsize", 5);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_gs1qrcode() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.parse = false;
  $_.dontlint = false;
  $_.lintreqs = true;
  $_.dontdraw = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $k[$j++] = $_.barcode;
  $k[$j++] = "ai";
  bwipp_gs1process();
  $_.fncs = $k[--$j];
  $_.vals = $k[--$j];
  $_.ais = $k[--$j];
  $_.fnc1 = -1;
  $_.qrc = $a([$_.fnc1]);
  for (var _A = 0, _9 = $_.ais.length - 1; _A <= _9; _A += 1) {
    $_.i = _A;
    $_.ai = $get($_.ais, $_.i);
    $_.val = $get($_.vals, $_.i);
    var _K = $a($_.qrc.length + $_.ai.length + $_.val.length);
    $puti(_K, 0, $_.qrc);
    $k[$j++] = _K;
    $k[$j++] = _K;
    $k[$j++] = $_.qrc.length;
    var _O = Infinity;
    var _P = $_.ai;
    $k[$j++] = _O;
    $forall(_P);
    var _Q = $a();
    var _R = $k[--$j];
    $puti($k[--$j], _R, _Q);
    var _T = $k[$j - 1];
    $k[$j++] = _T;
    $k[$j++] = $_.qrc.length + $_.ai.length;
    var _X = Infinity;
    var _Y = $_.val;
    $k[$j++] = _X;
    $forall(_Y);
    var _Z = $a();
    var _a = $k[--$j];
    $puti($k[--$j], _a, _Z);
    $_.qrc = $k[--$j];
    if ($_.i != $_.ais.length - 1 && $get($_.fncs, $_.i)) {
      var _j = $a($_.qrc.length + 1);
      $puti(_j, 0, $_.qrc);
      $put(_j, $_.qrc.length, $_.fnc1);
      $_.qrc = _j;
    }
  }
  $_.barcode = $s(($_.qrc.length + 1) * 5);
  $_.i = 0;
  $_.j = 0;
  for (; ; ) {
    if ($_.i == $_.qrc.length) {
      break;
    }
    var _t = $get($_.qrc, $_.i);
    $k[$j++] = _t;
    if (_t == $_.fnc1) {
      $j--;
      $puti($_.barcode, $_.j, "^FNC1");
      $_.j = $_.j + 4;
    } else {
      $put($_.barcode, $_.j, $k[--$j]);
    }
    $_.i = $_.i + 1;
    $_.j = $_.j + 1;
  }
  $_.barcode = $geti($_.barcode, 0, $_.j);
  delete $_.options["parse"];
  $put($_.options, "dontdraw", true);
  $put($_.options, "parsefnc", true);
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_qrcode();
  var _1B = $k[--$j];
  $_[$k[--$j]] = _1B;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_gs1dlqrcode() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.parse = false;
  $_.dontlint = false;
  $_.lintreqs = true;
  $_.dontdraw = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  var _3 = /* @__PURE__ */ new Map([
    ["parse", $_.parse],
    ["parseonly", true],
    ["parsefnc", false]
  ]);
  $_.fncvals = _3;
  $k[$j++] = "barcode";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.fncvals;
  bwipp_parseinput();
  var _6 = $k[--$j];
  $_[$k[--$j]] = _6;
  $k[$j++] = $_.barcode;
  $k[$j++] = "dl";
  bwipp_gs1process();
  $j--;
  $_.val = $get($k[--$j], 0);
  $_.key = $get($k[--$j], 0);
  $_.hri = $s($_.key.length + $_.val.length + 2);
  $put($_.hri, 0, 40);
  $puti($_.hri, 1, $_.key);
  $put($_.hri, $_.key.length + 1, 41);
  $puti($_.hri, $_.key.length + 2, $_.val);
  delete $_.options["parse"];
  $put($_.options, "dontdraw", true);
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_qrcode();
  var _S = $k[--$j];
  $_[$k[--$j]] = _S;
  $put($_.args, "opt", $_.options);
  $put($_.args, "alttext", $_.hri);
  $put($_.args, "textyoffset", -4);
  $put($_.args, "textfont", "OCR-B");
  $put($_.args, "textsize", 5);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_gs1dotcode() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.parse = false;
  $_.dontlint = false;
  $_.lintreqs = true;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $k[$j++] = $_.barcode;
  $k[$j++] = "ai";
  bwipp_gs1process();
  $_.fncs = $k[--$j];
  $_.vals = $k[--$j];
  $_.ais = $k[--$j];
  $_.fnc1 = -1;
  $_.dmtx = $a([$_.fnc1]);
  for (var _A = 0, _9 = $_.ais.length - 1; _A <= _9; _A += 1) {
    $_.i = _A;
    $_.ai = $get($_.ais, $_.i);
    $_.val = $get($_.vals, $_.i);
    var _K = $a($_.dmtx.length + $_.ai.length + $_.val.length);
    $puti(_K, 0, $_.dmtx);
    $k[$j++] = _K;
    $k[$j++] = _K;
    $k[$j++] = $_.dmtx.length;
    var _O = Infinity;
    var _P = $_.ai;
    $k[$j++] = _O;
    $forall(_P);
    var _Q = $a();
    var _R = $k[--$j];
    $puti($k[--$j], _R, _Q);
    var _T = $k[$j - 1];
    $k[$j++] = _T;
    $k[$j++] = $_.dmtx.length + $_.ai.length;
    var _X = Infinity;
    var _Y = $_.val;
    $k[$j++] = _X;
    $forall(_Y);
    var _Z = $a();
    var _a = $k[--$j];
    $puti($k[--$j], _a, _Z);
    $_.dmtx = $k[--$j];
    if ($_.i != $_.ais.length - 1 && $get($_.fncs, $_.i)) {
      var _j = $a($_.dmtx.length + 1);
      $puti(_j, 0, $_.dmtx);
      $put(_j, $_.dmtx.length, $_.fnc1);
      $_.dmtx = _j;
    }
  }
  $_.barcode = $s(($_.dmtx.length + 1) * 5);
  $_.i = 0;
  $_.j = 0;
  for (; ; ) {
    if ($_.i == $_.dmtx.length) {
      break;
    }
    var _t = $get($_.dmtx, $_.i);
    $k[$j++] = _t;
    if (_t == $_.fnc1) {
      $j--;
      $puti($_.barcode, $_.j, "^FNC1");
      $_.j = $_.j + 4;
    } else {
      $put($_.barcode, $_.j, $k[--$j]);
    }
    $_.i = $_.i + 1;
    $_.j = $_.j + 1;
  }
  $_.barcode = $geti($_.barcode, 0, $_.j);
  delete $_.options["parse"];
  $put($_.options, "dontdraw", true);
  $put($_.options, "parsefnc", true);
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_dotcode();
  var _1B = $k[--$j];
  $_[$k[--$j]] = _1B;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_hibccode39() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.textfont = "OCR-B";
  $_.textsize = 10;
  $_.textyoffset = -8;
  $_.textxoffset = 0;
  $_.validatecheck = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length == 0) {
    $k[$j++] = "bwipp.hibccode39emptyData#31945";
    $k[$j++] = "The data must not be empty";
    bwipp_raiseerror();
  }
  $_.barchars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
  $_.charvals = /* @__PURE__ */ new Map();
  for (var _3 = 0; _3 <= 42; _3 += 1) {
    $put($_.charvals, $geti($_.barchars, _3, 1), _3);
  }
  for (var _A = 0, _9 = $_.barcode.length - 1; _A <= _9; _A += 1) {
    var _E = $get($_.charvals, $geti($_.barcode, _A, 1)) !== void 0;
    if (!_E) {
      $k[$j++] = "bwipp.hibccode39badCharacter#31960";
      $k[$j++] = "HIBC Code 39 must contain only digits, capital letters, spaces and the symbols -.$/+%";
      bwipp_raiseerror();
    }
  }
  $k[$j++] = "barlen";
  $k[$j++] = $_.barcode.length;
  if ($_.validatecheck) {
    var _H = $k[--$j];
    $k[$j++] = _H - 1;
  }
  var _I = $k[--$j];
  $_[$k[--$j]] = _I;
  $_.checksum = 41;
  for (var _M = 0, _L = $_.barlen - 1; _M <= _L; _M += 1) {
    $_.checksum = $f($get($_.charvals, $geti($_.barcode, _M, 1)) + $_.checksum);
  }
  $_.checksum = $_.checksum % 43;
  if ($_.validatecheck) {
    if ($get($_.barcode, $_.barlen) != $get($_.barchars, $_.checksum)) {
      $k[$j++] = "bwipp.hibccode39badCheckDigit#31974";
      $k[$j++] = "Incorrect HIBC Code 39 check digit provided";
      bwipp_raiseerror();
    }
    $_.barcode = $geti($_.barcode, 0, $_.barlen);
  }
  var _e = $s($_.barlen + 2);
  $puti(_e, 1, $_.barcode);
  $_.barcode = _e;
  $put($_.barcode, 0, 43);
  $put($_.barcode, $_.barlen + 1, $get($_.barchars, $_.checksum));
  $_.text = $s($_.barlen + 4);
  $put($_.text, 0, 42);
  $puti($_.text, 1, $_.barcode);
  var _v = $get($_.barcode, $_.barlen + 1);
  $k[$j++] = $_.text;
  $k[$j++] = $_.barlen + 2;
  $k[$j++] = _v;
  if (_v == 32) {
    $k[$j - 1] = 95;
  }
  var _w = $k[--$j];
  var _x = $k[--$j];
  $put($k[--$j], _x, _w);
  $put($_.text, $_.barlen + 3, 42);
  $put($_.options, "dontdraw", true);
  $put($_.options, "includecheck", false);
  $put($_.options, "validatecheck", false);
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_code39();
  var _16 = $k[--$j];
  $_[$k[--$j]] = _16;
  $put($_.args, "txt", $a([$a([$_.text, $_.textxoffset, $_.textyoffset, $_.textfont, $_.textsize])]));
  $put($_.args, "textxalign", "center");
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_hibccode128() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.textfont = "OCR-B";
  $_.textsize = 10;
  $_.textyoffset = -8;
  $_.textxoffset = 0;
  $_.validatecheck = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length == 0) {
    $k[$j++] = "bwipp.hibccode128emptyData#32049";
    $k[$j++] = "The data must not be empty";
    bwipp_raiseerror();
  }
  $_.barchars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
  $_.charvals = /* @__PURE__ */ new Map();
  for (var _3 = 0; _3 <= 42; _3 += 1) {
    $put($_.charvals, $geti($_.barchars, _3, 1), _3);
  }
  for (var _A = 0, _9 = $_.barcode.length - 1; _A <= _9; _A += 1) {
    var _E = $get($_.charvals, $geti($_.barcode, _A, 1)) !== void 0;
    if (!_E) {
      $k[$j++] = "bwipp.hibccode128badCharacter#32064";
      $k[$j++] = "HIBC Code 128 must contain only digits, capital letters, spaces and the symbols -.$/+%";
      bwipp_raiseerror();
    }
  }
  $k[$j++] = "barlen";
  $k[$j++] = $_.barcode.length;
  if ($_.validatecheck) {
    var _H = $k[--$j];
    $k[$j++] = _H - 1;
  }
  var _I = $k[--$j];
  $_[$k[--$j]] = _I;
  $_.checksum = 41;
  for (var _M = 0, _L = $_.barlen - 1; _M <= _L; _M += 1) {
    $_.checksum = $f($get($_.charvals, $geti($_.barcode, _M, 1)) + $_.checksum);
  }
  $_.checksum = $_.checksum % 43;
  if ($_.validatecheck) {
    if ($get($_.barcode, $_.barlen) != $get($_.barchars, $_.checksum)) {
      $k[$j++] = "bwipp.hibccode128badCheckDigit#32078";
      $k[$j++] = "Incorrect HIBC Code 128 check digit provided";
      bwipp_raiseerror();
    }
    $_.barcode = $geti($_.barcode, 0, $_.barlen);
  }
  var _e = $s($_.barlen + 2);
  $puti(_e, 1, $_.barcode);
  $_.barcode = _e;
  $put($_.barcode, 0, 43);
  $put($_.barcode, $_.barlen + 1, $get($_.barchars, $_.checksum));
  $_.text = $s($_.barlen + 4);
  $put($_.text, 0, 42);
  $puti($_.text, 1, $_.barcode);
  var _v = $get($_.barcode, $_.barlen + 1);
  $k[$j++] = $_.text;
  $k[$j++] = $_.barlen + 2;
  $k[$j++] = _v;
  if (_v == 32) {
    $k[$j - 1] = 95;
  }
  var _w = $k[--$j];
  var _x = $k[--$j];
  $put($k[--$j], _x, _w);
  $put($_.text, $_.barlen + 3, 42);
  $put($_.options, "dontdraw", true);
  $put($_.options, "validatecheck", false);
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_code128();
  var _15 = $k[--$j];
  $_[$k[--$j]] = _15;
  $put($_.args, "txt", $a([$a([$_.text, $_.textxoffset, $_.textyoffset, $_.textfont, $_.textsize])]));
  $put($_.args, "textxalign", "center");
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_hibcdatamatrix() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.validatecheck = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length == 0) {
    $k[$j++] = "bwipp.hibcdatamatrixEmptyData#32148";
    $k[$j++] = "The data must not be empty";
    bwipp_raiseerror();
  }
  $_.barchars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
  $_.charvals = /* @__PURE__ */ new Map();
  for (var _3 = 0; _3 <= 42; _3 += 1) {
    $put($_.charvals, $geti($_.barchars, _3, 1), _3);
  }
  for (var _A = 0, _9 = $_.barcode.length - 1; _A <= _9; _A += 1) {
    var _E = $get($_.charvals, $geti($_.barcode, _A, 1)) !== void 0;
    if (!_E) {
      $k[$j++] = "bwipp.hibcdatamatrixBadCharacter#32163";
      $k[$j++] = "HIBC Data Matrix must contain only digits, capital letters, spaces and the symbols -.$/+%";
      bwipp_raiseerror();
    }
  }
  $k[$j++] = "barlen";
  $k[$j++] = $_.barcode.length;
  if ($_.validatecheck) {
    var _H = $k[--$j];
    $k[$j++] = _H - 1;
  }
  var _I = $k[--$j];
  $_[$k[--$j]] = _I;
  $_.checksum = 41;
  for (var _M = 0, _L = $_.barlen - 1; _M <= _L; _M += 1) {
    $_.checksum = $f($get($_.charvals, $geti($_.barcode, _M, 1)) + $_.checksum);
  }
  $_.checksum = $_.checksum % 43;
  if ($_.validatecheck) {
    if ($get($_.barcode, $_.barlen) != $get($_.barchars, $_.checksum)) {
      $k[$j++] = "bwipp.hibcdatamatrixBadCheckDigit#32177";
      $k[$j++] = "Incorrect HIBC Data Matrix check digit provided";
      bwipp_raiseerror();
    }
    $_.barcode = $geti($_.barcode, 0, $_.barlen);
  }
  var _d = $_.barlen;
  var _e = $s(_d + 2);
  $puti(_e, 1, $_.barcode);
  $_.barcode = _e;
  $put($_.barcode, 0, 43);
  $put($_.barcode, $_.barlen + 1, $get($_.barchars, $_.checksum));
  $put($_.options, "dontdraw", true);
  $put($_.options, "validatecheck", false);
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_datamatrix();
  var _q = $k[--$j];
  var _r = $k[--$j];
  $_[_r] = _q;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_hibcdatamatrixrectangular() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.validatecheck = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length == 0) {
    $k[$j++] = "bwipp.hibcdatamatrixrectangularEmptyData#32239";
    $k[$j++] = "The data must not be empty";
    bwipp_raiseerror();
  }
  $_.barchars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
  $_.charvals = /* @__PURE__ */ new Map();
  for (var _3 = 0; _3 <= 42; _3 += 1) {
    $put($_.charvals, $geti($_.barchars, _3, 1), _3);
  }
  for (var _A = 0, _9 = $_.barcode.length - 1; _A <= _9; _A += 1) {
    var _E = $get($_.charvals, $geti($_.barcode, _A, 1)) !== void 0;
    if (!_E) {
      $k[$j++] = "bwipp.hibcdatamatrixrectangularBadCharacter#32254";
      $k[$j++] = "HIBC Data Matrix Rectangular must contain only digits, capital letters, spaces and the symbols -.$/+%";
      bwipp_raiseerror();
    }
  }
  $k[$j++] = "barlen";
  $k[$j++] = $_.barcode.length;
  if ($_.validatecheck) {
    var _H = $k[--$j];
    $k[$j++] = _H - 1;
  }
  var _I = $k[--$j];
  $_[$k[--$j]] = _I;
  $_.checksum = 41;
  for (var _M = 0, _L = $_.barlen - 1; _M <= _L; _M += 1) {
    $_.checksum = $f($get($_.charvals, $geti($_.barcode, _M, 1)) + $_.checksum);
  }
  $_.checksum = $_.checksum % 43;
  if ($_.validatecheck) {
    if ($get($_.barcode, $_.barlen) != $get($_.barchars, $_.checksum)) {
      $k[$j++] = "bwipp.hibcdatamatrixrectangularBadCheckDigit#32268";
      $k[$j++] = "Incorrect HIBC Data Matrix Rectangular check digit provided";
      bwipp_raiseerror();
    }
    $_.barcode = $geti($_.barcode, 0, $_.barlen);
  }
  var _d = $_.barlen;
  var _e = $s(_d + 2);
  $puti(_e, 1, $_.barcode);
  $_.barcode = _e;
  $put($_.barcode, 0, 43);
  $put($_.barcode, $_.barlen + 1, $get($_.barchars, $_.checksum));
  $put($_.options, "dontdraw", true);
  $put($_.options, "validatecheck", false);
  $put($_.options, "format", "rectangle");
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_datamatrix();
  var _r = $k[--$j];
  $_[$k[--$j]] = _r;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_hibcpdf417() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.columns = 2;
  $_.validatecheck = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length == 0) {
    $k[$j++] = "bwipp.hibcpdf417EmptyData#32332";
    $k[$j++] = "The data must not be empty";
    bwipp_raiseerror();
  }
  $_.barchars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
  $_.charvals = /* @__PURE__ */ new Map();
  for (var _3 = 0; _3 <= 42; _3 += 1) {
    $put($_.charvals, $geti($_.barchars, _3, 1), _3);
  }
  for (var _A = 0, _9 = $_.barcode.length - 1; _A <= _9; _A += 1) {
    var _E = $get($_.charvals, $geti($_.barcode, _A, 1)) !== void 0;
    if (!_E) {
      $k[$j++] = "bwipp.hibcpdf417BadCharacter#32347";
      $k[$j++] = "HIBC PDF417 must contain only digits, capital letters, spaces and the symbols -.$/+%";
      bwipp_raiseerror();
    }
  }
  $k[$j++] = "barlen";
  $k[$j++] = $_.barcode.length;
  if ($_.validatecheck) {
    var _H = $k[--$j];
    $k[$j++] = _H - 1;
  }
  var _I = $k[--$j];
  $_[$k[--$j]] = _I;
  $_.checksum = 41;
  for (var _M = 0, _L = $_.barlen - 1; _M <= _L; _M += 1) {
    $_.checksum = $f($get($_.charvals, $geti($_.barcode, _M, 1)) + $_.checksum);
  }
  $_.checksum = $_.checksum % 43;
  if ($_.validatecheck) {
    if ($get($_.barcode, $_.barlen) != $get($_.barchars, $_.checksum)) {
      $k[$j++] = "bwipp.hibcpdf417BadCheckDigit#32361";
      $k[$j++] = "Incorrect HIBC PDF417 check digit provided";
      bwipp_raiseerror();
    }
    $_.barcode = $geti($_.barcode, 0, $_.barlen);
  }
  var _e = $s($_.barlen + 2);
  $puti(_e, 1, $_.barcode);
  $_.barcode = _e;
  $put($_.barcode, 0, 43);
  $put($_.barcode, $_.barlen + 1, $get($_.barchars, $_.checksum));
  $put($_.options, "dontdraw", true);
  $put($_.options, "columns", $_.columns);
  var _p = $_.options;
  $put(_p, "validatecheck", false);
  var _r = $_.options;
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = _r;
  bwipp_pdf417();
  var _s = $k[--$j];
  $_[$k[--$j]] = _s;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_hibcmicropdf417() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.columns = 2;
  $_.validatecheck = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length == 0) {
    $k[$j++] = "bwipp.hibcmicropdf417EmptyData#32425";
    $k[$j++] = "The data must not be empty";
    bwipp_raiseerror();
  }
  $_.barchars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
  $_.charvals = /* @__PURE__ */ new Map();
  for (var _3 = 0; _3 <= 42; _3 += 1) {
    $put($_.charvals, $geti($_.barchars, _3, 1), _3);
  }
  for (var _A = 0, _9 = $_.barcode.length - 1; _A <= _9; _A += 1) {
    var _E = $get($_.charvals, $geti($_.barcode, _A, 1)) !== void 0;
    if (!_E) {
      $k[$j++] = "bwipp.hibcmicropdf417BadCharacter#32440";
      $k[$j++] = "HIBC MicroPDF417 must contain only digits, capital letters, spaces and the symbols -.$/+%";
      bwipp_raiseerror();
    }
  }
  $k[$j++] = "barlen";
  $k[$j++] = $_.barcode.length;
  if ($_.validatecheck) {
    var _H = $k[--$j];
    $k[$j++] = _H - 1;
  }
  var _I = $k[--$j];
  $_[$k[--$j]] = _I;
  $_.checksum = 41;
  for (var _M = 0, _L = $_.barlen - 1; _M <= _L; _M += 1) {
    $_.checksum = $f($get($_.charvals, $geti($_.barcode, _M, 1)) + $_.checksum);
  }
  $_.checksum = $_.checksum % 43;
  if ($_.validatecheck) {
    if ($get($_.barcode, $_.barlen) != $get($_.barchars, $_.checksum)) {
      $k[$j++] = "bwipp.hibcmicropdf417BadCheckDigit#32454";
      $k[$j++] = "Incorrect HIBC MicroPDF417 check digit provided";
      bwipp_raiseerror();
    }
    $_.barcode = $geti($_.barcode, 0, $_.barlen);
  }
  var _e = $s($_.barlen + 2);
  $puti(_e, 1, $_.barcode);
  $_.barcode = _e;
  $put($_.barcode, 0, 43);
  $put($_.barcode, $_.barlen + 1, $get($_.barchars, $_.checksum));
  var _m = $_.options;
  $put(_m, "dontdraw", true);
  $put($_.options, "columns", $_.columns);
  $put($_.options, "validatecheck", false);
  var _r = $_.options;
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = _r;
  bwipp_micropdf417();
  var _s = $k[--$j];
  $_[$k[--$j]] = _s;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_hibcqrcode() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.validatecheck = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length == 0) {
    $k[$j++] = "bwipp.hibcqrcodeEmptyData#32517";
    $k[$j++] = "The data must not be empty";
    bwipp_raiseerror();
  }
  $_.barchars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
  $_.charvals = /* @__PURE__ */ new Map();
  for (var _3 = 0; _3 <= 42; _3 += 1) {
    $put($_.charvals, $geti($_.barchars, _3, 1), _3);
  }
  for (var _A = 0, _9 = $_.barcode.length - 1; _A <= _9; _A += 1) {
    var _E = $get($_.charvals, $geti($_.barcode, _A, 1)) !== void 0;
    if (!_E) {
      $k[$j++] = "bwipp.hibcqrcodeBadCharacter#32532";
      $k[$j++] = "HIBC QR Code must contain only digits, capital letters, spaces and the symbols -.$/+%";
      bwipp_raiseerror();
    }
  }
  $k[$j++] = "barlen";
  $k[$j++] = $_.barcode.length;
  if ($_.validatecheck) {
    var _H = $k[--$j];
    $k[$j++] = _H - 1;
  }
  var _I = $k[--$j];
  $_[$k[--$j]] = _I;
  $_.checksum = 41;
  for (var _M = 0, _L = $_.barlen - 1; _M <= _L; _M += 1) {
    $_.checksum = $f($get($_.charvals, $geti($_.barcode, _M, 1)) + $_.checksum);
  }
  $_.checksum = $_.checksum % 43;
  if ($_.validatecheck) {
    if ($get($_.barcode, $_.barlen) != $get($_.barchars, $_.checksum)) {
      $k[$j++] = "bwipp.hibcqrcodeBadCheckDigit#32546";
      $k[$j++] = "Incorrect HIBC QR Code check digit provided";
      bwipp_raiseerror();
    }
    $_.barcode = $geti($_.barcode, 0, $_.barlen);
  }
  var _e = $s($_.barlen + 2);
  $puti(_e, 1, $_.barcode);
  $_.barcode = _e;
  $put($_.barcode, 0, 43);
  $put($_.barcode, $_.barlen + 1, $get($_.barchars, $_.checksum));
  $put($_.options, "dontdraw", true);
  $put($_.options, "validatecheck", false);
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_qrcode();
  var _q = $k[--$j];
  var _r = $k[--$j];
  $_[_r] = _q;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_hibccodablockf() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.validatecheck = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length == 0) {
    $k[$j++] = "bwipp.hibccodablockfEmptyData#32608";
    $k[$j++] = "The data must not be empty";
    bwipp_raiseerror();
  }
  $_.barchars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
  $_.charvals = /* @__PURE__ */ new Map();
  for (var _3 = 0; _3 <= 42; _3 += 1) {
    $put($_.charvals, $geti($_.barchars, _3, 1), _3);
  }
  for (var _A = 0, _9 = $_.barcode.length - 1; _A <= _9; _A += 1) {
    var _E = $get($_.charvals, $geti($_.barcode, _A, 1)) !== void 0;
    if (!_E) {
      $k[$j++] = "bwipp.hibccodablockfBadCharacter#32623";
      $k[$j++] = "HIBC Codablock F must contain only digits, capital letters, spaces and the symbols -.$/+%";
      bwipp_raiseerror();
    }
  }
  $k[$j++] = "barlen";
  $k[$j++] = $_.barcode.length;
  if ($_.validatecheck) {
    var _H = $k[--$j];
    $k[$j++] = _H - 1;
  }
  var _I = $k[--$j];
  $_[$k[--$j]] = _I;
  $_.checksum = 41;
  for (var _M = 0, _L = $_.barlen - 1; _M <= _L; _M += 1) {
    $_.checksum = $f($get($_.charvals, $geti($_.barcode, _M, 1)) + $_.checksum);
  }
  $_.checksum = $_.checksum % 43;
  if ($_.validatecheck) {
    if ($get($_.barcode, $_.barlen) != $get($_.barchars, $_.checksum)) {
      $k[$j++] = "bwipp.hibccodablockfBadCheckDigit#32637";
      $k[$j++] = "Incorrect HIBC Codablock F check digit provided";
      bwipp_raiseerror();
    }
    $_.barcode = $geti($_.barcode, 0, $_.barlen);
  }
  var _e = $s($_.barlen + 2);
  $puti(_e, 1, $_.barcode);
  $_.barcode = _e;
  $put($_.barcode, 0, 43);
  $put($_.barcode, $_.barlen + 1, $get($_.barchars, $_.checksum));
  $put($_.options, "dontdraw", true);
  $put($_.options, "validatecheck", false);
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_codablockf();
  var _q = $k[--$j];
  var _r = $k[--$j];
  $_[_r] = _q;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_hibcazteccode() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.dontdraw = false;
  $_.validatecheck = false;
  $k[$j++] = $_;
  bwipp_processoptions();
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  if ($_.barcode.length == 0) {
    $k[$j++] = "bwipp.hibcazteccodeEmptyData#32699";
    $k[$j++] = "The data must not be empty";
    bwipp_raiseerror();
  }
  $_.barchars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
  $_.charvals = /* @__PURE__ */ new Map();
  for (var _3 = 0; _3 <= 42; _3 += 1) {
    $put($_.charvals, $geti($_.barchars, _3, 1), _3);
  }
  for (var _A = 0, _9 = $_.barcode.length - 1; _A <= _9; _A += 1) {
    var _E = $get($_.charvals, $geti($_.barcode, _A, 1)) !== void 0;
    if (!_E) {
      $k[$j++] = "bwipp.hibcazteccodeBadCharacter#32714";
      $k[$j++] = "HIBC Aztec Code must contain only digits, capital letters, spaces and the symbols -.$/+%";
      bwipp_raiseerror();
    }
  }
  $k[$j++] = "barlen";
  $k[$j++] = $_.barcode.length;
  if ($_.validatecheck) {
    var _H = $k[--$j];
    $k[$j++] = _H - 1;
  }
  var _I = $k[--$j];
  $_[$k[--$j]] = _I;
  $_.checksum = 41;
  for (var _M = 0, _L = $_.barlen - 1; _M <= _L; _M += 1) {
    $_.checksum = $f($get($_.charvals, $geti($_.barcode, _M, 1)) + $_.checksum);
  }
  $_.checksum = $_.checksum % 43;
  if ($_.validatecheck) {
    if ($get($_.barcode, $_.barlen) != $get($_.barchars, $_.checksum)) {
      $k[$j++] = "bwipp.hibcazteccodeBadCheckDigit#32728";
      $k[$j++] = "Incorrect HIBC Aztec Code check digit provided";
      bwipp_raiseerror();
    }
    $_.barcode = $geti($_.barcode, 0, $_.barlen);
  }
  var _e = $s($_.barlen + 2);
  $puti(_e, 1, $_.barcode);
  $_.barcode = _e;
  $put($_.barcode, 0, 43);
  $put($_.barcode, $_.barlen + 1, $get($_.barchars, $_.checksum));
  $put($_.options, "dontdraw", true);
  $put($_.options, "validatecheck", false);
  $k[$j++] = "args";
  $k[$j++] = $_.barcode;
  $k[$j++] = $_.options;
  bwipp_azteccode();
  var _q = $k[--$j];
  var _r = $k[--$j];
  $_[_r] = _q;
  $put($_.args, "opt", $_.options);
  $k[$j++] = $_.args;
  if (!$_.dontdraw) {
    bwipp_renmatrix();
  }
  $_ = $__;
}
function bwipp_channelcode() {
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.options = $k[--$j];
  $_.barcode = $k[--$j];
  $_.dontdraw = false;
  $_.shortfinder = false;
  $_.includetext = false;
  $_.includecheck = false;
  $_.height = 1;
  $forall($_.options, function() {
    var _3 = $k[--$j];
    $_[$k[--$j]] = _3;
  });
  $_.height = +$_.height;
  if ($_.barcode.length < 2 || $_.barcode.length > 7) {
    $k[$j++] = "bwipp.channelcodeBadLength#32803";
    $k[$j++] = "Channel Code must be 2 to 7 digits";
    bwipp_raiseerror();
  }
  $forall($_.barcode, function() {
    var _9 = $k[--$j];
    if (_9 < 48 || _9 > 57) {
      $k[$j++] = "bwipp.channelcodeBadCharacter#32807";
      $k[$j++] = "Channel Code must contain only digits";
      bwipp_raiseerror();
    }
  });
  if ($cvi($_.barcode) > $get($a([26, 292, 3493, 44072, 576688, 7742862]), $_.barcode.length - 2)) {
    $k[$j++] = "bwipp.channelcodeTooBig#32811";
    $k[$j++] = "The Channel Code value is too big for the number of channels";
    bwipp_raiseerror();
  }
  $_.nextb = function() {
    var _E = $k[$j - 1];
    var _N = $f($get($_.s, _E) + ($get($_.b, _E - 1) + ($get($_.b, _E - 2) + $get($_.s, _E - 1)))) > 4 ? 1 : 2;
    $k[$j++] = _N;
    if (_E < $_.chan + 2) {
      var _P = $k[$j - 1];
      var _R = $k[$j - 3];
      for (var _T = _P, _S = _R; _T <= _S; _T += 1) {
        var _W = $k[$j - 2];
        $put($_.b, _W, _T);
        var _X = $k[$j - 3];
        var _Y = $k[$j - 4];
        $k[$j++] = $f(_X - _T) + 1;
        $k[$j++] = _Y;
        $k[$j++] = _W + 1;
        $_.nexts();
      }
    } else {
      var _Z = $k[$j - 1];
      var _b = $k[$j - 3];
      if ($le(_Z, _b)) {
        var _e = $k[$j - 2];
        var _f = $k[$j - 3];
        $put($_.b, _e, _f);
        if ($_.value == $_.target) {
          $k[$j++] = Infinity;
          for (var _i = 3; _i <= 10; _i += 1) {
            $k[$j++] = $get($_.s, _i);
            $k[$j++] = $get($_.b, _i);
          }
          $_.out = $geti($a(), 0, $_.chan * 2);
        }
        $_.value = $_.value + 1;
      }
    }
    $j -= 4;
  };
  $_.nexts = function() {
    var _r = $k[$j - 1];
    if (_r < $_.chan + 2) {
      $k[$j++] = 1;
    } else {
      var _u = $k[$j - 2];
      $k[$j++] = _u;
    }
    var _v = $k[--$j];
    var _x = $k[$j - 2];
    for (var _z = _v, _y = _x; _z <= _y; _z += 1) {
      var _11 = $k[$j - 1];
      $put($_.s, _11, _z);
      var _12 = $k[$j - 2];
      var _13 = $k[$j - 3];
      $k[$j++] = $f(_12 - _z) + 1;
      $k[$j++] = _13;
      $k[$j++] = _11;
      $_.nextb();
    }
    $j -= 3;
  };
  $_.encode = function() {
    $_.chan = $k[--$j];
    $_.target = $k[--$j];
    $_.value = 0;
    $_.out = -1;
    $_.b = $a([1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]);
    $_.s = $a([0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]);
    var _18 = $_.chan;
    $k[$j++] = _18;
    $k[$j++] = _18;
    $k[$j++] = 3;
    $_.nexts();
    $k[$j++] = $_.out;
  };
  $_.barlen = $_.barcode.length;
  $k[$j++] = "finder";
  if ($_.shortfinder) {
    $k[$j++] = $a([1, 1, 1, 1, 1]);
  } else {
    $k[$j++] = $a([1, 1, 1, 1, 1, 1, 1, 1, 1]);
  }
  var _1E = $k[--$j];
  $_[$k[--$j]] = _1E;
  $k[$j++] = "data";
  $k[$j++] = $cvi($_.barcode);
  $k[$j++] = $_.barlen + 1;
  $_.encode();
  var _1I = $k[--$j];
  $_[$k[--$j]] = _1I;
  $_.check = $a([]);
  if ($_.includecheck) {
    $_.mod23 = $get($a([$a([]), $a([]), $a([13, 12, 4, 9, 3, 1]), $a([13, 2, 12, 3, 18, 16, 4, 1]), $a([11, 16, 17, 8, 20, 4, 10, 2, 5, 1]), $a([1, 4, 16, 18, 3, 12, 2, 8, 9, 13, 6, 1]), $a([20, 16, 22, 13, 15, 12, 5, 4, 8, 9, 21, 3, 7, 1]), $a([2, 6, 18, 8, 1, 3, 9, 4, 12, 13, 16, 2, 6, 18, 8, 1])]), $_.barlen);
    $k[$j++] = 0;
    for (var _1Z = 0, _1Y = $_.data.length - 1; _1Z <= _1Y; _1Z += 1) {
      var _1e = $k[--$j];
      $k[$j++] = $f(_1e + ($get($_.data, _1Z) - 1) * $get($_.mod23, _1Z));
    }
    var _1f = $k[--$j];
    $k[$j++] = _1f % 23;
    $k[$j++] = 3;
    $_.encode();
    $_.check = $k[--$j];
  }
  $k[$j++] = Infinity;
  $aload($_.finder);
  $aload($_.data);
  $aload($_.check);
  $_.sbs = $a();
  $_.txt = $a($_.barlen);
  for (var _1p = 0, _1o = $_.barlen - 1; _1p <= _1o; _1p += 1) {
    $_.i = _1p;
    $put($_.txt, $_.i, $a([$geti($_.barcode, $_.i, 1), 0, 0, "", 0]));
  }
  $k[$j++] = Infinity;
  var _1w = $_.sbs;
  $k[$j++] = Infinity;
  for (var _1y = 0, _1z = ~~(($_.sbs.length + 1) / 2); _1y < _1z; _1y++) {
    $k[$j++] = $_.height;
  }
  var _21 = $a();
  $k[$j++] = Infinity;
  for (var _23 = 0, _24 = ~~(($_.sbs.length + 1) / 2); _23 < _24; _23++) {
    $k[$j++] = 0;
  }
  var _25 = $a();
  $k[$j++] = "ren";
  $k[$j++] = bwipp_renlinear;
  $k[$j++] = "sbs";
  $k[$j++] = _1w;
  $k[$j++] = "bhs";
  $k[$j++] = _21;
  $k[$j++] = "bbs";
  $k[$j++] = _25;
  $k[$j++] = "txt";
  $k[$j++] = $_.txt;
  $k[$j++] = "textxalign";
  $k[$j++] = "center";
  $k[$j++] = "opt";
  $k[$j++] = $_.options;
  var _28 = $d();
  $k[$j++] = _28;
  if (!$_.dontdraw) {
    bwipp_renlinear();
  }
  $_ = $__;
}
function bwipp_renlinear() {
  if ($_.bwipjs_rawstack) {
    $_.bwipjs_rawstack.push($k[--$j]);
    return;
  }
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.sbs = $a([]);
  $_.bhs = $a([]);
  $_.bbs = $a([]);
  $_.txt = $a([]);
  $_.barcolor = "unset";
  $_.includetext = false;
  $_.textcolor = "unset";
  $_.textxalign = "unset";
  $_.textyalign = "unset";
  $_.textfont = "OCR-B";
  $_.textdirection = "forward";
  $_.textsize = 10;
  $_.textxoffset = 0;
  $_.textyoffset = 0;
  $_.textgaps = 0;
  $_.textlinegaps = 1.2;
  $_.alttext = "";
  $_.alttextsplit = "";
  $_.alttextsubspace = "";
  $_.extratext = "";
  $_.extratextsubspace = "";
  $_.extratextsplit = "";
  $_.extratextlinegaps = 1.2;
  $_.extratextcolor = "unset";
  $_.extratextxalign = "left";
  $_.extratextyalign = "above";
  $_.extratextfont = "OCR-B";
  $_.extratextdirection = "forward";
  $_.extratextsize = 10;
  $_.extratextxoffset = 0;
  $_.extratextyoffset = 0;
  $_.extratextgaps = 0;
  $_.bordercolor = "unset";
  $_.inkspread = 0;
  $_.width = 0;
  $_.barratio = 1;
  $_.spaceratio = 1;
  $_.showborder = false;
  $_.showbearer = false;
  $_.borderleft = 10;
  $_.borderright = 10;
  $_.bordertop = 1;
  $_.borderbottom = 1;
  $_.borderwidth = 0.5;
  $_.guardwhitespace = false;
  $_.guardleftpos = 0;
  $_.guardleftypos = 0;
  $_.guardrightpos = 0;
  $_.guardrightypos = 0;
  $_.guardwidth = 7;
  $_.guardheight = 7;
  $forall($k[--$j], function() {
    var _5 = $k[--$j];
    $_[$k[--$j]] = _5;
  });
  $k[$j++] = $_.opt;
  delete $_["opt"];
  $k[$j++] = $_;
  bwipp_processoptions();
  $j--;
  if ($ne($_.textxalign, "unset")) {
    $k[$j++] = Infinity;
    var _9 = "offleft";
    var _A = "left";
    var _B = "center";
    var _C = "right";
    var _D = "offright";
    $k[$j++] = _9;
    $k[$j++] = _9;
    $k[$j++] = _A;
    $k[$j++] = _A;
    $k[$j++] = _B;
    $k[$j++] = _B;
    $k[$j++] = _C;
    $k[$j++] = _C;
    $k[$j++] = _D;
    $k[$j++] = _D;
    var _G = $get($d(), $_.textxalign) !== void 0;
    if (!_G) {
      $k[$j++] = "bwipp.renmatrixBadTextxalign#33005";
      $k[$j++] = "textxalign must be offleft, left, center, right or offright";
      bwipp_raiseerror();
    }
  }
  if ($ne($_.textyalign, "unset")) {
    $k[$j++] = Infinity;
    var _I = "above";
    var _J = "top";
    var _K = "center";
    var _L = "bottom";
    var _M = "below";
    $k[$j++] = _I;
    $k[$j++] = _I;
    $k[$j++] = _J;
    $k[$j++] = _J;
    $k[$j++] = _K;
    $k[$j++] = _K;
    $k[$j++] = _L;
    $k[$j++] = _L;
    $k[$j++] = _M;
    $k[$j++] = _M;
    var _P = $get($d(), $_.textyalign) !== void 0;
    if (!_P) {
      $k[$j++] = "bwipp.renmatrixBadTextyalign#33011";
      $k[$j++] = "textyalign must be above, top, center, bottom or below";
      bwipp_raiseerror();
    }
  }
  $k[$j++] = Infinity;
  var _Q = "forward";
  var _R = "backward";
  var _S = "upward";
  var _T = "downward";
  $k[$j++] = _Q;
  $k[$j++] = _Q;
  $k[$j++] = _R;
  $k[$j++] = _R;
  $k[$j++] = _S;
  $k[$j++] = _S;
  $k[$j++] = _T;
  $k[$j++] = _T;
  var _W = $get($d(), $_.textdirection) !== void 0;
  if (!_W) {
    $k[$j++] = "bwipp.renmatrixBadTextdirection#33016";
    $k[$j++] = "textdirection must be forward, backward, upward or downward";
    bwipp_raiseerror();
  }
  if ($_.textsize <= 0 || $_.textsize >= 25) {
    $k[$j++] = "bwipp.renmatrixBadTextsize#33020";
    $k[$j++] = "textsize must be greater than zero and less that 25";
    bwipp_raiseerror();
  }
  $k[$j++] = Infinity;
  var _Z = "offleft";
  var _a = "left";
  var _b = "center";
  var _c = "right";
  var _d = "offright";
  $k[$j++] = _Z;
  $k[$j++] = _Z;
  $k[$j++] = _a;
  $k[$j++] = _a;
  $k[$j++] = _b;
  $k[$j++] = _b;
  $k[$j++] = _c;
  $k[$j++] = _c;
  $k[$j++] = _d;
  $k[$j++] = _d;
  var _g = $get($d(), $_.extratextxalign) !== void 0;
  if (!_g) {
    $k[$j++] = "bwipp.renmatrixBadExtratextxalign#33024";
    $k[$j++] = "extratextxalign must be offleft, left, center, right or offright";
    bwipp_raiseerror();
  }
  $k[$j++] = Infinity;
  var _h = "above";
  var _i = "top";
  var _j = "center";
  var _k = "bottom";
  var _l = "below";
  $k[$j++] = _h;
  $k[$j++] = _h;
  $k[$j++] = _i;
  $k[$j++] = _i;
  $k[$j++] = _j;
  $k[$j++] = _j;
  $k[$j++] = _k;
  $k[$j++] = _k;
  $k[$j++] = _l;
  $k[$j++] = _l;
  var _o = $get($d(), $_.extratextyalign) !== void 0;
  if (!_o) {
    $k[$j++] = "bwipp.renmatrixBadExtratextyalign#33028";
    $k[$j++] = "extratextyalign must be above, top, center, bottom or below";
    bwipp_raiseerror();
  }
  $k[$j++] = Infinity;
  var _p = "forward";
  var _q = "backward";
  var _r = "upward";
  var _s = "downward";
  $k[$j++] = _p;
  $k[$j++] = _p;
  $k[$j++] = _q;
  $k[$j++] = _q;
  $k[$j++] = _r;
  $k[$j++] = _r;
  $k[$j++] = _s;
  $k[$j++] = _s;
  var _v = $get($d(), $_.extratextdirection) !== void 0;
  if (!_v) {
    $k[$j++] = "bwipp.renmatrixBadExtratextdirection#33032";
    $k[$j++] = "extratextdirection must be forward, backward, upward or downward";
    bwipp_raiseerror();
  }
  if ($_.extratextsize <= 0 || $_.extratextsize >= 25) {
    $k[$j++] = "bwipp.renmatrixBadTextsize#33036";
    $k[$j++] = "extratextsize must be greater than zero and less that 25";
    bwipp_raiseerror();
  }
  $_.bars = $a(~~(($_.sbs.length + 1) / 2));
  $_.pixx = 0;
  $_.pixy = 0;
  for (var _12 = 0, _11 = ~~(($_.sbs.length + 1) / 2) * 2 - 2; _12 <= _11; _12 += 1) {
    $_.i = _12;
    if ($_.i % 2 == 0) {
      $_.d = $f($get($_.sbs, $_.i) * $_.barratio - $_.barratio) + 1;
      if ($get($_.sbs, $_.i) != 0) {
        $_.h = $get($_.bhs, ~~($_.i / 2)) * 72;
        $_.c = $f($_.d / 2 + $_.pixx);
        $_.y = $get($_.bbs, ~~($_.i / 2)) * 72;
        $_.w = $f($_.d - $_.inkspread);
        $put($_.bars, ~~($_.i / 2), $a([$_.h, $_.c, $_.y, $_.w]));
        if ($f($_.h + $_.y) > $_.pixy) {
          $_.pixy = $f($_.h + $_.y);
        }
      } else {
        $put($_.bars, ~~($_.i / 2), -1);
      }
    } else {
      $_.d = $f($get($_.sbs, $_.i) * $_.spaceratio - $_.spaceratio) + 1;
    }
    $_.pixx = $f($_.pixx + $_.d);
  }
  $$.save();
  var _1h = $$.currpos();
  $$.translate(_1h.x, _1h.y);
  if ($_.width != 0) {
    $$.scale($_.width * 72 / $_.pixx, 1);
  }
  $_.tl = $a([-$f($_.borderleft + $_.borderwidth / 2), $f($_.pixy + $_.bordertop + $_.borderwidth / 2)]);
  $_.tr = $a([$f($_.pixx + $_.borderright + $_.borderwidth / 2), $f($_.pixy + $_.bordertop + $_.borderwidth / 2)]);
  $_.bl = $a([-$f($_.borderleft + $_.borderwidth / 2), -$f($_.borderbottom + $_.borderwidth / 2)]);
  $_.br = $a([$f($_.pixx + $_.borderright + $_.borderwidth / 2), -$f($_.borderbottom + $_.borderwidth / 2)]);
  if ($_.showbearer) {
    $$.save();
    $$.newpath();
    $aload($_.bl);
    var _2B = $k[--$j];
    $$.moveto($k[--$j], _2B);
    $aload($_.br);
    var _2E = $k[--$j];
    $$.lineto($k[--$j], _2E);
    $aload($_.tl);
    var _2H = $k[--$j];
    $$.moveto($k[--$j], _2H);
    $aload($_.tr);
    var _2K = $k[--$j];
    $$.lineto($k[--$j], _2K);
    if ($ne($_.bordercolor, "unset")) {
      $$.setcolor($_.bordercolor);
    }
    $$.setlinewidth($f($_.borderwidth - $_.inkspread * 2));
    $$.stroke();
    $$.restore();
  } else {
    if ($_.showborder) {
      $$.save();
      $$.newpath();
      $aload($_.bl);
      var _2S = $k[--$j];
      $$.moveto($k[--$j], _2S);
      var _2X = $a([$_.br, $_.tr, $_.tl]);
      for (var _2Y = 0, _2Z = _2X.length; _2Y < _2Z; _2Y++) {
        $aload($get(_2X, _2Y));
        var _2b = $k[--$j];
        $$.lineto($k[--$j], _2b);
      }
      $$.closepath();
      if ($ne($_.bordercolor, "unset")) {
        $$.setcolor($_.bordercolor);
      }
      $$.setlinewidth($_.borderwidth);
      $$.stroke();
      $$.restore();
    }
  }
  $$.save();
  if ($ne($_.barcolor, "unset")) {
    $$.setcolor($_.barcolor);
  }
  var _2i = $_.bars;
  for (var _2j = 0, _2k = _2i.length; _2j < _2k; _2j++) {
    var _2l = $get(_2i, _2j);
    $k[$j++] = _2l;
    if (_2l != -1) {
      $aload($k[--$j]);
      $$.newpath();
      $$.setlinewidth($k[--$j]);
      var _2o = $k[--$j];
      $$.moveto($k[--$j], _2o);
      $$.rlineto(0, $k[--$j]);
      $$.stroke();
    } else {
      $j--;
    }
  }
  $$.restore();
  var _37 = /* @__PURE__ */ new Map([
    ["offleft", function() {
      $k[$j++] = $f(-$_.tw - $_.nudge);
    }],
    ["below", function() {
      $k[$j++] = $f(-$_.th - $_.nudge);
    }],
    ["left", function() {
      $k[$j++] = 0;
    }],
    ["bottom", function() {
      $k[$j++] = 0;
    }],
    ["xcenter", function() {
      $k[$j++] = $f($_.pixx - $_.tw) / 2;
    }],
    ["ycenter", function() {
      $k[$j++] = $f($_.pixy - $_.th) / 2;
    }],
    ["right", function() {
      $k[$j++] = $f($_.pixx - $_.tw);
    }],
    ["top", function() {
      $k[$j++] = $f($_.pixy - $_.th);
    }],
    ["offright", function() {
      $k[$j++] = $f($_.pixx + $_.nudge);
    }],
    ["above", function() {
      $k[$j++] = $f($_.pixy + $_.nudge);
    }]
  ]);
  var _3O = /* @__PURE__ */ new Map([
    ["offleft", function() {
      $k[$j++] = 0 - $_.nudge;
    }],
    ["below", function() {
      $k[$j++] = 0 - $_.nudge;
    }],
    ["left", function() {
      $k[$j++] = $_.tw;
    }],
    ["bottom", function() {
      $k[$j++] = $_.th;
    }],
    ["xcenter", function() {
      $k[$j++] = $f($_.pixx + $_.tw) / 2;
    }],
    ["ycenter", function() {
      $k[$j++] = $f($_.pixy + $_.th) / 2;
    }],
    ["right", function() {
      $k[$j++] = $_.pixx;
    }],
    ["top", function() {
      $k[$j++] = $_.pixy;
    }],
    ["offright", function() {
      $k[$j++] = $f($_.pixx + $_.tw + $_.nudge);
    }],
    ["above", function() {
      $k[$j++] = $f($_.pixy + $_.th + $_.nudge);
    }]
  ]);
  var _3f = /* @__PURE__ */ new Map([
    ["offleft", function() {
      $k[$j++] = 0 - $_.nudge;
    }],
    ["below", function() {
      $k[$j++] = $f(-$_.tw - $_.nudge);
    }],
    ["left", function() {
      $k[$j++] = $_.th;
    }],
    ["bottom", function() {
      $k[$j++] = 0;
    }],
    ["xcenter", function() {
      $k[$j++] = $f($_.pixx + $_.th) / 2;
    }],
    ["ycenter", function() {
      $k[$j++] = $f($_.pixy - $_.tw) / 2;
    }],
    ["right", function() {
      $k[$j++] = $_.pixx;
    }],
    ["top", function() {
      $k[$j++] = $f($_.pixy - $_.tw);
    }],
    ["offright", function() {
      $k[$j++] = $f($_.pixx + $_.th + $_.nudge);
    }],
    ["above", function() {
      $k[$j++] = $f($_.pixy + $_.nudge);
    }]
  ]);
  var _3w = /* @__PURE__ */ new Map([
    ["offleft", function() {
      $k[$j++] = $f(-$_.th - $_.nudge);
    }],
    ["below", function() {
      $k[$j++] = 0 - $_.nudge;
    }],
    ["left", function() {
      $k[$j++] = 0;
    }],
    ["bottom", function() {
      $k[$j++] = $_.tw;
    }],
    ["xcenter", function() {
      $k[$j++] = $f($_.pixx - $_.th) / 2;
    }],
    ["ycenter", function() {
      $k[$j++] = $f($_.pixy + $_.tw) / 2;
    }],
    ["right", function() {
      $k[$j++] = $f($_.pixx - $_.th);
    }],
    ["top", function() {
      $k[$j++] = $_.pixy;
    }],
    ["offright", function() {
      $k[$j++] = $f($_.pixx + $_.nudge);
    }],
    ["above", function() {
      $k[$j++] = $f($_.pixy + $_.tw + $_.nudge);
    }]
  ]);
  var _3x = /* @__PURE__ */ new Map([
    ["forward", _37],
    ["backward", _3O],
    ["upward", _3f],
    ["downward", _3w]
  ]);
  $_.positions = _3x;
  $_.positiontext = function() {
    $_.th = $k[--$j];
    $_.tw = $k[--$j];
    $_.nudge = 1;
    var _42 = $get($_.positions, $k[--$j]);
    $k[$j++] = _42;
    $k[$j++] = _42;
    $r(4, -1);
    var _43 = $k[$j - 1];
    if ($eq(_43, "center")) {
      $k[$j - 1] = "xcenter";
    }
    var _44 = $k[--$j];
    if ($get($k[--$j], _44)() === true) {
      return true;
    }
    var _47 = $k[--$j];
    var _48 = $k[--$j];
    $k[$j++] = _47;
    $k[$j++] = _48;
    $r(3, -1);
    var _49 = $k[$j - 1];
    if ($eq(_49, "center")) {
      $k[$j - 1] = "ycenter";
    }
    var _4A = $k[--$j];
    if ($get($k[--$j], _4A)() === true) {
      return true;
    }
  };
  if ($_.includetext) {
    if ($ne($_.textcolor, "unset")) {
      $$.setcolor($_.textcolor);
    }
    if ($eq($_.textxalign, "unset") && $eq($_.textyalign, "unset") && $_.alttext.length == 0) {
      $_.s = 0;
      $_.fn = "";
      var _4J = $_.txt;
      for (var _4K = 0, _4L = _4J.length; _4K < _4L; _4K++) {
        $aload($get(_4J, _4K));
        var _4N = $k[$j - 1];
        var _4O = $k[$j - 2];
        if (_4N != $_.s || $ne(_4O, $_.fn)) {
          var _4R = $k[$j - 1];
          if (_4R <= 0) {
            $j -= 5;
            $k[$j++] = "bwipp.renlinearFontTooSmall#33178";
            $k[$j++] = "The font size is too small";
            bwipp_raiseerror();
          }
          var _4S = $k[--$j];
          var _4T = $k[--$j];
          $_.s = _4S;
          $_.fn = _4T;
          $$.selectfont(_4T, _4S);
        } else {
          $j -= 2;
        }
        var _4U = $k[--$j];
        $$.moveto($k[--$j], _4U);
        $$.show($k[--$j], 0, 0);
      }
    } else {
      if ($_.alttext.length == 0) {
        $k[$j++] = Infinity;
        var _4Y = $_.txt;
        for (var _4Z = 0, _4a = _4Y.length; _4Z < _4a; _4Z++) {
          $forall($get($get(_4Y, _4Z), 0));
        }
        $_.txt = $a();
        $_.tstr = $s($_.txt.length);
        for (var _4i = 0, _4h = $_.txt.length - 1; _4i <= _4h; _4i += 1) {
          $put($_.tstr, _4i, $get($_.txt, _4i));
        }
      } else {
        $_.tstr = $_.alttext;
        for (var _4p = 0, _4o = $_.alttext.length - 1; _4p <= _4o; _4p += 1) {
          $k[$j++] = _4p;
          $search($_.alttextsubspace, $geti($_.alttext, _4p, 1));
          if ($k[--$j]) {
            $j--;
            $j--;
            var _4y = $k[$j - 2];
            $put($_.alttext, _4y, 32);
          }
          $j -= 2;
        }
      }
      if ($_.alttext.length != 0 && $_.alttextsplit.length != 0) {
        if ($_.alttextsplit.length != 1) {
          $k[$j++] = "bwipp.alttextsplitBad#33206";
          $k[$j++] = "The alttextsplit option must be a single character";
          bwipp_raiseerror();
        }
        $k[$j++] = Infinity;
        $k[$j++] = $_.tstr;
        for (; ; ) {
          $search($k[--$j], $_.alttextsplit);
          if ($k[--$j]) {
            var _56 = $k[--$j];
            $k[$j - 1] = _56;
            var _58 = $k[--$j];
            var _59 = $k[--$j];
            $k[$j++] = _58;
            $k[$j++] = _59;
          } else {
            break;
          }
        }
        $_.textlines = $a();
      } else {
        $_.textlines = $a([$_.tstr]);
      }
      $$.selectfont($_.textfont, $_.textsize);
      if ($_.tstr.length == 0) {
        $k[$j++] = 0;
      } else {
        $$.save();
        $$.newpath();
        $$.moveto(0, 0);
        $$.charpath("0", false);
        var _5G = $$.pathbbox();
        $$.restore();
        $k[$j++] = _5G.ury;
      }
      $_.textascent = $k[--$j];
      var _5I = $_.textlines;
      $k[$j++] = "textwidth";
      $k[$j++] = 0;
      for (var _5J = 0, _5K = _5I.length; _5J < _5K; _5J++) {
        var _5M = $$.stringwidth($get(_5I, _5J));
        var _5N = $k[--$j];
        var _5O = _5M.w;
        if (_5N < _5M.w) {
          var _ = _5O;
          _5O = _5N;
          _5N = _;
        }
        $k[$j++] = _5N;
      }
      var _5R = $k[--$j];
      $_[$k[--$j]] = $f(_5R + ($_.tstr.length - 1) * $_.textgaps);
      var _5U = $_.textlines.length;
      $_.textheight = $f(_5U * $_.textascent + (_5U - 1) * $_.textlinegaps);
      if ($eq($_.textxalign, "unset")) {
        $_.textxalign = "center";
      }
      if ($eq($_.textyalign, "unset")) {
        $_.textyalign = "below";
      }
      if ($eq($_.textxalign, "justify")) {
        if ($ne($_.textdirection, "forward") && $ne($_.textdirection, "backward")) {
          $k[$j++] = "bwipp.textxjustify#33243";
          $k[$j++] = "textxalign=justify requires forward or backward text";
          bwipp_raiseerror();
        }
        if ($_.textwidth < $_.pixx) {
          $_.textgaps = $f($_.pixx - $_.textwidth) / ($_.tstr.length - 1);
          $k[$j++] = "textxalign";
          if ($eq($_.textdirection, "forward")) {
            $k[$j++] = "left";
          } else {
            $k[$j++] = "right";
          }
          var _5i = $k[--$j];
          $_[$k[--$j]] = _5i;
        } else {
          $_.textgaps = 0;
          $_.textxalign = "center";
        }
      }
      if ($eq($_.textyalign, "justify")) {
        if ($ne($_.textdirection, "upward") && $ne($_.textdirection, "downward")) {
          $k[$j++] = "bwipp.textyjustify#33256";
          $k[$j++] = "textyalign=justify requires upward or downward text";
          bwipp_raiseerror();
        }
        if ($_.textwidth < $_.pixy) {
          $_.textgaps = $f($_.pixy - $_.textwidth) / ($_.tstr.length - 1);
          $k[$j++] = "textyalign";
          if ($eq($_.textdirection, "upward")) {
            $k[$j++] = "bottom";
          } else {
            $k[$j++] = "top";
          }
          var _5t = $k[--$j];
          $_[$k[--$j]] = _5t;
        } else {
          $_.textgaps = 0;
          $_.textyalign = "center";
        }
      }
      $k[$j++] = $_.textxalign;
      $k[$j++] = $_.textyalign;
      $k[$j++] = $_.textdirection;
      $k[$j++] = $_.textwidth;
      $k[$j++] = $_.textheight;
      $_.positiontext();
      var _60 = $k[--$j];
      $$.moveto($k[--$j], _60);
      $$.rmoveto($_.textxoffset, $_.textyoffset);
      $$.save();
      var _64 = /* @__PURE__ */ new Map([
        ["forward", 0],
        ["upward", 90],
        ["backward", 180],
        ["downward", 270]
      ]);
      $$.rotate($get(_64, $_.textdirection));
      var _67 = $$.currpos();
      $$.translate(_67.x, _67.y);
      for (var _6A = 0, _69 = $_.textlines.length - 1; _6A <= _69; _6A += 1) {
        $_.i = _6A;
        $$.moveto(0, 0 + $f($_.textascent + $_.textlinegaps) * $_.i);
        var _6F = $_.textlines;
        $$.show($get(_6F, _6F.length - $_.i - 1), $_.textgaps, 0);
      }
      $$.restore();
    }
  }
  if ($_.guardwhitespace) {
    $$.selectfont("OCR-B", $_.guardheight * 2);
    if ($_.guardleftpos != 0) {
      $$.moveto(-$_.guardleftpos - 2, $f($_.guardleftypos - $_.guardheight / 2 - 1.25));
      $$.show("<", 0, 0);
    }
    if ($_.guardrightpos != 0) {
      $$.moveto($f($_.guardrightpos + $_.pixx - $_.guardwidth) + 1, $f($_.guardrightypos - $_.guardheight / 2 - 1.25));
      $$.show(">", 0, 0);
    }
  }
  if ($_.extratext.length != 0) {
    for (var _6X = 0, _6W = $_.extratext.length - 1; _6X <= _6W; _6X += 1) {
      $k[$j++] = _6X;
      $search($_.extratextsubspace, $geti($_.extratext, _6X, 1));
      if ($k[--$j]) {
        $j--;
        $j--;
        var _6g = $k[$j - 2];
        $put($_.extratext, _6g, 32);
      }
      $j -= 2;
    }
    if ($_.extratextsplit.length != 0) {
      if ($_.extratextsplit.length != 1) {
        $k[$j++] = "bwipp.extratextsplitBad#33309";
        $k[$j++] = "The extratextsplit option must be a single character";
        bwipp_raiseerror();
      }
      $k[$j++] = Infinity;
      $k[$j++] = $_.extratext;
      for (; ; ) {
        $search($k[--$j], $_.extratextsplit);
        if ($k[--$j]) {
          var _6n = $k[--$j];
          $k[$j - 1] = _6n;
          var _6p = $k[--$j];
          var _6q = $k[--$j];
          $k[$j++] = _6p;
          $k[$j++] = _6q;
        } else {
          break;
        }
      }
      $_.textlines = $a();
    } else {
      $_.textlines = $a([$_.extratext]);
    }
    if ($ne($_.extratextcolor, "unset")) {
      $$.setcolor($_.extratextcolor);
    }
    $$.selectfont($_.extratextfont, $_.extratextsize);
    $$.save();
    $$.newpath();
    $$.moveto(0, 0);
    $$.charpath("0", false);
    var _6y = $$.pathbbox();
    $$.restore();
    $_.textascent = _6y.ury;
    var _6z = $_.textlines;
    $k[$j++] = "textwidth";
    $k[$j++] = 0;
    for (var _70 = 0, _71 = _6z.length; _70 < _71; _70++) {
      var _73 = $$.stringwidth($get(_6z, _70));
      var _74 = $k[--$j];
      var _75 = _73.w;
      if (_74 < _73.w) {
        var _ = _75;
        _75 = _74;
        _74 = _;
      }
      $k[$j++] = _74;
    }
    var _78 = $k[--$j];
    $_[$k[--$j]] = $f(_78 + ($_.extratext.length - 1) * $_.extratextgaps);
    var _7B = $_.textlines.length;
    $_.textheight = $f(_7B * $_.textascent + (_7B - 1) * $_.extratextlinegaps);
    if ($eq($_.extratextxalign, "justify")) {
      if ($ne($_.extratextdirection, "forward") && $ne($_.extratextdirection, "backward")) {
        $k[$j++] = "bwipp.extratextxjustify#33340";
        $k[$j++] = "extratextxalign=justify requires forward or backward text";
        bwipp_raiseerror();
      }
      if ($_.textwidth < $_.pixx) {
        $_.extratextgaps = $f($_.pixx - $_.textwidth) / ($_.extratext.length - 1);
        $k[$j++] = "extratextxalign";
        if ($eq($_.extratextdirection, "forward")) {
          $k[$j++] = "left";
        } else {
          $k[$j++] = "right";
        }
        var _7N = $k[--$j];
        $_[$k[--$j]] = _7N;
      } else {
        $_.extratextgaps = 0;
        $_.extratextxalign = "center";
      }
    }
    if ($eq($_.extratextyalign, "justify")) {
      if ($ne($_.extratextdirection, "upward") && $ne($_.extratextdirection, "downward")) {
        $k[$j++] = "bwipp.extratextyjustify#33353";
        $k[$j++] = "extratextyalign=justify requires upward or downward text";
        bwipp_raiseerror();
      }
      if ($_.textwidth < $_.pixy) {
        $_.extratextgaps = $f($_.pixy - $_.textwidth) / ($_.extratext.length - 1);
        $k[$j++] = "extratextyalign";
        if ($eq($_.extratextdirection, "upward")) {
          $k[$j++] = "bottom";
        } else {
          $k[$j++] = "top";
        }
        var _7Y = $k[--$j];
        $_[$k[--$j]] = _7Y;
      } else {
        $_.extratextgaps = 0;
        $_.extratextyalign = "center";
      }
    }
    $k[$j++] = $_.extratextxalign;
    $k[$j++] = $_.extratextyalign;
    $k[$j++] = $_.extratextdirection;
    $k[$j++] = $_.textwidth;
    $k[$j++] = $_.textheight;
    $_.positiontext();
    var _7f = $k[--$j];
    $$.moveto($k[--$j], _7f);
    $$.rmoveto($_.extratextxoffset, $_.extratextyoffset);
    $$.save();
    var _7j = /* @__PURE__ */ new Map([
      ["forward", 0],
      ["upward", 90],
      ["backward", 180],
      ["downward", 270]
    ]);
    $$.rotate($get(_7j, $_.extratextdirection));
    var _7m = $$.currpos();
    $$.translate(_7m.x, _7m.y);
    for (var _7p = 0, _7o = $_.textlines.length - 1; _7p <= _7o; _7p += 1) {
      $_.i = _7p;
      $$.moveto(0, 0 + $f($_.textascent + $_.extratextlinegaps) * $_.i);
      var _7u = $_.textlines;
      $$.show($get(_7u, _7u.length - $_.i - 1), $_.extratextgaps, 0);
    }
    $$.restore();
  }
  $$.restore();
  $_ = $__;
}
function bwipp_renmatrix() {
  if ($_.bwipjs_rawstack) {
    $_.bwipjs_rawstack.push($k[--$j]);
    return;
  }
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.width = 1;
  $_.height = 1;
  $_.barcolor = "unset";
  $_.bordercolor = "unset";
  $_.colormap = "unset";
  $_.dotty = false;
  $_.inkspread = 0;
  $_.inkspreadh = null;
  $_.inkspreadv = null;
  $_.txt = $a([]);
  $_.includetext = false;
  $_.textcolor = "unset";
  $_.textxalign = "unset";
  $_.textyalign = "unset";
  $_.textfont = "OCR-B";
  $_.textdirection = "forward";
  $_.textsize = 10;
  $_.textxoffset = 0;
  $_.textyoffset = 0;
  $_.textgaps = 0;
  $_.textlinegaps = 1.2;
  $_.alttext = "";
  $_.alttextsplit = "";
  $_.alttextsubspace = "";
  $_.extratext = "";
  $_.extratextsubspace = "";
  $_.extratextsplit = "";
  $_.extratextlinegaps = 1.2;
  $_.extratextcolor = "unset";
  $_.extratextxalign = "left";
  $_.extratextyalign = "above";
  $_.extratextfont = "OCR-B";
  $_.extratextdirection = "forward";
  $_.extratextsize = 10;
  $_.extratextxoffset = 0;
  $_.extratextyoffset = 0;
  $_.extratextgaps = 0;
  $_.showborder = false;
  $_.borderleft = 0;
  $_.borderright = 0;
  $_.bordertop = 0;
  $_.borderbottom = 0;
  $_.borderwidth = 0.25;
  $forall($k[--$j], function() {
    var _2 = $k[--$j];
    $_[$k[--$j]] = _2;
  });
  $k[$j++] = $_.opt;
  delete $_["opt"];
  $k[$j++] = $_;
  bwipp_processoptions();
  $j--;
  if ($_.inkspreadh == null) {
    $_.inkspreadh = $_.inkspread;
  }
  if ($_.inkspreadv == null) {
    $_.inkspreadv = $_.inkspread;
  }
  if ($ne($_.textxalign, "unset")) {
    $k[$j++] = Infinity;
    var _A = "offleft";
    var _B = "left";
    var _C = "center";
    var _D = "right";
    var _E = "offright";
    $k[$j++] = _A;
    $k[$j++] = _A;
    $k[$j++] = _B;
    $k[$j++] = _B;
    $k[$j++] = _C;
    $k[$j++] = _C;
    $k[$j++] = _D;
    $k[$j++] = _D;
    $k[$j++] = _E;
    $k[$j++] = _E;
    var _H = $get($d(), $_.textxalign) !== void 0;
    if (!_H) {
      $k[$j++] = "bwipp.renmatrixBadTextxalign#33458";
      $k[$j++] = "textxalign must be offleft, left, center, right or offright";
      bwipp_raiseerror();
    }
  }
  if ($ne($_.textyalign, "unset")) {
    $k[$j++] = Infinity;
    var _J = "above";
    var _K = "top";
    var _L = "center";
    var _M = "bottom";
    var _N = "below";
    $k[$j++] = _J;
    $k[$j++] = _J;
    $k[$j++] = _K;
    $k[$j++] = _K;
    $k[$j++] = _L;
    $k[$j++] = _L;
    $k[$j++] = _M;
    $k[$j++] = _M;
    $k[$j++] = _N;
    $k[$j++] = _N;
    var _Q = $get($d(), $_.textyalign) !== void 0;
    if (!_Q) {
      $k[$j++] = "bwipp.renmatrixBadTextyalign#33464";
      $k[$j++] = "textyalign must be above, top, center, bottom or below";
      bwipp_raiseerror();
    }
  }
  $k[$j++] = Infinity;
  var _R = "forward";
  var _S = "backward";
  var _T = "upward";
  var _U = "downward";
  $k[$j++] = _R;
  $k[$j++] = _R;
  $k[$j++] = _S;
  $k[$j++] = _S;
  $k[$j++] = _T;
  $k[$j++] = _T;
  $k[$j++] = _U;
  $k[$j++] = _U;
  var _X = $get($d(), $_.textdirection) !== void 0;
  if (!_X) {
    $k[$j++] = "bwipp.renmatrixBadTextdirection#33469";
    $k[$j++] = "textdirection must be forward, backward, upward or downward";
    bwipp_raiseerror();
  }
  if ($_.textsize <= 0 || $_.textsize >= 25) {
    $k[$j++] = "bwipp.renmatrixBadTextsize#33473";
    $k[$j++] = "textsize must be greater than zero and less that 25";
    bwipp_raiseerror();
  }
  $k[$j++] = Infinity;
  var _a = "offleft";
  var _b = "left";
  var _c = "center";
  var _d = "right";
  var _e = "offright";
  $k[$j++] = _a;
  $k[$j++] = _a;
  $k[$j++] = _b;
  $k[$j++] = _b;
  $k[$j++] = _c;
  $k[$j++] = _c;
  $k[$j++] = _d;
  $k[$j++] = _d;
  $k[$j++] = _e;
  $k[$j++] = _e;
  var _h = $get($d(), $_.extratextxalign) !== void 0;
  if (!_h) {
    $k[$j++] = "bwipp.renmatrixBadExtratextxalign#33477";
    $k[$j++] = "extratextxalign must be offleft, left, center, right or offright";
    bwipp_raiseerror();
  }
  $k[$j++] = Infinity;
  var _i = "above";
  var _j = "top";
  var _k = "center";
  var _l = "bottom";
  var _m = "below";
  $k[$j++] = _i;
  $k[$j++] = _i;
  $k[$j++] = _j;
  $k[$j++] = _j;
  $k[$j++] = _k;
  $k[$j++] = _k;
  $k[$j++] = _l;
  $k[$j++] = _l;
  $k[$j++] = _m;
  $k[$j++] = _m;
  var _p = $get($d(), $_.extratextyalign) !== void 0;
  if (!_p) {
    $k[$j++] = "bwipp.renmatrixBadExtratextyalign#33481";
    $k[$j++] = "extratextyalign must be above, top, center, bottom or below";
    bwipp_raiseerror();
  }
  $k[$j++] = Infinity;
  var _q = "forward";
  var _r = "backward";
  var _s = "upward";
  var _t = "downward";
  $k[$j++] = _q;
  $k[$j++] = _q;
  $k[$j++] = _r;
  $k[$j++] = _r;
  $k[$j++] = _s;
  $k[$j++] = _s;
  $k[$j++] = _t;
  $k[$j++] = _t;
  var _w = $get($d(), $_.extratextdirection) !== void 0;
  if (!_w) {
    $k[$j++] = "bwipp.renmatrixBadExtratextdirection#33485";
    $k[$j++] = "extratextdirection must be forward, backward, upward or downward";
    bwipp_raiseerror();
  }
  if ($_.extratextsize <= 0 || $_.extratextsize >= 25) {
    $k[$j++] = "bwipp.renmatrixBadTextsize#33489";
    $k[$j++] = "extratextsize must be greater than zero and less that 25";
    bwipp_raiseerror();
  }
  $_.xyget = function() {
    var _10 = $k[--$j];
    var _13 = $get($_.pixs, $f($k[--$j] + _10 * $_.pixx));
    $k[$j++] = _13;
  };
  $_.drawlayerdots = function() {
    $_.pixsorig = $_.pixs;
    $_.pixs = $k[--$j];
    $$.newpath();
    for (var _18 = 0, _17 = $_.pixs.length - 1; _18 <= _17; _18 += 1) {
      $_.x = _18 % $_.pixx;
      $_.y = ~~(_18 / $_.pixx);
      $k[$j++] = $_.x;
      $k[$j++] = $_.y;
      $_.xyget();
      if ($k[--$j] == 1) {
        $$.moveto($f($_.x + 0.5), $f($_.pixy - $_.y - 0.5));
        $$.arc($f($_.x + 0.5), $f($_.pixy - $_.y - 0.5), $f(0.5 - $_.inkspread), 0, 360, 1);
      }
    }
    $$.fill();
    $_.pixs = $_.pixsorig;
  };
  $$.save();
  var _1M = $$.currpos();
  $$.translate(_1M.x, _1M.y);
  $_.inkspread = $_.inkspread / 2;
  $_.inkspreadh = $_.inkspreadh / 2;
  $_.inkspreadv = $_.inkspreadv / 2;
  $$.scale($_.width / $_.pixx * 72, $_.height / $_.pixy * 72);
  if ($_.showborder) {
    $_.tl = $a([-$f($_.borderleft + $_.borderwidth / 2), $f($_.pixy + $_.bordertop + $_.borderwidth / 2)]);
    $_.tr = $a([$f($_.pixx + $_.borderright + $_.borderwidth / 2), $f($_.pixy + $_.bordertop + $_.borderwidth / 2)]);
    $_.bl = $a([-$f($_.borderleft + $_.borderwidth / 2), -$f($_.borderbottom + $_.borderwidth / 2)]);
    $_.br = $a([$f($_.pixx + $_.borderright + $_.borderwidth / 2), -$f($_.borderbottom + $_.borderwidth / 2)]);
  } else {
    $_.tl = $a([$f(-$_.borderleft + $_.inkspread), $f($_.pixy + $_.bordertop - $_.inkspread)]);
    $_.tr = $a([$f($_.pixx + $_.borderright - $_.inkspread), $f($_.pixy + $_.bordertop - $_.inkspread)]);
    $_.bl = $a([$f(-$_.borderleft + $_.inkspread), $f(-$_.borderbottom + $_.inkspread)]);
    $_.br = $a([$f($_.pixx + $_.borderright - $_.inkspread), $f(-$_.borderbottom + $_.inkspread)]);
  }
  if ($_.showborder) {
    $$.save();
    $$.newpath();
    $aload($_.bl);
    var _2J = $k[--$j];
    $$.moveto($k[--$j], _2J);
    var _2O = $a([$_.br, $_.tr, $_.tl]);
    for (var _2P = 0, _2Q = _2O.length; _2P < _2Q; _2P++) {
      $aload($get(_2O, _2P));
      var _2S = $k[--$j];
      $$.lineto($k[--$j], _2S);
    }
    $$.closepath();
    if ($ne($_.bordercolor, "unset")) {
      $$.setcolor($_.bordercolor);
    }
    $$.setlinewidth($f($_.borderwidth - $_.inkspread * 2));
    $$.stroke();
    $$.restore();
  }
  if ($eq($_.colormap, "unset")) {
    var _2a = /* @__PURE__ */ new Map([
      [1, $_.barcolor]
    ]);
    $_.colormap = _2a;
  }
  var _2b = $_.colormap;
  for (var _2g = _2b.size, _2f = _2b.keys(), _2e = 0; _2e < _2g; _2e++) {
    var _2c = _2f.next().value;
    var _2d = _2b.get(_2c);
    $k[$j++] = _2c;
    $k[$j++] = _2d;
    if ($ne(_2d, "unset")) {
      $$.setcolor($k[--$j]);
    } else {
      $j--;
    }
    $_.key = $k[--$j];
    $k[$j++] = Infinity;
    var _2j = $_.pixs;
    for (var _2k = 0, _2l = _2j.length; _2k < _2l; _2k++) {
      var _2o = $eq($get(_2j, _2k), $_.key) ? 1 : 0;
      $k[$j++] = _2o;
    }
    var _2p = $a();
    $k[$j++] = _2p;
    if ($_.dotty) {
      $_.drawlayerdots();
    } else {
      $$.drawlayer($k[--$j], $_.pixx, $_.pixy, $_.inkspreadh, $_.inkspreadv);
    }
  }
  var _38 = /* @__PURE__ */ new Map([
    ["offleft", function() {
      $k[$j++] = $f(-$_.tw - $_.nudge);
    }],
    ["below", function() {
      $k[$j++] = $f(-$_.th - $_.nudge);
    }],
    ["left", function() {
      $k[$j++] = 0;
    }],
    ["bottom", function() {
      $k[$j++] = 0;
    }],
    ["xcenter", function() {
      $k[$j++] = $f($_.pixx - $_.tw) / 2;
    }],
    ["ycenter", function() {
      $k[$j++] = $f($_.pixy - $_.th) / 2;
    }],
    ["right", function() {
      $k[$j++] = $f($_.pixx - $_.tw);
    }],
    ["top", function() {
      $k[$j++] = $f($_.pixy - $_.th);
    }],
    ["offright", function() {
      $k[$j++] = $_.pixx + $_.nudge;
    }],
    ["above", function() {
      $k[$j++] = $_.pixy + $_.nudge;
    }]
  ]);
  var _3P = /* @__PURE__ */ new Map([
    ["offleft", function() {
      $k[$j++] = 0 - $_.nudge;
    }],
    ["below", function() {
      $k[$j++] = 0 - $_.nudge;
    }],
    ["left", function() {
      $k[$j++] = $_.tw;
    }],
    ["bottom", function() {
      $k[$j++] = $_.th;
    }],
    ["xcenter", function() {
      $k[$j++] = $f($_.pixx + $_.tw) / 2;
    }],
    ["ycenter", function() {
      $k[$j++] = $f($_.pixy + $_.th) / 2;
    }],
    ["right", function() {
      $k[$j++] = $_.pixx;
    }],
    ["top", function() {
      $k[$j++] = $_.pixy;
    }],
    ["offright", function() {
      $k[$j++] = $f($_.pixx + $_.tw + $_.nudge);
    }],
    ["above", function() {
      $k[$j++] = $f($_.pixy + $_.th + $_.nudge);
    }]
  ]);
  var _3g = /* @__PURE__ */ new Map([
    ["offleft", function() {
      $k[$j++] = 0 - $_.nudge;
    }],
    ["below", function() {
      $k[$j++] = $f(-$_.tw - $_.nudge);
    }],
    ["left", function() {
      $k[$j++] = $_.th;
    }],
    ["bottom", function() {
      $k[$j++] = 0;
    }],
    ["xcenter", function() {
      $k[$j++] = $f($_.pixx + $_.th) / 2;
    }],
    ["ycenter", function() {
      $k[$j++] = $f($_.pixy - $_.tw) / 2;
    }],
    ["right", function() {
      $k[$j++] = $_.pixx;
    }],
    ["top", function() {
      $k[$j++] = $f($_.pixy - $_.tw);
    }],
    ["offright", function() {
      $k[$j++] = $f($_.pixx + $_.th + $_.nudge);
    }],
    ["above", function() {
      $k[$j++] = $_.pixy + $_.nudge;
    }]
  ]);
  var _3x = /* @__PURE__ */ new Map([
    ["offleft", function() {
      $k[$j++] = $f(-$_.th - $_.nudge);
    }],
    ["below", function() {
      $k[$j++] = 0 - $_.nudge;
    }],
    ["left", function() {
      $k[$j++] = 0;
    }],
    ["bottom", function() {
      $k[$j++] = $_.tw;
    }],
    ["xcenter", function() {
      $k[$j++] = $f($_.pixx - $_.th) / 2;
    }],
    ["ycenter", function() {
      $k[$j++] = $f($_.pixy + $_.tw) / 2;
    }],
    ["right", function() {
      $k[$j++] = $f($_.pixx - $_.th);
    }],
    ["top", function() {
      $k[$j++] = $_.pixy;
    }],
    ["offright", function() {
      $k[$j++] = $_.pixx + $_.nudge;
    }],
    ["above", function() {
      $k[$j++] = $f($_.pixy + $_.tw + $_.nudge);
    }]
  ]);
  var _3y = /* @__PURE__ */ new Map([
    ["forward", _38],
    ["backward", _3P],
    ["upward", _3g],
    ["downward", _3x]
  ]);
  $_.positions = _3y;
  $_.positiontext = function() {
    $_.th = $k[--$j];
    $_.tw = $k[--$j];
    $_.nudge = 1;
    var _43 = $get($_.positions, $k[--$j]);
    $k[$j++] = _43;
    $k[$j++] = _43;
    $r(4, -1);
    var _44 = $k[$j - 1];
    if ($eq(_44, "center")) {
      $k[$j - 1] = "xcenter";
    }
    var _45 = $k[--$j];
    if ($get($k[--$j], _45)() === true) {
      return true;
    }
    var _48 = $k[--$j];
    var _49 = $k[--$j];
    $k[$j++] = _48;
    $k[$j++] = _49;
    $r(3, -1);
    var _4A = $k[$j - 1];
    if ($eq(_4A, "center")) {
      $k[$j - 1] = "ycenter";
    }
    var _4B = $k[--$j];
    if ($get($k[--$j], _4B)() === true) {
      return true;
    }
  };
  if ($_.includetext) {
    if ($ne($_.textcolor, "unset")) {
      $$.setcolor($_.textcolor);
    }
    if ($eq($_.textxalign, "unset") && $eq($_.textyalign, "unset") && $_.alttext.length == 0) {
      $_.s = 0;
      $_.fn = "";
      var _4K = $_.txt;
      for (var _4L = 0, _4M = _4K.length; _4L < _4M; _4L++) {
        $aload($get(_4K, _4L));
        var _4O = $k[$j - 1];
        var _4P = $k[$j - 2];
        if (_4O != $_.s || $ne(_4P, $_.fn)) {
          var _4S = $k[$j - 1];
          if (_4S <= 0) {
            $j -= 5;
            $k[$j++] = "bwipp.renmatrixFontTooSmall#33793";
            $k[$j++] = "The font size is too small";
            bwipp_raiseerror();
          }
          var _4T = $k[--$j];
          var _4U = $k[--$j];
          $_.s = _4T;
          $_.fn = _4U;
          $$.selectfont(_4U, _4T);
        } else {
          $j -= 2;
        }
        var _4V = $k[--$j];
        $$.moveto($k[--$j], _4V);
        $$.show($k[--$j], 0, 0);
      }
    } else {
      if ($_.alttext.length == 0) {
        $k[$j++] = Infinity;
        var _4Z = $_.txt;
        for (var _4a = 0, _4b = _4Z.length; _4a < _4b; _4a++) {
          $forall($get($get(_4Z, _4a), 0));
        }
        $_.txt = $a();
        $_.tstr = $s($_.txt.length);
        for (var _4j = 0, _4i = $_.txt.length - 1; _4j <= _4i; _4j += 1) {
          $put($_.tstr, _4j, $get($_.txt, _4j));
        }
      } else {
        $_.tstr = $_.alttext;
        for (var _4q = 0, _4p = $_.alttext.length - 1; _4q <= _4p; _4q += 1) {
          $k[$j++] = _4q;
          $search($_.alttextsubspace, $geti($_.alttext, _4q, 1));
          if ($k[--$j]) {
            $j--;
            $j--;
            var _4z = $k[$j - 2];
            $put($_.alttext, _4z, 32);
          }
          $j -= 2;
        }
      }
      if ($_.alttext.length != 0 && $_.alttextsplit.length != 0) {
        if ($_.alttextsplit.length != 1) {
          $k[$j++] = "bwipp.alttextsplitBad#33821";
          $k[$j++] = "The alttextsplit option must be a single character";
          bwipp_raiseerror();
        }
        $k[$j++] = Infinity;
        $k[$j++] = $_.tstr;
        for (; ; ) {
          $search($k[--$j], $_.alttextsplit);
          if ($k[--$j]) {
            var _57 = $k[--$j];
            $k[$j - 1] = _57;
            var _59 = $k[--$j];
            var _5A = $k[--$j];
            $k[$j++] = _59;
            $k[$j++] = _5A;
          } else {
            break;
          }
        }
        $_.textlines = $a();
      } else {
        $_.textlines = $a([$_.tstr]);
      }
      $$.selectfont($_.textfont, $_.textsize);
      if ($_.tstr.length == 0) {
        $k[$j++] = 0;
      } else {
        $$.save();
        $$.newpath();
        $$.moveto(0, 0);
        $$.charpath("0", false);
        var _5H = $$.pathbbox();
        $$.restore();
        $k[$j++] = _5H.ury;
      }
      $_.textascent = $k[--$j];
      var _5J = $_.textlines;
      $k[$j++] = "textwidth";
      $k[$j++] = 0;
      for (var _5K = 0, _5L = _5J.length; _5K < _5L; _5K++) {
        var _5N = $$.stringwidth($get(_5J, _5K));
        var _5O = $k[--$j];
        var _5P = _5N.w;
        if (_5O < _5N.w) {
          var _ = _5P;
          _5P = _5O;
          _5O = _;
        }
        $k[$j++] = _5O;
      }
      var _5S = $k[--$j];
      $_[$k[--$j]] = $f(_5S + ($_.tstr.length - 1) * $_.textgaps);
      var _5V = $_.textlines.length;
      $_.textheight = $f(_5V * $_.textascent + (_5V - 1) * $_.textlinegaps);
      if ($eq($_.textxalign, "unset")) {
        $_.textxalign = "center";
      }
      if ($eq($_.textyalign, "unset")) {
        $_.textyalign = "below";
      }
      if ($eq($_.textxalign, "justify")) {
        if ($ne($_.textdirection, "forward") && $ne($_.textdirection, "backward")) {
          $k[$j++] = "bwipp.textxjustify#33858";
          $k[$j++] = "textxalign=justify requires forward or backward text";
          bwipp_raiseerror();
        }
        if ($_.textwidth < $_.pixx) {
          $_.textgaps = $f($_.pixx - $_.textwidth) / ($_.tstr.length - 1);
          $k[$j++] = "textxalign";
          if ($eq($_.textdirection, "forward")) {
            $k[$j++] = "left";
          } else {
            $k[$j++] = "right";
          }
          var _5j = $k[--$j];
          $_[$k[--$j]] = _5j;
        } else {
          $_.textgaps = 0;
          $_.textxalign = "center";
        }
      }
      if ($eq($_.textyalign, "justify")) {
        if ($ne($_.textdirection, "upward") && $ne($_.textdirection, "downward")) {
          $k[$j++] = "bwipp.textyjustify#33871";
          $k[$j++] = "textyalign=justify requires upward or downward text";
          bwipp_raiseerror();
        }
        if ($_.textwidth < $_.pixy) {
          $_.textgaps = $f($_.pixy - $_.textwidth) / ($_.tstr.length - 1);
          $k[$j++] = "textyalign";
          if ($eq($_.textdirection, "upward")) {
            $k[$j++] = "bottom";
          } else {
            $k[$j++] = "top";
          }
          var _5u = $k[--$j];
          $_[$k[--$j]] = _5u;
        } else {
          $_.textgaps = 0;
          $_.textyalign = "center";
        }
      }
      $k[$j++] = $_.textxalign;
      $k[$j++] = $_.textyalign;
      $k[$j++] = $_.textdirection;
      $k[$j++] = $_.textwidth;
      $k[$j++] = $_.textheight;
      $_.positiontext();
      var _61 = $k[--$j];
      $$.moveto($k[--$j], _61);
      $$.rmoveto($_.textxoffset, $_.textyoffset);
      $$.save();
      var _65 = /* @__PURE__ */ new Map([
        ["forward", 0],
        ["upward", 90],
        ["backward", 180],
        ["downward", 270]
      ]);
      $$.rotate($get(_65, $_.textdirection));
      var _68 = $$.currpos();
      $$.translate(_68.x, _68.y);
      for (var _6B = 0, _6A = $_.textlines.length - 1; _6B <= _6A; _6B += 1) {
        $_.i = _6B;
        $$.moveto(0, 0 + $f($_.textascent + $_.textlinegaps) * $_.i);
        var _6G = $_.textlines;
        $$.show($get(_6G, _6G.length - $_.i - 1), $_.textgaps, 0);
      }
      $$.restore();
    }
  }
  if ($_.extratext.length != 0) {
    for (var _6M = 0, _6L = $_.extratext.length - 1; _6M <= _6L; _6M += 1) {
      $k[$j++] = _6M;
      $search($_.extratextsubspace, $geti($_.extratext, _6M, 1));
      if ($k[--$j]) {
        $j--;
        $j--;
        var _6V = $k[$j - 2];
        $put($_.extratext, _6V, 32);
      }
      $j -= 2;
    }
    if ($_.extratextsplit.length != 0) {
      if ($_.extratextsplit.length != 1) {
        $k[$j++] = "bwipp.extratextsplitBad#33911";
        $k[$j++] = "The extratextsplit option must be a single character";
        bwipp_raiseerror();
      }
      $k[$j++] = Infinity;
      $k[$j++] = $_.extratext;
      for (; ; ) {
        $search($k[--$j], $_.extratextsplit);
        if ($k[--$j]) {
          var _6c = $k[--$j];
          $k[$j - 1] = _6c;
          var _6e = $k[--$j];
          var _6f = $k[--$j];
          $k[$j++] = _6e;
          $k[$j++] = _6f;
        } else {
          break;
        }
      }
      $_.textlines = $a();
    } else {
      $_.textlines = $a([$_.extratext]);
    }
    if ($ne($_.extratextcolor, "unset")) {
      $$.setcolor($_.extratextcolor);
    }
    $$.selectfont($_.extratextfont, $_.extratextsize);
    $$.save();
    $$.newpath();
    $$.moveto(0, 0);
    $$.charpath("0", false);
    var _6n = $$.pathbbox();
    $$.restore();
    $_.textascent = _6n.ury;
    var _6o = $_.textlines;
    $k[$j++] = "textwidth";
    $k[$j++] = 0;
    for (var _6p = 0, _6q = _6o.length; _6p < _6q; _6p++) {
      var _6s = $$.stringwidth($get(_6o, _6p));
      var _6t = $k[--$j];
      var _6u = _6s.w;
      if (_6t < _6s.w) {
        var _ = _6u;
        _6u = _6t;
        _6t = _;
      }
      $k[$j++] = _6t;
    }
    var _6x = $k[--$j];
    $_[$k[--$j]] = $f(_6x + ($_.extratext.length - 1) * $_.extratextgaps);
    var _70 = $_.textlines.length;
    $_.textheight = $f(_70 * $_.textascent + (_70 - 1) * $_.extratextlinegaps);
    if ($eq($_.extratextxalign, "justify")) {
      if ($ne($_.extratextdirection, "forward") && $ne($_.extratextdirection, "backward")) {
        $k[$j++] = "bwipp.extratextxjustify#33942";
        $k[$j++] = "extratextxalign=justify requires forward or backward text";
        bwipp_raiseerror();
      }
      if ($_.textwidth < $_.pixx) {
        $_.extratextgaps = $f($_.pixx - $_.textwidth) / ($_.extratext.length - 1);
        $k[$j++] = "extratextxalign";
        if ($eq($_.extratextdirection, "forward")) {
          $k[$j++] = "left";
        } else {
          $k[$j++] = "right";
        }
        var _7C = $k[--$j];
        $_[$k[--$j]] = _7C;
      } else {
        $_.extratextgaps = 0;
        $_.extratextxalign = "center";
      }
    }
    if ($eq($_.extratextyalign, "justify")) {
      if ($ne($_.extratextdirection, "upward") && $ne($_.extratextdirection, "downward")) {
        $k[$j++] = "bwipp.extratextyjustify#33955";
        $k[$j++] = "extratextyalign=justify requires upward or downward text";
        bwipp_raiseerror();
      }
      if ($_.textwidth < $_.pixy) {
        $_.extratextgaps = $f($_.pixy - $_.textwidth) / ($_.extratext.length - 1);
        $k[$j++] = "extratextyalign";
        if ($eq($_.extratextdirection, "upward")) {
          $k[$j++] = "bottom";
        } else {
          $k[$j++] = "top";
        }
        var _7N = $k[--$j];
        $_[$k[--$j]] = _7N;
      } else {
        $_.extratextgaps = 0;
        $_.extratextyalign = "center";
      }
    }
    $k[$j++] = $_.extratextxalign;
    $k[$j++] = $_.extratextyalign;
    $k[$j++] = $_.extratextdirection;
    $k[$j++] = $_.textwidth;
    $k[$j++] = $_.textheight;
    $_.positiontext();
    var _7U = $k[--$j];
    $$.moveto($k[--$j], _7U);
    $$.rmoveto($_.extratextxoffset, $_.extratextyoffset);
    $$.save();
    var _7Y = /* @__PURE__ */ new Map([
      ["forward", 0],
      ["upward", 90],
      ["backward", 180],
      ["downward", 270]
    ]);
    $$.rotate($get(_7Y, $_.extratextdirection));
    var _7b = $$.currpos();
    $$.translate(_7b.x, _7b.y);
    for (var _7e = 0, _7d = $_.textlines.length - 1; _7e <= _7d; _7e += 1) {
      $_.i = _7e;
      $$.moveto(0, 0 + $f($_.textascent + $_.extratextlinegaps) * $_.i);
      var _7j = $_.textlines;
      $$.show($get(_7j, _7j.length - $_.i - 1), $_.extratextgaps, 0);
    }
    $$.restore();
  }
  $$.restore();
  $_ = $__;
}
function bwipp_renmaximatrix() {
  if ($_.bwipjs_rawstack) {
    $_.bwipjs_rawstack.push($k[--$j]);
    return;
  }
  var $__ = $_;
  $_ = Object.assign({}, $_);
  $_.barcolor = "unset";
  $_.bordercolor = "unset";
  $_.inkspread = 0;
  $_.showborder = false;
  $_.borderleft = 0;
  $_.borderright = 0;
  $_.bordertop = 0;
  $_.borderbottom = 0;
  $_.borderwidth = 0.25;
  $forall($k[--$j], function() {
    var _1 = $k[--$j];
    $_[$k[--$j]] = _1;
  });
  $k[$j++] = $_.opt;
  delete $_["opt"];
  $k[$j++] = $_;
  bwipp_processoptions();
  $j--;
  $$.save();
  if ($_.showborder) {
    $_.tl = $a([-$f($_.borderleft + $_.borderwidth / 2), $f(29 + $_.bordertop + $_.borderwidth / 2)]);
    $_.tr = $a([$f(30 + $_.borderright + $_.borderwidth / 2), $f(29 + $_.bordertop + $_.borderwidth / 2)]);
    $_.bl = $a([-$f($_.borderleft + $_.borderwidth / 2), -$f($_.borderbottom + $_.borderwidth / 2)]);
    $_.br = $a([$f(30 + $_.borderright + $_.borderwidth / 2), -$f($_.borderbottom + $_.borderwidth / 2)]);
  } else {
    $_.tl = $a([-$_.borderleft + $_.inkspread, 29 + $_.bordertop - $_.inkspread]);
    $_.tr = $a([30 + $_.borderright - $_.inkspread, 29 + $_.bordertop - $_.inkspread]);
    $_.bl = $a([-$_.borderleft + $_.inkspread, -$_.borderbottom + $_.inkspread]);
    $_.br = $a([30 + $_.borderright - $_.inkspread, -$_.borderbottom + $_.inkspread]);
  }
  if ($_.showborder) {
    $$.save();
    $$.newpath();
    $aload($_.bl);
    var _l = $k[--$j];
    $$.moveto($k[--$j], _l);
    var _q = $a([$_.br, $_.tr, $_.tl]);
    for (var _r = 0, _s = _q.length; _r < _s; _r++) {
      $aload($get(_q, _r));
      var _u = $k[--$j];
      $$.lineto($k[--$j], _u);
    }
    $$.closepath();
    if ($ne($_.bordercolor, "unset")) {
      $$.setcolor($_.bordercolor);
    }
    $$.setlinewidth($f($_.borderwidth - $_.inkspread * 2));
    $$.stroke();
    $$.restore();
  }
  if ($ne($_.barcolor, "unset")) {
    $$.setcolor($_.barcolor);
  }
  $$.showmaxicode($_.pixs);
  $$.restore();
  $_ = $__;
}
function bwipp_encode(bwipjs2, encoder2, text, opts, dontdraw) {
  if (typeof text !== "string") {
    throw new Error("bwipp.typeError: barcode text not a string (" + text + ")");
  }
  opts = opts || {};
  if (typeof opts === "string") {
    var tmp = opts.split(" ");
    opts = {};
    for (var i = 0; i < tmp.length; i++) {
      if (!tmp[i]) {
        continue;
      }
      var eq = tmp[i].indexOf("=");
      if (eq == -1) {
        if (tmp[i][0] == "!") {
          opts[tmp[i].substr(1)] = false;
        } else {
          opts[tmp[i]] = true;
        }
      } else {
        opts[tmp[i].substr(0, eq)] = tmp[i].substr(eq + 1);
      }
    }
  } else if (typeof opts !== "object" || opts.constructor !== Object) {
    throw new Error("bwipp.typeError: options not an object");
  }
  if (opts.binarytext) {
    if (/[\u0100-\uffff]/.test(text)) {
      throw new Error("bwip-js: 16-bit chars not allowed with binarytext");
    }
  } else if (/[\u0080-\uffff]/.test(text)) {
    text = unescape(encodeURIComponent(text));
  }
  var map = /* @__PURE__ */ new Map();
  for (var id in opts) {
    if (opts.hasOwnProperty(id)) {
      map.set(id, opts[id]);
    }
  }
  $$ = bwipjs2;
  $k = [text, map];
  $j = 2;
  $_ = {
    bwipjs_rawstack: opts.dontdraw || dontdraw ? [] : false
  };
  encoder2();
  if ($_.bwipjs_rawstack) {
    return $_.bwipjs_rawstack;
  }
  return true;
}
function bwipp_lookup(symbol) {
  if (!symbol) {
    throw new Error("bwipp.undefinedEncoder: bcid is not defined");
  }
  switch (symbol.replace(/-/g, "_")) {
    case "auspost":
      return bwipp_auspost;
    case "azteccode":
      return bwipp_azteccode;
    case "azteccodecompact":
      return bwipp_azteccodecompact;
    case "aztecrune":
      return bwipp_aztecrune;
    case "bc412":
      return bwipp_bc412;
    case "channelcode":
      return bwipp_channelcode;
    case "codablockf":
      return bwipp_codablockf;
    case "code11":
      return bwipp_code11;
    case "code128":
      return bwipp_code128;
    case "code16k":
      return bwipp_code16k;
    case "code2of5":
      return bwipp_code2of5;
    case "code32":
      return bwipp_code32;
    case "code39":
      return bwipp_code39;
    case "code39ext":
      return bwipp_code39ext;
    case "code49":
      return bwipp_code49;
    case "code93":
      return bwipp_code93;
    case "code93ext":
      return bwipp_code93ext;
    case "codeone":
      return bwipp_codeone;
    case "coop2of5":
      return bwipp_coop2of5;
    case "daft":
      return bwipp_daft;
    case "databarexpanded":
      return bwipp_databarexpanded;
    case "databarexpandedcomposite":
      return bwipp_databarexpandedcomposite;
    case "databarexpandedstacked":
      return bwipp_databarexpandedstacked;
    case "databarexpandedstackedcomposite":
      return bwipp_databarexpandedstackedcomposite;
    case "databarlimited":
      return bwipp_databarlimited;
    case "databarlimitedcomposite":
      return bwipp_databarlimitedcomposite;
    case "databaromni":
      return bwipp_databaromni;
    case "databaromnicomposite":
      return bwipp_databaromnicomposite;
    case "databarstacked":
      return bwipp_databarstacked;
    case "databarstackedcomposite":
      return bwipp_databarstackedcomposite;
    case "databarstackedomni":
      return bwipp_databarstackedomni;
    case "databarstackedomnicomposite":
      return bwipp_databarstackedomnicomposite;
    case "databartruncated":
      return bwipp_databartruncated;
    case "databartruncatedcomposite":
      return bwipp_databartruncatedcomposite;
    case "datalogic2of5":
      return bwipp_datalogic2of5;
    case "datamatrix":
      return bwipp_datamatrix;
    case "datamatrixrectangular":
      return bwipp_datamatrixrectangular;
    case "datamatrixrectangularextension":
      return bwipp_datamatrixrectangularextension;
    case "dotcode":
      return bwipp_dotcode;
    case "ean13":
      return bwipp_ean13;
    case "ean13composite":
      return bwipp_ean13composite;
    case "ean14":
      return bwipp_ean14;
    case "ean2":
      return bwipp_ean2;
    case "ean5":
      return bwipp_ean5;
    case "ean8":
      return bwipp_ean8;
    case "ean8composite":
      return bwipp_ean8composite;
    case "flattermarken":
      return bwipp_flattermarken;
    case "gs1_128":
      return bwipp_gs1_128;
    case "gs1_128composite":
      return bwipp_gs1_128composite;
    case "gs1_cc":
      return bwipp_gs1_cc;
    case "gs1datamatrix":
      return bwipp_gs1datamatrix;
    case "gs1datamatrixrectangular":
      return bwipp_gs1datamatrixrectangular;
    case "gs1dldatamatrix":
      return bwipp_gs1dldatamatrix;
    case "gs1dlqrcode":
      return bwipp_gs1dlqrcode;
    case "gs1dotcode":
      return bwipp_gs1dotcode;
    case "gs1northamericancoupon":
      return bwipp_gs1northamericancoupon;
    case "gs1qrcode":
      return bwipp_gs1qrcode;
    case "hanxin":
      return bwipp_hanxin;
    case "hibcazteccode":
      return bwipp_hibcazteccode;
    case "hibccodablockf":
      return bwipp_hibccodablockf;
    case "hibccode128":
      return bwipp_hibccode128;
    case "hibccode39":
      return bwipp_hibccode39;
    case "hibcdatamatrix":
      return bwipp_hibcdatamatrix;
    case "hibcdatamatrixrectangular":
      return bwipp_hibcdatamatrixrectangular;
    case "hibcmicropdf417":
      return bwipp_hibcmicropdf417;
    case "hibcpdf417":
      return bwipp_hibcpdf417;
    case "hibcqrcode":
      return bwipp_hibcqrcode;
    case "iata2of5":
      return bwipp_iata2of5;
    case "identcode":
      return bwipp_identcode;
    case "industrial2of5":
      return bwipp_industrial2of5;
    case "interleaved2of5":
      return bwipp_interleaved2of5;
    case "isbn":
      return bwipp_isbn;
    case "ismn":
      return bwipp_ismn;
    case "issn":
      return bwipp_issn;
    case "itf14":
      return bwipp_itf14;
    case "jabcode":
      return bwipp_jabcode;
    case "japanpost":
      return bwipp_japanpost;
    case "kix":
      return bwipp_kix;
    case "leitcode":
      return bwipp_leitcode;
    case "mailmark":
      return bwipp_mailmark;
    case "mands":
      return bwipp_mands;
    case "matrix2of5":
      return bwipp_matrix2of5;
    case "maxicode":
      return bwipp_maxicode;
    case "micropdf417":
      return bwipp_micropdf417;
    case "microqrcode":
      return bwipp_microqrcode;
    case "msi":
      return bwipp_msi;
    case "onecode":
      return bwipp_onecode;
    case "pdf417":
      return bwipp_pdf417;
    case "pdf417compact":
      return bwipp_pdf417compact;
    case "pharmacode":
      return bwipp_pharmacode;
    case "pharmacode2":
      return bwipp_pharmacode2;
    case "planet":
      return bwipp_planet;
    case "plessey":
      return bwipp_plessey;
    case "posicode":
      return bwipp_posicode;
    case "postnet":
      return bwipp_postnet;
    case "pzn":
      return bwipp_pzn;
    case "qrcode":
      return bwipp_qrcode;
    case "rationalizedCodabar":
      return bwipp_rationalizedCodabar;
    case "raw":
      return bwipp_raw;
    case "rectangularmicroqrcode":
      return bwipp_rectangularmicroqrcode;
    case "royalmail":
      return bwipp_royalmail;
    case "sscc18":
      return bwipp_sscc18;
    case "swissqrcode":
      return bwipp_swissqrcode;
    case "symbol":
      return bwipp_symbol;
    case "telepen":
      return bwipp_telepen;
    case "telepennumeric":
      return bwipp_telepennumeric;
    case "ultracode":
      return bwipp_ultracode;
    case "upca":
      return bwipp_upca;
    case "upcacomposite":
      return bwipp_upcacomposite;
    case "upce":
      return bwipp_upce;
    case "upcecomposite":
      return bwipp_upcecomposite;
  }
  throw new Error("bwipp.unknownEncoder: unknown encoder name: " + symbol);
}
var BWIPP_VERSION = "2025-10-24";
const BWIPJS_VERSION = "4.8.0 (2025-11-11)";
function Request(req, res, extra) {
  var opts = require$$0$7.parse(req.url, true).query;
  for (var id in opts) {
    if (opts[id] === "") {
      if (id[0] == "!") {
        opts[id.substr(1)] = false;
      } else {
        opts[id] = true;
      }
    }
  }
  if (extra) {
    for (var id in extra) {
      opts[id] = extra[id];
    }
  }
  ToBuffer(opts, function(err, png2) {
    if (err) {
      res.writeHead(400, { "Content-Type": "text/plain" });
      res.end("" + (err.stack || err), "utf-8");
    } else {
      res.writeHead(200, { "Content-Type": "image/png" });
      res.end(png2, "binary");
    }
  });
}
function ToBuffer(opts, callback) {
  return _ToAny(bwipp_lookup(opts.bcid), opts, callback);
}
function _ToAny(encoder2, opts, drawing) {
  var callback;
  if (typeof drawing == "function") {
    callback = drawing;
    drawing = null;
  }
  if (drawing) {
    return _Render(encoder2, opts, drawing);
  } else if (callback) {
    try {
      _Render(encoder2, opts, DrawingZlibPng(callback));
    } catch (e) {
      callback(e);
    }
  } else {
    return new Promise(function(resolve, reject) {
      _Render(encoder2, opts, DrawingZlibPng(function(err, buf) {
        err ? reject(err) : resolve(buf);
      }));
    });
  }
}
function ToSVG(opts) {
  return _Render(bwipp_lookup(opts.bcid), opts, DrawingSVG());
}
function FixupOptions(opts) {
  var scale = opts.scale || 2;
  var scaleX = +opts.scaleX || scale;
  var scaleY = +opts.scaleY || scaleX;
  opts.paddingleft = padding(opts.paddingleft, opts.paddingwidth, opts.padding, scaleX);
  opts.paddingright = padding(opts.paddingright, opts.paddingwidth, opts.padding, scaleX);
  opts.paddingtop = padding(opts.paddingtop, opts.paddingheight, opts.padding, scaleY);
  opts.paddingbottom = padding(opts.paddingbottom, opts.paddingheight, opts.padding, scaleY);
  if (opts.backgroundcolor) {
    var bgc = "" + opts.backgroundcolor;
    if (/^[0-9a-fA-F]{8}$/.test(bgc)) {
      var c = parseInt(bgc.substr(0, 2), 16) / 255;
      var m = parseInt(bgc.substr(2, 2), 16) / 255;
      var y = parseInt(bgc.substr(4, 2), 16) / 255;
      var k = parseInt(bgc.substr(6, 2), 16) / 255;
      var r = Math.floor((1 - c) * (1 - k) * 255).toString(16);
      var g = Math.floor((1 - m) * (1 - k) * 255).toString(16);
      var b = Math.floor((1 - y) * (1 - k) * 255).toString(16);
      opts.backgroundcolor = (r.length == 1 ? "0" : "") + r + (g.length == 1 ? "0" : "") + g + (b.length == 1 ? "0" : "") + b;
    } else {
      if (bgc[0] == "#") {
        bgc = bgc.substr(1);
      }
      if (/^[0-9a-fA-F]{6}$/.test(bgc)) {
        opts.backgroundcolor = bgc;
      } else if (/^[0-9a-fA-F]{3}$/.test(bgc)) {
        opts.backgroundcolor = bgc[0] + bgc[0] + bgc[1] + bgc[1] + bgc[2] + bgc[2];
      } else {
        throw new Error("bwip-js: invalid backgroundcolor: " + opts.backgroundcolor);
      }
    }
  }
  return opts;
  function padding(a, b2, c2, s) {
    if (a != null) {
      a = a >>> 0;
      return a * s >>> 0;
    }
    if (b2 != null) {
      b2 = b2 >>> 0;
      return b2 * s >>> 0;
    }
    c2 = c2 >>> 0;
    return c2 * s >>> 0 || 0;
  }
}
var BWIPJS_OPTIONS = {
  bcid: 1,
  text: 1,
  scale: 1,
  scaleX: 1,
  scaleY: 1,
  rotate: 1,
  padding: 1,
  paddingwidth: 1,
  paddingheight: 1,
  paddingtop: 1,
  paddingleft: 1,
  paddingright: 1,
  paddingbottom: 1,
  backgroundcolor: 1
};
function Render(options, drawing) {
  return _Render(bwipp_lookup(options.bcid), options, drawing);
}
function _Render(encoder2, options, drawing) {
  var text = options.text;
  if (!text) {
    throw new ReferenceError("bwip-js: bar code text not specified.");
  }
  FixupOptions(options);
  drawing.setopts && drawing.setopts(options);
  var scale = options.scale || 2;
  var scaleX = +options.scaleX || scale;
  var scaleY = +options.scaleY || scaleX;
  options.rotate || "N";
  var bw = new BWIPJS(drawing);
  var bwippopts = {};
  for (var id in options) {
    if (!BWIPJS_OPTIONS[id]) {
      bwippopts[id] = options[id];
    }
  }
  if (bwippopts.alttext) {
    bwippopts.includetext = true;
  }
  if (+bwippopts.height && encoder2 != bwipp_pharmacode2) {
    bwippopts.height = bwippopts.height / 25.4 || 0.5;
  }
  if (+bwippopts.width) {
    bwippopts.width = bwippopts.width / 25.4 || 0;
  }
  bw.scale(scaleX, scaleY);
  bwipp_encode(bw, encoder2, text, bwippopts);
  return bw.render();
}
function ToRaw(bcid, text, options) {
  if (arguments.length == 1) {
    options = bcid;
    bcid = options.bcid;
    text = options.text;
  }
  var drawing = DrawingBuiltin();
  drawing.setopts(options);
  var bw = new BWIPJS(drawing);
  var stack = bwipp_encode(bw, bwipp_lookup(bcid), text, options, true);
  var ids = { pixs: 1, pixx: 1, pixy: 1, sbs: 1, bbs: 1, bhs: 1, width: 1, height: 1 };
  for (var i = 0; i < stack.length; i++) {
    var elt = stack[i];
    if (elt instanceof Map) {
      var obj = {};
      for (var keys = elt.keys(), size = elt.size, k = 0; k < size; k++) {
        var id = keys.next().value;
        if (ids[id]) {
          var val = elt.get(id);
          if (val instanceof Array) {
            obj[id] = val.b.slice(val.o, val.o + val.length);
          } else {
            obj[id] = val;
          }
        }
      }
      stack[i] = obj;
    } else {
      stack.splice(i--, 1);
    }
  }
  return stack;
}
var BWIPJS = (function() {
  var floor = Math.floor;
  var round = Math.round;
  var ceil = Math.ceil;
  var min = Math.min;
  var max = Math.max;
  function BWIPJS2(drawing) {
    if (this.constructor !== BWIPJS2) {
      return new BWIPJS2(drawing);
    }
    this.gstk = [];
    this.cmds = [];
    this.drawing = drawing;
    this.reset();
    this.minx = this.miny = Infinity;
    this.maxx = this.maxy = -Infinity;
  }
  BWIPJS2.prototype.reset = function() {
    this.g_m0 = 1;
    this.g_m1 = 0;
    this.g_m2 = 0;
    this.g_m3 = 1;
    this.g_m4 = 0;
    this.g_m5 = 0;
    this.g_tsx = 1;
    this.g_tsy = 1;
    this.g_rot = 0;
    this.g_posx = 0;
    this.g_posy = 0;
    this.g_penw = 1;
    this.g_path = [];
    this.g_font = null;
    this.g_rgb = [0, 0, 0];
    this.g_clip = false;
  };
  BWIPJS2.prototype.save = function() {
    var ctx = {};
    for (var id in this) {
      if (id.indexOf("g_") == 0) {
        ctx[id] = clone(this[id]);
      }
    }
    this.gstk.push(ctx);
    function clone(v) {
      if (v instanceof Array) {
        var t = [];
        for (var i = 0; i < v.length; i++)
          t[i] = clone(v[i]);
        return t;
      }
      if (v instanceof Object) {
        var t = {};
        for (var id2 in v)
          t[id2] = clone(v[id2]);
        return t;
      }
      return v;
    }
  };
  BWIPJS2.prototype.restore = function() {
    if (!this.gstk.length) {
      throw new Error("grestore: stack underflow");
    }
    var ctx = this.gstk.pop();
    var self2 = this;
    if (this.g_clip && !ctx.g_clip) {
      this.cmds.push(function() {
        self2.drawing.unclip();
      });
    }
    for (var id in ctx) {
      this[id] = ctx[id];
    }
  };
  BWIPJS2.prototype.currpos = function() {
    return {
      x: (this.g_posx - this.g_m4) / this.g_tsx,
      y: (this.g_posy - this.g_m5) / this.g_tsy
    };
  };
  BWIPJS2.prototype.currfont = function() {
    return this.g_font;
  };
  BWIPJS2.prototype.rotate = function(rot) {
    this.g_rot += rot;
    var cos = round(Math.cos(rot * Math.PI / 180));
    var sin = round(Math.sin(rot * Math.PI / 180));
    var m0 = this.g_m0 * cos + this.g_m2 * sin;
    var m1 = this.g_m1 * cos + this.g_m3 * sin;
    var m2 = this.g_m0 * -sin + this.g_m2 * cos;
    var m3 = this.g_m1 * -sin + this.g_m3 * cos;
    this.g_m0 = m0;
    this.g_m1 = m1;
    this.g_m2 = m2;
    this.g_m3 = m3;
  };
  BWIPJS2.prototype.translate = function(x, y) {
    this.g_m4 += this.g_tsx * x;
    this.g_m5 += this.g_tsy * y;
  };
  BWIPJS2.prototype.scale = function(x, y) {
    var sx = this.g_tsx;
    var sy = this.g_tsy;
    this.g_tsx *= x;
    this.g_tsy *= y;
    var sxy = this.drawing.scale(this.g_tsx, this.g_tsy);
    if (sxy && sxy[0] && sxy[1]) {
      this.g_tsx = sxy[0];
      this.g_tsy = sxy[1];
    }
    this.g_m0 *= this.g_tsx / sx;
    this.g_m1 *= this.g_tsx / sx;
    this.g_m2 *= this.g_tsy / sy;
    this.g_m3 *= this.g_tsy / sy;
  };
  BWIPJS2.prototype.setlinewidth = function(w) {
    this.g_penw = w;
  };
  BWIPJS2.prototype.selectfont = function(f, z) {
    this.g_font = { FontName: this.jsstring(f), FontSize: +z };
  };
  BWIPJS2.prototype.getfont = function() {
    return this.g_font.FontName;
  };
  BWIPJS2.prototype.jsstring = function(s) {
    if (s instanceof Uint8Array) {
      return String.fromCharCode.apply(null, s);
    }
    return "" + s;
  };
  BWIPJS2.prototype.setcolor = function(s) {
    if (s instanceof Uint8Array) {
      s = this.jsstring(s);
    }
    if (!s) {
      return;
    }
    if (!/^(?:#?[0-9a-fA-F]{3}(?:[0-9a-fA-F]{3})?|[0-9a-fA-F]{8})$/.test(s)) {
      throw new Error("bwip-js: invalid color: " + s);
    }
    if (s[0] == "#") {
      s = s.substr(1);
    }
    if (s.length == 3) {
      var r = parseInt(s[0], 16);
      var g = parseInt(s[1], 16);
      var b = parseInt(s[2], 16);
      this.g_rgb = [r << 4 | r, g << 4 | g, b << 4 | b];
    } else if (s.length == 6) {
      var r = parseInt(s.substr(0, 2), 16);
      var g = parseInt(s.substr(2, 2), 16);
      var b = parseInt(s.substr(4, 2), 16);
      this.g_rgb = [r, g, b];
    } else {
      var c = parseInt(s.substr(0, 2), 16) / 255;
      var m = parseInt(s.substr(2, 2), 16) / 255;
      var y = parseInt(s.substr(4, 2), 16) / 255;
      var k = parseInt(s.substr(6, 2), 16) / 255;
      var r = round((1 - c) * (1 - k) * 255);
      var g = round((1 - m) * (1 - k) * 255);
      var b = round((1 - y) * (1 - k) * 255);
      this.g_rgb = [r, g, b];
    }
  };
  BWIPJS2.prototype.setrgbcolor = function(r, g, b) {
    this.g_rgb = [r, g, b];
  };
  BWIPJS2.prototype.getRGB = function() {
    var r = this.g_rgb[0].toString(16);
    var g = this.g_rgb[1].toString(16);
    var b = this.g_rgb[2].toString(16);
    return "00".substr(r.length) + r + "00".substr(g.length) + g + "00".substr(b.length) + b;
  };
  BWIPJS2.prototype.newpath = function() {
    this.g_path = [];
  };
  BWIPJS2.prototype.closepath = function() {
    var path = this.g_path;
    var plen = path.length;
    if (!plen) return;
    var f = plen - 1;
    for (; f >= 0 && path[f].op == "l"; f--) ;
    f++;
    if (f < plen - 1) {
      var poly = [];
      var xmin = Infinity;
      var ymin = Infinity;
      var xmax = -Infinity;
      var ymax = -Infinity;
      for (var i = f; i < plen; i++) {
        var a = path[i];
        poly.push([a.x0, a.y0]);
        if (xmin > a.x0) xmin = a.x0;
        if (xmax < a.x0) xmax = a.x0;
        if (ymin > a.y0) ymin = a.y0;
        if (ymax < a.y0) ymax = a.y0;
      }
      var a = path[plen - 1];
      var b = path[f];
      if (a.x1 != b.x0 || a.y1 != b.y0) {
        poly.push([a.x1, a.y1]);
        if (xmin > a.x1) xmin = a.x1;
        if (xmax < a.x1) xmax = a.x1;
        if (ymin > a.y1) ymin = a.y1;
        if (ymax < a.y1) ymax = a.y1;
      }
      path.splice(
        f,
        plen - f,
        { op: "p", x0: xmin, y0: ymin, x1: xmax, y1: ymax, poly }
      );
    } else {
      path.push({ op: "c" });
    }
  };
  BWIPJS2.prototype.moveto = function(x, y) {
    this.g_posx = this.g_m0 * x + this.g_m2 * y + this.g_m4;
    this.g_posy = this.g_m1 * x + this.g_m3 * y + this.g_m5;
  };
  BWIPJS2.prototype.rmoveto = function(x, y) {
    this.g_posx += this.g_m0 * x + this.g_m2 * y + this.g_m4;
    this.g_posy += this.g_m1 * x + this.g_m3 * y + this.g_m5;
  };
  BWIPJS2.prototype.lineto = function(x, y) {
    var x0 = round(this.g_posx);
    var y0 = round(this.g_posy);
    this.g_posx = this.g_m0 * x + this.g_m2 * y + this.g_m4;
    this.g_posy = this.g_m1 * x + this.g_m3 * y + this.g_m5;
    var x1 = round(this.g_posx);
    var y1 = round(this.g_posy);
    this.g_path.push({ op: "l", x0, y0, x1, y1 });
  };
  BWIPJS2.prototype.rlineto = function(x, y) {
    var x0 = round(this.g_posx);
    var y0 = round(this.g_posy);
    this.g_posx += this.g_m0 * x + this.g_m2 * y + this.g_m4;
    this.g_posy += this.g_m1 * x + this.g_m3 * y + this.g_m5;
    var x1 = round(this.g_posx);
    var y1 = round(this.g_posy);
    this.g_path.push({ op: "l", x0, y0, x1, y1 });
  };
  BWIPJS2.prototype.arc = function(x, y, r, sa, ea, ccw) {
    if (sa == ea) {
      return;
    }
    if (sa != 0 && sa != 360 || ea != 0 && ea != 360) {
      throw new Error("arc: not a full circle (" + sa + "," + ea + ")");
    }
    var xx = this.g_m0 * x + this.g_m2 * y + this.g_m4;
    var yy = this.g_m1 * x + this.g_m3 * y + this.g_m5;
    var rx = r * this.g_tsx;
    var ry = r * this.g_tsy;
    this.g_path.push({
      op: "e",
      x0: xx - rx,
      y0: yy - ry,
      x1: xx + rx,
      y1: yy + ry,
      x: xx,
      y: yy,
      rx,
      ry,
      sa,
      ea,
      ccw
    });
  };
  BWIPJS2.prototype.stringwidth = function(str) {
    var tsx = this.g_tsx;
    var tsy = this.g_tsy;
    var size = +this.g_font.FontSize || 10;
    str = this.toUCS2(this.jsstring(str));
    var bbox = this.drawing.measure(str, this.g_font.FontName, size * tsx, size * tsy);
    return {
      w: bbox.width / tsx,
      h: (bbox.ascent + bbox.descent) / tsy,
      a: bbox.ascent / tsy,
      d: bbox.descent / tsy
    };
  };
  BWIPJS2.prototype.charpath = function(str, b) {
    var sw = this.stringwidth(str);
    this.rlineto(0, sw.a);
    this.rlineto(sw.w, 0);
    this.rlineto(0, -sw.h);
  };
  BWIPJS2.prototype.pathbbox = function() {
    if (!this.g_path.length) throw new Error("pathbbox: --nocurrentpoint--");
    var path = this.g_path;
    var llx = Infinity;
    var lly = Infinity;
    var urx = -Infinity;
    var ury = -Infinity;
    for (var i = 0; i < path.length; i++) {
      var a = path[i];
      if (a.op == "c") {
        continue;
      }
      if (a.x0 < a.x1) {
        if (llx > a.x0) llx = a.x0;
        if (urx < a.x1) urx = a.x1;
      } else {
        if (llx > a.x1) llx = a.x1;
        if (urx < a.x0) urx = a.x0;
      }
      if (a.y0 < a.y1) {
        if (lly > a.y0) lly = a.y0;
        if (ury < a.y1) ury = a.y1;
      } else {
        if (lly > a.y1) lly = a.y1;
        if (ury < a.y0) ury = a.y0;
      }
    }
    var rv = {
      llx: (llx - this.g_m4) / this.g_tsx,
      lly: (lly - this.g_m5) / this.g_tsy,
      urx: (urx - this.g_m4) / this.g_tsx,
      ury: (ury - this.g_m5) / this.g_tsy
    };
    return rv;
  };
  BWIPJS2.prototype.transform = function(pts) {
    var minx = this.minx;
    var maxy = this.maxy;
    for (var i = 0; i < pts.length; i++) {
      var pt = pts[i];
      pt[0] = pt[0] - minx;
      pt[1] = maxy - pt[1];
    }
  };
  BWIPJS2.prototype.stroke = function() {
    var tsx = this.g_tsx;
    var tsy = this.g_tsy;
    var path = this.g_path;
    var rgb = this.getRGB();
    this.g_path = [];
    var penw = floor(this.g_penw * tsx + 0.66);
    var penh = floor(this.g_penw * tsy + 0.66);
    for (var i = 0; i < path.length; i++) {
      var a = path[i];
      if (a.op == "l") {
        if (a.x0 != a.x1 && a.y0 != a.y1) {
          throw new Error("stroke: --not-orthogonal--");
        }
        var x0 = a.x0;
        var y0 = a.y0;
        var x1 = a.x1;
        var y1 = a.y1;
        var penw2 = penw / 2;
        var penh2 = penh / 2;
        if (x0 > x1) {
          var t = x0;
          x0 = x1;
          x1 = t;
        }
        if (y0 > y1) {
          var t = y0;
          y0 = y1;
          y1 = t;
        }
        if (x0 == x1) {
          this.bbox(x0 - penw2, y0, x0 + penw - penw2 - 1, y1);
        } else {
          this.bbox(x0, y0 - penh + penh2 + 1, x1, y1 + penh2);
        }
      } else if (a.op == "p") {
        var minx = Infinity;
        var miny = Infinity;
        var maxx = -Infinity;
        var maxy = -Infinity;
        var pts = a.poly;
        if (pts.length != 4) {
          throw new Error("stroke: --not-a-rect--");
        }
        for (var i = 0, j = pts.length - 1; i < pts.length; j = i++) {
          var xj = pts[j][0];
          var yj = pts[j][1];
          var xi = pts[i][0];
          var yi = pts[i][1];
          if (xi != xj && yi != yj) {
            throw new Error("stroke: --not-orthogonal--");
          }
          if (xi < minx) minx = xi;
          if (xi > maxx) maxx = xi;
          if (yi < miny) miny = yi;
          if (yi > maxy) maxy = yi;
        }
        var penw2 = ceil(penw / 2);
        var penh2 = ceil(penh / 2);
        this.bbox(minx - penw2, miny - penh2, maxx + penw2, maxy + penh2);
      } else {
        throw new Error("stroke: --not-a-line--");
      }
    }
    var self2 = this;
    this.cmds.push(function() {
      var bigw2 = ceil(penw / 2);
      var bigh2 = ceil(penh / 2);
      var remw2 = penw - bigw2;
      var remh2 = penh - bigh2;
      for (var i2 = 0; i2 < path.length; i2++) {
        var a2 = path[i2];
        if (a2.op == "l") {
          var pts2 = [[a2.x0, a2.y0], [a2.x1, a2.y1]];
          self2.transform(pts2);
          self2.drawing.line(
            pts2[0][0],
            pts2[0][1],
            pts2[1][0],
            pts2[1][1],
            a2.x0 == a2.x1 ? penw : penh,
            rgb
          );
          self2.fill(rgb);
        } else {
          var pts2 = a2.poly;
          self2.transform(pts2);
          var x02 = min(pts2[0][0], pts2[2][0]);
          var x12 = max(pts2[0][0], pts2[2][0]);
          var y02 = min(pts2[0][1], pts2[2][1]);
          var y12 = max(pts2[0][1], pts2[2][1]);
          self2.drawing.polygon([
            [x02 - bigw2, y02 - bigh2],
            [x02 - bigw2, y12 + bigh2 + 1],
            [x12 + bigw2 + 1, y12 + bigh2 + 1],
            [x12 + bigw2 + 1, y02 - bigh2]
          ]);
          self2.drawing.polygon([
            [x02 + remw2, y02 + remh2],
            [x12 - remw2 + 1, y02 + remh2],
            [x12 - remw2 + 1, y12 - remh2 + 1],
            [x02 + remw2, y12 - remh2 + 1]
          ]);
          self2.drawing.fill(rgb);
        }
      }
    });
  };
  BWIPJS2.prototype.fill = function() {
    var path = this.g_path;
    var rgb = this.getRGB();
    this.g_path = [];
    for (var p = 0; p < path.length; p++) {
      var a = path[p];
      if (a.op == "p") {
        var minx = Infinity;
        var miny = Infinity;
        var maxx = -Infinity;
        var maxy = -Infinity;
        var pts = a.poly;
        for (var i = 0; i < pts.length; i++) {
          var xi = pts[i][0];
          var yi = pts[i][1];
          if (xi < minx) minx = xi;
          if (xi > maxx) maxx = xi;
          if (yi < miny) miny = yi;
          if (yi > maxy) maxy = yi;
        }
        this.bbox(minx, miny + 1, maxx - 1, maxy);
      } else if (a.op == "e") {
        this.bbox(a.x - a.rx, a.y - a.ry, a.x + a.rx, a.y + a.ry);
      } else {
        throw new Error("fill: --not-a-polygon--");
      }
    }
    var self2 = this;
    this.cmds.push(function() {
      for (var i2 = 0; i2 < path.length; i2++) {
        var a2 = path[i2];
        if (a2.op == "p") {
          var pts2 = a2.poly;
          self2.transform(pts2);
          self2.drawing.polygon(pts2);
        } else if (a2.op == "e") {
          var pts2 = [[a2.x, a2.y]];
          self2.transform(pts2);
          self2.drawing.ellipse(pts2[0][0], pts2[0][1], a2.rx, a2.ry, a2.ccw);
        }
      }
      self2.drawing.fill(rgb);
    });
  };
  BWIPJS2.prototype.clip = function() {
    var path = this.g_path;
    this.g_path = [];
    this.g_clip = true;
    var self2 = this;
    this.cmds.push(function() {
      var polys = [];
      for (var i = 0; i < path.length; i++) {
        var a = path[i];
        if (a.op == "p") {
          var pts = a.poly;
          self2.transform(pts);
          polys.push(pts);
        } else {
          throw new Error("clip: only polygon regions supported");
        }
      }
      self2.drawing.clip(polys);
    });
  };
  BWIPJS2.prototype.drawlayer = function(pix, width, height) {
    let paths = tracepaths(pix, width, height);
    this.newpath();
    for (let i = 0, il = paths.length; i < il; i++) {
      let path = paths[i];
      this.moveto(path[0][0], path[0][1]);
      for (let j = 1, jl = path.length; j < jl; j++) {
        let pt = path[j];
        this.lineto(pt[0], pt[1]);
      }
      this.closepath();
    }
    this.fill();
  };
  BWIPJS2.prototype.showmaxicode = function(pix) {
    var tsx = this.g_tsx;
    var tsy = this.g_tsy;
    var rgb = this.getRGB();
    var twidth = 1.04 * tsx * 100;
    var mwidth = twidth / 30 | 0;
    if (twidth - (mwidth * 30 - 1) > 9) {
      mwidth++;
    }
    var w, h, wgap, hgap;
    wgap = tsx / 2 | 0;
    hgap = tsy / 2 | 0;
    w = mwidth - wgap;
    if (w & 1) {
      w--;
    }
    h = (4 * tsy | 0) - hgap;
    var w2 = w / 2 - 1;
    var qh = (w2 + 1) / 2 | 0;
    var vh = h - 2 - 2 * qh;
    this.bbox(0, 0, mwidth * 30 - wgap, tsy * 3 * 32 + tsy * 4 - hgap);
    var self2 = this;
    this.cmds.push(function() {
      for (var i = 0; i < pix.length; i++) {
        var c = pix[i];
        var x = c % 30;
        var y = c / 30 | 0;
        x *= mwidth;
        x += y & 1 ? mwidth : mwidth / 2;
        x = x | 0;
        y = 33 - y;
        y *= tsy * 3;
        y += tsy * 2 - h / 2;
        y = y | 0;
        var pts = [[x - 0.5, y--]];
        y -= qh - 1;
        pts.push([x - 1 - w2, y--]);
        y -= vh;
        pts.push([x - 1 - w2, y--]);
        y -= qh - 1;
        pts.push([x - 0.5, y++]);
        y += qh - 1;
        pts.push([x + w2, y++]);
        y += vh;
        pts.push([x + w2, y++]);
        self2.transform(pts);
        self2.drawing.hexagon(pts, rgb);
      }
      self2.drawing.fill(rgb);
      var x = 14 * mwidth + mwidth / 2 + 0.01 | 0;
      var y = (12 * 4 + 3) * tsy - qh / 2 + 0.01 | 0;
      self2.drawing.ellipse(x, y, 0.5774 * 3.5 * tsx + 0.01 | 0, 0.5774 * 3.5 * tsy + 0.01 | 0, true);
      self2.drawing.ellipse(x, y, 1.3359 * 3.5 * tsx + 0.01 | 0, 1.3359 * 3.5 * tsy + 0.01 | 0, false);
      self2.drawing.fill(rgb);
      self2.drawing.ellipse(x, y, 2.1058 * 3.5 * tsx + 0.01 | 0, 2.1058 * 3.5 * tsy + 0.01 | 0, true);
      self2.drawing.ellipse(x, y, 2.8644 * 3.5 * tsx + 0.01 | 0, 2.8644 * 3.5 * tsy + 0.01 | 0, false);
      self2.drawing.fill(rgb);
      self2.drawing.ellipse(x, y, 3.6229 * 3.5 * tsx + 0.01 | 0, 3.6229 * 3.5 * tsy + 0.01 | 0, true);
      self2.drawing.ellipse(x, y, 4.3814 * 3.5 * tsx + 0.01 | 0, 4.3814 * 3.5 * tsy + 0.01 | 0, false);
      self2.drawing.fill(rgb);
    });
  };
  BWIPJS2.prototype.toUCS2 = function(str) {
    return str.replace(
      /[\xc0-\xdf][\x80-\xbf]|[\xe0-\xff][\x80-\xbf]{2}/g,
      function(s) {
        var code;
        if (s.length == 2) {
          code = (s.charCodeAt(0) & 31) << 6 | s.charCodeAt(1) & 63;
        } else {
          code = (s.charCodeAt(0) & 15) << 12 | (s.charCodeAt(1) & 63) << 6 | s.charCodeAt(2) & 63;
        }
        return String.fromCharCode(code);
      }
    );
  };
  BWIPJS2.prototype.show = function(str, dx, dy) {
    if (!str.length) {
      return;
    }
    var rot = this.g_rot;
    var tsx = rot == 90 || rot == 270 ? this.g_tsy : this.g_tsx;
    var tsy = rot == 90 || rot == 270 ? this.g_tsx : this.g_tsy;
    var name = this.g_font.FontName || "OCR-B";
    var size = this.g_font.FontSize || 10;
    var szx = size * tsx;
    var szy = size * tsy;
    var posx = this.g_posx;
    var posy = this.g_posy;
    var rgb = this.getRGB();
    dx = tsx * dx || 0;
    dy = tsy * dy || 0;
    str = this.toUCS2(this.jsstring(str));
    var bbox = this.drawing.measure(str, name, szx, szy);
    var width = bbox.width + (str.length - 1) * dx;
    if (rot == 90) {
      this.bbox(posx - dy + bbox.descent - 1, posy, posx - dy - bbox.ascent, posy + width - 1);
    } else if (rot == 180) {
      this.bbox(posx, posy - dy + bbox.descent - 1, posx - width + 1, posy - dy - bbox.ascent);
    } else if (rot == 270) {
      this.bbox(posx + dy - bbox.descent + 1, posy, posx + dy + bbox.ascent, posy - width + 1);
    } else {
      rot = 0;
      this.bbox(posx, posy + dy - bbox.descent + 1, posx + width - 1, posy + dy + bbox.ascent);
      this.g_posx += width;
    }
    var self2 = this;
    self2.cmds.push(function() {
      var x = posx - self2.minx;
      var y = self2.maxy - posy;
      self2.drawing.text(x, y, str, rgb, { name, width: szx, height: szy, rotate: rot, dx });
    });
  };
  BWIPJS2.prototype.bbox = function(x0, y0, x1, y1) {
    if (x0 > x1) {
      var t = x0;
      x0 = x1;
      x1 = t;
    }
    if (y0 > y1) {
      var t = y0;
      y0 = y1;
      y1 = t;
    }
    x0 = floor(x0);
    y0 = floor(y0);
    x1 = ceil(x1);
    y1 = ceil(y1);
    if (this.minx > x0) this.minx = x0;
    if (this.maxx < x1) this.maxx = x1;
    if (this.miny > y0) this.miny = y0;
    if (this.maxy < y1) this.maxy = y1;
  };
  BWIPJS2.prototype.render = function() {
    if (this.minx === Infinity) {
      return false;
    }
    this.drawing.init(
      this.maxx - this.minx + 1,
      this.maxy - this.miny + 1,
      this.g_tsx,
      this.g_tsy
    );
    for (var i = 0, l = this.cmds.length; i < l; i++) {
      this.cmds[i]();
    }
    return this.drawing.end();
  };
  return BWIPJS2;
})();
function tracepaths(pixs, width, height, inkspreadh, inkspreadv) {
  let dx = 0;
  let dy = 0;
  let grid = new Array(height + 1);
  let yoff = 0;
  for (let y = height - 1; y >= 0; y--) {
    let row = new Uint8Array(width);
    for (let x = 0; x < width; x++) {
      row[x] = pixs[yoff + x] ? 1 : 0;
    }
    grid[y] = row;
    yoff += width;
  }
  grid[-1] = [];
  grid[height] = [];
  let paths = [];
  for (let y = 0; y < height; y++) {
    let last = 0;
    for (let x = 0; x < width; x++) {
      if ((last & 9) == 0 && grid[y][x] == 1) {
        paths.push(tracecw(x, y, []));
      } else if ((last & 5) == 1 && grid[y][x] == 0) {
        paths.push(traceccw(x, y, []));
      }
      last = grid[y][x];
    }
  }
  return paths;
  function tracecw(x, y, path) {
    path.push([x + dx, y + dy]);
    let dir = 2;
    for (; ; ) {
      if (grid[y][x] & dir) {
        path.pop();
        return path;
      }
      grid[y][x] |= dir;
      if (dir == 2) {
        if (grid[y][x + 1] & 1) {
          if (grid[y - 1][x + 1] & 1) {
            path.push([x + 1 - dx, y + dy, "H"]);
            dir = 16;
          }
          x++;
        } else {
          path.push([x + 1 - dx, y + dy, "H"]);
          dir = 4;
        }
      } else if (dir == 4) {
        if (grid[y + 1][x] & 1) {
          if (grid[y + 1][x + 1] & 1) {
            path.push([x + 1 - dx, y + 1 - dy, "V"]);
            dir = 2;
          }
          y++;
        } else {
          path.push([x + 1 - dx, y + 1 - dy, "V"]);
          dir = 8;
        }
      } else if (dir == 8) {
        if (grid[y][x - 1] & 1) {
          if (grid[y + 1][x - 1] & 1) {
            path.push([x + dx, y + 1 - dy, "H"]);
            dir = 4;
          }
          x--;
        } else {
          path.push([x + dx, y + 1 - dy, "H"]);
          dir = 16;
        }
      } else {
        if (grid[y - 1][x] & 1) {
          if (grid[y - 1][x - 1] & 1) {
            path.push([x + dx, y + dy, "V"]);
            dir = 8;
          }
          y--;
        } else {
          path.push([x + dx, y + dy, "V"]);
          dir = 2;
        }
      }
    }
  }
  function traceccw(x, y, path) {
    path.push([x - dx, y - dy]);
    let dir = 2;
    for (; ; ) {
      if (grid[y][x] & dir) {
        path.pop();
        return path;
      }
      grid[y][x] |= dir;
      if (dir == 2) {
        if ((grid[y + 1][x] & 1) == 0) {
          if ((grid[y + 1][x - 1] & 1) == 0) {
            path.push([x - dx, y + 1 + dy]);
            dir = 16;
          }
          y++;
        } else {
          path.push([x - dx, y + 1 + dy]);
          dir = 4;
        }
      } else if (dir == 4) {
        if ((grid[y][x + 1] & 1) == 0) {
          if ((grid[y + 1][x + 1] & 1) == 0) {
            path.push([x + 1 + dx, y + 1 + dy]);
            dir = 2;
          }
          x++;
        } else {
          path.push([x + 1 + dx, y + 1 + dy]);
          dir = 8;
        }
      } else if (dir == 8) {
        if ((grid[y - 1][x] & 1) == 0) {
          if ((grid[y - 1][x + 1] & 1) == 0) {
            path.push([x + 1 + dx, y - dy]);
            dir = 4;
          }
          y--;
        } else {
          path.push([x + 1 + dx, y - dy]);
          dir = 16;
        }
      } else {
        if ((grid[y][x - 1] & 1) == 0) {
          if ((grid[y - 1][x - 1] & 1) == 0) {
            path.push([x - dx, y - dy]);
            dir = 8;
          }
          x--;
        } else {
          path.push([x - dx, y - dy]);
          dir = 2;
        }
      }
    }
  }
}
function DrawingBuiltin() {
  var tx0 = 0, tx1 = 0, tx2 = 0, tx3 = 0;
  var ty0 = 0, ty1 = 0, ty2 = 0, ty3 = 0;
  var opts;
  var gs_image, gs_rowbyte;
  var gs_width, gs_height;
  var gs_dx, gs_dy;
  var gs_r, gs_g, gs_b;
  var gs_xymap;
  var gs_xyclip;
  return {
    // setopts() is called after the options are fixed-up/normalized,
    // but before calling into BWIPP.
    // This method allows omitting the options in the constructor call.
    // The method is optional.
    setopts(options) {
      opts = options;
    },
    // Ensure compliant bar codes by always using integer scaling factors.
    scale: function(sx, sy) {
      if (opts.bcid == "swissqrcode") {
        return [sx, sy];
      } else {
        return [sx | 0 || 1, sy | 0 || 1];
      }
    },
    // Measure text.  This and scale() are the only drawing primitives that
    // are called before init().
    //
    // `font` is the font name typically OCR-A or OCR-B.
    // `fwidth` and `fheight` are the requested font cell size.  They will
    // usually be the same, except when the scaling is not symetric.
    measure: function(str, font, fwidth, fheight) {
      fwidth = fwidth | 0;
      fheight = fheight | 0;
      var fontid = FontLib.lookup(font);
      var width = 0;
      var ascent = 0;
      var descent = 0;
      for (var i = 0, l = str.length; i < l; i++) {
        var ch = str.charCodeAt(i);
        var glyph = FontLib.getglyph(fontid, ch, fwidth, fheight);
        ascent = Math.max(ascent, glyph.top);
        descent = Math.max(descent, glyph.height - glyph.top);
        if (i == l - 1) {
          width += glyph.left + glyph.width;
        } else {
          width += glyph.advance;
        }
      }
      return { width, ascent, descent };
    },
    // width and height represent the maximum bounding box the graphics will occupy.
    // The dimensions are for an unrotated rendering.  Adjust as necessary.
    init: function(width, height) {
      var padl = opts.paddingleft;
      var padr = opts.paddingright;
      var padt = opts.paddingtop;
      var padb = opts.paddingbottom;
      var rot = opts.rotate || "N";
      width += padl + padr;
      height += padt + padb;
      if (+opts.sizelimit && +opts.sizelimit < width * height) {
        throw new Error("Image size over limit");
      }
      switch (rot) {
        // tx = w-y, ty = x
        case "R":
          tx1 = -1;
          tx2 = 1;
          ty0 = 1;
          break;
        // tx = w-x, ty = h-y
        case "I":
          tx0 = -1;
          tx2 = 1;
          ty1 = -1;
          ty3 = 1;
          break;
        // tx = y, ty = h-x
        case "L":
          tx1 = 1;
          ty0 = -1;
          ty3 = 1;
          break;
        // tx = x, ty = y
        default:
          tx0 = ty1 = 1;
          break;
      }
      var swap = rot == "L" || rot == "R";
      gs_width = swap ? height : width;
      gs_height = swap ? width : height;
      gs_dx = padl;
      gs_dy = padt;
      gs_xymap = [];
      gs_xymap.min = Infinity;
      gs_xyclip = null;
      gs_r = gs_g = gs_b = 0;
      var res = this.image(gs_width, gs_height);
      gs_image = res.buffer;
      gs_rowbyte = res.ispng ? 1 : 0;
    },
    // Unconnected stroked lines are used to draw the bars in linear barcodes;
    // and the border around a linear barcode (e.g. ITF-14)
    // No line cap should be applied.  These lines are always orthogonal.
    line: function(x0, y0, x1, y1, lw, rgb) {
      x0 = x0 | 0;
      y0 = y0 | 0;
      x1 = x1 | 0;
      y1 = y1 | 0;
      lw = Math.round(lw) || 1;
      if (y1 < y0) {
        var t = y0;
        y0 = y1;
        y1 = t;
      }
      if (x1 < x0) {
        var t = x0;
        x0 = x1;
        x1 = t;
      }
      gs_r = parseInt(rgb.substr(0, 2), 16);
      gs_g = parseInt(rgb.substr(2, 2), 16);
      gs_b = parseInt(rgb.substr(4, 2), 16);
      var w2 = lw / 2 | 0;
      if (x0 == x1) {
        x0 = x0 - lw + w2;
        x1 = x1 + w2 - 1;
      } else {
        y0 = y0 - w2;
        y1 = y1 + lw - w2 - 1;
      }
      for (var y = y0; y <= y1; y++) {
        for (var x = x0; x <= x1; x++) {
          set(x, y, 255);
        }
      }
    },
    // Polygons are used to draw the connected regions in a 2d barcode.
    // These will always be unstroked, filled, orthogonal shapes.
    //
    // You will see a series of polygon() calls, followed by a fill().
    polygon: function(pts) {
      var npts = pts.length;
      for (var j = npts - 1, i = 0; i < npts; j = i++) {
        if (pts[j][0] == pts[i][0]) {
          var xj = pts[j][0] | 0;
          var yj = pts[j][1] | 0;
          var yi = pts[i][1] | 0;
          if (yj > yi) {
            for (var y = yi + 1; y < yj; y++) {
              addPoint(xj, y);
            }
          } else {
            for (var y = yj + 1; y < yi; y++) {
              addPoint(xj, y);
            }
          }
        } else {
          var xj = pts[j][0] | 0;
          var xi = pts[i][0] | 0;
          var yj = pts[j][1] | 0;
          if (xj < xi) {
            var yl = pts[j == 0 ? npts - 1 : j - 1][1];
            var yr = pts[i == npts - 1 ? 0 : i + 1][1];
            if (yl > yj) {
              addPoint(xj, yj);
            }
            if (yr > yj) {
              addPoint(xi, yj);
            }
          } else {
            var yl = pts[i == npts - 1 ? 0 : i + 1][1];
            var yr = pts[j == 0 ? npts - 1 : j - 1][1];
            if (yl > yj) {
              addPoint(xi, yj);
            }
            if (yr > yj) {
              addPoint(xj, yj);
            }
          }
        }
      }
    },
    // An unstroked, filled hexagon used by maxicode.  You can choose to fill
    // each individually, or wait for the final fill().
    //
    // The hexagon is drawn from the top, counter-clockwise.
    //
    // The X-coordinate for the top and bottom points on the hexagon is always
    // .5 pixels.  We draw our hexagons with a 2 pixel flat top.
    //
    // All other points of the polygon/hexagon are guaranteed to be integer values.
    hexagon: function(pts, rgb) {
      var x = pts[0][0] | 0;
      var y = pts[0][1] | 0;
      var qh = pts[1][1] - pts[0][1] | 0;
      var vh = pts[2][1] - pts[1][1] - 1 | 0;
      var xl = pts[2][0] | 0;
      var xr = pts[4][0] | 0;
      gs_r = parseInt(rgb.substr(0, 2), 16);
      gs_g = parseInt(rgb.substr(2, 2), 16);
      gs_b = parseInt(rgb.substr(4, 2), 16);
      fillSegment(x, x + 1, y++);
      for (var k = 1; k < qh; k++) {
        fillSegment(x - 2 * k, x + 1 + 2 * k, y++);
      }
      for (var k = 0; k <= vh; k++) {
        fillSegment(xl, xr, y++);
      }
      for (var k = qh - 1; k >= 1; k--) {
        fillSegment(x - 2 * k, x + 1 + 2 * k, y++);
      }
      fillSegment(x, x + 1, y);
    },
    // An unstroked, filled ellipse.  Used by dotcode and maxicode at present.
    // maxicode issues pairs of ellipse calls (one cw, one ccw) followed by a fill()
    // to create the bullseye rings.  dotcode issues all of its ellipses then a
    // fill().
    ellipse: function(x, y, rx, ry, ccw) {
      drawEllipse(x - rx | 0, y - ry | 0, x + rx | 0, y + ry | 0);
    },
    // PostScript's default fill rule is non-zero but since there are never
    // intersecting regions, we use the easier to implement even-odd.
    fill: function(rgb) {
      gs_r = parseInt(rgb.substr(0, 2), 16);
      gs_g = parseInt(rgb.substr(2, 2), 16);
      gs_b = parseInt(rgb.substr(4, 2), 16);
      evenodd();
      gs_xymap = [];
      gs_xymap.min = Infinity;
    },
    // Currently only used by swissqrcode.  The `polys` area is an array of
    // arrays of points.  Each array of points is identical to the `pts`
    // parameter passed to polygon().  The postscript default clipping rule,
    // like the fill rule, is even-odd winding.
    clip: function(polys) {
      if (!gs_xyclip) {
        gs_xyclip = [];
        gs_xyclip.min = Infinity;
      }
      var xymap = gs_xymap;
      gs_xymap = gs_xyclip;
      for (var i = 0, l = polys.length; i < l; i++) {
        this.polygon(polys[i]);
      }
      gs_xymap = xymap;
    },
    unclip: function() {
      gs_xyclip = null;
    },
    // Draw text with optional inter-character spacing.  `y` is the baseline.
    // font is an object with properties { name, width, height, rotate, dx }
    // width and height are the font cell size.
    // rotate is one of 0, 90, 180, 270 (default is zero)
    // dx is extra space requested between characters (usually zero).
    text: function(x, y, str, rgb, font) {
      x = x | 0;
      y = y | 0;
      gs_r = parseInt(rgb.substr(0, 2), 16);
      gs_g = parseInt(rgb.substr(2, 2), 16);
      gs_b = parseInt(rgb.substr(4, 2), 16);
      var fontid = FontLib.lookup(font.name);
      var fwidth = font.width | 0;
      var fheight = font.height | 0;
      var dx = font.dx | 0;
      var tx02 = 0, tx12 = 0, ty02 = 0, ty12 = 0;
      switch (font.rotate) {
        case 90:
          tx12 = 1;
          ty02 = -1;
          break;
        case 180:
          tx02 = -1;
          ty12 = -1;
          break;
        case 270:
          tx12 = -1;
          ty02 = 1;
          break;
        default:
          tx02 = 1;
          ty12 = 1;
          break;
      }
      var gx = 0;
      for (var k = 0; k < str.length; k++) {
        var ch = str.charCodeAt(k);
        var glyph = FontLib.getglyph(fontid, ch, fwidth, fheight);
        var gt = -glyph.top;
        var gl = glyph.left;
        var gw = glyph.width;
        var gh = glyph.height;
        var gb = glyph.bytes;
        var go = glyph.offset;
        for (var i = 0; i < gw; i++) {
          for (var j = 0; j < gh; j++) {
            var a = gb[go + j * gw + i];
            if (a) {
              var xx = gx + gl + i;
              var yy = gt + j;
              var tx = tx02 * xx + tx12 * yy;
              var ty = ty02 * xx + ty12 * yy;
              set(x + tx, y + ty, a);
            }
          }
        }
        gx += glyph.advance + dx;
      }
    },
    // Called after all drawing is complete.
    end: function() {
    }
  };
  function set(x, y, a) {
    if (gs_xyclip && clipped(x, y)) {
      return;
    }
    x += gs_dx;
    y += gs_dy;
    var tx = tx0 * x + tx1 * y + tx2 * (gs_width - 1) + tx3 * (gs_height - 1);
    var ty = ty0 * x + ty1 * y + ty2 * (gs_width - 1) + ty3 * (gs_height - 1);
    var offs = (ty * gs_width + tx) * 4 + (ty + 1) * gs_rowbyte;
    var dsta = gs_image[offs + 3] / 255;
    var srca = a / 255;
    var inva = (1 - srca) * dsta;
    var outa = srca + inva;
    gs_image[offs + 0] = (gs_r * srca + gs_image[offs + 0] * inva) / outa | 0;
    gs_image[offs + 1] = (gs_g * srca + gs_image[offs + 1] * inva) / outa | 0;
    gs_image[offs + 2] = (gs_b * srca + gs_image[offs + 2] * inva) / outa | 0;
    gs_image[offs + 3] = 255 * outa | 0;
  }
  function addPoint(x, y) {
    if (gs_xymap.min > y) gs_xymap.min = y;
    if (!gs_xymap[y]) {
      gs_xymap[y] = [x];
    } else {
      gs_xymap[y].push(x);
    }
  }
  function fillSegment(x0, x1, y) {
    while (x0 <= x1) {
      set(x0++, y, 255);
    }
  }
  function evenodd() {
    var ymin = gs_xymap.min;
    var ymax = gs_xymap.length - 1;
    for (var y = ymin; y <= ymax; y++) {
      var pts = gs_xymap[y];
      if (!pts) {
        continue;
      }
      pts.sort(function(a, b) {
        return a - b;
      });
      var wn = false;
      var xl = 0;
      for (var n = 0, npts = pts.length; n < npts; n++) {
        var x = pts[n];
        if (wn) {
          fillSegment(xl, x - 1, y);
        } else {
          xl = x;
        }
        wn = !wn;
      }
    }
  }
  function drawEllipse(x0, y0, x1, y1, dir) {
    x0 = x0 | 0;
    y0 = y0 | 0;
    x1 = x1 | 0;
    y1 = y1 | 0;
    var a = Math.abs(x1 - x0);
    var b = Math.abs(y1 - y0);
    var b1 = b & 1;
    var dx = 4 * (1 - a) * b * b;
    var dy = 4 * (b1 + 1) * a * a;
    var err = dx + dy + b1 * a * a;
    var e2;
    var left = [], right = [];
    left.min = right.min = Infinity;
    if (x0 > x1) {
      x0 = x1;
      x1 += a;
    }
    if (y0 > y1) y0 = y1;
    y0 += (b + 1) / 2 | 0;
    y1 = y0 - b1;
    a *= 8 * a;
    b1 = 8 * b * b;
    do {
      maxedge(right, x1, y0);
      minedge(left, x0, y0);
      minedge(left, x0, y1);
      maxedge(right, x1, y1);
      e2 = 2 * err;
      if (e2 >= dx) {
        x0++;
        x1--;
        dx += b1;
        err += dx;
      }
      if (e2 <= dy) {
        y0++;
        y1--;
        dy += a;
        err += dy;
      }
    } while (x0 <= x1);
    while (y0 - y1 < b) {
      maxedge(right, x1 + 1, y0);
      minedge(left, x0 - 1, y0++);
      minedge(left, x0 - 1, y1);
      maxedge(right, x1 + 1, y1--);
    }
    for (var y = left.min, max = left.length - 1; y <= max; y++) {
      addPoint(left[y], y);
    }
    for (var y = right.min, max = right.length - 1; y <= max; y++) {
      addPoint(right[y] + 1, y);
    }
    function minedge(e, x, y2) {
      if (e.min > y2) e.min = y2;
      var ey = e[y2];
      if (ey == null || ey > x) {
        e[y2] = x;
      }
    }
    function maxedge(e, x, y2) {
      if (e.min > y2) e.min = y2;
      var ey = e[y2];
      if (ey == null || ey < x) {
        e[y2] = x;
      }
    }
  }
  function clipped(x, y) {
    var pts = gs_xyclip[y];
    if (!pts) {
      return true;
    }
    if (!pts.sorted) {
      pts.sort(function(a, b) {
        return a - b;
      });
      pts.sorted = true;
    }
    var wn = false;
    for (var n = 0, npts = pts.length; n < npts; n++) {
      var xn = pts[n];
      if (xn > x) {
        return !wn;
      } else if (xn == x) {
        return wn;
      }
      wn = !wn;
    }
    return true;
  }
}
var PNGTYPE_TRUEALPHA = 6;
var PNG_TEXT = "Software\0bwip-js.metafloor.com";
var PNG_CRC = (function() {
  var precalc = [];
  for (var i = 0; i < 256; i++) {
    var c = i;
    for (var j = 0; j < 8; j++) {
      if (c & 1) {
        c = 3988292384 ^ c >>> 1;
      } else {
        c = c >>> 1;
      }
    }
    precalc[i] = c;
  }
  return precalc;
})();
function DrawingZlibPng(callback, maybe) {
  if (maybe && typeof maybe == "function") {
    callback = maybe;
  }
  var image_buffer, image_width, image_height;
  var drawing = DrawingBuiltin();
  drawing.image = image2;
  drawing.end = end;
  var opts;
  var _setopts = drawing.setopts;
  drawing.setopts = function(options) {
    opts = options;
    _setopts && _setopts.call(drawing, options);
  };
  return drawing;
  function image2(width, height) {
    image_buffer = Buffer.alloc ? Buffer.alloc(width * height * 4 + height) : new Buffer(width * height * 4 + height);
    image_width = width;
    image_height = height;
    if (/^[0-9a-fA-F]{6}$/.test("" + opts.backgroundcolor)) {
      var rgb = opts.backgroundcolor;
      fillRGB(
        parseInt(rgb.substr(0, 2), 16),
        parseInt(rgb.substr(2, 2), 16),
        parseInt(rgb.substr(4, 2), 16)
      );
    }
    return { buffer: image_buffer, ispng: true };
  }
  function fillRGB(r, g, b) {
    var color = (r << 24 | g << 16 | b << 8 | 255) >>> 0;
    var len = image_width * 4 + 1;
    var row = Buffer.alloc ? Buffer.alloc(len) : new Buffer(len);
    for (var i = 1; i < len; i += 4) {
      row.writeUInt32BE(color, i);
    }
    image_buffer.fill(row);
  }
  function end() {
    if (!callback) {
      return new Promise(makePNG);
    } else {
      makePNG(function(png2) {
        callback(null, png2);
      }, function(err) {
        callback(err);
      });
    }
  }
  function makePNG(resolve, reject) {
    var bufs = [];
    var buflen = 0;
    var deflator = require$$0$3.createDeflate({
      chunkSize: 32 * 1024,
      level: require$$0$3.Z_DEFAULT_COMPRESSION,
      strategy: require$$0$3.Z_DEFAULT_STRATEGY
    });
    deflator.on("error", reject);
    deflator.on("data", function(data2) {
      bufs.push(data2);
      buflen += data2.length;
    });
    deflator.on("end", returnPNG);
    deflator.end(image_buffer);
    function returnPNG() {
      var length = 8 + 12 + 13 + // PNG Header + IHDR chunk
      12 + PNG_TEXT.length + // tEXt
      12 + buflen + // IDAT
      12;
      if (opts.dpi) {
        length += 12 + 9;
      }
      var png2 = Buffer.alloc(length);
      var pngoff = 0;
      write("Â‰PNG\r\n\n");
      writeIHDR();
      writeTEXT();
      if (opts.dpi) {
        writePHYS();
      }
      writeIDAT();
      writeIEND();
      resolve(png2);
      function writeIHDR() {
        write32(13);
        var crcoff = pngoff;
        write("IHDR");
        write32(image_width);
        write32(image_height);
        write8(8);
        write8(PNGTYPE_TRUEALPHA);
        write8(0);
        write8(0);
        write8(0);
        writeCRC(crcoff);
      }
      function writeTEXT() {
        write32(PNG_TEXT.length);
        var crcoff = pngoff;
        write("tEXt");
        write(PNG_TEXT);
        writeCRC(crcoff);
      }
      function writePHYS() {
        write32(9);
        var crcoff = pngoff;
        var pxm = (opts.dpi || 72) / 0.0254 | 0;
        write("pHYs");
        write32(pxm);
        write32(pxm);
        write8(1);
        writeCRC(crcoff);
      }
      function writeIDAT() {
        write32(buflen);
        var crcoff = pngoff;
        write("IDAT");
        for (var i = 0; i < bufs.length; i++) {
          bufs[i].copy(png2, pngoff);
          pngoff += bufs[i].length;
        }
        writeCRC(crcoff);
      }
      function writeIEND() {
        write32(0);
        var crcoff = pngoff;
        write("IEND");
        writeCRC(crcoff);
      }
      function write(s) {
        png2.write(s, pngoff, "binary");
        pngoff += s.length;
      }
      function write32(v) {
        png2.writeUInt32BE(v, pngoff);
        pngoff += 4;
      }
      function write8(v) {
        png2[pngoff++] = v;
      }
      function writeCRC(off) {
        var crc2 = -1;
        while (off < pngoff) {
          crc2 = PNG_CRC[(crc2 ^ png2[off++]) & 255] ^ crc2 >>> 8;
        }
        write32((crc2 ^ -1) >>> 0);
      }
    }
  }
}
function DrawingSVG() {
  var tx0 = 0, tx1 = 0, tx2 = 0, tx3 = 0;
  var ty0 = 0, ty1 = 0, ty2 = 0, ty3 = 0;
  var opts;
  var svg = "";
  var path;
  var clipid = "";
  var clips = [];
  var lines = {};
  var scalex, scaley;
  var ELLIPSE_MAGIC = 0.55228475 - 45e-5;
  var gs_width, gs_height;
  var gs_dx, gs_dy;
  return {
    // setopts() is called after the options are fixed-up/normalized,
    // but before calling into BWIPP.
    // This allows omitting the options in the constructor call.
    // It is also your last chance to amend the options before usage.
    setopts(options) {
      opts = options;
    },
    // measure() and scale() are the only drawing primitives that are called before init().
    // Make no adjustments
    scale(sx, sy) {
      scalex = sx;
      scaley = sy;
    },
    // Measure text.
    // `font` is the font name typically OCR-A or OCR-B.
    // `fwidth` and `fheight` are the requested font cell size.  They will
    // usually be the same, except when the scaling is not symetric.
    measure(str, font, fwidth, fheight) {
      fwidth = fwidth | 0;
      fheight = fheight | 0;
      var fontid = FontLib.lookup(font);
      var width = 0;
      var ascent = 0;
      var descent = 0;
      for (var i = 0, l = str.length; i < l; i++) {
        var ch = str.charCodeAt(i);
        var glyph = FontLib.getglyph(fontid, ch, fwidth, fheight);
        if (!glyph) {
          continue;
        }
        ascent = Math.max(ascent, glyph.top);
        descent = Math.max(descent, glyph.height - glyph.top);
        if (i == l - 1) {
          width += glyph.left + glyph.width;
        } else {
          width += glyph.advance;
        }
      }
      return { width, ascent, descent };
    },
    // `width` and `height` represent the maximum bounding box the graphics will
    // occupy.  The dimensions are for an unrotated rendering.  Adjust as necessary.
    init(width, height) {
      var padl = opts.paddingleft;
      var padr = opts.paddingright;
      var padt = opts.paddingtop;
      var padb = opts.paddingbottom;
      var rot = opts.rotate || "N";
      width += padl + padr;
      height += padt + padb;
      switch (rot) {
        // tx = w-y, ty = x
        case "R":
          tx1 = -1;
          tx2 = 1;
          ty0 = 1;
          break;
        // tx = w-x, ty = h-y
        case "I":
          tx0 = -1;
          tx2 = 1;
          ty1 = -1;
          ty3 = 1;
          break;
        // tx = y, ty = h-x
        case "L":
          tx1 = 1;
          ty0 = -1;
          ty3 = 1;
          break;
        // tx = x, ty = y
        default:
          tx0 = ty1 = 1;
          break;
      }
      var swap = rot == "L" || rot == "R";
      gs_width = swap ? height : width;
      gs_height = swap ? width : height;
      gs_dx = padl;
      gs_dy = padt;
    },
    // Unconnected stroked lines are used to draw the bars in linear barcodes.
    // No line cap should be applied.  These lines are always orthogonal.
    line(x0, y0, x1, y1, lw, rgb) {
      x0 = x0 | 0;
      y0 = y0 | 0;
      x1 = x1 | 0;
      y1 = y1 | 0;
      lw = Math.round(lw) || 1;
      if (lw & 1) {
        if (x0 == x1) {
          let dx = scalex & 1 ? -0.5 : 0.5;
          x0 += dx;
          x1 += dx;
        }
        if (y0 == y1) {
          let dy = scaley & 1 ? -0.5 : 0.5;
          y0 += dy;
          y1 += dy;
        }
      }
      if (x0 == x1) {
        y0++;
      } else if (y0 == y1) {
        x0++;
      }
      var key2 = "" + lw + "#" + rgb;
      if (!lines[key2]) {
        lines[key2] = '<path stroke="#' + rgb + '" stroke-width="' + lw + '" d="';
      }
      lines[key2] += "M" + transform(x0, y0) + "L" + transform(x1, y1);
    },
    // Polygons are used to draw the connected regions in a 2d barcode.
    // These will always be unstroked, filled, non-intersecting,
    // orthogonal shapes.
    // You will see a series of polygon() calls, followed by a fill().
    polygon(pts) {
      if (!path) {
        path = '<path d="';
      }
      path += "M" + transform(pts[0][0], pts[0][1]);
      for (var i = 1, n = pts.length; i < n; i++) {
        var p = pts[i];
        path += "L" + transform(p[0], p[1]);
      }
      path += "Z";
    },
    // An unstroked, filled hexagon used by maxicode.  You can choose to fill
    // each individually, or wait for the final fill().
    //
    // The hexagon is drawn from the top, counter-clockwise.
    hexagon(pts, rgb) {
      this.polygon(pts);
    },
    // An unstroked, filled ellipse.  Used by dotcode and maxicode at present.
    // maxicode issues pairs of ellipse calls (one cw, one ccw) followed by a fill()
    // to create the bullseye rings.  dotcode issues all of its ellipses then a
    // fill().
    ellipse(x, y, rx, ry, ccw) {
      if (!path) {
        path = '<path d="';
      }
      var dx = rx * ELLIPSE_MAGIC;
      var dy = ry * ELLIPSE_MAGIC;
      path += "M" + transform(x - rx, y) + "C" + transform(x - rx, y - dy) + " " + transform(x - dx, y - ry) + " " + transform(x, y - ry) + "C" + transform(x + dx, y - ry) + " " + transform(x + rx, y - dy) + " " + transform(x + rx, y) + "C" + transform(x + rx, y + dy) + " " + transform(x + dx, y + ry) + " " + transform(x, y + ry) + "C" + transform(x - dx, y + ry) + " " + transform(x - rx, y + dy) + " " + transform(x - rx, y) + "Z";
    },
    // PostScript's default fill rule is non-zero but there are never intersecting
    // regions. The built-in drawing uses even-odd for simplicity - we match that
    // to be consistent.
    fill(rgb) {
      if (path) {
        svg += path + '" fill="#' + rgb + '" fill-rule="evenodd"' + (clipid ? ' clip-path="url(#' + clipid + ')"' : "") + " />\n";
        path = null;
      }
    },
    // Currently only used by swissqrcode.  The `polys` area is an array of
    // arrays of points.  Each array of points is identical to the `pts`
    // parameter passed to polygon().  The clipping rule, like the fill rule,
    // defaults to non-zero winding.
    clip: function(polys) {
      var path2 = '<clipPath id="clip' + clips.length + '"><path d="';
      for (let j = 0; j < polys.length; j++) {
        let pts = polys[j];
        path2 += "M" + transform(pts[0][0], pts[0][1]);
        for (var i = 1, n = pts.length; i < n; i++) {
          var p = pts[i];
          path2 += "L" + transform(p[0], p[1]);
        }
        path2 += "Z";
      }
      path2 += '" clip-rule="nonzero" /></clipPath>';
      clipid = "clip" + clips.length;
      clips.push(path2);
    },
    unclip: function() {
      clipid = "";
    },
    // Draw text with optional inter-character spacing.  `y` is the baseline.
    // font is an object with properties { name, width, height, rotate, dx }
    // width and height are the font cell size.
    // rotate is one of 0, 90, 180, 270 (default 0).
    // dx is extra space requested between characters (usually zero).
    text(x, y, str, rgb, font) {
      x = x | 0;
      y = y | 0;
      var x0 = x, y0 = y;
      var fontid = FontLib.lookup(font.name);
      var fwidth = font.width | 0;
      var fheight = font.height | 0;
      var dx = font.dx | 0;
      var path2 = "";
      for (var k = 0; k < str.length; k++) {
        var ch = str.charCodeAt(k);
        var glyph = FontLib.getpaths(fontid, ch, fwidth, fheight);
        if (!glyph) {
          continue;
        }
        if (glyph.length) {
          for (var i = 0, l = glyph.length; i < l; i++) {
            let seg = glyph[i];
            if (seg.type == "M" || seg.type == "L") {
              path2 += seg.type + transform(seg.x + x, y - seg.y);
            } else if (seg.type == "Q") {
              path2 += seg.type + transform(seg.cx + x, y - seg.cy) + " " + transform(seg.x + x, y - seg.y);
            } else if (seg.type == "C") {
              path2 += seg.type + transform(seg.cx1 + x, y - seg.cy1) + " " + transform(seg.cx2 + x, y - seg.cy2) + " " + transform(seg.x + x, y - seg.y);
            }
          }
          path2 += "Z";
        }
        x += FontLib.getglyph(fontid, ch, fwidth, fheight).advance + dx;
      }
      if (path2) {
        if (font.rotate) {
          svg += '<path d="' + path2 + '" fill="#' + rgb + '" transform="rotate(-' + font.rotate + " " + transform(x0, y0) + ')" />\n';
        } else {
          svg += '<path d="' + path2 + '" fill="#' + rgb + '" />\n';
        }
      }
    },
    // Called after all drawing is complete.  The return value from this method
    // will be the return value from `bwipjs.render()`.
    end() {
      var linesvg = "";
      for (var key2 in lines) {
        linesvg += lines[key2] + '" />\n';
      }
      var bg = opts.backgroundcolor;
      return '<svg viewBox="0 0 ' + gs_width + " " + gs_height + '" xmlns="http://www.w3.org/2000/svg">\n' + (clips.length ? "<defs>" + clips.join("") + "</defs>" : "") + (/^[0-9A-Fa-f]{6}$/.test("" + bg) ? '<rect width="100%" height="100%" fill="#' + bg + '" />\n' : "") + linesvg + svg + "</svg>\n";
    }
  };
  function transform(x, y) {
    x += gs_dx;
    y += gs_dy;
    var tx = tx0 * x + tx1 * y + tx2 * (gs_width - 1) + tx3 * (gs_height - 1);
    var ty = ty0 * x + ty1 * y + ty2 * (gs_width - 1) + ty3 * (gs_height - 1);
    return "" + ((tx | 0) == tx ? tx : tx.toFixed(2)) + " " + ((ty | 0) == ty ? ty : ty.toFixed(2));
  }
}
var FontLib = (function() {
  var fonts = [];
  var names = {};
  var glyphcache = {};
  var glyphmru = {};
  var glyphcount = 0;
  glyphmru.next = glyphmru;
  glyphmru.prev = glyphmru;
  return {
    lookup,
    monochrome,
    getglyph,
    getpaths,
    loadFont
  };
  function loadFont(name) {
    var multx = 100;
    var multy = 100;
    var data2 = null;
    if (arguments.length == 2) {
      data2 = arguments[1];
    } else if (arguments.length == 3) {
      multx = multy = +arguments[1] || 100;
      data2 = arguments[2];
    } else if (arguments.length == 4) {
      multy = +arguments[1] || 100;
      multx = +arguments[2] || 100;
      data2 = arguments[3];
    } else {
      throw new Error("bwipjs: loadFont: invalid number of arguments");
    }
    var font = STBTT.InitFont(toUint8Array(data2));
    font.bwipjs_name = name;
    font.bwipjs_multx = multx;
    font.bwipjs_multy = multy;
    var fontid = fonts.push(font) - 1;
    names[name.toUpperCase()] = fontid;
    return fontid;
  }
  function lookup(name) {
    var fontid = names[name.toUpperCase()];
    return fontid === void 0 ? 1 : fontid;
  }
  function monochrome(mono) {
    if (mono) {
      throw new Error("bwipjs: monochrome fonts not implemented");
    }
  }
  function getglyph(fontid, charcode, width, height) {
    fontid = fontid | 0;
    charcode = charcode | 0;
    width = +width;
    height = +height;
    if (!width || width < 8) {
      width = 8;
    }
    if (!height || height < 8) {
      height = width;
    }
    if (fontid < 0 || fontid >= fonts.length) {
      fontid = 1;
    }
    if (!charcode || charcode < 32) {
      charcode = 32;
    }
    var cachekey = "" + fontid + "c" + charcode + "w" + width + "h" + height;
    var glyph = glyphcache[cachekey];
    if (glyph) {
      glyph.prev.next = glyph.next;
      glyph.next.prev = glyph.prev;
      var sntl = glyphmru;
      sntl.next.prev = glyph;
      glyph.next = sntl.next;
      glyph.prev = sntl;
      sntl.next = glyph;
      return glyph;
    }
    var font = fonts[fontid];
    var glyph = STBTT.GetGlyph(
      font,
      charcode,
      width * font.bwipjs_multx / 100,
      height * font.bwipjs_multy / 100
    ) || STBTT.GetGlyph(
      font,
      0,
      width * font.bwipjs_multx / 100,
      height * font.bwipjs_multy / 100
    );
    glyph.bytes = glyph.pixels;
    glyph.cachekey = cachekey;
    glyph.offset = 0;
    if (glyphcount > 250) {
      var sntl = glyphmru;
      var temp = sntl.prev;
      temp.prev.next = sntl;
      sntl.prev = temp.prev;
      temp.next = temp.prev = null;
      delete glyphcache[temp.cachekey];
    } else {
      glyphcount++;
    }
    glyphcache[cachekey] = glyph;
    var sntl = glyphmru;
    sntl.next.prev = glyph;
    glyph.next = sntl.next;
    glyph.prev = sntl;
    sntl.next = glyph;
    return glyph;
  }
  function getpaths(fontid, charcode, width, height) {
    fontid = fontid | 0;
    charcode = charcode | 0;
    width = +width;
    height = +height;
    if (!width || width < 8) {
      width = 8;
    }
    if (!height || height < 8) {
      height = width;
    }
    if (fontid < 0 || fontid >= fonts.length) {
      fontid = 1;
    }
    if (!charcode || charcode < 32) {
      charcode = 32;
    }
    var font = fonts[fontid];
    return STBTT.GetPaths(
      font,
      charcode,
      width * font.bwipjs_multx / 100,
      height * font.bwipjs_multy / 100
    );
  }
})();
function LoadFont() {
  return FontLib.loadFont.apply(FontLib, Array.prototype.slice.call(arguments));
}
var STBTT = /* @__PURE__ */ (function() {
  var STBTT_vmove = 1, STBTT_vline = 2, STBTT_vcurve = 3, STBTT_vcubic = 4, STBTT_PLATFORM_ID_UNICODE = 0, STBTT_PLATFORM_ID_MICROSOFT = 3, STBTT_MS_EID_UNICODE_BMP = 1, STBTT_MS_EID_UNICODE_FULL = 10;
  var floor = Math.floor;
  var ceil = Math.ceil;
  var sqrt = Math.sqrt;
  var abs = Math.abs;
  function oalloc(n) {
    var o = [];
    for (var i = 0; i < n; i++) {
      o.push({});
    }
    return o;
  }
  function stbtt__buf_get8(b) {
    return b[b.cursor++] || 0;
  }
  function stbtt__buf_peek8(b) {
    return b[b.cursor];
  }
  function stbtt__buf_seek(b, o) {
    b.cursor = o > b.length || o < 0 ? b.length : o;
  }
  function stbtt__buf_skip(b, o) {
    stbtt__buf_seek(b, b.cursor + o);
  }
  function stbtt__buf_get(b, n) {
    var v = 0;
    for (var i = 0; i < n; i++) {
      v = v << 8 | stbtt__buf_get8(b);
    }
    return v;
  }
  function stbtt__null_buf() {
    return { length: 0 };
  }
  function stbtt__buf_range(b, o, s) {
    if (o < 0 || s < 0 || o > b.length || s > b.length - o) {
      return stbtt__null_buf();
    }
    var r = b.subarray(o, o + s);
    r.cursor = 0;
    return r;
  }
  function stbtt__cff_get_index(b) {
    var start = b.cursor;
    var count = stbtt__buf_get(b, 2);
    if (count) {
      var offsize = stbtt__buf_get8(b);
      stbtt__buf_skip(b, offsize * count);
      stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);
    }
    return stbtt__buf_range(b, start, b.cursor - start);
  }
  function stbtt__cff_int(b) {
    var b0 = stbtt__buf_get8(b);
    if (b0 >= 32 && b0 <= 246) {
      return b0 - 139;
    } else if (b0 >= 247 && b0 <= 250) {
      return (b0 - 247) * 256 + stbtt__buf_get8(b) + 108;
    } else if (b0 >= 251 && b0 <= 254) {
      return -(b0 - 251) * 256 - stbtt__buf_get8(b) - 108;
    } else if (b0 == 28) {
      return stbtt__buf_get(b, 2);
    } else if (b0 == 29) {
      return stbtt__buf_get(b, 4);
    }
    return 0;
  }
  function stbtt__cff_skip_operand(b) {
    var b0 = stbtt__buf_peek8(b);
    if (b0 == 30) {
      stbtt__buf_skip(b, 1);
      while (b.cursor < b.length) {
        var v = stbtt__buf_get8(b);
        if ((v & 15) == 15 || v >> 4 == 15) {
          break;
        }
      }
    } else {
      stbtt__cff_int(b);
    }
  }
  function stbtt__dict_get(b, key2) {
    stbtt__buf_seek(b, 0);
    while (b.cursor < b.length) {
      var start = b.cursor, end, op;
      while (stbtt__buf_peek8(b) >= 28) {
        stbtt__cff_skip_operand(b);
      }
      end = b.cursor;
      op = stbtt__buf_get8(b);
      if (op == 12) {
        op = stbtt__buf_get8(b) | 256;
      }
      if (op == key2) {
        return stbtt__buf_range(b, start, end - start);
      }
    }
    return stbtt__buf_range(b, 0, 0);
  }
  function stbtt__dict_get_ints(b, key2, outcount, out) {
    var operands = stbtt__dict_get(b, key2);
    for (var i = 0; i < outcount && operands.cursor < operands.length; i++) {
      out[i] = stbtt__cff_int(operands);
    }
  }
  function stbtt__dict_get_int(b, key2, out) {
    var operands = stbtt__dict_get(b, key2);
    if (operands.cursor < operands.length) {
      out = stbtt__cff_int(operands);
    }
    return out;
  }
  function stbtt__cff_index_count(b) {
    stbtt__buf_seek(b, 0);
    return stbtt__buf_get(b, 2);
  }
  function stbtt__cff_index_get(b, i) {
    var count, offsize, start, end;
    stbtt__buf_seek(b, 0);
    count = stbtt__buf_get(b, 2);
    offsize = stbtt__buf_get8(b);
    stbtt__buf_skip(b, i * offsize);
    start = stbtt__buf_get(b, offsize);
    end = stbtt__buf_get(b, offsize);
    return stbtt__buf_range(b, 2 + (count + 1) * offsize + start, end - start);
  }
  function INT16(n) {
    return n & 32768 ? (4294901760 | n) >> 0 : n;
  }
  function ttUSHORT(b, o) {
    return b[o] * 256 + b[o + 1];
  }
  function ttSHORT(b, o) {
    var n = b[o] * 256 + b[o + 1];
    return n & 32768 ? (4294901760 | n) >> 0 : n;
  }
  function ttULONG(b, o) {
    return (b[o] << 24) + (b[o + 1] << 16) + (b[o + 2] << 8) + b[o + 3];
  }
  function stbtt__find_table(data2, fontstart, tag) {
    var num_tables = ttUSHORT(data2, fontstart + 4);
    var tabledir = fontstart + 12;
    for (var i = 0; i < num_tables; ++i) {
      var loc = tabledir + 16 * i;
      if (data2[loc] == tag[0] && data2[loc + 1] == tag[1] && data2[loc + 2] == tag[2] && data2[loc + 3] == tag[3]) {
        return ttULONG(data2, loc + 8);
      }
    }
    return 0;
  }
  function stbtt__get_subrs(cff, fontdict) {
    var private_loc = [0, 0];
    stbtt__dict_get_ints(fontdict, 18, 2, private_loc);
    if (!private_loc[1] || !private_loc[0]) {
      return stbtt__null_buf();
    }
    var pdict = stbtt__buf_range(cff, private_loc[1], private_loc[0]);
    var subrsoff = stbtt__dict_get_int(pdict, 19, 0);
    if (!subrsoff) {
      return stbtt__null_buf();
    }
    stbtt__buf_seek(cff, private_loc[1] + subrsoff);
    return stbtt__cff_get_index(cff);
  }
  function stbtt_InitFont_internal(info, data2, fontstart) {
    var cmap, t, i, numTables;
    info.data = data2;
    info.fontstart = fontstart;
    info.cff = stbtt__null_buf();
    cmap = stbtt__find_table(data2, fontstart, [99, 109, 97, 112]);
    info.loca = stbtt__find_table(data2, fontstart, [108, 111, 99, 97]);
    info.head = stbtt__find_table(data2, fontstart, [104, 101, 97, 100]);
    info.glyf = stbtt__find_table(data2, fontstart, [103, 108, 121, 102]);
    info.hhea = stbtt__find_table(data2, fontstart, [104, 104, 101, 97]);
    info.hmtx = stbtt__find_table(data2, fontstart, [104, 109, 116, 120]);
    info.kern = stbtt__find_table(data2, fontstart, [107, 101, 114, 110]);
    if (!cmap || !info.head || !info.hhea || !info.hmtx) {
      return 0;
    }
    if (info.glyf) {
      if (!info.loca) {
        return 0;
      }
    } else {
      var b, topdict, topdictidx, cff, cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;
      cff = stbtt__find_table(data2, fontstart, [67, 70, 70, 32]);
      if (!cff) {
        return 0;
      }
      info.fontdicts = stbtt__null_buf();
      info.fdselect = stbtt__null_buf();
      info.cff = data2.subarray(cff);
      info.cff.cursor = 0;
      b = info.cff;
      stbtt__buf_skip(b, 2);
      stbtt__buf_seek(b, stbtt__buf_get8(b));
      stbtt__cff_get_index(b);
      topdictidx = stbtt__cff_get_index(b);
      topdict = stbtt__cff_index_get(topdictidx, 0);
      stbtt__cff_get_index(b);
      info.gsubrs = stbtt__cff_get_index(b);
      charstrings = stbtt__dict_get_int(topdict, 17, charstrings);
      cstype = stbtt__dict_get_int(topdict, 256 | 6, cstype);
      fdarrayoff = stbtt__dict_get_int(topdict, 256 | 36, fdarrayoff);
      fdselectoff = stbtt__dict_get_int(topdict, 256 | 37, fdselectoff);
      info.subrs = stbtt__get_subrs(b, topdict);
      if (cstype != 2) {
        return 0;
      }
      if (charstrings == 0) {
        return 0;
      }
      if (fdarrayoff) {
        if (!fdselectoff) {
          return 0;
        }
        stbtt__buf_seek(b, fdarrayoff);
        info.fontdicts = stbtt__cff_get_index(b);
        info.fdselect = stbtt__buf_range(b, fdselectoff, b.length - fdselectoff);
      }
      stbtt__buf_seek(b, charstrings);
      info.charstrings = stbtt__cff_get_index(b);
    }
    t = stbtt__find_table(data2, fontstart, [109, 97, 120, 112]);
    if (t) {
      info.numGlyphs = ttUSHORT(data2, t + 4);
    } else {
      info.numGlyphs = 65535;
    }
    numTables = ttUSHORT(data2, cmap + 2);
    info.index_map = 0;
    for (i = 0; i < numTables; ++i) {
      var encoding_record = cmap + 4 + 8 * i;
      switch (ttUSHORT(data2, encoding_record)) {
        case STBTT_PLATFORM_ID_MICROSOFT:
          switch (ttUSHORT(data2, encoding_record + 2)) {
            case STBTT_MS_EID_UNICODE_BMP:
            case STBTT_MS_EID_UNICODE_FULL:
              info.index_map = cmap + ttULONG(data2, encoding_record + 4);
              break;
          }
          break;
        case STBTT_PLATFORM_ID_UNICODE:
          info.index_map = cmap + ttULONG(data2, encoding_record + 4);
          break;
      }
    }
    if (info.index_map == 0) {
      return 0;
    }
    info.indexToLocFormat = ttUSHORT(data2, info.head + 50);
    return 1;
  }
  function stbtt_FindGlyphIndex(info, unicode_codepoint) {
    var data2 = info.data, index_map = info.index_map;
    var format2 = ttUSHORT(data2, index_map + 0);
    if (format2 == 0) {
      var bytes = ttUSHORT(data2, index_map + 2);
      if (unicode_codepoint < bytes - 6) {
        return data2[index_map + 6 + unicode_codepoint];
      }
      return 0;
    } else if (format2 == 6) {
      var first = ttUSHORT(data2, index_map + 6), count = ttUSHORT(data2, index_map + 8);
      if (unicode_codepoint >= first && unicode_codepoint < first + count) {
        return ttUSHORT(data2, index_map + 10 + (unicode_codepoint - first) * 2);
      }
      return 0;
    } else if (format2 == 2) {
      return 0;
    } else if (format2 == 4) {
      var segcount = ttUSHORT(data2, index_map + 6) >> 1, searchRange = ttUSHORT(data2, index_map + 8) >> 1, entrySelector = ttUSHORT(data2, index_map + 10), rangeShift = ttUSHORT(data2, index_map + 12) >> 1, endCount = index_map + 14, search = endCount;
      if (unicode_codepoint > 65535) {
        return 0;
      }
      if (unicode_codepoint >= ttUSHORT(data2, search + rangeShift * 2)) {
        search += rangeShift * 2;
      }
      search -= 2;
      while (entrySelector) {
        searchRange >>= 1;
        var end = ttUSHORT(data2, search + searchRange * 2);
        if (unicode_codepoint > end) {
          search += searchRange * 2;
        }
        --entrySelector;
      }
      search += 2;
      var offset, start, item = search - endCount >>> 1;
      start = ttUSHORT(data2, index_map + 14 + segcount * 2 + 2 + 2 * item);
      if (unicode_codepoint < start) {
        return 0;
      }
      offset = ttUSHORT(data2, index_map + 14 + segcount * 6 + 2 + 2 * item);
      if (offset == 0) {
        return unicode_codepoint + ttSHORT(data2, index_map + 14 + segcount * 4 + 2 + 2 * item);
      }
      return ttUSHORT(data2, offset + (unicode_codepoint - start) * 2 + index_map + 14 + segcount * 6 + 2 + 2 * item);
    } else if (format2 == 12 || format2 == 13) {
      var ngroups = ttULONG(data2, index_map + 12), low = 0, high = ngroups;
      while (low < high) {
        var mid = low + (high - low >> 1);
        var start_char = ttULONG(data2, index_map + 16 + mid * 12);
        var end_char = ttULONG(data2, index_map + 16 + mid * 12 + 4);
        if (unicode_codepoint < start_char) {
          high = mid;
        } else if (unicode_codepoint > end_char) {
          low = mid + 1;
        } else {
          var start_glyph = ttULONG(data2, index_map + 16 + mid * 12 + 8);
          if (format2 == 12) {
            return start_glyph + unicode_codepoint - start_char;
          } else {
            return start_glyph;
          }
        }
      }
      return 0;
    }
    return 0;
  }
  function stbtt_setvertex(v, type2, x, y, cx, cy) {
    v.type = type2;
    v.x = x;
    v.y = y;
    v.cx = cx;
    v.cy = cy;
  }
  function stbtt__GetGlyfOffset(info, glyph_index) {
    var g1, g2;
    if (glyph_index >= info.numGlyphs) {
      return -1;
    }
    if (info.indexToLocFormat >= 2) {
      return -1;
    }
    if (info.indexToLocFormat == 0) {
      g1 = info.glyf + ttUSHORT(info.data, info.loca + glyph_index * 2) * 2;
      g2 = info.glyf + ttUSHORT(info.data, info.loca + glyph_index * 2 + 2) * 2;
    } else {
      g1 = info.glyf + ttULONG(info.data, info.loca + glyph_index * 4);
      g2 = info.glyf + ttULONG(info.data, info.loca + glyph_index * 4 + 4);
    }
    return g1 == g2 ? -1 : g1;
  }
  function stbtt_GetGlyphBox(info, glyph_index, out) {
    if (info.cff.length) {
      stbtt__GetGlyphInfoT2(info, glyph_index, out);
    } else {
      var g = stbtt__GetGlyfOffset(info, glyph_index);
      if (g < 0) {
        return 0;
      }
      out.x0 = ttSHORT(info.data, g + 2);
      out.y0 = ttSHORT(info.data, g + 4);
      out.x1 = ttSHORT(info.data, g + 6);
      out.y1 = ttSHORT(info.data, g + 8);
    }
    return 1;
  }
  function stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx, sy, scx, scy, cx, cy) {
    if (start_off) {
      if (was_off) {
        stbtt_setvertex(
          vertices[num_vertices++],
          STBTT_vcurve,
          cx + scx >> 1,
          cy + scy >> 1,
          cx,
          cy
        );
      }
      stbtt_setvertex(vertices[num_vertices++], STBTT_vcurve, sx, sy, scx, scy);
    } else {
      if (was_off) {
        stbtt_setvertex(vertices[num_vertices++], STBTT_vcurve, sx, sy, cx, cy);
      } else {
        stbtt_setvertex(vertices[num_vertices++], STBTT_vline, sx, sy, 0, 0);
      }
    }
    return num_vertices;
  }
  function stbtt__GetGlyphShapeTT(info, glyph_index) {
    var data2 = info.data, g = stbtt__GetGlyfOffset(info, glyph_index);
    if (g < 0) {
      return null;
    }
    var vertices = [];
    var numberOfContours = ttSHORT(data2, g);
    if (numberOfContours > 0) {
      var flags = 0, flagcount, i, j = 0, m, n, next_move, was_off = 0, off, start_off = 0, x, y, cx, cy, sx, sy, scx, scy;
      var endPtsOfContours = g + 10;
      var ins = ttUSHORT(data2, g + 10 + numberOfContours * 2);
      var points = data2.subarray(g + 10 + numberOfContours * 2 + 2 + ins);
      var ptsoff = 0;
      n = 1 + ttUSHORT(data2, endPtsOfContours + numberOfContours * 2 - 2);
      m = n + 2 * numberOfContours;
      vertices = oalloc(m);
      next_move = 0;
      flagcount = 0;
      off = m - n;
      for (i = 0; i < n; ++i) {
        if (flagcount == 0) {
          flags = points[ptsoff++];
          if (flags & 8) {
            flagcount = points[ptsoff++];
          }
        } else {
          --flagcount;
        }
        vertices[off + i].type = flags;
      }
      x = 0;
      for (i = 0; i < n; ++i) {
        flags = vertices[off + i].type;
        if (flags & 2) {
          var dx = points[ptsoff++];
          x += flags & 16 ? dx : -dx;
        } else {
          if (!(flags & 16)) {
            x = x + INT16(points[ptsoff] * 256 + points[ptsoff + 1]);
            ptsoff += 2;
          }
        }
        vertices[off + i].x = x;
      }
      y = 0;
      for (i = 0; i < n; ++i) {
        flags = vertices[off + i].type;
        if (flags & 4) {
          var dy = points[ptsoff++];
          y += flags & 32 ? dy : -dy;
        } else {
          if (!(flags & 32)) {
            y = y + INT16(points[ptsoff] * 256 + points[ptsoff + 1]);
            ptsoff += 2;
          }
        }
        vertices[off + i].y = y;
      }
      var num_vertices = 0;
      sx = sy = cx = cy = scx = scy = 0;
      for (i = 0; i < n; ++i) {
        flags = vertices[off + i].type;
        x = vertices[off + i].x;
        y = vertices[off + i].y;
        if (next_move == i) {
          if (i != 0) {
            num_vertices = stbtt__close_shape(
              vertices,
              num_vertices,
              was_off,
              start_off,
              sx,
              sy,
              scx,
              scy,
              cx,
              cy
            );
          }
          start_off = !(flags & 1);
          if (start_off) {
            scx = x;
            scy = y;
            if (!(vertices[off + i + 1].type & 1)) {
              sx = x + vertices[off + i + 1].x >> 1;
              sy = y + vertices[off + i + 1].y >> 1;
            } else {
              sx = vertices[off + i + 1].x;
              sy = vertices[off + i + 1].y;
              ++i;
            }
          } else {
            sx = x;
            sy = y;
          }
          stbtt_setvertex(vertices[num_vertices++], STBTT_vmove, sx, sy, 0, 0);
          was_off = 0;
          next_move = 1 + ttUSHORT(data2, endPtsOfContours + j * 2);
          ++j;
        } else {
          if (!(flags & 1)) {
            if (was_off) {
              stbtt_setvertex(
                vertices[num_vertices++],
                STBTT_vcurve,
                cx + x >> 1,
                cy + y >> 1,
                cx,
                cy
              );
            }
            cx = x;
            cy = y;
            was_off = 1;
          } else {
            if (was_off) {
              stbtt_setvertex(vertices[num_vertices++], STBTT_vcurve, x, y, cx, cy);
            } else {
              stbtt_setvertex(vertices[num_vertices++], STBTT_vline, x, y, 0, 0);
            }
            was_off = 0;
          }
        }
      }
      vertices.length = stbtt__close_shape(
        vertices,
        num_vertices,
        was_off,
        start_off,
        sx,
        sy,
        scx,
        scy,
        cx,
        cy
      );
    } else if (numberOfContours == -1) {
      var more = 1;
      var comp = g + 10;
      while (more) {
        var flags, gidx, mtx = [1, 0, 0, 1, 0, 0];
        flags = ttSHORT(data2, comp);
        comp += 2;
        gidx = ttSHORT(data2, comp);
        comp += 2;
        if (flags & 2) {
          if (flags & 1) {
            mtx[4] = ttSHORT(data2, comp);
            comp += 2;
            mtx[5] = ttSHORT(data2, comp);
            comp += 2;
          } else {
            mtx[4] = stbtt__buf_get8(data2);
            comp += 1;
            mtx[5] = stbtt__buf_get8(data2);
            comp += 1;
          }
        }
        if (flags & 1 << 3) {
          mtx[0] = mtx[3] = ttSHORT(data2, comp) / 16384;
          comp += 2;
          mtx[1] = mtx[2] = 0;
        } else if (flags & 1 << 6) {
          mtx[0] = ttSHORT(data2, comp) / 16384;
          comp += 2;
          mtx[1] = mtx[2] = 0;
          mtx[3] = ttSHORT(data2, comp) / 16384;
          comp += 2;
        } else if (flags & 1 << 7) {
          mtx[0] = ttSHORT(data2, comp) / 16384;
          comp += 2;
          mtx[1] = ttSHORT(data2, comp) / 16384;
          comp += 2;
          mtx[2] = ttSHORT(data2, comp) / 16384;
          comp += 2;
          mtx[3] = ttSHORT(data2, comp) / 16384;
          comp += 2;
        }
        var m = sqrt(mtx[0] * mtx[0] + mtx[1] * mtx[1]);
        var n = sqrt(mtx[2] * mtx[2] + mtx[3] * mtx[3]);
        var comp_verts = stbtt_GetGlyphShape(info, gidx);
        if (comp_verts.length > 0) {
          for (var i = 0, l = comp_verts.length; i < l; ++i) {
            var v = comp_verts[i], x, y;
            x = v.x;
            y = v.y;
            v.x = floor(m * (mtx[0] * x + mtx[2] * y + mtx[4]));
            v.y = floor(n * (mtx[1] * x + mtx[3] * y + mtx[5]));
            x = v.cx;
            y = v.cy;
            v.cx = floor(m * (mtx[0] * x + mtx[2] * y + mtx[4]));
            v.cy = floor(n * (mtx[1] * x + mtx[3] * y + mtx[5]));
          }
          vertices = vertices.concat(comp_verts);
        }
        more = flags & 1 << 5;
      }
    }
    return vertices;
  }
  function stbtt__track_vertex(c, x, y) {
    if (x > c.max_x || !c.started) {
      c.max_x = x;
    }
    if (y > c.max_y || !c.started) {
      c.max_y = y;
    }
    if (x < c.min_x || !c.started) {
      c.min_x = x;
    }
    if (y < c.min_y || !c.started) {
      c.min_y = y;
    }
    c.started = 1;
  }
  function stbtt__csctx_v(c, type2, x, y, cx, cy, cx1, cy1) {
    stbtt__track_vertex(c, x, y);
    if (type2 == STBTT_vcubic) {
      stbtt__track_vertex(c, cx, cy);
      stbtt__track_vertex(c, cx1, cy1);
    }
    var v = {};
    stbtt_setvertex(v, type2, x, y, cx, cy);
    v.cx1 = cx1;
    v.cy1 = cy1;
    c.vertices.push(v);
  }
  function stbtt__csctx_close_shape(ctx) {
    if (ctx.first_x != ctx.x || ctx.first_y != ctx.y) {
      stbtt__csctx_v(ctx, STBTT_vline, ctx.first_x, ctx.first_y, 0, 0, 0, 0);
    }
  }
  function stbtt__csctx_rmove_to(ctx, dx, dy) {
    stbtt__csctx_close_shape(ctx);
    ctx.first_x = ctx.x = ctx.x + dx;
    ctx.first_y = ctx.y = ctx.y + dy;
    stbtt__csctx_v(ctx, STBTT_vmove, ctx.x, ctx.y, 0, 0, 0, 0);
  }
  function stbtt__csctx_rline_to(ctx, dx, dy) {
    ctx.x += dx;
    ctx.y += dy;
    stbtt__csctx_v(ctx, STBTT_vline, ctx.x, ctx.y, 0, 0, 0, 0);
  }
  function stbtt__csctx_rccurve_to(ctx, dx1, dy1, dx2, dy2, dx3, dy3) {
    var cx1 = ctx.x + dx1, cy1 = ctx.y + dy1, cx2 = cx1 + dx2, cy2 = cy1 + dy2;
    ctx.x = cx2 + dx3;
    ctx.y = cy2 + dy3;
    stbtt__csctx_v(ctx, STBTT_vcubic, ctx.x, ctx.y, cx1, cy1, cx2, cy2);
  }
  function stbtt__get_subr(b, n) {
    var count = stbtt__cff_index_count(b);
    var bias = 107;
    if (count >= 33900) {
      bias = 32768;
    } else if (count >= 1240) {
      bias = 1131;
    }
    n += bias;
    if (n < 0 || n >= count) {
      return stbtt__null_buf();
    }
    return stbtt__cff_index_get(b, n);
  }
  function stbtt__cid_get_glyph_subrs(info, glyph_index) {
    var fdselect = info.fdselect;
    var nranges, start, end, v, fmt, fdselector = -1, i;
    stbtt__buf_seek(fdselect, 0);
    fmt = stbtt__buf_get8(fdselect);
    if (fmt == 0) {
      stbtt__buf_skip(fdselect, glyph_index);
      fdselector = stbtt__buf_get8(fdselect);
    } else if (fmt == 3) {
      nranges = stbtt__buf_get(fdselect, 2);
      start = stbtt__buf_get(fdselect, 2);
      for (i = 0; i < nranges; i++) {
        v = stbtt__buf_get8(fdselect);
        end = stbtt__buf_get(fdselect, 2);
        if (glyph_index >= start && glyph_index < end) {
          fdselector = v;
          break;
        }
        start = end;
      }
    }
    return stbtt__get_subrs(info.cff, stbtt__cff_index_get(info.fontdicts, fdselector));
  }
  function stbtt__run_charstring(info, glyph_index, c) {
    var in_header = 1, maskbits = 0, subr_stack_height = 0, sp = 0, v, i, b0, has_subrs = 0, clear_stack, s = [], subr_stack = [], subrs = info.subrs, b, f;
    b = stbtt__cff_index_get(info.charstrings, glyph_index);
    while (b.cursor < b.length) {
      i = 0;
      clear_stack = 1;
      b0 = stbtt__buf_get8(b);
      switch (b0) {
        case 19:
        case 20:
          if (in_header) {
            maskbits += sp / 2 | 0;
          }
          in_header = 0;
          stbtt__buf_skip(b, (maskbits + 7) / 8 | 0);
          break;
        case 1:
        case 3:
        case 18:
        case 23:
          maskbits += sp / 2 | 0;
          break;
        case 21:
          in_header = 0;
          if (sp < 2) {
            return 0;
          }
          stbtt__csctx_rmove_to(c, s[sp - 2], s[sp - 1]);
          break;
        case 4:
          in_header = 0;
          if (sp < 1) {
            return 0;
          }
          stbtt__csctx_rmove_to(c, 0, s[sp - 1]);
          break;
        case 22:
          in_header = 0;
          if (sp < 1) {
            return 0;
          }
          stbtt__csctx_rmove_to(c, s[sp - 1], 0);
          break;
        case 5:
          if (sp < 2) {
            return 0;
          }
          for (; i + 1 < sp; i += 2) {
            stbtt__csctx_rline_to(c, s[i], s[i + 1]);
          }
          break;
        case 7:
          if (sp < 1) {
            return 0;
          }
          for (; ; ) {
            if (i >= sp) {
              break;
            }
            stbtt__csctx_rline_to(c, 0, s[i]);
            i++;
            if (i >= sp) {
              break;
            }
            stbtt__csctx_rline_to(c, s[i], 0);
            i++;
          }
          break;
        case 6:
          if (sp < 1) {
            return 0;
          }
          for (; ; ) {
            if (i >= sp) {
              break;
            }
            stbtt__csctx_rline_to(c, s[i], 0);
            i++;
            if (i >= sp) {
              break;
            }
            stbtt__csctx_rline_to(c, 0, s[i]);
            i++;
          }
          break;
        case 31:
          if (sp < 4) {
            return 0;
          }
          for (; ; ) {
            if (i + 3 >= sp) {
              break;
            }
            stbtt__csctx_rccurve_to(
              c,
              s[i],
              0,
              s[i + 1],
              s[i + 2],
              sp - i == 5 ? s[i + 4] : 0,
              s[i + 3]
            );
            i += 4;
            if (i + 3 >= sp) {
              break;
            }
            stbtt__csctx_rccurve_to(
              c,
              0,
              s[i],
              s[i + 1],
              s[i + 2],
              s[i + 3],
              sp - i == 5 ? s[i + 4] : 0
            );
            i += 4;
          }
          break;
        case 30:
          if (sp < 4) {
            return 0;
          }
          for (; ; ) {
            if (i + 3 >= sp) {
              break;
            }
            stbtt__csctx_rccurve_to(
              c,
              0,
              s[i],
              s[i + 1],
              s[i + 2],
              s[i + 3],
              sp - i == 5 ? s[i + 4] : 0
            );
            i += 4;
            if (i + 3 >= sp) {
              break;
            }
            stbtt__csctx_rccurve_to(
              c,
              s[i],
              0,
              s[i + 1],
              s[i + 2],
              sp - i == 5 ? s[i + 4] : 0,
              s[i + 3]
            );
            i += 4;
          }
          break;
        case 8:
          if (sp < 6) {
            return 0;
          }
          for (; i + 5 < sp; i += 6) {
            stbtt__csctx_rccurve_to(
              c,
              s[i],
              s[i + 1],
              s[i + 2],
              s[i + 3],
              s[i + 4],
              s[i + 5]
            );
          }
          break;
        case 24:
          if (sp < 8) {
            return 0;
          }
          for (; i + 5 < sp - 2; i += 6) {
            stbtt__csctx_rccurve_to(
              c,
              s[i],
              s[i + 1],
              s[i + 2],
              s[i + 3],
              s[i + 4],
              s[i + 5]
            );
          }
          if (i + 1 >= sp) {
            return 0;
          }
          stbtt__csctx_rline_to(c, s[i], s[i + 1]);
          break;
        case 25:
          if (sp < 8) {
            return 0;
          }
          for (; i + 1 < sp - 6; i += 2) {
            stbtt__csctx_rline_to(c, s[i], s[i + 1]);
          }
          if (i + 5 >= sp) {
            return 0;
          }
          stbtt__csctx_rccurve_to(
            c,
            s[i],
            s[i + 1],
            s[i + 2],
            s[i + 3],
            s[i + 4],
            s[i + 5]
          );
          break;
        case 26:
        case 27:
          if (sp < 4) {
            return 0;
          }
          f = 0;
          if (sp & 1) {
            f = s[i];
            i++;
          }
          for (; i + 3 < sp; i += 4) {
            if (b0 == 27) {
              stbtt__csctx_rccurve_to(
                c,
                s[i],
                f,
                s[i + 1],
                s[i + 2],
                s[i + 3],
                0
              );
            } else {
              stbtt__csctx_rccurve_to(
                c,
                f,
                s[i],
                s[i + 1],
                s[i + 2],
                0,
                s[i + 3]
              );
            }
            f = 0;
          }
          break;
        case 10:
          if (!has_subrs) {
            if (info.fdselect.length) {
              subrs = stbtt__cid_get_glyph_subrs(info, glyph_index);
            }
            has_subrs = 1;
          }
        case 29:
          if (sp < 1) {
            return 0;
          }
          v = s[--sp] | 0;
          if (subr_stack_height >= 10) {
            return 0;
          }
          subr_stack[subr_stack_height++] = b;
          b = stbtt__get_subr(b0 == 10 ? subrs : info.gsubrs, v);
          if (b.length == 0) {
            return 0;
          }
          b.cursor = 0;
          clear_stack = 0;
          break;
        case 11:
          if (subr_stack_height <= 0) {
            return 0;
          }
          b = subr_stack[--subr_stack_height];
          clear_stack = 0;
          break;
        case 14:
          stbtt__csctx_close_shape(c);
          return 1;
        case 12:
          var dx1, dx2, dx3, dx4, dx5, dx6, dy1, dy2, dy3, dy4, dy5, dy6, dx, dy, b1 = stbtt__buf_get8(b);
          switch (b1) {
            case 34:
              if (sp < 7) {
                return 0;
              }
              dx1 = s[0];
              dx2 = s[1];
              dy2 = s[2];
              dx3 = s[3];
              dx4 = s[4];
              dx5 = s[5];
              dx6 = s[6];
              stbtt__csctx_rccurve_to(c, dx1, 0, dx2, dy2, dx3, 0);
              stbtt__csctx_rccurve_to(c, dx4, 0, dx5, -dy2, dx6, 0);
              break;
            case 35:
              if (sp < 13) {
                return 0;
              }
              dx1 = s[0];
              dy1 = s[1];
              dx2 = s[2];
              dy2 = s[3];
              dx3 = s[4];
              dy3 = s[5];
              dx4 = s[6];
              dy4 = s[7];
              dx5 = s[8];
              dy5 = s[9];
              dx6 = s[10];
              dy6 = s[11];
              stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
              stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
              break;
            case 36:
              if (sp < 9) {
                return 0;
              }
              dx1 = s[0];
              dy1 = s[1];
              dx2 = s[2];
              dy2 = s[3];
              dx3 = s[4];
              dx4 = s[5];
              dx5 = s[6];
              dy5 = s[7];
              dx6 = s[8];
              stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, 0);
              stbtt__csctx_rccurve_to(c, dx4, 0, dx5, dy5, dx6, -(dy1 + dy2 + dy5));
              break;
            case 37:
              if (sp < 11) {
                return 0;
              }
              dx1 = s[0];
              dy1 = s[1];
              dx2 = s[2];
              dy2 = s[3];
              dx3 = s[4];
              dy3 = s[5];
              dx4 = s[6];
              dy4 = s[7];
              dx5 = s[8];
              dy5 = s[9];
              dx6 = dy6 = s[10];
              dx = dx1 + dx2 + dx3 + dx4 + dx5;
              dy = dy1 + dy2 + dy3 + dy4 + dy5;
              if (abs(dx) > abs(dy)) {
                dy6 = -dy;
              } else {
                dx6 = -dx;
              }
              stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
              stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
              break;
            default:
              return 0;
          }
          break;
        default:
          if (b0 != 255 && b0 != 28 && (b0 < 32 || b0 > 254)) {
            return 0;
          }
          if (b0 == 255) {
            f = (stbtt__buf_get(b, 4) | 0) / 65536;
          } else {
            stbtt__buf_skip(b, -1);
            f = (stbtt__cff_int(b) << 16 | 0) >> 16;
          }
          if (sp >= 48) {
            return 0;
          }
          s[sp++] = f;
          clear_stack = 0;
          break;
      }
      if (clear_stack) {
        sp = 0;
      }
    }
    return 0;
  }
  function stbtt__csctx_init() {
    return {
      started: 0,
      first_x: 0,
      first_y: 0,
      x: 0,
      y: 0,
      min_x: 0,
      max_x: 0,
      min_y: 0,
      max_y: 0,
      vertices: []
    };
  }
  function stbtt__GetGlyphShapeT2(info, glyph_index) {
    var output_ctx = stbtt__csctx_init();
    if (stbtt__run_charstring(info, glyph_index, output_ctx)) {
      return output_ctx.vertices;
    }
    return null;
  }
  function stbtt__GetGlyphInfoT2(info, glyph_index, out) {
    var c = stbtt__csctx_init();
    var r = stbtt__run_charstring(info, glyph_index, c);
    out.x0 = r ? c.min_x : 0;
    out.y0 = r ? c.min_y : 0;
    out.x1 = r ? c.max_x : 0;
    out.y1 = r ? c.max_y : 0;
    return r && c.vertices ? c.vertices.length : 0;
  }
  function stbtt_GetGlyphShape(info, glyph_index) {
    if (!info.cff.length) {
      return stbtt__GetGlyphShapeTT(info, glyph_index);
    } else {
      return stbtt__GetGlyphShapeT2(info, glyph_index);
    }
  }
  function stbtt_GetGlyphHMetrics(info, glyph_index) {
    var numOfLongHorMetrics = ttUSHORT(info.data, info.hhea + 34);
    if (glyph_index < numOfLongHorMetrics) {
      return {
        advanceWidth: ttSHORT(info.data, info.hmtx + 4 * glyph_index),
        leftSideBearing: ttSHORT(info.data, info.hmtx + 4 * glyph_index + 2)
      };
    } else {
      return {
        advanceWidth: ttSHORT(info.data, info.hmtx + 4 * (numOfLongHorMetrics - 1)),
        leftSideBearing: ttSHORT(info.data, info.hmtx + 4 * numOfLongHorMetrics + 2 * (glyph_index - numOfLongHorMetrics))
      };
    }
  }
  function stbtt_GetFontVMetrics(info) {
    return {
      ascent: ttSHORT(info.data, info.hhea + 4),
      descent: ttSHORT(info.data, info.hhea + 6),
      linegap: ttSHORT(info.data, info.hhea + 8)
    };
  }
  function stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y, shift_x, shift_y) {
    var tmp = {};
    if (!stbtt_GetGlyphBox(font, glyph, tmp)) {
      return { x0: 0, y0: 0, x1: 0, y1: 0 };
    }
    return {
      x0: floor(tmp.x0 * scale_x + shift_x),
      y0: floor(-tmp.y1 * scale_y + shift_y),
      x1: ceil(tmp.x1 * scale_x + shift_x),
      y1: ceil(-tmp.y0 * scale_y + shift_y)
    };
  }
  function stbtt__new_active(e, off_x, start_point) {
    var dxdy = (e.x1 - e.x0) / (e.y1 - e.y0);
    return {
      fdx: dxdy,
      fdy: dxdy != 0 ? 1 / dxdy : 0,
      fx: e.x0 + dxdy * (start_point - e.y0) - (off_x | 0),
      direction: e.invert ? 1 : -1,
      sy: e.y0,
      ey: e.y1,
      next: 0
    };
  }
  function stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x1, y1) {
    x = x | 0;
    if (y0 == y1) {
      return;
    }
    if (y0 > e.ey) {
      return;
    }
    if (y1 < e.sy) {
      return;
    }
    if (y0 < e.sy) {
      x0 += (x1 - x0) * (e.sy - y0) / (y1 - y0);
      y0 = e.sy;
    }
    if (y1 > e.ey) {
      x1 += (x1 - x0) * (e.ey - y1) / (y1 - y0);
      y1 = e.ey;
    }
    if (x0 <= x && x1 <= x) {
      scanline[x] += e.direction * (y1 - y0);
    } else if (x0 >= x + 1 && x1 >= x + 1) ;
    else {
      scanline[x] += e.direction * (y1 - y0) * (1 - (x0 - x + (x1 - x)) / 2);
    }
  }
  function stbtt__fill_active_edges_new(scanline, scanline_fill, len, e, y_top) {
    var y_bottom = y_top + 1;
    while (e) {
      if (e.fdx == 0) {
        var x0 = e.fx;
        if (x0 < len) {
          if (x0 >= 0) {
            stbtt__handle_clipped_edge(scanline, x0, e, x0, y_top, x0, y_bottom);
            stbtt__handle_clipped_edge(scanline_fill, x0 + 1, e, x0, y_top, x0, y_bottom);
          } else {
            stbtt__handle_clipped_edge(scanline_fill, 0, e, x0, y_top, x0, y_bottom);
          }
        }
      } else {
        var x0 = e.fx, dx = e.fdx, xb = x0 + dx, x_top, x_bottom, sy0, sy1, dy = e.fdy;
        if (e.sy > y_top) {
          x_top = x0 + dx * (e.sy - y_top);
          sy0 = e.sy;
        } else {
          x_top = x0;
          sy0 = y_top;
        }
        if (e.ey < y_bottom) {
          x_bottom = x0 + dx * (e.ey - y_top);
          sy1 = e.ey;
        } else {
          x_bottom = xb;
          sy1 = y_bottom;
        }
        if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {
          if ((x_top | 0) == (x_bottom | 0)) {
            var height = sy1 - sy0, x = x_top | 0;
            scanline[x] += e.direction * (1 - (x_top - x + (x_bottom - x)) / 2) * height;
            scanline_fill[x + 1] += e.direction * height;
          } else {
            var t, x, x1, x2, y_crossing, step, sign, area;
            if (x_top > x_bottom) {
              sy0 = y_bottom - (sy0 - y_top);
              sy1 = y_bottom - (sy1 - y_top);
              t = sy0, sy0 = sy1, sy1 = t;
              t = x_bottom, x_bottom = x_top, x_top = t;
              dx = -dx;
              dy = -dy;
              t = x0, x0 = xb, xb = t;
            }
            x1 = x_top | 0;
            x2 = x_bottom | 0;
            y_crossing = (x1 + 1 - x0) * dy + y_top;
            sign = e.direction;
            area = sign * (y_crossing - sy0);
            scanline[x1] += area * (1 - (x_top - x1 + (x1 + 1 - x1)) / 2);
            step = sign * dy;
            for (x = x1 + 1; x < x2; ++x) {
              scanline[x] += area + step / 2;
              area += step;
            }
            y_crossing += dy * (x2 - (x1 + 1));
            scanline[x2] += area + sign * (1 - (x2 - x2 + (x_bottom - x2)) / 2) * (sy1 - y_crossing);
            scanline_fill[x2 + 1] += sign * (sy1 - sy0);
          }
        } else {
          for (var x = 0; x < len; ++x) {
            var y0 = y_top, x1 = x, x2 = x + 1, x3 = xb, y3 = y_bottom, y1 = (x - x0) / dx + y_top, y2 = (x + 1 - x0) / dx + y_top;
            if (x0 < x1 && x3 > x2) {
              stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x1, y1);
              stbtt__handle_clipped_edge(scanline, x, e, x1, y1, x2, y2);
              stbtt__handle_clipped_edge(scanline, x, e, x2, y2, x3, y3);
            } else if (x3 < x1 && x0 > x2) {
              stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x2, y2);
              stbtt__handle_clipped_edge(scanline, x, e, x2, y2, x1, y1);
              stbtt__handle_clipped_edge(scanline, x, e, x1, y1, x3, y3);
            } else if (x0 < x1 && x3 > x1) {
              stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x1, y1);
              stbtt__handle_clipped_edge(scanline, x, e, x1, y1, x3, y3);
            } else if (x3 < x1 && x0 > x1) {
              stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x1, y1);
              stbtt__handle_clipped_edge(scanline, x, e, x1, y1, x3, y3);
            } else if (x0 < x2 && x3 > x2) {
              stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x2, y2);
              stbtt__handle_clipped_edge(scanline, x, e, x2, y2, x3, y3);
            } else if (x3 < x2 && x0 > x2) {
              stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x2, y2);
              stbtt__handle_clipped_edge(scanline, x, e, x2, y2, x3, y3);
            } else {
              stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x3, y3);
            }
          }
        }
      }
      e = e.next;
    }
  }
  function stbtt__rasterize_sorted_edges(result, edges, nedges, vsubsample, off_x, off_y) {
    off_x |= 0, off_y |= 0;
    var active = null, z;
    var y = off_y, j = 0, i;
    var scanline = new Float32Array(result.w * 2 + 1);
    var scanline2 = scanline.subarray(result.w);
    var eoff = 0;
    edges[nedges].y0 = off_y + result.h + 1;
    while (j < result.h) {
      var scan_y_top = y + 0, scan_y_bottom = y + 1, step = active;
      if (scanline.fill) {
        scanline.fill(0);
      } else {
        for (var $i = 0, $l = scanline.length; $i < $l; $i++) scanline[$i] = 0;
      }
      while (step) {
        z = step;
        step = z.next;
        if (z.ey <= scan_y_top) {
          z.direction = 0;
        }
      }
      while (edges[eoff].y0 <= scan_y_bottom) {
        if (edges[eoff].y0 != edges[eoff].y1) {
          z = stbtt__new_active(edges[eoff], off_x, scan_y_top);
          z.next = active;
          active = z;
        }
        ++eoff;
      }
      if (active) {
        stbtt__fill_active_edges_new(scanline, scanline2, result.w, active, scan_y_top);
      }
      for (var i = 0, sum = 0; i < result.w; ++i) {
        var k, m;
        sum += scanline2[i];
        k = scanline[i] + sum;
        k = abs(k) * 255 + 0.5;
        m = k >>> 0;
        if (m > 255) {
          m = 255;
        }
        result.pixels[j * result.stride + i] = m;
      }
      step = active;
      while (step) {
        z = step;
        z.fx += z.fdx;
        step = z.next;
      }
      ++y;
      ++j;
    }
  }
  function stbtt__sort_edges_ins_sort(p, n) {
    for (var i = 1; i < n; ++i) {
      var t = p[i], j = i;
      while (j > 0 && t.y0 < p[j - 1].y0) {
        p[j] = p[j - 1];
        --j;
      }
      if (i != j) {
        p[j] = t;
      }
    }
  }
  function stbtt__sort_edges_quicksort(p, o, n) {
    while (n > 12) {
      var t, c, i, j, z, m = n >> 1, c01 = p[o].y0 < p[o + m].y0, c12 = p[o + m].y0 < p[o + n - 1].y0;
      if (c01 != c12) {
        c = p[o].y0 < p[o + n - 11].y0;
        z = c == c12 ? 0 : n - 1;
        t = p[o + z];
        p[o + z] = p[o + m];
        p[o + m] = t;
      }
      t = p[o];
      p[o] = p[o + m];
      p[o + m] = t;
      i = 1;
      j = n - 1;
      for (; ; ) {
        for (; p[o + i].y0 < p[o].y0; ++i) {
        }
        for (; p[o].y0 < p[o + j].y0; --j) {
        }
        if (i >= j) {
          break;
        }
        t = p[o + i];
        p[o + i] = p[o + j];
        p[o + j] = t;
        ++i;
        --j;
      }
      if (j < n - i) {
        stbtt__sort_edges_quicksort(p, o, j);
        o += i;
        n -= i;
      } else {
        stbtt__sort_edges_quicksort(p, o + i, n - i);
        n = j;
      }
    }
  }
  function stbtt__sort_edges(p, n) {
    stbtt__sort_edges_quicksort(p, 0, n);
    stbtt__sort_edges_ins_sort(p, n);
  }
  function stbtt__rasterize(result, pts, wcount, scale_x, scale_y, shift_x, shift_y, off_x, off_y, invert) {
    var y_scale_inv = -scale_y, e, n, i, j, k, m, vsubsample = 1;
    n = 0;
    for (i = 0; i < wcount.length; ++i) {
      n += wcount[i];
    }
    e = oalloc(n + 1);
    n = 0;
    m = 0;
    for (i = 0; i < wcount.length; ++i) {
      var p = m;
      m += wcount[i];
      j = wcount[i] - 1;
      for (k = 0; k < wcount[i]; j = k++) {
        var a = k, b = j;
        if (pts[p + j].y == pts[p + k].y) {
          continue;
        }
        e[n].invert = 0;
        if (pts[p + j].y > pts[p + k].y) {
          e[n].invert = 1;
          a = j, b = k;
        }
        e[n].x0 = pts[p + a].x * scale_x + shift_x;
        e[n].y0 = (pts[p + a].y * y_scale_inv + shift_y) * vsubsample;
        e[n].x1 = pts[p + b].x * scale_x + shift_x;
        e[n].y1 = (pts[p + b].y * y_scale_inv + shift_y) * vsubsample;
        ++n;
      }
    }
    stbtt__sort_edges(e, n);
    stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y);
  }
  function stbtt__tesselate_curve(points, x0, y0, x1, y1, x2, y2, objspace_flatness_squared, n) {
    var mx = (x0 + 2 * x1 + x2) / 4, my = (y0 + 2 * y1 + y2) / 4, dx = (x0 + x2) / 2 - mx, dy = (y0 + y2) / 2 - my;
    if (n > 16) {
      return 1;
    }
    if (dx * dx + dy * dy > objspace_flatness_squared) {
      stbtt__tesselate_curve(
        points,
        x0,
        y0,
        (x0 + x1) / 2,
        (y0 + y1) / 2,
        mx,
        my,
        objspace_flatness_squared,
        n + 1
      );
      stbtt__tesselate_curve(
        points,
        mx,
        my,
        (x1 + x2) / 2,
        (y1 + y2) / 2,
        x2,
        y2,
        objspace_flatness_squared,
        n + 1
      );
    } else {
      points.push({ x: x2, y: y2 });
    }
    return 1;
  }
  function stbtt__tesselate_cubic(points, x0, y0, x1, y1, x2, y2, x3, y3, objspace_flatness_squared, n) {
    var dx0 = x1 - x0, dy0 = y1 - y0, dx1 = x2 - x1, dy1 = y2 - y1, dx2 = x3 - x2, dy2 = y3 - y2, dx = x3 - x0, dy = y3 - y0, longlen = sqrt(dx0 * dx0 + dy0 * dy0) + sqrt(dx1 * dx1 + dy1 * dy1) + sqrt(dx2 * dx2 + dy2 * dy2), shortlen = sqrt(dx * dx + dy * dy), flatness_squared = longlen * longlen - shortlen * shortlen;
    if (n > 16) {
      return;
    }
    if (flatness_squared > objspace_flatness_squared) {
      var x01 = (x0 + x1) / 2, y01 = (y0 + y1) / 2, x12 = (x1 + x2) / 2, y12 = (y1 + y2) / 2, x23 = (x2 + x3) / 2, y23 = (y2 + y3) / 2, xa = (x01 + x12) / 2, ya = (y01 + y12) / 2, xb = (x12 + x23) / 2, yb = (y12 + y23) / 2, mx = (xa + xb) / 2, my = (ya + yb) / 2;
      stbtt__tesselate_cubic(
        points,
        x0,
        y0,
        x01,
        y01,
        xa,
        ya,
        mx,
        my,
        objspace_flatness_squared,
        n + 1
      );
      stbtt__tesselate_cubic(
        points,
        mx,
        my,
        xb,
        yb,
        x23,
        y23,
        x3,
        y3,
        objspace_flatness_squared,
        n + 1
      );
    } else {
      points.push({ x: x3, y: y3 });
    }
  }
  function stbtt_FlattenCurves(vertices, objspace_flatness, contour_lengths) {
    var points = [], objspace_flatness_squared = objspace_flatness * objspace_flatness, n = -1, start = 0, x = 0, y = 0;
    for (var i = 0, nverts = vertices.length; i < nverts; ++i) {
      switch (vertices[i].type) {
        case STBTT_vmove:
          if (n >= 0) {
            contour_lengths[n] = points.length - start;
          }
          ++n;
          start = points.length;
          x = vertices[i].x, y = vertices[i].y;
          points.push({ x, y });
          break;
        case STBTT_vline:
          x = vertices[i].x, y = vertices[i].y;
          points.push({ x, y });
          break;
        case STBTT_vcurve:
          stbtt__tesselate_curve(
            points,
            x,
            y,
            vertices[i].cx,
            vertices[i].cy,
            vertices[i].x,
            vertices[i].y,
            objspace_flatness_squared,
            0
          );
          x = vertices[i].x, y = vertices[i].y;
          break;
        case STBTT_vcubic:
          stbtt__tesselate_cubic(
            points,
            x,
            y,
            vertices[i].cx,
            vertices[i].cy,
            vertices[i].cx1,
            vertices[i].cy1,
            vertices[i].x,
            vertices[i].y,
            objspace_flatness_squared,
            0
          );
          x = vertices[i].x, y = vertices[i].y;
          break;
      }
    }
    contour_lengths[n] = points.length - start;
    return points;
  }
  function stbtt_Rasterize(result, flatness_in_pixels, vertices, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert) {
    x_off |= 0, y_off |= 0;
    var scale = scale_x > scale_y ? scale_y : scale_x, wcount = [], windings = stbtt_FlattenCurves(vertices, flatness_in_pixels / scale, wcount);
    if (windings) {
      stbtt__rasterize(
        result,
        windings,
        wcount,
        scale_x,
        scale_y,
        shift_x,
        shift_y,
        x_off,
        y_off
      );
    }
  }
  function InitFont(data2) {
    var font = {};
    if (!stbtt_InitFont_internal(font, data2, 0)) {
      return null;
    }
    var vm = stbtt_GetFontVMetrics(font);
    font.ascent = vm.ascent;
    font.descent = vm.descent;
    font.linegap = vm.linegap;
    return font;
  }
  function GetGlyph(font, codepoint, size_x, size_y) {
    size_y = size_y || size_x;
    var scale_x = size_x / font.ascent;
    var scale_y = size_y / font.ascent;
    var glyph = stbtt_FindGlyphIndex(font, codepoint);
    if (!glyph && codepoint) {
      return null;
    }
    var vertices = stbtt_GetGlyphShape(font, glyph);
    var rect = stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y, 0, 0);
    var width = rect.x1 - rect.x0;
    var height = rect.y1 - rect.y0;
    var pixels = null;
    if (width && height) {
      var gbm = {
        pixels: pixels = new Uint8Array(width * height),
        w: width,
        h: height,
        stride: width
      };
      stbtt_Rasterize(gbm, 0.35, vertices, scale_x, scale_y, 0, 0, rect.x0, rect.y0);
    }
    var hmetrics = stbtt_GetGlyphHMetrics(font, glyph);
    return {
      glyph,
      pixels,
      width,
      height,
      top: -rect.y0,
      left: rect.x0,
      advance: floor(hmetrics.advanceWidth * scale_x)
    };
  }
  function GetPaths(font, codepoint, size_x, size_y) {
    size_y = size_y || size_x;
    var scale_x = size_x / font.ascent;
    var scale_y = size_y / font.ascent;
    var glyph = stbtt_FindGlyphIndex(font, codepoint);
    if (!glyph && codepoint) {
      return null;
    }
    var vertices = stbtt_GetGlyphShape(font, glyph);
    var hmetrics = stbtt_GetGlyphHMetrics(font, glyph);
    var ascent = 0;
    var descent = 0;
    var paths = [];
    if (vertices) {
      for (var i = 0, l = vertices.length; i < l; i++) {
        var v = vertices[i];
        var path;
        if (v.type == STBTT_vmove) {
          path = { type: "M", x: v.x * scale_x, y: v.y * scale_y };
        } else if (v.type == STBTT_vline) {
          path = { type: "L", x: v.x * scale_x, y: v.y * scale_y };
        } else if (v.type == STBTT_vcurve) {
          path = {
            type: "Q",
            x: v.x * scale_x,
            y: v.y * scale_y,
            cx: v.cx * scale_x,
            cy: v.cy * scale_y
          };
        } else if (v.type == STBTT_vcubic) {
          path = {
            type: "C",
            x: v.x * scale_x,
            y: v.y * scale_y,
            cx1: v.cx * scale_x,
            cy1: v.cy * scale_y,
            cx2: v.cx1 * scale_x,
            cy2: v.cy1 * scale_y
          };
        } else {
          continue;
        }
        if (path.y > ascent) ascent = path.y;
        if (path.y < descent) descent = path.y;
        paths.push(path);
      }
    }
    paths.advance = hmetrics.advanceWidth * scale_x;
    paths.ascent = ascent;
    paths.descent = descent;
    return paths;
  }
  return {
    InitFont,
    GetGlyph,
    GetPaths
  };
})();
function toUint8Array(data2) {
  if (typeof data2 == "string") {
    var binary = /[^A-Za-z0-9+\/=\s]/.test(data2);
    return Buffer.from ? Buffer.from(data2, binary ? "binary" : "base64") : new Buffer(data2, binary ? "binary" : "base64");
  } else if (data2 instanceof Uint8Array) {
    return data2;
  } else if (data2 instanceof ArrayBuffer) {
    return new Uint8Array(data2);
  }
  throw new ReferenceError("data must be a binary or base64 encoded string or a Buffer/Uint8Array");
}
FontLib.loadFont("OCR-A", 100, 100, "AAEAAAAPAIAAAwBwRkZUTXxHoksAADPIAAAAHEdERUYAmQAGAAAyIAAAACBHUE9TuP+4/gAAM5gAAAAwR1NVQuq3l/0AADJAAAABWE9TLzKDm4kvAAABeAAAAGBjbWFwO6GiGgAAArgAAAFaZ2FzcP//AAMAADIYAAAACGdseWYfHUemAAAE8AAAKUBoZWFkFeCL3QAAAPwAAAA2aGhlYQcqAgQAAAE0AAAAJGhtdHgagBVHAAAB2AAAAOBsb2NhH+IWRAAABBQAAADabWF4cACxAF0AAAFYAAAAIG5hbWUIp3NfAAAuMAAAAoJwb3N0oJoboAAAMLQAAAFkAAEAAAACAAAhYPsHXw889QALA+gAAAAA2gMjvQAAAADaAyO9AD7/LAJ8BFIAAAAIAAIAAAAAAAAAAQAABFL/LABaAtMAAAAAAnwAAQAAAAAAAAAAAAAAAAAAAAQAAQAAAGwAWgADAAAAAAACAAAAAQABAAAAQAAAAAAAAAACAtMBkAAFAAACigK8AAAAjAKKArwAAAHgADEBAgAAAgAFCQAAAAAAAAAAACMAACoAAAAAAAAAAABQZkVkAEAAICWgAyD/OABaBFIA1AAAAAEAAAAAAjgDDAAAACAAAQLTAAAAAAAAAtMAAALTAAAA9gBJAEkASQBJAEkA3QDdAKwASQBJAKwASQDdAEkASQBJAEkASQBhAEkASQBJAEkASQDdAKwASQBJAEkASQBJAEYASQBJAEkASQBJAEkASQBJAHoASQBJAEkASQBJAEkASQBJAEkASQBJAEkASQBJAEkASABJAEkASQBIAEkAegBJAEkASQBJAEkAYQBJAEkAegB6AEkAegBBAEkASQBJAEkASQBJAEkASQBJAD4ASQBJAEkASQEPAEkASQBxAHEAcQE3AFcA7QBxAQMA1ABxAAAAAwAAAAMAAAAcAAEAAAAAAFQAAwABAAAAHAAEADgAAAAKAAgAAgACAH4kQiUCJaD//wAAACAkQCUCJaD////j3CLbY9rGAAEAAAAAAAAAAAAAAAABBgAAAQAAAAAAAAABAgAAAAIAAAAAAAAAAAAAAAAAAAABAAADBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xdXl9gYQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAFIApgDoAS4BigGqAdYCAgJKAnQCkAKsAsYC5AMIAzIDYAOcA8gD+gQmBFIEggSuBNwFDAU0BVwFhAXEBhIGPgZwBqgG5AcKBy4HageWB8QH7gggCDoIZgiICMoI8glMCYIJwAnmChAKNAp0Cq4K1gr6CyYLRAtwC5QLrgvODBYMdAysDRANag2eDhYOSA6EDsYO+A8iD2YPmA/yEFgQvBDqETQRbhGgEcwSDhJEEnoSqBLiEwITPBNyE5ITthPeE+wT+hQUFEYUaBSIFKAAAAACAPYAAAGNAwwADwAfAAA3NTQ2OwEyFh0BFAYrASImETQ2OwEyFh0BAxQGIyImJ/YeFTEVHh4VMRUeHhUxFB8ZHhQVHAIzKhUdHRUqFR4eArwUHhwTA/6BFR0dFQAAAAABAEkBqAI7AwwAEwAAEychFQYHBiMiJjUnIwcOASMiJidKAQHyJgsMKBQgKHIqAxwSExwDAsJKSrkvMhoS09YRGBgRAAIASQB/AjsDDAA9AEEAABM0NjsBNSMiJjQ2OwE1NDYyFh0BMzU0NjIWHQEzMhYUBisBFTMyFhUUBisBFRQGIiY9ASMVFAYiJj0BIyImNzM1I0kdFTExFR0dFTEdKh5hHiodMRUeHhUxMRUeHhUxHSoeYR4qHTEVHchhYQFcFB5vHiodeBQeHhR4eBQeHhR4HSoebx4UFR53FR4eFXd3FR4eFXceR28AAAEASQAAAjsDDAAxAAA2NDYzITUhIiY9ATQ2OwE1NDYzMhYdATMyFhQGIyEVITIWHQEUBisBFRQGIyImPQEjIkkdFQFb/qUVHR0VlB4VFB6UFR4eFf6lAVsVHh4VlB4UFR6UFccqHkQeFaoVHXgUHh4UeB0qHkQeFaoVHXcVHh4VdwAAAAMASQAAAjsDDAAPAB8ALwAANzQ3ATYzMhYVFAcBBiMiJhE1NDY7ATIWHQEUBisBIiYBNTQ2OwEyFh0BFAYrASImSQoBjQ4aFR4L/nMOGhUdHRVjFR4eFWMVHQEpHhVjFR4eFWMVHocUCwH+Ex0VEg3+AhMdAhNVFB4eFFUVHh79w1QVHh4VVBUeHgAAAwBJAAACOwK3AC4ANgBBAAA3NTQ/AScmPQE0NjsBMhYdARQPARc3NjMyFhUUDgIHFxYVFAYjIi8BBwYrASImNxQWOwE3JwcRFzc1NCYrASIGFUkRXGANWT5gPlkRfWszDxIVHhAPIQI0Dh4VFw43Sg8RYj5ZZR4UTzhrTlVvHhRgFB6XRRgPT2YPFEU+WVk+RRkOa3IsDB4VDRoOGAI4EBIVHhA7PwxZPhUdMHJCASpbXi4UHh0VAAEA3QFUAaYDDAARAAATETQ2OwEyFhcUBg8BDgEjIibdHhVjFRwCMhoZBRoSFR4BhgFUFB4dFQawVVURFR0AAAABAN0AAAHZAwwAGwAAEzU0PwE2MzIWFRQPAQYdARQfARYVFAYjIi8BJt0rdRAYFR8MdRYWdQodFRgQdSsBJsBFOJYTHhQOEpUdIsAiHZUPEBUeE5Y4AAAAAQCsAAABpgMMABsAADc0PwE2PQE0LwEmNTQ2MzIfARYdARQPAQYjIiasCnUWFnUKHRUYEHUrK3UQGBUdMxAPlR0iwCIdlQ8RFB4TljhFwEU4lhMeAAAAAAEASQBVAjsCtwAzAAA3ND8BJyY1NDYzMh8BNTQ2MzIWHQE3NjMyFhUUDwEXFhUUBiMiLwEVFAYjIiY9AQcGIyImSRGZmREdFRMOcx4VFB5zDRQVHhKZmRIeFRQNcx4UFR5zDhMVHdwYD4ODDxgVHQxikRUdHRWRYgwdFRcQg4MQFxUdDGKRFR0dFZFiDB0AAAEASQCNAjsCfwAdAAASNDY7ATU0NjMyFh0BMzIWFAYrARUUBiMiJj0BIyJJHRWUHhUUHpQVHh4VlB4UFR6UFQFxKh6UFB4eFJQeKh2UFR4eFZQAAAEArAAAAdcBZAAQAAASNDY7ATIWHQEUBiImPQEjIqwdFccVHR0qHpQVARwqHh4V/hUeHhXMAAAAAQBJASkCOwG5AA8AABM1NDYzITIWHQEUBiMhIiZJHRUBjRUeHhX+cxUdAVwqFR4eFSoVHh4AAAABAN0AfwGmATkADwAANzU0NjsBMhYdARQGKwEiJt0eFWMVHh4VYxUeslUVHR0VVRUeHgAAAQBJAAACOwMMAA8AADc0NwE2MzIWFRQHAQYjIiZJBgGNDx0VHgf+cw8dFR0zDQwCpxkeFAwO/VkZHgAAAgBJAAACOwMMAA8AEwAANxE0NjMhMhYVERQGIyEiJjchESFJPCkBKCg9PSj+2Ck8ZQEo/thlAkIpPDwp/b4pPDwpAkIAAAAAAQBJAAACOwMMABwAADc0NjsBESMiJjU0NjsBETM1NDYyFh0BFAYjISImSR0VlJQVHR0V+WIdKh4eFf5zFR0zFB4CQh4VFB79WcwVHh4V/hUeHgAAAQBJAAACOwMMAB4AADMRNDYzITUhIiY1NDYzITIWHQEUBiMhFSEyFhUUBiNJPCkBKP6lFR0dFQFbKD08Kf7YAVoVHh4VAVQpO+8eFRQePCnvKDzvHhQVHgAAAAABAEkAAAI7AwwAKgAANzQ2MyE1NCYrASImNDY7ATI2PQEhIiY1NDYzITIWHQEUBxYdARQGIyEiJkkdFQFbHxTFFR0dFcUVHv6lFR0dFQFbKD0oKD0o/qUVHTMUHrwUHx0qHh4UvB4VFB48Kbw6Kys6vCk8HgAAAAABAGEAAAIiAwwAHQAAExE0NjIWFREzETQ2MzIWFREyFhQGIxUUBiMiJj0BYR4qHcUeFRQeFR0dFR4UFR4A/wHbFB4eFP6KASEVHR0V/t8eKh3MFR4eFcwAAQBJAAACOwMMACIAADc0NjMyHwEzNSERITIWFRQGKwEVMzIWHQEUBisBIi4CJyZJHRUMCFrt/tYBXBUeHhX3xSg9PSjjFCkaLAkeXRUdBCbvAbgeFBUe7j0o7yk8CgsVBA0AAAIASQAAAjsDDAAXABsAADcRNDY7ATIWFRQGIxEhMhYdARQGIyEiJjchNSFJHRUyFR0dFQFbFR4eFf5zFR1kASn+1zMCpxQeHhQVHv69HhX+FR4eR5oAAAABAEkAAAI7AwwAGwAAEzU0NjMhERQPARUUBiMiJj0BND8BNSEOASMiJkkdFQHAErUeFBUeErX+1wMcExUdAq8rFB7+zxcQmucVHh4V/hcQmrUSGB0AAAAAAwBJAAACOwMMABcAGwAfAAA3NTQ2MxE0NjsBMhYVETIWHQEUBiMhIiY3ITUhNzM1I0k7KRwVxxUcKD09KP7XKTtkASn+12RhYWXvKTwBIRUdHRX+3z0o7yk8PCnvZe4AAgBJAAACOwMMABcAGwAAExE0NjMhMhYVERQGKwEiJjU0NjMRISImNyE1IUkdFQGNFR4eFTIVHR0V/qUVHWQBKf7XAdsA/xQeHhT9WRUeHhUUHgFDHkeaAAIA3QB/AaYCjQAPAB8AADc1NDY7ATIWHQEUBisBIiYRNTQ2OwEyFh0BFAYrASIm3R4VYxUeHhVjFR4eFWMVHh4VYxUeslUVHR0VVRUeHgFoVRUeHhVVFR0dAAAAAgCsAAAB1wK3ABAAIAAAEjQ2OwEyFh0BFAYiJj0BIyIDNTQ2OwEyFh0BFAYrASImrB0VxxUdHSoelBUdHRVkFB4eFGQVHQEcKh4eFf4VHh4VzAExVRUdHRVVFR4eAAAAAQBJAFUCOwK3ABYAABM1NDclNjMyFhUUBw0BFhUUBiMiJyUmSRgBjQsPFR4Z/pkBZxkeFQ8L/nMYAXArHQ/pBx0VHBDT0xAcFR0H6Q8AAAACAEkA/wI7AjgACwAXAAASNDYzITIWFAYjISImNDYzITIWFAYjISJJHRUBjRUeHhX+cxUdHRUBjRUeHhX+cxUBHCoeHiod8SoeHiodAAAAAAEASQBVAjsCtwAWAAA3NDctASY1NDYzMhcFFh0BFAcFBiMiJkkYAWj+mBgdFQ8LAY0ZFP5uCw8VHYcdD9PTDx0VHQfpEBwqHQzsBx0AAAAAAgBJAAACOwMMAB4AKAAAEzQ3ATYyHwEWHQEUBwUVFAYiJj0BNDclNScFBiMiJhM0NjIWFRQGIiZJEQEqDyQPYxIS/ugeKh0RARkx/vcPEhUdYx0qHh4qHQHbGA4A/wwMVQ8XVRcQ7z4VHR0VVRkO7yYq4wwe/m0UHh4UFR4eAAACAEkAAAI7AwwALQA4AAA3NTQ2OwEyFhURFBYyNjURNCYrASIGBwYjIiY1NDc2OwEyFhURFAYjIicGIyImNxQWMjY9ASMiBhVJWD1kFB4dKB0uH48ZLQwOHxUdNjdEj0lpWT05Kiw4PVhlHCgdMRQclrc+WB4V/uYUHR0UAcQgLSMXGx4VJDEyakj+PD1ZJydYPhQdHRToHRQAAAACAEYAAAI8AwwAFQAYAAA3Ez4BMhYXExQGIyImLwEjBw4BIyImNzMDRssFGiIcBMofFREaBSffJwUbERUfqqNSMwK1EBQUEP1LFR4UEIaGEBQe8QEWAAAAAwBJAAACOwMMAA4AGAAiAAAzESEyFh0BFAcWHQEUBiMnMzI2PQE0JisBNTMyNj0BNCYrAUkBKFJ4RkZ4UsPDKTw8KcPDKTw8KcMDDHhSJVk+PlklUnhlPSglKTxlPCglKD0AAAEASQAAAjsDDAAlAAATND8BPgE7ATIWFRQGKwEiDwEGFB8BFjsBMhYVFAYrASImJyYnJkkYZRBLLboVHh4Vuh8NZw0NZw0fuhUeHhW6LEkSShwYAYY1MswkLx4UFR4cyxw8HMscHhQVHjAkjT4zAAACAEkAAAI7AwwAGwAoAAA3NDY7AREjIiY1NDY7ATIWHwEWFA8BDgErASImNzMyPwE2NTQvASYrAUkdFTExFR0dFbosSRJmGRllEEstuhUdyCQfDWcODmcNHyQzFB4CQh4VFB4wJMs0ZjTMJC8eRxzLIhgeHMscAAABAEkAAAI7AwwAGQAAMxEhMhYVFAYjIRUzMhYUBisBFSEyFhUUBiNJAb8VHh4V/qaUFB4eFJQBWhUeHhUDDB4UFR7uHiod7x4UFR4AAQBJAAACOwMMABYAADcRITIWFRQGIyEVMzIWFAYrAREUBiImSQG/FR4eFf6m9xUdHRX3HiodMwLZHhQVHpodKh7+ixUeHgAAAQBJAAACOwMMACoAADcRND8BNjsBMhYVFAYrASIPAQYVERQWOwEyNj0BIyImNDY7ARUUBisBIiZJKogtS5UVHh4VlRkPiBUeFMMUH2MVHR0VyFo+wz9YmAEPRTawOh4UFR4Urhwi/vEVHh4VZx0qHsw+WlkAAAAAAQBJAAACOwMMABsAADcRNDYyFhURIRE0NjIWFREUBiImNREhERQGIiZJHSoeASgdKh4eKh3+2B4qHTMCpxQeHhT+3wEhFB4eFP1ZFR4eFQEh/t8VHh4AAAEASQAAAjsDDAAfAAA3NDY7AREjIiY1NDYzITIWFRQGKwERMzIWFRQGIyEiJkkdFZSUFR0dFQGNFR4eFZSUFR4eFf5zFR0zFB4CQh4VFB4eFBUe/b4eFBUeHgAAAQB6AAACCQMMABsAADc1NDYyFh0BFBY7ATI2NRE0NjIWFREUBisBIiZ6HiodHhVfFR4dKh5aPl8+WpeaFR4eFZoVHR4UAkMUHh4U/b0+WVkAAAAAAQBJAAACOwMMAB4AADcRNDYyFh0BATYzMhYVFAcJARYVFAYjIicBFRQGIiZJHSoeATkPEhUeEv6gAWASHhUSD/7HHiodMwKnFB4eFOYBDAweFBgP/tP+0w8XFR4MAQzlFR4eAAEASQAAAjsDDAAOAAAzETQ2MhYVESEyFhUUBiNJHSoeAVoVHh4VAtoUHh4U/YseFBUeAAABAEkAAAI7AwwAGwAANxEzFzczERQGIiY1EQcVFAYjIiY9AScRFAYiJkl+e3p/HiodYh4UFR5hHiodMwLZr6/9JxUeHhUCTowaFR4eFRqK/bQVHh4AAAAAAQBJAAACOwMMABEAADcRMwERNDYyFhURIwERFAYiJkmFAQgdKh6G/vkeKh0zAtn9pgIoFB4eFP0mAlj92xUeHgAAAAACAEkAAAI7AwwAFgApAAATND8BPgEzMhYfARYUDwEOASMiJi8BJjcGFB8BFjMyPwE2NTQvASYjIgdJGGsQPyYnPxBrGRlrED8nJj8QaxhyDQ1sCBIUCGsODmwIExEJAYY1MtcfKSkf1zRmNNcfKSkf1y5zHDwc1hEQ1yIYHhzVEhIAAAACAEkAAAI7AwwADwAZAAA3ESEyFh0BFAYrARUUBiImEzMyNj0BNCYrAUkBWj5aWj71HiodZfUUHx8U9TMC2Vk+tD5a9hUeHgFwHhW0FB4AAAIASQAAAjsDDAAhAEAAADcRND8BNjMyFhURFA4FBxczMhYVFAYrAScHBiMiJjcUOwE3JyY1NDYzMh4DFz4ENRE0JisBBwYVSUbhIC8ySggUDiMOLAUYQRUeHhWGJUsiLTJIZRUIbCUDHhUNFA8IDAIEHw4UCQ0KB+giewEaXj2+Hkky/uYXKSUZIg0kBD0eFBUeXkAeSTIWXF4HCxUeCxoRJAQEGQ0aHBEBGgkMwx4wAAAAAAIASQAAAjsDDAAZACMAADcRITIWHQEUBisBExYVFAYjIicDIxEUBiImEzMyNj0BNCYrAUkBWj5aWz06ywceFR0P6UUeKh1l9RQfHxT1MwLZWj40Plr+pA4LFR4ZAY/+ixUeHgHvHxQ0FR4AAAEASQAAAjsDDAAsAAA3NDYyFhUUFjsBMjUBJj0BNDY7ATIWFRQGIiY1NCYrASIdAgEWFQ4BKwEiJkkdKh4UDvkN/ooXQy75N1EeKh0VDvkMAXQZAkEv+TdQhxUeHhUOFA0B4iAmAy1CUDcVHh4VDRUKAwT+Ih4oL0NQAAABAEkAAAI7AwwAGAAAEzUhFRQGIiY9ASMRFAYjIiY1ESMVFAYiJkkB8h4qHWIeFBUeYR4qHQKFh4cVHh4VIv2MFR4eFQJ0IhUeHgAAAQBJAAACOwMMABsAADcRNDYyFhURFBY7ATI2NRE0NjIWFREUBisBIiZJHSoeHhTDFB8dKh5aPsM+WZcCQxQeHhT9vRUdHhQCQxQeHhT9vT5ZWQAAAQBJAAACOwMMABUAABM1NDYyFh0BGwE1NDYyFh0BAwYjIidJHSoelJQdKh7KDSIjDQIltRQeHhSh/oYBeqEUHh4UtP36ICAAAQBJAAACOwMMACsAADcRNDYyFhURFzM+ATcRNDYzMhYVER4BFzM3ETQ2MhYVEQcGKwEiJwYrASInSR0qHhwpAhQGHhUUHgYUAikdHSoeOQ8dYiASFR5hHg96AmAUHh4U/bswAyYKAUMVHR0V/r0KJgMwAkUUHh4U/aBhGSMjGQABAEkAAAI7AwwAIwAANzQ3EwMmNTQ2MzIXGwE2MzIWFRQHAxMWFRQGIyInCwEGIyImSQa4uAYdFR0Pm5oPHRUeB7i4Bx4VHQ+amw8dFR0zDQwBOgE6DA4UHhn++AEIGR4UDA7+xv7GDgsVHhkBCP74GR4AAAEASQAAAjsDDAAZAAATNTQ2MhYdARc3NTQ2MhYdAQcRFAYjIiY1EUkdKh6Ukx4qHsceFBUeAnNnFB4eFES+vkQUHh4UZ/7+vhUeHhUBQgAAAQBIAAACOwMMABMAADcBISImNTQ2MyEVASEyFhUUBiMhSAFo/ssVHR0VAcD+mAE1FR4eFf5BQAJnHhUUHkD9mR4UFR4AAAAAAgBJAAACOwMMABcAGwAANxE0NjMhMhYVFAYrAREzMhYVFAYjISImNzMRI0kdFQGNFR4eFcbGFR4eFf5zFR1kMDAzAqcUHh4UFR79vh4UFR4eRwJCAAAAAAEASQAAAjsDDAAPAAATNDYzMhcBFhUUBiMiJwEmSR0VHQ8BjQceFR0P/nMGAtoUHhn9WQ4LFR4ZAqcMAAIASQAAAjsDDAAXABsAADc0NjsBESMiJjU0NjMhMhYVERQGIyEiJiUzESNJHRXGxhUdHRUBjRUeHhX+cxUdAV0wMDMUHgJCHhUUHh4U/VkVHh5HAkIAAAABAEgAfwI7AmIAFAAANxM2MzIXExYVFAYjIi8BBwYjIiY1SM0NIB4OyAUeFRsOnZ4OGxUdvgGJGxv+gAwJFR4V7OwVHhUAAAABAEn/mwI7AAAADQAAFzQ2MyEyFhUUBiMhIiZJHRUBjRUeHhX+cxUdMhQeHhQVHh4AAAAAAQB6AagCCQMMABAAABM0NjsBMhcTFhUUBiMiJwEmeh4VYxoOywYeFRAQ/tYSAtoUHhP++gsNFR4MAP8PAAAAAAIASQAAAjsCOAAmADQAADc1NDY7ATIXNC4FKwEiJjQ2OwEyFhcTFAYjIiY1BwYrASImNxQWOwE3NTQmKwEiBhVJWD3BGBQBAQMGCxEMuhUdHRW6PVcCDR8VFB1KCg+VPVhlHBSHax8SwRMdljg+WAcHIQ8cDRAGHSoeVTz+ixUdHhQrB1g+FB0/LBIdHRQAAAIASQAAAjsDDAApAEMAADcRNDYyFh0BNjsBMh4FFxYdARQOBA8BBisBIi4BJxUUBiImNxQfARY7ATI+ATc2PQE0LgEnJisBIg8BBhVJHSoeRENLDRgYDhgHGwE1BA4HGgURESk4Sx02HRceKh1lEVYMFEsOFh4CEg0fARUUSxQMVhEzAqcUHh4U4kADCwUTBRcBLkTOEBsaDxoGDw4kFhcVDxUeHsIXDkoMDB4BDhfODhQaARMMSgsaAAAAAQBJAAACOwI4ACYAADc1NDc+AzsBMhYUBisBIg8BBh0BFB8BFjsBMhYVFAYrASIvASZJNAszITof0xUeHhXTFAxWERFWDBTTFR4eFdM5KVY04HhFLQkxGxkeKh0MSgsaeBcPSQweFBUeJEotAAAAAAIASQAAAjsDDAAtAEgAADc1NDY3Njc2OwEyHgQXNTQ2MhYVERQGIiY9AQ4CKwEiLgcnJjcUHgIXFjsBMj8BNj0BNC8BJisBIg4BBwYVSSonBQMpOEsQHhMeCB8CHSoeHiodFx02HksLExMOEQoRBhMCNGUMDRgEDxFLEg5WEhJWDBRLDhcaBBK1zjA7IAQCJAcHFAYcAecUHh4U/VkVHh4VEBYXFgIGBQoGDgURAitHDBYMEwMMDEoNGHgVEEoMDRoDEBYAAAAAAgBJAAACOwI4ADQAQQAANzU0PgE3NjsBMh4GHwEWHQEUBiMhFRQeAhcWMyEyFhUUBiMhIi4HJyY3ITU0JisBIg4BBwYVSSAaHyk4fQoTFAwUBxQECws1HhX+pgwNGAQPEQEFFR4eFf77CxMTDhEKEQYTAjRlASg8Gn0OFh4CEbXOIzwYGiQCBgQMBBECCgouRHwVHh8MFgwTAwweFBUeAgYFCgYOBRECK8tKGjYMHgEOFwAAAQBhAAACIQMMACQAABI0NjsBNTQ2OwEyFhUUBisBIgYdATMyFhQGKwERFAYiJjURIyJhHRUxaEp5FR0dFXkgLWMUHh4UYx0qHjEVAfAqHiJKaB4UFR4tICIeKh3+YBUeHhUBoAAAAAACAEn/LAI7AjgAQgBZAAA3NTQ+CDc2OwEyHgQXNTQ2MhYVERQOBA8BBisBIiY0NjsBMj4BNzY9AQ4CKwEiLgMvASY3FBY7ATI/ATY9ATQvASYrASIOAQcGFUkDAwsEEAQVAxcBKThLEB4THggfAh0qHgQOBxoFEREpONMVHh4V0w4XHAMSFx42HUsPHxIeBxARNGQ7G0sUDFYSElYMFEsPFxgGEuCjCxYQFAoTBhIDEwEkBwcUBhwBEhUeHhX93BAbGg8aBg8OJB0qHg4aAw4XjRUYFwcGFQUPDi1FGzYMSg4XThUQSgwOGAQSFAAAAAABAEkAAAI6AwwAIAAANxE0NjIWHQE3NjsBMhYXExQGIyImNQMuASsBBxEUBiImSR0qHmAmKzk9VwIMHRUUHg0CGxRHox4qHTMCpxQeHhT3PRhVPP6MFR4dFAFzExxp/skVHh4AAgB6AAACCQM2ABoAKgAANzQ2OwERIyImNDY7ATIWFREzMhYVFAYjISImEzU0NjsBMhYdARQGKwEiJnoeFWNjFR4eFZUUHmIVHh4V/tcVHmMeFTIUHh4UMhUeMxQeAW4dKh4eFf5gHhQVHh4CvCoVHR0VKhUeHgAAAgB6/ywCCQM2AB8ALwAAFzQ2MzIeAjsBMjY1ESMiJjQ2OwEyFhURFAYrASImJxM1NDY7ATIWHQEUBisBIiZ6HhUUGAkZFWIUH5UVHh4VxhUeWT5iOFYI+B4VMRUeHhUxFR5NFR4bHxsdFAIRHSoeHhX9vT5YSjUDLyoVHR0VKhUeHgAAAQBJAAACOwMMAB8AADcRNDYyFhURJTYzMhYVFA8BFxYVFAYjIiclBxUUBiImSR0qHgEIDhIVHhLL/RIdFRMP/vcwHiodMwKnFB4eFP5x4QweFRcPrtgPFxUeDOMqkhUeHgAAAAEAegAAAgkDDAAbAAA3NDY7AREjIiY1NDY7ATIWFREzMhYVFAYjISImeh4VYmIVHh4VlRQeYhUeHhX+1xUeMxQeAkIeFRQeHhT9ix4UFR4eAAAAAAEAQQAAAkICOAAuAAA3ETQ2MzIWFzYzMhc3NjMyFhcTFAYjIiYnAyYrAQcRFAYjIiY1ETQrAQcRFAYiJkEdFRAbBSktPSQWISovSAEPHRUUHgEOAg8GRB4UFR4WCEseKh0zAdIVHhQPIzASG0Iv/m8VHh0UAY8TOv6aFR4eFQGKFkH+oRUeHgABAEkAAAI6AjgAIAAANxE0NjIWHQE3NjsBMhYXExQGIyImNQMuASsBBxEUBiImSR0qHmAmKzk9VwIMHRUUHg0CGxRHox4qHTMB0hUeHhUiPRhVPP6MFR4dFAFzExxp/skVHh4AAgBJAAACOwI4ACYAQAAANzU0PgE3NjsBMh4FFxYdARQOBA8BBisBIi4EJyY3FB4CFxY7ATI+ATc2PQE0JisBIg4BBwYVSSAaHyk4fQ0YGA4YBxsBNQQOBxoFEREpOH0QHRQbCxsENGUMDRgEDxF9DhYeAhI8Gn0OFh4CEbXOIzwYGiQDCwUTBRcBLkTOEBsaDxoGDw4kBwcSCBgDK0cMFgwTAwwMHgEOF84aNgweAQ4XAAAAAgBJ/ywCOwJNACwASgAAFxE0NjIWHQE+CDsBMh4BFx4EHQEUDwEGKwEiLgEnFRQGIiYTFB4CFx4CFxY7ATI/ATY9ATQvASYrASIPAQYVSR0qHgITBhIKEg8TFQsVHTcbGQIwDB0KNVYpORUfNyAVHiodZQoKFQMHGBQJDhUVFAxXERFXDBQVFQ5aDqICvRQeHhQbAhQFEQYNBQcCGBUXAikPJiYXoUQuSiQYHBfYFR0dAZIMFQsSAwcZFAgODEoNGKEYDUsMDlsLFwAAAgBJ/ywCOwI4AC0ASAAANzU0Njc2NzY7ATIeBBc1NDYyFhURFAYiJj0BDgIrASIuBycmNxQeAhcWOwEyPwE2PQE0LwEmKwEiDgEHBhVJKicFAyk4SxAeEx4IHwIdKh4eKh0XHTYeSwsTEw4RChEGEwI0ZQwNGAQPEUsSDlYSElYMFEsOFxoEErXOMDsgBAIkBwcUBhwBEhUeHhX9WRUdHRXlFhcWAgYFCgYOBRECK0cMFgwTAwwMSg0YeBUQSgwNGgMQFgAAAAABAEkAAAI7AjgAHwAANxE0NjIWHQE3NjsBMhYdARQGIiY9ATQmKwEHERQGIiZJHSoedwsSYz1ZHiodHRRRph4qHTMB0hUeHhU7ZghZPRwVHR0VHBQdj/7vFR4eAAEASQAAAjoCOAA0AAA3NDYzMhYXHgE7ATI2NTQnJS4BNTQ3NjsBMhcWFRQGIyImKwEiBhUUFwUeAR0BDgErASInJkkcFRImCQIUBMsYGx3+6yIqJSY11kswCh4VEi0T1g0PEAEWJjUBWj+9ST4TXRUdHQMBCSAWIg14D0MnMyQmPw0RFR4rEgsSBngRTS4CP1k1EAABAEkAAAI7AuIAKgAAEjQ2OwE1NDYyFh0BMzIWFAYrAREUFjsBMj4CMzIWHQEOASsBIiY1ESMiSR0VMR0qHsUVHR0VxRwUZBQZCRkUFR4KVTdkPVgxFQHwKh53FR4eFXceKh3+wxQdGx8bHhUINEtZPQE9AAEASQAAAjsCOAAgAAATNDYzMhYVEx4BOwE3ETQ2MhYVERQGIiY9AQcGKwEiJidJHRUUHg0CGxRHpB0qHh4qHWEmKzk8WAICBRUeHRT+jRQbaAE4FR4eFf4uFR4eFSM+GFU7AAABAEkAAAI7AjgAGgAAEzU0NjIWHQEbATU0NjIWHQEUBwMGKwEiJwMmSR0qHpOVHSoeBacNIT8hDacEAbBVFR4eFUr+rQFTShUeHhVVCgr+gh4eAX4IAAAAAQA+AAACRQI4ACsAABM0NjMyFhcTFzc1NDYzMhYdARc3Ez4BMhYdAQMHDgErASIvAQcGKwEiJi8BPh4VFB0BCiBCHhUUHkIgCgEdKB8LMwUbETEdDzc4Dx0xERsFNAIEFR8dFP7dbHJyFB4eFHJybAEjFB0eFAL+yqoQFBlfXxkUELYAAQBJAAACOwI4ACMAADc0PwEnJjU0NjMyHwE3NjMyFhUUDwEXFhUUBiMiLwEHBiMiJkkKraEMHhUXEJWUEBcVHgyhrQseFRgPn6APGBUdMxMN0MIPERUeE7OzEx4VEQ/C0A4SFR4SwcESHgAAAQBJ/ywCOwI4ACMAABY0NjsBNyMiJwMmPQE0NjIWHQETMxM1NDYyFh0BFAcBBisBIkkdFWdDFSIMlQQdKh6DIIQeKh4F/vwNIogVtyoemR8BUwgMVRUeHhVK/tQBLEoVHh4VVQoK/a4eAAAAAQBJAAACOwI4ABwAADc1NDcBISImNDYzITIWHQEUBwEhMhYVFAYjISImSQ8BYP7bFR0dFQF1FR4Q/qEBPBUeHhX+cxUdMyoXDQFSHSoeHhUqFRD+rx4UFR4eAAABAEkAAAI7AwwAKgAAEjQ2OwEyNj0BNDY7ATIWFRQGKwEVFAcWHQEzMhYVFAYrASImPQE0JisBIkkdFWEWHT0olBUeHhWUJyeUFR4eFZQoPR4VYRUBcSoeHRW8KTweFBUevDksLDm8HhQVHjwpvBQfAAAAAAIBDwAAAXQDDAAIABEAACURMxEUBiMiJhkBNDYzMhYVEQEPZR4UFR4eFRQeMwEh/t8VHh4BmwEhFB4eFP7fAAABAEkAAAI7AwwAKgAANzQ2OwE1NDcmPQEjIiY1NDY7ATIWHQEUFjsBMhYUBisBIgYdARQGKwEiJkkdFZQnJ5QVHR0VlCk8HRViFR4eFWIVHTwplBUdMxQevDksLDm8HhUUHjwpvBQeHiodHxS8KTweAAAAAAEASQGqAjsDCwAmAAATNTQ2MzIWHQEUFjI2PQE0NjIWHQEUBiMiJyY9ATQmIgYdARQGIiZJXTw6WB0oHR0qHlw9PCssHSgcHiodAgVvQVZYPzQUHx8UbxUeHhVvQVUrLj00FB4eFG8VHR0AAAEAcQAAAmMDDAATAAAzETQ2MhYdATMRIREUBiImPQEjEXEdKh5hASweKh1iATEVHh4VzAKn/s8VHh4VzP1ZAAABAHEAAAJjAwwAFQAANxEhETQ2MhYVERQGIiY1ESERFAYiJnEBjR0qHh4qHf7YHiodMwGGASEUHh4U/VkVHh4VASH+3xUeHgABAHEAAAJjAwwAGAAAExE0NjIWFREhETQ2MhYVESMRFAYjIiY1EXEdKh4BKB0qHsceFBUeAVQBhhQeHhT+3wEhFB4eFP56/t8VHh4VASEAAAEBN/+bAZwEUgADAAAFETMRATdlZQS3+0kAAAABAFf/5wJ8AyUAAwAAFxEhEVcCJRkDPvzCAAAAAQDtAAAB5gD6AA8AADc1NDY7ATIWHQEUBisBIibtHRWVFR0dFZUVHTOUFR4eFZQVHh4AAAEAcQAAAmMDDAAeAAATNDcBNjIfARYdARQHBRUUBiImPQE0NyU1JwUGIyImcREBKg8kD2MSEv7oHiodEQEZMf73DxIVHQHbGA4A/wwMVQ8XVRcQ7+cVHh4V/hkO7yYq4wweAAABAQMBqAHRAwwAEwAAATQ2OwEyFhUUBhUDFAYiJjU0NjUBAyAVYxQiATMfKCEBAtoUHhoSAQQB/wAUHhoSAQQBAAAAAAEA1AAAAf8BZAAUAAATNTQ2OwEyFh0BFAYrASImPQEjIibUHRXHFR0dFTIVHWMVHQEHKhUeHhX+FR4eFaEeAAABAHEBVAJjAbkACwAAEjQ2MyEyFhQGIyEicR0VAY0VHh4V/nMVAXEqHh4qHQAAAAAAAA4ArgABAAAAAAAAAFYArgABAAAAAAABAAQBDwABAAAAAAACAAcBJAABAAAAAAADACEBcAABAAAAAAAEAAUBngABAAAAAAAFAAoBugABAAAAAAAGAAQBzwADAAEECQAAAKwAAAADAAEECQABAAgBBQADAAEECQACAA4BFAADAAEECQADAEIBLAADAAEECQAEAAoBkgADAAEECQAFABQBpAADAAEECQAGAAgBxQBNAGEAdAB0AGgAZQB3ACAAUwBrAGEAbABhACAAKAAyADAAMQAxAC0AMQAyACkAOwAgAGIAYQBzAGUAZAAgAG8AbgAgAGMAbwBkAGUAIABiAHkAIABSAGkAYwBoAGEAcgBkACAAQgAuACAAVwBhAGwAZQBzACAAKAAxADkAOAA4AC0AOAA5ACkAIABhAG4AZAAgAFQAbwByACAATABpAGwAbABxAHYAaQBzAHQAAE1hdHRoZXcgU2thbGEgKDIwMTEtMTIpOyBiYXNlZCBvbiBjb2RlIGJ5IFJpY2hhcmQgQi4gV2FsZXMgKDE5ODgtODkpIGFuZCBUb3IgTGlsbHF2aXN0AABPAEMAUgBBAABPQ1JBAABSAGUAZwB1AGwAYQByAABSZWd1bGFyAABGAG8AbgB0AEYAbwByAGcAZQAgADIALgAwACAAOgAgAE8AQwBSACAAQQAgADoAIAAyADcALQA5AC0AMgAwADEAMgAARm9udEZvcmdlIDIuMCA6IE9DUiBBIDogMjctOS0yMDEyAABPAEMAUgAgAEEAAE9DUiBBAABWAGUAcgBzAGkAbwBuACAAMgAgAABWZXJzaW9uIDIgAABPAEMAUgBBAABPQ1JBAAAAAAIAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAbAAAAAEAAgADAAQABQAGAAcACAAJALcACwAMAA0ADgAPABAAEQASABMAFAAVABYAFwAYABkAGgAbABwAHQAeAB8AIAAhACIAIwAkACUAJgAnACgAKQAqACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ADoAOwA8AD0APgA/AEAAQQBCALYARABFAEYARwBIAEkASgBLAEwATQBOAE8AUABRAFIAUwBUAFUAVgBXAFgAWQBaAFsAXABdAF4AXwBgAGEBAgEDAQQBBQEGAQcBCAEJAQoBCwd1bmkyNDQwB3VuaTI0NDEHdW5pMjQ0MghTRjExMDAwMAtibGFja3NxdWFyZQpwZXJpb2QuYWx0DHF1ZXN0aW9uLmFsdA9xdW90ZXNpbmdsZS5hbHQJY29tbWEuYWx0Cmh5cGhlbi5hbHQAAAAB//8AAgABAAAADgAAABgAAAAAAAIAAQADAGsAAQAEAAAAAgAAAAEAAAAKAEQAogACREZMVAAObGF0bgAkAAQAAAAA//8ABgAAAAEAAgADAAQABQAEAAAAAP//AAYAAAABAAIAAwAEAAUABmFhbHQAJnNzMDEALHNzMDIAMnNzMDMAOHNzMDQAPnNzMDUARAAAAAEAAAAeAAEAAQAcAAEAAgAaAAEAAwAYAAEABAAWAAEABQAAAQAAAAEBAAABAgAAAQMAAAEEAAYADgAWAB4AJgAuADYAAwAAAAEAMAABAAAAAQBkAAEAAAABAGgAAQAAAAEAbAABAAAAAQBwAAEAAAABAHQAAQAuAAUAEAAWABwAIgAoAAIACgBpAAIADwBqAAIAEABrAAIAEQBnAAIAIgBoAAEABQAKAA8AEAARACIAAQAGAFYAAQABABEAAQAGAEYAAQABACIAAQAGAF8AAQABAAoAAQAGAFsAAQABAA8AAQAGAFsAAQABABAAAQAAAAoALAAuAAJERkxUAA5sYXRuABgABAAAAAD//wAAAAQAAAAA//8AAAAAAAAAAAABAAAAAMw9os8AAAAA1gbbzAAAAADaAyOv");
FontLib.loadFont("OCR-B", 96, 100, "AAEAAAAPAIAAAwBwRkZUTXxHn14AADmUAAAAHEdERUYAkwAEAAA4IAAAACBHUE9TuP+4/gAAOWQAAAAwR1NVQnZYZVQAADhAAAABJE9TLzJa+GPlAAABeAAAAGBjbWFwzJGg2QAAA2QAAAFCZ2FzcP//AAMAADgYAAAACGdseWbm+CwyAAAFeAAALwRoZWFkFgqHXQAAAPwAAAA2aGhlYQeFAeAAAAE0AAAAJGhtdHgIFCYVAAAB2AAAAYpsb2NhZAZYlAAABKgAAADObWF4cACtAGkAAAFYAAAAIG5hbWWukZg3AAA0fAAAAnlwb3N0tfQXywAANvgAAAEdAAEAAAACAADO4NltXw889QALA+gAAAAA2gMiKgAAAADaAyIqAA7/GQLWAwsAAAAIAAIAAAAAAAAAAQAABFL+sABaAtMAAP/9AtYAAQAAAAAAAAAAAAAAAAAAAF8AAQAAAGYAZgAFAAAAAAACAAAAAQABAAAAQAAAAAAAAAACAsMBkAAFAAACigK8AAAAjAKKArwAAAHgADEBAgAAAgAFCQAAAAAAAAAAAK8AAABoAAAAAAAAAABQZkVkAEAAIAB+AyD/OABaBFIBUAAAAAEAAAAAAiAC+QAAACAAAQLTAAAAAAAAAtMAAALTAAAC0wD1AtMAdALTAEQCvwA/Ar8APwLTAEQC0wDnAtMA0wLTAIgC0wBEAtMARALTAHIC0wBEAtMAxALTAIACvwA/AskAXgK/AFACvwA/Ar8APwK/AFkCvwA/Ar8APwK/AD8CvwA/AtMA1gLTAG8C0wBBAtMARALTAEEC0wBgAtMARAK/AEUCvwA/Ar8AbwK/AHICvwBtAr8AoAK/AEcCvwBbAr8AeAK/AFACvwBNAr8AWwK/AD8CvwBNAr8AQgK/AFsCvwBBAr8AZwK/AGECvwA/Ar8ATQK/AD4CvwA/Ar8AUwK/AFYCvwBbAtMApQLTAIAC0wBVAtMARALTAEQC0wC2Ar8ATQK/AEoCvwB1Ar8APwK/AE0CvwBhAr8AQgK/AGoCyQCDAskAZwK/AHsCyQDLAr8APwK/AE0CvwA/Ar8ASgK/AD8CvwCaAr8AZwK/AE0CvwBNAr8AQgK/AEECvwBhAr8APwK/AGEC0wBEAQwARABSAnICBgG2AA4AAAAAAAMAAAADAAAAHAABAAAAAAA8AAMAAQAAABwABAAgAAAABAAEAAEAAAB+//8AAAAg////4wABAAAAAAAAAQYAAAEAAAAAAAAAAQIAAAACAAAAAAAAAAAAAAAAAAAAAQAAAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALABiAMYBUAG6AkICYgKMArQC8gMaAzoDVgNwA5QEEgQ2BIgE2AUSBVYFngXSBjQGegaoBtwHDAcyB1oHxAhUCIQI2glACXgJrAnaCjQKYgqYCswLAgskC2QLlgvuDB4MgAzODUQNbA2eDcgOEg5ODoAOsg7WDvoPHA9ED2APgg/eECoQaBCyEPgRLBGUEdISAhJOEoASqBLyEygTVhOiE+gUIhSYFN4VGBVGFYYVvBXyFiAWbBaEFs4XDhcmF0QXaheCAAAAAgD1/7wBfQL9AA8AGwAAFzU0NjsBMhYdARQGKwEiJhMRNDYyFhURFAYiJvUbEi4SGxsSLhIbFxskGxomGhcuEhsbEi4SGxsBcgGHExobEv55EhsaAAAAAAIAdAHHAgkC/QASACMAABM1NDY7ATIXFhUwFQ8BDgEjIiYlNTQ2OwEyFxYdAQcOASMiJnQbEh0SDg4BHQIZEhEcASQbEhcRDg4ZBBYREhsB9NwSGw0MDwEC5BAXGxLcExoNDBAE5RAUGwAAAAIARP/4Ai4DAABEAEgAADc0NjsBNyMiJjQ2OwE3PgEzMhcWFQczNzYzMhYdAQcXHgEVFAYrAQczMhYUBisBBw4BIyImPQE3IwcOASMiJyY1NycuATczNyNEGhMVJicSGxoTOygDGRASDQ4liCgNHxIbIwUQFxsSFCUlExobEjopAxoPEhskhykDGRASDQ4mBRIXnoglh/4TGqcaJhqxDhUODhCosSMaEwqcAQMZERIbpxskG7YOFRsSCqK2DxQODRGsAQIaPqcAAwA///sCHwL9AEcAWABfAAA3JjU0NjMyFxYXFhczNScuAScuAjU0NzY/ATU0NjIWHQEXFhcxFhUUBiMiJyYvARUXFhcWFx4BFRQHBg8BFRQGIiY9ASMmJxMGFRQXFhcWFxYXHgIfATUTNzY1NC8BQQIbEhYVFwwYLQUEIS4cGyIWNjZSBBoiGgRpOAkbEhcOITUGBCwcHR8fHjc3UwQaIhoFlSi8YwMECAgFBgwMChwCB1YGZWQHoAUMExodIQYNBNwBChEPDyQ2IkwqKwoBCRMaGxIJAQ5SDA4SGhMsCwHFAQ4MDBYVPytNMDENAQYSGxoTBw1kAcoORQsKCggHBQUGBgUKAQKq/iABFEo8JAIAAAAABQA///gCHwMAAA0AHAAoADcARwAAJSIVFBcWHwEzMjc2NTQHJjU0NzYzMhcWFAcGIyIDIhUUFzsBMjc2NTQHJjU0NzYzMhcWFAcGIyICJjU0NwE2MzIWFRQHAQYjAaIhBQUOAQgRCQl6HyAfNzogICAgOjiuIxgBChEJB3wgISA6Nx8fHx83OycbBgGMDRQSGwb+exAYtTIPDxABAhAPEjKVKDg5KyspKXIqKQKuMikIEA8SMpUoODkrKykqcikp/hQbEw0JAq0MGxIMCv1dFwAAAAADAET/9wIuAwAAQgBOAFwAADc0PwEnJjU0NzYzMhcWFRQHDgEHDgIPARc3NjU0NjIWFRQPARcWFx4BFxYVFAYjIicmJyYnJicmJyYvAQcGKwEuATcUFzMyPwEnBwYHBhMUHwE3Njc2NTQnJiMiRF8EA0Q1NVhKNTQJChQYFxY+BASXBBUcJBs3AgICBwcHAwMbEgYFBgQDBAUCAQUGAQMEPlEGYnVafwYwKAShBRwPEBwwAwRMHiAcGyJozXJUAwRdVVQwMCgmRBsaGyMXGBMuAwPSCDRFExscEnxTAwIFCAgKCQgIEhsCAgEBBQUCAQcIAgICJwFyYnkCFwLhBB0bGwFXOEQEAzYlJx0eDgwAAAEA5wGIAY0C/QASAAATNDY7AR4BFTAVBwMGKwEiJyYn5xsSURAXARUIJCISDQ0BAtATGgIZDwEB/twlCwoRAAABANP/+AHpAwAAGQAAEzU2NzYzMhYVFAcGBwYHFRQXFhUUBiMiJybTA80LDhIbFE4sLQGoFBsSDgvQAXMG8I8IGhMXDjNKS20FvmsOGBMaB4wAAAABAIj/+AGfAwAAGAAANzQ3NjU0LwEmJyY1NDYzMhcWFRQHBiMiJogUqakBBwYGGxIOC9HRCw4SGyUYDm7AwnMBAgwMChIbCJDv7I4HGwAAAAEARACeAi4ChQAqAAATNDc2Mxc1NDYyFh0BNzE2MzIWFRQPARcWFRQGIyIvAQcGIyImNTQ/AScmRA4OEZsbJBuNBggSGyB6UAUaExQMV3AMFBMaCV6MHwG+Eg8OM54TGhsSni4DGxIgCymICwwTGguWlgsbEg0Ofy4MAAABAEQAagIuAo0AGwAAEjQ2OwE1NDYyFh0BMzIWFAYrARUUBiImPQEjIkQbEpsaJhqbEhsbEpsbJBubEgFpJhq3ExobErcbJBu4EhsaE7gAAAEAcv9NAeYAygASAAAXNDcTNjsBMhYdARQHAwYrASImcgWyDBVvEhsN/gwUHBMahgwKAS4MGhMfEwz++w0aAAABAEQBQQIuAbcADwAAEzU0NjMhMhYdARQGIyEiJkQaEwGQExoaE/5wExoBbhwTGhsSHBIbGgAAAAEAxP/7Aa0AtgAPAAA3NTQ2OwEyFh0BFAYrASImxBsSjxIbGxKPEhsoYRIbGhNhExobAAABAID/+AHyAwAAEwAANzQ3MwE+ATMyFhUUByMBDgEjIiaAAwEBGAQYDRIbAwH+6AQYDRIbJQoHAq4MEBsSCgf9UgwQGgAAAAACAD//+AIfAv8AJQBUAAAFIyYnLgEnJicmNTQ2Nz4BNz4CMzIeARceARceARUUDgUDFRQWFxYXHgE7ATI2Nz4BNz4BPQE0JicmJyYnJicmJyYnLgEjIg4CBw4BBw4BATMEOywsNA8QBQUDBgYVEhIySC4tSDITEhUGBgMEDRQmMEbFBQkIEBA4KBUcLA0OEgQFAwEBAQMDBQUICAsMDg8nGBknHhcICAoCAgMIARMSOy8vMC9AOVEvMEEhICYYGCYgIUIvL1I4KEFMOTYkFgGwUi1AJSUXGB8XFhUxHyA0Hy4fJRwdEBEXFw4ODw8ICQoLFB0SESkXFi8AAAABAF7/+wGMAv0AFQAAEiY1ND8BNjsBMhYVERQGIiY1EQcGI3gaDbcNECASGxskG4kNEQIJGxIVCp0LGxL9WBIbGhMCYXULAAABAFAABgILAwAANwAAEiY1NDc2MzIXFhUUBw4BBw4BBw4BBwYHBgcVITIWFAYjISImPQE0NzY3Njc2NzY1NCcmIyIHBiNrGxNbcVs9Pg0NISAgISMmIhgYCwsCASgTGhsS/qoSGwoRLy9EXhkcJSM0Wj4LDwJyGxEZDTw6OV0lIiMsGxsYFxkaGhkgHysFGyQbGxIVTiI8LzAuPyQkKDUhICwIAAEAP//4AhYC/AA3AAA3JjU0NjMyFxYzMjc2NzU0JyYnJiMiJjU0PwEhIiY0NjMhMhYdARQPARcWFxYdAQYHBiMiJyYnJlQVGxIGC0BGTDQ1BCAeLCs1ERoJuP7nEhsaEwFhEhsOoQhVNjUFUE5wHBwcIyMeEBgTGwQdJidKCjMkIw8OGxMSCswbJhobEiQQDrECFjs7WRBtQEADAwcIAAABAD//+wIfAv0AKAAANiY9ATQ3Ez4BMzIWFRQHAzM1NDYyFxYdATMyFhQGKwEVFAcGIiY9ASNaGwXVBBYMEhoFyMMaIg0OOhMaGxI6Dg0iGvWpGhMrCAsBzwsPGxIKCf5GeRIbDg0SeRskG4ESDQ4bEoEAAAIAWf/4AfcC/AAqAC0AABYmNDYzMjc2NTQnJiMiByMiJj0BEz4BMyEyFhQGKwEHMzIXFhUUBwYHBiMSIjN0GxsSyjsSIi1xHyAEEhsOAhkSARwTGhsS8ggTf01OFxgkYL4YAQEIGicacSIfSSU1AxkSAwD/EhgbJBydQUB+NS4vIVoBrQAAAAACAD//+AIfAv0AHwAvAAA3Jic1NDc2Nz4BNzYzMhYVFAcGDwE3NjMyFxYVFAcGIgMGFRQXFjMyNzY1NCcmIyKFQwNFHCgnNjILFBEaC3E1BwsdHm1BQkRE0AYoKilDQikrJyZJRzlBawx9ci80NT85DRsSEQ6ATQoCBkRFdGlCQgFkK0xEKCcoKENOKisAAAABAD//+wIfAvwAHwAAEiY0NjMhMhYVFAcGBwYHBhUUBiImNTQ3Njc2NzY/ASFaGxoTAYYTGjsSNDQWQRoiGkwXNDURGAkC/q8CoRsmGhsSTFkcQUIpeMETGxoU2o0pRUYaKBQHAAAAAAMAP//3Ah8DAAAVACQAQgAAEwYVFBYXHgEXOwE2NzY3PgE1NCcmIhMGFRQXFjsBMjc2NTQvAQMmNTQ/AScmNTQ3NjMyFxYVFAcGDwEXFhUUBgcjIuEmEhUUGxwCAhwODhQUEiYlUimXLSpAFDUmJ5ICrUWOBgZsQD9PTkBAHB0zBgaOdFIqZwKSFCYZJhAPEA4NCAgPECcZJhQU/s9PXjgfHyMjMF9OAv67Olx5YgQEQmtJLzAwMEg7KSghBARieU96BwACAD//+wIfAwAADwAtAAATBhUUFxYzMjc2NTQnJiMiAyY1NDc2MzIXFhUUBwYHBgcGIyImNDc2PwEHBiMixSwqKER3FQoqKUM/bURIRmJlRUYVFSZTeA0PERoOX0QFChogagJ1MENBKShJIShLLC3+tENlaEtLRkZyRzk5QpFvDBomDltuCgIEAAAAAAIA1v/7AZwCEAAPAB8AADc1NDY7ATIWHQEUBisBIiYRNTQ2OwEyFh0BFAYrASIm1hsSbBIbGxJsEhsbEmwSGxoTbBMaKFATGhsSUBIbGgF+UBMaGxJQEhsaAAAAAgBv/1IBswIQABIAIgAAFzQ/ATM2OwEyFhUUBwMGKwEiJhM1NDY7ATIWHQEUBisBIiZvA3wBCR9vEhsBzA4RKxIbexsSbBIbGhNsExqBDAf9GRsSDgP+9Q0aAidQExobElASGxoAAAABAEEARQIuArMAHQAAEy4BJyYnLgE1NDcBMDE2MzIWFRQHDQEWFRQGIyInTwEGAQECAQIOAZkLDhIbDf6hAV8NGxIOCwFcAQUBAgMECAcREAEPCBsSFwnq6g4SEhsIAAACAEQA3QIuAhsACwAXAAA2NDYzITIWFAYjISImNDYzITIWFAYjISJEGxIBkBIbGhP+cBMaGhMBkBMaGxL+cBL3JhobJBv+JhobJBsAAQBBAEUCLgKzABcAAAkBBiMiJjU0Ny0BJjU0NjMyFzAxARYVFAIg/mcLDhIbDQFf/qENGxIOCwGZDgFc/vEIGxISDurqCRcSGwj+8RAREgACAGD/vAH1AwEAOQBLAAATNTQ2NzYzMhcWHQEOAQcGBwYHBhUUBwYiJjU0NzY3Njc2NzY3NjU0JyMiJyYrAgYdARQHBiMiJyYTNTQ2OwEyFh0BFAcGKwEiJyZgPi8vNlA6OQEsHwcUFgkJDg0kGwoKCwwUFQgSEBFTAQUICgQDAW4NDRMSDQ2UGxIuEhsODRIuEg0OAjQMPFsVFTAwWAIxZCMIExQOCwsUDw8dFRoYFw4OFBUKEyIiG0IVAQIOUgkUDw4ODv3MMRUdHRUxFA8PDw8AAAIARP/yAi4DBABKAGUAADc1NDcyHwE3NjMyFxYVERY7ATY3Njc+AT0BNCYnLgEnJicmKwEGBw4BIyInJj0BNjc2NzMyFhcWFx4BHQEUBwYHBiMiLwEHBisBJjcUFxYXHgEXMzI3Njc9AiYnJiMiBwYHDgEVRIgvJwUCDhkSDQ4CHAETDQwEBQMDBQUXEBEbGyMJggsCGRETDQ0MPT9eCTpZGxsREQ0KCiMmNzYdAwQrPQiMWgEBBQQYEwYcEQ8NDRcXHBALCgMEAtIB7wIdAwUYDw8T/vk2AQwNFhUmHZgqPyYlNBcYDAwGVxIYDg8VB1ItLgMqIyM1NXBGfFsxMCInJgQDKAXWGw8QFBUVAREQHQGMARoTFAwMFhQiGAAAAAIARf/1AhoC9gAZABwAABYmPQETPgE7ATIWFxMUBwYjIiYvASMHDgEjEwMzYBufBBgOQg0XA6MODhIPGQMtyywDGQ+9T54LHRUOAp4OFREM/U0TDw8VD8PDDxUCov6qAAMAPwAGAh8C/QAhACsAOQAANiY1ETQ3NjsBMhcWFxYXHgEVFA8BFx4BHQEUBgcGBwYrARMVNzI9ASYnJiMDFRcyPQEmJyYnJicmI1obDQ0TpyQVFR4dFiwyOgQEIicnJCUvLz6nLXqyASspQZaWiAMODRgYGRkkBh0VApIWDw4BAgcIDRxiOVo4BAQeWDACMlkfHwsLAVr1AXwBPh0cATrVAWMLIRUWCwoDBAABAG//8gHwAwsARQAAEyYnNTQ2NzY3Njc2NzMyFxYXFRQHBiMiJyYnJicwMSYrAQYRFR4BFxYXFhceATMyNzY3PgEzMhcWHQEGBwYjIicmJyYnJnYGAQ0QERkYJyQvBTsuLQ0NDRITCQsICQsVHQWBAQQFBAoJDg4tHBwTFgQDGRASDQ0KLS09MiUoGBkREQD/NT8OQGw0MyUkFhYCJiY9ChQPDw0NFRYKEgf+6RIlOiMkGhoXFxoPDxoSFw8PFAo8JiYVFSQkMzMAAAACAHIABgIFAv4AFAAhAAA3JjURNDc2MzIXFhcWFRQHBgcGIyITJxE3Njc2NTQnJicmgA4NDRNmQ0M1RUhGayJLEkUGBmU5OyEgMysVDxUCkxQPDyssTmiFi19eFwcCkQH91AELQUB1UkFAKyQAAAAAAQBtAAYCEwL7ACIAADYmNRE0NzYzITIXFhQGIyEVMzIXFhQHBisBFSEyFxYUBiMhiBsNDRMBTBMNDRsS/uHvEg0ODQ0T7wEfEw0NGxL+tAYdFQKRFQ8ODg8qHdQPDykPDvUODyodAAABAKD/9QICAvoAHgAANyY1ETQ3NjMhMhcWFAYrARUzMhcWFAcGKwERFAcGIq4ODQ0TAQgTDQ0bEtuuEg0ODg0Srg4NJAQPFQKgFA8PDg8qHdQPDygPD/7KFQ8PAAEAR//xAg4DCAA+AAA3Jj0BNDc2NzYzMhcWFxYVFAYjIicmIyIHBgcGFRQXHgEzMj8BNSMiJyY0NjsBMhYVERQHDgEHDgEHBiMiJyZeFxcXLEZeExNYNwsbEhQOK0M+Kh8PEBwSTDUuMgNyEgwNGhGfEhsHCBIREhEQLC5sQivEV2MDYVNUME8DEEgOExQdETYxJD4+SWlYODoUAckODykdHRX+6Q4LDA4ICAYFDk0wAAAAAAEAW//1AgIDBAAdAAAWJjURNDc2MhYVETMRNDc2MhYVERQGIiY1ESMRFAZ2Gw4NJBvzDg0kGxskG/MbCx0VAqoVDw8dFv7lARsVDw8dFv1WFR0dFQEt/tMVHQAAAQB4AAYB5gL6ACMAADcmNDc2OwERIyInJjQ3NjsBMhcWFAcGKwERMzIXFhQHBiMhIoYODQ0TYEwSDQ4NDRPsEw0NDg0STGATDQ0ODRL+7BIVDykPDgIsDw8oDw8PDygPD/3UDg8pDw8AAAAAAQBQ//ABpQMHACMAADYmNTQzMhcWHQEGFRQXFjMyNzY1ETQ2MhYVERQXFBUUBiMiJ4Y2MBMMDQIcGiAeFRcbJBsBZ0EpJyBXN04ODxUKDAQpGhoYGS0CJBUdHRX95wMFBAJMchcAAAABAE3/9QIfAwcAHwAANyY1ETQ2MhYVEQE2MhYUBwMBFhUUBwYjIicBERQHBiJbDhskGwEUDiQbDvwBEw4ODRITDf7VDg0kBA8VAq0VHR0U/ucBOw8dKRD+3P6+ERIVDw8OAVv+yRQPDwAAAAABAFsACwIfAwcAEwAANyY1ETQ2MhYVESEyFxYUBwYjISJpDhskGwE9Ew0NDg0S/pYSGg8UApkUHR0U/ZkPDygPDwAAAAEAP//1Ah8DBAAoAAAWJjURNDY7ATIXFhcbAT4BOwEyFxYVERQGIiY1EQMGBwYjIiYnAxEUBlobGxJNDgwLBE1NAxgOTRINDhskG2wGCwoPDhcEbRsLHRUCqhYdCgsO/uUBGw4VDw8V/VYVHR0UAmv+cxAKChQPAY79lRQdAAAAAQBN//UCEQMIAB8AADcmNRE0NjsBMhYXExE0NjIWFREUBwYrASInAxEUBwYiWw4bEiUMFwXwGyQbDg0SJhwM7w4NJAQPFQKtFR0PDf3JAiMUHR0V/VMVDw8bAjf93xQPDwAAAAIAQv/yAhwDBwAeADkAADYmPQE0PgE3Njc2MzIXFhceAR0BFAYHBgcGIyInJicSBh0BFBYXFhcWMjc2Nz4BNTQmJyYnJiIHBgdkIhEmHRsoJy81LS4eHiEhHR4uLTY1LS4eLBESEREdHkgeHREREhERER0eSh8dEKuLRwM2bWcnJxcYIiE4OItJA0eLOjkjIyMjOQGdYSwELmItLx4fHx4vLWMtMWQtLR0dHh4vAAAAAgBb//UCHwL8ABUAHwAANyY1ETQ3NjsBMhcWFRQHBisBERQGIhMVMzI3NTQnJiNpDg0NE6hoQ0QmPYx7GyQ/e5AFKSdFBA8VAqEVDw85OWxRNVj+6BYdAqP1dAdEGxsAAgBB//UCHwMIACMAQwAANyY9ATQ3Njc2OwEyFxYXHgEVFA8BFxYVFAYjIi8BBwYjIicmEgYdARAzMj8BJyY1NDc2MzIfATc2NTQnJicmIyIHBgdfHh4ZMzFBCDYrKxsbHTACQwocEhYKOAQ1Oz03OTIMhSAeBGAKDQwRFwpRAxQPDyEiLiUbGw3DUYMDgk1BLy8fHzU1gUeMZAJfDxEUHg5SBC4uLwGzTS0D/tgZA4sPEBQPDw52CkFLRjs8KSkWFSUAAAIAZ//1AggC+AAkADEAABYmNRE0NzY7ARYXFhcWFxYHBgcGDwETFhUUBwYjIicDIxEUBwYTFTcyNzY3NjU0JyYjghsNDROfKiMkHx4REQEBICFCBYoFDg0SFgueWw4NG242GhoKCiUiOAsdFQKeFg8OAQoLFRUnJjRfOjobAv77ChEUDw8NAT7+6BUPDwKk9QIaGRwcLDAWFgAAAAEAYf/wAf0DBwBRAAA3Jic1NDYzMhYXFhcWMzI3NjU0JyYnLgEnLgInJicmJyYnJjU0NzY3MzIXFhcWFRQHBiInJicmJyYjIgcGFRQXFhcWFx4BFx4CFRQGBwYjIqU6ChsSERoCBiEfKTAlJAcHDg0WEw45IhoaDxAQDwgHPDxPBkcyNBECDQ0mCwwJCgobMC0jJBUTJBAjIyceHSEXZksSEkkiMk0IFB0YEi0YGCAcOxgUEw4OEQoIHxUQERARFxcdHCNSNTYCJydDCAQUDw4NDhUYChoZGSotGBgUCxITFxcWLUQpVXQOAwAAAQA///UCHwL4ABgAABMmNDc2MyEyFxYUBwYrAREUBwYiJjURIyJNDg0NEwGGEw0NDg0SmA0NIhqYEgKiDyoPDg8PKQ8P/ZQUDw8dFQJsAAABAE3/8gIRAwgAIAAANyY1ETQ2MhYVERQXFjMyNzY1ETQ2MhYVERQHBgcGIicmZRgbJBsyHzc+JCYbJBsYGCw1ojUscDY9AfMVHR0V/g1RJhcmJkEB8xUdHRX+Dj02NiAoKCAAAQA+//UCIAMGABgAADcDNDc2MzIWFxsBPgEzMhcWFQMOASsBIibjpQ4OEg8ZA5iXBhcPEg4OpwMYDkIOGhkCvBQODxUO/YACgA8UDw8T/UQPFRYAAQA///QCHwMFAC8AADcmAzU0NjIXFhcSHwE3NjsBMhcWHwE3NhM0NjMyFh0BAgMOAQcjIi8BBwYrASInJn4xDhskDQ0BCxgDPwsdEQ4LDAQ+AxkKHBIRHA4yAxkQBTQNPj8KIBsRDAwb9AHFAhQbDg8U/r+4GfUhCgsO6xjBATEUHR0TAv5G/wAOFgEw6/giCwsAAAEAU//1AgsDBgAlAAAWJj0BNDcTAyY1NDYzMhcbATYzMhcWFRQHAxMWFRQGIyInCwEGI24bBaCaBRsSFAyJgRMVEg0OBZqgBRsSFQ2NhxIWCx0VAQ8KAUYBMgwOFh0N/u0BBRsPDxUODP7O/roKDxUdDQEj/ukaAAEAVv/0AggC+QAeAAATJjU0NjMyFxsBMz4BMzIXFhUUBxUDERQGIiY1EQMwWwUbEhkPhIQBAxgMEg0OBakaIhqpArAIDxUdG/7rARULEA8PFA8IAf6l/tEUHR0UAS8BWwAAAAABAFsABgICAv4AHgAANyY1NDcBIyInJjQ3NjMhMhcWFRQHASEyFxYUBiMhImkOBQEL4BINDg0NEwEoEg0OBf73AQMTDQ0bEv6zEhUPFA4KAkkPDykPDw8QFA0K/bcPDyodAAAAAQCl//gCHQMAABUAADcRNDYzITIWFAYrAREzMhYUBiMhIialGxIBHhIbGhPx8RIbGxL+4hIbJQKuEhsbJBv9rBskGxsAAAAAAQCA//gB8gMAABQAABM0NjMyFhcBMDMWFRQGIyInATAjJoAbEgwZBAEYAQMbEh4L/ugBAwLTExoQDP1SBwoSGxwCrgcAAAAAAQBV//gBzQMAABUAADY0NjsBESMiJjQ2MyEyFhURFAYjISJVGxLx8RMaGxIBHhIbGxL+4hITJBsCVBskGxsS/VISGwABAEQBdAIuAvsAGAAAEzU0NxM2NzIXEzAxFhUUBiMiLwEHBiMiJkQHzg8QGAnNCBsSEw2pqAwTEhsBoQoOCwErCgEM/swLDhIbDbKyDRoAAAEARP8ZAi7/kAAPAAAXNDYzITIWHQEUBiMhIiY1RBsSAZASGxsS/nASG50TGhsSHRIbGhMAAAAAAQC2AgcBuQMAABIAAAEnJjU0PwE2MzIfAhYUBwYjIgFvqRALDw0XDgoDnwsLDRURAhGODRUQDRIQCQKmDh4NDwAAAAACAE3/7wH6AiAADQA/AAAlIhUUFxYXMzI/ATUjJgcmNTQ3Njc2NzY3PgE7AScmJyYjIgcGIyImNTQ3NjMyFxYVERQGIiY9AQcGIyIjJiMmAVixHRodCFZGAQUr7zQNDBkaHR0pKUQyBgEGGRo5PC4MEBMaEU9TWzU8GyQbCERPAgYFBD/3YCEVFQJ6ATAC1C9FKh8fExMMDQYGBAY/GRonCRoTFg06MjpY/sUSHBoTEwc9AQUAAAAAAgBK//ACHwMFAB4AMgAAFiY1ETQ2MhYdATc2MzIXHgEXFRQHBiMiJyYvARUUBjcVFhcWMzI3Nj0BJicmIyIHBg8BZRsbJBsIQkoYIE9fATo5aBEIRDsIGxsUKysxJSFAAiUlNxsdQCUBDRsTArcSGxoT+QY2CBV/XweBVVMBBzAGDhMa0gExJSUXLYgJQDIzDh9NAQAAAAABAHX/7gHwAhoAKgAANyY1NDc2MzIXFhcWFxUUBiMiJyYjIgcGFRQzMjc2Nz4BMzIWHQEGBwYjIuVwNTVjExQwIyMLGRMfDAw+JRg9bBIPMQsDGRASGg4yNDwwBz7NeElHAwYbGyoLExokIw0fgsoEDCsOFRsSCzckJQAAAgA///ECEwMFAB4AMQAANyY1NDc2NzYzMh8BNTQ2MhYVERQGIiYvAQcGIyInJhMGFRQXFjMyNzY3PQImJyYjImwtLy5RHBhKRggbJBsbJBoBAQc/TxocVUA/IiI9HB5MGRUpKTAoVEpvZkVEFwg1BvgSGxoT/UkUGhoRCgYxBhQBnCxuTzs8DiBQAYUBLyMjAAAAAAIATf/xAhECIAAkAC0AADcmNTQ3NjczMhcWFRQGIyEXFhcWMzI3Njc2MzIWFRQHBiMiJyYTByEnJicmIyJ2KT49ZgZoOjsbEv7EAQclJEMREh4UDBITGy0tPzMmTA8CAQQBCxwcPGNgSmhzTUwCR0dzEhwGSyssAwQVDRoTKxQVDRoBOgcGPBwdAAAAAQBh//MB/QMCACMAABImNDY7ATU0MzIWFAYjIgcGBwYdATMyFhQGKwETFAYiJjUDI3saGxJxzhIbGxIsICAJBHwSGxsSfAYaIhoFcQG7GyQbDt8bJBsPECINNw4bJBv+ZhIcGxMBmgACAEL/QgIGAhsANABJAAA3JjU0NzYzMhcWHwE3PgEzMhYVERUWHQEUBwYjIicmJyMmNTQ2MzIXFhcWMzI3Nj0BBwYjIhMGFRQXFjMyNjc2NzY/AT0BJicjIns5OjlmDwg/MgcBARsREhsBOzxhTjAwFQEDGxIUEBEKFkVbGAoIPlJfCCAfHjocMRISDAsPAStVDUJbR2t4S0sBBikGChEYGxP+UQEJDBdeNzcTEzEHCxMaFRgFCjgXLDsHNwF8L09CLC0UFBMQEBkCVgF3BgAAAQBq//MB9AMFACkAABYmNRE0NjIWHQE3NjMyFxYXFh0BFAYiJjURNCc0Jy4CIyIHBg8BERQGhRsbJBsIOUo4KioPChskGwEEBBAdFTEgHxoBGw0aFAK3ExobEvUHMSMjNyVb/RIcHBIBCxsRERUXGRMhHzMB/tQSHAAAAAIAg//zAZQDBQAQACAAABImNDY7ATIWFREUBiImNREjNiY9ATQ2OwEyFh0BFAYrAZ4bGhO0ExobJBuHeBsbEi0SGxsSLQGoGyQbGhP+SxMaGxIBiNUaEy4TGhoTLhMaAAIAZ/9JAZQDBAAPADQAAAAmPQE0NjsBMhYdARQGKwEDIj0BNDc2MzIXFjMyNzY3NjURIyImNDY7ATIWFREUBwYHBgcGASgbGxItEhsbEi10Xw4PFQQQEAoICD0UCmUSGxoTkhMaERMdHSciAnwaEy4TGhoTLhMa/M0uCREKCwECAQQtFkkBdBskGxsS/lJVJCUbGgYFAAAAAQB7//MCBQMFACEAABYmNRE0NjIWFREzNzM2MzIWFRQPARcWFRQGIyIvASMVFAaWGxskGwq7AQ0REhsOqssMGxIVC9kKGw0aFAK3ExobEv6Asg4cEhQNpOUOERIcDfTUEhsAAAEAy//5AfADBQAYAAA3JjUTNDYzMhYVAxQXFhcWMzIWFAYjIicm9CkGGhMSGwcQES8PQBIbGxJTMC48N28B9RMbGxP+Cj8iJAcCGyQbDQ4AAQA///MCHwIbADIAABYmNRE0NjMyHwE3NjMyHwE3NjMyFhURFAYiJjURJiMiBwYVERQGIiY1ESYjIgcGFREUBlobGxIXDgMEIig4JAMEKTQ2RxskGwIhHxUUGiIaAiAgFRQbDRsTAckTGxUEAxktBQUtTzX+ihIcGxMBbzEvLif+5BIcGxMBbzEwLib+5BIcAAAAAAEATf/zAhECGwAjAAAWJjURNDYyFh0BNzYzMhcWHQEUBiImNRE0JyYjIgcGBxURFAZoGxskGwhDWGUxMRskGxcXPzsoKBgbDRwSAckSGxoSFAc9Q0N3/RIcGxMA/08oKiopOwH+7xIcAAAAAAIAP//wAh8CIAAPABsAADcmNTQ3NjMyFxYVFAcGIyIDBhQXFjI3NjQnJiKAQUFAb2xCQkJBbW4BJycmkiYnJyeQPk96e09PT1B6eU9PAaA2pjU1NTWmNjYAAAAAAgBK/0gCHwIbABUAMwAANxcWMzI3NjU0JyYjIgciIzEGBwYHFQImNRE0NjIWHQE3NjMyFxYXFhUUBwYrASYvARUUBqQBPlQPFWohIUQDBAMDLyUlFUAaGyQbCD5LGSFWLS09PGkRRjoIGssBgAUdlVQ2NwEDJCMvAf4BGxICdRMbGhMLBzQIFkZHb3dNTQQxB7cTGgAAAAACAD//SAITAhsAHAAvAAA3JjU0NzYzMh8BNTQ2MhYVERQGIiY9AQcGIyInJhMGFRQXFjMyNzY3PQImJyYjIm0uryEZSz4IGyQbGiYaCD5OHBtTPT8jIzwZIEIjFygpMSNQRmvmLAg0BwsSGxsT/YsTGhsStgc0BxMBoCiBSzY4DR1VAX0BMiQlAAAAAAEAmv/zAg4CGwAnAAAWJjURNDYzMhYdATc2MzIWFxQGIiYnNCcjIicmIgcGKwEGBwYdARQGtRsbEhMaCDdPPE8BGyQaASMBAgQFBwcGAwE3ICIbDRwSAckSGxkTCwc0TTgTGxoSIggBAgIBCTg3QOUTGwAAAQBn//AB/QIgAFEAADcmNTQ2MzIXFhcWMzI3NjU0JyYnJicuAicuAScmJyYnJjU0NzY7ARYXFhcWFRQGIyImJyYnIyIHBgcGFRQXFhceARcWFxYXFhcWFRQHBgcjImwFGxITEhUJITIwIyYPDgwKFgs5GhkaGRISCQgHBzg4Uh02LC0MAhsSEBkDCEAZGxMUEhQ+Dx8gIhwdDxAREQcHOjxYCYVFCA8TGhUYBBESEyYTDg0EBQYDDwgJCQ8ODg8OFhUZTiUmAxsbLwkDEhsTDiIEAwIODxswEgQHCAsKCQwLEREWFx1SJygCAAABAE3/8wHjAqYAMQAAEiY0NjsBNzQ2MhYVBzMyFhQGKwEHFBUWFx4COwEyNzYzMhYVFAcGIyInJicmPQE3I2gbGxJSARkkGAKWEhsbEpcDAQMEDRsUAhAcGw0SGyMlNCofLxQUA1ABshslG2wUGRsSbBwkHO0aDQwTExENCgobEiAQEQwTLi9MDOsAAAEATf/wAhECGAAoAAA3Jj0BNDYzMhYdARQXFhczMjc2NzERNDYyFhURFAYiJj0BBwYrASYnJlcKGxESHBUVQwU7KCYVGyQbGyQbCEFYBEgwMYEmS/gSHBwS6lwrLQIsKz8BChMbHBL+NxIcGhMSBzsBJyYAAQBC//MCHAIYAB0AABMmNTQ2MzIXEzMTMDU+ATMyFhUUBzEDDgErASImJ0UDGxIfC5EKkQMZDhIbA54DGQ1GDhcEAdsGCRMbH/5eAaIBDBIcEgkG/jYMEhENAAABAEH/8wIeAhgAKAAANwM0NzYzMhYXEzc+ATsBMh8BEz4BMzIXFh0BAw4BKwEiLwEHBisBIiZ4Nw4OEhEZAiorAxcPLCAKKikDGRESDg44AhkRMCAJMTELHTERGhsBzxMNDhcR/qSWDRMglgFcEBgNDRAE/jEQGB+wryAYAAAAAAEAYf/zAf0CGAAjAAAWJjU0PwEnJjU0NjMyHwE3NjMyFhUUDwEXFhUUBiMiLwEHBiN8GwiMgQcbEhcJdXUNExIbB4KMCRsSGAmAgQwUDRwSDg3OxgwOExsMtbUMHBIODMbODg0SHAy/vwwAAAEAP/9JAh8CGAAjAAAWJjU0NjsBMj8BAyY1NDYzMhcbATYzMhYVFAcBMDEGBwYjIidTFBsSEBYHa78GGxITDaicDhQSGwX+zQ0dHSMNDrEZEBMaEMsBVAkNExsM/tcBKQwbEw0K/bccEhMDAAEAYQAEAgUCBwAcAAA2Jj0BNDcBIyImNDYzITIWHQEUBxUBITIWFAYjIXsaDAEU6hIbGhMBKhMaDf7zAQQSGxoT/rYEGxIjDw4BPBomGhoTKBEMAf7KGyQbAAAAAQBE//gCLgMAADQAABI0NjMyNzY9ATQ3Njc2MzIWFAYrASIHBgcGFRQPARcWFRQXFhcWMzIWFAYjIicmNTQnJiMiRBsSVhcRJiE0NmESGxoTIjUdHxEUMQUEMgcIGhd4EhsbEpAtVRYYUBMBaCYbGxQ9CmM1Lg0OGyQbBgYYGkl7JQMFMWE3Hh8RDhskGxsznzsXGAAAAAABAQz/ZAFmAwAACwAABRE0NjIWFREUBiImAQwbJBsaJhpvA0ITGhsS/L4SGxoAAAABAET/+AIuAwAAMwAANjQ2OwEyNzY3NjU0PwEnJjU0JyYnJiMiJjQ2MzIXFhcWFRQXFjsBMhYUBiMiBhUUBwYjIkQbEiE9HyIOCjIEBTENDScVYRMaGxJhNjQhJRIXUgQSGxsSUC9UK5ISEiYaCQkgGUhhMQUDJXs1HyELBxomGg4NLjNlRhUbHCQaLzufMxsAAAAAAQBSAhwCIALNACsAABM1Njc2MzIzFjMWFxYzMjc+ATMyFhUUBxUOASMiIyYjJicmIyIHMQ4BIyImUgonJzACBQQDLj4rICAIAxoPEhsCCkwwAgUEAy4+KiAgCQMZEBIbAlUKMB8fAQUvIicPFRsSAwUBMD8BBDAhJg8VGwAAAAABAnIB9QLWAq8ACwAAATU0NjIWHQEUBiImAnIeKB4eKB4CJ1YVHR4UVhQeHQAAAAABAgYB9QKgAq8ADwAAATQ2MzIfARYVFAYjIi8BJgIGHhQbCTwIHhQTET0HAn0VHQ5fDQ4UHg9eCwAAAAACAbYCVALWAwIACwAXAAABNTQ2MhYdARQGIiY3NTQ2MhYdARQGIiYBth4oHh0qHbweKB4dKh0ChkoVHR4UShQeHRVKFB4eFEoUHh4AAQAO/4cAcgK1AAsAABcRNDYyFhURFAYiJg4eKB4dKh1HAsoUHh4U/TYUHh4AAAAAAAAOAK4AAQAAAAAAAABDAIgAAQAAAAAAAQAEANYAAQAAAAAAAgAHAOsAAQAAAAAAAwApAUcAAQAAAAAABAANAY0AAQAAAAAABQAKAbEAAQAAAAAABgAEAcYAAwABBAkAAACGAAAAAwABBAkAAQAIAMwAAwABBAkAAgAOANsAAwABBAkAAwBSAPMAAwABBAkABAAaAXEAAwABBAkABQAUAZsAAwABBAkABgAIAbwATQBhAHQAdABoAGUAdwAgAFMAawBhAGwAYQAgACgAMgAwADEAMQApADsAIABiAGEAcwBlAGQAIABvAG4AIABjAG8AZABlACAAYgB5ACAATgBvAHIAYgBlAHIAdAAgAFMAYwBoAHcAYQByAHoAIAAoADEAOQA4ADYALAAgADIAMAAxADEAKQAATWF0dGhldyBTa2FsYSAoMjAxMSk7IGJhc2VkIG9uIGNvZGUgYnkgTm9yYmVydCBTY2h3YXJ6ICgxOTg2LCAyMDExKQAATwBDAFIAQgAAT0NSQgAAUgBlAGcAdQBsAGEAcgAAUmVndWxhcgAARgBvAG4AdABGAG8AcgBnAGUAIAAyAC4AMAAgADoAIABPAEMAUgAgAEIAIABSAGUAZwB1AGwAYQByACAAOgAgADIANwAtADkALQAyADAAMQAyAABGb250Rm9yZ2UgMi4wIDogT0NSIEIgUmVndWxhciA6IDI3LTktMjAxMgAATwBDAFIAIABCACAAUgBlAGcAdQBsAGEAcgAAT0NSIEIgUmVndWxhcgAAVgBlAHIAcwBpAG8AbgAgADIAIAAAVmVyc2lvbiAyIAAATwBDAFIAQgAAT0NSQgAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABmAAAAAQACAAMABAAFAAYABwAIAAkAtwALAAwADQAOAA8AEAARABIAEwAUABUAFgAXABgAGQAaABsAHAAdAB4AHwAgACEAIgAjACQAJQAmACcAKAApACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA7ADwAPQA+AD8AQABBAEIAtgBEAEUARgBHAEgASQBKAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAWwBcAF0AXgBfAGAAYQECAQMBBAEFD3F1b3Rlc2luZ2xlLmFsdAlncmF2ZS5hbHQMcXVvdGVkYmwuYWx0B2Jhci5hbHQAAAAAAAAB//8AAgABAAAADgAAABgAAAAAAAIAAQABAGUAAQAEAAAAAgAAAAEAAAAKAEAAjgACREZMVAAObGF0bgAiAAQAAAAA//8ABQAAAAEAAgADAAQABAAAAAD//wAFAAAAAQACAAMABAAFYWFsdAAgc3MwMQAmc3MwMgAsc3MwMwAyc3MwNAA4AAAAAQAAABgAAQABABYAAQACABQAAQADABIAAQAEAAABAAAAAQEAAAECAAABAwAFAAwAFAAcACQALAADAAAAAQAoAAEAAAABAFIAAQAAAAEAVgABAAAAAQBaAAEAAAABAF4AAQAmAAQADgAUABoAIAACAAUAZAACAAoAYgACAEMAYwACAF8AZQABAAQABQAKAEMAXwABAAYAIAABAAEAQwABAAYAXwABAAEABQABAAYAWAABAAEACgABAAYABgABAAEAXwABAAAACgAsAC4AAkRGTFQADmxhdG4AGAAEAAAAAP//AAAABAAAAAD//wAAAAAAAAAAAAEAAAAAzD2izwAAAADWBtqRAAAAANoDIf0=");
const bwipjs = {
  request: Request,
  toBuffer: ToBuffer,
  toSVG: ToSVG,
  render: Render,
  raw: ToRaw,
  drawingZlibPng: DrawingZlibPng,
  drawingSVG: DrawingSVG,
  fixupOptions: FixupOptions,
  loadFont: LoadFont,
  FontLib,
  BWIPJS_VERSION,
  BWIPP_VERSION
};
escpos.USB = USB;
const getUSBPrinters = () => {
  try {
    const devices = USB.findPrinter();
    return devices.map((d) => ({
      name: `USB Printer (VID:${d.deviceDescriptor.idVendor.toString(16)} PID:${d.deviceDescriptor.idProduct.toString(16)})`,
      displayName: "USB Thermal Printer",
      description: "Direct USB Connection",
      deviceDescriptor: {
        idVendor: d.deviceDescriptor.idVendor,
        idProduct: d.deviceDescriptor.idProduct
      },
      isUSB: true
    }));
  } catch (error2) {
    console.error("Error finding USB printers:", error2);
    return [];
  }
};
const getSystemPrinters = async () => {
  try {
    const win = BrowserWindow.getAllWindows()[0];
    if (!win) return [];
    const printers = await win.webContents.getPrintersAsync();
    return printers.map((p) => ({
      name: p.name,
      displayName: p.displayName,
      description: p.description,
      status: p.status,
      isDefault: p.isDefault,
      isSystem: true
    }));
  } catch (error2) {
    console.error("Error getting system printers:", error2);
    return [];
  }
};
const getAllPrinters = async () => {
  const [usbPrinters, systemPrinters] = await Promise.all([
    Promise.resolve(getUSBPrinters()),
    getSystemPrinters()
  ]);
  return [...usbPrinters, ...systemPrinters];
};
const generateBarcodeBase64 = async (text) => {
  return new Promise((resolve, reject) => {
    bwipjs.toBuffer({
      bcid: "code128",
      text,
      scale: 3,
      height: 10,
      includetext: true,
      textxalign: "center"
    }, (err, png2) => {
      if (err) {
        reject(err);
      } else {
        resolve(`data:image/png;base64,${png2.toString("base64")}`);
      }
    });
  });
};
const generateReceiptHTML = async (sale, settings) => {
  const is58mm = settings.printer_paper_width === "58mm";
  const width = is58mm ? "48mm" : "72mm";
  const barcode = await generateBarcodeBase64(sale.receipt_number);
  const total = (sale.total_amount || sale.total || 0) / 100;
  const currencySymbol = settings.currency_symbol || "GHâ‚µ";
  const timestamp = sale.created_at || sale.timestamp || (/* @__PURE__ */ new Date()).toISOString();
  return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    @page {
      size: ${settings.printer_paper_width} auto;
      margin: 0;
    }
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      width: ${width};
      font-size: 9pt;
      line-height: 1.3;
      padding: 2mm;
    }
    .center { text-align: center; }
    .right { text-align: right; }
    .bold { font-weight: bold; }
    .divider {
      border-top: 1px dashed #000;
      margin: 2mm 0;
    }
    table {
      width: 100%;
      border-collapse: collapse;
    }
    td {
      padding: 1px 0;
      vertical-align: top;
    }
    .header {
      margin-bottom: 2mm;
    }
    .header h1 {
      font-size: 12pt;
      margin-bottom: 1mm;
    }
    .item-name {
      font-weight: bold;
      font-size: 9pt;
    }
    .item-details {
      font-size: 8pt;
      color: #333;
    }
    .total-section {
      margin-top: 2mm;
      font-size: 10pt;
    }
    img {
      max-width: 100%;
      height: auto;
    }
  </style>
</head>
<body>
  <div class="header center">
    <h1>${settings.store_name}</h1>
    ${settings.store_address ? `<div>${settings.store_address}</div>` : ""}
    ${settings.store_phone ? `<div>${settings.store_phone}</div>` : ""}
  </div>
  
  <div class="divider"></div>
  
  <table>
    <tr>
      <td>Date:</td>
      <td class="right">${new Date(timestamp).toLocaleDateString()}</td>
    </tr>
    <tr>
      <td>Time:</td>
      <td class="right">${new Date(timestamp).toLocaleTimeString()}</td>
    </tr>
    <tr>
      <td colspan="2">Receipt: ${sale.receipt_number}</td>
    </tr>
    ${sale.customer_name ? `<tr><td colspan="2">Customer: ${sale.customer_name}</td></tr>` : ""}
  </table>
  
  <div class="divider"></div>
  
  <table>
    ${sale.items.map((item) => {
    const qty = item.quantity || item.qty || 0;
    const price = (item.price_at_sale || item.price || 0) / 100;
    const total2 = (price * qty).toFixed(2);
    const variant = item.size && item.color ? ` (${item.size}/${item.color})` : "";
    return `
        <tr>
          <td colspan="2" class="item-name">${item.name}${variant}</td>
        </tr>
        <tr class="item-details">
          <td>${qty} Ã— ${currencySymbol}${price.toFixed(2)}</td>
          <td class="right">${currencySymbol}${total2}</td>
        </tr>
      `;
  }).join("")}
  </table>
  
  <div class="divider"></div>
  
  <table class="total-section">
    <tr class="bold">
      <td>TOTAL</td>
      <td class="right">${currencySymbol}${total.toFixed(2)}</td>
    </tr>
    <tr>
      <td>Payment</td>
      <td class="right">${sale.payment_method.toUpperCase()}</td>
    </tr>
  </table>
  
  <div class="divider"></div>
  
  <div class="center">
    <img src="${barcode}" alt="Barcode" />
  </div>
  
  ${settings.receipt_footer ? `
    <div class="divider"></div>
    <div class="center" style="font-size: 8pt;">${settings.receipt_footer}</div>
  ` : ""}
  
  <div class="center" style="margin-top: 3mm; font-size: 8pt;">
    Thank you for your purchase!
  </div>
</body>
</html>
  `;
};
const printViaWebContents = async (html, printerName, settings) => {
  const is58mm = settings.printer_paper_width === "58mm";
  const widthMicrons = is58mm ? 58e3 : 8e4;
  const heightMicrons = 3e5;
  return new Promise((resolve, reject) => {
    const workerWindow = new BrowserWindow({
      show: false,
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true
      }
    });
    workerWindow.loadURL("data:text/html;charset=utf-8," + encodeURIComponent(html));
    workerWindow.webContents.on("did-finish-load", () => {
      setTimeout(() => {
        workerWindow.webContents.print({
          silent: true,
          printBackground: true,
          deviceName: printerName || void 0,
          margins: { marginType: "none" },
          pageSize: {
            width: widthMicrons,
            height: heightMicrons
          }
        }, (success, errorType) => {
          workerWindow.close();
          if (!success) {
            reject(new Error(`Print failed: ${errorType}`));
          } else {
            resolve(true);
          }
        });
      }, 500);
    });
    workerWindow.webContents.on("did-fail-load", () => {
      workerWindow.close();
      reject(new Error("Failed to load print content"));
    });
  });
};
const printViaUSB = async (sale, settings) => {
  return new Promise((resolve, reject) => {
    try {
      const device2 = new USB();
      const printer = new escpos.Printer(device2);
      const is58mm = settings.printer_paper_width === "58mm";
      const width = is58mm ? 32 : 48;
      const currencySymbol = settings.currency_symbol || "GHâ‚µ";
      const timestamp = sale.created_at || sale.timestamp || (/* @__PURE__ */ new Date()).toISOString();
      const total = (sale.total_amount || sale.total || 0) / 100;
      const twoColumns = (left, right) => {
        const spaceNeeded = width - left.length - right.length;
        if (spaceNeeded < 1) {
          const availableForLeft = width - right.length - 1;
          return left.substring(0, availableForLeft) + " " + right;
        }
        return left + " ".repeat(spaceNeeded) + right;
      };
      device2.open((error2) => {
        if (error2) {
          reject(error2);
          return;
        }
        setTimeout(() => {
          try {
            printer.hardware("INIT");
            printer.align("CT");
            printer.size(1, 1).text(settings.store_name).size(0, 0);
            if (settings.store_address) printer.text(settings.store_address);
            if (settings.store_phone) printer.text(settings.store_phone);
            printer.text("-".repeat(width));
            printer.align("LT");
            printer.text(`Receipt: ${sale.receipt_number}`);
            printer.text(new Date(timestamp).toLocaleString());
            if (sale.customer_name) printer.text(`Customer: ${sale.customer_name}`);
            printer.text("-".repeat(width));
            sale.items.forEach((item) => {
              const qty = item.quantity || item.qty || 0;
              const price = (item.price_at_sale || item.price || 0) / 100;
              const itemTotal = (price * qty).toFixed(2);
              const variant = item.size && item.color ? ` (${item.size}/${item.color})` : "";
              printer.text(item.name + variant);
              const detailLine = twoColumns(
                `${qty} x ${currencySymbol}${price.toFixed(2)}`,
                `${currencySymbol}${itemTotal}`
              );
              printer.text(detailLine);
              printer.control("LF");
            });
            printer.text("-".repeat(width));
            printer.align("RT");
            printer.size(1, 1);
            printer.text(`TOTAL: ${currencySymbol}${total.toFixed(2)}`);
            printer.size(0, 0);
            printer.text(`Payment: ${sale.payment_method.toUpperCase()}`);
            printer.text("-".repeat(width));
            printer.align("CT");
            printer.barcode(sale.receipt_number, "CODE128", { height: 50 });
            if (settings.receipt_footer) {
              printer.text(settings.receipt_footer);
            }
            printer.text("Thank you for your purchase!");
            printer.feed(4);
            printer.cut();
            printer.close(() => {
              resolve(true);
            });
          } catch (printError) {
            reject(printError);
          }
        }, 100);
      });
    } catch (error2) {
      reject(error2);
    }
  });
};
const printReceipt = async (sale, settings) => {
  try {
    if (settings.printer_type === "system") {
      const html = await generateReceiptHTML(sale, settings);
      return await printViaWebContents(html, settings.printer_device_name, settings);
    } else {
      return await printViaUSB(sale, settings);
    }
  } catch (error2) {
    console.error("Print error:", error2);
    throw error2;
  }
};
export {
  generateReceiptHTML,
  getAllPrinters,
  getSystemPrinters,
  getUSBPrinters,
  printReceipt,
  printViaUSB,
  printViaWebContents
};
